
==================== Output Cmm ====================
2018-03-16 16:07:35.706431366 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:35.707093827 UTC

[section ""cstring" . lvl_rcHpv_bytes" {
     lvl_rcHpv_bytes:
         I8[] [71,67,68,101,116,97,105,108,115,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.70769586 UTC

[section ""cstring" . lvl1_rcHpw_bytes" {
     lvl1_rcHpw_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,103,101,110,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.708300527 UTC

[section ""cstring" . lvl2_rcHpx_bytes" {
     lvl2_rcHpx_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,116,104,114,101,97,100,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.708904769 UTC

[section ""cstring" . lvl3_rcHpy_bytes" {
     lvl3_rcHpy_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,97,108,108,111,99,97,116,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.70951514 UTC

[section ""cstring" . lvl4_rcHpz_bytes" {
     lvl4_rcHpz_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,105,118,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.710111404 UTC

[section ""cstring" . lvl5_rcHpA_bytes" {
     lvl5_rcHpA_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.710746985 UTC

[section ""cstring" . lvl6_rcHpB_bytes" {
     lvl6_rcHpB_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,109,112,97,99,116,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.762503198 UTC

[section ""cstring" . lvl7_rcHpC_bytes" {
     lvl7_rcHpC_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,108,111,112,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.763083197 UTC

[section ""cstring" . lvl8_rcHpD_bytes" {
     lvl8_rcHpD_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.76363624 UTC

[section ""cstring" . lvl9_rcHpE_bytes" {
     lvl9_rcHpE_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.764104252 UTC

[section ""cstring" . lvl10_rcHpF_bytes" {
     lvl10_rcHpF_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.764607504 UTC

[section ""cstring" . lvl11_rcHpG_bytes" {
     lvl11_rcHpG_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.765119575 UTC

[section ""cstring" . lvl12_rcHpH_bytes" {
     lvl12_rcHpH_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,121,110,99,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.765663774 UTC

[section ""cstring" . lvl13_rcHpI_bytes" {
     lvl13_rcHpI_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.766221435 UTC

[section ""cstring" . lvl14_rcHpJ_bytes" {
     lvl14_rcHpJ_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.766784212 UTC

[section ""cstring" . lvl15_rcHpK_bytes" {
     lvl15_rcHpK_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.780633598 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_$cshowsPrec_closure" {
     GHC.Stats.$fShowGCDetails_$cshowsPrec_closure:
         const GHC.Stats.$fShowGCDetails_$cshowsPrec_info;
         const 0;
 },
 w1_scHss_entry() //  [R1]
         { info_tbl: [(ccHQL,
                       label: w1_scHss_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHQL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccHQM; else goto ccHQN;
       ccHQM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHQN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccHQI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucHQZ; else goto ccHQJ;
       ucHQZ: // global
           call _ccHQI(R1) args: 0, res: 0, upd: 0;
       ccHQJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHQI() //  [R1]
         { info_tbl: [(ccHQI,
                       label: block_ccHQI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHQI: // global
           _scHsu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsu::I64, 0)) goto ccHQX; else goto ccHQY;
       ccHQX: // global
           R2 = _scHsu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccHQY: // global
           R2 = _scHsu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w2_scHsx_entry() //  [R1]
         { info_tbl: [(ccHR7,
                       label: w2_scHsx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHR7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccHR8; else goto ccHR9;
       ccHR8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHR9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccHR4_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucHRl; else goto ccHR5;
       ucHRl: // global
           call _ccHR4(R1) args: 0, res: 0, upd: 0;
       ccHR5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHR4() //  [R1]
         { info_tbl: [(ccHR4,
                       label: block_ccHR4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHR4: // global
           _scHsz::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsz::I64, 0)) goto ccHRj; else goto ccHRk;
       ccHRj: // global
           R2 = _scHsz::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccHRk: // global
           R2 = _scHsz::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w3_scHsC_entry() //  [R1]
         { info_tbl: [(ccHRt,
                       label: w3_scHsC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHRt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccHRu; else goto ccHRv;
       ccHRu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHRv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccHRq_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucHRH; else goto ccHRr;
       ucHRH: // global
           call _ccHRq(R1) args: 0, res: 0, upd: 0;
       ccHRr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHRq() //  [R1]
         { info_tbl: [(ccHRq,
                       label: block_ccHRq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHRq: // global
           _scHsE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsE::I64, 0)) goto ccHRF; else goto ccHRG;
       ccHRF: // global
           R2 = _scHsE::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccHRG: // global
           R2 = _scHsE::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w4_scHsH_entry() //  [R1]
         { info_tbl: [(ccHRP,
                       label: w4_scHsH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHRP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccHRQ; else goto ccHRR;
       ccHRQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHRR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccHRM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucHS3; else goto ccHRN;
       ucHS3: // global
           call _ccHRM(R1) args: 0, res: 0, upd: 0;
       ccHRN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHRM() //  [R1]
         { info_tbl: [(ccHRM,
                       label: block_ccHRM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHRM: // global
           _scHsJ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsJ::I64, 0)) goto ccHS1; else goto ccHS2;
       ccHS1: // global
           R2 = _scHsJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccHS2: // global
           R2 = _scHsJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_scHsM_entry() //  [R1]
         { info_tbl: [(ccHSb,
                       label: w5_scHsM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHSb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccHSc; else goto ccHSd;
       ccHSc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHSd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccHS8_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucHSp; else goto ccHS9;
       ucHSp: // global
           call _ccHS8(R1) args: 0, res: 0, upd: 0;
       ccHS9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHS8() //  [R1]
         { info_tbl: [(ccHS8,
                       label: block_ccHS8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHS8: // global
           _scHsO::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsO::I64, 0)) goto ccHSn; else goto ccHSo;
       ccHSn: // global
           R2 = _scHsO::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccHSo: // global
           R2 = _scHsO::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_scHsR_entry() //  [R1]
         { info_tbl: [(ccHSx,
                       label: w6_scHsR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHSx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccHSy; else goto ccHSz;
       ccHSy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHSz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccHSu_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucHSL; else goto ccHSv;
       ucHSL: // global
           call _ccHSu(R1) args: 0, res: 0, upd: 0;
       ccHSv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHSu() //  [R1]
         { info_tbl: [(ccHSu,
                       label: block_ccHSu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHSu: // global
           _scHsT::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsT::I64, 0)) goto ccHSJ; else goto ccHSK;
       ccHSJ: // global
           R2 = _scHsT::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccHSK: // global
           R2 = _scHsT::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_scHsW_entry() //  [R1]
         { info_tbl: [(ccHST,
                       label: w7_scHsW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHST: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccHSU; else goto ccHSV;
       ccHSU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHSV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccHSQ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucHT7; else goto ccHSR;
       ucHT7: // global
           call _ccHSQ(R1) args: 0, res: 0, upd: 0;
       ccHSR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHSQ() //  [R1]
         { info_tbl: [(ccHSQ,
                       label: block_ccHSQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHSQ: // global
           _scHsY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsY::I64, 0)) goto ccHT5; else goto ccHT6;
       ccHT5: // global
           R2 = _scHsY::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccHT6: // global
           R2 = _scHsY::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w8_scHt1_entry() //  [R1]
         { info_tbl: [(ccHTf,
                       label: w8_scHt1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHTf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccHTg; else goto ccHTh;
       ccHTg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHTh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccHTc_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucHTt; else goto ccHTd;
       ucHTt: // global
           call _ccHTc(R1) args: 0, res: 0, upd: 0;
       ccHTd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHTc() //  [R1]
         { info_tbl: [(ccHTc,
                       label: block_ccHTc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHTc: // global
           _scHt3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHt3::I64, 0)) goto ccHTr; else goto ccHTs;
       ccHTr: // global
           R2 = _scHt3::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccHTs: // global
           R2 = _scHt3::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w9_scHt6_entry() //  [R1]
         { info_tbl: [(ccHTB,
                       label: w9_scHt6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHTB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccHTC; else goto ccHTD;
       ccHTC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHTD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccHTy_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucHTP; else goto ccHTz;
       ucHTP: // global
           call _ccHTy(R1) args: 0, res: 0, upd: 0;
       ccHTz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHTy() //  [R1]
         { info_tbl: [(ccHTy,
                       label: block_ccHTy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHTy: // global
           _scHt8::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHt8::I64, 0)) goto ccHTN; else goto ccHTO;
       ccHTN: // global
           R2 = _scHt8::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccHTO: // global
           R2 = _scHt8::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtp_entry() //  [R1]
         { info_tbl: [(ccHX2,
                       label: sat_scHtp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHX2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccHX3; else goto ccHX4;
       ccHX3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHX4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = lvl15_rcHpK_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtt_entry() //  [R1]
         { info_tbl: [(ccHX5,
                       label: sat_scHtt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHX5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccHX9; else goto ccHXa;
       ccHX9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHXa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccHWT_info;
           _scHtc::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucHXh; else goto ccHWU;
       ucHXh: // global
           call _ccHWT(R1) args: 0, res: 0, upd: 0;
       ccHWU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHWT() //  [R1]
         { info_tbl: [(ccHWT,
                       label: block_ccHWT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHWT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccHXd; else goto ccHXc;
       ccHXd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccHXc: // global
           _scHto::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_scHtp_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccHX6_info;
           R4 = Hp - 16;
           R3 = _scHto::I64;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccHX6() //  [R1, R2]
         { info_tbl: [(ccHX6,
                       label: block_ccHX6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHX6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccHXg; else goto ccHXf;
       ccHXg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccHXf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtu_entry() //  [R1]
         { info_tbl: [(ccHXi,
                       label: sat_scHtu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHXi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccHXm; else goto ccHXl;
       ccHXm: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHXl: // global
           _scHsp::P64 = P64[R1 + 16];
           _scHtc::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_scHtt_info;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 24;
           R2 = lvl14_rcHpJ_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtv_entry() //  [R1]
         { info_tbl: [(ccHXn,
                       label: sat_scHtv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHXn: // global
           _scHtv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccHXo; else goto ccHXp;
       ccHXp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccHXr; else goto ccHXq;
       ccHXr: // global
           HpAlloc = 32;
           goto ccHXo;
       ccHXo: // global
           R1 = _scHtv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHXq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtv::P64;
           _scHsp::P64 = P64[_scHtv::P64 + 16];
           _scHtc::P64 = P64[_scHtv::P64 + 24];
           I64[Hp - 24] = sat_scHtu_info;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtz_entry() //  [R1]
         { info_tbl: [(ccHXs,
                       label: sat_scHtz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHXs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccHXw; else goto ccHXx;
       ccHXw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHXx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccHWC_info;
           _scHsp::P64 = P64[R1 + 24];
           _scHtc::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _scHsp::P64;
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucHXE; else goto ccHWD;
       ucHXE: // global
           call _ccHWC(R1) args: 0, res: 0, upd: 0;
       ccHWD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHWC() //  [R1]
         { info_tbl: [(ccHWC,
                       label: block_ccHWC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHWC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccHXA; else goto ccHXz;
       ccHXA: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccHXz: // global
           _scHtm::I64 = I64[R1 + 7];
           I64[Hp - 24] = sat_scHtv_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_ccHXt_info;
           R4 = Hp - 24;
           R3 = _scHtm::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccHXt() //  [R1, R2]
         { info_tbl: [(ccHXt,
                       label: block_ccHXt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHXt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccHXD; else goto ccHXC;
       ccHXD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccHXC: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtA_entry() //  [R1]
         { info_tbl: [(ccHXF,
                       label: sat_scHtA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHXF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccHXJ; else goto ccHXI;
       ccHXJ: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHXI: // global
           _scHso::P64 = P64[R1 + 16];
           _scHsp::P64 = P64[R1 + 24];
           _scHtc::P64 = P64[R1 + 32];
           I64[Hp - 32] = sat_scHtz_info;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 32;
           R2 = lvl13_rcHpI_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtB_entry() //  [R1]
         { info_tbl: [(ccHXK,
                       label: sat_scHtB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHXK: // global
           _scHtB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccHXL; else goto ccHXM;
       ccHXM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccHXO; else goto ccHXN;
       ccHXO: // global
           HpAlloc = 40;
           goto ccHXL;
       ccHXL: // global
           R1 = _scHtB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHXN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtB::P64;
           _scHso::P64 = P64[_scHtB::P64 + 16];
           _scHsp::P64 = P64[_scHtB::P64 + 24];
           _scHtc::P64 = P64[_scHtB::P64 + 32];
           I64[Hp - 32] = sat_scHtA_info;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtF_entry() //  [R1]
         { info_tbl: [(ccHXP,
                       label: sat_scHtF_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHXP: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccHXT; else goto ccHXU;
       ccHXT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHXU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccHWl_info;
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHtc::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _scHso::P64;
           P64[Sp - 32] = _scHsp::P64;
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucHY1; else goto ccHWm;
       ucHY1: // global
           call _ccHWl(R1) args: 0, res: 0, upd: 0;
       ccHWm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHWl() //  [R1]
         { info_tbl: [(ccHWl,
                       label: block_ccHWl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHWl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccHXX; else goto ccHXW;
       ccHXX: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccHXW: // global
           _scHtk::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_scHtB_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_ccHXQ_info;
           R4 = Hp - 32;
           R3 = _scHtk::I64;
           R2 = 0;
           Sp = Sp + 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccHXQ() //  [R1, R2]
         { info_tbl: [(ccHXQ,
                       label: block_ccHXQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHXQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccHY0; else goto ccHXZ;
       ccHY0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccHXZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtG_entry() //  [R1]
         { info_tbl: [(ccHY2,
                       label: sat_scHtG_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHY2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccHY6; else goto ccHY5;
       ccHY6: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHY5: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHtc::P64 = P64[R1 + 40];
           I64[Hp - 40] = sat_scHtF_info;
           P64[Hp - 24] = _scHsn::P64;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 40;
           R2 = lvl12_rcHpH_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtH_entry() //  [R1]
         { info_tbl: [(ccHY7,
                       label: sat_scHtH_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHY7: // global
           _scHtH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccHY8; else goto ccHY9;
       ccHY9: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccHYb; else goto ccHYa;
       ccHYb: // global
           HpAlloc = 48;
           goto ccHY8;
       ccHY8: // global
           R1 = _scHtH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHYa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtH::P64;
           _scHsn::P64 = P64[_scHtH::P64 + 16];
           _scHso::P64 = P64[_scHtH::P64 + 24];
           _scHsp::P64 = P64[_scHtH::P64 + 32];
           _scHtc::P64 = P64[_scHtH::P64 + 40];
           I64[Hp - 40] = sat_scHtG_info;
           P64[Hp - 24] = _scHsn::P64;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 40;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtL_entry() //  [R1]
         { info_tbl: [(ccHYf,
                       label: sat_scHtL_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHYf: // global
           _scHtL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccHYg; else goto ccHYh;
       ccHYh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccHYj; else goto ccHYi;
       ccHYj: // global
           HpAlloc = 48;
           goto ccHYg;
       ccHYg: // global
           R1 = _scHtL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHYi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtL::P64;
           _scHsn::P64 = P64[_scHtL::P64 + 16];
           _scHso::P64 = P64[_scHtL::P64 + 24];
           _scHsp::P64 = P64[_scHtL::P64 + 32];
           _scHt6::P64 = P64[_scHtL::P64 + 40];
           _scHtc::P64 = P64[_scHtL::P64 + 48];
           I64[Hp - 40] = sat_scHtH_info;
           P64[Hp - 24] = _scHsn::P64;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccHYc_info;
           R4 = Hp - 40;
           R3 = _scHt6::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccHYc() //  [R1, R2]
         { info_tbl: [(ccHYc,
                       label: block_ccHYc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHYc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccHYm; else goto ccHYl;
       ccHYm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccHYl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtM_entry() //  [R1]
         { info_tbl: [(ccHYn,
                       label: sat_scHtM_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHYn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccHYr; else goto ccHYq;
       ccHYr: // global
           HpAlloc = 56;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHYq: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHt6::P64 = P64[R1 + 40];
           _scHtc::P64 = P64[R1 + 48];
           I64[Hp - 48] = sat_scHtL_info;
           P64[Hp - 32] = _scHsn::P64;
           P64[Hp - 24] = _scHso::P64;
           P64[Hp - 16] = _scHsp::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 48;
           R2 = lvl11_rcHpG_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtN_entry() //  [R1]
         { info_tbl: [(ccHYs,
                       label: sat_scHtN_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHYs: // global
           _scHtN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccHYt; else goto ccHYu;
       ccHYu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccHYw; else goto ccHYv;
       ccHYw: // global
           HpAlloc = 56;
           goto ccHYt;
       ccHYt: // global
           R1 = _scHtN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHYv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtN::P64;
           _scHsn::P64 = P64[_scHtN::P64 + 16];
           _scHso::P64 = P64[_scHtN::P64 + 24];
           _scHsp::P64 = P64[_scHtN::P64 + 32];
           _scHt6::P64 = P64[_scHtN::P64 + 40];
           _scHtc::P64 = P64[_scHtN::P64 + 48];
           I64[Hp - 48] = sat_scHtM_info;
           P64[Hp - 32] = _scHsn::P64;
           P64[Hp - 24] = _scHso::P64;
           P64[Hp - 16] = _scHsp::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 48;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtR_entry() //  [R1]
         { info_tbl: [(ccHYA,
                       label: sat_scHtR_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHYA: // global
           _scHtR::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccHYB; else goto ccHYC;
       ccHYC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccHYE; else goto ccHYD;
       ccHYE: // global
           HpAlloc = 56;
           goto ccHYB;
       ccHYB: // global
           R1 = _scHtR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHYD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtR::P64;
           _scHsn::P64 = P64[_scHtR::P64 + 16];
           _scHso::P64 = P64[_scHtR::P64 + 24];
           _scHsp::P64 = P64[_scHtR::P64 + 32];
           _scHt1::P64 = P64[_scHtR::P64 + 40];
           _scHt6::P64 = P64[_scHtR::P64 + 48];
           _scHtc::P64 = P64[_scHtR::P64 + 56];
           I64[Hp - 48] = sat_scHtN_info;
           P64[Hp - 32] = _scHsn::P64;
           P64[Hp - 24] = _scHso::P64;
           P64[Hp - 16] = _scHsp::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccHYx_info;
           R4 = Hp - 48;
           R3 = _scHt1::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccHYx() //  [R1, R2]
         { info_tbl: [(ccHYx,
                       label: block_ccHYx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHYx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccHYH; else goto ccHYG;
       ccHYH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccHYG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtS_entry() //  [R1]
         { info_tbl: [(ccHYI,
                       label: sat_scHtS_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHYI: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccHYM; else goto ccHYL;
       ccHYM: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHYL: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHt1::P64 = P64[R1 + 40];
           _scHt6::P64 = P64[R1 + 48];
           _scHtc::P64 = P64[R1 + 56];
           I64[Hp - 56] = sat_scHtR_info;
           P64[Hp - 40] = _scHsn::P64;
           P64[Hp - 32] = _scHso::P64;
           P64[Hp - 24] = _scHsp::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 56;
           R2 = lvl10_rcHpF_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtT_entry() //  [R1]
         { info_tbl: [(ccHYN,
                       label: sat_scHtT_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHYN: // global
           _scHtT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccHYO; else goto ccHYP;
       ccHYP: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccHYR; else goto ccHYQ;
       ccHYR: // global
           HpAlloc = 64;
           goto ccHYO;
       ccHYO: // global
           R1 = _scHtT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHYQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtT::P64;
           _scHsn::P64 = P64[_scHtT::P64 + 16];
           _scHso::P64 = P64[_scHtT::P64 + 24];
           _scHsp::P64 = P64[_scHtT::P64 + 32];
           _scHt1::P64 = P64[_scHtT::P64 + 40];
           _scHt6::P64 = P64[_scHtT::P64 + 48];
           _scHtc::P64 = P64[_scHtT::P64 + 56];
           I64[Hp - 56] = sat_scHtS_info;
           P64[Hp - 40] = _scHsn::P64;
           P64[Hp - 32] = _scHso::P64;
           P64[Hp - 24] = _scHsp::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 56;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtX_entry() //  [R1]
         { info_tbl: [(ccHYV,
                       label: sat_scHtX_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHYV: // global
           _scHtX::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccHYW; else goto ccHYX;
       ccHYX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccHYZ; else goto ccHYY;
       ccHYZ: // global
           HpAlloc = 64;
           goto ccHYW;
       ccHYW: // global
           R1 = _scHtX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHYY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtX::P64;
           _scHsn::P64 = P64[_scHtX::P64 + 16];
           _scHso::P64 = P64[_scHtX::P64 + 24];
           _scHsp::P64 = P64[_scHtX::P64 + 32];
           _scHsW::P64 = P64[_scHtX::P64 + 40];
           _scHt1::P64 = P64[_scHtX::P64 + 48];
           _scHt6::P64 = P64[_scHtX::P64 + 56];
           _scHtc::P64 = P64[_scHtX::P64 + 64];
           I64[Hp - 56] = sat_scHtT_info;
           P64[Hp - 40] = _scHsn::P64;
           P64[Hp - 32] = _scHso::P64;
           P64[Hp - 24] = _scHsp::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccHYS_info;
           R4 = Hp - 56;
           R3 = _scHsW::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccHYS() //  [R1, R2]
         { info_tbl: [(ccHYS,
                       label: block_ccHYS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHYS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccHZ2; else goto ccHZ1;
       ccHZ2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccHZ1: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtY_entry() //  [R1]
         { info_tbl: [(ccHZ3,
                       label: sat_scHtY_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHZ3: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccHZ7; else goto ccHZ6;
       ccHZ7: // global
           HpAlloc = 72;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHZ6: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsW::P64 = P64[R1 + 40];
           _scHt1::P64 = P64[R1 + 48];
           _scHt6::P64 = P64[R1 + 56];
           _scHtc::P64 = P64[R1 + 64];
           I64[Hp - 64] = sat_scHtX_info;
           P64[Hp - 48] = _scHsn::P64;
           P64[Hp - 40] = _scHso::P64;
           P64[Hp - 32] = _scHsp::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 64;
           R2 = lvl9_rcHpE_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtZ_entry() //  [R1]
         { info_tbl: [(ccHZ8,
                       label: sat_scHtZ_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHZ8: // global
           _scHtZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccHZ9; else goto ccHZa;
       ccHZa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccHZc; else goto ccHZb;
       ccHZc: // global
           HpAlloc = 72;
           goto ccHZ9;
       ccHZ9: // global
           R1 = _scHtZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHZb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtZ::P64;
           _scHsn::P64 = P64[_scHtZ::P64 + 16];
           _scHso::P64 = P64[_scHtZ::P64 + 24];
           _scHsp::P64 = P64[_scHtZ::P64 + 32];
           _scHsW::P64 = P64[_scHtZ::P64 + 40];
           _scHt1::P64 = P64[_scHtZ::P64 + 48];
           _scHt6::P64 = P64[_scHtZ::P64 + 56];
           _scHtc::P64 = P64[_scHtZ::P64 + 64];
           I64[Hp - 64] = sat_scHtY_info;
           P64[Hp - 48] = _scHsn::P64;
           P64[Hp - 40] = _scHso::P64;
           P64[Hp - 32] = _scHsp::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 64;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHu3_entry() //  [R1]
         { info_tbl: [(ccHZg,
                       label: sat_scHu3_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHZg: // global
           _scHu3::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccHZh; else goto ccHZi;
       ccHZi: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccHZk; else goto ccHZj;
       ccHZk: // global
           HpAlloc = 72;
           goto ccHZh;
       ccHZh: // global
           R1 = _scHu3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHZj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHu3::P64;
           _scHsn::P64 = P64[_scHu3::P64 + 16];
           _scHso::P64 = P64[_scHu3::P64 + 24];
           _scHsp::P64 = P64[_scHu3::P64 + 32];
           _scHsR::P64 = P64[_scHu3::P64 + 40];
           _scHsW::P64 = P64[_scHu3::P64 + 48];
           _scHt1::P64 = P64[_scHu3::P64 + 56];
           _scHt6::P64 = P64[_scHu3::P64 + 64];
           _scHtc::P64 = P64[_scHu3::P64 + 72];
           I64[Hp - 64] = sat_scHtZ_info;
           P64[Hp - 48] = _scHsn::P64;
           P64[Hp - 40] = _scHso::P64;
           P64[Hp - 32] = _scHsp::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccHZd_info;
           R4 = Hp - 64;
           R3 = _scHsR::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccHZd() //  [R1, R2]
         { info_tbl: [(ccHZd,
                       label: block_ccHZd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHZd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccHZn; else goto ccHZm;
       ccHZn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccHZm: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHu4_entry() //  [R1]
         { info_tbl: [(ccHZo,
                       label: sat_scHu4_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHZo: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccHZs; else goto ccHZr;
       ccHZs: // global
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHZr: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsR::P64 = P64[R1 + 40];
           _scHsW::P64 = P64[R1 + 48];
           _scHt1::P64 = P64[R1 + 56];
           _scHt6::P64 = P64[R1 + 64];
           _scHtc::P64 = P64[R1 + 72];
           I64[Hp - 72] = sat_scHu3_info;
           P64[Hp - 56] = _scHsn::P64;
           P64[Hp - 48] = _scHso::P64;
           P64[Hp - 40] = _scHsp::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 72;
           R2 = lvl8_rcHpD_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHu5_entry() //  [R1]
         { info_tbl: [(ccHZt,
                       label: sat_scHu5_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHZt: // global
           _scHu5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccHZu; else goto ccHZv;
       ccHZv: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccHZx; else goto ccHZw;
       ccHZx: // global
           HpAlloc = 80;
           goto ccHZu;
       ccHZu: // global
           R1 = _scHu5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHZw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHu5::P64;
           _scHsn::P64 = P64[_scHu5::P64 + 16];
           _scHso::P64 = P64[_scHu5::P64 + 24];
           _scHsp::P64 = P64[_scHu5::P64 + 32];
           _scHsR::P64 = P64[_scHu5::P64 + 40];
           _scHsW::P64 = P64[_scHu5::P64 + 48];
           _scHt1::P64 = P64[_scHu5::P64 + 56];
           _scHt6::P64 = P64[_scHu5::P64 + 64];
           _scHtc::P64 = P64[_scHu5::P64 + 72];
           I64[Hp - 72] = sat_scHu4_info;
           P64[Hp - 56] = _scHsn::P64;
           P64[Hp - 48] = _scHso::P64;
           P64[Hp - 40] = _scHsp::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 72;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHu9_entry() //  [R1]
         { info_tbl: [(ccHZB,
                       label: sat_scHu9_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHZB: // global
           _scHu9::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccHZC; else goto ccHZD;
       ccHZD: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccHZF; else goto ccHZE;
       ccHZF: // global
           HpAlloc = 80;
           goto ccHZC;
       ccHZC: // global
           R1 = _scHu9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHZE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHu9::P64;
           _scHsn::P64 = P64[_scHu9::P64 + 16];
           _scHso::P64 = P64[_scHu9::P64 + 24];
           _scHsp::P64 = P64[_scHu9::P64 + 32];
           _scHsM::P64 = P64[_scHu9::P64 + 40];
           _scHsR::P64 = P64[_scHu9::P64 + 48];
           _scHsW::P64 = P64[_scHu9::P64 + 56];
           _scHt1::P64 = P64[_scHu9::P64 + 64];
           _scHt6::P64 = P64[_scHu9::P64 + 72];
           _scHtc::P64 = P64[_scHu9::P64 + 80];
           I64[Hp - 72] = sat_scHu5_info;
           P64[Hp - 56] = _scHsn::P64;
           P64[Hp - 48] = _scHso::P64;
           P64[Hp - 40] = _scHsp::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccHZy_info;
           R4 = Hp - 72;
           R3 = _scHsM::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccHZy() //  [R1, R2]
         { info_tbl: [(ccHZy,
                       label: block_ccHZy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHZy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccHZI; else goto ccHZH;
       ccHZI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccHZH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHua_entry() //  [R1]
         { info_tbl: [(ccHZJ,
                       label: sat_scHua_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHZJ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccHZN; else goto ccHZM;
       ccHZN: // global
           HpAlloc = 88;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHZM: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsM::P64 = P64[R1 + 40];
           _scHsR::P64 = P64[R1 + 48];
           _scHsW::P64 = P64[R1 + 56];
           _scHt1::P64 = P64[R1 + 64];
           _scHt6::P64 = P64[R1 + 72];
           _scHtc::P64 = P64[R1 + 80];
           I64[Hp - 80] = sat_scHu9_info;
           P64[Hp - 64] = _scHsn::P64;
           P64[Hp - 56] = _scHso::P64;
           P64[Hp - 48] = _scHsp::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 80;
           R2 = lvl7_rcHpC_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHub_entry() //  [R1]
         { info_tbl: [(ccHZO,
                       label: sat_scHub_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHZO: // global
           _scHub::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccHZP; else goto ccHZQ;
       ccHZQ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccHZS; else goto ccHZR;
       ccHZS: // global
           HpAlloc = 88;
           goto ccHZP;
       ccHZP: // global
           R1 = _scHub::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHZR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHub::P64;
           _scHsn::P64 = P64[_scHub::P64 + 16];
           _scHso::P64 = P64[_scHub::P64 + 24];
           _scHsp::P64 = P64[_scHub::P64 + 32];
           _scHsM::P64 = P64[_scHub::P64 + 40];
           _scHsR::P64 = P64[_scHub::P64 + 48];
           _scHsW::P64 = P64[_scHub::P64 + 56];
           _scHt1::P64 = P64[_scHub::P64 + 64];
           _scHt6::P64 = P64[_scHub::P64 + 72];
           _scHtc::P64 = P64[_scHub::P64 + 80];
           I64[Hp - 80] = sat_scHua_info;
           P64[Hp - 64] = _scHsn::P64;
           P64[Hp - 56] = _scHso::P64;
           P64[Hp - 48] = _scHsp::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 80;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuf_entry() //  [R1]
         { info_tbl: [(ccHZW,
                       label: sat_scHuf_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHZW: // global
           _scHuf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccHZX; else goto ccHZY;
       ccHZY: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccI00; else goto ccHZZ;
       ccI00: // global
           HpAlloc = 88;
           goto ccHZX;
       ccHZX: // global
           R1 = _scHuf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccHZZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuf::P64;
           _scHsn::P64 = P64[_scHuf::P64 + 16];
           _scHso::P64 = P64[_scHuf::P64 + 24];
           _scHsp::P64 = P64[_scHuf::P64 + 32];
           _scHsH::P64 = P64[_scHuf::P64 + 40];
           _scHsM::P64 = P64[_scHuf::P64 + 48];
           _scHsR::P64 = P64[_scHuf::P64 + 56];
           _scHsW::P64 = P64[_scHuf::P64 + 64];
           _scHt1::P64 = P64[_scHuf::P64 + 72];
           _scHt6::P64 = P64[_scHuf::P64 + 80];
           _scHtc::P64 = P64[_scHuf::P64 + 88];
           I64[Hp - 80] = sat_scHub_info;
           P64[Hp - 64] = _scHsn::P64;
           P64[Hp - 56] = _scHso::P64;
           P64[Hp - 48] = _scHsp::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccHZT_info;
           R4 = Hp - 80;
           R3 = _scHsH::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccHZT() //  [R1, R2]
         { info_tbl: [(ccHZT,
                       label: block_ccHZT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHZT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccI03; else goto ccI02;
       ccI03: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccI02: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHug_entry() //  [R1]
         { info_tbl: [(ccI04,
                       label: sat_scHug_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI04: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccI08; else goto ccI07;
       ccI08: // global
           HpAlloc = 96;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI07: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsH::P64 = P64[R1 + 40];
           _scHsM::P64 = P64[R1 + 48];
           _scHsR::P64 = P64[R1 + 56];
           _scHsW::P64 = P64[R1 + 64];
           _scHt1::P64 = P64[R1 + 72];
           _scHt6::P64 = P64[R1 + 80];
           _scHtc::P64 = P64[R1 + 88];
           I64[Hp - 88] = sat_scHuf_info;
           P64[Hp - 72] = _scHsn::P64;
           P64[Hp - 64] = _scHso::P64;
           P64[Hp - 56] = _scHsp::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 88;
           R2 = lvl6_rcHpB_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHuh_entry() //  [R1]
         { info_tbl: [(ccI09,
                       label: sat_scHuh_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI09: // global
           _scHuh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccI0a; else goto ccI0b;
       ccI0b: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccI0d; else goto ccI0c;
       ccI0d: // global
           HpAlloc = 96;
           goto ccI0a;
       ccI0a: // global
           R1 = _scHuh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI0c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuh::P64;
           _scHsn::P64 = P64[_scHuh::P64 + 16];
           _scHso::P64 = P64[_scHuh::P64 + 24];
           _scHsp::P64 = P64[_scHuh::P64 + 32];
           _scHsH::P64 = P64[_scHuh::P64 + 40];
           _scHsM::P64 = P64[_scHuh::P64 + 48];
           _scHsR::P64 = P64[_scHuh::P64 + 56];
           _scHsW::P64 = P64[_scHuh::P64 + 64];
           _scHt1::P64 = P64[_scHuh::P64 + 72];
           _scHt6::P64 = P64[_scHuh::P64 + 80];
           _scHtc::P64 = P64[_scHuh::P64 + 88];
           I64[Hp - 88] = sat_scHug_info;
           P64[Hp - 72] = _scHsn::P64;
           P64[Hp - 64] = _scHso::P64;
           P64[Hp - 56] = _scHsp::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 88;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHul_entry() //  [R1]
         { info_tbl: [(ccI0h,
                       label: sat_scHul_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI0h: // global
           _scHul::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccI0i; else goto ccI0j;
       ccI0j: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccI0l; else goto ccI0k;
       ccI0l: // global
           HpAlloc = 96;
           goto ccI0i;
       ccI0i: // global
           R1 = _scHul::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI0k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHul::P64;
           _scHsn::P64 = P64[_scHul::P64 + 16];
           _scHso::P64 = P64[_scHul::P64 + 24];
           _scHsp::P64 = P64[_scHul::P64 + 32];
           _scHsC::P64 = P64[_scHul::P64 + 40];
           _scHsH::P64 = P64[_scHul::P64 + 48];
           _scHsM::P64 = P64[_scHul::P64 + 56];
           _scHsR::P64 = P64[_scHul::P64 + 64];
           _scHsW::P64 = P64[_scHul::P64 + 72];
           _scHt1::P64 = P64[_scHul::P64 + 80];
           _scHt6::P64 = P64[_scHul::P64 + 88];
           _scHtc::P64 = P64[_scHul::P64 + 96];
           I64[Hp - 88] = sat_scHuh_info;
           P64[Hp - 72] = _scHsn::P64;
           P64[Hp - 64] = _scHso::P64;
           P64[Hp - 56] = _scHsp::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccI0e_info;
           R4 = Hp - 88;
           R3 = _scHsC::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccI0e() //  [R1, R2]
         { info_tbl: [(ccI0e,
                       label: block_ccI0e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI0e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccI0o; else goto ccI0n;
       ccI0o: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccI0n: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHum_entry() //  [R1]
         { info_tbl: [(ccI0p,
                       label: sat_scHum_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI0p: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccI0t; else goto ccI0s;
       ccI0t: // global
           HpAlloc = 104;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI0s: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsC::P64 = P64[R1 + 40];
           _scHsH::P64 = P64[R1 + 48];
           _scHsM::P64 = P64[R1 + 56];
           _scHsR::P64 = P64[R1 + 64];
           _scHsW::P64 = P64[R1 + 72];
           _scHt1::P64 = P64[R1 + 80];
           _scHt6::P64 = P64[R1 + 88];
           _scHtc::P64 = P64[R1 + 96];
           I64[Hp - 96] = sat_scHul_info;
           P64[Hp - 80] = _scHsn::P64;
           P64[Hp - 72] = _scHso::P64;
           P64[Hp - 64] = _scHsp::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 96;
           R2 = lvl5_rcHpA_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHun_entry() //  [R1]
         { info_tbl: [(ccI0u,
                       label: sat_scHun_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI0u: // global
           _scHun::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccI0v; else goto ccI0w;
       ccI0w: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccI0y; else goto ccI0x;
       ccI0y: // global
           HpAlloc = 104;
           goto ccI0v;
       ccI0v: // global
           R1 = _scHun::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI0x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHun::P64;
           _scHsn::P64 = P64[_scHun::P64 + 16];
           _scHso::P64 = P64[_scHun::P64 + 24];
           _scHsp::P64 = P64[_scHun::P64 + 32];
           _scHsC::P64 = P64[_scHun::P64 + 40];
           _scHsH::P64 = P64[_scHun::P64 + 48];
           _scHsM::P64 = P64[_scHun::P64 + 56];
           _scHsR::P64 = P64[_scHun::P64 + 64];
           _scHsW::P64 = P64[_scHun::P64 + 72];
           _scHt1::P64 = P64[_scHun::P64 + 80];
           _scHt6::P64 = P64[_scHun::P64 + 88];
           _scHtc::P64 = P64[_scHun::P64 + 96];
           I64[Hp - 96] = sat_scHum_info;
           P64[Hp - 80] = _scHsn::P64;
           P64[Hp - 72] = _scHso::P64;
           P64[Hp - 64] = _scHsp::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 96;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHur_entry() //  [R1]
         { info_tbl: [(ccI0C,
                       label: sat_scHur_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI0C: // global
           _scHur::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccI0D; else goto ccI0E;
       ccI0E: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccI0G; else goto ccI0F;
       ccI0G: // global
           HpAlloc = 104;
           goto ccI0D;
       ccI0D: // global
           R1 = _scHur::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI0F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHur::P64;
           _scHsn::P64 = P64[_scHur::P64 + 16];
           _scHso::P64 = P64[_scHur::P64 + 24];
           _scHsp::P64 = P64[_scHur::P64 + 32];
           _scHsx::P64 = P64[_scHur::P64 + 40];
           _scHsC::P64 = P64[_scHur::P64 + 48];
           _scHsH::P64 = P64[_scHur::P64 + 56];
           _scHsM::P64 = P64[_scHur::P64 + 64];
           _scHsR::P64 = P64[_scHur::P64 + 72];
           _scHsW::P64 = P64[_scHur::P64 + 80];
           _scHt1::P64 = P64[_scHur::P64 + 88];
           _scHt6::P64 = P64[_scHur::P64 + 96];
           _scHtc::P64 = P64[_scHur::P64 + 104];
           I64[Hp - 96] = sat_scHun_info;
           P64[Hp - 80] = _scHsn::P64;
           P64[Hp - 72] = _scHso::P64;
           P64[Hp - 64] = _scHsp::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccI0z_info;
           R4 = Hp - 96;
           R3 = _scHsx::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccI0z() //  [R1, R2]
         { info_tbl: [(ccI0z,
                       label: block_ccI0z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI0z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccI0J; else goto ccI0I;
       ccI0J: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccI0I: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHus_entry() //  [R1]
         { info_tbl: [(ccI0K,
                       label: sat_scHus_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI0K: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccI0O; else goto ccI0N;
       ccI0O: // global
           HpAlloc = 112;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI0N: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsx::P64 = P64[R1 + 40];
           _scHsC::P64 = P64[R1 + 48];
           _scHsH::P64 = P64[R1 + 56];
           _scHsM::P64 = P64[R1 + 64];
           _scHsR::P64 = P64[R1 + 72];
           _scHsW::P64 = P64[R1 + 80];
           _scHt1::P64 = P64[R1 + 88];
           _scHt6::P64 = P64[R1 + 96];
           _scHtc::P64 = P64[R1 + 104];
           I64[Hp - 104] = sat_scHur_info;
           P64[Hp - 88] = _scHsn::P64;
           P64[Hp - 80] = _scHso::P64;
           P64[Hp - 72] = _scHsp::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 104;
           R2 = lvl4_rcHpz_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHut_entry() //  [R1]
         { info_tbl: [(ccI0P,
                       label: sat_scHut_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI0P: // global
           _scHut::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccI0Q; else goto ccI0R;
       ccI0R: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccI0T; else goto ccI0S;
       ccI0T: // global
           HpAlloc = 112;
           goto ccI0Q;
       ccI0Q: // global
           R1 = _scHut::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI0S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHut::P64;
           _scHsn::P64 = P64[_scHut::P64 + 16];
           _scHso::P64 = P64[_scHut::P64 + 24];
           _scHsp::P64 = P64[_scHut::P64 + 32];
           _scHsx::P64 = P64[_scHut::P64 + 40];
           _scHsC::P64 = P64[_scHut::P64 + 48];
           _scHsH::P64 = P64[_scHut::P64 + 56];
           _scHsM::P64 = P64[_scHut::P64 + 64];
           _scHsR::P64 = P64[_scHut::P64 + 72];
           _scHsW::P64 = P64[_scHut::P64 + 80];
           _scHt1::P64 = P64[_scHut::P64 + 88];
           _scHt6::P64 = P64[_scHut::P64 + 96];
           _scHtc::P64 = P64[_scHut::P64 + 104];
           I64[Hp - 104] = sat_scHus_info;
           P64[Hp - 88] = _scHsn::P64;
           P64[Hp - 80] = _scHso::P64;
           P64[Hp - 72] = _scHsp::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 104;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHux_entry() //  [R1]
         { info_tbl: [(ccI0X,
                       label: sat_scHux_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI0X: // global
           _scHux::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccI0Y; else goto ccI0Z;
       ccI0Z: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccI11; else goto ccI10;
       ccI11: // global
           HpAlloc = 112;
           goto ccI0Y;
       ccI0Y: // global
           R1 = _scHux::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI10: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHux::P64;
           _scHsn::P64 = P64[_scHux::P64 + 16];
           _scHso::P64 = P64[_scHux::P64 + 24];
           _scHsp::P64 = P64[_scHux::P64 + 32];
           _scHss::P64 = P64[_scHux::P64 + 40];
           _scHsx::P64 = P64[_scHux::P64 + 48];
           _scHsC::P64 = P64[_scHux::P64 + 56];
           _scHsH::P64 = P64[_scHux::P64 + 64];
           _scHsM::P64 = P64[_scHux::P64 + 72];
           _scHsR::P64 = P64[_scHux::P64 + 80];
           _scHsW::P64 = P64[_scHux::P64 + 88];
           _scHt1::P64 = P64[_scHux::P64 + 96];
           _scHt6::P64 = P64[_scHux::P64 + 104];
           _scHtc::P64 = P64[_scHux::P64 + 112];
           I64[Hp - 104] = sat_scHut_info;
           P64[Hp - 88] = _scHsn::P64;
           P64[Hp - 80] = _scHso::P64;
           P64[Hp - 72] = _scHsp::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccI0U_info;
           R4 = Hp - 104;
           R3 = _scHss::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccI0U() //  [R1, R2]
         { info_tbl: [(ccI0U,
                       label: block_ccI0U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI0U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccI14; else goto ccI13;
       ccI14: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccI13: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuy_entry() //  [R1]
         { info_tbl: [(ccI15,
                       label: sat_scHuy_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI15: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccI19; else goto ccI18;
       ccI19: // global
           HpAlloc = 120;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI18: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHss::P64 = P64[R1 + 40];
           _scHsx::P64 = P64[R1 + 48];
           _scHsC::P64 = P64[R1 + 56];
           _scHsH::P64 = P64[R1 + 64];
           _scHsM::P64 = P64[R1 + 72];
           _scHsR::P64 = P64[R1 + 80];
           _scHsW::P64 = P64[R1 + 88];
           _scHt1::P64 = P64[R1 + 96];
           _scHt6::P64 = P64[R1 + 104];
           _scHtc::P64 = P64[R1 + 112];
           I64[Hp - 112] = sat_scHux_info;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 112;
           R2 = lvl3_rcHpy_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHuz_entry() //  [R1]
         { info_tbl: [(ccI1a,
                       label: sat_scHuz_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI1a: // global
           _scHuz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccI1b; else goto ccI1c;
       ccI1c: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccI1e; else goto ccI1d;
       ccI1e: // global
           HpAlloc = 120;
           goto ccI1b;
       ccI1b: // global
           R1 = _scHuz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI1d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuz::P64;
           _scHsn::P64 = P64[_scHuz::P64 + 16];
           _scHso::P64 = P64[_scHuz::P64 + 24];
           _scHsp::P64 = P64[_scHuz::P64 + 32];
           _scHss::P64 = P64[_scHuz::P64 + 40];
           _scHsx::P64 = P64[_scHuz::P64 + 48];
           _scHsC::P64 = P64[_scHuz::P64 + 56];
           _scHsH::P64 = P64[_scHuz::P64 + 64];
           _scHsM::P64 = P64[_scHuz::P64 + 72];
           _scHsR::P64 = P64[_scHuz::P64 + 80];
           _scHsW::P64 = P64[_scHuz::P64 + 88];
           _scHt1::P64 = P64[_scHuz::P64 + 96];
           _scHt6::P64 = P64[_scHuz::P64 + 104];
           _scHtc::P64 = P64[_scHuz::P64 + 112];
           I64[Hp - 112] = sat_scHuy_info;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 112;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuD_entry() //  [R1]
         { info_tbl: [(ccI1f,
                       label: sat_scHuD_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI1f: // global
           if ((Sp + -128) < SpLim) (likely: False) goto ccI1m; else goto ccI1n;
       ccI1m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI1n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 128] = block_ccHUk_info;
           _scHsn::P64 = P64[R1 + 24];
           _scHso::P64 = P64[R1 + 32];
           _scHsp::P64 = P64[R1 + 40];
           _scHss::P64 = P64[R1 + 48];
           _scHsx::P64 = P64[R1 + 56];
           _scHsC::P64 = P64[R1 + 64];
           _scHsH::P64 = P64[R1 + 72];
           _scHsM::P64 = P64[R1 + 80];
           _scHsR::P64 = P64[R1 + 88];
           _scHsW::P64 = P64[R1 + 96];
           _scHt1::P64 = P64[R1 + 104];
           _scHt6::P64 = P64[R1 + 112];
           _scHtc::P64 = P64[R1 + 120];
           R1 = P64[R1 + 16];
           P64[Sp - 120] = _scHsn::P64;
           P64[Sp - 112] = _scHso::P64;
           P64[Sp - 104] = _scHsp::P64;
           P64[Sp - 96] = _scHss::P64;
           P64[Sp - 88] = _scHsx::P64;
           P64[Sp - 80] = _scHsC::P64;
           P64[Sp - 72] = _scHsH::P64;
           P64[Sp - 64] = _scHsM::P64;
           P64[Sp - 56] = _scHsR::P64;
           P64[Sp - 48] = _scHsW::P64;
           P64[Sp - 40] = _scHt1::P64;
           P64[Sp - 32] = _scHt6::P64;
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto ucI1u; else goto ccHUl;
       ucI1u: // global
           call _ccHUk(R1) args: 0, res: 0, upd: 0;
       ccHUl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHUk() //  [R1]
         { info_tbl: [(ccHUk,
                       label: block_ccHUk_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHUk: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccI1q; else goto ccI1p;
       ccI1q: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccI1p: // global
           _scHth::I64 = I64[R1 + 7];
           I64[Hp - 112] = sat_scHuz_info;
           P64[Hp - 96] = P64[Sp + 8];
           P64[Hp - 88] = P64[Sp + 16];
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 32];
           P64[Hp - 64] = P64[Sp + 40];
           P64[Hp - 56] = P64[Sp + 48];
           P64[Hp - 48] = P64[Sp + 56];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           P64[Hp - 24] = P64[Sp + 80];
           P64[Hp - 16] = P64[Sp + 88];
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 104];
           I64[Sp + 104] = block_ccI1j_info;
           R3 = Hp - 112;
           R2 = _scHth::I64;
           Sp = Sp + 104;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccI1j() //  [R1, R2]
         { info_tbl: [(ccI1j,
                       label: block_ccI1j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI1j: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccI1t; else goto ccI1s;
       ccI1t: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccI1s: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuE_entry() //  [R1]
         { info_tbl: [(ccI1v,
                       label: sat_scHuE_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI1v: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccI1z; else goto ccI1y;
       ccI1z: // global
           HpAlloc = 128;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI1y: // global
           _scHsd::P64 = P64[R1 + 16];
           _scHsn::P64 = P64[R1 + 24];
           _scHso::P64 = P64[R1 + 32];
           _scHsp::P64 = P64[R1 + 40];
           _scHss::P64 = P64[R1 + 48];
           _scHsx::P64 = P64[R1 + 56];
           _scHsC::P64 = P64[R1 + 64];
           _scHsH::P64 = P64[R1 + 72];
           _scHsM::P64 = P64[R1 + 80];
           _scHsR::P64 = P64[R1 + 88];
           _scHsW::P64 = P64[R1 + 96];
           _scHt1::P64 = P64[R1 + 104];
           _scHt6::P64 = P64[R1 + 112];
           _scHtc::P64 = P64[R1 + 120];
           I64[Hp - 120] = sat_scHuD_info;
           P64[Hp - 104] = _scHsd::P64;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 120;
           R2 = lvl2_rcHpx_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHuF_entry() //  [R1]
         { info_tbl: [(ccI1A,
                       label: sat_scHuF_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI1A: // global
           _scHuF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccI1B; else goto ccI1C;
       ccI1C: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccI1E; else goto ccI1D;
       ccI1E: // global
           HpAlloc = 128;
           goto ccI1B;
       ccI1B: // global
           R1 = _scHuF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI1D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuF::P64;
           _scHsd::P64 = P64[_scHuF::P64 + 16];
           _scHsn::P64 = P64[_scHuF::P64 + 24];
           _scHso::P64 = P64[_scHuF::P64 + 32];
           _scHsp::P64 = P64[_scHuF::P64 + 40];
           _scHss::P64 = P64[_scHuF::P64 + 48];
           _scHsx::P64 = P64[_scHuF::P64 + 56];
           _scHsC::P64 = P64[_scHuF::P64 + 64];
           _scHsH::P64 = P64[_scHuF::P64 + 72];
           _scHsM::P64 = P64[_scHuF::P64 + 80];
           _scHsR::P64 = P64[_scHuF::P64 + 88];
           _scHsW::P64 = P64[_scHuF::P64 + 96];
           _scHt1::P64 = P64[_scHuF::P64 + 104];
           _scHt6::P64 = P64[_scHuF::P64 + 112];
           _scHtc::P64 = P64[_scHuF::P64 + 120];
           I64[Hp - 120] = sat_scHuE_info;
           P64[Hp - 104] = _scHsd::P64;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 120;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuJ_entry() //  [R1]
         { info_tbl: [(ccI1F,
                       label: sat_scHuJ_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI1F: // global
           if ((Sp + -136) < SpLim) (likely: False) goto ccI1M; else goto ccI1N;
       ccI1M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI1N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 136] = block_ccHU3_info;
           _scHsd::P64 = P64[R1 + 24];
           _scHsn::P64 = P64[R1 + 32];
           _scHso::P64 = P64[R1 + 40];
           _scHsp::P64 = P64[R1 + 48];
           _scHss::P64 = P64[R1 + 56];
           _scHsx::P64 = P64[R1 + 64];
           _scHsC::P64 = P64[R1 + 72];
           _scHsH::P64 = P64[R1 + 80];
           _scHsM::P64 = P64[R1 + 88];
           _scHsR::P64 = P64[R1 + 96];
           _scHsW::P64 = P64[R1 + 104];
           _scHt1::P64 = P64[R1 + 112];
           _scHt6::P64 = P64[R1 + 120];
           _scHtc::P64 = P64[R1 + 128];
           R1 = P64[R1 + 16];
           P64[Sp - 128] = _scHsd::P64;
           P64[Sp - 120] = _scHsn::P64;
           P64[Sp - 112] = _scHso::P64;
           P64[Sp - 104] = _scHsp::P64;
           P64[Sp - 96] = _scHss::P64;
           P64[Sp - 88] = _scHsx::P64;
           P64[Sp - 80] = _scHsC::P64;
           P64[Sp - 72] = _scHsH::P64;
           P64[Sp - 64] = _scHsM::P64;
           P64[Sp - 56] = _scHsR::P64;
           P64[Sp - 48] = _scHsW::P64;
           P64[Sp - 40] = _scHt1::P64;
           P64[Sp - 32] = _scHt6::P64;
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 136;
           if (R1 & 7 != 0) goto ucI1U; else goto ccHU4;
       ucI1U: // global
           call _ccHU3(R1) args: 0, res: 0, upd: 0;
       ccHU4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccHU3() //  [R1]
         { info_tbl: [(ccHU3,
                       label: block_ccHU3_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHU3: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccI1Q; else goto ccI1P;
       ccI1Q: // global
           HpAlloc = 128;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccI1P: // global
           _scHte::I64 = I64[R1 + 7];
           I64[Hp - 120] = sat_scHuF_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = P64[Sp + 16];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = P64[Sp + 56];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = P64[Sp + 72];
           P64[Hp - 32] = P64[Sp + 80];
           P64[Hp - 24] = P64[Sp + 88];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           I64[Sp + 112] = block_ccI1J_info;
           R3 = Hp - 120;
           R2 = _scHte::I64;
           Sp = Sp + 112;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccI1J() //  [R1, R2]
         { info_tbl: [(ccI1J,
                       label: block_ccI1J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI1J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccI1T; else goto ccI1S;
       ccI1T: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccI1S: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuK_entry() //  [R1]
         { info_tbl: [(ccI1V,
                       label: sat_scHuK_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI1V: // global
           _scHuK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccI1W; else goto ccI1X;
       ccI1X: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccI1Z; else goto ccI1Y;
       ccI1Z: // global
           HpAlloc = 136;
           goto ccI1W;
       ccI1W: // global
           R1 = _scHuK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI1Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuK::P64;
           _scHsc::P64 = P64[_scHuK::P64 + 16];
           _scHsd::P64 = P64[_scHuK::P64 + 24];
           _scHsn::P64 = P64[_scHuK::P64 + 32];
           _scHso::P64 = P64[_scHuK::P64 + 40];
           _scHsp::P64 = P64[_scHuK::P64 + 48];
           _scHss::P64 = P64[_scHuK::P64 + 56];
           _scHsx::P64 = P64[_scHuK::P64 + 64];
           _scHsC::P64 = P64[_scHuK::P64 + 72];
           _scHsH::P64 = P64[_scHuK::P64 + 80];
           _scHsM::P64 = P64[_scHuK::P64 + 88];
           _scHsR::P64 = P64[_scHuK::P64 + 96];
           _scHsW::P64 = P64[_scHuK::P64 + 104];
           _scHt1::P64 = P64[_scHuK::P64 + 112];
           _scHt6::P64 = P64[_scHuK::P64 + 120];
           _scHtc::P64 = P64[_scHuK::P64 + 128];
           I64[Hp - 128] = sat_scHuJ_info;
           P64[Hp - 112] = _scHsc::P64;
           P64[Hp - 104] = _scHsd::P64;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 128;
           R2 = lvl1_rcHpw_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_scHtb_entry() //  [R1, R2]
         { info_tbl: [(ccI20,
                       label: p_scHtb_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI20: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccI24; else goto ccI23;
       ccI24: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccI23: // global
           _scHsc::P64 = P64[R1 + 7];
           _scHsd::P64 = P64[R1 + 15];
           _scHsn::P64 = P64[R1 + 23];
           _scHso::P64 = P64[R1 + 31];
           _scHsp::P64 = P64[R1 + 39];
           _scHss::P64 = P64[R1 + 47];
           _scHsx::P64 = P64[R1 + 55];
           _scHsC::P64 = P64[R1 + 63];
           _scHsH::P64 = P64[R1 + 71];
           _scHsM::P64 = P64[R1 + 79];
           _scHsR::P64 = P64[R1 + 87];
           _scHsW::P64 = P64[R1 + 95];
           _scHt1::P64 = P64[R1 + 103];
           _scHt6::P64 = P64[R1 + 111];
           I64[Hp - 128] = sat_scHuK_info;
           P64[Hp - 112] = _scHsc::P64;
           P64[Hp - 104] = _scHsd::P64;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = R2;
           R3 = Hp - 128;
           R2 = lvl_rcHpv_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHuO_entry() //  [R1]
         { info_tbl: [(ccI2j,
                       label: sat_scHuO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI2j: // global
           _scHuO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccI2k; else goto ccI2l;
       ccI2l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccI2n; else goto ccI2m;
       ccI2n: // global
           HpAlloc = 24;
           goto ccI2k;
       ccI2k: // global
           R1 = _scHuO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI2m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuO::P64;
           _scHtb::P64 = P64[_scHuO::P64 + 16];
           _scHuM::P64 = P64[_scHuO::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _scHuM::P64;
           R2 = Hp - 14;
           R1 = _scHtb::P64;
           Sp = Sp - 16;
           call p_scHtb_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuP_entry() //  [R1, R2]
         { info_tbl: [(ccI2p,
                       label: sat_scHuP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI2p: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccI2t; else goto ccI2s;
       ccI2t: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccI2s: // global
           _scHtb::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_scHuO_info;
           P64[Hp - 32] = _scHtb::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stats.$fShowGCDetails_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(ccI2u,
                       label: GHC.Stats.$fShowGCDetails_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI2u: // global
           if ((Sp + -120) < SpLim) (likely: False) goto ccI2v; else goto ccI2w;
       ccI2v: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fShowGCDetails_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccI2w: // global
           I64[Sp - 16] = block_ccHQu_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucI2F; else goto ccHQv;
       ucI2F: // global
           call _ccHQu(R1) args: 0, res: 0, upd: 0;
       ccHQv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccHQu() //  [R1]
         { info_tbl: [(ccHQu,
                       label: block_ccHQu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHQu: // global
           I64[Sp - 104] = block_ccHQz_info;
           _scHsc::P64 = P64[R1 + 7];
           _scHsd::P64 = P64[R1 + 15];
           _scHse::P64 = P64[R1 + 23];
           _scHsf::P64 = P64[R1 + 31];
           _scHsg::P64 = P64[R1 + 39];
           _scHsh::P64 = P64[R1 + 47];
           _scHsi::P64 = P64[R1 + 55];
           _scHsj::P64 = P64[R1 + 63];
           _scHsk::P64 = P64[R1 + 71];
           _scHsl::P64 = P64[R1 + 79];
           _scHsm::P64 = P64[R1 + 87];
           _scHsn::P64 = P64[R1 + 95];
           _scHso::P64 = P64[R1 + 103];
           _scHsp::P64 = P64[R1 + 111];
           R1 = P64[Sp + 8];
           P64[Sp - 96] = _scHse::P64;
           P64[Sp - 88] = _scHsf::P64;
           P64[Sp - 80] = _scHsg::P64;
           P64[Sp - 72] = _scHsh::P64;
           P64[Sp - 64] = _scHsi::P64;
           P64[Sp - 56] = _scHsj::P64;
           P64[Sp - 48] = _scHsk::P64;
           P64[Sp - 40] = _scHsl::P64;
           P64[Sp - 32] = _scHsm::P64;
           P64[Sp - 24] = _scHsn::P64;
           P64[Sp - 16] = _scHso::P64;
           P64[Sp - 8] = _scHsp::P64;
           P64[Sp] = _scHsd::P64;
           P64[Sp + 8] = _scHsc::P64;
           Sp = Sp - 104;
           if (R1 & 7 != 0) goto ucI2E; else goto ccHQA;
       ucI2E: // global
           call _ccHQz(R1) args: 0, res: 0, upd: 0;
       ccHQA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccHQz() //  [R1]
         { info_tbl: [(ccHQz,
                       label: block_ccHQz_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccHQz: // global
           Hp = Hp + 352;
           if (Hp > HpLim) (likely: False) goto ccI2A; else goto ccI2z;
       ccI2A: // global
           HpAlloc = 352;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccI2z: // global
           _scHsr::I64 = I64[R1 + 7];
           I64[Hp - 344] = w1_scHss_info;
           P64[Hp - 328] = P64[Sp + 8];
           I64[Hp - 320] = w2_scHsx_info;
           P64[Hp - 304] = P64[Sp + 16];
           I64[Hp - 296] = w3_scHsC_info;
           P64[Hp - 280] = P64[Sp + 24];
           I64[Hp - 272] = w4_scHsH_info;
           P64[Hp - 256] = P64[Sp + 32];
           I64[Hp - 248] = w5_scHsM_info;
           P64[Hp - 232] = P64[Sp + 40];
           I64[Hp - 224] = w6_scHsR_info;
           P64[Hp - 208] = P64[Sp + 48];
           I64[Hp - 200] = w7_scHsW_info;
           P64[Hp - 184] = P64[Sp + 56];
           I64[Hp - 176] = w8_scHt1_info;
           P64[Hp - 160] = P64[Sp + 64];
           I64[Hp - 152] = w9_scHt6_info;
           P64[Hp - 136] = P64[Sp + 72];
           I64[Hp - 128] = p_scHtb_info;
           P64[Hp - 120] = P64[Sp + 112];
           P64[Hp - 112] = P64[Sp + 104];
           P64[Hp - 104] = P64[Sp + 80];
           P64[Hp - 96] = P64[Sp + 88];
           P64[Hp - 88] = P64[Sp + 96];
           P64[Hp - 80] = Hp - 344;
           P64[Hp - 72] = Hp - 320;
           P64[Hp - 64] = Hp - 296;
           P64[Hp - 56] = Hp - 272;
           P64[Hp - 48] = Hp - 248;
           P64[Hp - 40] = Hp - 224;
           P64[Hp - 32] = Hp - 200;
           P64[Hp - 24] = Hp - 176;
           P64[Hp - 16] = Hp - 152;
           _ccHTQ::P64 = Hp - 127;
           if (%MO_S_Lt_W64(_scHsr::I64, 11)) goto ccI2C; else goto ccI2D;
       ccI2C: // global
           Hp = Hp - 16;
           R1 = _ccHTQ::P64;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccI2D: // global
           I64[Hp - 8] = sat_scHuP_info;
           P64[Hp] = _ccHTQ::P64;
           R1 = Hp - 7;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.815066215 UTC

[section ""data" . GHC.Stats.$fShowGCDetails2_closure" {
     GHC.Stats.$fShowGCDetails2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.815941364 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_$cshow_closure" {
     GHC.Stats.$fShowGCDetails_$cshow_closure:
         const GHC.Stats.$fShowGCDetails_$cshow_info;
         const 0;
 },
 GHC.Stats.$fShowGCDetails_$cshow_entry() //  [R2]
         { info_tbl: [(ccI2L,
                       label: GHC.Stats.$fShowGCDetails_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI2L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccI2M; else goto ccI2N;
       ccI2M: // global
           R2 = R2;
           R1 = GHC.Stats.$fShowGCDetails_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccI2N: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Stats.$fShowGCDetails_$cshowsPrec_entry(R3,
                                                            R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.816956503 UTC

[section ""data" . GHC.Stats.$fShowGCDetails1_closure" {
     GHC.Stats.$fShowGCDetails1_closure:
         const GHC.Stats.$fShowGCDetails1_info;
         const 0;
 },
 GHC.Stats.$fShowGCDetails1_entry() //  [R2]
         { info_tbl: [(ccI2S,
                       label: GHC.Stats.$fShowGCDetails1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI2S: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           call GHC.Stats.$fShowGCDetails_$cshowsPrec_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.817924465 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_$cshowList_closure" {
     GHC.Stats.$fShowGCDetails_$cshowList_closure:
         const GHC.Stats.$fShowGCDetails_$cshowList_info;
         const 0;
 },
 GHC.Stats.$fShowGCDetails_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(ccI2Z,
                       label: GHC.Stats.$fShowGCDetails_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI2Z: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.818734365 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_closure" {
     GHC.Stats.$fShowGCDetails_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Stats.$fShowGCDetails_$cshowsPrec_closure+2;
         const GHC.Stats.$fShowGCDetails_$cshow_closure+1;
         const GHC.Stats.$fShowGCDetails_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.819380239 UTC

[section ""cstring" . lvl16_rcHpL_bytes" {
     lvl16_rcHpL_bytes:
         I8[] [82,84,83,83,116,97,116,115,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.820003963 UTC

[section ""cstring" . lvl17_rcHpM_bytes" {
     lvl17_rcHpM_bytes:
         I8[] [103,99,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.820583781 UTC

[section ""cstring" . lvl18_rcHpN_bytes" {
     lvl18_rcHpN_bytes:
         I8[] [109,97,106,111,114,95,103,99,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.82119903 UTC

[section ""cstring" . lvl19_rcHpO_bytes" {
     lvl19_rcHpO_bytes:
         I8[] [97,108,108,111,99,97,116,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.821809342 UTC

[section ""cstring" . lvl20_rcHpP_bytes" {
     lvl20_rcHpP_bytes:
         I8[] [109,97,120,95,108,105,118,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.823498316 UTC

[section ""cstring" . lvl21_rcHpQ_bytes" {
     lvl21_rcHpQ_bytes:
         I8[] [109,97,120,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.824010107 UTC

[section ""cstring" . lvl22_rcHpR_bytes" {
     lvl22_rcHpR_bytes:
         I8[] [109,97,120,95,99,111,109,112,97,99,116,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.824605461 UTC

[section ""cstring" . lvl23_rcHpS_bytes" {
     lvl23_rcHpS_bytes:
         I8[] [109,97,120,95,115,108,111,112,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.825183702 UTC

[section ""cstring" . lvl24_rcHpT_bytes" {
     lvl24_rcHpT_bytes:
         I8[] [109,97,120,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.825832114 UTC

[section ""cstring" . lvl25_rcHpU_bytes" {
     lvl25_rcHpU_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,108,105,118,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.826394866 UTC

[section ""cstring" . lvl26_rcHpV_bytes" {
     lvl26_rcHpV_bytes:
         I8[] [99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.826970655 UTC

[section ""cstring" . lvl27_rcHpW_bytes" {
     lvl27_rcHpW_bytes:
         I8[] [112,97,114,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.827521151 UTC

[section ""cstring" . lvl28_rcHpX_bytes" {
     lvl28_rcHpX_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.828059847 UTC

[section ""cstring" . lvl29_rcHpY_bytes" {
     lvl29_rcHpY_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.828634854 UTC

[section ""cstring" . lvl30_rcHpZ_bytes" {
     lvl30_rcHpZ_bytes:
         I8[] [109,117,116,97,116,111,114,95,99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.829189306 UTC

[section ""cstring" . lvl31_rcHq0_bytes" {
     lvl31_rcHq0_bytes:
         I8[] [109,117,116,97,116,111,114,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.829845573 UTC

[section ""cstring" . lvl32_rcHq1_bytes" {
     lvl32_rcHq1_bytes:
         I8[] [103,99,95,99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.830421505 UTC

[section ""cstring" . lvl33_rcHq2_bytes" {
     lvl33_rcHq2_bytes:
         I8[] [103,99,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.830946462 UTC

[section ""cstring" . lvl34_rcHq3_bytes" {
     lvl34_rcHq3_bytes:
         I8[] [99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.831507045 UTC

[section ""cstring" . lvl35_rcHq4_bytes" {
     lvl35_rcHq4_bytes:
         I8[] [101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.832049011 UTC

[section ""cstring" . lvl36_rcHq5_bytes" {
     lvl36_rcHq5_bytes:
         I8[] [103,99,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.854607749 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_$cshowsPrec_closure" {
     GHC.Stats.$fShowRTSStats_$cshowsPrec_closure:
         const GHC.Stats.$fShowRTSStats_$cshowsPrec_info;
         const 0;
 },
 w1_scHvi_entry() //  [R1]
         { info_tbl: [(ccI3n,
                       label: w1_scHvi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI3n: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccI3o; else goto ccI3p;
       ccI3o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI3p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccI3k_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucI3B; else goto ccI3l;
       ucI3B: // global
           call _ccI3k(R1) args: 0, res: 0, upd: 0;
       ccI3l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccI3k() //  [R1]
         { info_tbl: [(ccI3k,
                       label: block_ccI3k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI3k: // global
           _scHvk::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvk::I64, 0)) goto ccI3z; else goto ccI3A;
       ccI3z: // global
           R2 = _scHvk::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccI3A: // global
           R2 = _scHvk::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w2_scHvn_entry() //  [R1]
         { info_tbl: [(ccI3J,
                       label: w2_scHvn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI3J: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccI3K; else goto ccI3L;
       ccI3K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI3L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccI3G_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucI3X; else goto ccI3H;
       ucI3X: // global
           call _ccI3G(R1) args: 0, res: 0, upd: 0;
       ccI3H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccI3G() //  [R1]
         { info_tbl: [(ccI3G,
                       label: block_ccI3G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI3G: // global
           _scHvp::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvp::I64, 0)) goto ccI3V; else goto ccI3W;
       ccI3V: // global
           R2 = _scHvp::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccI3W: // global
           R2 = _scHvp::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w3_scHvs_entry() //  [R1]
         { info_tbl: [(ccI45,
                       label: w3_scHvs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI45: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccI46; else goto ccI47;
       ccI46: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI47: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccI42_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucI4j; else goto ccI43;
       ucI4j: // global
           call _ccI42(R1) args: 0, res: 0, upd: 0;
       ccI43: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccI42() //  [R1]
         { info_tbl: [(ccI42,
                       label: block_ccI42_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI42: // global
           _scHvu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvu::I64, 0)) goto ccI4h; else goto ccI4i;
       ccI4h: // global
           R2 = _scHvu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccI4i: // global
           R2 = _scHvu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w4_scHvx_entry() //  [R1]
         { info_tbl: [(ccI4r,
                       label: w4_scHvx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI4r: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccI4s; else goto ccI4t;
       ccI4s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI4t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccI4o_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucI4F; else goto ccI4p;
       ucI4F: // global
           call _ccI4o(R1) args: 0, res: 0, upd: 0;
       ccI4p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccI4o() //  [R1]
         { info_tbl: [(ccI4o,
                       label: block_ccI4o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI4o: // global
           _scHvz::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvz::I64, 0)) goto ccI4D; else goto ccI4E;
       ccI4D: // global
           R2 = _scHvz::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccI4E: // global
           R2 = _scHvz::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_scHvC_entry() //  [R1]
         { info_tbl: [(ccI4N,
                       label: w5_scHvC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI4N: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccI4O; else goto ccI4P;
       ccI4O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI4P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccI4K_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucI51; else goto ccI4L;
       ucI51: // global
           call _ccI4K(R1) args: 0, res: 0, upd: 0;
       ccI4L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccI4K() //  [R1]
         { info_tbl: [(ccI4K,
                       label: block_ccI4K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI4K: // global
           _scHvE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvE::I64, 0)) goto ccI4Z; else goto ccI50;
       ccI4Z: // global
           R2 = _scHvE::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccI50: // global
           R2 = _scHvE::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_scHvH_entry() //  [R1]
         { info_tbl: [(ccI59,
                       label: w6_scHvH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI59: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccI5a; else goto ccI5b;
       ccI5a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI5b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccI56_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucI5n; else goto ccI57;
       ucI5n: // global
           call _ccI56(R1) args: 0, res: 0, upd: 0;
       ccI57: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccI56() //  [R1]
         { info_tbl: [(ccI56,
                       label: block_ccI56_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI56: // global
           _scHvJ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvJ::I64, 0)) goto ccI5l; else goto ccI5m;
       ccI5l: // global
           R2 = _scHvJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccI5m: // global
           R2 = _scHvJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_scHvM_entry() //  [R1]
         { info_tbl: [(ccI5v,
                       label: w7_scHvM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI5v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccI5w; else goto ccI5x;
       ccI5w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI5x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccI5s_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucI5J; else goto ccI5t;
       ucI5J: // global
           call _ccI5s(R1) args: 0, res: 0, upd: 0;
       ccI5t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccI5s() //  [R1]
         { info_tbl: [(ccI5s,
                       label: block_ccI5s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI5s: // global
           _scHvO::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvO::I64, 0)) goto ccI5H; else goto ccI5I;
       ccI5H: // global
           R2 = _scHvO::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccI5I: // global
           R2 = _scHvO::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w8_scHvR_entry() //  [R1]
         { info_tbl: [(ccI5R,
                       label: w8_scHvR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI5R: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccI5S; else goto ccI5T;
       ccI5S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI5T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccI5O_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucI65; else goto ccI5P;
       ucI65: // global
           call _ccI5O(R1) args: 0, res: 0, upd: 0;
       ccI5P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccI5O() //  [R1]
         { info_tbl: [(ccI5O,
                       label: block_ccI5O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI5O: // global
           _scHvT::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvT::I64, 0)) goto ccI63; else goto ccI64;
       ccI63: // global
           R2 = _scHvT::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccI64: // global
           R2 = _scHvT::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w9_scHvW_entry() //  [R1]
         { info_tbl: [(ccI6d,
                       label: w9_scHvW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI6d: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccI6e; else goto ccI6f;
       ccI6e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI6f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccI6a_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucI6r; else goto ccI6b;
       ucI6r: // global
           call _ccI6a(R1) args: 0, res: 0, upd: 0;
       ccI6b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccI6a() //  [R1]
         { info_tbl: [(ccI6a,
                       label: block_ccI6a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI6a: // global
           _scHvY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvY::I64, 0)) goto ccI6p; else goto ccI6q;
       ccI6p: // global
           R2 = _scHvY::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccI6q: // global
           R2 = _scHvY::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w10_scHw1_entry() //  [R1]
         { info_tbl: [(ccI6z,
                       label: w10_scHw1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI6z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccI6A; else goto ccI6B;
       ccI6A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI6B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccI6w_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucI6N; else goto ccI6x;
       ucI6N: // global
           call _ccI6w(R1) args: 0, res: 0, upd: 0;
       ccI6x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccI6w() //  [R1]
         { info_tbl: [(ccI6w,
                       label: block_ccI6w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI6w: // global
           _scHw3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHw3::I64, 0)) goto ccI6L; else goto ccI6M;
       ccI6L: // global
           R2 = _scHw3::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccI6M: // global
           R2 = _scHw3::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w11_scHw6_entry() //  [R1]
         { info_tbl: [(ccI6V,
                       label: w11_scHw6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI6V: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccI6W; else goto ccI6X;
       ccI6W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI6X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccI6S_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucI79; else goto ccI6T;
       ucI79: // global
           call _ccI6S(R1) args: 0, res: 0, upd: 0;
       ccI6T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccI6S() //  [R1]
         { info_tbl: [(ccI6S,
                       label: block_ccI6S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI6S: // global
           _scHw8::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHw8::I64, 0)) goto ccI77; else goto ccI78;
       ccI77: // global
           R2 = _scHw8::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccI78: // global
           R2 = _scHw8::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 f_scHwb_entry() //  [R1]
         { info_tbl: [(ccI7e,
                       label: f_scHwb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI7e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccI7f; else goto ccI7g;
       ccI7f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccI7g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           Sp = Sp - 16;
           call GHC.Stats.$fShowGCDetails_$cshowsPrec_entry(R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHww_entry() //  [R1]
         { info_tbl: [(ccIbS,
                       label: sat_scHww_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIbS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIbT; else goto ccIbU;
       ccIbT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIbU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = lvl15_rcHpK_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwx_entry() //  [R1]
         { info_tbl: [(ccIbV,
                       label: sat_scHwx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIbV: // global
           _scHwx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIbW; else goto ccIbX;
       ccIbX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIbZ; else goto ccIbY;
       ccIbZ: // global
           HpAlloc = 24;
           goto ccIbW;
       ccIbW: // global
           R1 = _scHwx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIbY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwx::P64;
           _scHwb::P64 = P64[_scHwx::P64 + 16];
           _scHwd::P64 = P64[_scHwx::P64 + 24];
           I64[Hp - 16] = sat_scHww_info;
           P64[Hp] = _scHwd::P64;
           R2 = Hp - 16;
           R1 = _scHwb::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwy_entry() //  [R1]
         { info_tbl: [(ccIc0,
                       label: sat_scHwy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIc0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccIc4; else goto ccIc3;
       ccIc4: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIc3: // global
           _scHwb::P64 = P64[R1 + 16];
           _scHwd::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_scHwx_info;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 24;
           R2 = lvl36_rcHq5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwz_entry() //  [R1]
         { info_tbl: [(ccIc5,
                       label: sat_scHwz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIc5: // global
           _scHwz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIc6; else goto ccIc7;
       ccIc7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccIc9; else goto ccIc8;
       ccIc9: // global
           HpAlloc = 32;
           goto ccIc6;
       ccIc6: // global
           R1 = _scHwz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIc8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwz::P64;
           _scHwb::P64 = P64[_scHwz::P64 + 16];
           _scHwd::P64 = P64[_scHwz::P64 + 24];
           I64[Hp - 24] = sat_scHwy_info;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwD_entry() //  [R1]
         { info_tbl: [(ccIca,
                       label: sat_scHwD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIca: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccIce; else goto ccIcf;
       ccIce: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIcf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccIbx_info;
           _scHwb::P64 = P64[R1 + 24];
           _scHwd::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucIcm; else goto ccIby;
       ucIcm: // global
           call _ccIbx(R1) args: 0, res: 0, upd: 0;
       ccIby: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIbx() //  [R1]
         { info_tbl: [(ccIbx,
                       label: block_ccIbx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIbx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccIci; else goto ccIch;
       ccIci: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccIch: // global
           _scHwv::I64 = I64[R1 + 7];
           I64[Hp - 24] = sat_scHwz_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_ccIcb_info;
           R4 = Hp - 24;
           R3 = _scHwv::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIcb() //  [R1, R2]
         { info_tbl: [(ccIcb,
                       label: block_ccIcb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIcb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIcl; else goto ccIck;
       ccIcl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIck: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwE_entry() //  [R1]
         { info_tbl: [(ccIcn,
                       label: sat_scHwE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIcn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccIcr; else goto ccIcq;
       ccIcr: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIcq: // global
           _scHve::P64 = P64[R1 + 16];
           _scHwb::P64 = P64[R1 + 24];
           _scHwd::P64 = P64[R1 + 32];
           I64[Hp - 32] = sat_scHwD_info;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 32;
           R2 = lvl35_rcHq4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwF_entry() //  [R1]
         { info_tbl: [(ccIcs,
                       label: sat_scHwF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIcs: // global
           _scHwF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIct; else goto ccIcu;
       ccIcu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccIcw; else goto ccIcv;
       ccIcw: // global
           HpAlloc = 40;
           goto ccIct;
       ccIct: // global
           R1 = _scHwF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIcv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwF::P64;
           _scHve::P64 = P64[_scHwF::P64 + 16];
           _scHwb::P64 = P64[_scHwF::P64 + 24];
           _scHwd::P64 = P64[_scHwF::P64 + 32];
           I64[Hp - 32] = sat_scHwE_info;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwJ_entry() //  [R1]
         { info_tbl: [(ccIcx,
                       label: sat_scHwJ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIcx: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccIcB; else goto ccIcC;
       ccIcB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIcC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccIbg_info;
           _scHve::P64 = P64[R1 + 24];
           _scHwb::P64 = P64[R1 + 32];
           _scHwd::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucIcJ; else goto ccIbh;
       ucIcJ: // global
           call _ccIbg(R1) args: 0, res: 0, upd: 0;
       ccIbh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIbg() //  [R1]
         { info_tbl: [(ccIbg,
                       label: block_ccIbg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIbg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccIcF; else goto ccIcE;
       ccIcF: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccIcE: // global
           _scHwt::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_scHwF_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_ccIcy_info;
           R4 = Hp - 32;
           R3 = _scHwt::I64;
           R2 = 0;
           Sp = Sp + 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIcy() //  [R1, R2]
         { info_tbl: [(ccIcy,
                       label: block_ccIcy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIcy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIcI; else goto ccIcH;
       ccIcI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIcH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwK_entry() //  [R1]
         { info_tbl: [(ccIcK,
                       label: sat_scHwK_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIcK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccIcO; else goto ccIcN;
       ccIcO: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIcN: // global
           _scHvd::P64 = P64[R1 + 16];
           _scHve::P64 = P64[R1 + 24];
           _scHwb::P64 = P64[R1 + 32];
           _scHwd::P64 = P64[R1 + 40];
           I64[Hp - 40] = sat_scHwJ_info;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 40;
           R2 = lvl34_rcHq3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwL_entry() //  [R1]
         { info_tbl: [(ccIcP,
                       label: sat_scHwL_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIcP: // global
           _scHwL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIcQ; else goto ccIcR;
       ccIcR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccIcT; else goto ccIcS;
       ccIcT: // global
           HpAlloc = 48;
           goto ccIcQ;
       ccIcQ: // global
           R1 = _scHwL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIcS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwL::P64;
           _scHvd::P64 = P64[_scHwL::P64 + 16];
           _scHve::P64 = P64[_scHwL::P64 + 24];
           _scHwb::P64 = P64[_scHwL::P64 + 32];
           _scHwd::P64 = P64[_scHwL::P64 + 40];
           I64[Hp - 40] = sat_scHwK_info;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 40;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwP_entry() //  [R1]
         { info_tbl: [(ccIcU,
                       label: sat_scHwP_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIcU: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccIcY; else goto ccIcZ;
       ccIcY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIcZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_ccIaZ_info;
           _scHvd::P64 = P64[R1 + 24];
           _scHve::P64 = P64[R1 + 32];
           _scHwb::P64 = P64[R1 + 40];
           _scHwd::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _scHvd::P64;
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ucId6; else goto ccIb0;
       ucId6: // global
           call _ccIaZ(R1) args: 0, res: 0, upd: 0;
       ccIb0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIaZ() //  [R1]
         { info_tbl: [(ccIaZ,
                       label: block_ccIaZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIaZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccId2; else goto ccId1;
       ccId2: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccId1: // global
           _scHwr::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_scHwL_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           I64[Sp + 32] = block_ccIcV_info;
           R4 = Hp - 40;
           R3 = _scHwr::I64;
           R2 = 0;
           Sp = Sp + 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIcV() //  [R1, R2]
         { info_tbl: [(ccIcV,
                       label: block_ccIcV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIcV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccId5; else goto ccId4;
       ccId5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccId4: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwQ_entry() //  [R1]
         { info_tbl: [(ccId7,
                       label: sat_scHwQ_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccId7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccIdb; else goto ccIda;
       ccIdb: // global
           HpAlloc = 56;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIda: // global
           _scHvc::P64 = P64[R1 + 16];
           _scHvd::P64 = P64[R1 + 24];
           _scHve::P64 = P64[R1 + 32];
           _scHwb::P64 = P64[R1 + 40];
           _scHwd::P64 = P64[R1 + 48];
           I64[Hp - 48] = sat_scHwP_info;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 48;
           R2 = lvl33_rcHq2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwR_entry() //  [R1]
         { info_tbl: [(ccIdc,
                       label: sat_scHwR_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIdc: // global
           _scHwR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIdd; else goto ccIde;
       ccIde: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccIdg; else goto ccIdf;
       ccIdg: // global
           HpAlloc = 56;
           goto ccIdd;
       ccIdd: // global
           R1 = _scHwR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIdf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwR::P64;
           _scHvc::P64 = P64[_scHwR::P64 + 16];
           _scHvd::P64 = P64[_scHwR::P64 + 24];
           _scHve::P64 = P64[_scHwR::P64 + 32];
           _scHwb::P64 = P64[_scHwR::P64 + 40];
           _scHwd::P64 = P64[_scHwR::P64 + 48];
           I64[Hp - 48] = sat_scHwQ_info;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 48;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwV_entry() //  [R1]
         { info_tbl: [(ccIdh,
                       label: sat_scHwV_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIdh: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccIdl; else goto ccIdm;
       ccIdl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIdm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_ccIaI_info;
           _scHvc::P64 = P64[R1 + 24];
           _scHvd::P64 = P64[R1 + 32];
           _scHve::P64 = P64[R1 + 40];
           _scHwb::P64 = P64[R1 + 48];
           _scHwd::P64 = P64[R1 + 56];
           R1 = P64[R1 + 16];
           P64[Sp - 56] = _scHvc::P64;
           P64[Sp - 48] = _scHvd::P64;
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ucIdt; else goto ccIaJ;
       ucIdt: // global
           call _ccIaI(R1) args: 0, res: 0, upd: 0;
       ccIaJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIaI() //  [R1]
         { info_tbl: [(ccIaI,
                       label: block_ccIaI_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIaI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccIdp; else goto ccIdo;
       ccIdp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccIdo: // global
           _scHwp::I64 = I64[R1 + 7];
           I64[Hp - 48] = sat_scHwR_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 40] = block_ccIdi_info;
           R4 = Hp - 48;
           R3 = _scHwp::I64;
           R2 = 0;
           Sp = Sp + 40;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIdi() //  [R1, R2]
         { info_tbl: [(ccIdi,
                       label: block_ccIdi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIdi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIds; else goto ccIdr;
       ccIds: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIdr: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwW_entry() //  [R1]
         { info_tbl: [(ccIdu,
                       label: sat_scHwW_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIdu: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccIdy; else goto ccIdx;
       ccIdy: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIdx: // global
           _scHvb::P64 = P64[R1 + 16];
           _scHvc::P64 = P64[R1 + 24];
           _scHvd::P64 = P64[R1 + 32];
           _scHve::P64 = P64[R1 + 40];
           _scHwb::P64 = P64[R1 + 48];
           _scHwd::P64 = P64[R1 + 56];
           I64[Hp - 56] = sat_scHwV_info;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 56;
           R2 = lvl32_rcHq1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwX_entry() //  [R1]
         { info_tbl: [(ccIdz,
                       label: sat_scHwX_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIdz: // global
           _scHwX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIdA; else goto ccIdB;
       ccIdB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccIdD; else goto ccIdC;
       ccIdD: // global
           HpAlloc = 64;
           goto ccIdA;
       ccIdA: // global
           R1 = _scHwX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIdC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwX::P64;
           _scHvb::P64 = P64[_scHwX::P64 + 16];
           _scHvc::P64 = P64[_scHwX::P64 + 24];
           _scHvd::P64 = P64[_scHwX::P64 + 32];
           _scHve::P64 = P64[_scHwX::P64 + 40];
           _scHwb::P64 = P64[_scHwX::P64 + 48];
           _scHwd::P64 = P64[_scHwX::P64 + 56];
           I64[Hp - 56] = sat_scHwW_info;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 56;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHx1_entry() //  [R1]
         { info_tbl: [(ccIdE,
                       label: sat_scHx1_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIdE: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccIdI; else goto ccIdJ;
       ccIdI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIdJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_ccIar_info;
           _scHvb::P64 = P64[R1 + 24];
           _scHvc::P64 = P64[R1 + 32];
           _scHvd::P64 = P64[R1 + 40];
           _scHve::P64 = P64[R1 + 48];
           _scHwb::P64 = P64[R1 + 56];
           _scHwd::P64 = P64[R1 + 64];
           R1 = P64[R1 + 16];
           P64[Sp - 64] = _scHvb::P64;
           P64[Sp - 56] = _scHvc::P64;
           P64[Sp - 48] = _scHvd::P64;
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto ucIdQ; else goto ccIas;
       ucIdQ: // global
           call _ccIar(R1) args: 0, res: 0, upd: 0;
       ccIas: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIar() //  [R1]
         { info_tbl: [(ccIar,
                       label: block_ccIar_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIar: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccIdM; else goto ccIdL;
       ccIdM: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccIdL: // global
           _scHwn::I64 = I64[R1 + 7];
           I64[Hp - 56] = sat_scHwX_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 48];
           I64[Sp + 48] = block_ccIdF_info;
           R4 = Hp - 56;
           R3 = _scHwn::I64;
           R2 = 0;
           Sp = Sp + 48;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIdF() //  [R1, R2]
         { info_tbl: [(ccIdF,
                       label: block_ccIdF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIdF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIdP; else goto ccIdO;
       ccIdP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIdO: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHx2_entry() //  [R1]
         { info_tbl: [(ccIdR,
                       label: sat_scHx2_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIdR: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccIdV; else goto ccIdU;
       ccIdV: // global
           HpAlloc = 72;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIdU: // global
           _scHva::P64 = P64[R1 + 16];
           _scHvb::P64 = P64[R1 + 24];
           _scHvc::P64 = P64[R1 + 32];
           _scHvd::P64 = P64[R1 + 40];
           _scHve::P64 = P64[R1 + 48];
           _scHwb::P64 = P64[R1 + 56];
           _scHwd::P64 = P64[R1 + 64];
           I64[Hp - 64] = sat_scHx1_info;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 64;
           R2 = lvl31_rcHq0_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHx3_entry() //  [R1]
         { info_tbl: [(ccIdW,
                       label: sat_scHx3_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIdW: // global
           _scHx3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIdX; else goto ccIdY;
       ccIdY: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccIe0; else goto ccIdZ;
       ccIe0: // global
           HpAlloc = 72;
           goto ccIdX;
       ccIdX: // global
           R1 = _scHx3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIdZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHx3::P64;
           _scHva::P64 = P64[_scHx3::P64 + 16];
           _scHvb::P64 = P64[_scHx3::P64 + 24];
           _scHvc::P64 = P64[_scHx3::P64 + 32];
           _scHvd::P64 = P64[_scHx3::P64 + 40];
           _scHve::P64 = P64[_scHx3::P64 + 48];
           _scHwb::P64 = P64[_scHx3::P64 + 56];
           _scHwd::P64 = P64[_scHx3::P64 + 64];
           I64[Hp - 64] = sat_scHx2_info;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 64;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHx7_entry() //  [R1]
         { info_tbl: [(ccIe1,
                       label: sat_scHx7_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIe1: // global
           if ((Sp + -80) < SpLim) (likely: False) goto ccIe5; else goto ccIe6;
       ccIe5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIe6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 80] = block_ccIaa_info;
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHwb::P64 = P64[R1 + 64];
           _scHwd::P64 = P64[R1 + 72];
           R1 = P64[R1 + 16];
           P64[Sp - 72] = _scHva::P64;
           P64[Sp - 64] = _scHvb::P64;
           P64[Sp - 56] = _scHvc::P64;
           P64[Sp - 48] = _scHvd::P64;
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto ucIed; else goto ccIab;
       ucIed: // global
           call _ccIaa(R1) args: 0, res: 0, upd: 0;
       ccIab: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIaa() //  [R1]
         { info_tbl: [(ccIaa,
                       label: block_ccIaa_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIaa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccIe9; else goto ccIe8;
       ccIe9: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccIe8: // global
           _scHwl::I64 = I64[R1 + 7];
           I64[Hp - 64] = sat_scHx3_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 56];
           I64[Sp + 56] = block_ccIe2_info;
           R4 = Hp - 64;
           R3 = _scHwl::I64;
           R2 = 0;
           Sp = Sp + 56;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIe2() //  [R1, R2]
         { info_tbl: [(ccIe2,
                       label: block_ccIe2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIe2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIec; else goto ccIeb;
       ccIec: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIeb: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHx8_entry() //  [R1]
         { info_tbl: [(ccIee,
                       label: sat_scHx8_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIee: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccIei; else goto ccIeh;
       ccIei: // global
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIeh: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHwb::P64 = P64[R1 + 64];
           _scHwd::P64 = P64[R1 + 72];
           I64[Hp - 72] = sat_scHx7_info;
           P64[Hp - 56] = _scHv9::P64;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 72;
           R2 = lvl30_rcHpZ_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHx9_entry() //  [R1]
         { info_tbl: [(ccIej,
                       label: sat_scHx9_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIej: // global
           _scHx9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIek; else goto ccIel;
       ccIel: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccIen; else goto ccIem;
       ccIen: // global
           HpAlloc = 80;
           goto ccIek;
       ccIek: // global
           R1 = _scHx9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIem: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHx9::P64;
           _scHv9::P64 = P64[_scHx9::P64 + 16];
           _scHva::P64 = P64[_scHx9::P64 + 24];
           _scHvb::P64 = P64[_scHx9::P64 + 32];
           _scHvc::P64 = P64[_scHx9::P64 + 40];
           _scHvd::P64 = P64[_scHx9::P64 + 48];
           _scHve::P64 = P64[_scHx9::P64 + 56];
           _scHwb::P64 = P64[_scHx9::P64 + 64];
           _scHwd::P64 = P64[_scHx9::P64 + 72];
           I64[Hp - 72] = sat_scHx8_info;
           P64[Hp - 56] = _scHv9::P64;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 72;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxd_entry() //  [R1]
         { info_tbl: [(ccIer,
                       label: sat_scHxd_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIer: // global
           _scHxd::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccIes; else goto ccIet;
       ccIet: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccIev; else goto ccIeu;
       ccIev: // global
           HpAlloc = 80;
           goto ccIes;
       ccIes: // global
           R1 = _scHxd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIeu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxd::P64;
           _scHv9::P64 = P64[_scHxd::P64 + 16];
           _scHva::P64 = P64[_scHxd::P64 + 24];
           _scHvb::P64 = P64[_scHxd::P64 + 32];
           _scHvc::P64 = P64[_scHxd::P64 + 40];
           _scHvd::P64 = P64[_scHxd::P64 + 48];
           _scHve::P64 = P64[_scHxd::P64 + 56];
           _scHw6::P64 = P64[_scHxd::P64 + 64];
           _scHwb::P64 = P64[_scHxd::P64 + 72];
           _scHwd::P64 = P64[_scHxd::P64 + 80];
           I64[Hp - 72] = sat_scHx9_info;
           P64[Hp - 56] = _scHv9::P64;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccIeo_info;
           R4 = Hp - 72;
           R3 = _scHw6::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIeo() //  [R1, R2]
         { info_tbl: [(ccIeo,
                       label: block_ccIeo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIeo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIey; else goto ccIex;
       ccIey: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIex: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxe_entry() //  [R1]
         { info_tbl: [(ccIez,
                       label: sat_scHxe_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIez: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccIeD; else goto ccIeC;
       ccIeD: // global
           HpAlloc = 88;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIeC: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHw6::P64 = P64[R1 + 64];
           _scHwb::P64 = P64[R1 + 72];
           _scHwd::P64 = P64[R1 + 80];
           I64[Hp - 80] = sat_scHxd_info;
           P64[Hp - 64] = _scHv9::P64;
           P64[Hp - 56] = _scHva::P64;
           P64[Hp - 48] = _scHvb::P64;
           P64[Hp - 40] = _scHvc::P64;
           P64[Hp - 32] = _scHvd::P64;
           P64[Hp - 24] = _scHve::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 80;
           R2 = lvl29_rcHpY_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxf_entry() //  [R1]
         { info_tbl: [(ccIeE,
                       label: sat_scHxf_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIeE: // global
           _scHxf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIeF; else goto ccIeG;
       ccIeG: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccIeI; else goto ccIeH;
       ccIeI: // global
           HpAlloc = 88;
           goto ccIeF;
       ccIeF: // global
           R1 = _scHxf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIeH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxf::P64;
           _scHv9::P64 = P64[_scHxf::P64 + 16];
           _scHva::P64 = P64[_scHxf::P64 + 24];
           _scHvb::P64 = P64[_scHxf::P64 + 32];
           _scHvc::P64 = P64[_scHxf::P64 + 40];
           _scHvd::P64 = P64[_scHxf::P64 + 48];
           _scHve::P64 = P64[_scHxf::P64 + 56];
           _scHw6::P64 = P64[_scHxf::P64 + 64];
           _scHwb::P64 = P64[_scHxf::P64 + 72];
           _scHwd::P64 = P64[_scHxf::P64 + 80];
           I64[Hp - 80] = sat_scHxe_info;
           P64[Hp - 64] = _scHv9::P64;
           P64[Hp - 56] = _scHva::P64;
           P64[Hp - 48] = _scHvb::P64;
           P64[Hp - 40] = _scHvc::P64;
           P64[Hp - 32] = _scHvd::P64;
           P64[Hp - 24] = _scHve::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 80;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxj_entry() //  [R1]
         { info_tbl: [(ccIeM,
                       label: sat_scHxj_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIeM: // global
           _scHxj::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccIeN; else goto ccIeO;
       ccIeO: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccIeQ; else goto ccIeP;
       ccIeQ: // global
           HpAlloc = 88;
           goto ccIeN;
       ccIeN: // global
           R1 = _scHxj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIeP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxj::P64;
           _scHv9::P64 = P64[_scHxj::P64 + 16];
           _scHva::P64 = P64[_scHxj::P64 + 24];
           _scHvb::P64 = P64[_scHxj::P64 + 32];
           _scHvc::P64 = P64[_scHxj::P64 + 40];
           _scHvd::P64 = P64[_scHxj::P64 + 48];
           _scHve::P64 = P64[_scHxj::P64 + 56];
           _scHw1::P64 = P64[_scHxj::P64 + 64];
           _scHw6::P64 = P64[_scHxj::P64 + 72];
           _scHwb::P64 = P64[_scHxj::P64 + 80];
           _scHwd::P64 = P64[_scHxj::P64 + 88];
           I64[Hp - 80] = sat_scHxf_info;
           P64[Hp - 64] = _scHv9::P64;
           P64[Hp - 56] = _scHva::P64;
           P64[Hp - 48] = _scHvb::P64;
           P64[Hp - 40] = _scHvc::P64;
           P64[Hp - 32] = _scHvd::P64;
           P64[Hp - 24] = _scHve::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccIeJ_info;
           R4 = Hp - 80;
           R3 = _scHw1::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIeJ() //  [R1, R2]
         { info_tbl: [(ccIeJ,
                       label: block_ccIeJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIeJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIeT; else goto ccIeS;
       ccIeT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIeS: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxk_entry() //  [R1]
         { info_tbl: [(ccIeU,
                       label: sat_scHxk_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIeU: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccIeY; else goto ccIeX;
       ccIeY: // global
           HpAlloc = 96;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIeX: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHw1::P64 = P64[R1 + 64];
           _scHw6::P64 = P64[R1 + 72];
           _scHwb::P64 = P64[R1 + 80];
           _scHwd::P64 = P64[R1 + 88];
           I64[Hp - 88] = sat_scHxj_info;
           P64[Hp - 72] = _scHv9::P64;
           P64[Hp - 64] = _scHva::P64;
           P64[Hp - 56] = _scHvb::P64;
           P64[Hp - 48] = _scHvc::P64;
           P64[Hp - 40] = _scHvd::P64;
           P64[Hp - 32] = _scHve::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 88;
           R2 = lvl28_rcHpX_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxl_entry() //  [R1]
         { info_tbl: [(ccIeZ,
                       label: sat_scHxl_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIeZ: // global
           _scHxl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIf0; else goto ccIf1;
       ccIf1: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccIf3; else goto ccIf2;
       ccIf3: // global
           HpAlloc = 96;
           goto ccIf0;
       ccIf0: // global
           R1 = _scHxl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIf2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxl::P64;
           _scHv9::P64 = P64[_scHxl::P64 + 16];
           _scHva::P64 = P64[_scHxl::P64 + 24];
           _scHvb::P64 = P64[_scHxl::P64 + 32];
           _scHvc::P64 = P64[_scHxl::P64 + 40];
           _scHvd::P64 = P64[_scHxl::P64 + 48];
           _scHve::P64 = P64[_scHxl::P64 + 56];
           _scHw1::P64 = P64[_scHxl::P64 + 64];
           _scHw6::P64 = P64[_scHxl::P64 + 72];
           _scHwb::P64 = P64[_scHxl::P64 + 80];
           _scHwd::P64 = P64[_scHxl::P64 + 88];
           I64[Hp - 88] = sat_scHxk_info;
           P64[Hp - 72] = _scHv9::P64;
           P64[Hp - 64] = _scHva::P64;
           P64[Hp - 56] = _scHvb::P64;
           P64[Hp - 48] = _scHvc::P64;
           P64[Hp - 40] = _scHvd::P64;
           P64[Hp - 32] = _scHve::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 88;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxp_entry() //  [R1]
         { info_tbl: [(ccIf7,
                       label: sat_scHxp_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIf7: // global
           _scHxp::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccIf8; else goto ccIf9;
       ccIf9: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccIfb; else goto ccIfa;
       ccIfb: // global
           HpAlloc = 96;
           goto ccIf8;
       ccIf8: // global
           R1 = _scHxp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIfa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxp::P64;
           _scHv9::P64 = P64[_scHxp::P64 + 16];
           _scHva::P64 = P64[_scHxp::P64 + 24];
           _scHvb::P64 = P64[_scHxp::P64 + 32];
           _scHvc::P64 = P64[_scHxp::P64 + 40];
           _scHvd::P64 = P64[_scHxp::P64 + 48];
           _scHve::P64 = P64[_scHxp::P64 + 56];
           _scHvW::P64 = P64[_scHxp::P64 + 64];
           _scHw1::P64 = P64[_scHxp::P64 + 72];
           _scHw6::P64 = P64[_scHxp::P64 + 80];
           _scHwb::P64 = P64[_scHxp::P64 + 88];
           _scHwd::P64 = P64[_scHxp::P64 + 96];
           I64[Hp - 88] = sat_scHxl_info;
           P64[Hp - 72] = _scHv9::P64;
           P64[Hp - 64] = _scHva::P64;
           P64[Hp - 56] = _scHvb::P64;
           P64[Hp - 48] = _scHvc::P64;
           P64[Hp - 40] = _scHvd::P64;
           P64[Hp - 32] = _scHve::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccIf4_info;
           R4 = Hp - 88;
           R3 = _scHvW::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIf4() //  [R1, R2]
         { info_tbl: [(ccIf4,
                       label: block_ccIf4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIf4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIfe; else goto ccIfd;
       ccIfe: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIfd: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxq_entry() //  [R1]
         { info_tbl: [(ccIff,
                       label: sat_scHxq_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIff: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccIfj; else goto ccIfi;
       ccIfj: // global
           HpAlloc = 104;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIfi: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvW::P64 = P64[R1 + 64];
           _scHw1::P64 = P64[R1 + 72];
           _scHw6::P64 = P64[R1 + 80];
           _scHwb::P64 = P64[R1 + 88];
           _scHwd::P64 = P64[R1 + 96];
           I64[Hp - 96] = sat_scHxp_info;
           P64[Hp - 80] = _scHv9::P64;
           P64[Hp - 72] = _scHva::P64;
           P64[Hp - 64] = _scHvb::P64;
           P64[Hp - 56] = _scHvc::P64;
           P64[Hp - 48] = _scHvd::P64;
           P64[Hp - 40] = _scHve::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 96;
           R2 = lvl27_rcHpW_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxr_entry() //  [R1]
         { info_tbl: [(ccIfk,
                       label: sat_scHxr_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIfk: // global
           _scHxr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIfl; else goto ccIfm;
       ccIfm: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccIfo; else goto ccIfn;
       ccIfo: // global
           HpAlloc = 104;
           goto ccIfl;
       ccIfl: // global
           R1 = _scHxr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIfn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxr::P64;
           _scHv9::P64 = P64[_scHxr::P64 + 16];
           _scHva::P64 = P64[_scHxr::P64 + 24];
           _scHvb::P64 = P64[_scHxr::P64 + 32];
           _scHvc::P64 = P64[_scHxr::P64 + 40];
           _scHvd::P64 = P64[_scHxr::P64 + 48];
           _scHve::P64 = P64[_scHxr::P64 + 56];
           _scHvW::P64 = P64[_scHxr::P64 + 64];
           _scHw1::P64 = P64[_scHxr::P64 + 72];
           _scHw6::P64 = P64[_scHxr::P64 + 80];
           _scHwb::P64 = P64[_scHxr::P64 + 88];
           _scHwd::P64 = P64[_scHxr::P64 + 96];
           I64[Hp - 96] = sat_scHxq_info;
           P64[Hp - 80] = _scHv9::P64;
           P64[Hp - 72] = _scHva::P64;
           P64[Hp - 64] = _scHvb::P64;
           P64[Hp - 56] = _scHvc::P64;
           P64[Hp - 48] = _scHvd::P64;
           P64[Hp - 40] = _scHve::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 96;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxv_entry() //  [R1]
         { info_tbl: [(ccIfs,
                       label: sat_scHxv_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIfs: // global
           _scHxv::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccIft; else goto ccIfu;
       ccIfu: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccIfw; else goto ccIfv;
       ccIfw: // global
           HpAlloc = 104;
           goto ccIft;
       ccIft: // global
           R1 = _scHxv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIfv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxv::P64;
           _scHv9::P64 = P64[_scHxv::P64 + 16];
           _scHva::P64 = P64[_scHxv::P64 + 24];
           _scHvb::P64 = P64[_scHxv::P64 + 32];
           _scHvc::P64 = P64[_scHxv::P64 + 40];
           _scHvd::P64 = P64[_scHxv::P64 + 48];
           _scHve::P64 = P64[_scHxv::P64 + 56];
           _scHvR::P64 = P64[_scHxv::P64 + 64];
           _scHvW::P64 = P64[_scHxv::P64 + 72];
           _scHw1::P64 = P64[_scHxv::P64 + 80];
           _scHw6::P64 = P64[_scHxv::P64 + 88];
           _scHwb::P64 = P64[_scHxv::P64 + 96];
           _scHwd::P64 = P64[_scHxv::P64 + 104];
           I64[Hp - 96] = sat_scHxr_info;
           P64[Hp - 80] = _scHv9::P64;
           P64[Hp - 72] = _scHva::P64;
           P64[Hp - 64] = _scHvb::P64;
           P64[Hp - 56] = _scHvc::P64;
           P64[Hp - 48] = _scHvd::P64;
           P64[Hp - 40] = _scHve::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccIfp_info;
           R4 = Hp - 96;
           R3 = _scHvR::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIfp() //  [R1, R2]
         { info_tbl: [(ccIfp,
                       label: block_ccIfp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIfp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIfz; else goto ccIfy;
       ccIfz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIfy: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxw_entry() //  [R1]
         { info_tbl: [(ccIfA,
                       label: sat_scHxw_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIfA: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccIfE; else goto ccIfD;
       ccIfE: // global
           HpAlloc = 112;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIfD: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvR::P64 = P64[R1 + 64];
           _scHvW::P64 = P64[R1 + 72];
           _scHw1::P64 = P64[R1 + 80];
           _scHw6::P64 = P64[R1 + 88];
           _scHwb::P64 = P64[R1 + 96];
           _scHwd::P64 = P64[R1 + 104];
           I64[Hp - 104] = sat_scHxv_info;
           P64[Hp - 88] = _scHv9::P64;
           P64[Hp - 80] = _scHva::P64;
           P64[Hp - 72] = _scHvb::P64;
           P64[Hp - 64] = _scHvc::P64;
           P64[Hp - 56] = _scHvd::P64;
           P64[Hp - 48] = _scHve::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 104;
           R2 = lvl26_rcHpV_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxx_entry() //  [R1]
         { info_tbl: [(ccIfF,
                       label: sat_scHxx_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIfF: // global
           _scHxx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIfG; else goto ccIfH;
       ccIfH: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccIfJ; else goto ccIfI;
       ccIfJ: // global
           HpAlloc = 112;
           goto ccIfG;
       ccIfG: // global
           R1 = _scHxx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIfI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxx::P64;
           _scHv9::P64 = P64[_scHxx::P64 + 16];
           _scHva::P64 = P64[_scHxx::P64 + 24];
           _scHvb::P64 = P64[_scHxx::P64 + 32];
           _scHvc::P64 = P64[_scHxx::P64 + 40];
           _scHvd::P64 = P64[_scHxx::P64 + 48];
           _scHve::P64 = P64[_scHxx::P64 + 56];
           _scHvR::P64 = P64[_scHxx::P64 + 64];
           _scHvW::P64 = P64[_scHxx::P64 + 72];
           _scHw1::P64 = P64[_scHxx::P64 + 80];
           _scHw6::P64 = P64[_scHxx::P64 + 88];
           _scHwb::P64 = P64[_scHxx::P64 + 96];
           _scHwd::P64 = P64[_scHxx::P64 + 104];
           I64[Hp - 104] = sat_scHxw_info;
           P64[Hp - 88] = _scHv9::P64;
           P64[Hp - 80] = _scHva::P64;
           P64[Hp - 72] = _scHvb::P64;
           P64[Hp - 64] = _scHvc::P64;
           P64[Hp - 56] = _scHvd::P64;
           P64[Hp - 48] = _scHve::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 104;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxB_entry() //  [R1]
         { info_tbl: [(ccIfN,
                       label: sat_scHxB_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIfN: // global
           _scHxB::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccIfO; else goto ccIfP;
       ccIfP: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccIfR; else goto ccIfQ;
       ccIfR: // global
           HpAlloc = 112;
           goto ccIfO;
       ccIfO: // global
           R1 = _scHxB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIfQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxB::P64;
           _scHv9::P64 = P64[_scHxB::P64 + 16];
           _scHva::P64 = P64[_scHxB::P64 + 24];
           _scHvb::P64 = P64[_scHxB::P64 + 32];
           _scHvc::P64 = P64[_scHxB::P64 + 40];
           _scHvd::P64 = P64[_scHxB::P64 + 48];
           _scHve::P64 = P64[_scHxB::P64 + 56];
           _scHvM::P64 = P64[_scHxB::P64 + 64];
           _scHvR::P64 = P64[_scHxB::P64 + 72];
           _scHvW::P64 = P64[_scHxB::P64 + 80];
           _scHw1::P64 = P64[_scHxB::P64 + 88];
           _scHw6::P64 = P64[_scHxB::P64 + 96];
           _scHwb::P64 = P64[_scHxB::P64 + 104];
           _scHwd::P64 = P64[_scHxB::P64 + 112];
           I64[Hp - 104] = sat_scHxx_info;
           P64[Hp - 88] = _scHv9::P64;
           P64[Hp - 80] = _scHva::P64;
           P64[Hp - 72] = _scHvb::P64;
           P64[Hp - 64] = _scHvc::P64;
           P64[Hp - 56] = _scHvd::P64;
           P64[Hp - 48] = _scHve::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccIfK_info;
           R4 = Hp - 104;
           R3 = _scHvM::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIfK() //  [R1, R2]
         { info_tbl: [(ccIfK,
                       label: block_ccIfK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIfK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIfU; else goto ccIfT;
       ccIfU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIfT: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxC_entry() //  [R1]
         { info_tbl: [(ccIfV,
                       label: sat_scHxC_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIfV: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccIfZ; else goto ccIfY;
       ccIfZ: // global
           HpAlloc = 120;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIfY: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvM::P64 = P64[R1 + 64];
           _scHvR::P64 = P64[R1 + 72];
           _scHvW::P64 = P64[R1 + 80];
           _scHw1::P64 = P64[R1 + 88];
           _scHw6::P64 = P64[R1 + 96];
           _scHwb::P64 = P64[R1 + 104];
           _scHwd::P64 = P64[R1 + 112];
           I64[Hp - 112] = sat_scHxB_info;
           P64[Hp - 96] = _scHv9::P64;
           P64[Hp - 88] = _scHva::P64;
           P64[Hp - 80] = _scHvb::P64;
           P64[Hp - 72] = _scHvc::P64;
           P64[Hp - 64] = _scHvd::P64;
           P64[Hp - 56] = _scHve::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 112;
           R2 = lvl25_rcHpU_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxD_entry() //  [R1]
         { info_tbl: [(ccIg0,
                       label: sat_scHxD_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIg0: // global
           _scHxD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIg1; else goto ccIg2;
       ccIg2: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccIg4; else goto ccIg3;
       ccIg4: // global
           HpAlloc = 120;
           goto ccIg1;
       ccIg1: // global
           R1 = _scHxD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIg3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxD::P64;
           _scHv9::P64 = P64[_scHxD::P64 + 16];
           _scHva::P64 = P64[_scHxD::P64 + 24];
           _scHvb::P64 = P64[_scHxD::P64 + 32];
           _scHvc::P64 = P64[_scHxD::P64 + 40];
           _scHvd::P64 = P64[_scHxD::P64 + 48];
           _scHve::P64 = P64[_scHxD::P64 + 56];
           _scHvM::P64 = P64[_scHxD::P64 + 64];
           _scHvR::P64 = P64[_scHxD::P64 + 72];
           _scHvW::P64 = P64[_scHxD::P64 + 80];
           _scHw1::P64 = P64[_scHxD::P64 + 88];
           _scHw6::P64 = P64[_scHxD::P64 + 96];
           _scHwb::P64 = P64[_scHxD::P64 + 104];
           _scHwd::P64 = P64[_scHxD::P64 + 112];
           I64[Hp - 112] = sat_scHxC_info;
           P64[Hp - 96] = _scHv9::P64;
           P64[Hp - 88] = _scHva::P64;
           P64[Hp - 80] = _scHvb::P64;
           P64[Hp - 72] = _scHvc::P64;
           P64[Hp - 64] = _scHvd::P64;
           P64[Hp - 56] = _scHve::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 112;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxH_entry() //  [R1]
         { info_tbl: [(ccIg8,
                       label: sat_scHxH_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIg8: // global
           _scHxH::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccIg9; else goto ccIga;
       ccIga: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccIgc; else goto ccIgb;
       ccIgc: // global
           HpAlloc = 120;
           goto ccIg9;
       ccIg9: // global
           R1 = _scHxH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIgb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxH::P64;
           _scHv9::P64 = P64[_scHxH::P64 + 16];
           _scHva::P64 = P64[_scHxH::P64 + 24];
           _scHvb::P64 = P64[_scHxH::P64 + 32];
           _scHvc::P64 = P64[_scHxH::P64 + 40];
           _scHvd::P64 = P64[_scHxH::P64 + 48];
           _scHve::P64 = P64[_scHxH::P64 + 56];
           _scHvH::P64 = P64[_scHxH::P64 + 64];
           _scHvM::P64 = P64[_scHxH::P64 + 72];
           _scHvR::P64 = P64[_scHxH::P64 + 80];
           _scHvW::P64 = P64[_scHxH::P64 + 88];
           _scHw1::P64 = P64[_scHxH::P64 + 96];
           _scHw6::P64 = P64[_scHxH::P64 + 104];
           _scHwb::P64 = P64[_scHxH::P64 + 112];
           _scHwd::P64 = P64[_scHxH::P64 + 120];
           I64[Hp - 112] = sat_scHxD_info;
           P64[Hp - 96] = _scHv9::P64;
           P64[Hp - 88] = _scHva::P64;
           P64[Hp - 80] = _scHvb::P64;
           P64[Hp - 72] = _scHvc::P64;
           P64[Hp - 64] = _scHvd::P64;
           P64[Hp - 56] = _scHve::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccIg5_info;
           R4 = Hp - 112;
           R3 = _scHvH::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIg5() //  [R1, R2]
         { info_tbl: [(ccIg5,
                       label: block_ccIg5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIg5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIgf; else goto ccIge;
       ccIgf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIge: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxI_entry() //  [R1]
         { info_tbl: [(ccIgg,
                       label: sat_scHxI_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIgg: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccIgk; else goto ccIgj;
       ccIgk: // global
           HpAlloc = 128;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIgj: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvH::P64 = P64[R1 + 64];
           _scHvM::P64 = P64[R1 + 72];
           _scHvR::P64 = P64[R1 + 80];
           _scHvW::P64 = P64[R1 + 88];
           _scHw1::P64 = P64[R1 + 96];
           _scHw6::P64 = P64[R1 + 104];
           _scHwb::P64 = P64[R1 + 112];
           _scHwd::P64 = P64[R1 + 120];
           I64[Hp - 120] = sat_scHxH_info;
           P64[Hp - 104] = _scHv9::P64;
           P64[Hp - 96] = _scHva::P64;
           P64[Hp - 88] = _scHvb::P64;
           P64[Hp - 80] = _scHvc::P64;
           P64[Hp - 72] = _scHvd::P64;
           P64[Hp - 64] = _scHve::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 120;
           R2 = lvl24_rcHpT_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxJ_entry() //  [R1]
         { info_tbl: [(ccIgl,
                       label: sat_scHxJ_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIgl: // global
           _scHxJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIgm; else goto ccIgn;
       ccIgn: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccIgp; else goto ccIgo;
       ccIgp: // global
           HpAlloc = 128;
           goto ccIgm;
       ccIgm: // global
           R1 = _scHxJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIgo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxJ::P64;
           _scHv9::P64 = P64[_scHxJ::P64 + 16];
           _scHva::P64 = P64[_scHxJ::P64 + 24];
           _scHvb::P64 = P64[_scHxJ::P64 + 32];
           _scHvc::P64 = P64[_scHxJ::P64 + 40];
           _scHvd::P64 = P64[_scHxJ::P64 + 48];
           _scHve::P64 = P64[_scHxJ::P64 + 56];
           _scHvH::P64 = P64[_scHxJ::P64 + 64];
           _scHvM::P64 = P64[_scHxJ::P64 + 72];
           _scHvR::P64 = P64[_scHxJ::P64 + 80];
           _scHvW::P64 = P64[_scHxJ::P64 + 88];
           _scHw1::P64 = P64[_scHxJ::P64 + 96];
           _scHw6::P64 = P64[_scHxJ::P64 + 104];
           _scHwb::P64 = P64[_scHxJ::P64 + 112];
           _scHwd::P64 = P64[_scHxJ::P64 + 120];
           I64[Hp - 120] = sat_scHxI_info;
           P64[Hp - 104] = _scHv9::P64;
           P64[Hp - 96] = _scHva::P64;
           P64[Hp - 88] = _scHvb::P64;
           P64[Hp - 80] = _scHvc::P64;
           P64[Hp - 72] = _scHvd::P64;
           P64[Hp - 64] = _scHve::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 120;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxN_entry() //  [R1]
         { info_tbl: [(ccIgt,
                       label: sat_scHxN_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIgt: // global
           _scHxN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccIgu; else goto ccIgv;
       ccIgv: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccIgx; else goto ccIgw;
       ccIgx: // global
           HpAlloc = 128;
           goto ccIgu;
       ccIgu: // global
           R1 = _scHxN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIgw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxN::P64;
           _scHv9::P64 = P64[_scHxN::P64 + 16];
           _scHva::P64 = P64[_scHxN::P64 + 24];
           _scHvb::P64 = P64[_scHxN::P64 + 32];
           _scHvc::P64 = P64[_scHxN::P64 + 40];
           _scHvd::P64 = P64[_scHxN::P64 + 48];
           _scHve::P64 = P64[_scHxN::P64 + 56];
           _scHvC::P64 = P64[_scHxN::P64 + 64];
           _scHvH::P64 = P64[_scHxN::P64 + 72];
           _scHvM::P64 = P64[_scHxN::P64 + 80];
           _scHvR::P64 = P64[_scHxN::P64 + 88];
           _scHvW::P64 = P64[_scHxN::P64 + 96];
           _scHw1::P64 = P64[_scHxN::P64 + 104];
           _scHw6::P64 = P64[_scHxN::P64 + 112];
           _scHwb::P64 = P64[_scHxN::P64 + 120];
           _scHwd::P64 = P64[_scHxN::P64 + 128];
           I64[Hp - 120] = sat_scHxJ_info;
           P64[Hp - 104] = _scHv9::P64;
           P64[Hp - 96] = _scHva::P64;
           P64[Hp - 88] = _scHvb::P64;
           P64[Hp - 80] = _scHvc::P64;
           P64[Hp - 72] = _scHvd::P64;
           P64[Hp - 64] = _scHve::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccIgq_info;
           R4 = Hp - 120;
           R3 = _scHvC::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIgq() //  [R1, R2]
         { info_tbl: [(ccIgq,
                       label: block_ccIgq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIgq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIgA; else goto ccIgz;
       ccIgA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIgz: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxO_entry() //  [R1]
         { info_tbl: [(ccIgB,
                       label: sat_scHxO_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIgB: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccIgF; else goto ccIgE;
       ccIgF: // global
           HpAlloc = 136;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIgE: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvC::P64 = P64[R1 + 64];
           _scHvH::P64 = P64[R1 + 72];
           _scHvM::P64 = P64[R1 + 80];
           _scHvR::P64 = P64[R1 + 88];
           _scHvW::P64 = P64[R1 + 96];
           _scHw1::P64 = P64[R1 + 104];
           _scHw6::P64 = P64[R1 + 112];
           _scHwb::P64 = P64[R1 + 120];
           _scHwd::P64 = P64[R1 + 128];
           I64[Hp - 128] = sat_scHxN_info;
           P64[Hp - 112] = _scHv9::P64;
           P64[Hp - 104] = _scHva::P64;
           P64[Hp - 96] = _scHvb::P64;
           P64[Hp - 88] = _scHvc::P64;
           P64[Hp - 80] = _scHvd::P64;
           P64[Hp - 72] = _scHve::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 128;
           R2 = lvl23_rcHpS_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxP_entry() //  [R1]
         { info_tbl: [(ccIgG,
                       label: sat_scHxP_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIgG: // global
           _scHxP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIgH; else goto ccIgI;
       ccIgI: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccIgK; else goto ccIgJ;
       ccIgK: // global
           HpAlloc = 136;
           goto ccIgH;
       ccIgH: // global
           R1 = _scHxP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIgJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxP::P64;
           _scHv9::P64 = P64[_scHxP::P64 + 16];
           _scHva::P64 = P64[_scHxP::P64 + 24];
           _scHvb::P64 = P64[_scHxP::P64 + 32];
           _scHvc::P64 = P64[_scHxP::P64 + 40];
           _scHvd::P64 = P64[_scHxP::P64 + 48];
           _scHve::P64 = P64[_scHxP::P64 + 56];
           _scHvC::P64 = P64[_scHxP::P64 + 64];
           _scHvH::P64 = P64[_scHxP::P64 + 72];
           _scHvM::P64 = P64[_scHxP::P64 + 80];
           _scHvR::P64 = P64[_scHxP::P64 + 88];
           _scHvW::P64 = P64[_scHxP::P64 + 96];
           _scHw1::P64 = P64[_scHxP::P64 + 104];
           _scHw6::P64 = P64[_scHxP::P64 + 112];
           _scHwb::P64 = P64[_scHxP::P64 + 120];
           _scHwd::P64 = P64[_scHxP::P64 + 128];
           I64[Hp - 128] = sat_scHxO_info;
           P64[Hp - 112] = _scHv9::P64;
           P64[Hp - 104] = _scHva::P64;
           P64[Hp - 96] = _scHvb::P64;
           P64[Hp - 88] = _scHvc::P64;
           P64[Hp - 80] = _scHvd::P64;
           P64[Hp - 72] = _scHve::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 128;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxT_entry() //  [R1]
         { info_tbl: [(ccIgO,
                       label: sat_scHxT_info
                       rep:HeapRep 16 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIgO: // global
           _scHxT::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccIgP; else goto ccIgQ;
       ccIgQ: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccIgS; else goto ccIgR;
       ccIgS: // global
           HpAlloc = 136;
           goto ccIgP;
       ccIgP: // global
           R1 = _scHxT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIgR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxT::P64;
           _scHv9::P64 = P64[_scHxT::P64 + 16];
           _scHva::P64 = P64[_scHxT::P64 + 24];
           _scHvb::P64 = P64[_scHxT::P64 + 32];
           _scHvc::P64 = P64[_scHxT::P64 + 40];
           _scHvd::P64 = P64[_scHxT::P64 + 48];
           _scHve::P64 = P64[_scHxT::P64 + 56];
           _scHvx::P64 = P64[_scHxT::P64 + 64];
           _scHvC::P64 = P64[_scHxT::P64 + 72];
           _scHvH::P64 = P64[_scHxT::P64 + 80];
           _scHvM::P64 = P64[_scHxT::P64 + 88];
           _scHvR::P64 = P64[_scHxT::P64 + 96];
           _scHvW::P64 = P64[_scHxT::P64 + 104];
           _scHw1::P64 = P64[_scHxT::P64 + 112];
           _scHw6::P64 = P64[_scHxT::P64 + 120];
           _scHwb::P64 = P64[_scHxT::P64 + 128];
           _scHwd::P64 = P64[_scHxT::P64 + 136];
           I64[Hp - 128] = sat_scHxP_info;
           P64[Hp - 112] = _scHv9::P64;
           P64[Hp - 104] = _scHva::P64;
           P64[Hp - 96] = _scHvb::P64;
           P64[Hp - 88] = _scHvc::P64;
           P64[Hp - 80] = _scHvd::P64;
           P64[Hp - 72] = _scHve::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccIgL_info;
           R4 = Hp - 128;
           R3 = _scHvx::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIgL() //  [R1, R2]
         { info_tbl: [(ccIgL,
                       label: block_ccIgL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIgL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIgV; else goto ccIgU;
       ccIgV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIgU: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxU_entry() //  [R1]
         { info_tbl: [(ccIgW,
                       label: sat_scHxU_info
                       rep:HeapRep 16 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIgW: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccIh0; else goto ccIgZ;
       ccIh0: // global
           HpAlloc = 144;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIgZ: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvx::P64 = P64[R1 + 64];
           _scHvC::P64 = P64[R1 + 72];
           _scHvH::P64 = P64[R1 + 80];
           _scHvM::P64 = P64[R1 + 88];
           _scHvR::P64 = P64[R1 + 96];
           _scHvW::P64 = P64[R1 + 104];
           _scHw1::P64 = P64[R1 + 112];
           _scHw6::P64 = P64[R1 + 120];
           _scHwb::P64 = P64[R1 + 128];
           _scHwd::P64 = P64[R1 + 136];
           I64[Hp - 136] = sat_scHxT_info;
           P64[Hp - 120] = _scHv9::P64;
           P64[Hp - 112] = _scHva::P64;
           P64[Hp - 104] = _scHvb::P64;
           P64[Hp - 96] = _scHvc::P64;
           P64[Hp - 88] = _scHvd::P64;
           P64[Hp - 80] = _scHve::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 136;
           R2 = lvl22_rcHpR_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxV_entry() //  [R1]
         { info_tbl: [(ccIh1,
                       label: sat_scHxV_info
                       rep:HeapRep 16 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIh1: // global
           _scHxV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIh2; else goto ccIh3;
       ccIh3: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccIh5; else goto ccIh4;
       ccIh5: // global
           HpAlloc = 144;
           goto ccIh2;
       ccIh2: // global
           R1 = _scHxV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIh4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxV::P64;
           _scHv9::P64 = P64[_scHxV::P64 + 16];
           _scHva::P64 = P64[_scHxV::P64 + 24];
           _scHvb::P64 = P64[_scHxV::P64 + 32];
           _scHvc::P64 = P64[_scHxV::P64 + 40];
           _scHvd::P64 = P64[_scHxV::P64 + 48];
           _scHve::P64 = P64[_scHxV::P64 + 56];
           _scHvx::P64 = P64[_scHxV::P64 + 64];
           _scHvC::P64 = P64[_scHxV::P64 + 72];
           _scHvH::P64 = P64[_scHxV::P64 + 80];
           _scHvM::P64 = P64[_scHxV::P64 + 88];
           _scHvR::P64 = P64[_scHxV::P64 + 96];
           _scHvW::P64 = P64[_scHxV::P64 + 104];
           _scHw1::P64 = P64[_scHxV::P64 + 112];
           _scHw6::P64 = P64[_scHxV::P64 + 120];
           _scHwb::P64 = P64[_scHxV::P64 + 128];
           _scHwd::P64 = P64[_scHxV::P64 + 136];
           I64[Hp - 136] = sat_scHxU_info;
           P64[Hp - 120] = _scHv9::P64;
           P64[Hp - 112] = _scHva::P64;
           P64[Hp - 104] = _scHvb::P64;
           P64[Hp - 96] = _scHvc::P64;
           P64[Hp - 88] = _scHvd::P64;
           P64[Hp - 80] = _scHve::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 136;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxZ_entry() //  [R1]
         { info_tbl: [(ccIh9,
                       label: sat_scHxZ_info
                       rep:HeapRep 17 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIh9: // global
           _scHxZ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccIha; else goto ccIhb;
       ccIhb: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccIhd; else goto ccIhc;
       ccIhd: // global
           HpAlloc = 144;
           goto ccIha;
       ccIha: // global
           R1 = _scHxZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIhc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxZ::P64;
           _scHv9::P64 = P64[_scHxZ::P64 + 16];
           _scHva::P64 = P64[_scHxZ::P64 + 24];
           _scHvb::P64 = P64[_scHxZ::P64 + 32];
           _scHvc::P64 = P64[_scHxZ::P64 + 40];
           _scHvd::P64 = P64[_scHxZ::P64 + 48];
           _scHve::P64 = P64[_scHxZ::P64 + 56];
           _scHvs::P64 = P64[_scHxZ::P64 + 64];
           _scHvx::P64 = P64[_scHxZ::P64 + 72];
           _scHvC::P64 = P64[_scHxZ::P64 + 80];
           _scHvH::P64 = P64[_scHxZ::P64 + 88];
           _scHvM::P64 = P64[_scHxZ::P64 + 96];
           _scHvR::P64 = P64[_scHxZ::P64 + 104];
           _scHvW::P64 = P64[_scHxZ::P64 + 112];
           _scHw1::P64 = P64[_scHxZ::P64 + 120];
           _scHw6::P64 = P64[_scHxZ::P64 + 128];
           _scHwb::P64 = P64[_scHxZ::P64 + 136];
           _scHwd::P64 = P64[_scHxZ::P64 + 144];
           I64[Hp - 136] = sat_scHxV_info;
           P64[Hp - 120] = _scHv9::P64;
           P64[Hp - 112] = _scHva::P64;
           P64[Hp - 104] = _scHvb::P64;
           P64[Hp - 96] = _scHvc::P64;
           P64[Hp - 88] = _scHvd::P64;
           P64[Hp - 80] = _scHve::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccIh6_info;
           R4 = Hp - 136;
           R3 = _scHvs::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIh6() //  [R1, R2]
         { info_tbl: [(ccIh6,
                       label: block_ccIh6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIh6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIhg; else goto ccIhf;
       ccIhg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIhf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHy0_entry() //  [R1]
         { info_tbl: [(ccIhh,
                       label: sat_scHy0_info
                       rep:HeapRep 17 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIhh: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccIhl; else goto ccIhk;
       ccIhl: // global
           HpAlloc = 152;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIhk: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvs::P64 = P64[R1 + 64];
           _scHvx::P64 = P64[R1 + 72];
           _scHvC::P64 = P64[R1 + 80];
           _scHvH::P64 = P64[R1 + 88];
           _scHvM::P64 = P64[R1 + 96];
           _scHvR::P64 = P64[R1 + 104];
           _scHvW::P64 = P64[R1 + 112];
           _scHw1::P64 = P64[R1 + 120];
           _scHw6::P64 = P64[R1 + 128];
           _scHwb::P64 = P64[R1 + 136];
           _scHwd::P64 = P64[R1 + 144];
           I64[Hp - 144] = sat_scHxZ_info;
           P64[Hp - 128] = _scHv9::P64;
           P64[Hp - 120] = _scHva::P64;
           P64[Hp - 112] = _scHvb::P64;
           P64[Hp - 104] = _scHvc::P64;
           P64[Hp - 96] = _scHvd::P64;
           P64[Hp - 88] = _scHve::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 144;
           R2 = lvl21_rcHpQ_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHy1_entry() //  [R1]
         { info_tbl: [(ccIhm,
                       label: sat_scHy1_info
                       rep:HeapRep 17 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIhm: // global
           _scHy1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIhn; else goto ccIho;
       ccIho: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccIhq; else goto ccIhp;
       ccIhq: // global
           HpAlloc = 152;
           goto ccIhn;
       ccIhn: // global
           R1 = _scHy1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIhp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHy1::P64;
           _scHv9::P64 = P64[_scHy1::P64 + 16];
           _scHva::P64 = P64[_scHy1::P64 + 24];
           _scHvb::P64 = P64[_scHy1::P64 + 32];
           _scHvc::P64 = P64[_scHy1::P64 + 40];
           _scHvd::P64 = P64[_scHy1::P64 + 48];
           _scHve::P64 = P64[_scHy1::P64 + 56];
           _scHvs::P64 = P64[_scHy1::P64 + 64];
           _scHvx::P64 = P64[_scHy1::P64 + 72];
           _scHvC::P64 = P64[_scHy1::P64 + 80];
           _scHvH::P64 = P64[_scHy1::P64 + 88];
           _scHvM::P64 = P64[_scHy1::P64 + 96];
           _scHvR::P64 = P64[_scHy1::P64 + 104];
           _scHvW::P64 = P64[_scHy1::P64 + 112];
           _scHw1::P64 = P64[_scHy1::P64 + 120];
           _scHw6::P64 = P64[_scHy1::P64 + 128];
           _scHwb::P64 = P64[_scHy1::P64 + 136];
           _scHwd::P64 = P64[_scHy1::P64 + 144];
           I64[Hp - 144] = sat_scHy0_info;
           P64[Hp - 128] = _scHv9::P64;
           P64[Hp - 120] = _scHva::P64;
           P64[Hp - 112] = _scHvb::P64;
           P64[Hp - 104] = _scHvc::P64;
           P64[Hp - 96] = _scHvd::P64;
           P64[Hp - 88] = _scHve::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 144;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHy5_entry() //  [R1]
         { info_tbl: [(ccIhu,
                       label: sat_scHy5_info
                       rep:HeapRep 18 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIhu: // global
           _scHy5::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccIhv; else goto ccIhw;
       ccIhw: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccIhy; else goto ccIhx;
       ccIhy: // global
           HpAlloc = 152;
           goto ccIhv;
       ccIhv: // global
           R1 = _scHy5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIhx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHy5::P64;
           _scHv9::P64 = P64[_scHy5::P64 + 16];
           _scHva::P64 = P64[_scHy5::P64 + 24];
           _scHvb::P64 = P64[_scHy5::P64 + 32];
           _scHvc::P64 = P64[_scHy5::P64 + 40];
           _scHvd::P64 = P64[_scHy5::P64 + 48];
           _scHve::P64 = P64[_scHy5::P64 + 56];
           _scHvn::P64 = P64[_scHy5::P64 + 64];
           _scHvs::P64 = P64[_scHy5::P64 + 72];
           _scHvx::P64 = P64[_scHy5::P64 + 80];
           _scHvC::P64 = P64[_scHy5::P64 + 88];
           _scHvH::P64 = P64[_scHy5::P64 + 96];
           _scHvM::P64 = P64[_scHy5::P64 + 104];
           _scHvR::P64 = P64[_scHy5::P64 + 112];
           _scHvW::P64 = P64[_scHy5::P64 + 120];
           _scHw1::P64 = P64[_scHy5::P64 + 128];
           _scHw6::P64 = P64[_scHy5::P64 + 136];
           _scHwb::P64 = P64[_scHy5::P64 + 144];
           _scHwd::P64 = P64[_scHy5::P64 + 152];
           I64[Hp - 144] = sat_scHy1_info;
           P64[Hp - 128] = _scHv9::P64;
           P64[Hp - 120] = _scHva::P64;
           P64[Hp - 112] = _scHvb::P64;
           P64[Hp - 104] = _scHvc::P64;
           P64[Hp - 96] = _scHvd::P64;
           P64[Hp - 88] = _scHve::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccIhr_info;
           R4 = Hp - 144;
           R3 = _scHvn::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIhr() //  [R1, R2]
         { info_tbl: [(ccIhr,
                       label: block_ccIhr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIhr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIhB; else goto ccIhA;
       ccIhB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIhA: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHy6_entry() //  [R1]
         { info_tbl: [(ccIhC,
                       label: sat_scHy6_info
                       rep:HeapRep 18 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIhC: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccIhG; else goto ccIhF;
       ccIhG: // global
           HpAlloc = 160;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIhF: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvn::P64 = P64[R1 + 64];
           _scHvs::P64 = P64[R1 + 72];
           _scHvx::P64 = P64[R1 + 80];
           _scHvC::P64 = P64[R1 + 88];
           _scHvH::P64 = P64[R1 + 96];
           _scHvM::P64 = P64[R1 + 104];
           _scHvR::P64 = P64[R1 + 112];
           _scHvW::P64 = P64[R1 + 120];
           _scHw1::P64 = P64[R1 + 128];
           _scHw6::P64 = P64[R1 + 136];
           _scHwb::P64 = P64[R1 + 144];
           _scHwd::P64 = P64[R1 + 152];
           I64[Hp - 152] = sat_scHy5_info;
           P64[Hp - 136] = _scHv9::P64;
           P64[Hp - 128] = _scHva::P64;
           P64[Hp - 120] = _scHvb::P64;
           P64[Hp - 112] = _scHvc::P64;
           P64[Hp - 104] = _scHvd::P64;
           P64[Hp - 96] = _scHve::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 152;
           R2 = lvl20_rcHpP_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHy7_entry() //  [R1]
         { info_tbl: [(ccIhH,
                       label: sat_scHy7_info
                       rep:HeapRep 18 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIhH: // global
           _scHy7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIhI; else goto ccIhJ;
       ccIhJ: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccIhL; else goto ccIhK;
       ccIhL: // global
           HpAlloc = 160;
           goto ccIhI;
       ccIhI: // global
           R1 = _scHy7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIhK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHy7::P64;
           _scHv9::P64 = P64[_scHy7::P64 + 16];
           _scHva::P64 = P64[_scHy7::P64 + 24];
           _scHvb::P64 = P64[_scHy7::P64 + 32];
           _scHvc::P64 = P64[_scHy7::P64 + 40];
           _scHvd::P64 = P64[_scHy7::P64 + 48];
           _scHve::P64 = P64[_scHy7::P64 + 56];
           _scHvn::P64 = P64[_scHy7::P64 + 64];
           _scHvs::P64 = P64[_scHy7::P64 + 72];
           _scHvx::P64 = P64[_scHy7::P64 + 80];
           _scHvC::P64 = P64[_scHy7::P64 + 88];
           _scHvH::P64 = P64[_scHy7::P64 + 96];
           _scHvM::P64 = P64[_scHy7::P64 + 104];
           _scHvR::P64 = P64[_scHy7::P64 + 112];
           _scHvW::P64 = P64[_scHy7::P64 + 120];
           _scHw1::P64 = P64[_scHy7::P64 + 128];
           _scHw6::P64 = P64[_scHy7::P64 + 136];
           _scHwb::P64 = P64[_scHy7::P64 + 144];
           _scHwd::P64 = P64[_scHy7::P64 + 152];
           I64[Hp - 152] = sat_scHy6_info;
           P64[Hp - 136] = _scHv9::P64;
           P64[Hp - 128] = _scHva::P64;
           P64[Hp - 120] = _scHvb::P64;
           P64[Hp - 112] = _scHvc::P64;
           P64[Hp - 104] = _scHvd::P64;
           P64[Hp - 96] = _scHve::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 152;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyb_entry() //  [R1]
         { info_tbl: [(ccIhP,
                       label: sat_scHyb_info
                       rep:HeapRep 19 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIhP: // global
           _scHyb::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccIhQ; else goto ccIhR;
       ccIhR: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccIhT; else goto ccIhS;
       ccIhT: // global
           HpAlloc = 160;
           goto ccIhQ;
       ccIhQ: // global
           R1 = _scHyb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIhS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHyb::P64;
           _scHv9::P64 = P64[_scHyb::P64 + 16];
           _scHva::P64 = P64[_scHyb::P64 + 24];
           _scHvb::P64 = P64[_scHyb::P64 + 32];
           _scHvc::P64 = P64[_scHyb::P64 + 40];
           _scHvd::P64 = P64[_scHyb::P64 + 48];
           _scHve::P64 = P64[_scHyb::P64 + 56];
           _scHvi::P64 = P64[_scHyb::P64 + 64];
           _scHvn::P64 = P64[_scHyb::P64 + 72];
           _scHvs::P64 = P64[_scHyb::P64 + 80];
           _scHvx::P64 = P64[_scHyb::P64 + 88];
           _scHvC::P64 = P64[_scHyb::P64 + 96];
           _scHvH::P64 = P64[_scHyb::P64 + 104];
           _scHvM::P64 = P64[_scHyb::P64 + 112];
           _scHvR::P64 = P64[_scHyb::P64 + 120];
           _scHvW::P64 = P64[_scHyb::P64 + 128];
           _scHw1::P64 = P64[_scHyb::P64 + 136];
           _scHw6::P64 = P64[_scHyb::P64 + 144];
           _scHwb::P64 = P64[_scHyb::P64 + 152];
           _scHwd::P64 = P64[_scHyb::P64 + 160];
           I64[Hp - 152] = sat_scHy7_info;
           P64[Hp - 136] = _scHv9::P64;
           P64[Hp - 128] = _scHva::P64;
           P64[Hp - 120] = _scHvb::P64;
           P64[Hp - 112] = _scHvc::P64;
           P64[Hp - 104] = _scHvd::P64;
           P64[Hp - 96] = _scHve::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccIhM_info;
           R4 = Hp - 152;
           R3 = _scHvi::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIhM() //  [R1, R2]
         { info_tbl: [(ccIhM,
                       label: block_ccIhM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIhM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIhW; else goto ccIhV;
       ccIhW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIhV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyc_entry() //  [R1]
         { info_tbl: [(ccIhX,
                       label: sat_scHyc_info
                       rep:HeapRep 19 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIhX: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccIi1; else goto ccIi0;
       ccIi1: // global
           HpAlloc = 168;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIi0: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvi::P64 = P64[R1 + 64];
           _scHvn::P64 = P64[R1 + 72];
           _scHvs::P64 = P64[R1 + 80];
           _scHvx::P64 = P64[R1 + 88];
           _scHvC::P64 = P64[R1 + 96];
           _scHvH::P64 = P64[R1 + 104];
           _scHvM::P64 = P64[R1 + 112];
           _scHvR::P64 = P64[R1 + 120];
           _scHvW::P64 = P64[R1 + 128];
           _scHw1::P64 = P64[R1 + 136];
           _scHw6::P64 = P64[R1 + 144];
           _scHwb::P64 = P64[R1 + 152];
           _scHwd::P64 = P64[R1 + 160];
           I64[Hp - 160] = sat_scHyb_info;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 160;
           R2 = lvl19_rcHpO_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHyd_entry() //  [R1]
         { info_tbl: [(ccIi2,
                       label: sat_scHyd_info
                       rep:HeapRep 19 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIi2: // global
           _scHyd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIi3; else goto ccIi4;
       ccIi4: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccIi6; else goto ccIi5;
       ccIi6: // global
           HpAlloc = 168;
           goto ccIi3;
       ccIi3: // global
           R1 = _scHyd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIi5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHyd::P64;
           _scHv9::P64 = P64[_scHyd::P64 + 16];
           _scHva::P64 = P64[_scHyd::P64 + 24];
           _scHvb::P64 = P64[_scHyd::P64 + 32];
           _scHvc::P64 = P64[_scHyd::P64 + 40];
           _scHvd::P64 = P64[_scHyd::P64 + 48];
           _scHve::P64 = P64[_scHyd::P64 + 56];
           _scHvi::P64 = P64[_scHyd::P64 + 64];
           _scHvn::P64 = P64[_scHyd::P64 + 72];
           _scHvs::P64 = P64[_scHyd::P64 + 80];
           _scHvx::P64 = P64[_scHyd::P64 + 88];
           _scHvC::P64 = P64[_scHyd::P64 + 96];
           _scHvH::P64 = P64[_scHyd::P64 + 104];
           _scHvM::P64 = P64[_scHyd::P64 + 112];
           _scHvR::P64 = P64[_scHyd::P64 + 120];
           _scHvW::P64 = P64[_scHyd::P64 + 128];
           _scHw1::P64 = P64[_scHyd::P64 + 136];
           _scHw6::P64 = P64[_scHyd::P64 + 144];
           _scHwb::P64 = P64[_scHyd::P64 + 152];
           _scHwd::P64 = P64[_scHyd::P64 + 160];
           I64[Hp - 160] = sat_scHyc_info;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 160;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyh_entry() //  [R1]
         { info_tbl: [(ccIi7,
                       label: sat_scHyh_info
                       rep:HeapRep 20 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIi7: // global
           if ((Sp + -176) < SpLim) (likely: False) goto ccIie; else goto ccIif;
       ccIie: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIif: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 176] = block_ccI7L_info;
           _scHv9::P64 = P64[R1 + 24];
           _scHva::P64 = P64[R1 + 32];
           _scHvb::P64 = P64[R1 + 40];
           _scHvc::P64 = P64[R1 + 48];
           _scHvd::P64 = P64[R1 + 56];
           _scHve::P64 = P64[R1 + 64];
           _scHvi::P64 = P64[R1 + 72];
           _scHvn::P64 = P64[R1 + 80];
           _scHvs::P64 = P64[R1 + 88];
           _scHvx::P64 = P64[R1 + 96];
           _scHvC::P64 = P64[R1 + 104];
           _scHvH::P64 = P64[R1 + 112];
           _scHvM::P64 = P64[R1 + 120];
           _scHvR::P64 = P64[R1 + 128];
           _scHvW::P64 = P64[R1 + 136];
           _scHw1::P64 = P64[R1 + 144];
           _scHw6::P64 = P64[R1 + 152];
           _scHwb::P64 = P64[R1 + 160];
           _scHwd::P64 = P64[R1 + 168];
           R1 = P64[R1 + 16];
           P64[Sp - 168] = _scHv9::P64;
           P64[Sp - 160] = _scHva::P64;
           P64[Sp - 152] = _scHvb::P64;
           P64[Sp - 144] = _scHvc::P64;
           P64[Sp - 136] = _scHvd::P64;
           P64[Sp - 128] = _scHve::P64;
           P64[Sp - 120] = _scHvi::P64;
           P64[Sp - 112] = _scHvn::P64;
           P64[Sp - 104] = _scHvs::P64;
           P64[Sp - 96] = _scHvx::P64;
           P64[Sp - 88] = _scHvC::P64;
           P64[Sp - 80] = _scHvH::P64;
           P64[Sp - 72] = _scHvM::P64;
           P64[Sp - 64] = _scHvR::P64;
           P64[Sp - 56] = _scHvW::P64;
           P64[Sp - 48] = _scHw1::P64;
           P64[Sp - 40] = _scHw6::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 176;
           if (R1 & 7 != 0) goto ucIim; else goto ccI7M;
       ucIim: // global
           call _ccI7L(R1) args: 0, res: 0, upd: 0;
       ccI7M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccI7L() //  [R1]
         { info_tbl: [(ccI7L,
                       label: block_ccI7L_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI7L: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccIii; else goto ccIih;
       ccIii: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccIih: // global
           _scHwi::I64 = I64[R1 + 7];
           I64[Hp - 160] = sat_scHyd_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           P64[Hp - 128] = P64[Sp + 24];
           P64[Hp - 120] = P64[Sp + 32];
           P64[Hp - 112] = P64[Sp + 40];
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           P64[Hp - 16] = P64[Sp + 136];
           P64[Hp - 8] = P64[Sp + 144];
           P64[Hp] = P64[Sp + 152];
           I64[Sp + 152] = block_ccIib_info;
           R3 = Hp - 160;
           R2 = _scHwi::I64;
           Sp = Sp + 152;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIib() //  [R1, R2]
         { info_tbl: [(ccIib,
                       label: block_ccIib_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIib: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIil; else goto ccIik;
       ccIil: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIik: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyi_entry() //  [R1]
         { info_tbl: [(ccIin,
                       label: sat_scHyi_info
                       rep:HeapRep 20 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIin: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccIir; else goto ccIiq;
       ccIir: // global
           HpAlloc = 176;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIiq: // global
           _scHuX::P64 = P64[R1 + 16];
           _scHv9::P64 = P64[R1 + 24];
           _scHva::P64 = P64[R1 + 32];
           _scHvb::P64 = P64[R1 + 40];
           _scHvc::P64 = P64[R1 + 48];
           _scHvd::P64 = P64[R1 + 56];
           _scHve::P64 = P64[R1 + 64];
           _scHvi::P64 = P64[R1 + 72];
           _scHvn::P64 = P64[R1 + 80];
           _scHvs::P64 = P64[R1 + 88];
           _scHvx::P64 = P64[R1 + 96];
           _scHvC::P64 = P64[R1 + 104];
           _scHvH::P64 = P64[R1 + 112];
           _scHvM::P64 = P64[R1 + 120];
           _scHvR::P64 = P64[R1 + 128];
           _scHvW::P64 = P64[R1 + 136];
           _scHw1::P64 = P64[R1 + 144];
           _scHw6::P64 = P64[R1 + 152];
           _scHwb::P64 = P64[R1 + 160];
           _scHwd::P64 = P64[R1 + 168];
           I64[Hp - 168] = sat_scHyh_info;
           P64[Hp - 152] = _scHuX::P64;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 168;
           R2 = lvl18_rcHpN_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHyj_entry() //  [R1]
         { info_tbl: [(ccIis,
                       label: sat_scHyj_info
                       rep:HeapRep 20 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIis: // global
           _scHyj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIit; else goto ccIiu;
       ccIiu: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccIiw; else goto ccIiv;
       ccIiw: // global
           HpAlloc = 176;
           goto ccIit;
       ccIit: // global
           R1 = _scHyj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIiv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHyj::P64;
           _scHuX::P64 = P64[_scHyj::P64 + 16];
           _scHv9::P64 = P64[_scHyj::P64 + 24];
           _scHva::P64 = P64[_scHyj::P64 + 32];
           _scHvb::P64 = P64[_scHyj::P64 + 40];
           _scHvc::P64 = P64[_scHyj::P64 + 48];
           _scHvd::P64 = P64[_scHyj::P64 + 56];
           _scHve::P64 = P64[_scHyj::P64 + 64];
           _scHvi::P64 = P64[_scHyj::P64 + 72];
           _scHvn::P64 = P64[_scHyj::P64 + 80];
           _scHvs::P64 = P64[_scHyj::P64 + 88];
           _scHvx::P64 = P64[_scHyj::P64 + 96];
           _scHvC::P64 = P64[_scHyj::P64 + 104];
           _scHvH::P64 = P64[_scHyj::P64 + 112];
           _scHvM::P64 = P64[_scHyj::P64 + 120];
           _scHvR::P64 = P64[_scHyj::P64 + 128];
           _scHvW::P64 = P64[_scHyj::P64 + 136];
           _scHw1::P64 = P64[_scHyj::P64 + 144];
           _scHw6::P64 = P64[_scHyj::P64 + 152];
           _scHwb::P64 = P64[_scHyj::P64 + 160];
           _scHwd::P64 = P64[_scHyj::P64 + 168];
           I64[Hp - 168] = sat_scHyi_info;
           P64[Hp - 152] = _scHuX::P64;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 168;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyn_entry() //  [R1]
         { info_tbl: [(ccIix,
                       label: sat_scHyn_info
                       rep:HeapRep 21 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIix: // global
           if ((Sp + -184) < SpLim) (likely: False) goto ccIiE; else goto ccIiF;
       ccIiE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIiF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 184] = block_ccI7u_info;
           _scHuX::P64 = P64[R1 + 24];
           _scHv9::P64 = P64[R1 + 32];
           _scHva::P64 = P64[R1 + 40];
           _scHvb::P64 = P64[R1 + 48];
           _scHvc::P64 = P64[R1 + 56];
           _scHvd::P64 = P64[R1 + 64];
           _scHve::P64 = P64[R1 + 72];
           _scHvi::P64 = P64[R1 + 80];
           _scHvn::P64 = P64[R1 + 88];
           _scHvs::P64 = P64[R1 + 96];
           _scHvx::P64 = P64[R1 + 104];
           _scHvC::P64 = P64[R1 + 112];
           _scHvH::P64 = P64[R1 + 120];
           _scHvM::P64 = P64[R1 + 128];
           _scHvR::P64 = P64[R1 + 136];
           _scHvW::P64 = P64[R1 + 144];
           _scHw1::P64 = P64[R1 + 152];
           _scHw6::P64 = P64[R1 + 160];
           _scHwb::P64 = P64[R1 + 168];
           _scHwd::P64 = P64[R1 + 176];
           R1 = P64[R1 + 16];
           P64[Sp - 176] = _scHuX::P64;
           P64[Sp - 168] = _scHv9::P64;
           P64[Sp - 160] = _scHva::P64;
           P64[Sp - 152] = _scHvb::P64;
           P64[Sp - 144] = _scHvc::P64;
           P64[Sp - 136] = _scHvd::P64;
           P64[Sp - 128] = _scHve::P64;
           P64[Sp - 120] = _scHvi::P64;
           P64[Sp - 112] = _scHvn::P64;
           P64[Sp - 104] = _scHvs::P64;
           P64[Sp - 96] = _scHvx::P64;
           P64[Sp - 88] = _scHvC::P64;
           P64[Sp - 80] = _scHvH::P64;
           P64[Sp - 72] = _scHvM::P64;
           P64[Sp - 64] = _scHvR::P64;
           P64[Sp - 56] = _scHvW::P64;
           P64[Sp - 48] = _scHw1::P64;
           P64[Sp - 40] = _scHw6::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 184;
           if (R1 & 7 != 0) goto ucIiM; else goto ccI7v;
       ucIiM: // global
           call _ccI7u(R1) args: 0, res: 0, upd: 0;
       ccI7v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccI7u() //  [R1]
         { info_tbl: [(ccI7u,
                       label: block_ccI7u_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI7u: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccIiI; else goto ccIiH;
       ccIiI: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccIiH: // global
           _scHwf::I64 = I64[R1 + 7];
           I64[Hp - 168] = sat_scHyj_info;
           P64[Hp - 152] = P64[Sp + 8];
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = P64[Sp + 48];
           P64[Hp - 104] = P64[Sp + 56];
           P64[Hp - 96] = P64[Sp + 64];
           P64[Hp - 88] = P64[Sp + 72];
           P64[Hp - 80] = P64[Sp + 80];
           P64[Hp - 72] = P64[Sp + 88];
           P64[Hp - 64] = P64[Sp + 96];
           P64[Hp - 56] = P64[Sp + 104];
           P64[Hp - 48] = P64[Sp + 112];
           P64[Hp - 40] = P64[Sp + 120];
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 144];
           P64[Hp - 8] = P64[Sp + 152];
           P64[Hp] = P64[Sp + 160];
           I64[Sp + 160] = block_ccIiB_info;
           R3 = Hp - 168;
           R2 = _scHwf::I64;
           Sp = Sp + 160;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccIiB() //  [R1, R2]
         { info_tbl: [(ccIiB,
                       label: block_ccIiB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIiB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIiL; else goto ccIiK;
       ccIiL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccIiK: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyo_entry() //  [R1]
         { info_tbl: [(ccIiN,
                       label: sat_scHyo_info
                       rep:HeapRep 21 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIiN: // global
           _scHyo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIiO; else goto ccIiP;
       ccIiP: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto ccIiR; else goto ccIiQ;
       ccIiR: // global
           HpAlloc = 184;
           goto ccIiO;
       ccIiO: // global
           R1 = _scHyo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIiQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHyo::P64;
           _scHuW::P64 = P64[_scHyo::P64 + 16];
           _scHuX::P64 = P64[_scHyo::P64 + 24];
           _scHv9::P64 = P64[_scHyo::P64 + 32];
           _scHva::P64 = P64[_scHyo::P64 + 40];
           _scHvb::P64 = P64[_scHyo::P64 + 48];
           _scHvc::P64 = P64[_scHyo::P64 + 56];
           _scHvd::P64 = P64[_scHyo::P64 + 64];
           _scHve::P64 = P64[_scHyo::P64 + 72];
           _scHvi::P64 = P64[_scHyo::P64 + 80];
           _scHvn::P64 = P64[_scHyo::P64 + 88];
           _scHvs::P64 = P64[_scHyo::P64 + 96];
           _scHvx::P64 = P64[_scHyo::P64 + 104];
           _scHvC::P64 = P64[_scHyo::P64 + 112];
           _scHvH::P64 = P64[_scHyo::P64 + 120];
           _scHvM::P64 = P64[_scHyo::P64 + 128];
           _scHvR::P64 = P64[_scHyo::P64 + 136];
           _scHvW::P64 = P64[_scHyo::P64 + 144];
           _scHw1::P64 = P64[_scHyo::P64 + 152];
           _scHw6::P64 = P64[_scHyo::P64 + 160];
           _scHwb::P64 = P64[_scHyo::P64 + 168];
           _scHwd::P64 = P64[_scHyo::P64 + 176];
           I64[Hp - 176] = sat_scHyn_info;
           P64[Hp - 160] = _scHuW::P64;
           P64[Hp - 152] = _scHuX::P64;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 176;
           R2 = lvl17_rcHpM_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_scHwc_entry() //  [R1, R2]
         { info_tbl: [(ccIiS,
                       label: p_scHwc_info
                       rep:HeapRep 20 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIiS: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto ccIiW; else goto ccIiV;
       ccIiW: // global
           HpAlloc = 184;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIiV: // global
           _scHuW::P64 = P64[R1 + 7];
           _scHuX::P64 = P64[R1 + 15];
           _scHv9::P64 = P64[R1 + 23];
           _scHva::P64 = P64[R1 + 31];
           _scHvb::P64 = P64[R1 + 39];
           _scHvc::P64 = P64[R1 + 47];
           _scHvd::P64 = P64[R1 + 55];
           _scHve::P64 = P64[R1 + 63];
           _scHvi::P64 = P64[R1 + 71];
           _scHvn::P64 = P64[R1 + 79];
           _scHvs::P64 = P64[R1 + 87];
           _scHvx::P64 = P64[R1 + 95];
           _scHvC::P64 = P64[R1 + 103];
           _scHvH::P64 = P64[R1 + 111];
           _scHvM::P64 = P64[R1 + 119];
           _scHvR::P64 = P64[R1 + 127];
           _scHvW::P64 = P64[R1 + 135];
           _scHw1::P64 = P64[R1 + 143];
           _scHw6::P64 = P64[R1 + 151];
           _scHwb::P64 = P64[R1 + 159];
           I64[Hp - 176] = sat_scHyo_info;
           P64[Hp - 160] = _scHuW::P64;
           P64[Hp - 152] = _scHuX::P64;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = R2;
           R3 = Hp - 176;
           R2 = lvl16_rcHpL_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHys_entry() //  [R1]
         { info_tbl: [(ccIjb,
                       label: sat_scHys_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIjb: // global
           _scHys::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccIjc; else goto ccIjd;
       ccIjd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIjf; else goto ccIje;
       ccIjf: // global
           HpAlloc = 24;
           goto ccIjc;
       ccIjc: // global
           R1 = _scHys::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIje: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHys::P64;
           _scHwc::P64 = P64[_scHys::P64 + 16];
           _scHyq::P64 = P64[_scHys::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _scHyq::P64;
           R2 = Hp - 14;
           R1 = _scHwc::P64;
           Sp = Sp - 16;
           call p_scHwc_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyt_entry() //  [R1, R2]
         { info_tbl: [(ccIjh,
                       label: sat_scHyt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIjh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccIjl; else goto ccIjk;
       ccIjl: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIjk: // global
           _scHwc::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_scHys_info;
           P64[Hp - 32] = _scHwc::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stats.$fShowRTSStats_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(ccIjm,
                       label: GHC.Stats.$fShowRTSStats_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIjm: // global
           if ((Sp + -168) < SpLim) (likely: False) goto ccIjn; else goto ccIjo;
       ccIjn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fShowRTSStats_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccIjo: // global
           I64[Sp - 16] = block_ccI36_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucIjx; else goto ccI37;
       ucIjx: // global
           call _ccI36(R1) args: 0, res: 0, upd: 0;
       ccI37: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccI36() //  [R1]
         { info_tbl: [(ccI36,
                       label: block_ccI36_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI36: // global
           I64[Sp - 152] = block_ccI3b_info;
           _scHuW::P64 = P64[R1 + 7];
           _scHuX::P64 = P64[R1 + 15];
           _scHuY::P64 = P64[R1 + 23];
           _scHuZ::P64 = P64[R1 + 31];
           _scHv0::P64 = P64[R1 + 39];
           _scHv1::P64 = P64[R1 + 47];
           _scHv2::P64 = P64[R1 + 55];
           _scHv3::P64 = P64[R1 + 63];
           _scHv4::P64 = P64[R1 + 71];
           _scHv5::P64 = P64[R1 + 79];
           _scHv6::P64 = P64[R1 + 87];
           _scHv7::P64 = P64[R1 + 95];
           _scHv8::P64 = P64[R1 + 103];
           _scHv9::P64 = P64[R1 + 111];
           _scHva::P64 = P64[R1 + 119];
           _scHvb::P64 = P64[R1 + 127];
           _scHvc::P64 = P64[R1 + 135];
           _scHvd::P64 = P64[R1 + 143];
           _scHve::P64 = P64[R1 + 151];
           _scHvf::P64 = P64[R1 + 159];
           R1 = P64[Sp + 8];
           P64[Sp - 144] = _scHuY::P64;
           P64[Sp - 136] = _scHuZ::P64;
           P64[Sp - 128] = _scHv0::P64;
           P64[Sp - 120] = _scHv1::P64;
           P64[Sp - 112] = _scHv2::P64;
           P64[Sp - 104] = _scHv3::P64;
           P64[Sp - 96] = _scHv4::P64;
           P64[Sp - 88] = _scHv5::P64;
           P64[Sp - 80] = _scHv6::P64;
           P64[Sp - 72] = _scHv7::P64;
           P64[Sp - 64] = _scHv8::P64;
           P64[Sp - 56] = _scHv9::P64;
           P64[Sp - 48] = _scHva::P64;
           P64[Sp - 40] = _scHvb::P64;
           P64[Sp - 32] = _scHvc::P64;
           P64[Sp - 24] = _scHvd::P64;
           P64[Sp - 16] = _scHve::P64;
           P64[Sp - 8] = _scHvf::P64;
           P64[Sp] = _scHuX::P64;
           P64[Sp + 8] = _scHuW::P64;
           Sp = Sp - 152;
           if (R1 & 7 != 0) goto ucIjw; else goto ccI3c;
       ucIjw: // global
           call _ccI3b(R1) args: 0, res: 0, upd: 0;
       ccI3c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccI3b() //  [R1]
         { info_tbl: [(ccI3b,
                       label: block_ccI3b_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccI3b: // global
           Hp = Hp + 472;
           if (Hp > HpLim) (likely: False) goto ccIjs; else goto ccIjr;
       ccIjs: // global
           HpAlloc = 472;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIjr: // global
           _scHvh::I64 = I64[R1 + 7];
           I64[Hp - 464] = w1_scHvi_info;
           P64[Hp - 448] = P64[Sp + 8];
           I64[Hp - 440] = w2_scHvn_info;
           P64[Hp - 424] = P64[Sp + 16];
           I64[Hp - 416] = w3_scHvs_info;
           P64[Hp - 400] = P64[Sp + 24];
           I64[Hp - 392] = w4_scHvx_info;
           P64[Hp - 376] = P64[Sp + 32];
           I64[Hp - 368] = w5_scHvC_info;
           P64[Hp - 352] = P64[Sp + 40];
           I64[Hp - 344] = w6_scHvH_info;
           P64[Hp - 328] = P64[Sp + 48];
           I64[Hp - 320] = w7_scHvM_info;
           P64[Hp - 304] = P64[Sp + 56];
           I64[Hp - 296] = w8_scHvR_info;
           P64[Hp - 280] = P64[Sp + 64];
           I64[Hp - 272] = w9_scHvW_info;
           P64[Hp - 256] = P64[Sp + 72];
           I64[Hp - 248] = w10_scHw1_info;
           P64[Hp - 232] = P64[Sp + 80];
           I64[Hp - 224] = w11_scHw6_info;
           P64[Hp - 208] = P64[Sp + 88];
           I64[Hp - 200] = f_scHwb_info;
           P64[Hp - 184] = P64[Sp + 144];
           I64[Hp - 176] = p_scHwc_info;
           P64[Hp - 168] = P64[Sp + 160];
           P64[Hp - 160] = P64[Sp + 152];
           P64[Hp - 152] = P64[Sp + 96];
           P64[Hp - 144] = P64[Sp + 104];
           P64[Hp - 136] = P64[Sp + 112];
           P64[Hp - 128] = P64[Sp + 120];
           P64[Hp - 120] = P64[Sp + 128];
           P64[Hp - 112] = P64[Sp + 136];
           P64[Hp - 104] = Hp - 464;
           P64[Hp - 96] = Hp - 440;
           P64[Hp - 88] = Hp - 416;
           P64[Hp - 80] = Hp - 392;
           P64[Hp - 72] = Hp - 368;
           P64[Hp - 64] = Hp - 344;
           P64[Hp - 56] = Hp - 320;
           P64[Hp - 48] = Hp - 296;
           P64[Hp - 40] = Hp - 272;
           P64[Hp - 32] = Hp - 248;
           P64[Hp - 24] = Hp - 224;
           P64[Hp - 16] = Hp - 200;
           _ccI7h::P64 = Hp - 175;
           if (%MO_S_Lt_W64(_scHvh::I64, 11)) goto ccIju; else goto ccIjv;
       ccIju: // global
           Hp = Hp - 16;
           R1 = _ccI7h::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccIjv: // global
           I64[Hp - 8] = sat_scHyt_info;
           P64[Hp] = _ccI7h::P64;
           R1 = Hp - 7;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.910931554 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_$cshow_closure" {
     GHC.Stats.$fShowRTSStats_$cshow_closure:
         const GHC.Stats.$fShowRTSStats_$cshow_info;
         const 0;
 },
 GHC.Stats.$fShowRTSStats_$cshow_entry() //  [R2]
         { info_tbl: [(ccIjC,
                       label: GHC.Stats.$fShowRTSStats_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIjC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIjD; else goto ccIjE;
       ccIjD: // global
           R2 = R2;
           R1 = GHC.Stats.$fShowRTSStats_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIjE: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Stats.$fShowRTSStats_$cshowsPrec_entry(R3,
                                                           R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.911958588 UTC

[section ""data" . GHC.Stats.$fShowRTSStats1_closure" {
     GHC.Stats.$fShowRTSStats1_closure:
         const GHC.Stats.$fShowRTSStats1_info;
         const 0;
 },
 GHC.Stats.$fShowRTSStats1_entry() //  [R2]
         { info_tbl: [(ccIjJ,
                       label: GHC.Stats.$fShowRTSStats1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIjJ: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           call GHC.Stats.$fShowRTSStats_$cshowsPrec_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.912832545 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_$cshowList_closure" {
     GHC.Stats.$fShowRTSStats_$cshowList_closure:
         const GHC.Stats.$fShowRTSStats_$cshowList_info;
         const 0;
 },
 GHC.Stats.$fShowRTSStats_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(ccIjQ,
                       label: GHC.Stats.$fShowRTSStats_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIjQ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fShowRTSStats1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.913602626 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_closure" {
     GHC.Stats.$fShowRTSStats_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Stats.$fShowRTSStats_$cshowsPrec_closure+2;
         const GHC.Stats.$fShowRTSStats_$cshow_closure+1;
         const GHC.Stats.$fShowRTSStats_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.914230536 UTC

[section ""cstring" . GHC.Stats.$tcGCDetails2_bytes" {
     GHC.Stats.$tcGCDetails2_bytes:
         I8[] [71,67,68,101,116,97,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.914981456 UTC

[section ""data" . lexeme_rcHq6_closure" {
     lexeme_rcHq6_closure:
         const lexeme_rcHq6_info;
         const 0;
         const 0;
         const 0;
 },
 lexeme_rcHq6_entry() //  [R1]
         { info_tbl: [(ccIjZ,
                       label: lexeme_rcHq6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIjZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIk0; else goto ccIk1;
       ccIk0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIk1: // global
           (_ccIjW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIjW::I64 == 0) goto ccIjY; else goto ccIjX;
       ccIjY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIjX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIjW::I64;
           R2 = GHC.Stats.$tcGCDetails2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.915890572 UTC

[section ""data" . lexeme1_rcHq7_closure" {
     lexeme1_rcHq7_closure:
         const Text.Read.Lex.Ident_con_info;
         const lexeme_rcHq6_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.916418514 UTC

[section ""cstring" . lexeme2_rcHq8_bytes" {
     lexeme2_rcHq8_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.917141958 UTC

[section ""data" . lexeme3_rcHq9_closure" {
     lexeme3_rcHq9_closure:
         const lexeme3_rcHq9_info;
         const 0;
         const 0;
         const 0;
 },
 lexeme3_rcHq9_entry() //  [R1]
         { info_tbl: [(ccIk8,
                       label: lexeme3_rcHq9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIk8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIk9; else goto ccIka;
       ccIk9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIka: // global
           (_ccIk5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIk5::I64 == 0) goto ccIk7; else goto ccIk6;
       ccIk7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIk6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIk5::I64;
           R2 = lexeme2_rcHq8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.918060399 UTC

[section ""data" . lexeme4_rcHqa_closure" {
     lexeme4_rcHqa_closure:
         const Text.Read.Lex.Punc_con_info;
         const lexeme3_rcHq9_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.918633538 UTC

[section ""cstring" . ds_rcHqb_bytes" {
     ds_rcHqb_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,103,101,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.919397449 UTC

[section ""data" . ds1_rcHqc_closure" {
     ds1_rcHqc_closure:
         const ds1_rcHqc_info;
         const 0;
         const 0;
         const 0;
 },
 ds1_rcHqc_entry() //  [R1]
         { info_tbl: [(ccIkh,
                       label: ds1_rcHqc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIkh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIki; else goto ccIkj;
       ccIki: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIkj: // global
           (_ccIke::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIke::I64 == 0) goto ccIkg; else goto ccIkf;
       ccIkg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIkf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIke::I64;
           R2 = ds_rcHqb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.920493665 UTC

[section ""data" . lvl37_rcHqd_closure" {
     lvl37_rcHqd_closure:
         const lvl37_rcHqd_info;
         const 0;
 },
 lvl37_rcHqd_entry() //  [R2]
         { info_tbl: [(ccIko,
                       label: lvl37_rcHqd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIko: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           call GHC.Read.$fReadWord32_$creadsPrec_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.921626533 UTC

[section ""data" . ds2_rcHqe_closure" {
     ds2_rcHqe_closure:
         const ds2_rcHqe_info;
         const 0;
 },
 ds2_rcHqe_entry() //  [R2, R3]
         { info_tbl: [(ccIky,
                       label: ds2_rcHqe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIky: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIkz; else goto ccIkA;
       ccIkz: // global
           R3 = R3;
           R2 = R2;
           R1 = ds2_rcHqe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccIkA: // global
           I64[Sp - 8] = block_ccIkv_info;
           R3 = R3;
           R2 = lvl37_rcHqd_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIkv() //  [R1]
         { info_tbl: [(ccIkv,
                       label: block_ccIkv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIkv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIkD; else goto ccIkC;
       ccIkD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIkC: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.922742222 UTC

[section ""data" . n_rcHqf_closure" {
     n_rcHqf_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.923361644 UTC

[section ""cstring" . lvl38_rcHqg_bytes" {
     lvl38_rcHqg_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.924134394 UTC

[section ""data" . lvl39_rcHqh_closure" {
     lvl39_rcHqh_closure:
         const lvl39_rcHqh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl39_rcHqh_entry() //  [R1]
         { info_tbl: [(ccIkK,
                       label: lvl39_rcHqh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIkK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIkL; else goto ccIkM;
       ccIkL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIkM: // global
           (_ccIkH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIkH::I64 == 0) goto ccIkJ; else goto ccIkI;
       ccIkJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIkI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIkH::I64;
           R2 = lvl38_rcHqg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.925085925 UTC

[section ""data" . lvl40_rcHqi_closure" {
     lvl40_rcHqi_closure:
         const Text.Read.Lex.Punc_con_info;
         const lvl39_rcHqh_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.926306807 UTC

[section ""cstring" . lvl41_rcHqj_bytes" {
     lvl41_rcHqj_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,116,104,114,101,97,100,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.926997466 UTC

[section ""data" . lvl42_rcHqk_closure" {
     lvl42_rcHqk_closure:
         const lvl42_rcHqk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_rcHqk_entry() //  [R1]
         { info_tbl: [(ccIkT,
                       label: lvl42_rcHqk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIkT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIkU; else goto ccIkV;
       ccIkU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIkV: // global
           (_ccIkQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIkQ::I64 == 0) goto ccIkS; else goto ccIkR;
       ccIkS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIkR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIkQ::I64;
           R2 = lvl41_rcHqj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.927851594 UTC

[section ""cstring" . lvl43_rcHql_bytes" {
     lvl43_rcHql_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,97,108,108,111,99,97,116,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.928574987 UTC

[section ""data" . lvl44_rcHqm_closure" {
     lvl44_rcHqm_closure:
         const lvl44_rcHqm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl44_rcHqm_entry() //  [R1]
         { info_tbl: [(ccIl2,
                       label: lvl44_rcHqm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIl2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIl3; else goto ccIl4;
       ccIl3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIl4: // global
           (_ccIkZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIkZ::I64 == 0) goto ccIl1; else goto ccIl0;
       ccIl1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIl0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIkZ::I64;
           R2 = lvl43_rcHql_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.929591038 UTC

[section ""data" . lvl45_rcHqn_closure" {
     lvl45_rcHqn_closure:
         const lvl45_rcHqn_info;
         const 0;
 },
 lvl45_rcHqn_entry() //  [R2]
         { info_tbl: [(ccIl9,
                       label: lvl45_rcHqn_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIl9: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           call GHC.Read.$fReadWord64_$creadsPrec_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.930524555 UTC

[section ""data" . lvl46_rcHqo_closure" {
     lvl46_rcHqo_closure:
         const lvl46_rcHqo_info;
         const 0;
 },
 lvl46_rcHqo_entry() //  [R2, R3]
         { info_tbl: [(ccIlj,
                       label: lvl46_rcHqo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIlj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIlk; else goto ccIll;
       ccIlk: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl46_rcHqo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccIll: // global
           I64[Sp - 8] = block_ccIlg_info;
           R3 = R3;
           R2 = lvl45_rcHqn_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIlg() //  [R1]
         { info_tbl: [(ccIlg,
                       label: block_ccIlg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIlg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIlo; else goto ccIln;
       ccIlo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIln: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.931549413 UTC

[section ""cstring" . lvl47_rcHqp_bytes" {
     lvl47_rcHqp_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,105,118,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.932296172 UTC

[section ""data" . lvl48_rcHqq_closure" {
     lvl48_rcHqq_closure:
         const lvl48_rcHqq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl48_rcHqq_entry() //  [R1]
         { info_tbl: [(ccIlv,
                       label: lvl48_rcHqq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIlv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIlw; else goto ccIlx;
       ccIlw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIlx: // global
           (_ccIls::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIls::I64 == 0) goto ccIlu; else goto ccIlt;
       ccIlu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIlt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIls::I64;
           R2 = lvl47_rcHqp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.93317329 UTC

[section ""cstring" . lvl49_rcHqr_bytes" {
     lvl49_rcHqr_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.93391509 UTC

[section ""data" . lvl50_rcHqs_closure" {
     lvl50_rcHqs_closure:
         const lvl50_rcHqs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl50_rcHqs_entry() //  [R1]
         { info_tbl: [(ccIlE,
                       label: lvl50_rcHqs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIlE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIlF; else goto ccIlG;
       ccIlF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIlG: // global
           (_ccIlB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIlB::I64 == 0) goto ccIlD; else goto ccIlC;
       ccIlD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIlC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIlB::I64;
           R2 = lvl49_rcHqr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.934768129 UTC

[section ""cstring" . lvl51_rcHqt_bytes" {
     lvl51_rcHqt_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,109,112,97,99,116,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.935493254 UTC

[section ""data" . lvl52_rcHqu_closure" {
     lvl52_rcHqu_closure:
         const lvl52_rcHqu_info;
         const 0;
         const 0;
         const 0;
 },
 lvl52_rcHqu_entry() //  [R1]
         { info_tbl: [(ccIlN,
                       label: lvl52_rcHqu_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIlN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIlO; else goto ccIlP;
       ccIlO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIlP: // global
           (_ccIlK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIlK::I64 == 0) goto ccIlM; else goto ccIlL;
       ccIlM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIlL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIlK::I64;
           R2 = lvl51_rcHqt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.936371346 UTC

[section ""cstring" . lvl53_rcHqv_bytes" {
     lvl53_rcHqv_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,108,111,112,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.937098991 UTC

[section ""data" . lvl54_rcHqw_closure" {
     lvl54_rcHqw_closure:
         const lvl54_rcHqw_info;
         const 0;
         const 0;
         const 0;
 },
 lvl54_rcHqw_entry() //  [R1]
         { info_tbl: [(ccIlW,
                       label: lvl54_rcHqw_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIlW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIlX; else goto ccIlY;
       ccIlX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIlY: // global
           (_ccIlT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIlT::I64 == 0) goto ccIlV; else goto ccIlU;
       ccIlV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIlU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIlT::I64;
           R2 = lvl53_rcHqv_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.938325046 UTC

[section ""cstring" . lvl55_rcHqx_bytes" {
     lvl55_rcHqx_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.939080472 UTC

[section ""data" . lvl56_rcHqy_closure" {
     lvl56_rcHqy_closure:
         const lvl56_rcHqy_info;
         const 0;
         const 0;
         const 0;
 },
 lvl56_rcHqy_entry() //  [R1]
         { info_tbl: [(ccIm5,
                       label: lvl56_rcHqy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIm5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIm6; else goto ccIm7;
       ccIm6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIm7: // global
           (_ccIm2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIm2::I64 == 0) goto ccIm4; else goto ccIm3;
       ccIm4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIm3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIm2::I64;
           R2 = lvl55_rcHqx_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.939948168 UTC

[section ""cstring" . lvl57_rcHqz_bytes" {
     lvl57_rcHqz_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.940666034 UTC

[section ""data" . lvl58_rcHqA_closure" {
     lvl58_rcHqA_closure:
         const lvl58_rcHqA_info;
         const 0;
         const 0;
         const 0;
 },
 lvl58_rcHqA_entry() //  [R1]
         { info_tbl: [(ccIme,
                       label: lvl58_rcHqA_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIme: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccImf; else goto ccImg;
       ccImf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccImg: // global
           (_ccImb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccImb::I64 == 0) goto ccImd; else goto ccImc;
       ccImd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccImc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccImb::I64;
           R2 = lvl57_rcHqz_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.941571631 UTC

[section ""cstring" . lvl59_rcHqB_bytes" {
     lvl59_rcHqB_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.942307927 UTC

[section ""data" . lvl60_rcHqC_closure" {
     lvl60_rcHqC_closure:
         const lvl60_rcHqC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl60_rcHqC_entry() //  [R1]
         { info_tbl: [(ccImn,
                       label: lvl60_rcHqC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccImn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccImo; else goto ccImp;
       ccImo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccImp: // global
           (_ccImk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccImk::I64 == 0) goto ccImm; else goto ccIml;
       ccImm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIml: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccImk::I64;
           R2 = lvl59_rcHqB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.943198048 UTC

[section ""cstring" . lvl61_rcHqD_bytes" {
     lvl61_rcHqD_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.943921362 UTC

[section ""data" . lvl62_rcHqE_closure" {
     lvl62_rcHqE_closure:
         const lvl62_rcHqE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl62_rcHqE_entry() //  [R1]
         { info_tbl: [(ccImw,
                       label: lvl62_rcHqE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccImw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccImx; else goto ccImy;
       ccImx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccImy: // global
           (_ccImt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccImt::I64 == 0) goto ccImv; else goto ccImu;
       ccImv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccImu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccImt::I64;
           R2 = lvl61_rcHqD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.94481109 UTC

[section ""cstring" . lvl63_rcHqF_bytes" {
     lvl63_rcHqF_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,121,110,99,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.945532585 UTC

[section ""data" . lvl64_rcHqG_closure" {
     lvl64_rcHqG_closure:
         const lvl64_rcHqG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl64_rcHqG_entry() //  [R1]
         { info_tbl: [(ccImF,
                       label: lvl64_rcHqG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccImF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccImG; else goto ccImH;
       ccImG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccImH: // global
           (_ccImC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccImC::I64 == 0) goto ccImE; else goto ccImD;
       ccImE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccImD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccImC::I64;
           R2 = lvl63_rcHqF_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.946548115 UTC

[section ""data" . lvl65_rcHqH_closure" {
     lvl65_rcHqH_closure:
         const lvl65_rcHqH_info;
         const 0;
 },
 lvl65_rcHqH_entry() //  [R2]
         { info_tbl: [(ccImM,
                       label: lvl65_rcHqH_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccImM: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           call GHC.Int.$fReadInt64_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.947547681 UTC

[section ""data" . lvl66_rcHqI_closure" {
     lvl66_rcHqI_closure:
         const lvl66_rcHqI_info;
         const 0;
 },
 lvl66_rcHqI_entry() //  [R2, R3]
         { info_tbl: [(ccImW,
                       label: lvl66_rcHqI_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccImW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccImX; else goto ccImY;
       ccImX: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl66_rcHqI_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccImY: // global
           I64[Sp - 8] = block_ccImT_info;
           R3 = R3;
           R2 = lvl65_rcHqH_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccImT() //  [R1]
         { info_tbl: [(ccImT,
                       label: block_ccImT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccImT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIn1; else goto ccIn0;
       ccIn1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIn0: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.94863478 UTC

[section ""cstring" . lvl67_rcHqJ_bytes" {
     lvl67_rcHqJ_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.949736425 UTC

[section ""data" . lvl68_rcHqK_closure" {
     lvl68_rcHqK_closure:
         const lvl68_rcHqK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl68_rcHqK_entry() //  [R1]
         { info_tbl: [(ccIn8,
                       label: lvl68_rcHqK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIn8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIn9; else goto ccIna;
       ccIn9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIna: // global
           (_ccIn5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIn5::I64 == 0) goto ccIn7; else goto ccIn6;
       ccIn7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIn6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIn5::I64;
           R2 = lvl67_rcHqJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.950630018 UTC

[section ""cstring" . lvl69_rcHqL_bytes" {
     lvl69_rcHqL_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.951373813 UTC

[section ""data" . lvl70_rcHqM_closure" {
     lvl70_rcHqM_closure:
         const lvl70_rcHqM_info;
         const 0;
         const 0;
         const 0;
 },
 lvl70_rcHqM_entry() //  [R1]
         { info_tbl: [(ccInh,
                       label: lvl70_rcHqM_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccInh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIni; else goto ccInj;
       ccIni: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccInj: // global
           (_ccIne::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIne::I64 == 0) goto ccIng; else goto ccInf;
       ccIng: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccInf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIne::I64;
           R2 = lvl69_rcHqL_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.952470147 UTC

[section ""data" . lvl71_rcHqN_closure" {
     lvl71_rcHqN_closure:
         const lvl71_rcHqN_info;
         const 0;
         const 0;
         const 0;
 },
 lvl71_rcHqN_entry() //  [R1]
         { info_tbl: [(ccInq,
                       label: lvl71_rcHqN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccInq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccInr; else goto ccIns;
       ccInr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIns: // global
           (_ccInn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccInn::I64 == 0) goto ccInp; else goto ccIno;
       ccInp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIno: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccInn::I64;
           R2 = lvl15_rcHpK_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.953446901 UTC

[section ""data" . lvl72_rcHqO_closure" {
     lvl72_rcHqO_closure:
         const Text.Read.Lex.Punc_con_info;
         const lvl71_rcHqN_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.961883871 UTC

[section ""data" . GHC.Stats.$w$creadPrec_closure" {
     GHC.Stats.$w$creadPrec_closure:
         const GHC.Stats.$w$creadPrec_info;
         const 0;
 },
 sat_scHzh_entry() //  [R1, R2]
         { info_tbl: [(ccIq2,
                       label: sat_scHzh_info
                       rep:HeapRep 15 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIq2: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccIq6; else goto ccIq5;
       ccIq6: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIq5: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           _scHz8::P64 = P64[R1 + 95];
           _scHza::P64 = P64[R1 + 103];
           _scHzc::P64 = P64[R1 + 111];
           _scHze::P64 = P64[R1 + 119];
           I64[Hp - 112] = GHC.Stats.GCDetails_con_info;
           P64[Hp - 104] = _scHyO::P64;
           P64[Hp - 96] = _scHyQ::P64;
           P64[Hp - 88] = _scHyS::P64;
           P64[Hp - 80] = _scHyU::P64;
           P64[Hp - 72] = _scHyW::P64;
           P64[Hp - 64] = _scHyY::P64;
           P64[Hp - 56] = _scHz0::P64;
           P64[Hp - 48] = _scHz2::P64;
           P64[Hp - 40] = _scHz4::P64;
           P64[Hp - 32] = _scHz6::P64;
           P64[Hp - 24] = _scHz8::P64;
           P64[Hp - 16] = _scHza::P64;
           P64[Hp - 8] = _scHzc::P64;
           P64[Hp] = _scHze::P64;
           R2 = Hp - 111;
           R1 = _scHyK::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzk_entry() //  [R1, R2]
         { info_tbl: [(ccIqa,
                       label: sat_scHzk_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIqa: // global
           _scHze::P64 = R2;
           _scHzk::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIqb; else goto ccIqc;
       ccIqc: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccIqe; else goto ccIqd;
       ccIqe: // global
           HpAlloc = 128;
           goto ccIqb;
       ccIqb: // global
           R2 = _scHze::P64;
           R1 = _scHzk::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIqd: // global
           _scHyK::P64 = P64[_scHzk::P64 + 7];
           _scHyO::P64 = P64[_scHzk::P64 + 15];
           _scHyQ::P64 = P64[_scHzk::P64 + 23];
           _scHyS::P64 = P64[_scHzk::P64 + 31];
           _scHyU::P64 = P64[_scHzk::P64 + 39];
           _scHyW::P64 = P64[_scHzk::P64 + 47];
           _scHyY::P64 = P64[_scHzk::P64 + 55];
           _scHz0::P64 = P64[_scHzk::P64 + 63];
           _scHz2::P64 = P64[_scHzk::P64 + 71];
           _scHz4::P64 = P64[_scHzk::P64 + 79];
           _scHz6::P64 = P64[_scHzk::P64 + 87];
           _scHz8::P64 = P64[_scHzk::P64 + 95];
           _scHza::P64 = P64[_scHzk::P64 + 103];
           _scHzc::P64 = P64[_scHzk::P64 + 111];
           I64[Hp - 120] = sat_scHzh_info;
           P64[Hp - 112] = _scHyK::P64;
           P64[Hp - 104] = _scHyO::P64;
           P64[Hp - 96] = _scHyQ::P64;
           P64[Hp - 88] = _scHyS::P64;
           P64[Hp - 80] = _scHyU::P64;
           P64[Hp - 72] = _scHyW::P64;
           P64[Hp - 64] = _scHyY::P64;
           P64[Hp - 56] = _scHz0::P64;
           P64[Hp - 48] = _scHz2::P64;
           P64[Hp - 40] = _scHz4::P64;
           P64[Hp - 32] = _scHz6::P64;
           P64[Hp - 24] = _scHz8::P64;
           P64[Hp - 16] = _scHza::P64;
           P64[Hp - 8] = _scHzc::P64;
           P64[Hp] = _scHze::P64;
           I64[Sp - 8] = block_ccIq7_info;
           R3 = Hp - 119;
           R2 = lvl72_rcHqO_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIq7() //  [R1]
         { info_tbl: [(ccIq7,
                       label: block_ccIq7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIq7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIqh; else goto ccIqg;
       ccIqh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIqg: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzl_entry() //  [R1, R2]
         { info_tbl: [(ccIqi,
                       label: sat_scHzl_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIqi: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccIqm; else goto ccIql;
       ccIqm: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIql: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           _scHz8::P64 = P64[R1 + 95];
           _scHza::P64 = P64[R1 + 103];
           _scHzc::P64 = P64[R1 + 111];
           I64[Hp - 112] = sat_scHzk_info;
           P64[Hp - 104] = _scHyK::P64;
           P64[Hp - 96] = _scHyO::P64;
           P64[Hp - 88] = _scHyQ::P64;
           P64[Hp - 80] = _scHyS::P64;
           P64[Hp - 72] = _scHyU::P64;
           P64[Hp - 64] = _scHyW::P64;
           P64[Hp - 56] = _scHyY::P64;
           P64[Hp - 48] = _scHz0::P64;
           P64[Hp - 40] = _scHz2::P64;
           P64[Hp - 32] = _scHz4::P64;
           P64[Hp - 24] = _scHz6::P64;
           P64[Hp - 16] = _scHz8::P64;
           P64[Hp - 8] = _scHza::P64;
           P64[Hp] = _scHzc::P64;
           R5 = Hp - 111;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl70_rcHqM_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzo_entry() //  [R1, R2]
         { info_tbl: [(ccIqq,
                       label: sat_scHzo_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIqq: // global
           _scHzc::P64 = R2;
           _scHzo::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIqr; else goto ccIqs;
       ccIqs: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccIqu; else goto ccIqt;
       ccIqu: // global
           HpAlloc = 120;
           goto ccIqr;
       ccIqr: // global
           R2 = _scHzc::P64;
           R1 = _scHzo::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIqt: // global
           _scHyK::P64 = P64[_scHzo::P64 + 7];
           _scHyO::P64 = P64[_scHzo::P64 + 15];
           _scHyQ::P64 = P64[_scHzo::P64 + 23];
           _scHyS::P64 = P64[_scHzo::P64 + 31];
           _scHyU::P64 = P64[_scHzo::P64 + 39];
           _scHyW::P64 = P64[_scHzo::P64 + 47];
           _scHyY::P64 = P64[_scHzo::P64 + 55];
           _scHz0::P64 = P64[_scHzo::P64 + 63];
           _scHz2::P64 = P64[_scHzo::P64 + 71];
           _scHz4::P64 = P64[_scHzo::P64 + 79];
           _scHz6::P64 = P64[_scHzo::P64 + 87];
           _scHz8::P64 = P64[_scHzo::P64 + 95];
           _scHza::P64 = P64[_scHzo::P64 + 103];
           I64[Hp - 112] = sat_scHzl_info;
           P64[Hp - 104] = _scHyK::P64;
           P64[Hp - 96] = _scHyO::P64;
           P64[Hp - 88] = _scHyQ::P64;
           P64[Hp - 80] = _scHyS::P64;
           P64[Hp - 72] = _scHyU::P64;
           P64[Hp - 64] = _scHyW::P64;
           P64[Hp - 56] = _scHyY::P64;
           P64[Hp - 48] = _scHz0::P64;
           P64[Hp - 40] = _scHz2::P64;
           P64[Hp - 32] = _scHz4::P64;
           P64[Hp - 24] = _scHz6::P64;
           P64[Hp - 16] = _scHz8::P64;
           P64[Hp - 8] = _scHza::P64;
           P64[Hp] = _scHzc::P64;
           I64[Sp - 8] = block_ccIqn_info;
           R3 = Hp - 111;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIqn() //  [R1]
         { info_tbl: [(ccIqn,
                       label: block_ccIqn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIqn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIqx; else goto ccIqw;
       ccIqx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIqw: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzp_entry() //  [R1, R2]
         { info_tbl: [(ccIqy,
                       label: sat_scHzp_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIqy: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccIqC; else goto ccIqB;
       ccIqC: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIqB: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           _scHz8::P64 = P64[R1 + 95];
           _scHza::P64 = P64[R1 + 103];
           I64[Hp - 104] = sat_scHzo_info;
           P64[Hp - 96] = _scHyK::P64;
           P64[Hp - 88] = _scHyO::P64;
           P64[Hp - 80] = _scHyQ::P64;
           P64[Hp - 72] = _scHyS::P64;
           P64[Hp - 64] = _scHyU::P64;
           P64[Hp - 56] = _scHyW::P64;
           P64[Hp - 48] = _scHyY::P64;
           P64[Hp - 40] = _scHz0::P64;
           P64[Hp - 32] = _scHz2::P64;
           P64[Hp - 24] = _scHz4::P64;
           P64[Hp - 16] = _scHz6::P64;
           P64[Hp - 8] = _scHz8::P64;
           P64[Hp] = _scHza::P64;
           R5 = Hp - 103;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl68_rcHqK_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzs_entry() //  [R1, R2]
         { info_tbl: [(ccIqG,
                       label: sat_scHzs_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIqG: // global
           _scHza::P64 = R2;
           _scHzs::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIqH; else goto ccIqI;
       ccIqI: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccIqK; else goto ccIqJ;
       ccIqK: // global
           HpAlloc = 112;
           goto ccIqH;
       ccIqH: // global
           R2 = _scHza::P64;
           R1 = _scHzs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIqJ: // global
           _scHyK::P64 = P64[_scHzs::P64 + 7];
           _scHyO::P64 = P64[_scHzs::P64 + 15];
           _scHyQ::P64 = P64[_scHzs::P64 + 23];
           _scHyS::P64 = P64[_scHzs::P64 + 31];
           _scHyU::P64 = P64[_scHzs::P64 + 39];
           _scHyW::P64 = P64[_scHzs::P64 + 47];
           _scHyY::P64 = P64[_scHzs::P64 + 55];
           _scHz0::P64 = P64[_scHzs::P64 + 63];
           _scHz2::P64 = P64[_scHzs::P64 + 71];
           _scHz4::P64 = P64[_scHzs::P64 + 79];
           _scHz6::P64 = P64[_scHzs::P64 + 87];
           _scHz8::P64 = P64[_scHzs::P64 + 95];
           I64[Hp - 104] = sat_scHzp_info;
           P64[Hp - 96] = _scHyK::P64;
           P64[Hp - 88] = _scHyO::P64;
           P64[Hp - 80] = _scHyQ::P64;
           P64[Hp - 72] = _scHyS::P64;
           P64[Hp - 64] = _scHyU::P64;
           P64[Hp - 56] = _scHyW::P64;
           P64[Hp - 48] = _scHyY::P64;
           P64[Hp - 40] = _scHz0::P64;
           P64[Hp - 32] = _scHz2::P64;
           P64[Hp - 24] = _scHz4::P64;
           P64[Hp - 16] = _scHz6::P64;
           P64[Hp - 8] = _scHz8::P64;
           P64[Hp] = _scHza::P64;
           I64[Sp - 8] = block_ccIqD_info;
           R3 = Hp - 103;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIqD() //  [R1]
         { info_tbl: [(ccIqD,
                       label: block_ccIqD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIqD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIqN; else goto ccIqM;
       ccIqN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIqM: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzt_entry() //  [R1, R2]
         { info_tbl: [(ccIqO,
                       label: sat_scHzt_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIqO: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccIqS; else goto ccIqR;
       ccIqS: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIqR: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           _scHz8::P64 = P64[R1 + 95];
           I64[Hp - 96] = sat_scHzs_info;
           P64[Hp - 88] = _scHyK::P64;
           P64[Hp - 80] = _scHyO::P64;
           P64[Hp - 72] = _scHyQ::P64;
           P64[Hp - 64] = _scHyS::P64;
           P64[Hp - 56] = _scHyU::P64;
           P64[Hp - 48] = _scHyW::P64;
           P64[Hp - 40] = _scHyY::P64;
           P64[Hp - 32] = _scHz0::P64;
           P64[Hp - 24] = _scHz2::P64;
           P64[Hp - 16] = _scHz4::P64;
           P64[Hp - 8] = _scHz6::P64;
           P64[Hp] = _scHz8::P64;
           R5 = Hp - 95;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl64_rcHqG_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzw_entry() //  [R1, R2]
         { info_tbl: [(ccIqW,
                       label: sat_scHzw_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIqW: // global
           _scHz8::P64 = R2;
           _scHzw::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIqX; else goto ccIqY;
       ccIqY: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccIr0; else goto ccIqZ;
       ccIr0: // global
           HpAlloc = 104;
           goto ccIqX;
       ccIqX: // global
           R2 = _scHz8::P64;
           R1 = _scHzw::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIqZ: // global
           _scHyK::P64 = P64[_scHzw::P64 + 7];
           _scHyO::P64 = P64[_scHzw::P64 + 15];
           _scHyQ::P64 = P64[_scHzw::P64 + 23];
           _scHyS::P64 = P64[_scHzw::P64 + 31];
           _scHyU::P64 = P64[_scHzw::P64 + 39];
           _scHyW::P64 = P64[_scHzw::P64 + 47];
           _scHyY::P64 = P64[_scHzw::P64 + 55];
           _scHz0::P64 = P64[_scHzw::P64 + 63];
           _scHz2::P64 = P64[_scHzw::P64 + 71];
           _scHz4::P64 = P64[_scHzw::P64 + 79];
           _scHz6::P64 = P64[_scHzw::P64 + 87];
           I64[Hp - 96] = sat_scHzt_info;
           P64[Hp - 88] = _scHyK::P64;
           P64[Hp - 80] = _scHyO::P64;
           P64[Hp - 72] = _scHyQ::P64;
           P64[Hp - 64] = _scHyS::P64;
           P64[Hp - 56] = _scHyU::P64;
           P64[Hp - 48] = _scHyW::P64;
           P64[Hp - 40] = _scHyY::P64;
           P64[Hp - 32] = _scHz0::P64;
           P64[Hp - 24] = _scHz2::P64;
           P64[Hp - 16] = _scHz4::P64;
           P64[Hp - 8] = _scHz6::P64;
           P64[Hp] = _scHz8::P64;
           I64[Sp - 8] = block_ccIqT_info;
           R3 = Hp - 95;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIqT() //  [R1]
         { info_tbl: [(ccIqT,
                       label: block_ccIqT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIqT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIr3; else goto ccIr2;
       ccIr3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIr2: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzx_entry() //  [R1, R2]
         { info_tbl: [(ccIr4,
                       label: sat_scHzx_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIr4: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccIr8; else goto ccIr7;
       ccIr8: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIr7: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           I64[Hp - 88] = sat_scHzw_info;
           P64[Hp - 80] = _scHyK::P64;
           P64[Hp - 72] = _scHyO::P64;
           P64[Hp - 64] = _scHyQ::P64;
           P64[Hp - 56] = _scHyS::P64;
           P64[Hp - 48] = _scHyU::P64;
           P64[Hp - 40] = _scHyW::P64;
           P64[Hp - 32] = _scHyY::P64;
           P64[Hp - 24] = _scHz0::P64;
           P64[Hp - 16] = _scHz2::P64;
           P64[Hp - 8] = _scHz4::P64;
           P64[Hp] = _scHz6::P64;
           R5 = Hp - 87;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl62_rcHqE_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzA_entry() //  [R1, R2]
         { info_tbl: [(ccIrc,
                       label: sat_scHzA_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIrc: // global
           _scHz6::P64 = R2;
           _scHzA::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIrd; else goto ccIre;
       ccIre: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccIrg; else goto ccIrf;
       ccIrg: // global
           HpAlloc = 96;
           goto ccIrd;
       ccIrd: // global
           R2 = _scHz6::P64;
           R1 = _scHzA::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIrf: // global
           _scHyK::P64 = P64[_scHzA::P64 + 7];
           _scHyO::P64 = P64[_scHzA::P64 + 15];
           _scHyQ::P64 = P64[_scHzA::P64 + 23];
           _scHyS::P64 = P64[_scHzA::P64 + 31];
           _scHyU::P64 = P64[_scHzA::P64 + 39];
           _scHyW::P64 = P64[_scHzA::P64 + 47];
           _scHyY::P64 = P64[_scHzA::P64 + 55];
           _scHz0::P64 = P64[_scHzA::P64 + 63];
           _scHz2::P64 = P64[_scHzA::P64 + 71];
           _scHz4::P64 = P64[_scHzA::P64 + 79];
           I64[Hp - 88] = sat_scHzx_info;
           P64[Hp - 80] = _scHyK::P64;
           P64[Hp - 72] = _scHyO::P64;
           P64[Hp - 64] = _scHyQ::P64;
           P64[Hp - 56] = _scHyS::P64;
           P64[Hp - 48] = _scHyU::P64;
           P64[Hp - 40] = _scHyW::P64;
           P64[Hp - 32] = _scHyY::P64;
           P64[Hp - 24] = _scHz0::P64;
           P64[Hp - 16] = _scHz2::P64;
           P64[Hp - 8] = _scHz4::P64;
           P64[Hp] = _scHz6::P64;
           I64[Sp - 8] = block_ccIr9_info;
           R3 = Hp - 87;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIr9() //  [R1]
         { info_tbl: [(ccIr9,
                       label: block_ccIr9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIr9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIrj; else goto ccIri;
       ccIrj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIri: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzB_entry() //  [R1, R2]
         { info_tbl: [(ccIrk,
                       label: sat_scHzB_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIrk: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccIro; else goto ccIrn;
       ccIro: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIrn: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           I64[Hp - 80] = sat_scHzA_info;
           P64[Hp - 72] = _scHyK::P64;
           P64[Hp - 64] = _scHyO::P64;
           P64[Hp - 56] = _scHyQ::P64;
           P64[Hp - 48] = _scHyS::P64;
           P64[Hp - 40] = _scHyU::P64;
           P64[Hp - 32] = _scHyW::P64;
           P64[Hp - 24] = _scHyY::P64;
           P64[Hp - 16] = _scHz0::P64;
           P64[Hp - 8] = _scHz2::P64;
           P64[Hp] = _scHz4::P64;
           R5 = Hp - 79;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl60_rcHqC_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzE_entry() //  [R1, R2]
         { info_tbl: [(ccIrs,
                       label: sat_scHzE_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIrs: // global
           _scHz4::P64 = R2;
           _scHzE::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIrt; else goto ccIru;
       ccIru: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccIrw; else goto ccIrv;
       ccIrw: // global
           HpAlloc = 88;
           goto ccIrt;
       ccIrt: // global
           R2 = _scHz4::P64;
           R1 = _scHzE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIrv: // global
           _scHyK::P64 = P64[_scHzE::P64 + 7];
           _scHyO::P64 = P64[_scHzE::P64 + 15];
           _scHyQ::P64 = P64[_scHzE::P64 + 23];
           _scHyS::P64 = P64[_scHzE::P64 + 31];
           _scHyU::P64 = P64[_scHzE::P64 + 39];
           _scHyW::P64 = P64[_scHzE::P64 + 47];
           _scHyY::P64 = P64[_scHzE::P64 + 55];
           _scHz0::P64 = P64[_scHzE::P64 + 63];
           _scHz2::P64 = P64[_scHzE::P64 + 71];
           I64[Hp - 80] = sat_scHzB_info;
           P64[Hp - 72] = _scHyK::P64;
           P64[Hp - 64] = _scHyO::P64;
           P64[Hp - 56] = _scHyQ::P64;
           P64[Hp - 48] = _scHyS::P64;
           P64[Hp - 40] = _scHyU::P64;
           P64[Hp - 32] = _scHyW::P64;
           P64[Hp - 24] = _scHyY::P64;
           P64[Hp - 16] = _scHz0::P64;
           P64[Hp - 8] = _scHz2::P64;
           P64[Hp] = _scHz4::P64;
           I64[Sp - 8] = block_ccIrp_info;
           R3 = Hp - 79;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIrp() //  [R1]
         { info_tbl: [(ccIrp,
                       label: block_ccIrp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIrp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIrz; else goto ccIry;
       ccIrz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIry: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzF_entry() //  [R1, R2]
         { info_tbl: [(ccIrA,
                       label: sat_scHzF_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIrA: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccIrE; else goto ccIrD;
       ccIrE: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIrD: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           I64[Hp - 72] = sat_scHzE_info;
           P64[Hp - 64] = _scHyK::P64;
           P64[Hp - 56] = _scHyO::P64;
           P64[Hp - 48] = _scHyQ::P64;
           P64[Hp - 40] = _scHyS::P64;
           P64[Hp - 32] = _scHyU::P64;
           P64[Hp - 24] = _scHyW::P64;
           P64[Hp - 16] = _scHyY::P64;
           P64[Hp - 8] = _scHz0::P64;
           P64[Hp] = _scHz2::P64;
           R5 = Hp - 71;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl58_rcHqA_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzI_entry() //  [R1, R2]
         { info_tbl: [(ccIrI,
                       label: sat_scHzI_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIrI: // global
           _scHz2::P64 = R2;
           _scHzI::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIrJ; else goto ccIrK;
       ccIrK: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccIrM; else goto ccIrL;
       ccIrM: // global
           HpAlloc = 80;
           goto ccIrJ;
       ccIrJ: // global
           R2 = _scHz2::P64;
           R1 = _scHzI::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIrL: // global
           _scHyK::P64 = P64[_scHzI::P64 + 7];
           _scHyO::P64 = P64[_scHzI::P64 + 15];
           _scHyQ::P64 = P64[_scHzI::P64 + 23];
           _scHyS::P64 = P64[_scHzI::P64 + 31];
           _scHyU::P64 = P64[_scHzI::P64 + 39];
           _scHyW::P64 = P64[_scHzI::P64 + 47];
           _scHyY::P64 = P64[_scHzI::P64 + 55];
           _scHz0::P64 = P64[_scHzI::P64 + 63];
           I64[Hp - 72] = sat_scHzF_info;
           P64[Hp - 64] = _scHyK::P64;
           P64[Hp - 56] = _scHyO::P64;
           P64[Hp - 48] = _scHyQ::P64;
           P64[Hp - 40] = _scHyS::P64;
           P64[Hp - 32] = _scHyU::P64;
           P64[Hp - 24] = _scHyW::P64;
           P64[Hp - 16] = _scHyY::P64;
           P64[Hp - 8] = _scHz0::P64;
           P64[Hp] = _scHz2::P64;
           I64[Sp - 8] = block_ccIrF_info;
           R3 = Hp - 71;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIrF() //  [R1]
         { info_tbl: [(ccIrF,
                       label: block_ccIrF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIrF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIrP; else goto ccIrO;
       ccIrP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIrO: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzJ_entry() //  [R1, R2]
         { info_tbl: [(ccIrQ,
                       label: sat_scHzJ_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIrQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccIrU; else goto ccIrT;
       ccIrU: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIrT: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           I64[Hp - 64] = sat_scHzI_info;
           P64[Hp - 56] = _scHyK::P64;
           P64[Hp - 48] = _scHyO::P64;
           P64[Hp - 40] = _scHyQ::P64;
           P64[Hp - 32] = _scHyS::P64;
           P64[Hp - 24] = _scHyU::P64;
           P64[Hp - 16] = _scHyW::P64;
           P64[Hp - 8] = _scHyY::P64;
           P64[Hp] = _scHz0::P64;
           R5 = Hp - 63;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl56_rcHqy_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzM_entry() //  [R1, R2]
         { info_tbl: [(ccIrY,
                       label: sat_scHzM_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIrY: // global
           _scHz0::P64 = R2;
           _scHzM::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIrZ; else goto ccIs0;
       ccIs0: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccIs2; else goto ccIs1;
       ccIs2: // global
           HpAlloc = 72;
           goto ccIrZ;
       ccIrZ: // global
           R2 = _scHz0::P64;
           R1 = _scHzM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIs1: // global
           _scHyK::P64 = P64[_scHzM::P64 + 7];
           _scHyO::P64 = P64[_scHzM::P64 + 15];
           _scHyQ::P64 = P64[_scHzM::P64 + 23];
           _scHyS::P64 = P64[_scHzM::P64 + 31];
           _scHyU::P64 = P64[_scHzM::P64 + 39];
           _scHyW::P64 = P64[_scHzM::P64 + 47];
           _scHyY::P64 = P64[_scHzM::P64 + 55];
           I64[Hp - 64] = sat_scHzJ_info;
           P64[Hp - 56] = _scHyK::P64;
           P64[Hp - 48] = _scHyO::P64;
           P64[Hp - 40] = _scHyQ::P64;
           P64[Hp - 32] = _scHyS::P64;
           P64[Hp - 24] = _scHyU::P64;
           P64[Hp - 16] = _scHyW::P64;
           P64[Hp - 8] = _scHyY::P64;
           P64[Hp] = _scHz0::P64;
           I64[Sp - 8] = block_ccIrV_info;
           R3 = Hp - 63;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIrV() //  [R1]
         { info_tbl: [(ccIrV,
                       label: block_ccIrV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIrV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIs5; else goto ccIs4;
       ccIs5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIs4: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzN_entry() //  [R1, R2]
         { info_tbl: [(ccIs6,
                       label: sat_scHzN_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIs6: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccIsa; else goto ccIs9;
       ccIsa: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIs9: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           I64[Hp - 56] = sat_scHzM_info;
           P64[Hp - 48] = _scHyK::P64;
           P64[Hp - 40] = _scHyO::P64;
           P64[Hp - 32] = _scHyQ::P64;
           P64[Hp - 24] = _scHyS::P64;
           P64[Hp - 16] = _scHyU::P64;
           P64[Hp - 8] = _scHyW::P64;
           P64[Hp] = _scHyY::P64;
           R5 = Hp - 55;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl54_rcHqw_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzQ_entry() //  [R1, R2]
         { info_tbl: [(ccIse,
                       label: sat_scHzQ_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIse: // global
           _scHyY::P64 = R2;
           _scHzQ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIsf; else goto ccIsg;
       ccIsg: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccIsi; else goto ccIsh;
       ccIsi: // global
           HpAlloc = 64;
           goto ccIsf;
       ccIsf: // global
           R2 = _scHyY::P64;
           R1 = _scHzQ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIsh: // global
           _scHyK::P64 = P64[_scHzQ::P64 + 7];
           _scHyO::P64 = P64[_scHzQ::P64 + 15];
           _scHyQ::P64 = P64[_scHzQ::P64 + 23];
           _scHyS::P64 = P64[_scHzQ::P64 + 31];
           _scHyU::P64 = P64[_scHzQ::P64 + 39];
           _scHyW::P64 = P64[_scHzQ::P64 + 47];
           I64[Hp - 56] = sat_scHzN_info;
           P64[Hp - 48] = _scHyK::P64;
           P64[Hp - 40] = _scHyO::P64;
           P64[Hp - 32] = _scHyQ::P64;
           P64[Hp - 24] = _scHyS::P64;
           P64[Hp - 16] = _scHyU::P64;
           P64[Hp - 8] = _scHyW::P64;
           P64[Hp] = _scHyY::P64;
           I64[Sp - 8] = block_ccIsb_info;
           R3 = Hp - 55;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIsb() //  [R1]
         { info_tbl: [(ccIsb,
                       label: block_ccIsb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIsb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIsl; else goto ccIsk;
       ccIsl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIsk: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzR_entry() //  [R1, R2]
         { info_tbl: [(ccIsm,
                       label: sat_scHzR_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIsm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccIsq; else goto ccIsp;
       ccIsq: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIsp: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           I64[Hp - 48] = sat_scHzQ_info;
           P64[Hp - 40] = _scHyK::P64;
           P64[Hp - 32] = _scHyO::P64;
           P64[Hp - 24] = _scHyQ::P64;
           P64[Hp - 16] = _scHyS::P64;
           P64[Hp - 8] = _scHyU::P64;
           P64[Hp] = _scHyW::P64;
           R5 = Hp - 47;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl52_rcHqu_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzU_entry() //  [R1, R2]
         { info_tbl: [(ccIsu,
                       label: sat_scHzU_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIsu: // global
           _scHyW::P64 = R2;
           _scHzU::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIsv; else goto ccIsw;
       ccIsw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccIsy; else goto ccIsx;
       ccIsy: // global
           HpAlloc = 56;
           goto ccIsv;
       ccIsv: // global
           R2 = _scHyW::P64;
           R1 = _scHzU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIsx: // global
           _scHyK::P64 = P64[_scHzU::P64 + 7];
           _scHyO::P64 = P64[_scHzU::P64 + 15];
           _scHyQ::P64 = P64[_scHzU::P64 + 23];
           _scHyS::P64 = P64[_scHzU::P64 + 31];
           _scHyU::P64 = P64[_scHzU::P64 + 39];
           I64[Hp - 48] = sat_scHzR_info;
           P64[Hp - 40] = _scHyK::P64;
           P64[Hp - 32] = _scHyO::P64;
           P64[Hp - 24] = _scHyQ::P64;
           P64[Hp - 16] = _scHyS::P64;
           P64[Hp - 8] = _scHyU::P64;
           P64[Hp] = _scHyW::P64;
           I64[Sp - 8] = block_ccIsr_info;
           R3 = Hp - 47;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIsr() //  [R1]
         { info_tbl: [(ccIsr,
                       label: block_ccIsr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIsr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIsB; else goto ccIsA;
       ccIsB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIsA: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzV_entry() //  [R1, R2]
         { info_tbl: [(ccIsC,
                       label: sat_scHzV_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIsC: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccIsG; else goto ccIsF;
       ccIsG: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIsF: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           I64[Hp - 40] = sat_scHzU_info;
           P64[Hp - 32] = _scHyK::P64;
           P64[Hp - 24] = _scHyO::P64;
           P64[Hp - 16] = _scHyQ::P64;
           P64[Hp - 8] = _scHyS::P64;
           P64[Hp] = _scHyU::P64;
           R5 = Hp - 39;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl50_rcHqs_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzY_entry() //  [R1, R2]
         { info_tbl: [(ccIsK,
                       label: sat_scHzY_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIsK: // global
           _scHyU::P64 = R2;
           _scHzY::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIsL; else goto ccIsM;
       ccIsM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccIsO; else goto ccIsN;
       ccIsO: // global
           HpAlloc = 48;
           goto ccIsL;
       ccIsL: // global
           R2 = _scHyU::P64;
           R1 = _scHzY::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIsN: // global
           _scHyK::P64 = P64[_scHzY::P64 + 7];
           _scHyO::P64 = P64[_scHzY::P64 + 15];
           _scHyQ::P64 = P64[_scHzY::P64 + 23];
           _scHyS::P64 = P64[_scHzY::P64 + 31];
           I64[Hp - 40] = sat_scHzV_info;
           P64[Hp - 32] = _scHyK::P64;
           P64[Hp - 24] = _scHyO::P64;
           P64[Hp - 16] = _scHyQ::P64;
           P64[Hp - 8] = _scHyS::P64;
           P64[Hp] = _scHyU::P64;
           I64[Sp - 8] = block_ccIsH_info;
           R3 = Hp - 39;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIsH() //  [R1]
         { info_tbl: [(ccIsH,
                       label: block_ccIsH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIsH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIsR; else goto ccIsQ;
       ccIsR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIsQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzZ_entry() //  [R1, R2]
         { info_tbl: [(ccIsS,
                       label: sat_scHzZ_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIsS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccIsW; else goto ccIsV;
       ccIsW: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIsV: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           I64[Hp - 32] = sat_scHzY_info;
           P64[Hp - 24] = _scHyK::P64;
           P64[Hp - 16] = _scHyO::P64;
           P64[Hp - 8] = _scHyQ::P64;
           P64[Hp] = _scHyS::P64;
           R5 = Hp - 31;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl48_rcHqq_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHA2_entry() //  [R1, R2]
         { info_tbl: [(ccIt0,
                       label: sat_scHA2_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIt0: // global
           _scHyS::P64 = R2;
           _scHA2::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIt1; else goto ccIt2;
       ccIt2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccIt4; else goto ccIt3;
       ccIt4: // global
           HpAlloc = 40;
           goto ccIt1;
       ccIt1: // global
           R2 = _scHyS::P64;
           R1 = _scHA2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIt3: // global
           _scHyK::P64 = P64[_scHA2::P64 + 7];
           _scHyO::P64 = P64[_scHA2::P64 + 15];
           _scHyQ::P64 = P64[_scHA2::P64 + 23];
           I64[Hp - 32] = sat_scHzZ_info;
           P64[Hp - 24] = _scHyK::P64;
           P64[Hp - 16] = _scHyO::P64;
           P64[Hp - 8] = _scHyQ::P64;
           P64[Hp] = _scHyS::P64;
           I64[Sp - 8] = block_ccIsX_info;
           R3 = Hp - 31;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIsX() //  [R1]
         { info_tbl: [(ccIsX,
                       label: block_ccIsX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIsX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIt7; else goto ccIt6;
       ccIt7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIt6: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHA3_entry() //  [R1, R2]
         { info_tbl: [(ccIt8,
                       label: sat_scHA3_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIt8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccItc; else goto ccItb;
       ccItc: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccItb: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           I64[Hp - 24] = sat_scHA2_info;
           P64[Hp - 16] = _scHyK::P64;
           P64[Hp - 8] = _scHyO::P64;
           P64[Hp] = _scHyQ::P64;
           R5 = Hp - 23;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl44_rcHqm_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHA6_entry() //  [R1, R2]
         { info_tbl: [(ccItg,
                       label: sat_scHA6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccItg: // global
           _scHyQ::P64 = R2;
           _scHA6::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIth; else goto ccIti;
       ccIti: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccItk; else goto ccItj;
       ccItk: // global
           HpAlloc = 32;
           goto ccIth;
       ccIth: // global
           R2 = _scHyQ::P64;
           R1 = _scHA6::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccItj: // global
           _scHyK::P64 = P64[_scHA6::P64 + 7];
           _scHyO::P64 = P64[_scHA6::P64 + 15];
           I64[Hp - 24] = sat_scHA3_info;
           P64[Hp - 16] = _scHyK::P64;
           P64[Hp - 8] = _scHyO::P64;
           P64[Hp] = _scHyQ::P64;
           I64[Sp - 8] = block_ccItd_info;
           R3 = Hp - 23;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccItd() //  [R1]
         { info_tbl: [(ccItd,
                       label: block_ccItd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccItd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccItn; else goto ccItm;
       ccItn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccItm: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHA7_entry() //  [R1, R2]
         { info_tbl: [(ccIto,
                       label: sat_scHA7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIto: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIts; else goto ccItr;
       ccIts: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccItr: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_scHA6_info;
           P64[Hp - 8] = _scHyK::P64;
           P64[Hp] = _scHyO::P64;
           R5 = Hp - 15;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = lvl42_rcHqk_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHAa_entry() //  [R1, R2]
         { info_tbl: [(ccItw,
                       label: sat_scHAa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccItw: // global
           _scHyO::P64 = R2;
           _scHAa::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccItx; else goto ccIty;
       ccIty: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccItA; else goto ccItz;
       ccItA: // global
           HpAlloc = 24;
           goto ccItx;
       ccItx: // global
           R2 = _scHyO::P64;
           R1 = _scHAa::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccItz: // global
           _scHyK::P64 = P64[_scHAa::P64 + 7];
           I64[Hp - 16] = sat_scHA7_info;
           P64[Hp - 8] = _scHyK::P64;
           P64[Hp] = _scHyO::P64;
           I64[Sp - 8] = block_ccItt_info;
           R3 = Hp - 15;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccItt() //  [R1]
         { info_tbl: [(ccItt,
                       label: block_ccItt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccItt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccItD; else goto ccItC;
       ccItD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccItC: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHAb_entry() //  [R1, R2]
         { info_tbl: [(ccItE,
                       label: sat_scHAb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccItE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccItI; else goto ccItH;
       ccItI: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccItH: // global
           _scHyK::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_scHAa_info;
           P64[Hp] = _scHyK::P64;
           R5 = Hp - 7;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = ds1_rcHqc_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHAe_entry() //  [R1, R2]
         { info_tbl: [(ccItM,
                       label: sat_scHAe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccItM: // global
           _scHyM::P64 = R2;
           _scHAe::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccItN; else goto ccItO;
       ccItO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccItQ; else goto ccItP;
       ccItQ: // global
           HpAlloc = 16;
           goto ccItN;
       ccItN: // global
           R2 = _scHyM::P64;
           R1 = _scHAe::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccItP: // global
           _scHyK::P64 = P64[_scHAe::P64 + 7];
           I64[Hp - 8] = sat_scHAb_info;
           P64[Hp] = _scHyK::P64;
           I64[Sp - 8] = block_ccItJ_info;
           R3 = Hp - 7;
           R2 = lexeme4_rcHqa_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccItJ() //  [R1]
         { info_tbl: [(ccItJ,
                       label: block_ccItJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccItJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccItT; else goto ccItS;
       ccItT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccItS: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stats.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(ccItX,
                       label: GHC.Stats.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccItX: // global
           _scHyK::P64 = R3;
           _scHyJ::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccItY; else goto ccItZ;
       ccItZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIu1; else goto ccIu0;
       ccIu1: // global
           HpAlloc = 16;
           goto ccItY;
       ccItY: // global
           R3 = _scHyK::P64;
           R2 = _scHyJ::I64;
           R1 = GHC.Stats.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccIu0: // global
           if (%MO_S_Gt_W64(_scHyJ::I64, 11)) goto ccItV; else goto ccItW;
       ccItV: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccItW: // global
           I64[Hp - 8] = sat_scHAe_info;
           P64[Hp] = _scHyK::P64;
           I64[Sp - 8] = block_ccIu2_info;
           R3 = Hp - 7;
           R2 = lexeme1_rcHq7_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIu2() //  [R1]
         { info_tbl: [(ccIu2,
                       label: block_ccIu2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIu2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIu7; else goto ccIu6;
       ccIu7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIu6: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.983222595 UTC

[section ""data" . GHC.Stats.$fReadGCDetails2_closure" {
     GHC.Stats.$fReadGCDetails2_closure:
         const GHC.Stats.$fReadGCDetails2_info;
         const 0;
 },
 GHC.Stats.$fReadGCDetails2_entry() //  [R2, R3]
         { info_tbl: [(ccIuf,
                       label: GHC.Stats.$fReadGCDetails2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIuf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIug; else goto ccIuh;
       ccIug: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fReadGCDetails2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccIuh: // global
           I64[Sp - 16] = block_ccIuc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucIul; else goto ccIud;
       ucIul: // global
           call _ccIuc(R1) args: 0, res: 0, upd: 0;
       ccIud: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIuc() //  [R1]
         { info_tbl: [(ccIuc,
                       label: block_ccIuc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIuc: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Stats.$w$creadPrec_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.98445397 UTC

[section ""data" . GHC.Stats.$fReadGCDetails1_closure" {
     GHC.Stats.$fReadGCDetails1_closure:
         const GHC.Stats.$fReadGCDetails1_info;
         const 0;
 },
 GHC.Stats.$fReadGCDetails1_entry() //  [R2, R3]
         { info_tbl: [(ccIuq,
                       label: GHC.Stats.$fReadGCDetails1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIuq: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fReadGCDetails2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.985572005 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_$creadsPrec_closure" {
     GHC.Stats.$fReadGCDetails_$creadsPrec_closure:
         const GHC.Stats.$fReadGCDetails_$creadsPrec_info;
         const 0;
 },
 sat_scHAm_entry() //  [R1]
         { info_tbl: [(ccIuB,
                       label: sat_scHAm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIuB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIuC; else goto ccIuD;
       ccIuC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIuD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Stats.$fReadGCDetails2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stats.$fReadGCDetails_$creadsPrec_entry() //  [R2]
         { info_tbl: [(ccIuE,
                       label: GHC.Stats.$fReadGCDetails_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIuE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIuI; else goto ccIuH;
       ccIuI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stats.$fReadGCDetails_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIuH: // global
           I64[Hp - 16] = sat_scHAm_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.986891427 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_$creadListPrec_closure" {
     GHC.Stats.$fReadGCDetails_$creadListPrec_closure:
         const GHC.Stats.$fReadGCDetails_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadGCDetails_$creadListPrec_entry() //  [R1]
         { info_tbl: [(ccIuP,
                       label: GHC.Stats.$fReadGCDetails_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIuP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIuQ; else goto ccIuR;
       ccIuQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIuR: // global
           (_ccIuM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIuM::I64 == 0) goto ccIuO; else goto ccIuN;
       ccIuO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIuN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIuM::I64;
           R2 = GHC.Stats.$fReadGCDetails1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.988015642 UTC

[section ""data" . GHC.Stats.$fReadGCDetails3_closure" {
     GHC.Stats.$fReadGCDetails3_closure:
         const GHC.Stats.$fReadGCDetails3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadGCDetails3_entry() //  [R1]
         { info_tbl: [(ccIuY,
                       label: GHC.Stats.$fReadGCDetails3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIuY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIuZ; else goto ccIv0;
       ccIuZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIv0: // global
           (_ccIuV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIuV::I64 == 0) goto ccIuX; else goto ccIuW;
       ccIuX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIuW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIuV::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.Stats.$fReadGCDetails_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.989059567 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_$creadList_closure" {
     GHC.Stats.$fReadGCDetails_$creadList_closure:
         const GHC.Stats.$fReadGCDetails_$creadList_info;
         const 0;
 },
 GHC.Stats.$fReadGCDetails_$creadList_entry() //  [R2]
         { info_tbl: [(ccIv5,
                       label: GHC.Stats.$fReadGCDetails_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIv5: // global
           R3 = R2;
           R2 = GHC.Stats.$fReadGCDetails3_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.989855003 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_closure" {
     GHC.Stats.$fReadGCDetails_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Stats.$fReadGCDetails_$creadsPrec_closure+1;
         const GHC.Stats.$fReadGCDetails_$creadList_closure+1;
         const GHC.Stats.$fReadGCDetails1_closure+2;
         const GHC.Stats.$fReadGCDetails_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.990468847 UTC

[section ""cstring" . GHC.Stats.$tcRTSStats2_bytes" {
     GHC.Stats.$tcRTSStats2_bytes:
         I8[] [82,84,83,83,116,97,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.991213869 UTC

[section ""data" . lexeme5_rcHqP_closure" {
     lexeme5_rcHqP_closure:
         const lexeme5_rcHqP_info;
         const 0;
         const 0;
         const 0;
 },
 lexeme5_rcHqP_entry() //  [R1]
         { info_tbl: [(ccIve,
                       label: lexeme5_rcHqP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIve: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIvf; else goto ccIvg;
       ccIvf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIvg: // global
           (_ccIvb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIvb::I64 == 0) goto ccIvd; else goto ccIvc;
       ccIvd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIvc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIvb::I64;
           R2 = GHC.Stats.$tcRTSStats2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.992164767 UTC

[section ""data" . lexeme6_rcHqQ_closure" {
     lexeme6_rcHqQ_closure:
         const Text.Read.Lex.Ident_con_info;
         const lexeme5_rcHqP_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.992726436 UTC

[section ""cstring" . ds3_rcHqR_bytes" {
     ds3_rcHqR_bytes:
         I8[] [103,99,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.993503104 UTC

[section ""data" . ds4_rcHqS_closure" {
     ds4_rcHqS_closure:
         const ds4_rcHqS_info;
         const 0;
         const 0;
         const 0;
 },
 ds4_rcHqS_entry() //  [R1]
         { info_tbl: [(ccIvn,
                       label: ds4_rcHqS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIvn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIvo; else goto ccIvp;
       ccIvo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIvp: // global
           (_ccIvk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIvk::I64 == 0) goto ccIvm; else goto ccIvl;
       ccIvm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIvl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIvk::I64;
           R2 = ds3_rcHqR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.995525811 UTC

[section ""cstring" . lvl73_rcHqT_bytes" {
     lvl73_rcHqT_bytes:
         I8[] [109,97,106,111,114,95,103,99,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.99621896 UTC

[section ""data" . lvl74_rcHqU_closure" {
     lvl74_rcHqU_closure:
         const lvl74_rcHqU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl74_rcHqU_entry() //  [R1]
         { info_tbl: [(ccIvw,
                       label: lvl74_rcHqU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIvw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIvx; else goto ccIvy;
       ccIvx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIvy: // global
           (_ccIvt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIvt::I64 == 0) goto ccIvv; else goto ccIvu;
       ccIvv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIvu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIvt::I64;
           R2 = lvl73_rcHqT_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.997046791 UTC

[section ""cstring" . lvl75_rcHqV_bytes" {
     lvl75_rcHqV_bytes:
         I8[] [97,108,108,111,99,97,116,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.997851933 UTC

[section ""data" . lvl76_rcHqW_closure" {
     lvl76_rcHqW_closure:
         const lvl76_rcHqW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl76_rcHqW_entry() //  [R1]
         { info_tbl: [(ccIvF,
                       label: lvl76_rcHqW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIvF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIvG; else goto ccIvH;
       ccIvG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIvH: // global
           (_ccIvC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIvC::I64 == 0) goto ccIvE; else goto ccIvD;
       ccIvE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIvD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIvC::I64;
           R2 = lvl75_rcHqV_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.99871236 UTC

[section ""cstring" . lvl77_rcHqX_bytes" {
     lvl77_rcHqX_bytes:
         I8[] [109,97,120,95,108,105,118,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:35.999357881 UTC

[section ""data" . lvl78_rcHqY_closure" {
     lvl78_rcHqY_closure:
         const lvl78_rcHqY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl78_rcHqY_entry() //  [R1]
         { info_tbl: [(ccIvO,
                       label: lvl78_rcHqY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIvO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIvP; else goto ccIvQ;
       ccIvP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIvQ: // global
           (_ccIvL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIvL::I64 == 0) goto ccIvN; else goto ccIvM;
       ccIvN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIvM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIvL::I64;
           R2 = lvl77_rcHqX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.000189626 UTC

[section ""cstring" . lvl79_rcHqZ_bytes" {
     lvl79_rcHqZ_bytes:
         I8[] [109,97,120,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.00085423 UTC

[section ""data" . lvl80_rcHr0_closure" {
     lvl80_rcHr0_closure:
         const lvl80_rcHr0_info;
         const 0;
         const 0;
         const 0;
 },
 lvl80_rcHr0_entry() //  [R1]
         { info_tbl: [(ccIvX,
                       label: lvl80_rcHr0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIvX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIvY; else goto ccIvZ;
       ccIvY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIvZ: // global
           (_ccIvU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIvU::I64 == 0) goto ccIvW; else goto ccIvV;
       ccIvW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIvV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIvU::I64;
           R2 = lvl79_rcHqZ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.001720729 UTC

[section ""cstring" . lvl81_rcHr1_bytes" {
     lvl81_rcHr1_bytes:
         I8[] [109,97,120,95,99,111,109,112,97,99,116,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.00240273 UTC

[section ""data" . lvl82_rcHr2_closure" {
     lvl82_rcHr2_closure:
         const lvl82_rcHr2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl82_rcHr2_entry() //  [R1]
         { info_tbl: [(ccIw6,
                       label: lvl82_rcHr2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIw6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIw7; else goto ccIw8;
       ccIw7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIw8: // global
           (_ccIw3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIw3::I64 == 0) goto ccIw5; else goto ccIw4;
       ccIw5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIw4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIw3::I64;
           R2 = lvl81_rcHr1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.003277554 UTC

[section ""cstring" . lvl83_rcHr3_bytes" {
     lvl83_rcHr3_bytes:
         I8[] [109,97,120,95,115,108,111,112,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.003976213 UTC

[section ""data" . lvl84_rcHr4_closure" {
     lvl84_rcHr4_closure:
         const lvl84_rcHr4_info;
         const 0;
         const 0;
         const 0;
 },
 lvl84_rcHr4_entry() //  [R1]
         { info_tbl: [(ccIwf,
                       label: lvl84_rcHr4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIwf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIwg; else goto ccIwh;
       ccIwg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIwh: // global
           (_ccIwc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIwc::I64 == 0) goto ccIwe; else goto ccIwd;
       ccIwe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIwd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIwc::I64;
           R2 = lvl83_rcHr3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.004798195 UTC

[section ""cstring" . lvl85_rcHr5_bytes" {
     lvl85_rcHr5_bytes:
         I8[] [109,97,120,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.005503015 UTC

[section ""data" . lvl86_rcHr6_closure" {
     lvl86_rcHr6_closure:
         const lvl86_rcHr6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl86_rcHr6_entry() //  [R1]
         { info_tbl: [(ccIwo,
                       label: lvl86_rcHr6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIwo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIwp; else goto ccIwq;
       ccIwp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIwq: // global
           (_ccIwl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIwl::I64 == 0) goto ccIwn; else goto ccIwm;
       ccIwn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIwm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIwl::I64;
           R2 = lvl85_rcHr5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.006374933 UTC

[section ""cstring" . lvl87_rcHr7_bytes" {
     lvl87_rcHr7_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,108,105,118,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.007108328 UTC

[section ""data" . lvl88_rcHr8_closure" {
     lvl88_rcHr8_closure:
         const lvl88_rcHr8_info;
         const 0;
         const 0;
         const 0;
 },
 lvl88_rcHr8_entry() //  [R1]
         { info_tbl: [(ccIwx,
                       label: lvl88_rcHr8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIwx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIwy; else goto ccIwz;
       ccIwy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIwz: // global
           (_ccIwu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIwu::I64 == 0) goto ccIww; else goto ccIwv;
       ccIww: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIwv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIwu::I64;
           R2 = lvl87_rcHr7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.007949559 UTC

[section ""cstring" . lvl89_rcHr9_bytes" {
     lvl89_rcHr9_bytes:
         I8[] [99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.008656928 UTC

[section ""data" . lvl90_rcHra_closure" {
     lvl90_rcHra_closure:
         const lvl90_rcHra_info;
         const 0;
         const 0;
         const 0;
 },
 lvl90_rcHra_entry() //  [R1]
         { info_tbl: [(ccIwG,
                       label: lvl90_rcHra_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIwG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIwH; else goto ccIwI;
       ccIwH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIwI: // global
           (_ccIwD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIwD::I64 == 0) goto ccIwF; else goto ccIwE;
       ccIwF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIwE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIwD::I64;
           R2 = lvl89_rcHr9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.009563198 UTC

[section ""cstring" . lvl91_rcHrb_bytes" {
     lvl91_rcHrb_bytes:
         I8[] [112,97,114,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.010252921 UTC

[section ""data" . lvl92_rcHrc_closure" {
     lvl92_rcHrc_closure:
         const lvl92_rcHrc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl92_rcHrc_entry() //  [R1]
         { info_tbl: [(ccIwP,
                       label: lvl92_rcHrc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIwP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIwQ; else goto ccIwR;
       ccIwQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIwR: // global
           (_ccIwM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIwM::I64 == 0) goto ccIwO; else goto ccIwN;
       ccIwO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIwN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIwM::I64;
           R2 = lvl91_rcHrb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.011124166 UTC

[section ""cstring" . lvl93_rcHrd_bytes" {
     lvl93_rcHrd_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.011859511 UTC

[section ""data" . lvl94_rcHre_closure" {
     lvl94_rcHre_closure:
         const lvl94_rcHre_info;
         const 0;
         const 0;
         const 0;
 },
 lvl94_rcHre_entry() //  [R1]
         { info_tbl: [(ccIwY,
                       label: lvl94_rcHre_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIwY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIwZ; else goto ccIx0;
       ccIwZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIx0: // global
           (_ccIwV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIwV::I64 == 0) goto ccIwX; else goto ccIwW;
       ccIwX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIwW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIwV::I64;
           R2 = lvl93_rcHrd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.012729413 UTC

[section ""cstring" . lvl95_rcHrf_bytes" {
     lvl95_rcHrf_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.013515131 UTC

[section ""data" . lvl96_rcHrg_closure" {
     lvl96_rcHrg_closure:
         const lvl96_rcHrg_info;
         const 0;
         const 0;
         const 0;
 },
 lvl96_rcHrg_entry() //  [R1]
         { info_tbl: [(ccIx7,
                       label: lvl96_rcHrg_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIx7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIx8; else goto ccIx9;
       ccIx8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIx9: // global
           (_ccIx4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIx4::I64 == 0) goto ccIx6; else goto ccIx5;
       ccIx6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIx5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIx4::I64;
           R2 = lvl95_rcHrf_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.014384305 UTC

[section ""cstring" . lvl97_rcHrh_bytes" {
     lvl97_rcHrh_bytes:
         I8[] [109,117,116,97,116,111,114,95,99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.015078846 UTC

[section ""data" . lvl98_rcHri_closure" {
     lvl98_rcHri_closure:
         const lvl98_rcHri_info;
         const 0;
         const 0;
         const 0;
 },
 lvl98_rcHri_entry() //  [R1]
         { info_tbl: [(ccIxg,
                       label: lvl98_rcHri_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIxg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIxh; else goto ccIxi;
       ccIxh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIxi: // global
           (_ccIxd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIxd::I64 == 0) goto ccIxf; else goto ccIxe;
       ccIxf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIxe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIxd::I64;
           R2 = lvl97_rcHrh_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.015943361 UTC

[section ""cstring" . lvl99_rcHrj_bytes" {
     lvl99_rcHrj_bytes:
         I8[] [109,117,116,97,116,111,114,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.016669418 UTC

[section ""data" . lvl100_rcHrk_closure" {
     lvl100_rcHrk_closure:
         const lvl100_rcHrk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl100_rcHrk_entry() //  [R1]
         { info_tbl: [(ccIxp,
                       label: lvl100_rcHrk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIxp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIxq; else goto ccIxr;
       ccIxq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIxr: // global
           (_ccIxm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIxm::I64 == 0) goto ccIxo; else goto ccIxn;
       ccIxo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIxn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIxm::I64;
           R2 = lvl99_rcHrj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.017871374 UTC

[section ""cstring" . lvl101_rcHrl_bytes" {
     lvl101_rcHrl_bytes:
         I8[] [103,99,95,99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.018608119 UTC

[section ""data" . lvl102_rcHrm_closure" {
     lvl102_rcHrm_closure:
         const lvl102_rcHrm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl102_rcHrm_entry() //  [R1]
         { info_tbl: [(ccIxy,
                       label: lvl102_rcHrm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIxy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIxz; else goto ccIxA;
       ccIxz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIxA: // global
           (_ccIxv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIxv::I64 == 0) goto ccIxx; else goto ccIxw;
       ccIxx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIxw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIxv::I64;
           R2 = lvl101_rcHrl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.019478052 UTC

[section ""cstring" . lvl103_rcHrn_bytes" {
     lvl103_rcHrn_bytes:
         I8[] [103,99,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.02021218 UTC

[section ""data" . lvl104_rcHro_closure" {
     lvl104_rcHro_closure:
         const lvl104_rcHro_info;
         const 0;
         const 0;
         const 0;
 },
 lvl104_rcHro_entry() //  [R1]
         { info_tbl: [(ccIxH,
                       label: lvl104_rcHro_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIxH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIxI; else goto ccIxJ;
       ccIxI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIxJ: // global
           (_ccIxE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIxE::I64 == 0) goto ccIxG; else goto ccIxF;
       ccIxG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIxF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIxE::I64;
           R2 = lvl103_rcHrn_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.021129559 UTC

[section ""cstring" . lvl105_rcHrp_bytes" {
     lvl105_rcHrp_bytes:
         I8[] [99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.021907855 UTC

[section ""data" . lvl106_rcHrq_closure" {
     lvl106_rcHrq_closure:
         const lvl106_rcHrq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl106_rcHrq_entry() //  [R1]
         { info_tbl: [(ccIxQ,
                       label: lvl106_rcHrq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIxQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIxR; else goto ccIxS;
       ccIxR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIxS: // global
           (_ccIxN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIxN::I64 == 0) goto ccIxP; else goto ccIxO;
       ccIxP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIxO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIxN::I64;
           R2 = lvl105_rcHrp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.022816025 UTC

[section ""cstring" . lvl107_rcHrr_bytes" {
     lvl107_rcHrr_bytes:
         I8[] [101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.023535759 UTC

[section ""data" . lvl108_rcHrs_closure" {
     lvl108_rcHrs_closure:
         const lvl108_rcHrs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl108_rcHrs_entry() //  [R1]
         { info_tbl: [(ccIxZ,
                       label: lvl108_rcHrs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIxZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIy0; else goto ccIy1;
       ccIy0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIy1: // global
           (_ccIxW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIxW::I64 == 0) goto ccIxY; else goto ccIxX;
       ccIxY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIxX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIxW::I64;
           R2 = lvl107_rcHrr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.024483254 UTC

[section ""cstring" . lvl109_rcHrt_bytes" {
     lvl109_rcHrt_bytes:
         I8[] [103,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.025216184 UTC

[section ""data" . lvl110_rcHru_closure" {
     lvl110_rcHru_closure:
         const lvl110_rcHru_info;
         const 0;
         const 0;
         const 0;
 },
 lvl110_rcHru_entry() //  [R1]
         { info_tbl: [(ccIy8,
                       label: lvl110_rcHru_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIy8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIy9; else goto ccIya;
       ccIy9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIya: // global
           (_ccIy5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIy5::I64 == 0) goto ccIy7; else goto ccIy6;
       ccIy7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIy6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIy5::I64;
           R2 = lvl109_rcHrt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.026298106 UTC

[section ""data" . lvl111_rcHrv_closure" {
     lvl111_rcHrv_closure:
         const lvl111_rcHrv_info;
         const 0;
 },
 lvl111_rcHrv_entry() //  [R3]
         { info_tbl: [(ccIyf,
                       label: lvl111_rcHrv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIyf: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Stats.$fReadGCDetails2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.039349875 UTC

[section ""data" . GHC.Stats.$w$creadPrec1_closure" {
     GHC.Stats.$w$creadPrec1_closure:
         const GHC.Stats.$w$creadPrec1_info;
         const 0;
 },
 sat_scHB9_entry() //  [R1, R2]
         { info_tbl: [(ccIBP,
                       label: sat_scHB9_info
                       rep:HeapRep 21 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIBP: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccIBT; else goto ccIBS;
       ccIBT: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIBS: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           _scHB0::P64 = P64[R1 + 143];
           _scHB2::P64 = P64[R1 + 151];
           _scHB4::P64 = P64[R1 + 159];
           _scHB6::P64 = P64[R1 + 167];
           I64[Hp - 160] = GHC.Stats.RTSStats_con_info;
           P64[Hp - 152] = _scHAu::P64;
           P64[Hp - 144] = _scHAw::P64;
           P64[Hp - 136] = _scHAy::P64;
           P64[Hp - 128] = _scHAA::P64;
           P64[Hp - 120] = _scHAC::P64;
           P64[Hp - 112] = _scHAE::P64;
           P64[Hp - 104] = _scHAG::P64;
           P64[Hp - 96] = _scHAI::P64;
           P64[Hp - 88] = _scHAK::P64;
           P64[Hp - 80] = _scHAM::P64;
           P64[Hp - 72] = _scHAO::P64;
           P64[Hp - 64] = _scHAQ::P64;
           P64[Hp - 56] = _scHAS::P64;
           P64[Hp - 48] = _scHAU::P64;
           P64[Hp - 40] = _scHAW::P64;
           P64[Hp - 32] = _scHAY::P64;
           P64[Hp - 24] = _scHB0::P64;
           P64[Hp - 16] = _scHB2::P64;
           P64[Hp - 8] = _scHB4::P64;
           P64[Hp] = _scHB6::P64;
           R2 = Hp - 159;
           R1 = _scHAq::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBc_entry() //  [R1, R2]
         { info_tbl: [(ccIBX,
                       label: sat_scHBc_info
                       rep:HeapRep 20 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIBX: // global
           _scHB6::P64 = R2;
           _scHBc::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIBY; else goto ccIBZ;
       ccIBZ: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccIC1; else goto ccIC0;
       ccIC1: // global
           HpAlloc = 176;
           goto ccIBY;
       ccIBY: // global
           R2 = _scHB6::P64;
           R1 = _scHBc::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIC0: // global
           _scHAq::P64 = P64[_scHBc::P64 + 7];
           _scHAu::P64 = P64[_scHBc::P64 + 15];
           _scHAw::P64 = P64[_scHBc::P64 + 23];
           _scHAy::P64 = P64[_scHBc::P64 + 31];
           _scHAA::P64 = P64[_scHBc::P64 + 39];
           _scHAC::P64 = P64[_scHBc::P64 + 47];
           _scHAE::P64 = P64[_scHBc::P64 + 55];
           _scHAG::P64 = P64[_scHBc::P64 + 63];
           _scHAI::P64 = P64[_scHBc::P64 + 71];
           _scHAK::P64 = P64[_scHBc::P64 + 79];
           _scHAM::P64 = P64[_scHBc::P64 + 87];
           _scHAO::P64 = P64[_scHBc::P64 + 95];
           _scHAQ::P64 = P64[_scHBc::P64 + 103];
           _scHAS::P64 = P64[_scHBc::P64 + 111];
           _scHAU::P64 = P64[_scHBc::P64 + 119];
           _scHAW::P64 = P64[_scHBc::P64 + 127];
           _scHAY::P64 = P64[_scHBc::P64 + 135];
           _scHB0::P64 = P64[_scHBc::P64 + 143];
           _scHB2::P64 = P64[_scHBc::P64 + 151];
           _scHB4::P64 = P64[_scHBc::P64 + 159];
           I64[Hp - 168] = sat_scHB9_info;
           P64[Hp - 160] = _scHAq::P64;
           P64[Hp - 152] = _scHAu::P64;
           P64[Hp - 144] = _scHAw::P64;
           P64[Hp - 136] = _scHAy::P64;
           P64[Hp - 128] = _scHAA::P64;
           P64[Hp - 120] = _scHAC::P64;
           P64[Hp - 112] = _scHAE::P64;
           P64[Hp - 104] = _scHAG::P64;
           P64[Hp - 96] = _scHAI::P64;
           P64[Hp - 88] = _scHAK::P64;
           P64[Hp - 80] = _scHAM::P64;
           P64[Hp - 72] = _scHAO::P64;
           P64[Hp - 64] = _scHAQ::P64;
           P64[Hp - 56] = _scHAS::P64;
           P64[Hp - 48] = _scHAU::P64;
           P64[Hp - 40] = _scHAW::P64;
           P64[Hp - 32] = _scHAY::P64;
           P64[Hp - 24] = _scHB0::P64;
           P64[Hp - 16] = _scHB2::P64;
           P64[Hp - 8] = _scHB4::P64;
           P64[Hp] = _scHB6::P64;
           I64[Sp - 8] = block_ccIBU_info;
           R3 = Hp - 167;
           R2 = lvl72_rcHqO_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIBU() //  [R1]
         { info_tbl: [(ccIBU,
                       label: block_ccIBU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIBU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIC4; else goto ccIC3;
       ccIC4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIC3: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBd_entry() //  [R1, R2]
         { info_tbl: [(ccIC5,
                       label: sat_scHBd_info
                       rep:HeapRep 20 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIC5: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccIC9; else goto ccIC8;
       ccIC9: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIC8: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           _scHB0::P64 = P64[R1 + 143];
           _scHB2::P64 = P64[R1 + 151];
           _scHB4::P64 = P64[R1 + 159];
           I64[Hp - 160] = sat_scHBc_info;
           P64[Hp - 152] = _scHAq::P64;
           P64[Hp - 144] = _scHAu::P64;
           P64[Hp - 136] = _scHAw::P64;
           P64[Hp - 128] = _scHAy::P64;
           P64[Hp - 120] = _scHAA::P64;
           P64[Hp - 112] = _scHAC::P64;
           P64[Hp - 104] = _scHAE::P64;
           P64[Hp - 96] = _scHAG::P64;
           P64[Hp - 88] = _scHAI::P64;
           P64[Hp - 80] = _scHAK::P64;
           P64[Hp - 72] = _scHAM::P64;
           P64[Hp - 64] = _scHAO::P64;
           P64[Hp - 56] = _scHAQ::P64;
           P64[Hp - 48] = _scHAS::P64;
           P64[Hp - 40] = _scHAU::P64;
           P64[Hp - 32] = _scHAW::P64;
           P64[Hp - 24] = _scHAY::P64;
           P64[Hp - 16] = _scHB0::P64;
           P64[Hp - 8] = _scHB2::P64;
           P64[Hp] = _scHB4::P64;
           R5 = Hp - 159;
           R4 = n_rcHqf_closure+1;
           R3 = lvl111_rcHrv_closure+2;
           R2 = lvl110_rcHru_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBg_entry() //  [R1, R2]
         { info_tbl: [(ccICd,
                       label: sat_scHBg_info
                       rep:HeapRep 19 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccICd: // global
           _scHB4::P64 = R2;
           _scHBg::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccICe; else goto ccICf;
       ccICf: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccICh; else goto ccICg;
       ccICh: // global
           HpAlloc = 168;
           goto ccICe;
       ccICe: // global
           R2 = _scHB4::P64;
           R1 = _scHBg::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccICg: // global
           _scHAq::P64 = P64[_scHBg::P64 + 7];
           _scHAu::P64 = P64[_scHBg::P64 + 15];
           _scHAw::P64 = P64[_scHBg::P64 + 23];
           _scHAy::P64 = P64[_scHBg::P64 + 31];
           _scHAA::P64 = P64[_scHBg::P64 + 39];
           _scHAC::P64 = P64[_scHBg::P64 + 47];
           _scHAE::P64 = P64[_scHBg::P64 + 55];
           _scHAG::P64 = P64[_scHBg::P64 + 63];
           _scHAI::P64 = P64[_scHBg::P64 + 71];
           _scHAK::P64 = P64[_scHBg::P64 + 79];
           _scHAM::P64 = P64[_scHBg::P64 + 87];
           _scHAO::P64 = P64[_scHBg::P64 + 95];
           _scHAQ::P64 = P64[_scHBg::P64 + 103];
           _scHAS::P64 = P64[_scHBg::P64 + 111];
           _scHAU::P64 = P64[_scHBg::P64 + 119];
           _scHAW::P64 = P64[_scHBg::P64 + 127];
           _scHAY::P64 = P64[_scHBg::P64 + 135];
           _scHB0::P64 = P64[_scHBg::P64 + 143];
           _scHB2::P64 = P64[_scHBg::P64 + 151];
           I64[Hp - 160] = sat_scHBd_info;
           P64[Hp - 152] = _scHAq::P64;
           P64[Hp - 144] = _scHAu::P64;
           P64[Hp - 136] = _scHAw::P64;
           P64[Hp - 128] = _scHAy::P64;
           P64[Hp - 120] = _scHAA::P64;
           P64[Hp - 112] = _scHAC::P64;
           P64[Hp - 104] = _scHAE::P64;
           P64[Hp - 96] = _scHAG::P64;
           P64[Hp - 88] = _scHAI::P64;
           P64[Hp - 80] = _scHAK::P64;
           P64[Hp - 72] = _scHAM::P64;
           P64[Hp - 64] = _scHAO::P64;
           P64[Hp - 56] = _scHAQ::P64;
           P64[Hp - 48] = _scHAS::P64;
           P64[Hp - 40] = _scHAU::P64;
           P64[Hp - 32] = _scHAW::P64;
           P64[Hp - 24] = _scHAY::P64;
           P64[Hp - 16] = _scHB0::P64;
           P64[Hp - 8] = _scHB2::P64;
           P64[Hp] = _scHB4::P64;
           I64[Sp - 8] = block_ccICa_info;
           R3 = Hp - 159;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccICa() //  [R1]
         { info_tbl: [(ccICa,
                       label: block_ccICa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccICa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccICk; else goto ccICj;
       ccICk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccICj: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBh_entry() //  [R1, R2]
         { info_tbl: [(ccICl,
                       label: sat_scHBh_info
                       rep:HeapRep 19 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccICl: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccICp; else goto ccICo;
       ccICp: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccICo: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           _scHB0::P64 = P64[R1 + 143];
           _scHB2::P64 = P64[R1 + 151];
           I64[Hp - 152] = sat_scHBg_info;
           P64[Hp - 144] = _scHAq::P64;
           P64[Hp - 136] = _scHAu::P64;
           P64[Hp - 128] = _scHAw::P64;
           P64[Hp - 120] = _scHAy::P64;
           P64[Hp - 112] = _scHAA::P64;
           P64[Hp - 104] = _scHAC::P64;
           P64[Hp - 96] = _scHAE::P64;
           P64[Hp - 88] = _scHAG::P64;
           P64[Hp - 80] = _scHAI::P64;
           P64[Hp - 72] = _scHAK::P64;
           P64[Hp - 64] = _scHAM::P64;
           P64[Hp - 56] = _scHAO::P64;
           P64[Hp - 48] = _scHAQ::P64;
           P64[Hp - 40] = _scHAS::P64;
           P64[Hp - 32] = _scHAU::P64;
           P64[Hp - 24] = _scHAW::P64;
           P64[Hp - 16] = _scHAY::P64;
           P64[Hp - 8] = _scHB0::P64;
           P64[Hp] = _scHB2::P64;
           R5 = Hp - 151;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl108_rcHrs_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBk_entry() //  [R1, R2]
         { info_tbl: [(ccICt,
                       label: sat_scHBk_info
                       rep:HeapRep 18 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccICt: // global
           _scHB2::P64 = R2;
           _scHBk::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccICu; else goto ccICv;
       ccICv: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccICx; else goto ccICw;
       ccICx: // global
           HpAlloc = 160;
           goto ccICu;
       ccICu: // global
           R2 = _scHB2::P64;
           R1 = _scHBk::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccICw: // global
           _scHAq::P64 = P64[_scHBk::P64 + 7];
           _scHAu::P64 = P64[_scHBk::P64 + 15];
           _scHAw::P64 = P64[_scHBk::P64 + 23];
           _scHAy::P64 = P64[_scHBk::P64 + 31];
           _scHAA::P64 = P64[_scHBk::P64 + 39];
           _scHAC::P64 = P64[_scHBk::P64 + 47];
           _scHAE::P64 = P64[_scHBk::P64 + 55];
           _scHAG::P64 = P64[_scHBk::P64 + 63];
           _scHAI::P64 = P64[_scHBk::P64 + 71];
           _scHAK::P64 = P64[_scHBk::P64 + 79];
           _scHAM::P64 = P64[_scHBk::P64 + 87];
           _scHAO::P64 = P64[_scHBk::P64 + 95];
           _scHAQ::P64 = P64[_scHBk::P64 + 103];
           _scHAS::P64 = P64[_scHBk::P64 + 111];
           _scHAU::P64 = P64[_scHBk::P64 + 119];
           _scHAW::P64 = P64[_scHBk::P64 + 127];
           _scHAY::P64 = P64[_scHBk::P64 + 135];
           _scHB0::P64 = P64[_scHBk::P64 + 143];
           I64[Hp - 152] = sat_scHBh_info;
           P64[Hp - 144] = _scHAq::P64;
           P64[Hp - 136] = _scHAu::P64;
           P64[Hp - 128] = _scHAw::P64;
           P64[Hp - 120] = _scHAy::P64;
           P64[Hp - 112] = _scHAA::P64;
           P64[Hp - 104] = _scHAC::P64;
           P64[Hp - 96] = _scHAE::P64;
           P64[Hp - 88] = _scHAG::P64;
           P64[Hp - 80] = _scHAI::P64;
           P64[Hp - 72] = _scHAK::P64;
           P64[Hp - 64] = _scHAM::P64;
           P64[Hp - 56] = _scHAO::P64;
           P64[Hp - 48] = _scHAQ::P64;
           P64[Hp - 40] = _scHAS::P64;
           P64[Hp - 32] = _scHAU::P64;
           P64[Hp - 24] = _scHAW::P64;
           P64[Hp - 16] = _scHAY::P64;
           P64[Hp - 8] = _scHB0::P64;
           P64[Hp] = _scHB2::P64;
           I64[Sp - 8] = block_ccICq_info;
           R3 = Hp - 151;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccICq() //  [R1]
         { info_tbl: [(ccICq,
                       label: block_ccICq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccICq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccICA; else goto ccICz;
       ccICA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccICz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHt_srtd" {
     ucIHt_srtd:
         const ScI2G_srt+128;
         const 33;
         const 8053063727;
 },
 sat_scHBl_entry() //  [R1, R2]
         { info_tbl: [(ccICB,
                       label: sat_scHBl_info
                       rep:HeapRep 18 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccICB: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccICF; else goto ccICE;
       ccICF: // global
           HpAlloc = 152;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccICE: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           _scHB0::P64 = P64[R1 + 143];
           I64[Hp - 144] = sat_scHBk_info;
           P64[Hp - 136] = _scHAq::P64;
           P64[Hp - 128] = _scHAu::P64;
           P64[Hp - 120] = _scHAw::P64;
           P64[Hp - 112] = _scHAy::P64;
           P64[Hp - 104] = _scHAA::P64;
           P64[Hp - 96] = _scHAC::P64;
           P64[Hp - 88] = _scHAE::P64;
           P64[Hp - 80] = _scHAG::P64;
           P64[Hp - 72] = _scHAI::P64;
           P64[Hp - 64] = _scHAK::P64;
           P64[Hp - 56] = _scHAM::P64;
           P64[Hp - 48] = _scHAO::P64;
           P64[Hp - 40] = _scHAQ::P64;
           P64[Hp - 32] = _scHAS::P64;
           P64[Hp - 24] = _scHAU::P64;
           P64[Hp - 16] = _scHAW::P64;
           P64[Hp - 8] = _scHAY::P64;
           P64[Hp] = _scHB0::P64;
           R5 = Hp - 143;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl106_rcHrq_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHu_srtd" {
     ucIHu_srtd:
         const ScI2G_srt+128;
         const 33;
         const 8053063727;
 },
 sat_scHBo_entry() //  [R1, R2]
         { info_tbl: [(ccICJ,
                       label: sat_scHBo_info
                       rep:HeapRep 17 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccICJ: // global
           _scHB0::P64 = R2;
           _scHBo::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccICK; else goto ccICL;
       ccICL: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccICN; else goto ccICM;
       ccICN: // global
           HpAlloc = 152;
           goto ccICK;
       ccICK: // global
           R2 = _scHB0::P64;
           R1 = _scHBo::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccICM: // global
           _scHAq::P64 = P64[_scHBo::P64 + 7];
           _scHAu::P64 = P64[_scHBo::P64 + 15];
           _scHAw::P64 = P64[_scHBo::P64 + 23];
           _scHAy::P64 = P64[_scHBo::P64 + 31];
           _scHAA::P64 = P64[_scHBo::P64 + 39];
           _scHAC::P64 = P64[_scHBo::P64 + 47];
           _scHAE::P64 = P64[_scHBo::P64 + 55];
           _scHAG::P64 = P64[_scHBo::P64 + 63];
           _scHAI::P64 = P64[_scHBo::P64 + 71];
           _scHAK::P64 = P64[_scHBo::P64 + 79];
           _scHAM::P64 = P64[_scHBo::P64 + 87];
           _scHAO::P64 = P64[_scHBo::P64 + 95];
           _scHAQ::P64 = P64[_scHBo::P64 + 103];
           _scHAS::P64 = P64[_scHBo::P64 + 111];
           _scHAU::P64 = P64[_scHBo::P64 + 119];
           _scHAW::P64 = P64[_scHBo::P64 + 127];
           _scHAY::P64 = P64[_scHBo::P64 + 135];
           I64[Hp - 144] = sat_scHBl_info;
           P64[Hp - 136] = _scHAq::P64;
           P64[Hp - 128] = _scHAu::P64;
           P64[Hp - 120] = _scHAw::P64;
           P64[Hp - 112] = _scHAy::P64;
           P64[Hp - 104] = _scHAA::P64;
           P64[Hp - 96] = _scHAC::P64;
           P64[Hp - 88] = _scHAE::P64;
           P64[Hp - 80] = _scHAG::P64;
           P64[Hp - 72] = _scHAI::P64;
           P64[Hp - 64] = _scHAK::P64;
           P64[Hp - 56] = _scHAM::P64;
           P64[Hp - 48] = _scHAO::P64;
           P64[Hp - 40] = _scHAQ::P64;
           P64[Hp - 32] = _scHAS::P64;
           P64[Hp - 24] = _scHAU::P64;
           P64[Hp - 16] = _scHAW::P64;
           P64[Hp - 8] = _scHAY::P64;
           P64[Hp] = _scHB0::P64;
           I64[Sp - 8] = block_ccICG_info;
           R3 = Hp - 143;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccICG() //  [R1]
         { info_tbl: [(ccICG,
                       label: block_ccICG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccICG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccICQ; else goto ccICP;
       ccICQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccICP: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHv_srtd" {
     ucIHv_srtd:
         const ScI2G_srt+128;
         const 34;
         const 16642998319;
 },
 sat_scHBp_entry() //  [R1, R2]
         { info_tbl: [(ccICR,
                       label: sat_scHBp_info
                       rep:HeapRep 17 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccICR: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccICV; else goto ccICU;
       ccICV: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccICU: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           I64[Hp - 136] = sat_scHBo_info;
           P64[Hp - 128] = _scHAq::P64;
           P64[Hp - 120] = _scHAu::P64;
           P64[Hp - 112] = _scHAw::P64;
           P64[Hp - 104] = _scHAy::P64;
           P64[Hp - 96] = _scHAA::P64;
           P64[Hp - 88] = _scHAC::P64;
           P64[Hp - 80] = _scHAE::P64;
           P64[Hp - 72] = _scHAG::P64;
           P64[Hp - 64] = _scHAI::P64;
           P64[Hp - 56] = _scHAK::P64;
           P64[Hp - 48] = _scHAM::P64;
           P64[Hp - 40] = _scHAO::P64;
           P64[Hp - 32] = _scHAQ::P64;
           P64[Hp - 24] = _scHAS::P64;
           P64[Hp - 16] = _scHAU::P64;
           P64[Hp - 8] = _scHAW::P64;
           P64[Hp] = _scHAY::P64;
           R5 = Hp - 135;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl104_rcHro_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHw_srtd" {
     ucIHw_srtd:
         const ScI2G_srt+128;
         const 34;
         const 16642998319;
 },
 sat_scHBs_entry() //  [R1, R2]
         { info_tbl: [(ccICZ,
                       label: sat_scHBs_info
                       rep:HeapRep 16 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccICZ: // global
           _scHAY::P64 = R2;
           _scHBs::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccID0; else goto ccID1;
       ccID1: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccID3; else goto ccID2;
       ccID3: // global
           HpAlloc = 144;
           goto ccID0;
       ccID0: // global
           R2 = _scHAY::P64;
           R1 = _scHBs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccID2: // global
           _scHAq::P64 = P64[_scHBs::P64 + 7];
           _scHAu::P64 = P64[_scHBs::P64 + 15];
           _scHAw::P64 = P64[_scHBs::P64 + 23];
           _scHAy::P64 = P64[_scHBs::P64 + 31];
           _scHAA::P64 = P64[_scHBs::P64 + 39];
           _scHAC::P64 = P64[_scHBs::P64 + 47];
           _scHAE::P64 = P64[_scHBs::P64 + 55];
           _scHAG::P64 = P64[_scHBs::P64 + 63];
           _scHAI::P64 = P64[_scHBs::P64 + 71];
           _scHAK::P64 = P64[_scHBs::P64 + 79];
           _scHAM::P64 = P64[_scHBs::P64 + 87];
           _scHAO::P64 = P64[_scHBs::P64 + 95];
           _scHAQ::P64 = P64[_scHBs::P64 + 103];
           _scHAS::P64 = P64[_scHBs::P64 + 111];
           _scHAU::P64 = P64[_scHBs::P64 + 119];
           _scHAW::P64 = P64[_scHBs::P64 + 127];
           I64[Hp - 136] = sat_scHBp_info;
           P64[Hp - 128] = _scHAq::P64;
           P64[Hp - 120] = _scHAu::P64;
           P64[Hp - 112] = _scHAw::P64;
           P64[Hp - 104] = _scHAy::P64;
           P64[Hp - 96] = _scHAA::P64;
           P64[Hp - 88] = _scHAC::P64;
           P64[Hp - 80] = _scHAE::P64;
           P64[Hp - 72] = _scHAG::P64;
           P64[Hp - 64] = _scHAI::P64;
           P64[Hp - 56] = _scHAK::P64;
           P64[Hp - 48] = _scHAM::P64;
           P64[Hp - 40] = _scHAO::P64;
           P64[Hp - 32] = _scHAQ::P64;
           P64[Hp - 24] = _scHAS::P64;
           P64[Hp - 16] = _scHAU::P64;
           P64[Hp - 8] = _scHAW::P64;
           P64[Hp] = _scHAY::P64;
           I64[Sp - 8] = block_ccICW_info;
           R3 = Hp - 135;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccICW() //  [R1]
         { info_tbl: [(ccICW,
                       label: block_ccICW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccICW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccID6; else goto ccID5;
       ccID6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccID5: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHx_srtd" {
     ucIHx_srtd:
         const ScI2G_srt+128;
         const 35;
         const 33822867503;
 },
 sat_scHBt_entry() //  [R1, R2]
         { info_tbl: [(ccID7,
                       label: sat_scHBt_info
                       rep:HeapRep 16 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccID7: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccIDb; else goto ccIDa;
       ccIDb: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIDa: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           I64[Hp - 128] = sat_scHBs_info;
           P64[Hp - 120] = _scHAq::P64;
           P64[Hp - 112] = _scHAu::P64;
           P64[Hp - 104] = _scHAw::P64;
           P64[Hp - 96] = _scHAy::P64;
           P64[Hp - 88] = _scHAA::P64;
           P64[Hp - 80] = _scHAC::P64;
           P64[Hp - 72] = _scHAE::P64;
           P64[Hp - 64] = _scHAG::P64;
           P64[Hp - 56] = _scHAI::P64;
           P64[Hp - 48] = _scHAK::P64;
           P64[Hp - 40] = _scHAM::P64;
           P64[Hp - 32] = _scHAO::P64;
           P64[Hp - 24] = _scHAQ::P64;
           P64[Hp - 16] = _scHAS::P64;
           P64[Hp - 8] = _scHAU::P64;
           P64[Hp] = _scHAW::P64;
           R5 = Hp - 127;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl102_rcHrm_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHy_srtd" {
     ucIHy_srtd:
         const ScI2G_srt+128;
         const 35;
         const 33822867503;
 },
 sat_scHBw_entry() //  [R1, R2]
         { info_tbl: [(ccIDf,
                       label: sat_scHBw_info
                       rep:HeapRep 15 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIDf: // global
           _scHAW::P64 = R2;
           _scHBw::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIDg; else goto ccIDh;
       ccIDh: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccIDj; else goto ccIDi;
       ccIDj: // global
           HpAlloc = 136;
           goto ccIDg;
       ccIDg: // global
           R2 = _scHAW::P64;
           R1 = _scHBw::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIDi: // global
           _scHAq::P64 = P64[_scHBw::P64 + 7];
           _scHAu::P64 = P64[_scHBw::P64 + 15];
           _scHAw::P64 = P64[_scHBw::P64 + 23];
           _scHAy::P64 = P64[_scHBw::P64 + 31];
           _scHAA::P64 = P64[_scHBw::P64 + 39];
           _scHAC::P64 = P64[_scHBw::P64 + 47];
           _scHAE::P64 = P64[_scHBw::P64 + 55];
           _scHAG::P64 = P64[_scHBw::P64 + 63];
           _scHAI::P64 = P64[_scHBw::P64 + 71];
           _scHAK::P64 = P64[_scHBw::P64 + 79];
           _scHAM::P64 = P64[_scHBw::P64 + 87];
           _scHAO::P64 = P64[_scHBw::P64 + 95];
           _scHAQ::P64 = P64[_scHBw::P64 + 103];
           _scHAS::P64 = P64[_scHBw::P64 + 111];
           _scHAU::P64 = P64[_scHBw::P64 + 119];
           I64[Hp - 128] = sat_scHBt_info;
           P64[Hp - 120] = _scHAq::P64;
           P64[Hp - 112] = _scHAu::P64;
           P64[Hp - 104] = _scHAw::P64;
           P64[Hp - 96] = _scHAy::P64;
           P64[Hp - 88] = _scHAA::P64;
           P64[Hp - 80] = _scHAC::P64;
           P64[Hp - 72] = _scHAE::P64;
           P64[Hp - 64] = _scHAG::P64;
           P64[Hp - 56] = _scHAI::P64;
           P64[Hp - 48] = _scHAK::P64;
           P64[Hp - 40] = _scHAM::P64;
           P64[Hp - 32] = _scHAO::P64;
           P64[Hp - 24] = _scHAQ::P64;
           P64[Hp - 16] = _scHAS::P64;
           P64[Hp - 8] = _scHAU::P64;
           P64[Hp] = _scHAW::P64;
           I64[Sp - 8] = block_ccIDc_info;
           R3 = Hp - 127;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIDc() //  [R1]
         { info_tbl: [(ccIDc,
                       label: block_ccIDc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIDc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIDm; else goto ccIDl;
       ccIDm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIDl: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHz_srtd" {
     ucIHz_srtd:
         const ScI2G_srt+128;
         const 36;
         const 68182605871;
 },
 sat_scHBx_entry() //  [R1, R2]
         { info_tbl: [(ccIDn,
                       label: sat_scHBx_info
                       rep:HeapRep 15 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIDn: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccIDr; else goto ccIDq;
       ccIDr: // global
           HpAlloc = 128;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIDq: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           I64[Hp - 120] = sat_scHBw_info;
           P64[Hp - 112] = _scHAq::P64;
           P64[Hp - 104] = _scHAu::P64;
           P64[Hp - 96] = _scHAw::P64;
           P64[Hp - 88] = _scHAy::P64;
           P64[Hp - 80] = _scHAA::P64;
           P64[Hp - 72] = _scHAC::P64;
           P64[Hp - 64] = _scHAE::P64;
           P64[Hp - 56] = _scHAG::P64;
           P64[Hp - 48] = _scHAI::P64;
           P64[Hp - 40] = _scHAK::P64;
           P64[Hp - 32] = _scHAM::P64;
           P64[Hp - 24] = _scHAO::P64;
           P64[Hp - 16] = _scHAQ::P64;
           P64[Hp - 8] = _scHAS::P64;
           P64[Hp] = _scHAU::P64;
           R5 = Hp - 119;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl100_rcHrk_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHA_srtd" {
     ucIHA_srtd:
         const ScI2G_srt+128;
         const 36;
         const 68182605871;
 },
 sat_scHBA_entry() //  [R1, R2]
         { info_tbl: [(ccIDv,
                       label: sat_scHBA_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIDv: // global
           _scHAU::P64 = R2;
           _scHBA::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIDw; else goto ccIDx;
       ccIDx: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccIDz; else goto ccIDy;
       ccIDz: // global
           HpAlloc = 128;
           goto ccIDw;
       ccIDw: // global
           R2 = _scHAU::P64;
           R1 = _scHBA::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIDy: // global
           _scHAq::P64 = P64[_scHBA::P64 + 7];
           _scHAu::P64 = P64[_scHBA::P64 + 15];
           _scHAw::P64 = P64[_scHBA::P64 + 23];
           _scHAy::P64 = P64[_scHBA::P64 + 31];
           _scHAA::P64 = P64[_scHBA::P64 + 39];
           _scHAC::P64 = P64[_scHBA::P64 + 47];
           _scHAE::P64 = P64[_scHBA::P64 + 55];
           _scHAG::P64 = P64[_scHBA::P64 + 63];
           _scHAI::P64 = P64[_scHBA::P64 + 71];
           _scHAK::P64 = P64[_scHBA::P64 + 79];
           _scHAM::P64 = P64[_scHBA::P64 + 87];
           _scHAO::P64 = P64[_scHBA::P64 + 95];
           _scHAQ::P64 = P64[_scHBA::P64 + 103];
           _scHAS::P64 = P64[_scHBA::P64 + 111];
           I64[Hp - 120] = sat_scHBx_info;
           P64[Hp - 112] = _scHAq::P64;
           P64[Hp - 104] = _scHAu::P64;
           P64[Hp - 96] = _scHAw::P64;
           P64[Hp - 88] = _scHAy::P64;
           P64[Hp - 80] = _scHAA::P64;
           P64[Hp - 72] = _scHAC::P64;
           P64[Hp - 64] = _scHAE::P64;
           P64[Hp - 56] = _scHAG::P64;
           P64[Hp - 48] = _scHAI::P64;
           P64[Hp - 40] = _scHAK::P64;
           P64[Hp - 32] = _scHAM::P64;
           P64[Hp - 24] = _scHAO::P64;
           P64[Hp - 16] = _scHAQ::P64;
           P64[Hp - 8] = _scHAS::P64;
           P64[Hp] = _scHAU::P64;
           I64[Sp - 8] = block_ccIDs_info;
           R3 = Hp - 119;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIDs() //  [R1]
         { info_tbl: [(ccIDs,
                       label: block_ccIDs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIDs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIDC; else goto ccIDB;
       ccIDC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIDB: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHB_srtd" {
     ucIHB_srtd:
         const ScI2G_srt+128;
         const 37;
         const 136902082607;
 },
 sat_scHBB_entry() //  [R1, R2]
         { info_tbl: [(ccIDD,
                       label: sat_scHBB_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIDD: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccIDH; else goto ccIDG;
       ccIDH: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIDG: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           I64[Hp - 112] = sat_scHBA_info;
           P64[Hp - 104] = _scHAq::P64;
           P64[Hp - 96] = _scHAu::P64;
           P64[Hp - 88] = _scHAw::P64;
           P64[Hp - 80] = _scHAy::P64;
           P64[Hp - 72] = _scHAA::P64;
           P64[Hp - 64] = _scHAC::P64;
           P64[Hp - 56] = _scHAE::P64;
           P64[Hp - 48] = _scHAG::P64;
           P64[Hp - 40] = _scHAI::P64;
           P64[Hp - 32] = _scHAK::P64;
           P64[Hp - 24] = _scHAM::P64;
           P64[Hp - 16] = _scHAO::P64;
           P64[Hp - 8] = _scHAQ::P64;
           P64[Hp] = _scHAS::P64;
           R5 = Hp - 111;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl98_rcHri_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHC_srtd" {
     ucIHC_srtd:
         const ScI2G_srt+128;
         const 37;
         const 136902082607;
 },
 sat_scHBE_entry() //  [R1, R2]
         { info_tbl: [(ccIDL,
                       label: sat_scHBE_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIDL: // global
           _scHAS::P64 = R2;
           _scHBE::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIDM; else goto ccIDN;
       ccIDN: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccIDP; else goto ccIDO;
       ccIDP: // global
           HpAlloc = 120;
           goto ccIDM;
       ccIDM: // global
           R2 = _scHAS::P64;
           R1 = _scHBE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIDO: // global
           _scHAq::P64 = P64[_scHBE::P64 + 7];
           _scHAu::P64 = P64[_scHBE::P64 + 15];
           _scHAw::P64 = P64[_scHBE::P64 + 23];
           _scHAy::P64 = P64[_scHBE::P64 + 31];
           _scHAA::P64 = P64[_scHBE::P64 + 39];
           _scHAC::P64 = P64[_scHBE::P64 + 47];
           _scHAE::P64 = P64[_scHBE::P64 + 55];
           _scHAG::P64 = P64[_scHBE::P64 + 63];
           _scHAI::P64 = P64[_scHBE::P64 + 71];
           _scHAK::P64 = P64[_scHBE::P64 + 79];
           _scHAM::P64 = P64[_scHBE::P64 + 87];
           _scHAO::P64 = P64[_scHBE::P64 + 95];
           _scHAQ::P64 = P64[_scHBE::P64 + 103];
           I64[Hp - 112] = sat_scHBB_info;
           P64[Hp - 104] = _scHAq::P64;
           P64[Hp - 96] = _scHAu::P64;
           P64[Hp - 88] = _scHAw::P64;
           P64[Hp - 80] = _scHAy::P64;
           P64[Hp - 72] = _scHAA::P64;
           P64[Hp - 64] = _scHAC::P64;
           P64[Hp - 56] = _scHAE::P64;
           P64[Hp - 48] = _scHAG::P64;
           P64[Hp - 40] = _scHAI::P64;
           P64[Hp - 32] = _scHAK::P64;
           P64[Hp - 24] = _scHAM::P64;
           P64[Hp - 16] = _scHAO::P64;
           P64[Hp - 8] = _scHAQ::P64;
           P64[Hp] = _scHAS::P64;
           I64[Sp - 8] = block_ccIDI_info;
           R3 = Hp - 111;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIDI() //  [R1]
         { info_tbl: [(ccIDI,
                       label: block_ccIDI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIDI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIDS; else goto ccIDR;
       ccIDS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIDR: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHD_srtd" {
     ucIHD_srtd:
         const ScI2G_srt+104;
         const 41;
         const 2194728288633;
 },
 sat_scHBF_entry() //  [R1, R2]
         { info_tbl: [(ccIDT,
                       label: sat_scHBF_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIDT: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccIDX; else goto ccIDW;
       ccIDX: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIDW: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           I64[Hp - 104] = sat_scHBE_info;
           P64[Hp - 96] = _scHAq::P64;
           P64[Hp - 88] = _scHAu::P64;
           P64[Hp - 80] = _scHAw::P64;
           P64[Hp - 72] = _scHAy::P64;
           P64[Hp - 64] = _scHAA::P64;
           P64[Hp - 56] = _scHAC::P64;
           P64[Hp - 48] = _scHAE::P64;
           P64[Hp - 40] = _scHAG::P64;
           P64[Hp - 32] = _scHAI::P64;
           P64[Hp - 24] = _scHAK::P64;
           P64[Hp - 16] = _scHAM::P64;
           P64[Hp - 8] = _scHAO::P64;
           P64[Hp] = _scHAQ::P64;
           R5 = Hp - 103;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl96_rcHrg_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHE_srtd" {
     ucIHE_srtd:
         const ScI2G_srt+104;
         const 41;
         const 2194728288633;
 },
 sat_scHBI_entry() //  [R1, R2]
         { info_tbl: [(ccIE1,
                       label: sat_scHBI_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIE1: // global
           _scHAQ::P64 = R2;
           _scHBI::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIE2; else goto ccIE3;
       ccIE3: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccIE5; else goto ccIE4;
       ccIE5: // global
           HpAlloc = 112;
           goto ccIE2;
       ccIE2: // global
           R2 = _scHAQ::P64;
           R1 = _scHBI::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIE4: // global
           _scHAq::P64 = P64[_scHBI::P64 + 7];
           _scHAu::P64 = P64[_scHBI::P64 + 15];
           _scHAw::P64 = P64[_scHBI::P64 + 23];
           _scHAy::P64 = P64[_scHBI::P64 + 31];
           _scHAA::P64 = P64[_scHBI::P64 + 39];
           _scHAC::P64 = P64[_scHBI::P64 + 47];
           _scHAE::P64 = P64[_scHBI::P64 + 55];
           _scHAG::P64 = P64[_scHBI::P64 + 63];
           _scHAI::P64 = P64[_scHBI::P64 + 71];
           _scHAK::P64 = P64[_scHBI::P64 + 79];
           _scHAM::P64 = P64[_scHBI::P64 + 87];
           _scHAO::P64 = P64[_scHBI::P64 + 95];
           I64[Hp - 104] = sat_scHBF_info;
           P64[Hp - 96] = _scHAq::P64;
           P64[Hp - 88] = _scHAu::P64;
           P64[Hp - 80] = _scHAw::P64;
           P64[Hp - 72] = _scHAy::P64;
           P64[Hp - 64] = _scHAA::P64;
           P64[Hp - 56] = _scHAC::P64;
           P64[Hp - 48] = _scHAE::P64;
           P64[Hp - 40] = _scHAG::P64;
           P64[Hp - 32] = _scHAI::P64;
           P64[Hp - 24] = _scHAK::P64;
           P64[Hp - 16] = _scHAM::P64;
           P64[Hp - 8] = _scHAO::P64;
           P64[Hp] = _scHAQ::P64;
           I64[Sp - 8] = block_ccIDY_info;
           R3 = Hp - 103;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIDY() //  [R1]
         { info_tbl: [(ccIDY,
                       label: block_ccIDY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIDY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIE8; else goto ccIE7;
       ccIE8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIE7: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHF_srtd" {
     ucIHF_srtd:
         const ScI2G_srt+104;
         const 42;
         const 4393751544185;
 },
 sat_scHBJ_entry() //  [R1, R2]
         { info_tbl: [(ccIE9,
                       label: sat_scHBJ_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIE9: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccIEd; else goto ccIEc;
       ccIEd: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIEc: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           I64[Hp - 96] = sat_scHBI_info;
           P64[Hp - 88] = _scHAq::P64;
           P64[Hp - 80] = _scHAu::P64;
           P64[Hp - 72] = _scHAw::P64;
           P64[Hp - 64] = _scHAy::P64;
           P64[Hp - 56] = _scHAA::P64;
           P64[Hp - 48] = _scHAC::P64;
           P64[Hp - 40] = _scHAE::P64;
           P64[Hp - 32] = _scHAG::P64;
           P64[Hp - 24] = _scHAI::P64;
           P64[Hp - 16] = _scHAK::P64;
           P64[Hp - 8] = _scHAM::P64;
           P64[Hp] = _scHAO::P64;
           R5 = Hp - 95;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl94_rcHre_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHG_srtd" {
     ucIHG_srtd:
         const ScI2G_srt+104;
         const 42;
         const 4393751544185;
 },
 sat_scHBM_entry() //  [R1, R2]
         { info_tbl: [(ccIEh,
                       label: sat_scHBM_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIEh: // global
           _scHAO::P64 = R2;
           _scHBM::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIEi; else goto ccIEj;
       ccIEj: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccIEl; else goto ccIEk;
       ccIEl: // global
           HpAlloc = 104;
           goto ccIEi;
       ccIEi: // global
           R2 = _scHAO::P64;
           R1 = _scHBM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIEk: // global
           _scHAq::P64 = P64[_scHBM::P64 + 7];
           _scHAu::P64 = P64[_scHBM::P64 + 15];
           _scHAw::P64 = P64[_scHBM::P64 + 23];
           _scHAy::P64 = P64[_scHBM::P64 + 31];
           _scHAA::P64 = P64[_scHBM::P64 + 39];
           _scHAC::P64 = P64[_scHBM::P64 + 47];
           _scHAE::P64 = P64[_scHBM::P64 + 55];
           _scHAG::P64 = P64[_scHBM::P64 + 63];
           _scHAI::P64 = P64[_scHBM::P64 + 71];
           _scHAK::P64 = P64[_scHBM::P64 + 79];
           _scHAM::P64 = P64[_scHBM::P64 + 87];
           I64[Hp - 96] = sat_scHBJ_info;
           P64[Hp - 88] = _scHAq::P64;
           P64[Hp - 80] = _scHAu::P64;
           P64[Hp - 72] = _scHAw::P64;
           P64[Hp - 64] = _scHAy::P64;
           P64[Hp - 56] = _scHAA::P64;
           P64[Hp - 48] = _scHAC::P64;
           P64[Hp - 40] = _scHAE::P64;
           P64[Hp - 32] = _scHAG::P64;
           P64[Hp - 24] = _scHAI::P64;
           P64[Hp - 16] = _scHAK::P64;
           P64[Hp - 8] = _scHAM::P64;
           P64[Hp] = _scHAO::P64;
           I64[Sp - 8] = block_ccIEe_info;
           R3 = Hp - 95;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIEe() //  [R1]
         { info_tbl: [(ccIEe,
                       label: block_ccIEe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIEe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIEo; else goto ccIEn;
       ccIEo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIEn: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHH_srtd" {
     ucIHH_srtd:
         const ScI2G_srt+104;
         const 43;
         const 8791798055289;
 },
 sat_scHBN_entry() //  [R1, R2]
         { info_tbl: [(ccIEp,
                       label: sat_scHBN_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIEp: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccIEt; else goto ccIEs;
       ccIEt: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIEs: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           I64[Hp - 88] = sat_scHBM_info;
           P64[Hp - 80] = _scHAq::P64;
           P64[Hp - 72] = _scHAu::P64;
           P64[Hp - 64] = _scHAw::P64;
           P64[Hp - 56] = _scHAy::P64;
           P64[Hp - 48] = _scHAA::P64;
           P64[Hp - 40] = _scHAC::P64;
           P64[Hp - 32] = _scHAE::P64;
           P64[Hp - 24] = _scHAG::P64;
           P64[Hp - 16] = _scHAI::P64;
           P64[Hp - 8] = _scHAK::P64;
           P64[Hp] = _scHAM::P64;
           R5 = Hp - 87;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl92_rcHrc_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHI_srtd" {
     ucIHI_srtd:
         const ScI2G_srt+104;
         const 43;
         const 8791798055289;
 },
 sat_scHBQ_entry() //  [R1, R2]
         { info_tbl: [(ccIEx,
                       label: sat_scHBQ_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIEx: // global
           _scHAM::P64 = R2;
           _scHBQ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIEy; else goto ccIEz;
       ccIEz: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccIEB; else goto ccIEA;
       ccIEB: // global
           HpAlloc = 96;
           goto ccIEy;
       ccIEy: // global
           R2 = _scHAM::P64;
           R1 = _scHBQ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIEA: // global
           _scHAq::P64 = P64[_scHBQ::P64 + 7];
           _scHAu::P64 = P64[_scHBQ::P64 + 15];
           _scHAw::P64 = P64[_scHBQ::P64 + 23];
           _scHAy::P64 = P64[_scHBQ::P64 + 31];
           _scHAA::P64 = P64[_scHBQ::P64 + 39];
           _scHAC::P64 = P64[_scHBQ::P64 + 47];
           _scHAE::P64 = P64[_scHBQ::P64 + 55];
           _scHAG::P64 = P64[_scHBQ::P64 + 63];
           _scHAI::P64 = P64[_scHBQ::P64 + 71];
           _scHAK::P64 = P64[_scHBQ::P64 + 79];
           I64[Hp - 88] = sat_scHBN_info;
           P64[Hp - 80] = _scHAq::P64;
           P64[Hp - 72] = _scHAu::P64;
           P64[Hp - 64] = _scHAw::P64;
           P64[Hp - 56] = _scHAy::P64;
           P64[Hp - 48] = _scHAA::P64;
           P64[Hp - 40] = _scHAC::P64;
           P64[Hp - 32] = _scHAE::P64;
           P64[Hp - 24] = _scHAG::P64;
           P64[Hp - 16] = _scHAI::P64;
           P64[Hp - 8] = _scHAK::P64;
           P64[Hp] = _scHAM::P64;
           I64[Sp - 8] = block_ccIEu_info;
           R3 = Hp - 87;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIEu() //  [R1]
         { info_tbl: [(ccIEu,
                       label: block_ccIEu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIEu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIEE; else goto ccIED;
       ccIEE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIED: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHJ_srtd" {
     ucIHJ_srtd:
         const ScI2G_srt+104;
         const 44;
         const 17587891077497;
 },
 sat_scHBR_entry() //  [R1, R2]
         { info_tbl: [(ccIEF,
                       label: sat_scHBR_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIEF: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccIEJ; else goto ccIEI;
       ccIEJ: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIEI: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           I64[Hp - 80] = sat_scHBQ_info;
           P64[Hp - 72] = _scHAq::P64;
           P64[Hp - 64] = _scHAu::P64;
           P64[Hp - 56] = _scHAw::P64;
           P64[Hp - 48] = _scHAy::P64;
           P64[Hp - 40] = _scHAA::P64;
           P64[Hp - 32] = _scHAC::P64;
           P64[Hp - 24] = _scHAE::P64;
           P64[Hp - 16] = _scHAG::P64;
           P64[Hp - 8] = _scHAI::P64;
           P64[Hp] = _scHAK::P64;
           R5 = Hp - 79;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl90_rcHra_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHK_srtd" {
     ucIHK_srtd:
         const ScI2G_srt+104;
         const 44;
         const 17587891077497;
 },
 sat_scHBU_entry() //  [R1, R2]
         { info_tbl: [(ccIEN,
                       label: sat_scHBU_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIEN: // global
           _scHAK::P64 = R2;
           _scHBU::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIEO; else goto ccIEP;
       ccIEP: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccIER; else goto ccIEQ;
       ccIER: // global
           HpAlloc = 88;
           goto ccIEO;
       ccIEO: // global
           R2 = _scHAK::P64;
           R1 = _scHBU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIEQ: // global
           _scHAq::P64 = P64[_scHBU::P64 + 7];
           _scHAu::P64 = P64[_scHBU::P64 + 15];
           _scHAw::P64 = P64[_scHBU::P64 + 23];
           _scHAy::P64 = P64[_scHBU::P64 + 31];
           _scHAA::P64 = P64[_scHBU::P64 + 39];
           _scHAC::P64 = P64[_scHBU::P64 + 47];
           _scHAE::P64 = P64[_scHBU::P64 + 55];
           _scHAG::P64 = P64[_scHBU::P64 + 63];
           _scHAI::P64 = P64[_scHBU::P64 + 71];
           I64[Hp - 80] = sat_scHBR_info;
           P64[Hp - 72] = _scHAq::P64;
           P64[Hp - 64] = _scHAu::P64;
           P64[Hp - 56] = _scHAw::P64;
           P64[Hp - 48] = _scHAy::P64;
           P64[Hp - 40] = _scHAA::P64;
           P64[Hp - 32] = _scHAC::P64;
           P64[Hp - 24] = _scHAE::P64;
           P64[Hp - 16] = _scHAG::P64;
           P64[Hp - 8] = _scHAI::P64;
           P64[Hp] = _scHAK::P64;
           I64[Sp - 8] = block_ccIEK_info;
           R3 = Hp - 79;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIEK() //  [R1]
         { info_tbl: [(ccIEK,
                       label: block_ccIEK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIEK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIEU; else goto ccIET;
       ccIEU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIET: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHL_srtd" {
     ucIHL_srtd:
         const ScI2G_srt+104;
         const 45;
         const 35180077121913;
 },
 sat_scHBV_entry() //  [R1, R2]
         { info_tbl: [(ccIEV,
                       label: sat_scHBV_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIEV: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccIEZ; else goto ccIEY;
       ccIEZ: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIEY: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           I64[Hp - 72] = sat_scHBU_info;
           P64[Hp - 64] = _scHAq::P64;
           P64[Hp - 56] = _scHAu::P64;
           P64[Hp - 48] = _scHAw::P64;
           P64[Hp - 40] = _scHAy::P64;
           P64[Hp - 32] = _scHAA::P64;
           P64[Hp - 24] = _scHAC::P64;
           P64[Hp - 16] = _scHAE::P64;
           P64[Hp - 8] = _scHAG::P64;
           P64[Hp] = _scHAI::P64;
           R5 = Hp - 71;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl88_rcHr8_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHM_srtd" {
     ucIHM_srtd:
         const ScI2G_srt+104;
         const 45;
         const 35180077121913;
 },
 sat_scHBY_entry() //  [R1, R2]
         { info_tbl: [(ccIF3,
                       label: sat_scHBY_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIF3: // global
           _scHAI::P64 = R2;
           _scHBY::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIF4; else goto ccIF5;
       ccIF5: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccIF7; else goto ccIF6;
       ccIF7: // global
           HpAlloc = 80;
           goto ccIF4;
       ccIF4: // global
           R2 = _scHAI::P64;
           R1 = _scHBY::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIF6: // global
           _scHAq::P64 = P64[_scHBY::P64 + 7];
           _scHAu::P64 = P64[_scHBY::P64 + 15];
           _scHAw::P64 = P64[_scHBY::P64 + 23];
           _scHAy::P64 = P64[_scHBY::P64 + 31];
           _scHAA::P64 = P64[_scHBY::P64 + 39];
           _scHAC::P64 = P64[_scHBY::P64 + 47];
           _scHAE::P64 = P64[_scHBY::P64 + 55];
           _scHAG::P64 = P64[_scHBY::P64 + 63];
           I64[Hp - 72] = sat_scHBV_info;
           P64[Hp - 64] = _scHAq::P64;
           P64[Hp - 56] = _scHAu::P64;
           P64[Hp - 48] = _scHAw::P64;
           P64[Hp - 40] = _scHAy::P64;
           P64[Hp - 32] = _scHAA::P64;
           P64[Hp - 24] = _scHAC::P64;
           P64[Hp - 16] = _scHAE::P64;
           P64[Hp - 8] = _scHAG::P64;
           P64[Hp] = _scHAI::P64;
           I64[Sp - 8] = block_ccIF0_info;
           R3 = Hp - 71;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIF0() //  [R1]
         { info_tbl: [(ccIF0,
                       label: block_ccIF0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIF0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIFa; else goto ccIF9;
       ccIFa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIF9: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHN_srtd" {
     ucIHN_srtd:
         const ScI2G_srt+104;
         const 46;
         const 70364449210745;
 },
 sat_scHBZ_entry() //  [R1, R2]
         { info_tbl: [(ccIFb,
                       label: sat_scHBZ_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIFb: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccIFf; else goto ccIFe;
       ccIFf: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIFe: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           I64[Hp - 64] = sat_scHBY_info;
           P64[Hp - 56] = _scHAq::P64;
           P64[Hp - 48] = _scHAu::P64;
           P64[Hp - 40] = _scHAw::P64;
           P64[Hp - 32] = _scHAy::P64;
           P64[Hp - 24] = _scHAA::P64;
           P64[Hp - 16] = _scHAC::P64;
           P64[Hp - 8] = _scHAE::P64;
           P64[Hp] = _scHAG::P64;
           R5 = Hp - 63;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl86_rcHr6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHO_srtd" {
     ucIHO_srtd:
         const ScI2G_srt+104;
         const 46;
         const 70364449210745;
 },
 sat_scHC2_entry() //  [R1, R2]
         { info_tbl: [(ccIFj,
                       label: sat_scHC2_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIFj: // global
           _scHAG::P64 = R2;
           _scHC2::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIFk; else goto ccIFl;
       ccIFl: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccIFn; else goto ccIFm;
       ccIFn: // global
           HpAlloc = 72;
           goto ccIFk;
       ccIFk: // global
           R2 = _scHAG::P64;
           R1 = _scHC2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIFm: // global
           _scHAq::P64 = P64[_scHC2::P64 + 7];
           _scHAu::P64 = P64[_scHC2::P64 + 15];
           _scHAw::P64 = P64[_scHC2::P64 + 23];
           _scHAy::P64 = P64[_scHC2::P64 + 31];
           _scHAA::P64 = P64[_scHC2::P64 + 39];
           _scHAC::P64 = P64[_scHC2::P64 + 47];
           _scHAE::P64 = P64[_scHC2::P64 + 55];
           I64[Hp - 64] = sat_scHBZ_info;
           P64[Hp - 56] = _scHAq::P64;
           P64[Hp - 48] = _scHAu::P64;
           P64[Hp - 40] = _scHAw::P64;
           P64[Hp - 32] = _scHAy::P64;
           P64[Hp - 24] = _scHAA::P64;
           P64[Hp - 16] = _scHAC::P64;
           P64[Hp - 8] = _scHAE::P64;
           P64[Hp] = _scHAG::P64;
           I64[Sp - 8] = block_ccIFg_info;
           R3 = Hp - 63;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIFg() //  [R1]
         { info_tbl: [(ccIFg,
                       label: block_ccIFg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIFg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIFq; else goto ccIFp;
       ccIFq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIFp: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHP_srtd" {
     ucIHP_srtd:
         const ScI2G_srt+104;
         const 47;
         const 140733193388409;
 },
 sat_scHC3_entry() //  [R1, R2]
         { info_tbl: [(ccIFr,
                       label: sat_scHC3_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIFr: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccIFv; else goto ccIFu;
       ccIFv: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIFu: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           I64[Hp - 56] = sat_scHC2_info;
           P64[Hp - 48] = _scHAq::P64;
           P64[Hp - 40] = _scHAu::P64;
           P64[Hp - 32] = _scHAw::P64;
           P64[Hp - 24] = _scHAy::P64;
           P64[Hp - 16] = _scHAA::P64;
           P64[Hp - 8] = _scHAC::P64;
           P64[Hp] = _scHAE::P64;
           R5 = Hp - 55;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl84_rcHr4_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHQ_srtd" {
     ucIHQ_srtd:
         const ScI2G_srt+104;
         const 47;
         const 140733193388409;
 },
 sat_scHC6_entry() //  [R1, R2]
         { info_tbl: [(ccIFz,
                       label: sat_scHC6_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIFz: // global
           _scHAE::P64 = R2;
           _scHC6::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIFA; else goto ccIFB;
       ccIFB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccIFD; else goto ccIFC;
       ccIFD: // global
           HpAlloc = 64;
           goto ccIFA;
       ccIFA: // global
           R2 = _scHAE::P64;
           R1 = _scHC6::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIFC: // global
           _scHAq::P64 = P64[_scHC6::P64 + 7];
           _scHAu::P64 = P64[_scHC6::P64 + 15];
           _scHAw::P64 = P64[_scHC6::P64 + 23];
           _scHAy::P64 = P64[_scHC6::P64 + 31];
           _scHAA::P64 = P64[_scHC6::P64 + 39];
           _scHAC::P64 = P64[_scHC6::P64 + 47];
           I64[Hp - 56] = sat_scHC3_info;
           P64[Hp - 48] = _scHAq::P64;
           P64[Hp - 40] = _scHAu::P64;
           P64[Hp - 32] = _scHAw::P64;
           P64[Hp - 24] = _scHAy::P64;
           P64[Hp - 16] = _scHAA::P64;
           P64[Hp - 8] = _scHAC::P64;
           P64[Hp] = _scHAE::P64;
           I64[Sp - 8] = block_ccIFw_info;
           R3 = Hp - 55;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIFw() //  [R1]
         { info_tbl: [(ccIFw,
                       label: block_ccIFw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIFw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIFG; else goto ccIFF;
       ccIFG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIFF: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHR_srtd" {
     ucIHR_srtd:
         const ScI2G_srt+104;
         const 48;
         const 281470681743737;
 },
 sat_scHC7_entry() //  [R1, R2]
         { info_tbl: [(ccIFH,
                       label: sat_scHC7_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIFH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccIFL; else goto ccIFK;
       ccIFL: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIFK: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           I64[Hp - 48] = sat_scHC6_info;
           P64[Hp - 40] = _scHAq::P64;
           P64[Hp - 32] = _scHAu::P64;
           P64[Hp - 24] = _scHAw::P64;
           P64[Hp - 16] = _scHAy::P64;
           P64[Hp - 8] = _scHAA::P64;
           P64[Hp] = _scHAC::P64;
           R5 = Hp - 47;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl82_rcHr2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHS_srtd" {
     ucIHS_srtd:
         const ScI2G_srt+104;
         const 48;
         const 281470681743737;
 },
 sat_scHCa_entry() //  [R1, R2]
         { info_tbl: [(ccIFP,
                       label: sat_scHCa_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIFP: // global
           _scHAC::P64 = R2;
           _scHCa::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIFQ; else goto ccIFR;
       ccIFR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccIFT; else goto ccIFS;
       ccIFT: // global
           HpAlloc = 56;
           goto ccIFQ;
       ccIFQ: // global
           R2 = _scHAC::P64;
           R1 = _scHCa::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIFS: // global
           _scHAq::P64 = P64[_scHCa::P64 + 7];
           _scHAu::P64 = P64[_scHCa::P64 + 15];
           _scHAw::P64 = P64[_scHCa::P64 + 23];
           _scHAy::P64 = P64[_scHCa::P64 + 31];
           _scHAA::P64 = P64[_scHCa::P64 + 39];
           I64[Hp - 48] = sat_scHC7_info;
           P64[Hp - 40] = _scHAq::P64;
           P64[Hp - 32] = _scHAu::P64;
           P64[Hp - 24] = _scHAw::P64;
           P64[Hp - 16] = _scHAy::P64;
           P64[Hp - 8] = _scHAA::P64;
           P64[Hp] = _scHAC::P64;
           I64[Sp - 8] = block_ccIFM_info;
           R3 = Hp - 47;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIFM() //  [R1]
         { info_tbl: [(ccIFM,
                       label: block_ccIFM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIFM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIFW; else goto ccIFV;
       ccIFW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIFV: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHT_srtd" {
     ucIHT_srtd:
         const ScI2G_srt+104;
         const 49;
         const 562945658454393;
 },
 sat_scHCb_entry() //  [R1, R2]
         { info_tbl: [(ccIFX,
                       label: sat_scHCb_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIFX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccIG1; else goto ccIG0;
       ccIG1: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIG0: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           I64[Hp - 40] = sat_scHCa_info;
           P64[Hp - 32] = _scHAq::P64;
           P64[Hp - 24] = _scHAu::P64;
           P64[Hp - 16] = _scHAw::P64;
           P64[Hp - 8] = _scHAy::P64;
           P64[Hp] = _scHAA::P64;
           R5 = Hp - 39;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl80_rcHr0_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHU_srtd" {
     ucIHU_srtd:
         const ScI2G_srt+104;
         const 49;
         const 562945658454393;
 },
 sat_scHCe_entry() //  [R1, R2]
         { info_tbl: [(ccIG5,
                       label: sat_scHCe_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIG5: // global
           _scHAA::P64 = R2;
           _scHCe::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIG6; else goto ccIG7;
       ccIG7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccIG9; else goto ccIG8;
       ccIG9: // global
           HpAlloc = 48;
           goto ccIG6;
       ccIG6: // global
           R2 = _scHAA::P64;
           R1 = _scHCe::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIG8: // global
           _scHAq::P64 = P64[_scHCe::P64 + 7];
           _scHAu::P64 = P64[_scHCe::P64 + 15];
           _scHAw::P64 = P64[_scHCe::P64 + 23];
           _scHAy::P64 = P64[_scHCe::P64 + 31];
           I64[Hp - 40] = sat_scHCb_info;
           P64[Hp - 32] = _scHAq::P64;
           P64[Hp - 24] = _scHAu::P64;
           P64[Hp - 16] = _scHAw::P64;
           P64[Hp - 8] = _scHAy::P64;
           P64[Hp] = _scHAA::P64;
           I64[Sp - 8] = block_ccIG2_info;
           R3 = Hp - 39;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIG2() //  [R1]
         { info_tbl: [(ccIG2,
                       label: block_ccIG2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIG2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIGc; else goto ccIGb;
       ccIGc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIGb: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHV_srtd" {
     ucIHV_srtd:
         const ScI2G_srt+104;
         const 50;
         const 1125895611875705;
 },
 sat_scHCf_entry() //  [R1, R2]
         { info_tbl: [(ccIGd,
                       label: sat_scHCf_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIGd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccIGh; else goto ccIGg;
       ccIGh: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIGg: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           I64[Hp - 32] = sat_scHCe_info;
           P64[Hp - 24] = _scHAq::P64;
           P64[Hp - 16] = _scHAu::P64;
           P64[Hp - 8] = _scHAw::P64;
           P64[Hp] = _scHAy::P64;
           R5 = Hp - 31;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl78_rcHqY_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHW_srtd" {
     ucIHW_srtd:
         const ScI2G_srt+104;
         const 50;
         const 1125895611875705;
 },
 sat_scHCi_entry() //  [R1, R2]
         { info_tbl: [(ccIGl,
                       label: sat_scHCi_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIGl: // global
           _scHAy::P64 = R2;
           _scHCi::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIGm; else goto ccIGn;
       ccIGn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccIGp; else goto ccIGo;
       ccIGp: // global
           HpAlloc = 40;
           goto ccIGm;
       ccIGm: // global
           R2 = _scHAy::P64;
           R1 = _scHCi::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIGo: // global
           _scHAq::P64 = P64[_scHCi::P64 + 7];
           _scHAu::P64 = P64[_scHCi::P64 + 15];
           _scHAw::P64 = P64[_scHCi::P64 + 23];
           I64[Hp - 32] = sat_scHCf_info;
           P64[Hp - 24] = _scHAq::P64;
           P64[Hp - 16] = _scHAu::P64;
           P64[Hp - 8] = _scHAw::P64;
           P64[Hp] = _scHAy::P64;
           I64[Sp - 8] = block_ccIGi_info;
           R3 = Hp - 31;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIGi() //  [R1]
         { info_tbl: [(ccIGi,
                       label: block_ccIGi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIGi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIGs; else goto ccIGr;
       ccIGs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIGr: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHX_srtd" {
     ucIHX_srtd:
         const ScI2G_srt+104;
         const 51;
         const 2251795518718329;
 },
 sat_scHCj_entry() //  [R1, R2]
         { info_tbl: [(ccIGt,
                       label: sat_scHCj_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIGt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccIGx; else goto ccIGw;
       ccIGx: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIGw: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           I64[Hp - 24] = sat_scHCi_info;
           P64[Hp - 16] = _scHAq::P64;
           P64[Hp - 8] = _scHAu::P64;
           P64[Hp] = _scHAw::P64;
           R5 = Hp - 23;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl76_rcHqW_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHY_srtd" {
     ucIHY_srtd:
         const ScI2G_srt+104;
         const 51;
         const 2251795518718329;
 },
 sat_scHCm_entry() //  [R1, R2]
         { info_tbl: [(ccIGB,
                       label: sat_scHCm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIGB: // global
           _scHAw::P64 = R2;
           _scHCm::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIGC; else goto ccIGD;
       ccIGD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccIGF; else goto ccIGE;
       ccIGF: // global
           HpAlloc = 32;
           goto ccIGC;
       ccIGC: // global
           R2 = _scHAw::P64;
           R1 = _scHCm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIGE: // global
           _scHAq::P64 = P64[_scHCm::P64 + 7];
           _scHAu::P64 = P64[_scHCm::P64 + 15];
           I64[Hp - 24] = sat_scHCj_info;
           P64[Hp - 16] = _scHAq::P64;
           P64[Hp - 8] = _scHAu::P64;
           P64[Hp] = _scHAw::P64;
           I64[Sp - 8] = block_ccIGy_info;
           R3 = Hp - 23;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIGy() //  [R1]
         { info_tbl: [(ccIGy,
                       label: block_ccIGy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIGy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIGI; else goto ccIGH;
       ccIGI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIGH: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucIHZ_srtd" {
     ucIHZ_srtd:
         const ScI2G_srt+80;
         const 55;
         const 36028762659228617;
 },
 sat_scHCn_entry() //  [R1, R2]
         { info_tbl: [(ccIGJ,
                       label: sat_scHCn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIGJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIGN; else goto ccIGM;
       ccIGN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIGM: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_scHCm_info;
           P64[Hp - 8] = _scHAq::P64;
           P64[Hp] = _scHAu::P64;
           R5 = Hp - 15;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = lvl74_rcHqU_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucII0_srtd" {
     ucII0_srtd:
         const ScI2G_srt+80;
         const 55;
         const 36028762659228617;
 },
 sat_scHCq_entry() //  [R1, R2]
         { info_tbl: [(ccIGR,
                       label: sat_scHCq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIGR: // global
           _scHAu::P64 = R2;
           _scHCq::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIGS; else goto ccIGT;
       ccIGT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIGV; else goto ccIGU;
       ccIGV: // global
           HpAlloc = 24;
           goto ccIGS;
       ccIGS: // global
           R2 = _scHAu::P64;
           R1 = _scHCq::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIGU: // global
           _scHAq::P64 = P64[_scHCq::P64 + 7];
           I64[Hp - 16] = sat_scHCn_info;
           P64[Hp - 8] = _scHAq::P64;
           P64[Hp] = _scHAu::P64;
           I64[Sp - 8] = block_ccIGO_info;
           R3 = Hp - 15;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIGO() //  [R1]
         { info_tbl: [(ccIGO,
                       label: block_ccIGO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIGO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIGY; else goto ccIGX;
       ccIGY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIGX: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucII1_srtd" {
     ucII1_srtd:
         const ScI2G_srt+80;
         const 56;
         const 72057559678192585;
 },
 sat_scHCr_entry() //  [R1, R2]
         { info_tbl: [(ccIGZ,
                       label: sat_scHCr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIGZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIH3; else goto ccIH2;
       ccIH3: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIH2: // global
           _scHAq::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_scHCq_info;
           P64[Hp] = _scHAq::P64;
           R5 = Hp - 7;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = ds4_rcHqS_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucII2_srtd" {
     ucII2_srtd:
         const ScI2G_srt+80;
         const 56;
         const 72057559711747017;
 },
 sat_scHCu_entry() //  [R1, R2]
         { info_tbl: [(ccIH7,
                       label: sat_scHCu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIH7: // global
           _scHAs::P64 = R2;
           _scHCu::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIH8; else goto ccIH9;
       ccIH9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIHb; else goto ccIHa;
       ccIHb: // global
           HpAlloc = 16;
           goto ccIH8;
       ccIH8: // global
           R2 = _scHAs::P64;
           R1 = _scHCu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIHa: // global
           _scHAq::P64 = P64[_scHCu::P64 + 7];
           I64[Hp - 8] = sat_scHCr_info;
           P64[Hp] = _scHAq::P64;
           I64[Sp - 8] = block_ccIH4_info;
           R3 = Hp - 7;
           R2 = lexeme4_rcHqa_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIH4() //  [R1]
         { info_tbl: [(ccIH4,
                       label: block_ccIH4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIH4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIHe; else goto ccIHd;
       ccIHe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIHd: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucII3_srtd" {
     ucII3_srtd:
         const ScI2G_srt+80;
         const 58;
         const 288230341825530825;
 },
 GHC.Stats.$w$creadPrec1_entry() //  [R2, R3]
         { info_tbl: [(ccIHi,
                       label: GHC.Stats.$w$creadPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIHi: // global
           _scHAq::P64 = R3;
           _scHAp::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccIHj; else goto ccIHk;
       ccIHk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIHm; else goto ccIHl;
       ccIHm: // global
           HpAlloc = 16;
           goto ccIHj;
       ccIHj: // global
           R3 = _scHAq::P64;
           R2 = _scHAp::I64;
           R1 = GHC.Stats.$w$creadPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccIHl: // global
           if (%MO_S_Gt_W64(_scHAp::I64, 11)) goto ccIHg; else goto ccIHh;
       ccIHg: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccIHh: // global
           I64[Hp - 8] = sat_scHCu_info;
           P64[Hp] = _scHAq::P64;
           I64[Sp - 8] = block_ccIHn_info;
           R3 = Hp - 7;
           R2 = lexeme6_rcHqQ_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccIHn() //  [R1]
         { info_tbl: [(ccIHn,
                       label: block_ccIHn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIHn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccIHs; else goto ccIHr;
       ccIHs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccIHr: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.072976523 UTC

[section ""data" . GHC.Stats.$fReadRTSStats2_closure" {
     GHC.Stats.$fReadRTSStats2_closure:
         const GHC.Stats.$fReadRTSStats2_info;
         const 0;
 },
 GHC.Stats.$fReadRTSStats2_entry() //  [R2, R3]
         { info_tbl: [(ccIIb,
                       label: GHC.Stats.$fReadRTSStats2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIIb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIIc; else goto ccIId;
       ccIIc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fReadRTSStats2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccIId: // global
           I64[Sp - 16] = block_ccII8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucIIh; else goto ccII9;
       ucIIh: // global
           call _ccII8(R1) args: 0, res: 0, upd: 0;
       ccII9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccII8() //  [R1]
         { info_tbl: [(ccII8,
                       label: block_ccII8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccII8: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Stats.$w$creadPrec1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.074269064 UTC

[section ""data" . GHC.Stats.$fReadRTSStats1_closure" {
     GHC.Stats.$fReadRTSStats1_closure:
         const GHC.Stats.$fReadRTSStats1_info;
         const 0;
 },
 GHC.Stats.$fReadRTSStats1_entry() //  [R2, R3]
         { info_tbl: [(ccIIm,
                       label: GHC.Stats.$fReadRTSStats1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIIm: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fReadRTSStats2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.075328413 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_$creadsPrec_closure" {
     GHC.Stats.$fReadRTSStats_$creadsPrec_closure:
         const GHC.Stats.$fReadRTSStats_$creadsPrec_info;
         const 0;
 },
 sat_scHCC_entry() //  [R1]
         { info_tbl: [(ccIIx,
                       label: sat_scHCC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIIx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIIy; else goto ccIIz;
       ccIIy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIIz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Stats.$fReadRTSStats2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stats.$fReadRTSStats_$creadsPrec_entry() //  [R2]
         { info_tbl: [(ccIIA,
                       label: GHC.Stats.$fReadRTSStats_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIIA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIIE; else goto ccIID;
       ccIIE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stats.$fReadRTSStats_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIID: // global
           I64[Hp - 16] = sat_scHCC_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.0766545 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_$creadListPrec_closure" {
     GHC.Stats.$fReadRTSStats_$creadListPrec_closure:
         const GHC.Stats.$fReadRTSStats_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadRTSStats_$creadListPrec_entry() //  [R1]
         { info_tbl: [(ccIIL,
                       label: GHC.Stats.$fReadRTSStats_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIIL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIIM; else goto ccIIN;
       ccIIM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIIN: // global
           (_ccIII::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIII::I64 == 0) goto ccIIK; else goto ccIIJ;
       ccIIK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIIJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIII::I64;
           R2 = GHC.Stats.$fReadRTSStats1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.077707152 UTC

[section ""data" . GHC.Stats.$fReadRTSStats3_closure" {
     GHC.Stats.$fReadRTSStats3_closure:
         const GHC.Stats.$fReadRTSStats3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadRTSStats3_entry() //  [R1]
         { info_tbl: [(ccIIU,
                       label: GHC.Stats.$fReadRTSStats3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIIU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIIV; else goto ccIIW;
       ccIIV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIIW: // global
           (_ccIIR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIIR::I64 == 0) goto ccIIT; else goto ccIIS;
       ccIIT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIIS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIIR::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.Stats.$fReadRTSStats_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.078753558 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_$creadList_closure" {
     GHC.Stats.$fReadRTSStats_$creadList_closure:
         const GHC.Stats.$fReadRTSStats_$creadList_info;
         const 0;
 },
 GHC.Stats.$fReadRTSStats_$creadList_entry() //  [R2]
         { info_tbl: [(ccIJ1,
                       label: GHC.Stats.$fReadRTSStats_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIJ1: // global
           R3 = R2;
           R2 = GHC.Stats.$fReadRTSStats3_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.079472862 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_closure" {
     GHC.Stats.$fReadRTSStats_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Stats.$fReadRTSStats_$creadsPrec_closure+1;
         const GHC.Stats.$fReadRTSStats_$creadList_closure+1;
         const GHC.Stats.$fReadRTSStats1_closure+2;
         const GHC.Stats.$fReadRTSStats_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.080286942 UTC

[section ""data" . GHC.Stats.gcdetails_elapsed_ns_closure" {
     GHC.Stats.gcdetails_elapsed_ns_closure:
         const GHC.Stats.gcdetails_elapsed_ns_info;
 },
 GHC.Stats.gcdetails_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccIJb,
                       label: GHC.Stats.gcdetails_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIJb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIJc; else goto ccIJd;
       ccIJc: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIJd: // global
           I64[Sp - 8] = block_ccIJ8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIJh; else goto ccIJ9;
       ucIJh: // global
           call _ccIJ8(R1) args: 0, res: 0, upd: 0;
       ccIJ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIJ8() //  [R1]
         { info_tbl: [(ccIJ8,
                       label: block_ccIJ8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIJ8: // global
           R1 = P64[R1 + 111] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.081489626 UTC

[section ""data" . GHC.Stats.gcdetails_cpu_ns_closure" {
     GHC.Stats.gcdetails_cpu_ns_closure:
         const GHC.Stats.gcdetails_cpu_ns_info;
 },
 GHC.Stats.gcdetails_cpu_ns_entry() //  [R2]
         { info_tbl: [(ccIJp,
                       label: GHC.Stats.gcdetails_cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIJp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIJq; else goto ccIJr;
       ccIJq: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIJr: // global
           I64[Sp - 8] = block_ccIJm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIJv; else goto ccIJn;
       ucIJv: // global
           call _ccIJm(R1) args: 0, res: 0, upd: 0;
       ccIJn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIJm() //  [R1]
         { info_tbl: [(ccIJm,
                       label: block_ccIJm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIJm: // global
           R1 = P64[R1 + 103] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.082660332 UTC

[section ""data" . GHC.Stats.gcdetails_sync_elapsed_ns_closure" {
     GHC.Stats.gcdetails_sync_elapsed_ns_closure:
         const GHC.Stats.gcdetails_sync_elapsed_ns_info;
 },
 GHC.Stats.gcdetails_sync_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccIJD,
                       label: GHC.Stats.gcdetails_sync_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIJD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIJE; else goto ccIJF;
       ccIJE: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_sync_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIJF: // global
           I64[Sp - 8] = block_ccIJA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIJJ; else goto ccIJB;
       ucIJJ: // global
           call _ccIJA(R1) args: 0, res: 0, upd: 0;
       ccIJB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIJA() //  [R1]
         { info_tbl: [(ccIJA,
                       label: block_ccIJA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIJA: // global
           R1 = P64[R1 + 95] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.083807333 UTC

[section ""data" . GHC.Stats.gcdetails_par_balanced_copied_bytes_closure" {
     GHC.Stats.gcdetails_par_balanced_copied_bytes_closure:
         const GHC.Stats.gcdetails_par_balanced_copied_bytes_info;
 },
 GHC.Stats.gcdetails_par_balanced_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccIJR,
                       label: GHC.Stats.gcdetails_par_balanced_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIJR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIJS; else goto ccIJT;
       ccIJS: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_par_balanced_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIJT: // global
           I64[Sp - 8] = block_ccIJO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIJX; else goto ccIJP;
       ucIJX: // global
           call _ccIJO(R1) args: 0, res: 0, upd: 0;
       ccIJP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIJO() //  [R1]
         { info_tbl: [(ccIJO,
                       label: block_ccIJO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIJO: // global
           R1 = P64[R1 + 87] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.084972928 UTC

[section ""data" . GHC.Stats.gcdetails_par_max_copied_bytes_closure" {
     GHC.Stats.gcdetails_par_max_copied_bytes_closure:
         const GHC.Stats.gcdetails_par_max_copied_bytes_info;
 },
 GHC.Stats.gcdetails_par_max_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccIK5,
                       label: GHC.Stats.gcdetails_par_max_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIK5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIK6; else goto ccIK7;
       ccIK6: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_par_max_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIK7: // global
           I64[Sp - 8] = block_ccIK2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIKb; else goto ccIK3;
       ucIKb: // global
           call _ccIK2(R1) args: 0, res: 0, upd: 0;
       ccIK3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIK2() //  [R1]
         { info_tbl: [(ccIK2,
                       label: block_ccIK2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIK2: // global
           R1 = P64[R1 + 79] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.086192337 UTC

[section ""data" . GHC.Stats.gcdetails_copied_bytes_closure" {
     GHC.Stats.gcdetails_copied_bytes_closure:
         const GHC.Stats.gcdetails_copied_bytes_info;
 },
 GHC.Stats.gcdetails_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccIKj,
                       label: GHC.Stats.gcdetails_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIKj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIKk; else goto ccIKl;
       ccIKk: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIKl: // global
           I64[Sp - 8] = block_ccIKg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIKp; else goto ccIKh;
       ucIKp: // global
           call _ccIKg(R1) args: 0, res: 0, upd: 0;
       ccIKh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIKg() //  [R1]
         { info_tbl: [(ccIKg,
                       label: block_ccIKg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIKg: // global
           R1 = P64[R1 + 71] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.087377686 UTC

[section ""data" . GHC.Stats.gcdetails_mem_in_use_bytes_closure" {
     GHC.Stats.gcdetails_mem_in_use_bytes_closure:
         const GHC.Stats.gcdetails_mem_in_use_bytes_info;
 },
 GHC.Stats.gcdetails_mem_in_use_bytes_entry() //  [R2]
         { info_tbl: [(ccIKx,
                       label: GHC.Stats.gcdetails_mem_in_use_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIKx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIKy; else goto ccIKz;
       ccIKy: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_mem_in_use_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIKz: // global
           I64[Sp - 8] = block_ccIKu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIKD; else goto ccIKv;
       ucIKD: // global
           call _ccIKu(R1) args: 0, res: 0, upd: 0;
       ccIKv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIKu() //  [R1]
         { info_tbl: [(ccIKu,
                       label: block_ccIKu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIKu: // global
           R1 = P64[R1 + 63] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.08858022 UTC

[section ""data" . GHC.Stats.gcdetails_slop_bytes_closure" {
     GHC.Stats.gcdetails_slop_bytes_closure:
         const GHC.Stats.gcdetails_slop_bytes_info;
 },
 GHC.Stats.gcdetails_slop_bytes_entry() //  [R2]
         { info_tbl: [(ccIKL,
                       label: GHC.Stats.gcdetails_slop_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIKL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIKM; else goto ccIKN;
       ccIKM: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_slop_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIKN: // global
           I64[Sp - 8] = block_ccIKI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIKR; else goto ccIKJ;
       ucIKR: // global
           call _ccIKI(R1) args: 0, res: 0, upd: 0;
       ccIKJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIKI() //  [R1]
         { info_tbl: [(ccIKI,
                       label: block_ccIKI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIKI: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.089807893 UTC

[section ""data" . GHC.Stats.gcdetails_compact_bytes_closure" {
     GHC.Stats.gcdetails_compact_bytes_closure:
         const GHC.Stats.gcdetails_compact_bytes_info;
 },
 GHC.Stats.gcdetails_compact_bytes_entry() //  [R2]
         { info_tbl: [(ccIKZ,
                       label: GHC.Stats.gcdetails_compact_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIKZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIL0; else goto ccIL1;
       ccIL0: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_compact_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIL1: // global
           I64[Sp - 8] = block_ccIKW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIL5; else goto ccIKX;
       ucIL5: // global
           call _ccIKW(R1) args: 0, res: 0, upd: 0;
       ccIKX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIKW() //  [R1]
         { info_tbl: [(ccIKW,
                       label: block_ccIKW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIKW: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.090997841 UTC

[section ""data" . GHC.Stats.gcdetails_large_objects_bytes_closure" {
     GHC.Stats.gcdetails_large_objects_bytes_closure:
         const GHC.Stats.gcdetails_large_objects_bytes_info;
 },
 GHC.Stats.gcdetails_large_objects_bytes_entry() //  [R2]
         { info_tbl: [(ccILd,
                       label: GHC.Stats.gcdetails_large_objects_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccILd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccILe; else goto ccILf;
       ccILe: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_large_objects_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccILf: // global
           I64[Sp - 8] = block_ccILa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucILj; else goto ccILb;
       ucILj: // global
           call _ccILa(R1) args: 0, res: 0, upd: 0;
       ccILb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccILa() //  [R1]
         { info_tbl: [(ccILa,
                       label: block_ccILa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccILa: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.092213064 UTC

[section ""data" . GHC.Stats.gcdetails_live_bytes_closure" {
     GHC.Stats.gcdetails_live_bytes_closure:
         const GHC.Stats.gcdetails_live_bytes_info;
 },
 GHC.Stats.gcdetails_live_bytes_entry() //  [R2]
         { info_tbl: [(ccILr,
                       label: GHC.Stats.gcdetails_live_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccILr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccILs; else goto ccILt;
       ccILs: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_live_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccILt: // global
           I64[Sp - 8] = block_ccILo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucILx; else goto ccILp;
       ucILx: // global
           call _ccILo(R1) args: 0, res: 0, upd: 0;
       ccILp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccILo() //  [R1]
         { info_tbl: [(ccILo,
                       label: block_ccILo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccILo: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.0934381 UTC

[section ""data" . GHC.Stats.gcdetails_allocated_bytes_closure" {
     GHC.Stats.gcdetails_allocated_bytes_closure:
         const GHC.Stats.gcdetails_allocated_bytes_info;
 },
 GHC.Stats.gcdetails_allocated_bytes_entry() //  [R2]
         { info_tbl: [(ccILF,
                       label: GHC.Stats.gcdetails_allocated_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccILF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccILG; else goto ccILH;
       ccILG: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_allocated_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccILH: // global
           I64[Sp - 8] = block_ccILC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucILL; else goto ccILD;
       ucILL: // global
           call _ccILC(R1) args: 0, res: 0, upd: 0;
       ccILD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccILC() //  [R1]
         { info_tbl: [(ccILC,
                       label: block_ccILC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccILC: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.094660601 UTC

[section ""data" . GHC.Stats.gcdetails_threads_closure" {
     GHC.Stats.gcdetails_threads_closure:
         const GHC.Stats.gcdetails_threads_info;
 },
 GHC.Stats.gcdetails_threads_entry() //  [R2]
         { info_tbl: [(ccILT,
                       label: GHC.Stats.gcdetails_threads_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccILT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccILU; else goto ccILV;
       ccILU: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_threads_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccILV: // global
           I64[Sp - 8] = block_ccILQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucILZ; else goto ccILR;
       ucILZ: // global
           call _ccILQ(R1) args: 0, res: 0, upd: 0;
       ccILR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccILQ() //  [R1]
         { info_tbl: [(ccILQ,
                       label: block_ccILQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccILQ: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.097165027 UTC

[section ""data" . GHC.Stats.gcdetails_gen_closure" {
     GHC.Stats.gcdetails_gen_closure:
         const GHC.Stats.gcdetails_gen_info;
 },
 GHC.Stats.gcdetails_gen_entry() //  [R2]
         { info_tbl: [(ccIM7,
                       label: GHC.Stats.gcdetails_gen_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIM7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIM8; else goto ccIM9;
       ccIM8: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_gen_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIM9: // global
           I64[Sp - 8] = block_ccIM4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIMd; else goto ccIM5;
       ucIMd: // global
           call _ccIM4(R1) args: 0, res: 0, upd: 0;
       ccIM5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIM4() //  [R1]
         { info_tbl: [(ccIM4,
                       label: block_ccIM4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIM4: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.098388714 UTC

[section ""data" . GHC.Stats.gc_closure" {
     GHC.Stats.gc_closure:
         const GHC.Stats.gc_info;
 },
 GHC.Stats.gc_entry() //  [R2]
         { info_tbl: [(ccIMl,
                       label: GHC.Stats.gc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIMl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIMm; else goto ccIMn;
       ccIMm: // global
           R2 = R2;
           R1 = GHC.Stats.gc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIMn: // global
           I64[Sp - 8] = block_ccIMi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIMr; else goto ccIMj;
       ucIMr: // global
           call _ccIMi(R1) args: 0, res: 0, upd: 0;
       ccIMj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIMi() //  [R1]
         { info_tbl: [(ccIMi,
                       label: block_ccIMi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIMi: // global
           R1 = P64[R1 + 159] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.09956121 UTC

[section ""data" . GHC.Stats.elapsed_ns_closure" {
     GHC.Stats.elapsed_ns_closure:
         const GHC.Stats.elapsed_ns_info;
 },
 GHC.Stats.elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccIMz,
                       label: GHC.Stats.elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIMz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIMA; else goto ccIMB;
       ccIMA: // global
           R2 = R2;
           R1 = GHC.Stats.elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIMB: // global
           I64[Sp - 8] = block_ccIMw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIMF; else goto ccIMx;
       ucIMF: // global
           call _ccIMw(R1) args: 0, res: 0, upd: 0;
       ccIMx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIMw() //  [R1]
         { info_tbl: [(ccIMw,
                       label: block_ccIMw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIMw: // global
           R1 = P64[R1 + 151] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.100749862 UTC

[section ""data" . GHC.Stats.cpu_ns_closure" {
     GHC.Stats.cpu_ns_closure:
         const GHC.Stats.cpu_ns_info;
 },
 GHC.Stats.cpu_ns_entry() //  [R2]
         { info_tbl: [(ccIMN,
                       label: GHC.Stats.cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIMN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIMO; else goto ccIMP;
       ccIMO: // global
           R2 = R2;
           R1 = GHC.Stats.cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIMP: // global
           I64[Sp - 8] = block_ccIMK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIMT; else goto ccIML;
       ucIMT: // global
           call _ccIMK(R1) args: 0, res: 0, upd: 0;
       ccIML: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIMK() //  [R1]
         { info_tbl: [(ccIMK,
                       label: block_ccIMK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIMK: // global
           R1 = P64[R1 + 143] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.102181884 UTC

[section ""data" . GHC.Stats.gc_elapsed_ns_closure" {
     GHC.Stats.gc_elapsed_ns_closure:
         const GHC.Stats.gc_elapsed_ns_info;
 },
 GHC.Stats.gc_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccIN1,
                       label: GHC.Stats.gc_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIN1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIN2; else goto ccIN3;
       ccIN2: // global
           R2 = R2;
           R1 = GHC.Stats.gc_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIN3: // global
           I64[Sp - 8] = block_ccIMY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIN7; else goto ccIMZ;
       ucIN7: // global
           call _ccIMY(R1) args: 0, res: 0, upd: 0;
       ccIMZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIMY() //  [R1]
         { info_tbl: [(ccIMY,
                       label: block_ccIMY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIMY: // global
           R1 = P64[R1 + 135] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.103363702 UTC

[section ""data" . GHC.Stats.gc_cpu_ns_closure" {
     GHC.Stats.gc_cpu_ns_closure:
         const GHC.Stats.gc_cpu_ns_info;
 },
 GHC.Stats.gc_cpu_ns_entry() //  [R2]
         { info_tbl: [(ccINf,
                       label: GHC.Stats.gc_cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccINf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccINg; else goto ccINh;
       ccINg: // global
           R2 = R2;
           R1 = GHC.Stats.gc_cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccINh: // global
           I64[Sp - 8] = block_ccINc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucINl; else goto ccINd;
       ucINl: // global
           call _ccINc(R1) args: 0, res: 0, upd: 0;
       ccINd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccINc() //  [R1]
         { info_tbl: [(ccINc,
                       label: block_ccINc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccINc: // global
           R1 = P64[R1 + 127] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.104528349 UTC

[section ""data" . GHC.Stats.mutator_elapsed_ns_closure" {
     GHC.Stats.mutator_elapsed_ns_closure:
         const GHC.Stats.mutator_elapsed_ns_info;
 },
 GHC.Stats.mutator_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccINt,
                       label: GHC.Stats.mutator_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccINt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccINu; else goto ccINv;
       ccINu: // global
           R2 = R2;
           R1 = GHC.Stats.mutator_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccINv: // global
           I64[Sp - 8] = block_ccINq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucINz; else goto ccINr;
       ucINz: // global
           call _ccINq(R1) args: 0, res: 0, upd: 0;
       ccINr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccINq() //  [R1]
         { info_tbl: [(ccINq,
                       label: block_ccINq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccINq: // global
           R1 = P64[R1 + 119] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.105759034 UTC

[section ""data" . GHC.Stats.mutator_cpu_ns_closure" {
     GHC.Stats.mutator_cpu_ns_closure:
         const GHC.Stats.mutator_cpu_ns_info;
 },
 GHC.Stats.mutator_cpu_ns_entry() //  [R2]
         { info_tbl: [(ccINH,
                       label: GHC.Stats.mutator_cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccINH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccINI; else goto ccINJ;
       ccINI: // global
           R2 = R2;
           R1 = GHC.Stats.mutator_cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccINJ: // global
           I64[Sp - 8] = block_ccINE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucINN; else goto ccINF;
       ucINN: // global
           call _ccINE(R1) args: 0, res: 0, upd: 0;
       ccINF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccINE() //  [R1]
         { info_tbl: [(ccINE,
                       label: block_ccINE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccINE: // global
           R1 = P64[R1 + 111] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.106952143 UTC

[section ""data" . GHC.Stats.cumulative_par_balanced_copied_bytes_closure" {
     GHC.Stats.cumulative_par_balanced_copied_bytes_closure:
         const GHC.Stats.cumulative_par_balanced_copied_bytes_info;
 },
 GHC.Stats.cumulative_par_balanced_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccINV,
                       label: GHC.Stats.cumulative_par_balanced_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccINV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccINW; else goto ccINX;
       ccINW: // global
           R2 = R2;
           R1 = GHC.Stats.cumulative_par_balanced_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccINX: // global
           I64[Sp - 8] = block_ccINS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIO1; else goto ccINT;
       ucIO1: // global
           call _ccINS(R1) args: 0, res: 0, upd: 0;
       ccINT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccINS() //  [R1]
         { info_tbl: [(ccINS,
                       label: block_ccINS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccINS: // global
           R1 = P64[R1 + 103] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.108107214 UTC

[section ""data" . GHC.Stats.cumulative_par_max_copied_bytes_closure" {
     GHC.Stats.cumulative_par_max_copied_bytes_closure:
         const GHC.Stats.cumulative_par_max_copied_bytes_info;
 },
 GHC.Stats.cumulative_par_max_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccIO9,
                       label: GHC.Stats.cumulative_par_max_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIO9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIOa; else goto ccIOb;
       ccIOa: // global
           R2 = R2;
           R1 = GHC.Stats.cumulative_par_max_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIOb: // global
           I64[Sp - 8] = block_ccIO6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIOf; else goto ccIO7;
       ucIOf: // global
           call _ccIO6(R1) args: 0, res: 0, upd: 0;
       ccIO7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIO6() //  [R1]
         { info_tbl: [(ccIO6,
                       label: block_ccIO6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIO6: // global
           R1 = P64[R1 + 95] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.109277526 UTC

[section ""data" . GHC.Stats.par_copied_bytes_closure" {
     GHC.Stats.par_copied_bytes_closure:
         const GHC.Stats.par_copied_bytes_info;
 },
 GHC.Stats.par_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccIOn,
                       label: GHC.Stats.par_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIOn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIOo; else goto ccIOp;
       ccIOo: // global
           R2 = R2;
           R1 = GHC.Stats.par_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIOp: // global
           I64[Sp - 8] = block_ccIOk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIOt; else goto ccIOl;
       ucIOt: // global
           call _ccIOk(R1) args: 0, res: 0, upd: 0;
       ccIOl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIOk() //  [R1]
         { info_tbl: [(ccIOk,
                       label: block_ccIOk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIOk: // global
           R1 = P64[R1 + 87] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.110488291 UTC

[section ""data" . GHC.Stats.copied_bytes_closure" {
     GHC.Stats.copied_bytes_closure:
         const GHC.Stats.copied_bytes_info;
 },
 GHC.Stats.copied_bytes_entry() //  [R2]
         { info_tbl: [(ccIOB,
                       label: GHC.Stats.copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIOB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIOC; else goto ccIOD;
       ccIOC: // global
           R2 = R2;
           R1 = GHC.Stats.copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIOD: // global
           I64[Sp - 8] = block_ccIOy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIOH; else goto ccIOz;
       ucIOH: // global
           call _ccIOy(R1) args: 0, res: 0, upd: 0;
       ccIOz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIOy() //  [R1]
         { info_tbl: [(ccIOy,
                       label: block_ccIOy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIOy: // global
           R1 = P64[R1 + 79] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.111625812 UTC

[section ""data" . GHC.Stats.cumulative_live_bytes_closure" {
     GHC.Stats.cumulative_live_bytes_closure:
         const GHC.Stats.cumulative_live_bytes_info;
 },
 GHC.Stats.cumulative_live_bytes_entry() //  [R2]
         { info_tbl: [(ccIOP,
                       label: GHC.Stats.cumulative_live_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIOP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIOQ; else goto ccIOR;
       ccIOQ: // global
           R2 = R2;
           R1 = GHC.Stats.cumulative_live_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIOR: // global
           I64[Sp - 8] = block_ccIOM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIOV; else goto ccION;
       ucIOV: // global
           call _ccIOM(R1) args: 0, res: 0, upd: 0;
       ccION: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIOM() //  [R1]
         { info_tbl: [(ccIOM,
                       label: block_ccIOM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIOM: // global
           R1 = P64[R1 + 71] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.112813527 UTC

[section ""data" . GHC.Stats.max_mem_in_use_bytes_closure" {
     GHC.Stats.max_mem_in_use_bytes_closure:
         const GHC.Stats.max_mem_in_use_bytes_info;
 },
 GHC.Stats.max_mem_in_use_bytes_entry() //  [R2]
         { info_tbl: [(ccIP3,
                       label: GHC.Stats.max_mem_in_use_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIP3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIP4; else goto ccIP5;
       ccIP4: // global
           R2 = R2;
           R1 = GHC.Stats.max_mem_in_use_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIP5: // global
           I64[Sp - 8] = block_ccIP0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIP9; else goto ccIP1;
       ucIP9: // global
           call _ccIP0(R1) args: 0, res: 0, upd: 0;
       ccIP1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIP0() //  [R1]
         { info_tbl: [(ccIP0,
                       label: block_ccIP0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIP0: // global
           R1 = P64[R1 + 63] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.114316006 UTC

[section ""data" . GHC.Stats.max_slop_bytes_closure" {
     GHC.Stats.max_slop_bytes_closure:
         const GHC.Stats.max_slop_bytes_info;
 },
 GHC.Stats.max_slop_bytes_entry() //  [R2]
         { info_tbl: [(ccIPh,
                       label: GHC.Stats.max_slop_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIPh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIPi; else goto ccIPj;
       ccIPi: // global
           R2 = R2;
           R1 = GHC.Stats.max_slop_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIPj: // global
           I64[Sp - 8] = block_ccIPe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIPn; else goto ccIPf;
       ucIPn: // global
           call _ccIPe(R1) args: 0, res: 0, upd: 0;
       ccIPf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIPe() //  [R1]
         { info_tbl: [(ccIPe,
                       label: block_ccIPe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIPe: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.115504766 UTC

[section ""data" . GHC.Stats.max_compact_bytes_closure" {
     GHC.Stats.max_compact_bytes_closure:
         const GHC.Stats.max_compact_bytes_info;
 },
 GHC.Stats.max_compact_bytes_entry() //  [R2]
         { info_tbl: [(ccIPv,
                       label: GHC.Stats.max_compact_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIPv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIPw; else goto ccIPx;
       ccIPw: // global
           R2 = R2;
           R1 = GHC.Stats.max_compact_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIPx: // global
           I64[Sp - 8] = block_ccIPs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIPB; else goto ccIPt;
       ucIPB: // global
           call _ccIPs(R1) args: 0, res: 0, upd: 0;
       ccIPt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIPs() //  [R1]
         { info_tbl: [(ccIPs,
                       label: block_ccIPs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIPs: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.116679313 UTC

[section ""data" . GHC.Stats.max_large_objects_bytes_closure" {
     GHC.Stats.max_large_objects_bytes_closure:
         const GHC.Stats.max_large_objects_bytes_info;
 },
 GHC.Stats.max_large_objects_bytes_entry() //  [R2]
         { info_tbl: [(ccIPJ,
                       label: GHC.Stats.max_large_objects_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIPJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIPK; else goto ccIPL;
       ccIPK: // global
           R2 = R2;
           R1 = GHC.Stats.max_large_objects_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIPL: // global
           I64[Sp - 8] = block_ccIPG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIPP; else goto ccIPH;
       ucIPP: // global
           call _ccIPG(R1) args: 0, res: 0, upd: 0;
       ccIPH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIPG() //  [R1]
         { info_tbl: [(ccIPG,
                       label: block_ccIPG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIPG: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.117885435 UTC

[section ""data" . GHC.Stats.max_live_bytes_closure" {
     GHC.Stats.max_live_bytes_closure:
         const GHC.Stats.max_live_bytes_info;
 },
 GHC.Stats.max_live_bytes_entry() //  [R2]
         { info_tbl: [(ccIPX,
                       label: GHC.Stats.max_live_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIPX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIPY; else goto ccIPZ;
       ccIPY: // global
           R2 = R2;
           R1 = GHC.Stats.max_live_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIPZ: // global
           I64[Sp - 8] = block_ccIPU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIQ3; else goto ccIPV;
       ucIQ3: // global
           call _ccIPU(R1) args: 0, res: 0, upd: 0;
       ccIPV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIPU() //  [R1]
         { info_tbl: [(ccIPU,
                       label: block_ccIPU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIPU: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.119033304 UTC

[section ""data" . GHC.Stats.allocated_bytes_closure" {
     GHC.Stats.allocated_bytes_closure:
         const GHC.Stats.allocated_bytes_info;
 },
 GHC.Stats.allocated_bytes_entry() //  [R2]
         { info_tbl: [(ccIQb,
                       label: GHC.Stats.allocated_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIQb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIQc; else goto ccIQd;
       ccIQc: // global
           R2 = R2;
           R1 = GHC.Stats.allocated_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIQd: // global
           I64[Sp - 8] = block_ccIQ8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIQh; else goto ccIQ9;
       ucIQh: // global
           call _ccIQ8(R1) args: 0, res: 0, upd: 0;
       ccIQ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIQ8() //  [R1]
         { info_tbl: [(ccIQ8,
                       label: block_ccIQ8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIQ8: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.120196137 UTC

[section ""data" . GHC.Stats.major_gcs_closure" {
     GHC.Stats.major_gcs_closure:
         const GHC.Stats.major_gcs_info;
 },
 GHC.Stats.major_gcs_entry() //  [R2]
         { info_tbl: [(ccIQp,
                       label: GHC.Stats.major_gcs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIQp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIQq; else goto ccIQr;
       ccIQq: // global
           R2 = R2;
           R1 = GHC.Stats.major_gcs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIQr: // global
           I64[Sp - 8] = block_ccIQm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIQv; else goto ccIQn;
       ucIQv: // global
           call _ccIQm(R1) args: 0, res: 0, upd: 0;
       ccIQn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIQm() //  [R1]
         { info_tbl: [(ccIQm,
                       label: block_ccIQm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIQm: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.121371291 UTC

[section ""data" . GHC.Stats.gcs_closure" {
     GHC.Stats.gcs_closure:
         const GHC.Stats.gcs_info;
 },
 GHC.Stats.gcs_entry() //  [R2]
         { info_tbl: [(ccIQD,
                       label: GHC.Stats.gcs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIQD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIQE; else goto ccIQF;
       ccIQE: // global
           R2 = R2;
           R1 = GHC.Stats.gcs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccIQF: // global
           I64[Sp - 8] = block_ccIQA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucIQJ; else goto ccIQB;
       ucIQJ: // global
           call _ccIQA(R1) args: 0, res: 0, upd: 0;
       ccIQB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIQA() //  [R1]
         { info_tbl: [(ccIQA,
                       label: block_ccIQA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIQA: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.12234629 UTC

[section ""cstring" . GHC.Stats.$trModule4_bytes" {
     GHC.Stats.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.122942715 UTC

[section ""data" . GHC.Stats.$trModule3_closure" {
     GHC.Stats.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.123552564 UTC

[section ""cstring" . GHC.Stats.$trModule2_bytes" {
     GHC.Stats.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.124138409 UTC

[section ""data" . GHC.Stats.$trModule1_closure" {
     GHC.Stats.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.124718555 UTC

[section ""data" . GHC.Stats.$trModule_closure" {
     GHC.Stats.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Stats.$trModule3_closure+1;
         const GHC.Stats.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.125372645 UTC

[section ""data" . $krep_rcHrw_closure" {
     $krep_rcHrw_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt64_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.126021867 UTC

[section ""data" . $krep1_rcHrx_closure" {
     $krep1_rcHrx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.126661163 UTC

[section ""data" . $krep2_rcHry_closure" {
     $krep2_rcHry_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord32_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.127294488 UTC

[section ""data" . GHC.Stats.$tcGCDetails1_closure" {
     GHC.Stats.$tcGCDetails1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tcGCDetails2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.127917409 UTC

[section ""data" . GHC.Stats.$tcGCDetails_closure" {
     GHC.Stats.$tcGCDetails_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tcGCDetails1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1853976479346877039;
         const 12435514499433877542;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.129802618 UTC

[section ""data" . $krep3_rcHrz_closure" {
     $krep3_rcHrz_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Stats.$tcGCDetails_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.130397607 UTC

[section ""data" . $krep4_rcHrA_closure" {
     $krep4_rcHrA_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep3_rcHrz_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.130983474 UTC

[section ""data" . $krep5_rcHrB_closure" {
     $krep5_rcHrB_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep4_rcHrA_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.131569164 UTC

[section ""data" . $krep6_rcHrC_closure" {
     $krep6_rcHrC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep5_rcHrB_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.132187488 UTC

[section ""data" . $krep7_rcHrD_closure" {
     $krep7_rcHrD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep6_rcHrC_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.132748001 UTC

[section ""data" . $krep8_rcHrE_closure" {
     $krep8_rcHrE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep7_rcHrD_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.133410585 UTC

[section ""data" . $krep9_rcHrF_closure" {
     $krep9_rcHrF_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep8_rcHrE_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.133979952 UTC

[section ""data" . $krep10_rcHrG_closure" {
     $krep10_rcHrG_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep9_rcHrF_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.134526455 UTC

[section ""data" . $krep11_rcHrH_closure" {
     $krep11_rcHrH_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep10_rcHrG_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.135092246 UTC

[section ""data" . $krep12_rcHrI_closure" {
     $krep12_rcHrI_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep11_rcHrH_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.135680604 UTC

[section ""data" . $krep13_rcHrJ_closure" {
     $krep13_rcHrJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep12_rcHrI_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.136257437 UTC

[section ""data" . $krep14_rcHrK_closure" {
     $krep14_rcHrK_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep13_rcHrJ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.136824547 UTC

[section ""data" . $krep15_rcHrL_closure" {
     $krep15_rcHrL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep14_rcHrK_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.137509096 UTC

[section ""data" . $krep16_rcHrM_closure" {
     $krep16_rcHrM_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep15_rcHrL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.138099666 UTC

[section ""data" . GHC.Stats.$tc'GCDetails1_closure" {
     GHC.Stats.$tc'GCDetails1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep16_rcHrM_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.138671783 UTC

[section ""cstring" . GHC.Stats.$tc'GCDetails3_bytes" {
     GHC.Stats.$tc'GCDetails3_bytes:
         I8[] [39,71,67,68,101,116,97,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.139297477 UTC

[section ""data" . GHC.Stats.$tc'GCDetails2_closure" {
     GHC.Stats.$tc'GCDetails2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tc'GCDetails3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.13992226 UTC

[section ""data" . GHC.Stats.$tc'GCDetails_closure" {
     GHC.Stats.$tc'GCDetails_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tc'GCDetails2_closure+1;
         const GHC.Stats.$tc'GCDetails1_closure+4;
         const 5964953867232766897;
         const 8889994537819840032;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.140529899 UTC

[section ""data" . GHC.Stats.$tcRTSStats1_closure" {
     GHC.Stats.$tcRTSStats1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tcRTSStats2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.141111494 UTC

[section ""data" . GHC.Stats.$tcRTSStats_closure" {
     GHC.Stats.$tcRTSStats_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tcRTSStats1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1006825398788898151;
         const 9122067856566178937;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.141829182 UTC

[section ""data" . $krep17_rcHrN_closure" {
     $krep17_rcHrN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Stats.$tcRTSStats_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.142432198 UTC

[section ""data" . $krep18_rcHrO_closure" {
     $krep18_rcHrO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rcHrz_closure+1;
         const $krep17_rcHrN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.143011825 UTC

[section ""data" . $krep19_rcHrP_closure" {
     $krep19_rcHrP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep18_rcHrO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.143552792 UTC

[section ""data" . $krep20_rcHrQ_closure" {
     $krep20_rcHrQ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep19_rcHrP_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.144152502 UTC

[section ""data" . $krep21_rcHrR_closure" {
     $krep21_rcHrR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep20_rcHrQ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.14476051 UTC

[section ""data" . $krep22_rcHrS_closure" {
     $krep22_rcHrS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep21_rcHrR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.145695254 UTC

[section ""data" . $krep23_rcHrT_closure" {
     $krep23_rcHrT_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep22_rcHrS_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.14625975 UTC

[section ""data" . $krep24_rcHrU_closure" {
     $krep24_rcHrU_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep23_rcHrT_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.146792578 UTC

[section ""data" . $krep25_rcHrV_closure" {
     $krep25_rcHrV_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep24_rcHrU_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.147390512 UTC

[section ""data" . $krep26_rcHrW_closure" {
     $krep26_rcHrW_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep25_rcHrV_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.147994983 UTC

[section ""data" . $krep27_rcHrX_closure" {
     $krep27_rcHrX_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep26_rcHrW_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.148617099 UTC

[section ""data" . $krep28_rcHrY_closure" {
     $krep28_rcHrY_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep27_rcHrX_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.149278094 UTC

[section ""data" . $krep29_rcHrZ_closure" {
     $krep29_rcHrZ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep28_rcHrY_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.149860098 UTC

[section ""data" . $krep30_rcHs0_closure" {
     $krep30_rcHs0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep29_rcHrZ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.150477568 UTC

[section ""data" . $krep31_rcHs1_closure" {
     $krep31_rcHs1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep30_rcHs0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.151055861 UTC

[section ""data" . $krep32_rcHs2_closure" {
     $krep32_rcHs2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep31_rcHs1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.151691699 UTC

[section ""data" . $krep33_rcHs3_closure" {
     $krep33_rcHs3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep32_rcHs2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.152342172 UTC

[section ""data" . $krep34_rcHs4_closure" {
     $krep34_rcHs4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep33_rcHs3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.152972846 UTC

[section ""data" . $krep35_rcHs5_closure" {
     $krep35_rcHs5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep34_rcHs4_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.153658086 UTC

[section ""data" . $krep36_rcHs6_closure" {
     $krep36_rcHs6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep35_rcHs5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.154266127 UTC

[section ""data" . GHC.Stats.$tc'RTSStats1_closure" {
     GHC.Stats.$tc'RTSStats1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep36_rcHs6_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.154917595 UTC

[section ""cstring" . GHC.Stats.$tc'RTSStats3_bytes" {
     GHC.Stats.$tc'RTSStats3_bytes:
         I8[] [39,82,84,83,83,116,97,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.156299813 UTC

[section ""data" . GHC.Stats.$tc'RTSStats2_closure" {
     GHC.Stats.$tc'RTSStats2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tc'RTSStats3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.156911314 UTC

[section ""data" . GHC.Stats.$tc'RTSStats_closure" {
     GHC.Stats.$tc'RTSStats_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tc'RTSStats2_closure+1;
         const GHC.Stats.$tc'RTSStats1_closure+4;
         const 10718900236833312508;
         const 16334729378492634062;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.158752233 UTC

[section ""data" . getRTSStatsEnabled1_rcHs7_closure" {
     getRTSStatsEnabled1_rcHs7_closure:
         const getRTSStatsEnabled1_rcHs7_info;
 },
 sat_scHNr_entry() //  [R1]
         { info_tbl: [(ccIQZ,
                       label: sat_scHNr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIQZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIR0; else goto ccIR1;
       ccIR0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIR1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto ccIQY; else goto ccIQX;
       ccIQY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccIQX: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 getRTSStatsEnabled1_rcHs7_entry() //  []
         { info_tbl: [(ccIR2,
                       label: getRTSStatsEnabled1_rcHs7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIR2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccIR3; else goto ccIR4;
       ccIR3: // global
           R1 = getRTSStatsEnabled1_rcHs7_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccIR4: // global
           I64[Sp - 8] = block_ccIQP_info;
           Sp = Sp - 8;
           _ucIRa::P64 = CurrentTSO;
           I64[I64[_ucIRa::P64 + 24] + 16] = Sp;
           _ucIRb::I64 = CurrentNursery;
           P64[_ucIRb::I64 + 8] = Hp + 8;
           I64[_ucIRa::P64 + 104] = I64[_ucIRa::P64 + 104] - ((Hp + 8) - I64[_ucIRb::I64]);
           (_ucIR8::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_scHNp::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] getRTSStatsEnabled();
           (_ucIR9::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ucIR8::I64);
           BaseReg = _ucIR9::I64;
           _ucIRc::P64 = CurrentTSO;
           _ucIRd::P64 = I64[_ucIRc::P64 + 24];
           Sp = I64[_ucIRd::P64 + 16];
           SpLim = _ucIRd::P64 + 192;
           HpAlloc = 0;
           _ucIRe::I64 = CurrentNursery;
           _ucIRf::I64 = I64[_ucIRe::I64 + 8];
           Hp = _ucIRf::I64 - 8;
           _ucIRg::I64 = I64[_ucIRe::I64];
           HpLim = _ucIRg::I64 + ((%MO_SS_Conv_W32_W64(I32[_ucIRe::I64 + 48]) << 12) - 1);
           I64[_ucIRc::P64 + 104] = I64[_ucIRc::P64 + 104] + (_ucIRf::I64 - _ucIRg::I64);
           R1 = _scHNp::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIQP() //  [R1]
         { info_tbl: [(ccIQP,
                       label: block_ccIQP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIQP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccIR7; else goto ccIR6;
       ccIR7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccIR6: // global
           I64[Hp - 16] = sat_scHNr_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.160547635 UTC

[section ""data" . GHC.Stats.getRTSStatsEnabled_closure" {
     GHC.Stats.getRTSStatsEnabled_closure:
         const GHC.Stats.getRTSStatsEnabled_info;
 },
 GHC.Stats.getRTSStatsEnabled_entry() //  []
         { info_tbl: [(ccIRm,
                       label: GHC.Stats.getRTSStatsEnabled_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIRm: // global
           call getRTSStatsEnabled1_rcHs7_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.161206348 UTC

[section ""cstring" . GHC.Stats.getRTSStats5_bytes" {
     GHC.Stats.getRTSStats5_bytes:
         I8[] [71,72,67,46,83,116,97,116,115,46,103,101,116,82,84,83,83,116,97,116,115,58,32,71,67,32,115,116,97,116,115,32,110,111,116,32,101,110,97,98,108,101,100,46,32,85,115,101,32,96,43,82,84,83,32,45,84,32,45,82,84,83,39,32,116,111,32,101,110,97,98,108,101,32,116,104,101,109,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.162011068 UTC

[section ""data" . GHC.Stats.getRTSStats4_closure" {
     GHC.Stats.getRTSStats4_closure:
         const GHC.Stats.getRTSStats4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.getRTSStats4_entry() //  [R1]
         { info_tbl: [(ccIRv,
                       label: GHC.Stats.getRTSStats4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIRv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIRw; else goto ccIRx;
       ccIRw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIRx: // global
           (_ccIRs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIRs::I64 == 0) goto ccIRu; else goto ccIRt;
       ccIRu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIRt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIRs::I64;
           R2 = GHC.Stats.getRTSStats5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.162907601 UTC

[section ""data" . GHC.Stats.getRTSStats3_closure" {
     GHC.Stats.getRTSStats3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UnsupportedOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Stats.getRTSStats4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.163686952 UTC

[section ""data" . GHC.Stats.getRTSStats2_closure" {
     GHC.Stats.getRTSStats2_closure:
         const GHC.Stats.getRTSStats2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.getRTSStats2_entry() //  [R1]
         { info_tbl: [(ccIRE,
                       label: GHC.Stats.getRTSStats2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIRE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccIRF; else goto ccIRG;
       ccIRF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIRG: // global
           (_ccIRB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccIRB::I64 == 0) goto ccIRD; else goto ccIRC;
       ccIRD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccIRC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccIRB::I64;
           R2 = GHC.Stats.getRTSStats3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.166889009 UTC

[section ""data" . GHC.Stats.getRTSStats1_closure" {
     GHC.Stats.getRTSStats1_closure:
         const GHC.Stats.getRTSStats1_info;
         const 0;
 },
 GHC.Stats.getRTSStats1_entry() //  []
         { info_tbl: [(ccIRS,
                       label: GHC.Stats.getRTSStats1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIRS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccIRT; else goto ccIRU;
       ccIRT: // global
           R1 = GHC.Stats.getRTSStats1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccIRU: // global
           I64[Sp - 8] = block_ccIRM_info;
           Sp = Sp - 8;
           _ucIUk::P64 = CurrentTSO;
           I64[I64[_ucIUk::P64 + 24] + 16] = Sp;
           _ucIUl::I64 = CurrentNursery;
           P64[_ucIUl::I64 + 8] = Hp + 8;
           I64[_ucIUk::P64 + 104] = I64[_ucIUk::P64 + 104] - ((Hp + 8) - I64[_ucIUl::I64]);
           (_ucIUi::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_scHNw::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] getRTSStatsEnabled();
           (_ucIUj::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ucIUi::I64);
           BaseReg = _ucIUj::I64;
           _ucIUm::P64 = CurrentTSO;
           _ucIUn::P64 = I64[_ucIUm::P64 + 24];
           Sp = I64[_ucIUn::P64 + 16];
           SpLim = _ucIUn::P64 + 192;
           HpAlloc = 0;
           _ucIUo::I64 = CurrentNursery;
           _ucIUp::I64 = I64[_ucIUo::I64 + 8];
           Hp = _ucIUp::I64 - 8;
           _ucIUq::I64 = I64[_ucIUo::I64];
           HpLim = _ucIUq::I64 + ((%MO_SS_Conv_W32_W64(I32[_ucIUo::I64 + 48]) << 12) - 1);
           I64[_ucIUm::P64 + 104] = I64[_ucIUm::P64 + 104] + (_ucIUp::I64 - _ucIUq::I64);
           R1 = _scHNw::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIRM() //  [R1]
         { info_tbl: [(ccIRM,
                       label: block_ccIRM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIRM: // global
           if (R1 == 0) goto ccIRR; else goto ccIRQ;
       ccIRR: // global
           R1 = GHC.Stats.getRTSStats2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ccIRQ: // global
           I64[Sp] = block_ccIRX_info;
           R1 = 248;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIRX() //  [R1]
         { info_tbl: [(ccIRX,
                       label: block_ccIRX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIRX: // global
           I64[Sp - 16] = block_ccIS4_info;
           _scHNE::I64 = R1 + 16;
           I64[Sp - 8] = _scHNE::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           _ucIUu::P64 = CurrentTSO;
           I64[I64[_ucIUu::P64 + 24] + 16] = Sp;
           _ucIUv::I64 = CurrentNursery;
           P64[_ucIUv::I64 + 8] = Hp + 8;
           I64[_ucIUu::P64 + 104] = I64[_ucIUu::P64 + 104] - ((Hp + 8) - I64[_ucIUv::I64]);
           (_ucIUs::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] getRTSStats(_scHNE::I64);
           (_ucIUt::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ucIUs::I64);
           BaseReg = _ucIUt::I64;
           _ucIUw::P64 = CurrentTSO;
           _ucIUx::P64 = I64[_ucIUw::P64 + 24];
           Sp = I64[_ucIUx::P64 + 16];
           SpLim = _ucIUx::P64 + 192;
           HpAlloc = 0;
           _ucIUy::I64 = CurrentNursery;
           _ucIUz::I64 = I64[_ucIUy::I64 + 8];
           Hp = _ucIUz::I64 - 8;
           _ucIUA::I64 = I64[_ucIUy::I64];
           HpLim = _ucIUA::I64 + ((%MO_SS_Conv_W32_W64(I32[_ucIUy::I64 + 48]) << 12) - 1);
           I64[_ucIUw::P64 + 104] = I64[_ucIUw::P64 + 104] + (_ucIUz::I64 - _ucIUA::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _ccIS4() //  []
         { info_tbl: [(ccIS4,
                       label: block_ccIS4_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIS4: // global
           Hp = Hp + 816;
           if (Hp > HpLim) (likely: False) goto ccIUh; else goto ccIUg;
       ccIUh: // global
           HpAlloc = 816;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccIUg: // global
           _scHNE::I64 = I64[Sp + 8];
           _scHNK::I64 = %MO_UU_Conv_W32_W64(I32[_scHNE::I64]);
           _scHNO::I64 = %MO_UU_Conv_W32_W64(I32[_scHNE::I64 + 4]);
           _scHNS::I64 = I64[_scHNE::I64 + 8];
           _scHNW::I64 = I64[_scHNE::I64 + 16];
           _scHO0::I64 = I64[_scHNE::I64 + 24];
           _scHO4::I64 = I64[_scHNE::I64 + 32];
           _scHO8::I64 = I64[_scHNE::I64 + 40];
           _scHOc::I64 = I64[_scHNE::I64 + 48];
           _scHOg::I64 = I64[_scHNE::I64 + 56];
           _scHOk::I64 = I64[_scHNE::I64 + 64];
           _scHOo::I64 = I64[_scHNE::I64 + 72];
           _scHOs::I64 = I64[_scHNE::I64 + 80];
           _scHOw::I64 = I64[_scHNE::I64 + 88];
           _scHOA::I64 = I64[_scHNE::I64 + 96];
           _scHOE::I64 = I64[_scHNE::I64 + 104];
           _scHOI::I64 = I64[_scHNE::I64 + 112];
           _scHOM::I64 = I64[_scHNE::I64 + 120];
           _scHOQ::I64 = I64[_scHNE::I64 + 128];
           _scHOU::I64 = I64[_scHNE::I64 + 136];
           _scHOV::I64 = _scHNE::I64 + 144;
           _scHOY::I64 = %MO_UU_Conv_W32_W64(I32[_scHOV::I64]);
           _scHP2::I64 = %MO_UU_Conv_W32_W64(I32[_scHOV::I64 + 4]);
           _scHP6::I64 = I64[_scHOV::I64 + 8];
           _scHPa::I64 = I64[_scHOV::I64 + 16];
           _scHPe::I64 = I64[_scHOV::I64 + 24];
           _scHPi::I64 = I64[_scHOV::I64 + 32];
           _scHPm::I64 = I64[_scHOV::I64 + 40];
           _scHPq::I64 = I64[_scHOV::I64 + 48];
           _scHPu::I64 = I64[_scHOV::I64 + 56];
           _scHPy::I64 = I64[_scHOV::I64 + 64];
           _scHPC::I64 = I64[_scHOV::I64 + 72];
           _scHPG::I64 = I64[_scHOV::I64 + 80];
           _scHPK::I64 = I64[_scHOV::I64 + 88];
           _scHPO::I64 = I64[_scHOV::I64 + 96];
           call MO_Touch(P64[Sp + 16]);
           I64[Hp - 808] = GHC.Int.I64#_con_info;
           I64[Hp - 800] = _scHPO::I64;
           I64[Hp - 792] = GHC.Int.I64#_con_info;
           I64[Hp - 784] = _scHPK::I64;
           I64[Hp - 776] = GHC.Int.I64#_con_info;
           I64[Hp - 768] = _scHPG::I64;
           I64[Hp - 760] = GHC.Word.W64#_con_info;
           I64[Hp - 752] = _scHPC::I64;
           I64[Hp - 744] = GHC.Word.W64#_con_info;
           I64[Hp - 736] = _scHPy::I64;
           I64[Hp - 728] = GHC.Word.W64#_con_info;
           I64[Hp - 720] = _scHPu::I64;
           I64[Hp - 712] = GHC.Word.W64#_con_info;
           I64[Hp - 704] = _scHPq::I64;
           I64[Hp - 696] = GHC.Word.W64#_con_info;
           I64[Hp - 688] = _scHPm::I64;
           I64[Hp - 680] = GHC.Word.W64#_con_info;
           I64[Hp - 672] = _scHPi::I64;
           I64[Hp - 664] = GHC.Word.W64#_con_info;
           I64[Hp - 656] = _scHPe::I64;
           I64[Hp - 648] = GHC.Word.W64#_con_info;
           I64[Hp - 640] = _scHPa::I64;
           I64[Hp - 632] = GHC.Word.W64#_con_info;
           I64[Hp - 624] = _scHP6::I64;
           I64[Hp - 616] = GHC.Word.W32#_con_info;
           I64[Hp - 608] = _scHP2::I64;
           I64[Hp - 600] = GHC.Word.W32#_con_info;
           I64[Hp - 592] = _scHOY::I64;
           I64[Hp - 584] = GHC.Stats.GCDetails_con_info;
           P64[Hp - 576] = Hp - 599;
           P64[Hp - 568] = Hp - 615;
           P64[Hp - 560] = Hp - 631;
           P64[Hp - 552] = Hp - 647;
           P64[Hp - 544] = Hp - 663;
           P64[Hp - 536] = Hp - 679;
           P64[Hp - 528] = Hp - 695;
           P64[Hp - 520] = Hp - 711;
           P64[Hp - 512] = Hp - 727;
           P64[Hp - 504] = Hp - 743;
           P64[Hp - 496] = Hp - 759;
           P64[Hp - 488] = Hp - 775;
           P64[Hp - 480] = Hp - 791;
           P64[Hp - 472] = Hp - 807;
           I64[Hp - 464] = GHC.Int.I64#_con_info;
           I64[Hp - 456] = _scHOU::I64;
           I64[Hp - 448] = GHC.Int.I64#_con_info;
           I64[Hp - 440] = _scHOQ::I64;
           I64[Hp - 432] = GHC.Int.I64#_con_info;
           I64[Hp - 424] = _scHOM::I64;
           I64[Hp - 416] = GHC.Int.I64#_con_info;
           I64[Hp - 408] = _scHOI::I64;
           I64[Hp - 400] = GHC.Int.I64#_con_info;
           I64[Hp - 392] = _scHOE::I64;
           I64[Hp - 384] = GHC.Int.I64#_con_info;
           I64[Hp - 376] = _scHOA::I64;
           I64[Hp - 368] = GHC.Word.W64#_con_info;
           I64[Hp - 360] = _scHOw::I64;
           I64[Hp - 352] = GHC.Word.W64#_con_info;
           I64[Hp - 344] = _scHOs::I64;
           I64[Hp - 336] = GHC.Word.W64#_con_info;
           I64[Hp - 328] = _scHOo::I64;
           I64[Hp - 320] = GHC.Word.W64#_con_info;
           I64[Hp - 312] = _scHOk::I64;
           I64[Hp - 304] = GHC.Word.W64#_con_info;
           I64[Hp - 296] = _scHOg::I64;
           I64[Hp - 288] = GHC.Word.W64#_con_info;
           I64[Hp - 280] = _scHOc::I64;
           I64[Hp - 272] = GHC.Word.W64#_con_info;
           I64[Hp - 264] = _scHO8::I64;
           I64[Hp - 256] = GHC.Word.W64#_con_info;
           I64[Hp - 248] = _scHO4::I64;
           I64[Hp - 240] = GHC.Word.W64#_con_info;
           I64[Hp - 232] = _scHO0::I64;
           I64[Hp - 224] = GHC.Word.W64#_con_info;
           I64[Hp - 216] = _scHNW::I64;
           I64[Hp - 208] = GHC.Word.W64#_con_info;
           I64[Hp - 200] = _scHNS::I64;
           I64[Hp - 192] = GHC.Word.W32#_con_info;
           I64[Hp - 184] = _scHNO::I64;
           I64[Hp - 176] = GHC.Word.W32#_con_info;
           I64[Hp - 168] = _scHNK::I64;
           I64[Hp - 160] = GHC.Stats.RTSStats_con_info;
           P64[Hp - 152] = Hp - 175;
           P64[Hp - 144] = Hp - 191;
           P64[Hp - 136] = Hp - 207;
           P64[Hp - 128] = Hp - 223;
           P64[Hp - 120] = Hp - 239;
           P64[Hp - 112] = Hp - 255;
           P64[Hp - 104] = Hp - 271;
           P64[Hp - 96] = Hp - 287;
           P64[Hp - 88] = Hp - 303;
           P64[Hp - 80] = Hp - 319;
           P64[Hp - 72] = Hp - 335;
           P64[Hp - 64] = Hp - 351;
           P64[Hp - 56] = Hp - 367;
           P64[Hp - 48] = Hp - 383;
           P64[Hp - 40] = Hp - 399;
           P64[Hp - 32] = Hp - 415;
           P64[Hp - 24] = Hp - 431;
           P64[Hp - 16] = Hp - 447;
           P64[Hp - 8] = Hp - 463;
           P64[Hp] = Hp - 583;
           R1 = Hp - 159;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.171283467 UTC

[section ""data" . GHC.Stats.getRTSStats_closure" {
     GHC.Stats.getRTSStats_closure:
         const GHC.Stats.getRTSStats_info;
         const 0;
 },
 GHC.Stats.getRTSStats_entry() //  []
         { info_tbl: [(ccIUG,
                       label: GHC.Stats.getRTSStats_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIUG: // global
           call GHC.Stats.getRTSStats1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.172532264 UTC

[section ""data" . GHC.Stats.GCDetails_closure" {
     GHC.Stats.GCDetails_closure:
         const GHC.Stats.GCDetails_info;
 },
 GHC.Stats.GCDetails_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIUK: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Stats.GCDetails_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 80, res: 0, upd: 8;
     }
 },
 GHC.Stats.GCDetails_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccIUP,
                       label: GHC.Stats.GCDetails_info
                       rep:HeapRep static {
                             Fun {arity: 14
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIUP: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccIUT; else goto ccIUS;
       ccIUT: // global
           HpAlloc = 120;
           R1 = GHC.Stats.GCDetails_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 120, res: 0, upd: 8;
       ccIUS: // global
           I64[Hp - 112] = GHC.Stats.GCDetails_con_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           P64[Hp - 88] = R4;
           P64[Hp - 80] = R5;
           P64[Hp - 72] = R6;
           P64[Hp - 64] = P64[Sp];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = P64[Sp + 56];
           P64[Hp] = P64[Sp + 64];
           R1 = Hp - 111;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.17439688 UTC

[section ""data" . GHC.Stats.RTSStats_closure" {
     GHC.Stats.RTSStats_closure:
         const GHC.Stats.RTSStats_info;
 },
 GHC.Stats.RTSStats_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIUV: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Stats.RTSStats_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2,
                                         R1) args: 128, res: 0, upd: 8;
     }
 },
 GHC.Stats.RTSStats_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccIV0,
                       label: GHC.Stats.RTSStats_info
                       rep:HeapRep static {
                             Fun {arity: 20
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIV0: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccIV4; else goto ccIV3;
       ccIV4: // global
           HpAlloc = 168;
           R1 = GHC.Stats.RTSStats_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 168, res: 0, upd: 8;
       ccIV3: // global
           I64[Hp - 160] = GHC.Stats.RTSStats_con_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           P64[Hp - 136] = R4;
           P64[Hp - 128] = R5;
           P64[Hp - 120] = R6;
           P64[Hp - 112] = P64[Sp];
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = P64[Sp + 16];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = P64[Sp + 56];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = P64[Sp + 72];
           P64[Hp - 32] = P64[Sp + 80];
           P64[Hp - 24] = P64[Sp + 88];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 159;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.175823792 UTC

[GHC.Stats.GCDetails_con_entry() //  [R1]
         { info_tbl: [(ccIV5,
                       label: GHC.Stats.GCDetails_con_info
                       rep:HeapRep 14 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,115,46,71,67,68,101,116,97,105,108,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIV5: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.176546405 UTC

[GHC.Stats.RTSStats_con_entry() //  [R1]
         { info_tbl: [(ccIV6,
                       label: GHC.Stats.RTSStats_con_info
                       rep:HeapRep 20 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,115,46,82,84,83,83,116,97,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIV6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.17723649 UTC

[section ""relreadonly" . ScI2G_srt" {
     ScI2G_srt:
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Stats.$fShowGCDetails_$cshowsPrec_closure;
         const GHC.Stats.$fShowGCDetails_$cshow_closure;
         const GHC.Stats.$fShowGCDetails1_closure;
         const GHC.Stats.$fShowRTSStats_$cshowsPrec_closure;
         const GHC.Stats.$fShowRTSStats_$cshow_closure;
         const GHC.Stats.$fShowRTSStats1_closure;
         const GHC.Read.$fReadWord32_$creadsPrec_closure;
         const lvl37_rcHqd_closure;
         const ds2_rcHqe_closure;
         const GHC.Read.$fReadWord64_$creadsPrec_closure;
         const lvl45_rcHqn_closure;
         const lvl46_rcHqo_closure;
         const GHC.Int.$fReadInt64_$creadsPrec_closure;
         const lvl65_rcHqH_closure;
         const lvl66_rcHqI_closure;
         const Text.Read.Lex.$wexpect_closure;
         const lvl72_rcHqO_closure;
         const GHC.Read.readField_closure;
         const lvl70_rcHqM_closure;
         const lvl40_rcHqi_closure;
         const lvl68_rcHqK_closure;
         const lvl64_rcHqG_closure;
         const lvl62_rcHqE_closure;
         const lvl60_rcHqC_closure;
         const lvl58_rcHqA_closure;
         const lvl56_rcHqy_closure;
         const lvl54_rcHqw_closure;
         const lvl52_rcHqu_closure;
         const lvl50_rcHqs_closure;
         const lvl48_rcHqq_closure;
         const lvl44_rcHqm_closure;
         const lvl42_rcHqk_closure;
         const ds1_rcHqc_closure;
         const lexeme4_rcHqa_closure;
         const GHC.Stats.$w$creadPrec_closure;
         const lexeme1_rcHq7_closure;
         const GHC.Stats.$fReadGCDetails2_closure;
         const GHC.Read.list3_closure;
         const GHC.Stats.$fReadGCDetails_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.Stats.$fReadGCDetails1_closure;
         const GHC.Stats.$fReadGCDetails_$creadListPrec_closure;
         const GHC.Stats.$fReadGCDetails3_closure;
         const lvl110_rcHru_closure;
         const lvl111_rcHrv_closure;
         const lvl108_rcHrs_closure;
         const lvl106_rcHrq_closure;
         const lvl104_rcHro_closure;
         const lvl102_rcHrm_closure;
         const lvl100_rcHrk_closure;
         const lvl98_rcHri_closure;
         const lvl96_rcHrg_closure;
         const lvl94_rcHre_closure;
         const lvl92_rcHrc_closure;
         const lvl90_rcHra_closure;
         const lvl88_rcHr8_closure;
         const lvl86_rcHr6_closure;
         const lvl84_rcHr4_closure;
         const lvl82_rcHr2_closure;
         const lvl80_rcHr0_closure;
         const lvl78_rcHqY_closure;
         const lvl76_rcHqW_closure;
         const lvl74_rcHqU_closure;
         const ds4_rcHqS_closure;
         const GHC.Stats.$w$creadPrec1_closure;
         const lexeme6_rcHqQ_closure;
         const GHC.Stats.$fReadRTSStats2_closure;
         const GHC.Stats.$fReadRTSStats_$creadsPrec_closure;
         const GHC.Stats.$fReadRTSStats1_closure;
         const GHC.Stats.$fReadRTSStats_$creadListPrec_closure;
         const GHC.Stats.$fReadRTSStats3_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.Stats.getRTSStats3_closure;
         const GHC.Stats.getRTSStats1_closure;
         const GHC.Stats.getRTSStats2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.178265286 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:36.178848543 UTC

[section ""cstring" . lvl_rcHpv_bytes" {
     lvl_rcHpv_bytes:
         I8[] [71,67,68,101,116,97,105,108,115,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.179457793 UTC

[section ""cstring" . lvl1_rcHpw_bytes" {
     lvl1_rcHpw_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,103,101,110,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.180060226 UTC

[section ""cstring" . lvl2_rcHpx_bytes" {
     lvl2_rcHpx_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,116,104,114,101,97,100,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.18064038 UTC

[section ""cstring" . lvl3_rcHpy_bytes" {
     lvl3_rcHpy_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,97,108,108,111,99,97,116,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.181210432 UTC

[section ""cstring" . lvl4_rcHpz_bytes" {
     lvl4_rcHpz_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,105,118,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.181791309 UTC

[section ""cstring" . lvl5_rcHpA_bytes" {
     lvl5_rcHpA_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.182369434 UTC

[section ""cstring" . lvl6_rcHpB_bytes" {
     lvl6_rcHpB_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,109,112,97,99,116,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.182963512 UTC

[section ""cstring" . lvl7_rcHpC_bytes" {
     lvl7_rcHpC_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,108,111,112,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.183579355 UTC

[section ""cstring" . lvl8_rcHpD_bytes" {
     lvl8_rcHpD_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.184145239 UTC

[section ""cstring" . lvl9_rcHpE_bytes" {
     lvl9_rcHpE_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.184740089 UTC

[section ""cstring" . lvl10_rcHpF_bytes" {
     lvl10_rcHpF_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.185539859 UTC

[section ""cstring" . lvl11_rcHpG_bytes" {
     lvl11_rcHpG_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.186100321 UTC

[section ""cstring" . lvl12_rcHpH_bytes" {
     lvl12_rcHpH_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,121,110,99,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.186682903 UTC

[section ""cstring" . lvl13_rcHpI_bytes" {
     lvl13_rcHpI_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.187289883 UTC

[section ""cstring" . lvl14_rcHpJ_bytes" {
     lvl14_rcHpJ_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.188794091 UTC

[section ""cstring" . lvl15_rcHpK_bytes" {
     lvl15_rcHpK_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.203921385 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_$cshowsPrec_closure" {
     GHC.Stats.$fShowGCDetails_$cshowsPrec_closure:
         const GHC.Stats.$fShowGCDetails_$cshowsPrec_info;
         const 0;
 },
 w1_scHss_entry() //  [R1]
         { info_tbl: [(ccIVs,
                       label: w1_scHss_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIVs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccIVt; else goto ccIVu;
       ccIVt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIVu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccIVp_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucIVG; else goto ccIVq;
       ucIVG: // global
           call _ccIVp(R1) args: 0, res: 0, upd: 0;
       ccIVq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIVp() //  [R1]
         { info_tbl: [(ccIVp,
                       label: block_ccIVp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIVp: // global
           _scHsu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsu::I64, 0)) goto ccIVE; else goto ccIVF;
       ccIVE: // global
           R2 = _scHsu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccIVF: // global
           R2 = _scHsu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w2_scHsx_entry() //  [R1]
         { info_tbl: [(ccIVO,
                       label: w2_scHsx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIVO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccIVP; else goto ccIVQ;
       ccIVP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIVQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccIVL_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucIW2; else goto ccIVM;
       ucIW2: // global
           call _ccIVL(R1) args: 0, res: 0, upd: 0;
       ccIVM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIVL() //  [R1]
         { info_tbl: [(ccIVL,
                       label: block_ccIVL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIVL: // global
           _scHsz::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsz::I64, 0)) goto ccIW0; else goto ccIW1;
       ccIW0: // global
           R2 = _scHsz::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccIW1: // global
           R2 = _scHsz::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w3_scHsC_entry() //  [R1]
         { info_tbl: [(ccIWa,
                       label: w3_scHsC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIWa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccIWb; else goto ccIWc;
       ccIWb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIWc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccIW7_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucIWo; else goto ccIW8;
       ucIWo: // global
           call _ccIW7(R1) args: 0, res: 0, upd: 0;
       ccIW8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIW7() //  [R1]
         { info_tbl: [(ccIW7,
                       label: block_ccIW7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIW7: // global
           _scHsE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsE::I64, 0)) goto ccIWm; else goto ccIWn;
       ccIWm: // global
           R2 = _scHsE::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccIWn: // global
           R2 = _scHsE::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w4_scHsH_entry() //  [R1]
         { info_tbl: [(ccIWw,
                       label: w4_scHsH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIWw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccIWx; else goto ccIWy;
       ccIWx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIWy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccIWt_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucIWK; else goto ccIWu;
       ucIWK: // global
           call _ccIWt(R1) args: 0, res: 0, upd: 0;
       ccIWu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIWt() //  [R1]
         { info_tbl: [(ccIWt,
                       label: block_ccIWt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIWt: // global
           _scHsJ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsJ::I64, 0)) goto ccIWI; else goto ccIWJ;
       ccIWI: // global
           R2 = _scHsJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccIWJ: // global
           R2 = _scHsJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_scHsM_entry() //  [R1]
         { info_tbl: [(ccIWS,
                       label: w5_scHsM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIWS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccIWT; else goto ccIWU;
       ccIWT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIWU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccIWP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucIX6; else goto ccIWQ;
       ucIX6: // global
           call _ccIWP(R1) args: 0, res: 0, upd: 0;
       ccIWQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIWP() //  [R1]
         { info_tbl: [(ccIWP,
                       label: block_ccIWP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIWP: // global
           _scHsO::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsO::I64, 0)) goto ccIX4; else goto ccIX5;
       ccIX4: // global
           R2 = _scHsO::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccIX5: // global
           R2 = _scHsO::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_scHsR_entry() //  [R1]
         { info_tbl: [(ccIXe,
                       label: w6_scHsR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIXe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccIXf; else goto ccIXg;
       ccIXf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIXg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccIXb_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucIXs; else goto ccIXc;
       ucIXs: // global
           call _ccIXb(R1) args: 0, res: 0, upd: 0;
       ccIXc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIXb() //  [R1]
         { info_tbl: [(ccIXb,
                       label: block_ccIXb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIXb: // global
           _scHsT::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsT::I64, 0)) goto ccIXq; else goto ccIXr;
       ccIXq: // global
           R2 = _scHsT::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccIXr: // global
           R2 = _scHsT::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_scHsW_entry() //  [R1]
         { info_tbl: [(ccIXA,
                       label: w7_scHsW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIXA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccIXB; else goto ccIXC;
       ccIXB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIXC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccIXx_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucIXO; else goto ccIXy;
       ucIXO: // global
           call _ccIXx(R1) args: 0, res: 0, upd: 0;
       ccIXy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIXx() //  [R1]
         { info_tbl: [(ccIXx,
                       label: block_ccIXx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIXx: // global
           _scHsY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsY::I64, 0)) goto ccIXM; else goto ccIXN;
       ccIXM: // global
           R2 = _scHsY::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccIXN: // global
           R2 = _scHsY::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w8_scHt1_entry() //  [R1]
         { info_tbl: [(ccIXW,
                       label: w8_scHt1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIXW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccIXX; else goto ccIXY;
       ccIXX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIXY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccIXT_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucIYa; else goto ccIXU;
       ucIYa: // global
           call _ccIXT(R1) args: 0, res: 0, upd: 0;
       ccIXU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIXT() //  [R1]
         { info_tbl: [(ccIXT,
                       label: block_ccIXT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIXT: // global
           _scHt3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHt3::I64, 0)) goto ccIY8; else goto ccIY9;
       ccIY8: // global
           R2 = _scHt3::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccIY9: // global
           R2 = _scHt3::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w9_scHt6_entry() //  [R1]
         { info_tbl: [(ccIYi,
                       label: w9_scHt6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIYi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccIYj; else goto ccIYk;
       ccIYj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccIYk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccIYf_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucIYw; else goto ccIYg;
       ucIYw: // global
           call _ccIYf(R1) args: 0, res: 0, upd: 0;
       ccIYg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIYf() //  [R1]
         { info_tbl: [(ccIYf,
                       label: block_ccIYf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIYf: // global
           _scHt8::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHt8::I64, 0)) goto ccIYu; else goto ccIYv;
       ccIYu: // global
           R2 = _scHt8::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccIYv: // global
           R2 = _scHt8::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtp_entry() //  [R1]
         { info_tbl: [(ccJ1J,
                       label: sat_scHtp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ1J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ1K; else goto ccJ1L;
       ccJ1K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ1L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = lvl15_rcHpK_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtt_entry() //  [R1]
         { info_tbl: [(ccJ1M,
                       label: sat_scHtt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ1M: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccJ1Q; else goto ccJ1R;
       ccJ1Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ1R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccJ1A_info;
           _scHtc::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucJ1Y; else goto ccJ1B;
       ucJ1Y: // global
           call _ccJ1A(R1) args: 0, res: 0, upd: 0;
       ccJ1B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ1A() //  [R1]
         { info_tbl: [(ccJ1A,
                       label: block_ccJ1A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ1A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ1U; else goto ccJ1T;
       ccJ1U: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccJ1T: // global
           _scHto::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_scHtp_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccJ1N_info;
           R4 = Hp - 16;
           R3 = _scHto::I64;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ1N() //  [R1, R2]
         { info_tbl: [(ccJ1N,
                       label: block_ccJ1N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ1N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ1X; else goto ccJ1W;
       ccJ1X: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ1W: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtu_entry() //  [R1]
         { info_tbl: [(ccJ1Z,
                       label: sat_scHtu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ1Z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccJ23; else goto ccJ22;
       ccJ23: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ22: // global
           _scHsp::P64 = P64[R1 + 16];
           _scHtc::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_scHtt_info;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 24;
           R2 = lvl14_rcHpJ_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtv_entry() //  [R1]
         { info_tbl: [(ccJ24,
                       label: sat_scHtv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ24: // global
           _scHtv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ25; else goto ccJ26;
       ccJ26: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccJ28; else goto ccJ27;
       ccJ28: // global
           HpAlloc = 32;
           goto ccJ25;
       ccJ25: // global
           R1 = _scHtv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ27: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtv::P64;
           _scHsp::P64 = P64[_scHtv::P64 + 16];
           _scHtc::P64 = P64[_scHtv::P64 + 24];
           I64[Hp - 24] = sat_scHtu_info;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtz_entry() //  [R1]
         { info_tbl: [(ccJ29,
                       label: sat_scHtz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ29: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccJ2d; else goto ccJ2e;
       ccJ2d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ2e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccJ1j_info;
           _scHsp::P64 = P64[R1 + 24];
           _scHtc::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _scHsp::P64;
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucJ2l; else goto ccJ1k;
       ucJ2l: // global
           call _ccJ1j(R1) args: 0, res: 0, upd: 0;
       ccJ1k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ1j() //  [R1]
         { info_tbl: [(ccJ1j,
                       label: block_ccJ1j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ1j: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccJ2h; else goto ccJ2g;
       ccJ2h: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccJ2g: // global
           _scHtm::I64 = I64[R1 + 7];
           I64[Hp - 24] = sat_scHtv_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_ccJ2a_info;
           R4 = Hp - 24;
           R3 = _scHtm::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ2a() //  [R1, R2]
         { info_tbl: [(ccJ2a,
                       label: block_ccJ2a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ2a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ2k; else goto ccJ2j;
       ccJ2k: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ2j: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtA_entry() //  [R1]
         { info_tbl: [(ccJ2m,
                       label: sat_scHtA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ2m: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccJ2q; else goto ccJ2p;
       ccJ2q: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ2p: // global
           _scHso::P64 = P64[R1 + 16];
           _scHsp::P64 = P64[R1 + 24];
           _scHtc::P64 = P64[R1 + 32];
           I64[Hp - 32] = sat_scHtz_info;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 32;
           R2 = lvl13_rcHpI_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtB_entry() //  [R1]
         { info_tbl: [(ccJ2r,
                       label: sat_scHtB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ2r: // global
           _scHtB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ2s; else goto ccJ2t;
       ccJ2t: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccJ2v; else goto ccJ2u;
       ccJ2v: // global
           HpAlloc = 40;
           goto ccJ2s;
       ccJ2s: // global
           R1 = _scHtB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ2u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtB::P64;
           _scHso::P64 = P64[_scHtB::P64 + 16];
           _scHsp::P64 = P64[_scHtB::P64 + 24];
           _scHtc::P64 = P64[_scHtB::P64 + 32];
           I64[Hp - 32] = sat_scHtA_info;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtF_entry() //  [R1]
         { info_tbl: [(ccJ2w,
                       label: sat_scHtF_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ2w: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccJ2A; else goto ccJ2B;
       ccJ2A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ2B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccJ12_info;
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHtc::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _scHso::P64;
           P64[Sp - 32] = _scHsp::P64;
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucJ2I; else goto ccJ13;
       ucJ2I: // global
           call _ccJ12(R1) args: 0, res: 0, upd: 0;
       ccJ13: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ12() //  [R1]
         { info_tbl: [(ccJ12,
                       label: block_ccJ12_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ12: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccJ2E; else goto ccJ2D;
       ccJ2E: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccJ2D: // global
           _scHtk::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_scHtB_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_ccJ2x_info;
           R4 = Hp - 32;
           R3 = _scHtk::I64;
           R2 = 0;
           Sp = Sp + 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ2x() //  [R1, R2]
         { info_tbl: [(ccJ2x,
                       label: block_ccJ2x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ2x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ2H; else goto ccJ2G;
       ccJ2H: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ2G: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtG_entry() //  [R1]
         { info_tbl: [(ccJ2J,
                       label: sat_scHtG_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ2J: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccJ2N; else goto ccJ2M;
       ccJ2N: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ2M: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHtc::P64 = P64[R1 + 40];
           I64[Hp - 40] = sat_scHtF_info;
           P64[Hp - 24] = _scHsn::P64;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 40;
           R2 = lvl12_rcHpH_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtH_entry() //  [R1]
         { info_tbl: [(ccJ2O,
                       label: sat_scHtH_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ2O: // global
           _scHtH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ2P; else goto ccJ2Q;
       ccJ2Q: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccJ2S; else goto ccJ2R;
       ccJ2S: // global
           HpAlloc = 48;
           goto ccJ2P;
       ccJ2P: // global
           R1 = _scHtH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ2R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtH::P64;
           _scHsn::P64 = P64[_scHtH::P64 + 16];
           _scHso::P64 = P64[_scHtH::P64 + 24];
           _scHsp::P64 = P64[_scHtH::P64 + 32];
           _scHtc::P64 = P64[_scHtH::P64 + 40];
           I64[Hp - 40] = sat_scHtG_info;
           P64[Hp - 24] = _scHsn::P64;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 40;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtL_entry() //  [R1]
         { info_tbl: [(ccJ2W,
                       label: sat_scHtL_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ2W: // global
           _scHtL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ2X; else goto ccJ2Y;
       ccJ2Y: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccJ30; else goto ccJ2Z;
       ccJ30: // global
           HpAlloc = 48;
           goto ccJ2X;
       ccJ2X: // global
           R1 = _scHtL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ2Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtL::P64;
           _scHsn::P64 = P64[_scHtL::P64 + 16];
           _scHso::P64 = P64[_scHtL::P64 + 24];
           _scHsp::P64 = P64[_scHtL::P64 + 32];
           _scHt6::P64 = P64[_scHtL::P64 + 40];
           _scHtc::P64 = P64[_scHtL::P64 + 48];
           I64[Hp - 40] = sat_scHtH_info;
           P64[Hp - 24] = _scHsn::P64;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccJ2T_info;
           R4 = Hp - 40;
           R3 = _scHt6::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ2T() //  [R1, R2]
         { info_tbl: [(ccJ2T,
                       label: block_ccJ2T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ2T: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ33; else goto ccJ32;
       ccJ33: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ32: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtM_entry() //  [R1]
         { info_tbl: [(ccJ34,
                       label: sat_scHtM_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ34: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccJ38; else goto ccJ37;
       ccJ38: // global
           HpAlloc = 56;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ37: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHt6::P64 = P64[R1 + 40];
           _scHtc::P64 = P64[R1 + 48];
           I64[Hp - 48] = sat_scHtL_info;
           P64[Hp - 32] = _scHsn::P64;
           P64[Hp - 24] = _scHso::P64;
           P64[Hp - 16] = _scHsp::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 48;
           R2 = lvl11_rcHpG_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtN_entry() //  [R1]
         { info_tbl: [(ccJ39,
                       label: sat_scHtN_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ39: // global
           _scHtN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ3a; else goto ccJ3b;
       ccJ3b: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccJ3d; else goto ccJ3c;
       ccJ3d: // global
           HpAlloc = 56;
           goto ccJ3a;
       ccJ3a: // global
           R1 = _scHtN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ3c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtN::P64;
           _scHsn::P64 = P64[_scHtN::P64 + 16];
           _scHso::P64 = P64[_scHtN::P64 + 24];
           _scHsp::P64 = P64[_scHtN::P64 + 32];
           _scHt6::P64 = P64[_scHtN::P64 + 40];
           _scHtc::P64 = P64[_scHtN::P64 + 48];
           I64[Hp - 48] = sat_scHtM_info;
           P64[Hp - 32] = _scHsn::P64;
           P64[Hp - 24] = _scHso::P64;
           P64[Hp - 16] = _scHsp::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 48;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtR_entry() //  [R1]
         { info_tbl: [(ccJ3h,
                       label: sat_scHtR_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ3h: // global
           _scHtR::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ3i; else goto ccJ3j;
       ccJ3j: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccJ3l; else goto ccJ3k;
       ccJ3l: // global
           HpAlloc = 56;
           goto ccJ3i;
       ccJ3i: // global
           R1 = _scHtR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ3k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtR::P64;
           _scHsn::P64 = P64[_scHtR::P64 + 16];
           _scHso::P64 = P64[_scHtR::P64 + 24];
           _scHsp::P64 = P64[_scHtR::P64 + 32];
           _scHt1::P64 = P64[_scHtR::P64 + 40];
           _scHt6::P64 = P64[_scHtR::P64 + 48];
           _scHtc::P64 = P64[_scHtR::P64 + 56];
           I64[Hp - 48] = sat_scHtN_info;
           P64[Hp - 32] = _scHsn::P64;
           P64[Hp - 24] = _scHso::P64;
           P64[Hp - 16] = _scHsp::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccJ3e_info;
           R4 = Hp - 48;
           R3 = _scHt1::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ3e() //  [R1, R2]
         { info_tbl: [(ccJ3e,
                       label: block_ccJ3e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ3e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ3o; else goto ccJ3n;
       ccJ3o: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ3n: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtS_entry() //  [R1]
         { info_tbl: [(ccJ3p,
                       label: sat_scHtS_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ3p: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccJ3t; else goto ccJ3s;
       ccJ3t: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ3s: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHt1::P64 = P64[R1 + 40];
           _scHt6::P64 = P64[R1 + 48];
           _scHtc::P64 = P64[R1 + 56];
           I64[Hp - 56] = sat_scHtR_info;
           P64[Hp - 40] = _scHsn::P64;
           P64[Hp - 32] = _scHso::P64;
           P64[Hp - 24] = _scHsp::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 56;
           R2 = lvl10_rcHpF_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtT_entry() //  [R1]
         { info_tbl: [(ccJ3u,
                       label: sat_scHtT_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ3u: // global
           _scHtT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ3v; else goto ccJ3w;
       ccJ3w: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccJ3y; else goto ccJ3x;
       ccJ3y: // global
           HpAlloc = 64;
           goto ccJ3v;
       ccJ3v: // global
           R1 = _scHtT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ3x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtT::P64;
           _scHsn::P64 = P64[_scHtT::P64 + 16];
           _scHso::P64 = P64[_scHtT::P64 + 24];
           _scHsp::P64 = P64[_scHtT::P64 + 32];
           _scHt1::P64 = P64[_scHtT::P64 + 40];
           _scHt6::P64 = P64[_scHtT::P64 + 48];
           _scHtc::P64 = P64[_scHtT::P64 + 56];
           I64[Hp - 56] = sat_scHtS_info;
           P64[Hp - 40] = _scHsn::P64;
           P64[Hp - 32] = _scHso::P64;
           P64[Hp - 24] = _scHsp::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 56;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtX_entry() //  [R1]
         { info_tbl: [(ccJ3C,
                       label: sat_scHtX_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ3C: // global
           _scHtX::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ3D; else goto ccJ3E;
       ccJ3E: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccJ3G; else goto ccJ3F;
       ccJ3G: // global
           HpAlloc = 64;
           goto ccJ3D;
       ccJ3D: // global
           R1 = _scHtX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ3F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtX::P64;
           _scHsn::P64 = P64[_scHtX::P64 + 16];
           _scHso::P64 = P64[_scHtX::P64 + 24];
           _scHsp::P64 = P64[_scHtX::P64 + 32];
           _scHsW::P64 = P64[_scHtX::P64 + 40];
           _scHt1::P64 = P64[_scHtX::P64 + 48];
           _scHt6::P64 = P64[_scHtX::P64 + 56];
           _scHtc::P64 = P64[_scHtX::P64 + 64];
           I64[Hp - 56] = sat_scHtT_info;
           P64[Hp - 40] = _scHsn::P64;
           P64[Hp - 32] = _scHso::P64;
           P64[Hp - 24] = _scHsp::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccJ3z_info;
           R4 = Hp - 56;
           R3 = _scHsW::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ3z() //  [R1, R2]
         { info_tbl: [(ccJ3z,
                       label: block_ccJ3z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ3z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ3J; else goto ccJ3I;
       ccJ3J: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ3I: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtY_entry() //  [R1]
         { info_tbl: [(ccJ3K,
                       label: sat_scHtY_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ3K: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccJ3O; else goto ccJ3N;
       ccJ3O: // global
           HpAlloc = 72;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ3N: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsW::P64 = P64[R1 + 40];
           _scHt1::P64 = P64[R1 + 48];
           _scHt6::P64 = P64[R1 + 56];
           _scHtc::P64 = P64[R1 + 64];
           I64[Hp - 64] = sat_scHtX_info;
           P64[Hp - 48] = _scHsn::P64;
           P64[Hp - 40] = _scHso::P64;
           P64[Hp - 32] = _scHsp::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 64;
           R2 = lvl9_rcHpE_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtZ_entry() //  [R1]
         { info_tbl: [(ccJ3P,
                       label: sat_scHtZ_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ3P: // global
           _scHtZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ3Q; else goto ccJ3R;
       ccJ3R: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccJ3T; else goto ccJ3S;
       ccJ3T: // global
           HpAlloc = 72;
           goto ccJ3Q;
       ccJ3Q: // global
           R1 = _scHtZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ3S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtZ::P64;
           _scHsn::P64 = P64[_scHtZ::P64 + 16];
           _scHso::P64 = P64[_scHtZ::P64 + 24];
           _scHsp::P64 = P64[_scHtZ::P64 + 32];
           _scHsW::P64 = P64[_scHtZ::P64 + 40];
           _scHt1::P64 = P64[_scHtZ::P64 + 48];
           _scHt6::P64 = P64[_scHtZ::P64 + 56];
           _scHtc::P64 = P64[_scHtZ::P64 + 64];
           I64[Hp - 64] = sat_scHtY_info;
           P64[Hp - 48] = _scHsn::P64;
           P64[Hp - 40] = _scHso::P64;
           P64[Hp - 32] = _scHsp::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 64;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHu3_entry() //  [R1]
         { info_tbl: [(ccJ3X,
                       label: sat_scHu3_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ3X: // global
           _scHu3::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ3Y; else goto ccJ3Z;
       ccJ3Z: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccJ41; else goto ccJ40;
       ccJ41: // global
           HpAlloc = 72;
           goto ccJ3Y;
       ccJ3Y: // global
           R1 = _scHu3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ40: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHu3::P64;
           _scHsn::P64 = P64[_scHu3::P64 + 16];
           _scHso::P64 = P64[_scHu3::P64 + 24];
           _scHsp::P64 = P64[_scHu3::P64 + 32];
           _scHsR::P64 = P64[_scHu3::P64 + 40];
           _scHsW::P64 = P64[_scHu3::P64 + 48];
           _scHt1::P64 = P64[_scHu3::P64 + 56];
           _scHt6::P64 = P64[_scHu3::P64 + 64];
           _scHtc::P64 = P64[_scHu3::P64 + 72];
           I64[Hp - 64] = sat_scHtZ_info;
           P64[Hp - 48] = _scHsn::P64;
           P64[Hp - 40] = _scHso::P64;
           P64[Hp - 32] = _scHsp::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccJ3U_info;
           R4 = Hp - 64;
           R3 = _scHsR::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ3U() //  [R1, R2]
         { info_tbl: [(ccJ3U,
                       label: block_ccJ3U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ3U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ44; else goto ccJ43;
       ccJ44: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ43: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHu4_entry() //  [R1]
         { info_tbl: [(ccJ45,
                       label: sat_scHu4_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ45: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccJ49; else goto ccJ48;
       ccJ49: // global
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ48: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsR::P64 = P64[R1 + 40];
           _scHsW::P64 = P64[R1 + 48];
           _scHt1::P64 = P64[R1 + 56];
           _scHt6::P64 = P64[R1 + 64];
           _scHtc::P64 = P64[R1 + 72];
           I64[Hp - 72] = sat_scHu3_info;
           P64[Hp - 56] = _scHsn::P64;
           P64[Hp - 48] = _scHso::P64;
           P64[Hp - 40] = _scHsp::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 72;
           R2 = lvl8_rcHpD_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHu5_entry() //  [R1]
         { info_tbl: [(ccJ4a,
                       label: sat_scHu5_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ4a: // global
           _scHu5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ4b; else goto ccJ4c;
       ccJ4c: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccJ4e; else goto ccJ4d;
       ccJ4e: // global
           HpAlloc = 80;
           goto ccJ4b;
       ccJ4b: // global
           R1 = _scHu5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ4d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHu5::P64;
           _scHsn::P64 = P64[_scHu5::P64 + 16];
           _scHso::P64 = P64[_scHu5::P64 + 24];
           _scHsp::P64 = P64[_scHu5::P64 + 32];
           _scHsR::P64 = P64[_scHu5::P64 + 40];
           _scHsW::P64 = P64[_scHu5::P64 + 48];
           _scHt1::P64 = P64[_scHu5::P64 + 56];
           _scHt6::P64 = P64[_scHu5::P64 + 64];
           _scHtc::P64 = P64[_scHu5::P64 + 72];
           I64[Hp - 72] = sat_scHu4_info;
           P64[Hp - 56] = _scHsn::P64;
           P64[Hp - 48] = _scHso::P64;
           P64[Hp - 40] = _scHsp::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 72;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHu9_entry() //  [R1]
         { info_tbl: [(ccJ4i,
                       label: sat_scHu9_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ4i: // global
           _scHu9::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ4j; else goto ccJ4k;
       ccJ4k: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccJ4m; else goto ccJ4l;
       ccJ4m: // global
           HpAlloc = 80;
           goto ccJ4j;
       ccJ4j: // global
           R1 = _scHu9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ4l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHu9::P64;
           _scHsn::P64 = P64[_scHu9::P64 + 16];
           _scHso::P64 = P64[_scHu9::P64 + 24];
           _scHsp::P64 = P64[_scHu9::P64 + 32];
           _scHsM::P64 = P64[_scHu9::P64 + 40];
           _scHsR::P64 = P64[_scHu9::P64 + 48];
           _scHsW::P64 = P64[_scHu9::P64 + 56];
           _scHt1::P64 = P64[_scHu9::P64 + 64];
           _scHt6::P64 = P64[_scHu9::P64 + 72];
           _scHtc::P64 = P64[_scHu9::P64 + 80];
           I64[Hp - 72] = sat_scHu5_info;
           P64[Hp - 56] = _scHsn::P64;
           P64[Hp - 48] = _scHso::P64;
           P64[Hp - 40] = _scHsp::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccJ4f_info;
           R4 = Hp - 72;
           R3 = _scHsM::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ4f() //  [R1, R2]
         { info_tbl: [(ccJ4f,
                       label: block_ccJ4f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ4f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ4p; else goto ccJ4o;
       ccJ4p: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ4o: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHua_entry() //  [R1]
         { info_tbl: [(ccJ4q,
                       label: sat_scHua_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ4q: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccJ4u; else goto ccJ4t;
       ccJ4u: // global
           HpAlloc = 88;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ4t: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsM::P64 = P64[R1 + 40];
           _scHsR::P64 = P64[R1 + 48];
           _scHsW::P64 = P64[R1 + 56];
           _scHt1::P64 = P64[R1 + 64];
           _scHt6::P64 = P64[R1 + 72];
           _scHtc::P64 = P64[R1 + 80];
           I64[Hp - 80] = sat_scHu9_info;
           P64[Hp - 64] = _scHsn::P64;
           P64[Hp - 56] = _scHso::P64;
           P64[Hp - 48] = _scHsp::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 80;
           R2 = lvl7_rcHpC_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHub_entry() //  [R1]
         { info_tbl: [(ccJ4v,
                       label: sat_scHub_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ4v: // global
           _scHub::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ4w; else goto ccJ4x;
       ccJ4x: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccJ4z; else goto ccJ4y;
       ccJ4z: // global
           HpAlloc = 88;
           goto ccJ4w;
       ccJ4w: // global
           R1 = _scHub::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ4y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHub::P64;
           _scHsn::P64 = P64[_scHub::P64 + 16];
           _scHso::P64 = P64[_scHub::P64 + 24];
           _scHsp::P64 = P64[_scHub::P64 + 32];
           _scHsM::P64 = P64[_scHub::P64 + 40];
           _scHsR::P64 = P64[_scHub::P64 + 48];
           _scHsW::P64 = P64[_scHub::P64 + 56];
           _scHt1::P64 = P64[_scHub::P64 + 64];
           _scHt6::P64 = P64[_scHub::P64 + 72];
           _scHtc::P64 = P64[_scHub::P64 + 80];
           I64[Hp - 80] = sat_scHua_info;
           P64[Hp - 64] = _scHsn::P64;
           P64[Hp - 56] = _scHso::P64;
           P64[Hp - 48] = _scHsp::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 80;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuf_entry() //  [R1]
         { info_tbl: [(ccJ4D,
                       label: sat_scHuf_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ4D: // global
           _scHuf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ4E; else goto ccJ4F;
       ccJ4F: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccJ4H; else goto ccJ4G;
       ccJ4H: // global
           HpAlloc = 88;
           goto ccJ4E;
       ccJ4E: // global
           R1 = _scHuf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ4G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuf::P64;
           _scHsn::P64 = P64[_scHuf::P64 + 16];
           _scHso::P64 = P64[_scHuf::P64 + 24];
           _scHsp::P64 = P64[_scHuf::P64 + 32];
           _scHsH::P64 = P64[_scHuf::P64 + 40];
           _scHsM::P64 = P64[_scHuf::P64 + 48];
           _scHsR::P64 = P64[_scHuf::P64 + 56];
           _scHsW::P64 = P64[_scHuf::P64 + 64];
           _scHt1::P64 = P64[_scHuf::P64 + 72];
           _scHt6::P64 = P64[_scHuf::P64 + 80];
           _scHtc::P64 = P64[_scHuf::P64 + 88];
           I64[Hp - 80] = sat_scHub_info;
           P64[Hp - 64] = _scHsn::P64;
           P64[Hp - 56] = _scHso::P64;
           P64[Hp - 48] = _scHsp::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccJ4A_info;
           R4 = Hp - 80;
           R3 = _scHsH::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ4A() //  [R1, R2]
         { info_tbl: [(ccJ4A,
                       label: block_ccJ4A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ4A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ4K; else goto ccJ4J;
       ccJ4K: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ4J: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHug_entry() //  [R1]
         { info_tbl: [(ccJ4L,
                       label: sat_scHug_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ4L: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccJ4P; else goto ccJ4O;
       ccJ4P: // global
           HpAlloc = 96;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ4O: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsH::P64 = P64[R1 + 40];
           _scHsM::P64 = P64[R1 + 48];
           _scHsR::P64 = P64[R1 + 56];
           _scHsW::P64 = P64[R1 + 64];
           _scHt1::P64 = P64[R1 + 72];
           _scHt6::P64 = P64[R1 + 80];
           _scHtc::P64 = P64[R1 + 88];
           I64[Hp - 88] = sat_scHuf_info;
           P64[Hp - 72] = _scHsn::P64;
           P64[Hp - 64] = _scHso::P64;
           P64[Hp - 56] = _scHsp::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 88;
           R2 = lvl6_rcHpB_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHuh_entry() //  [R1]
         { info_tbl: [(ccJ4Q,
                       label: sat_scHuh_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ4Q: // global
           _scHuh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ4R; else goto ccJ4S;
       ccJ4S: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccJ4U; else goto ccJ4T;
       ccJ4U: // global
           HpAlloc = 96;
           goto ccJ4R;
       ccJ4R: // global
           R1 = _scHuh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ4T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuh::P64;
           _scHsn::P64 = P64[_scHuh::P64 + 16];
           _scHso::P64 = P64[_scHuh::P64 + 24];
           _scHsp::P64 = P64[_scHuh::P64 + 32];
           _scHsH::P64 = P64[_scHuh::P64 + 40];
           _scHsM::P64 = P64[_scHuh::P64 + 48];
           _scHsR::P64 = P64[_scHuh::P64 + 56];
           _scHsW::P64 = P64[_scHuh::P64 + 64];
           _scHt1::P64 = P64[_scHuh::P64 + 72];
           _scHt6::P64 = P64[_scHuh::P64 + 80];
           _scHtc::P64 = P64[_scHuh::P64 + 88];
           I64[Hp - 88] = sat_scHug_info;
           P64[Hp - 72] = _scHsn::P64;
           P64[Hp - 64] = _scHso::P64;
           P64[Hp - 56] = _scHsp::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 88;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHul_entry() //  [R1]
         { info_tbl: [(ccJ4Y,
                       label: sat_scHul_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ4Y: // global
           _scHul::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ4Z; else goto ccJ50;
       ccJ50: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccJ52; else goto ccJ51;
       ccJ52: // global
           HpAlloc = 96;
           goto ccJ4Z;
       ccJ4Z: // global
           R1 = _scHul::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ51: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHul::P64;
           _scHsn::P64 = P64[_scHul::P64 + 16];
           _scHso::P64 = P64[_scHul::P64 + 24];
           _scHsp::P64 = P64[_scHul::P64 + 32];
           _scHsC::P64 = P64[_scHul::P64 + 40];
           _scHsH::P64 = P64[_scHul::P64 + 48];
           _scHsM::P64 = P64[_scHul::P64 + 56];
           _scHsR::P64 = P64[_scHul::P64 + 64];
           _scHsW::P64 = P64[_scHul::P64 + 72];
           _scHt1::P64 = P64[_scHul::P64 + 80];
           _scHt6::P64 = P64[_scHul::P64 + 88];
           _scHtc::P64 = P64[_scHul::P64 + 96];
           I64[Hp - 88] = sat_scHuh_info;
           P64[Hp - 72] = _scHsn::P64;
           P64[Hp - 64] = _scHso::P64;
           P64[Hp - 56] = _scHsp::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccJ4V_info;
           R4 = Hp - 88;
           R3 = _scHsC::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ4V() //  [R1, R2]
         { info_tbl: [(ccJ4V,
                       label: block_ccJ4V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ4V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ55; else goto ccJ54;
       ccJ55: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ54: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHum_entry() //  [R1]
         { info_tbl: [(ccJ56,
                       label: sat_scHum_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ56: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccJ5a; else goto ccJ59;
       ccJ5a: // global
           HpAlloc = 104;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ59: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsC::P64 = P64[R1 + 40];
           _scHsH::P64 = P64[R1 + 48];
           _scHsM::P64 = P64[R1 + 56];
           _scHsR::P64 = P64[R1 + 64];
           _scHsW::P64 = P64[R1 + 72];
           _scHt1::P64 = P64[R1 + 80];
           _scHt6::P64 = P64[R1 + 88];
           _scHtc::P64 = P64[R1 + 96];
           I64[Hp - 96] = sat_scHul_info;
           P64[Hp - 80] = _scHsn::P64;
           P64[Hp - 72] = _scHso::P64;
           P64[Hp - 64] = _scHsp::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 96;
           R2 = lvl5_rcHpA_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHun_entry() //  [R1]
         { info_tbl: [(ccJ5b,
                       label: sat_scHun_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ5b: // global
           _scHun::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ5c; else goto ccJ5d;
       ccJ5d: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccJ5f; else goto ccJ5e;
       ccJ5f: // global
           HpAlloc = 104;
           goto ccJ5c;
       ccJ5c: // global
           R1 = _scHun::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ5e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHun::P64;
           _scHsn::P64 = P64[_scHun::P64 + 16];
           _scHso::P64 = P64[_scHun::P64 + 24];
           _scHsp::P64 = P64[_scHun::P64 + 32];
           _scHsC::P64 = P64[_scHun::P64 + 40];
           _scHsH::P64 = P64[_scHun::P64 + 48];
           _scHsM::P64 = P64[_scHun::P64 + 56];
           _scHsR::P64 = P64[_scHun::P64 + 64];
           _scHsW::P64 = P64[_scHun::P64 + 72];
           _scHt1::P64 = P64[_scHun::P64 + 80];
           _scHt6::P64 = P64[_scHun::P64 + 88];
           _scHtc::P64 = P64[_scHun::P64 + 96];
           I64[Hp - 96] = sat_scHum_info;
           P64[Hp - 80] = _scHsn::P64;
           P64[Hp - 72] = _scHso::P64;
           P64[Hp - 64] = _scHsp::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 96;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHur_entry() //  [R1]
         { info_tbl: [(ccJ5j,
                       label: sat_scHur_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ5j: // global
           _scHur::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ5k; else goto ccJ5l;
       ccJ5l: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccJ5n; else goto ccJ5m;
       ccJ5n: // global
           HpAlloc = 104;
           goto ccJ5k;
       ccJ5k: // global
           R1 = _scHur::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ5m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHur::P64;
           _scHsn::P64 = P64[_scHur::P64 + 16];
           _scHso::P64 = P64[_scHur::P64 + 24];
           _scHsp::P64 = P64[_scHur::P64 + 32];
           _scHsx::P64 = P64[_scHur::P64 + 40];
           _scHsC::P64 = P64[_scHur::P64 + 48];
           _scHsH::P64 = P64[_scHur::P64 + 56];
           _scHsM::P64 = P64[_scHur::P64 + 64];
           _scHsR::P64 = P64[_scHur::P64 + 72];
           _scHsW::P64 = P64[_scHur::P64 + 80];
           _scHt1::P64 = P64[_scHur::P64 + 88];
           _scHt6::P64 = P64[_scHur::P64 + 96];
           _scHtc::P64 = P64[_scHur::P64 + 104];
           I64[Hp - 96] = sat_scHun_info;
           P64[Hp - 80] = _scHsn::P64;
           P64[Hp - 72] = _scHso::P64;
           P64[Hp - 64] = _scHsp::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccJ5g_info;
           R4 = Hp - 96;
           R3 = _scHsx::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ5g() //  [R1, R2]
         { info_tbl: [(ccJ5g,
                       label: block_ccJ5g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ5g: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ5q; else goto ccJ5p;
       ccJ5q: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ5p: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHus_entry() //  [R1]
         { info_tbl: [(ccJ5r,
                       label: sat_scHus_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ5r: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccJ5v; else goto ccJ5u;
       ccJ5v: // global
           HpAlloc = 112;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ5u: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsx::P64 = P64[R1 + 40];
           _scHsC::P64 = P64[R1 + 48];
           _scHsH::P64 = P64[R1 + 56];
           _scHsM::P64 = P64[R1 + 64];
           _scHsR::P64 = P64[R1 + 72];
           _scHsW::P64 = P64[R1 + 80];
           _scHt1::P64 = P64[R1 + 88];
           _scHt6::P64 = P64[R1 + 96];
           _scHtc::P64 = P64[R1 + 104];
           I64[Hp - 104] = sat_scHur_info;
           P64[Hp - 88] = _scHsn::P64;
           P64[Hp - 80] = _scHso::P64;
           P64[Hp - 72] = _scHsp::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 104;
           R2 = lvl4_rcHpz_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHut_entry() //  [R1]
         { info_tbl: [(ccJ5w,
                       label: sat_scHut_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ5w: // global
           _scHut::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ5x; else goto ccJ5y;
       ccJ5y: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccJ5A; else goto ccJ5z;
       ccJ5A: // global
           HpAlloc = 112;
           goto ccJ5x;
       ccJ5x: // global
           R1 = _scHut::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ5z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHut::P64;
           _scHsn::P64 = P64[_scHut::P64 + 16];
           _scHso::P64 = P64[_scHut::P64 + 24];
           _scHsp::P64 = P64[_scHut::P64 + 32];
           _scHsx::P64 = P64[_scHut::P64 + 40];
           _scHsC::P64 = P64[_scHut::P64 + 48];
           _scHsH::P64 = P64[_scHut::P64 + 56];
           _scHsM::P64 = P64[_scHut::P64 + 64];
           _scHsR::P64 = P64[_scHut::P64 + 72];
           _scHsW::P64 = P64[_scHut::P64 + 80];
           _scHt1::P64 = P64[_scHut::P64 + 88];
           _scHt6::P64 = P64[_scHut::P64 + 96];
           _scHtc::P64 = P64[_scHut::P64 + 104];
           I64[Hp - 104] = sat_scHus_info;
           P64[Hp - 88] = _scHsn::P64;
           P64[Hp - 80] = _scHso::P64;
           P64[Hp - 72] = _scHsp::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 104;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHux_entry() //  [R1]
         { info_tbl: [(ccJ5E,
                       label: sat_scHux_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ5E: // global
           _scHux::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ5F; else goto ccJ5G;
       ccJ5G: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccJ5I; else goto ccJ5H;
       ccJ5I: // global
           HpAlloc = 112;
           goto ccJ5F;
       ccJ5F: // global
           R1 = _scHux::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ5H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHux::P64;
           _scHsn::P64 = P64[_scHux::P64 + 16];
           _scHso::P64 = P64[_scHux::P64 + 24];
           _scHsp::P64 = P64[_scHux::P64 + 32];
           _scHss::P64 = P64[_scHux::P64 + 40];
           _scHsx::P64 = P64[_scHux::P64 + 48];
           _scHsC::P64 = P64[_scHux::P64 + 56];
           _scHsH::P64 = P64[_scHux::P64 + 64];
           _scHsM::P64 = P64[_scHux::P64 + 72];
           _scHsR::P64 = P64[_scHux::P64 + 80];
           _scHsW::P64 = P64[_scHux::P64 + 88];
           _scHt1::P64 = P64[_scHux::P64 + 96];
           _scHt6::P64 = P64[_scHux::P64 + 104];
           _scHtc::P64 = P64[_scHux::P64 + 112];
           I64[Hp - 104] = sat_scHut_info;
           P64[Hp - 88] = _scHsn::P64;
           P64[Hp - 80] = _scHso::P64;
           P64[Hp - 72] = _scHsp::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccJ5B_info;
           R4 = Hp - 104;
           R3 = _scHss::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ5B() //  [R1, R2]
         { info_tbl: [(ccJ5B,
                       label: block_ccJ5B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ5B: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ5L; else goto ccJ5K;
       ccJ5L: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ5K: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuy_entry() //  [R1]
         { info_tbl: [(ccJ5M,
                       label: sat_scHuy_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ5M: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccJ5Q; else goto ccJ5P;
       ccJ5Q: // global
           HpAlloc = 120;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ5P: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHss::P64 = P64[R1 + 40];
           _scHsx::P64 = P64[R1 + 48];
           _scHsC::P64 = P64[R1 + 56];
           _scHsH::P64 = P64[R1 + 64];
           _scHsM::P64 = P64[R1 + 72];
           _scHsR::P64 = P64[R1 + 80];
           _scHsW::P64 = P64[R1 + 88];
           _scHt1::P64 = P64[R1 + 96];
           _scHt6::P64 = P64[R1 + 104];
           _scHtc::P64 = P64[R1 + 112];
           I64[Hp - 112] = sat_scHux_info;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 112;
           R2 = lvl3_rcHpy_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHuz_entry() //  [R1]
         { info_tbl: [(ccJ5R,
                       label: sat_scHuz_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ5R: // global
           _scHuz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ5S; else goto ccJ5T;
       ccJ5T: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccJ5V; else goto ccJ5U;
       ccJ5V: // global
           HpAlloc = 120;
           goto ccJ5S;
       ccJ5S: // global
           R1 = _scHuz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ5U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuz::P64;
           _scHsn::P64 = P64[_scHuz::P64 + 16];
           _scHso::P64 = P64[_scHuz::P64 + 24];
           _scHsp::P64 = P64[_scHuz::P64 + 32];
           _scHss::P64 = P64[_scHuz::P64 + 40];
           _scHsx::P64 = P64[_scHuz::P64 + 48];
           _scHsC::P64 = P64[_scHuz::P64 + 56];
           _scHsH::P64 = P64[_scHuz::P64 + 64];
           _scHsM::P64 = P64[_scHuz::P64 + 72];
           _scHsR::P64 = P64[_scHuz::P64 + 80];
           _scHsW::P64 = P64[_scHuz::P64 + 88];
           _scHt1::P64 = P64[_scHuz::P64 + 96];
           _scHt6::P64 = P64[_scHuz::P64 + 104];
           _scHtc::P64 = P64[_scHuz::P64 + 112];
           I64[Hp - 112] = sat_scHuy_info;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 112;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuD_entry() //  [R1]
         { info_tbl: [(ccJ5W,
                       label: sat_scHuD_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ5W: // global
           if ((Sp + -128) < SpLim) (likely: False) goto ccJ63; else goto ccJ64;
       ccJ63: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ64: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 128] = block_ccIZ1_info;
           _scHsn::P64 = P64[R1 + 24];
           _scHso::P64 = P64[R1 + 32];
           _scHsp::P64 = P64[R1 + 40];
           _scHss::P64 = P64[R1 + 48];
           _scHsx::P64 = P64[R1 + 56];
           _scHsC::P64 = P64[R1 + 64];
           _scHsH::P64 = P64[R1 + 72];
           _scHsM::P64 = P64[R1 + 80];
           _scHsR::P64 = P64[R1 + 88];
           _scHsW::P64 = P64[R1 + 96];
           _scHt1::P64 = P64[R1 + 104];
           _scHt6::P64 = P64[R1 + 112];
           _scHtc::P64 = P64[R1 + 120];
           R1 = P64[R1 + 16];
           P64[Sp - 120] = _scHsn::P64;
           P64[Sp - 112] = _scHso::P64;
           P64[Sp - 104] = _scHsp::P64;
           P64[Sp - 96] = _scHss::P64;
           P64[Sp - 88] = _scHsx::P64;
           P64[Sp - 80] = _scHsC::P64;
           P64[Sp - 72] = _scHsH::P64;
           P64[Sp - 64] = _scHsM::P64;
           P64[Sp - 56] = _scHsR::P64;
           P64[Sp - 48] = _scHsW::P64;
           P64[Sp - 40] = _scHt1::P64;
           P64[Sp - 32] = _scHt6::P64;
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto ucJ6b; else goto ccIZ2;
       ucJ6b: // global
           call _ccIZ1(R1) args: 0, res: 0, upd: 0;
       ccIZ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIZ1() //  [R1]
         { info_tbl: [(ccIZ1,
                       label: block_ccIZ1_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIZ1: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccJ67; else goto ccJ66;
       ccJ67: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccJ66: // global
           _scHth::I64 = I64[R1 + 7];
           I64[Hp - 112] = sat_scHuz_info;
           P64[Hp - 96] = P64[Sp + 8];
           P64[Hp - 88] = P64[Sp + 16];
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 32];
           P64[Hp - 64] = P64[Sp + 40];
           P64[Hp - 56] = P64[Sp + 48];
           P64[Hp - 48] = P64[Sp + 56];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           P64[Hp - 24] = P64[Sp + 80];
           P64[Hp - 16] = P64[Sp + 88];
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 104];
           I64[Sp + 104] = block_ccJ60_info;
           R3 = Hp - 112;
           R2 = _scHth::I64;
           Sp = Sp + 104;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ60() //  [R1, R2]
         { info_tbl: [(ccJ60,
                       label: block_ccJ60_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ60: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ6a; else goto ccJ69;
       ccJ6a: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ69: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuE_entry() //  [R1]
         { info_tbl: [(ccJ6c,
                       label: sat_scHuE_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ6c: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccJ6g; else goto ccJ6f;
       ccJ6g: // global
           HpAlloc = 128;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ6f: // global
           _scHsd::P64 = P64[R1 + 16];
           _scHsn::P64 = P64[R1 + 24];
           _scHso::P64 = P64[R1 + 32];
           _scHsp::P64 = P64[R1 + 40];
           _scHss::P64 = P64[R1 + 48];
           _scHsx::P64 = P64[R1 + 56];
           _scHsC::P64 = P64[R1 + 64];
           _scHsH::P64 = P64[R1 + 72];
           _scHsM::P64 = P64[R1 + 80];
           _scHsR::P64 = P64[R1 + 88];
           _scHsW::P64 = P64[R1 + 96];
           _scHt1::P64 = P64[R1 + 104];
           _scHt6::P64 = P64[R1 + 112];
           _scHtc::P64 = P64[R1 + 120];
           I64[Hp - 120] = sat_scHuD_info;
           P64[Hp - 104] = _scHsd::P64;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 120;
           R2 = lvl2_rcHpx_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHuF_entry() //  [R1]
         { info_tbl: [(ccJ6h,
                       label: sat_scHuF_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ6h: // global
           _scHuF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ6i; else goto ccJ6j;
       ccJ6j: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccJ6l; else goto ccJ6k;
       ccJ6l: // global
           HpAlloc = 128;
           goto ccJ6i;
       ccJ6i: // global
           R1 = _scHuF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ6k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuF::P64;
           _scHsd::P64 = P64[_scHuF::P64 + 16];
           _scHsn::P64 = P64[_scHuF::P64 + 24];
           _scHso::P64 = P64[_scHuF::P64 + 32];
           _scHsp::P64 = P64[_scHuF::P64 + 40];
           _scHss::P64 = P64[_scHuF::P64 + 48];
           _scHsx::P64 = P64[_scHuF::P64 + 56];
           _scHsC::P64 = P64[_scHuF::P64 + 64];
           _scHsH::P64 = P64[_scHuF::P64 + 72];
           _scHsM::P64 = P64[_scHuF::P64 + 80];
           _scHsR::P64 = P64[_scHuF::P64 + 88];
           _scHsW::P64 = P64[_scHuF::P64 + 96];
           _scHt1::P64 = P64[_scHuF::P64 + 104];
           _scHt6::P64 = P64[_scHuF::P64 + 112];
           _scHtc::P64 = P64[_scHuF::P64 + 120];
           I64[Hp - 120] = sat_scHuE_info;
           P64[Hp - 104] = _scHsd::P64;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 120;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuJ_entry() //  [R1]
         { info_tbl: [(ccJ6m,
                       label: sat_scHuJ_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ6m: // global
           if ((Sp + -136) < SpLim) (likely: False) goto ccJ6t; else goto ccJ6u;
       ccJ6t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ6u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 136] = block_ccIYK_info;
           _scHsd::P64 = P64[R1 + 24];
           _scHsn::P64 = P64[R1 + 32];
           _scHso::P64 = P64[R1 + 40];
           _scHsp::P64 = P64[R1 + 48];
           _scHss::P64 = P64[R1 + 56];
           _scHsx::P64 = P64[R1 + 64];
           _scHsC::P64 = P64[R1 + 72];
           _scHsH::P64 = P64[R1 + 80];
           _scHsM::P64 = P64[R1 + 88];
           _scHsR::P64 = P64[R1 + 96];
           _scHsW::P64 = P64[R1 + 104];
           _scHt1::P64 = P64[R1 + 112];
           _scHt6::P64 = P64[R1 + 120];
           _scHtc::P64 = P64[R1 + 128];
           R1 = P64[R1 + 16];
           P64[Sp - 128] = _scHsd::P64;
           P64[Sp - 120] = _scHsn::P64;
           P64[Sp - 112] = _scHso::P64;
           P64[Sp - 104] = _scHsp::P64;
           P64[Sp - 96] = _scHss::P64;
           P64[Sp - 88] = _scHsx::P64;
           P64[Sp - 80] = _scHsC::P64;
           P64[Sp - 72] = _scHsH::P64;
           P64[Sp - 64] = _scHsM::P64;
           P64[Sp - 56] = _scHsR::P64;
           P64[Sp - 48] = _scHsW::P64;
           P64[Sp - 40] = _scHt1::P64;
           P64[Sp - 32] = _scHt6::P64;
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 136;
           if (R1 & 7 != 0) goto ucJ6B; else goto ccIYL;
       ucJ6B: // global
           call _ccIYK(R1) args: 0, res: 0, upd: 0;
       ccIYL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccIYK() //  [R1]
         { info_tbl: [(ccIYK,
                       label: block_ccIYK_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIYK: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccJ6x; else goto ccJ6w;
       ccJ6x: // global
           HpAlloc = 128;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccJ6w: // global
           _scHte::I64 = I64[R1 + 7];
           I64[Hp - 120] = sat_scHuF_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = P64[Sp + 16];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = P64[Sp + 56];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = P64[Sp + 72];
           P64[Hp - 32] = P64[Sp + 80];
           P64[Hp - 24] = P64[Sp + 88];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           I64[Sp + 112] = block_ccJ6q_info;
           R3 = Hp - 120;
           R2 = _scHte::I64;
           Sp = Sp + 112;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ6q() //  [R1, R2]
         { info_tbl: [(ccJ6q,
                       label: block_ccJ6q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ6q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ6A; else goto ccJ6z;
       ccJ6A: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJ6z: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuK_entry() //  [R1]
         { info_tbl: [(ccJ6C,
                       label: sat_scHuK_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ6C: // global
           _scHuK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ6D; else goto ccJ6E;
       ccJ6E: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccJ6G; else goto ccJ6F;
       ccJ6G: // global
           HpAlloc = 136;
           goto ccJ6D;
       ccJ6D: // global
           R1 = _scHuK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ6F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuK::P64;
           _scHsc::P64 = P64[_scHuK::P64 + 16];
           _scHsd::P64 = P64[_scHuK::P64 + 24];
           _scHsn::P64 = P64[_scHuK::P64 + 32];
           _scHso::P64 = P64[_scHuK::P64 + 40];
           _scHsp::P64 = P64[_scHuK::P64 + 48];
           _scHss::P64 = P64[_scHuK::P64 + 56];
           _scHsx::P64 = P64[_scHuK::P64 + 64];
           _scHsC::P64 = P64[_scHuK::P64 + 72];
           _scHsH::P64 = P64[_scHuK::P64 + 80];
           _scHsM::P64 = P64[_scHuK::P64 + 88];
           _scHsR::P64 = P64[_scHuK::P64 + 96];
           _scHsW::P64 = P64[_scHuK::P64 + 104];
           _scHt1::P64 = P64[_scHuK::P64 + 112];
           _scHt6::P64 = P64[_scHuK::P64 + 120];
           _scHtc::P64 = P64[_scHuK::P64 + 128];
           I64[Hp - 128] = sat_scHuJ_info;
           P64[Hp - 112] = _scHsc::P64;
           P64[Hp - 104] = _scHsd::P64;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 128;
           R2 = lvl1_rcHpw_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_scHtb_entry() //  [R1, R2]
         { info_tbl: [(ccJ6H,
                       label: p_scHtb_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ6H: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccJ6L; else goto ccJ6K;
       ccJ6L: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJ6K: // global
           _scHsc::P64 = P64[R1 + 7];
           _scHsd::P64 = P64[R1 + 15];
           _scHsn::P64 = P64[R1 + 23];
           _scHso::P64 = P64[R1 + 31];
           _scHsp::P64 = P64[R1 + 39];
           _scHss::P64 = P64[R1 + 47];
           _scHsx::P64 = P64[R1 + 55];
           _scHsC::P64 = P64[R1 + 63];
           _scHsH::P64 = P64[R1 + 71];
           _scHsM::P64 = P64[R1 + 79];
           _scHsR::P64 = P64[R1 + 87];
           _scHsW::P64 = P64[R1 + 95];
           _scHt1::P64 = P64[R1 + 103];
           _scHt6::P64 = P64[R1 + 111];
           I64[Hp - 128] = sat_scHuK_info;
           P64[Hp - 112] = _scHsc::P64;
           P64[Hp - 104] = _scHsd::P64;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = R2;
           R3 = Hp - 128;
           R2 = lvl_rcHpv_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHuO_entry() //  [R1]
         { info_tbl: [(ccJ70,
                       label: sat_scHuO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ70: // global
           _scHuO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ71; else goto ccJ72;
       ccJ72: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJ74; else goto ccJ73;
       ccJ74: // global
           HpAlloc = 24;
           goto ccJ71;
       ccJ71: // global
           R1 = _scHuO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ73: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuO::P64;
           _scHtb::P64 = P64[_scHuO::P64 + 16];
           _scHuM::P64 = P64[_scHuO::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _scHuM::P64;
           R2 = Hp - 14;
           R1 = _scHtb::P64;
           Sp = Sp - 16;
           call p_scHtb_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuP_entry() //  [R1, R2]
         { info_tbl: [(ccJ76,
                       label: sat_scHuP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ76: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccJ7a; else goto ccJ79;
       ccJ7a: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJ79: // global
           _scHtb::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_scHuO_info;
           P64[Hp - 32] = _scHtb::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stats.$fShowGCDetails_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(ccJ7b,
                       label: GHC.Stats.$fShowGCDetails_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ7b: // global
           if ((Sp + -120) < SpLim) (likely: False) goto ccJ7c; else goto ccJ7d;
       ccJ7c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fShowGCDetails_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccJ7d: // global
           I64[Sp - 16] = block_ccIVb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucJ7m; else goto ccIVc;
       ucJ7m: // global
           call _ccIVb(R1) args: 0, res: 0, upd: 0;
       ccIVc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIVb() //  [R1]
         { info_tbl: [(ccIVb,
                       label: block_ccIVb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIVb: // global
           I64[Sp - 104] = block_ccIVg_info;
           _scHsc::P64 = P64[R1 + 7];
           _scHsd::P64 = P64[R1 + 15];
           _scHse::P64 = P64[R1 + 23];
           _scHsf::P64 = P64[R1 + 31];
           _scHsg::P64 = P64[R1 + 39];
           _scHsh::P64 = P64[R1 + 47];
           _scHsi::P64 = P64[R1 + 55];
           _scHsj::P64 = P64[R1 + 63];
           _scHsk::P64 = P64[R1 + 71];
           _scHsl::P64 = P64[R1 + 79];
           _scHsm::P64 = P64[R1 + 87];
           _scHsn::P64 = P64[R1 + 95];
           _scHso::P64 = P64[R1 + 103];
           _scHsp::P64 = P64[R1 + 111];
           R1 = P64[Sp + 8];
           P64[Sp - 96] = _scHse::P64;
           P64[Sp - 88] = _scHsf::P64;
           P64[Sp - 80] = _scHsg::P64;
           P64[Sp - 72] = _scHsh::P64;
           P64[Sp - 64] = _scHsi::P64;
           P64[Sp - 56] = _scHsj::P64;
           P64[Sp - 48] = _scHsk::P64;
           P64[Sp - 40] = _scHsl::P64;
           P64[Sp - 32] = _scHsm::P64;
           P64[Sp - 24] = _scHsn::P64;
           P64[Sp - 16] = _scHso::P64;
           P64[Sp - 8] = _scHsp::P64;
           P64[Sp] = _scHsd::P64;
           P64[Sp + 8] = _scHsc::P64;
           Sp = Sp - 104;
           if (R1 & 7 != 0) goto ucJ7l; else goto ccIVh;
       ucJ7l: // global
           call _ccIVg(R1) args: 0, res: 0, upd: 0;
       ccIVh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccIVg() //  [R1]
         { info_tbl: [(ccIVg,
                       label: block_ccIVg_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccIVg: // global
           Hp = Hp + 352;
           if (Hp > HpLim) (likely: False) goto ccJ7h; else goto ccJ7g;
       ccJ7h: // global
           HpAlloc = 352;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJ7g: // global
           _scHsr::I64 = I64[R1 + 7];
           I64[Hp - 344] = w1_scHss_info;
           P64[Hp - 328] = P64[Sp + 8];
           I64[Hp - 320] = w2_scHsx_info;
           P64[Hp - 304] = P64[Sp + 16];
           I64[Hp - 296] = w3_scHsC_info;
           P64[Hp - 280] = P64[Sp + 24];
           I64[Hp - 272] = w4_scHsH_info;
           P64[Hp - 256] = P64[Sp + 32];
           I64[Hp - 248] = w5_scHsM_info;
           P64[Hp - 232] = P64[Sp + 40];
           I64[Hp - 224] = w6_scHsR_info;
           P64[Hp - 208] = P64[Sp + 48];
           I64[Hp - 200] = w7_scHsW_info;
           P64[Hp - 184] = P64[Sp + 56];
           I64[Hp - 176] = w8_scHt1_info;
           P64[Hp - 160] = P64[Sp + 64];
           I64[Hp - 152] = w9_scHt6_info;
           P64[Hp - 136] = P64[Sp + 72];
           I64[Hp - 128] = p_scHtb_info;
           P64[Hp - 120] = P64[Sp + 112];
           P64[Hp - 112] = P64[Sp + 104];
           P64[Hp - 104] = P64[Sp + 80];
           P64[Hp - 96] = P64[Sp + 88];
           P64[Hp - 88] = P64[Sp + 96];
           P64[Hp - 80] = Hp - 344;
           P64[Hp - 72] = Hp - 320;
           P64[Hp - 64] = Hp - 296;
           P64[Hp - 56] = Hp - 272;
           P64[Hp - 48] = Hp - 248;
           P64[Hp - 40] = Hp - 224;
           P64[Hp - 32] = Hp - 200;
           P64[Hp - 24] = Hp - 176;
           P64[Hp - 16] = Hp - 152;
           _ccIYx::P64 = Hp - 127;
           if (%MO_S_Lt_W64(_scHsr::I64, 11)) goto ccJ7j; else goto ccJ7k;
       ccJ7j: // global
           Hp = Hp - 16;
           R1 = _ccIYx::P64;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccJ7k: // global
           I64[Hp - 8] = sat_scHuP_info;
           P64[Hp] = _ccIYx::P64;
           R1 = Hp - 7;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.239818587 UTC

[section ""data" . GHC.Stats.$fShowGCDetails2_closure" {
     GHC.Stats.$fShowGCDetails2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.240712529 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_$cshow_closure" {
     GHC.Stats.$fShowGCDetails_$cshow_closure:
         const GHC.Stats.$fShowGCDetails_$cshow_info;
         const 0;
 },
 GHC.Stats.$fShowGCDetails_$cshow_entry() //  [R2]
         { info_tbl: [(ccJ7r,
                       label: GHC.Stats.$fShowGCDetails_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ7r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJ7s; else goto ccJ7t;
       ccJ7s: // global
           R2 = R2;
           R1 = GHC.Stats.$fShowGCDetails_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJ7t: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Stats.$fShowGCDetails_$cshowsPrec_entry(R3,
                                                            R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.241682272 UTC

[section ""data" . GHC.Stats.$fShowGCDetails1_closure" {
     GHC.Stats.$fShowGCDetails1_closure:
         const GHC.Stats.$fShowGCDetails1_info;
         const 0;
 },
 GHC.Stats.$fShowGCDetails1_entry() //  [R2]
         { info_tbl: [(ccJ7y,
                       label: GHC.Stats.$fShowGCDetails1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ7y: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           call GHC.Stats.$fShowGCDetails_$cshowsPrec_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.24252915 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_$cshowList_closure" {
     GHC.Stats.$fShowGCDetails_$cshowList_closure:
         const GHC.Stats.$fShowGCDetails_$cshowList_info;
         const 0;
 },
 GHC.Stats.$fShowGCDetails_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(ccJ7F,
                       label: GHC.Stats.$fShowGCDetails_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ7F: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.243317569 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_closure" {
     GHC.Stats.$fShowGCDetails_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Stats.$fShowGCDetails_$cshowsPrec_closure+2;
         const GHC.Stats.$fShowGCDetails_$cshow_closure+1;
         const GHC.Stats.$fShowGCDetails_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.24395866 UTC

[section ""cstring" . lvl16_rcHpL_bytes" {
     lvl16_rcHpL_bytes:
         I8[] [82,84,83,83,116,97,116,115,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.244507745 UTC

[section ""cstring" . lvl17_rcHpM_bytes" {
     lvl17_rcHpM_bytes:
         I8[] [103,99,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.245070357 UTC

[section ""cstring" . lvl18_rcHpN_bytes" {
     lvl18_rcHpN_bytes:
         I8[] [109,97,106,111,114,95,103,99,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.245671145 UTC

[section ""cstring" . lvl19_rcHpO_bytes" {
     lvl19_rcHpO_bytes:
         I8[] [97,108,108,111,99,97,116,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.24623933 UTC

[section ""cstring" . lvl20_rcHpP_bytes" {
     lvl20_rcHpP_bytes:
         I8[] [109,97,120,95,108,105,118,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.246804045 UTC

[section ""cstring" . lvl21_rcHpQ_bytes" {
     lvl21_rcHpQ_bytes:
         I8[] [109,97,120,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.247343465 UTC

[section ""cstring" . lvl22_rcHpR_bytes" {
     lvl22_rcHpR_bytes:
         I8[] [109,97,120,95,99,111,109,112,97,99,116,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.2479107 UTC

[section ""cstring" . lvl23_rcHpS_bytes" {
     lvl23_rcHpS_bytes:
         I8[] [109,97,120,95,115,108,111,112,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.248454074 UTC

[section ""cstring" . lvl24_rcHpT_bytes" {
     lvl24_rcHpT_bytes:
         I8[] [109,97,120,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.249034637 UTC

[section ""cstring" . lvl25_rcHpU_bytes" {
     lvl25_rcHpU_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,108,105,118,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.249627675 UTC

[section ""cstring" . lvl26_rcHpV_bytes" {
     lvl26_rcHpV_bytes:
         I8[] [99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.25019314 UTC

[section ""cstring" . lvl27_rcHpW_bytes" {
     lvl27_rcHpW_bytes:
         I8[] [112,97,114,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.250756465 UTC

[section ""cstring" . lvl28_rcHpX_bytes" {
     lvl28_rcHpX_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.251350573 UTC

[section ""cstring" . lvl29_rcHpY_bytes" {
     lvl29_rcHpY_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.251960701 UTC

[section ""cstring" . lvl30_rcHpZ_bytes" {
     lvl30_rcHpZ_bytes:
         I8[] [109,117,116,97,116,111,114,95,99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.252574567 UTC

[section ""cstring" . lvl31_rcHq0_bytes" {
     lvl31_rcHq0_bytes:
         I8[] [109,117,116,97,116,111,114,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.253151986 UTC

[section ""cstring" . lvl32_rcHq1_bytes" {
     lvl32_rcHq1_bytes:
         I8[] [103,99,95,99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.253848713 UTC

[section ""cstring" . lvl33_rcHq2_bytes" {
     lvl33_rcHq2_bytes:
         I8[] [103,99,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.254442914 UTC

[section ""cstring" . lvl34_rcHq3_bytes" {
     lvl34_rcHq3_bytes:
         I8[] [99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.25619272 UTC

[section ""cstring" . lvl35_rcHq4_bytes" {
     lvl35_rcHq4_bytes:
         I8[] [101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.256729491 UTC

[section ""cstring" . lvl36_rcHq5_bytes" {
     lvl36_rcHq5_bytes:
         I8[] [103,99,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.277707974 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_$cshowsPrec_closure" {
     GHC.Stats.$fShowRTSStats_$cshowsPrec_closure:
         const GHC.Stats.$fShowRTSStats_$cshowsPrec_info;
         const 0;
 },
 w1_scHvi_entry() //  [R1]
         { info_tbl: [(ccJ83,
                       label: w1_scHvi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ83: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ84; else goto ccJ85;
       ccJ84: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ85: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccJ80_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucJ8h; else goto ccJ81;
       ucJ8h: // global
           call _ccJ80(R1) args: 0, res: 0, upd: 0;
       ccJ81: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ80() //  [R1]
         { info_tbl: [(ccJ80,
                       label: block_ccJ80_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ80: // global
           _scHvk::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvk::I64, 0)) goto ccJ8f; else goto ccJ8g;
       ccJ8f: // global
           R2 = _scHvk::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccJ8g: // global
           R2 = _scHvk::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w2_scHvn_entry() //  [R1]
         { info_tbl: [(ccJ8p,
                       label: w2_scHvn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ8p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ8q; else goto ccJ8r;
       ccJ8q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ8r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccJ8m_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucJ8D; else goto ccJ8n;
       ucJ8D: // global
           call _ccJ8m(R1) args: 0, res: 0, upd: 0;
       ccJ8n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ8m() //  [R1]
         { info_tbl: [(ccJ8m,
                       label: block_ccJ8m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ8m: // global
           _scHvp::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvp::I64, 0)) goto ccJ8B; else goto ccJ8C;
       ccJ8B: // global
           R2 = _scHvp::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccJ8C: // global
           R2 = _scHvp::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w3_scHvs_entry() //  [R1]
         { info_tbl: [(ccJ8L,
                       label: w3_scHvs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ8L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ8M; else goto ccJ8N;
       ccJ8M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ8N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccJ8I_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucJ8Z; else goto ccJ8J;
       ucJ8Z: // global
           call _ccJ8I(R1) args: 0, res: 0, upd: 0;
       ccJ8J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ8I() //  [R1]
         { info_tbl: [(ccJ8I,
                       label: block_ccJ8I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ8I: // global
           _scHvu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvu::I64, 0)) goto ccJ8X; else goto ccJ8Y;
       ccJ8X: // global
           R2 = _scHvu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccJ8Y: // global
           R2 = _scHvu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w4_scHvx_entry() //  [R1]
         { info_tbl: [(ccJ97,
                       label: w4_scHvx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ97: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ98; else goto ccJ99;
       ccJ98: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ99: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccJ94_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucJ9l; else goto ccJ95;
       ucJ9l: // global
           call _ccJ94(R1) args: 0, res: 0, upd: 0;
       ccJ95: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ94() //  [R1]
         { info_tbl: [(ccJ94,
                       label: block_ccJ94_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ94: // global
           _scHvz::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvz::I64, 0)) goto ccJ9j; else goto ccJ9k;
       ccJ9j: // global
           R2 = _scHvz::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccJ9k: // global
           R2 = _scHvz::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_scHvC_entry() //  [R1]
         { info_tbl: [(ccJ9t,
                       label: w5_scHvC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ9t: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ9u; else goto ccJ9v;
       ccJ9u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ9v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccJ9q_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucJ9H; else goto ccJ9r;
       ucJ9H: // global
           call _ccJ9q(R1) args: 0, res: 0, upd: 0;
       ccJ9r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ9q() //  [R1]
         { info_tbl: [(ccJ9q,
                       label: block_ccJ9q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ9q: // global
           _scHvE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvE::I64, 0)) goto ccJ9F; else goto ccJ9G;
       ccJ9F: // global
           R2 = _scHvE::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccJ9G: // global
           R2 = _scHvE::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_scHvH_entry() //  [R1]
         { info_tbl: [(ccJ9P,
                       label: w6_scHvH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ9P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccJ9Q; else goto ccJ9R;
       ccJ9Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJ9R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccJ9M_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucJa3; else goto ccJ9N;
       ucJa3: // global
           call _ccJ9M(R1) args: 0, res: 0, upd: 0;
       ccJ9N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJ9M() //  [R1]
         { info_tbl: [(ccJ9M,
                       label: block_ccJ9M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ9M: // global
           _scHvJ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvJ::I64, 0)) goto ccJa1; else goto ccJa2;
       ccJa1: // global
           R2 = _scHvJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccJa2: // global
           R2 = _scHvJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_scHvM_entry() //  [R1]
         { info_tbl: [(ccJab,
                       label: w7_scHvM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJab: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccJac; else goto ccJad;
       ccJac: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJad: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccJa8_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucJap; else goto ccJa9;
       ucJap: // global
           call _ccJa8(R1) args: 0, res: 0, upd: 0;
       ccJa9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJa8() //  [R1]
         { info_tbl: [(ccJa8,
                       label: block_ccJa8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJa8: // global
           _scHvO::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvO::I64, 0)) goto ccJan; else goto ccJao;
       ccJan: // global
           R2 = _scHvO::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccJao: // global
           R2 = _scHvO::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w8_scHvR_entry() //  [R1]
         { info_tbl: [(ccJax,
                       label: w8_scHvR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJax: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccJay; else goto ccJaz;
       ccJay: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJaz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccJau_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucJaL; else goto ccJav;
       ucJaL: // global
           call _ccJau(R1) args: 0, res: 0, upd: 0;
       ccJav: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJau() //  [R1]
         { info_tbl: [(ccJau,
                       label: block_ccJau_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJau: // global
           _scHvT::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvT::I64, 0)) goto ccJaJ; else goto ccJaK;
       ccJaJ: // global
           R2 = _scHvT::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccJaK: // global
           R2 = _scHvT::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w9_scHvW_entry() //  [R1]
         { info_tbl: [(ccJaT,
                       label: w9_scHvW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJaT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccJaU; else goto ccJaV;
       ccJaU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJaV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccJaQ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucJb7; else goto ccJaR;
       ucJb7: // global
           call _ccJaQ(R1) args: 0, res: 0, upd: 0;
       ccJaR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJaQ() //  [R1]
         { info_tbl: [(ccJaQ,
                       label: block_ccJaQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJaQ: // global
           _scHvY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvY::I64, 0)) goto ccJb5; else goto ccJb6;
       ccJb5: // global
           R2 = _scHvY::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccJb6: // global
           R2 = _scHvY::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w10_scHw1_entry() //  [R1]
         { info_tbl: [(ccJbf,
                       label: w10_scHw1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJbf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccJbg; else goto ccJbh;
       ccJbg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJbh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccJbc_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucJbt; else goto ccJbd;
       ucJbt: // global
           call _ccJbc(R1) args: 0, res: 0, upd: 0;
       ccJbd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJbc() //  [R1]
         { info_tbl: [(ccJbc,
                       label: block_ccJbc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJbc: // global
           _scHw3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHw3::I64, 0)) goto ccJbr; else goto ccJbs;
       ccJbr: // global
           R2 = _scHw3::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccJbs: // global
           R2 = _scHw3::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w11_scHw6_entry() //  [R1]
         { info_tbl: [(ccJbB,
                       label: w11_scHw6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJbB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccJbC; else goto ccJbD;
       ccJbC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJbD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccJby_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucJbP; else goto ccJbz;
       ucJbP: // global
           call _ccJby(R1) args: 0, res: 0, upd: 0;
       ccJbz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJby() //  [R1]
         { info_tbl: [(ccJby,
                       label: block_ccJby_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJby: // global
           _scHw8::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHw8::I64, 0)) goto ccJbN; else goto ccJbO;
       ccJbN: // global
           R2 = _scHw8::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccJbO: // global
           R2 = _scHw8::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 f_scHwb_entry() //  [R1]
         { info_tbl: [(ccJbU,
                       label: f_scHwb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJbU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJbV; else goto ccJbW;
       ccJbV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJbW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           Sp = Sp - 16;
           call GHC.Stats.$fShowGCDetails_$cshowsPrec_entry(R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHww_entry() //  [R1]
         { info_tbl: [(ccJgy,
                       label: sat_scHww_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJgy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJgz; else goto ccJgA;
       ccJgz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJgA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = lvl15_rcHpK_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwx_entry() //  [R1]
         { info_tbl: [(ccJgB,
                       label: sat_scHwx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJgB: // global
           _scHwx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJgC; else goto ccJgD;
       ccJgD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJgF; else goto ccJgE;
       ccJgF: // global
           HpAlloc = 24;
           goto ccJgC;
       ccJgC: // global
           R1 = _scHwx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJgE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwx::P64;
           _scHwb::P64 = P64[_scHwx::P64 + 16];
           _scHwd::P64 = P64[_scHwx::P64 + 24];
           I64[Hp - 16] = sat_scHww_info;
           P64[Hp] = _scHwd::P64;
           R2 = Hp - 16;
           R1 = _scHwb::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwy_entry() //  [R1]
         { info_tbl: [(ccJgG,
                       label: sat_scHwy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJgG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccJgK; else goto ccJgJ;
       ccJgK: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJgJ: // global
           _scHwb::P64 = P64[R1 + 16];
           _scHwd::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_scHwx_info;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 24;
           R2 = lvl36_rcHq5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwz_entry() //  [R1]
         { info_tbl: [(ccJgL,
                       label: sat_scHwz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJgL: // global
           _scHwz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJgM; else goto ccJgN;
       ccJgN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccJgP; else goto ccJgO;
       ccJgP: // global
           HpAlloc = 32;
           goto ccJgM;
       ccJgM: // global
           R1 = _scHwz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJgO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwz::P64;
           _scHwb::P64 = P64[_scHwz::P64 + 16];
           _scHwd::P64 = P64[_scHwz::P64 + 24];
           I64[Hp - 24] = sat_scHwy_info;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwD_entry() //  [R1]
         { info_tbl: [(ccJgQ,
                       label: sat_scHwD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJgQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccJgU; else goto ccJgV;
       ccJgU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJgV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccJgd_info;
           _scHwb::P64 = P64[R1 + 24];
           _scHwd::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucJh2; else goto ccJge;
       ucJh2: // global
           call _ccJgd(R1) args: 0, res: 0, upd: 0;
       ccJge: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJgd() //  [R1]
         { info_tbl: [(ccJgd,
                       label: block_ccJgd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJgd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccJgY; else goto ccJgX;
       ccJgY: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccJgX: // global
           _scHwv::I64 = I64[R1 + 7];
           I64[Hp - 24] = sat_scHwz_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_ccJgR_info;
           R4 = Hp - 24;
           R3 = _scHwv::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJgR() //  [R1, R2]
         { info_tbl: [(ccJgR,
                       label: block_ccJgR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJgR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJh1; else goto ccJh0;
       ccJh1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJh0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwE_entry() //  [R1]
         { info_tbl: [(ccJh3,
                       label: sat_scHwE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJh3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccJh7; else goto ccJh6;
       ccJh7: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJh6: // global
           _scHve::P64 = P64[R1 + 16];
           _scHwb::P64 = P64[R1 + 24];
           _scHwd::P64 = P64[R1 + 32];
           I64[Hp - 32] = sat_scHwD_info;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 32;
           R2 = lvl35_rcHq4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwF_entry() //  [R1]
         { info_tbl: [(ccJh8,
                       label: sat_scHwF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJh8: // global
           _scHwF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJh9; else goto ccJha;
       ccJha: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccJhc; else goto ccJhb;
       ccJhc: // global
           HpAlloc = 40;
           goto ccJh9;
       ccJh9: // global
           R1 = _scHwF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJhb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwF::P64;
           _scHve::P64 = P64[_scHwF::P64 + 16];
           _scHwb::P64 = P64[_scHwF::P64 + 24];
           _scHwd::P64 = P64[_scHwF::P64 + 32];
           I64[Hp - 32] = sat_scHwE_info;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwJ_entry() //  [R1]
         { info_tbl: [(ccJhd,
                       label: sat_scHwJ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJhd: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccJhh; else goto ccJhi;
       ccJhh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJhi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccJfW_info;
           _scHve::P64 = P64[R1 + 24];
           _scHwb::P64 = P64[R1 + 32];
           _scHwd::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucJhp; else goto ccJfX;
       ucJhp: // global
           call _ccJfW(R1) args: 0, res: 0, upd: 0;
       ccJfX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJfW() //  [R1]
         { info_tbl: [(ccJfW,
                       label: block_ccJfW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJfW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccJhl; else goto ccJhk;
       ccJhl: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccJhk: // global
           _scHwt::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_scHwF_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_ccJhe_info;
           R4 = Hp - 32;
           R3 = _scHwt::I64;
           R2 = 0;
           Sp = Sp + 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJhe() //  [R1, R2]
         { info_tbl: [(ccJhe,
                       label: block_ccJhe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJhe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJho; else goto ccJhn;
       ccJho: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJhn: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwK_entry() //  [R1]
         { info_tbl: [(ccJhq,
                       label: sat_scHwK_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJhq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccJhu; else goto ccJht;
       ccJhu: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJht: // global
           _scHvd::P64 = P64[R1 + 16];
           _scHve::P64 = P64[R1 + 24];
           _scHwb::P64 = P64[R1 + 32];
           _scHwd::P64 = P64[R1 + 40];
           I64[Hp - 40] = sat_scHwJ_info;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 40;
           R2 = lvl34_rcHq3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwL_entry() //  [R1]
         { info_tbl: [(ccJhv,
                       label: sat_scHwL_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJhv: // global
           _scHwL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJhw; else goto ccJhx;
       ccJhx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccJhz; else goto ccJhy;
       ccJhz: // global
           HpAlloc = 48;
           goto ccJhw;
       ccJhw: // global
           R1 = _scHwL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJhy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwL::P64;
           _scHvd::P64 = P64[_scHwL::P64 + 16];
           _scHve::P64 = P64[_scHwL::P64 + 24];
           _scHwb::P64 = P64[_scHwL::P64 + 32];
           _scHwd::P64 = P64[_scHwL::P64 + 40];
           I64[Hp - 40] = sat_scHwK_info;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 40;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwP_entry() //  [R1]
         { info_tbl: [(ccJhA,
                       label: sat_scHwP_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJhA: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccJhE; else goto ccJhF;
       ccJhE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJhF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_ccJfF_info;
           _scHvd::P64 = P64[R1 + 24];
           _scHve::P64 = P64[R1 + 32];
           _scHwb::P64 = P64[R1 + 40];
           _scHwd::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _scHvd::P64;
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ucJhM; else goto ccJfG;
       ucJhM: // global
           call _ccJfF(R1) args: 0, res: 0, upd: 0;
       ccJfG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJfF() //  [R1]
         { info_tbl: [(ccJfF,
                       label: block_ccJfF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJfF: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccJhI; else goto ccJhH;
       ccJhI: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccJhH: // global
           _scHwr::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_scHwL_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           I64[Sp + 32] = block_ccJhB_info;
           R4 = Hp - 40;
           R3 = _scHwr::I64;
           R2 = 0;
           Sp = Sp + 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJhB() //  [R1, R2]
         { info_tbl: [(ccJhB,
                       label: block_ccJhB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJhB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJhL; else goto ccJhK;
       ccJhL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJhK: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwQ_entry() //  [R1]
         { info_tbl: [(ccJhN,
                       label: sat_scHwQ_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJhN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccJhR; else goto ccJhQ;
       ccJhR: // global
           HpAlloc = 56;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJhQ: // global
           _scHvc::P64 = P64[R1 + 16];
           _scHvd::P64 = P64[R1 + 24];
           _scHve::P64 = P64[R1 + 32];
           _scHwb::P64 = P64[R1 + 40];
           _scHwd::P64 = P64[R1 + 48];
           I64[Hp - 48] = sat_scHwP_info;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 48;
           R2 = lvl33_rcHq2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwR_entry() //  [R1]
         { info_tbl: [(ccJhS,
                       label: sat_scHwR_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJhS: // global
           _scHwR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJhT; else goto ccJhU;
       ccJhU: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccJhW; else goto ccJhV;
       ccJhW: // global
           HpAlloc = 56;
           goto ccJhT;
       ccJhT: // global
           R1 = _scHwR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJhV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwR::P64;
           _scHvc::P64 = P64[_scHwR::P64 + 16];
           _scHvd::P64 = P64[_scHwR::P64 + 24];
           _scHve::P64 = P64[_scHwR::P64 + 32];
           _scHwb::P64 = P64[_scHwR::P64 + 40];
           _scHwd::P64 = P64[_scHwR::P64 + 48];
           I64[Hp - 48] = sat_scHwQ_info;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 48;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwV_entry() //  [R1]
         { info_tbl: [(ccJhX,
                       label: sat_scHwV_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJhX: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccJi1; else goto ccJi2;
       ccJi1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJi2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_ccJfo_info;
           _scHvc::P64 = P64[R1 + 24];
           _scHvd::P64 = P64[R1 + 32];
           _scHve::P64 = P64[R1 + 40];
           _scHwb::P64 = P64[R1 + 48];
           _scHwd::P64 = P64[R1 + 56];
           R1 = P64[R1 + 16];
           P64[Sp - 56] = _scHvc::P64;
           P64[Sp - 48] = _scHvd::P64;
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ucJi9; else goto ccJfp;
       ucJi9: // global
           call _ccJfo(R1) args: 0, res: 0, upd: 0;
       ccJfp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJfo() //  [R1]
         { info_tbl: [(ccJfo,
                       label: block_ccJfo_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJfo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccJi5; else goto ccJi4;
       ccJi5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccJi4: // global
           _scHwp::I64 = I64[R1 + 7];
           I64[Hp - 48] = sat_scHwR_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 40] = block_ccJhY_info;
           R4 = Hp - 48;
           R3 = _scHwp::I64;
           R2 = 0;
           Sp = Sp + 40;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJhY() //  [R1, R2]
         { info_tbl: [(ccJhY,
                       label: block_ccJhY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJhY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJi8; else goto ccJi7;
       ccJi8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJi7: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwW_entry() //  [R1]
         { info_tbl: [(ccJia,
                       label: sat_scHwW_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJia: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccJie; else goto ccJid;
       ccJie: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJid: // global
           _scHvb::P64 = P64[R1 + 16];
           _scHvc::P64 = P64[R1 + 24];
           _scHvd::P64 = P64[R1 + 32];
           _scHve::P64 = P64[R1 + 40];
           _scHwb::P64 = P64[R1 + 48];
           _scHwd::P64 = P64[R1 + 56];
           I64[Hp - 56] = sat_scHwV_info;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 56;
           R2 = lvl32_rcHq1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwX_entry() //  [R1]
         { info_tbl: [(ccJif,
                       label: sat_scHwX_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJif: // global
           _scHwX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJig; else goto ccJih;
       ccJih: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccJij; else goto ccJii;
       ccJij: // global
           HpAlloc = 64;
           goto ccJig;
       ccJig: // global
           R1 = _scHwX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJii: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwX::P64;
           _scHvb::P64 = P64[_scHwX::P64 + 16];
           _scHvc::P64 = P64[_scHwX::P64 + 24];
           _scHvd::P64 = P64[_scHwX::P64 + 32];
           _scHve::P64 = P64[_scHwX::P64 + 40];
           _scHwb::P64 = P64[_scHwX::P64 + 48];
           _scHwd::P64 = P64[_scHwX::P64 + 56];
           I64[Hp - 56] = sat_scHwW_info;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 56;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHx1_entry() //  [R1]
         { info_tbl: [(ccJik,
                       label: sat_scHx1_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJik: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccJio; else goto ccJip;
       ccJio: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJip: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_ccJf7_info;
           _scHvb::P64 = P64[R1 + 24];
           _scHvc::P64 = P64[R1 + 32];
           _scHvd::P64 = P64[R1 + 40];
           _scHve::P64 = P64[R1 + 48];
           _scHwb::P64 = P64[R1 + 56];
           _scHwd::P64 = P64[R1 + 64];
           R1 = P64[R1 + 16];
           P64[Sp - 64] = _scHvb::P64;
           P64[Sp - 56] = _scHvc::P64;
           P64[Sp - 48] = _scHvd::P64;
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto ucJiw; else goto ccJf8;
       ucJiw: // global
           call _ccJf7(R1) args: 0, res: 0, upd: 0;
       ccJf8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJf7() //  [R1]
         { info_tbl: [(ccJf7,
                       label: block_ccJf7_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJf7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccJis; else goto ccJir;
       ccJis: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccJir: // global
           _scHwn::I64 = I64[R1 + 7];
           I64[Hp - 56] = sat_scHwX_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 48];
           I64[Sp + 48] = block_ccJil_info;
           R4 = Hp - 56;
           R3 = _scHwn::I64;
           R2 = 0;
           Sp = Sp + 48;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJil() //  [R1, R2]
         { info_tbl: [(ccJil,
                       label: block_ccJil_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJil: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJiv; else goto ccJiu;
       ccJiv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJiu: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHx2_entry() //  [R1]
         { info_tbl: [(ccJix,
                       label: sat_scHx2_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJix: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccJiB; else goto ccJiA;
       ccJiB: // global
           HpAlloc = 72;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJiA: // global
           _scHva::P64 = P64[R1 + 16];
           _scHvb::P64 = P64[R1 + 24];
           _scHvc::P64 = P64[R1 + 32];
           _scHvd::P64 = P64[R1 + 40];
           _scHve::P64 = P64[R1 + 48];
           _scHwb::P64 = P64[R1 + 56];
           _scHwd::P64 = P64[R1 + 64];
           I64[Hp - 64] = sat_scHx1_info;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 64;
           R2 = lvl31_rcHq0_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHx3_entry() //  [R1]
         { info_tbl: [(ccJiC,
                       label: sat_scHx3_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJiC: // global
           _scHx3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJiD; else goto ccJiE;
       ccJiE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccJiG; else goto ccJiF;
       ccJiG: // global
           HpAlloc = 72;
           goto ccJiD;
       ccJiD: // global
           R1 = _scHx3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJiF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHx3::P64;
           _scHva::P64 = P64[_scHx3::P64 + 16];
           _scHvb::P64 = P64[_scHx3::P64 + 24];
           _scHvc::P64 = P64[_scHx3::P64 + 32];
           _scHvd::P64 = P64[_scHx3::P64 + 40];
           _scHve::P64 = P64[_scHx3::P64 + 48];
           _scHwb::P64 = P64[_scHx3::P64 + 56];
           _scHwd::P64 = P64[_scHx3::P64 + 64];
           I64[Hp - 64] = sat_scHx2_info;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 64;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHx7_entry() //  [R1]
         { info_tbl: [(ccJiH,
                       label: sat_scHx7_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJiH: // global
           if ((Sp + -80) < SpLim) (likely: False) goto ccJiL; else goto ccJiM;
       ccJiL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJiM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 80] = block_ccJeQ_info;
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHwb::P64 = P64[R1 + 64];
           _scHwd::P64 = P64[R1 + 72];
           R1 = P64[R1 + 16];
           P64[Sp - 72] = _scHva::P64;
           P64[Sp - 64] = _scHvb::P64;
           P64[Sp - 56] = _scHvc::P64;
           P64[Sp - 48] = _scHvd::P64;
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto ucJiT; else goto ccJeR;
       ucJiT: // global
           call _ccJeQ(R1) args: 0, res: 0, upd: 0;
       ccJeR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJeQ() //  [R1]
         { info_tbl: [(ccJeQ,
                       label: block_ccJeQ_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJeQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccJiP; else goto ccJiO;
       ccJiP: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccJiO: // global
           _scHwl::I64 = I64[R1 + 7];
           I64[Hp - 64] = sat_scHx3_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 56];
           I64[Sp + 56] = block_ccJiI_info;
           R4 = Hp - 64;
           R3 = _scHwl::I64;
           R2 = 0;
           Sp = Sp + 56;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJiI() //  [R1, R2]
         { info_tbl: [(ccJiI,
                       label: block_ccJiI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJiI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJiS; else goto ccJiR;
       ccJiS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJiR: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHx8_entry() //  [R1]
         { info_tbl: [(ccJiU,
                       label: sat_scHx8_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJiU: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccJiY; else goto ccJiX;
       ccJiY: // global
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJiX: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHwb::P64 = P64[R1 + 64];
           _scHwd::P64 = P64[R1 + 72];
           I64[Hp - 72] = sat_scHx7_info;
           P64[Hp - 56] = _scHv9::P64;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 72;
           R2 = lvl30_rcHpZ_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHx9_entry() //  [R1]
         { info_tbl: [(ccJiZ,
                       label: sat_scHx9_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJiZ: // global
           _scHx9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJj0; else goto ccJj1;
       ccJj1: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccJj3; else goto ccJj2;
       ccJj3: // global
           HpAlloc = 80;
           goto ccJj0;
       ccJj0: // global
           R1 = _scHx9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJj2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHx9::P64;
           _scHv9::P64 = P64[_scHx9::P64 + 16];
           _scHva::P64 = P64[_scHx9::P64 + 24];
           _scHvb::P64 = P64[_scHx9::P64 + 32];
           _scHvc::P64 = P64[_scHx9::P64 + 40];
           _scHvd::P64 = P64[_scHx9::P64 + 48];
           _scHve::P64 = P64[_scHx9::P64 + 56];
           _scHwb::P64 = P64[_scHx9::P64 + 64];
           _scHwd::P64 = P64[_scHx9::P64 + 72];
           I64[Hp - 72] = sat_scHx8_info;
           P64[Hp - 56] = _scHv9::P64;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 72;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxd_entry() //  [R1]
         { info_tbl: [(ccJj7,
                       label: sat_scHxd_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJj7: // global
           _scHxd::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJj8; else goto ccJj9;
       ccJj9: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccJjb; else goto ccJja;
       ccJjb: // global
           HpAlloc = 80;
           goto ccJj8;
       ccJj8: // global
           R1 = _scHxd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJja: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxd::P64;
           _scHv9::P64 = P64[_scHxd::P64 + 16];
           _scHva::P64 = P64[_scHxd::P64 + 24];
           _scHvb::P64 = P64[_scHxd::P64 + 32];
           _scHvc::P64 = P64[_scHxd::P64 + 40];
           _scHvd::P64 = P64[_scHxd::P64 + 48];
           _scHve::P64 = P64[_scHxd::P64 + 56];
           _scHw6::P64 = P64[_scHxd::P64 + 64];
           _scHwb::P64 = P64[_scHxd::P64 + 72];
           _scHwd::P64 = P64[_scHxd::P64 + 80];
           I64[Hp - 72] = sat_scHx9_info;
           P64[Hp - 56] = _scHv9::P64;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccJj4_info;
           R4 = Hp - 72;
           R3 = _scHw6::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJj4() //  [R1, R2]
         { info_tbl: [(ccJj4,
                       label: block_ccJj4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJj4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJje; else goto ccJjd;
       ccJje: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJjd: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxe_entry() //  [R1]
         { info_tbl: [(ccJjf,
                       label: sat_scHxe_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJjf: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccJjj; else goto ccJji;
       ccJjj: // global
           HpAlloc = 88;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJji: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHw6::P64 = P64[R1 + 64];
           _scHwb::P64 = P64[R1 + 72];
           _scHwd::P64 = P64[R1 + 80];
           I64[Hp - 80] = sat_scHxd_info;
           P64[Hp - 64] = _scHv9::P64;
           P64[Hp - 56] = _scHva::P64;
           P64[Hp - 48] = _scHvb::P64;
           P64[Hp - 40] = _scHvc::P64;
           P64[Hp - 32] = _scHvd::P64;
           P64[Hp - 24] = _scHve::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 80;
           R2 = lvl29_rcHpY_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxf_entry() //  [R1]
         { info_tbl: [(ccJjk,
                       label: sat_scHxf_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJjk: // global
           _scHxf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJjl; else goto ccJjm;
       ccJjm: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccJjo; else goto ccJjn;
       ccJjo: // global
           HpAlloc = 88;
           goto ccJjl;
       ccJjl: // global
           R1 = _scHxf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJjn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxf::P64;
           _scHv9::P64 = P64[_scHxf::P64 + 16];
           _scHva::P64 = P64[_scHxf::P64 + 24];
           _scHvb::P64 = P64[_scHxf::P64 + 32];
           _scHvc::P64 = P64[_scHxf::P64 + 40];
           _scHvd::P64 = P64[_scHxf::P64 + 48];
           _scHve::P64 = P64[_scHxf::P64 + 56];
           _scHw6::P64 = P64[_scHxf::P64 + 64];
           _scHwb::P64 = P64[_scHxf::P64 + 72];
           _scHwd::P64 = P64[_scHxf::P64 + 80];
           I64[Hp - 80] = sat_scHxe_info;
           P64[Hp - 64] = _scHv9::P64;
           P64[Hp - 56] = _scHva::P64;
           P64[Hp - 48] = _scHvb::P64;
           P64[Hp - 40] = _scHvc::P64;
           P64[Hp - 32] = _scHvd::P64;
           P64[Hp - 24] = _scHve::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 80;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxj_entry() //  [R1]
         { info_tbl: [(ccJjs,
                       label: sat_scHxj_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJjs: // global
           _scHxj::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJjt; else goto ccJju;
       ccJju: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccJjw; else goto ccJjv;
       ccJjw: // global
           HpAlloc = 88;
           goto ccJjt;
       ccJjt: // global
           R1 = _scHxj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJjv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxj::P64;
           _scHv9::P64 = P64[_scHxj::P64 + 16];
           _scHva::P64 = P64[_scHxj::P64 + 24];
           _scHvb::P64 = P64[_scHxj::P64 + 32];
           _scHvc::P64 = P64[_scHxj::P64 + 40];
           _scHvd::P64 = P64[_scHxj::P64 + 48];
           _scHve::P64 = P64[_scHxj::P64 + 56];
           _scHw1::P64 = P64[_scHxj::P64 + 64];
           _scHw6::P64 = P64[_scHxj::P64 + 72];
           _scHwb::P64 = P64[_scHxj::P64 + 80];
           _scHwd::P64 = P64[_scHxj::P64 + 88];
           I64[Hp - 80] = sat_scHxf_info;
           P64[Hp - 64] = _scHv9::P64;
           P64[Hp - 56] = _scHva::P64;
           P64[Hp - 48] = _scHvb::P64;
           P64[Hp - 40] = _scHvc::P64;
           P64[Hp - 32] = _scHvd::P64;
           P64[Hp - 24] = _scHve::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccJjp_info;
           R4 = Hp - 80;
           R3 = _scHw1::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJjp() //  [R1, R2]
         { info_tbl: [(ccJjp,
                       label: block_ccJjp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJjp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJjz; else goto ccJjy;
       ccJjz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJjy: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxk_entry() //  [R1]
         { info_tbl: [(ccJjA,
                       label: sat_scHxk_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJjA: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccJjE; else goto ccJjD;
       ccJjE: // global
           HpAlloc = 96;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJjD: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHw1::P64 = P64[R1 + 64];
           _scHw6::P64 = P64[R1 + 72];
           _scHwb::P64 = P64[R1 + 80];
           _scHwd::P64 = P64[R1 + 88];
           I64[Hp - 88] = sat_scHxj_info;
           P64[Hp - 72] = _scHv9::P64;
           P64[Hp - 64] = _scHva::P64;
           P64[Hp - 56] = _scHvb::P64;
           P64[Hp - 48] = _scHvc::P64;
           P64[Hp - 40] = _scHvd::P64;
           P64[Hp - 32] = _scHve::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 88;
           R2 = lvl28_rcHpX_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxl_entry() //  [R1]
         { info_tbl: [(ccJjF,
                       label: sat_scHxl_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJjF: // global
           _scHxl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJjG; else goto ccJjH;
       ccJjH: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccJjJ; else goto ccJjI;
       ccJjJ: // global
           HpAlloc = 96;
           goto ccJjG;
       ccJjG: // global
           R1 = _scHxl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJjI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxl::P64;
           _scHv9::P64 = P64[_scHxl::P64 + 16];
           _scHva::P64 = P64[_scHxl::P64 + 24];
           _scHvb::P64 = P64[_scHxl::P64 + 32];
           _scHvc::P64 = P64[_scHxl::P64 + 40];
           _scHvd::P64 = P64[_scHxl::P64 + 48];
           _scHve::P64 = P64[_scHxl::P64 + 56];
           _scHw1::P64 = P64[_scHxl::P64 + 64];
           _scHw6::P64 = P64[_scHxl::P64 + 72];
           _scHwb::P64 = P64[_scHxl::P64 + 80];
           _scHwd::P64 = P64[_scHxl::P64 + 88];
           I64[Hp - 88] = sat_scHxk_info;
           P64[Hp - 72] = _scHv9::P64;
           P64[Hp - 64] = _scHva::P64;
           P64[Hp - 56] = _scHvb::P64;
           P64[Hp - 48] = _scHvc::P64;
           P64[Hp - 40] = _scHvd::P64;
           P64[Hp - 32] = _scHve::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 88;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxp_entry() //  [R1]
         { info_tbl: [(ccJjN,
                       label: sat_scHxp_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJjN: // global
           _scHxp::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJjO; else goto ccJjP;
       ccJjP: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccJjR; else goto ccJjQ;
       ccJjR: // global
           HpAlloc = 96;
           goto ccJjO;
       ccJjO: // global
           R1 = _scHxp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJjQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxp::P64;
           _scHv9::P64 = P64[_scHxp::P64 + 16];
           _scHva::P64 = P64[_scHxp::P64 + 24];
           _scHvb::P64 = P64[_scHxp::P64 + 32];
           _scHvc::P64 = P64[_scHxp::P64 + 40];
           _scHvd::P64 = P64[_scHxp::P64 + 48];
           _scHve::P64 = P64[_scHxp::P64 + 56];
           _scHvW::P64 = P64[_scHxp::P64 + 64];
           _scHw1::P64 = P64[_scHxp::P64 + 72];
           _scHw6::P64 = P64[_scHxp::P64 + 80];
           _scHwb::P64 = P64[_scHxp::P64 + 88];
           _scHwd::P64 = P64[_scHxp::P64 + 96];
           I64[Hp - 88] = sat_scHxl_info;
           P64[Hp - 72] = _scHv9::P64;
           P64[Hp - 64] = _scHva::P64;
           P64[Hp - 56] = _scHvb::P64;
           P64[Hp - 48] = _scHvc::P64;
           P64[Hp - 40] = _scHvd::P64;
           P64[Hp - 32] = _scHve::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccJjK_info;
           R4 = Hp - 88;
           R3 = _scHvW::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJjK() //  [R1, R2]
         { info_tbl: [(ccJjK,
                       label: block_ccJjK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJjK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJjU; else goto ccJjT;
       ccJjU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJjT: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxq_entry() //  [R1]
         { info_tbl: [(ccJjV,
                       label: sat_scHxq_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJjV: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccJjZ; else goto ccJjY;
       ccJjZ: // global
           HpAlloc = 104;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJjY: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvW::P64 = P64[R1 + 64];
           _scHw1::P64 = P64[R1 + 72];
           _scHw6::P64 = P64[R1 + 80];
           _scHwb::P64 = P64[R1 + 88];
           _scHwd::P64 = P64[R1 + 96];
           I64[Hp - 96] = sat_scHxp_info;
           P64[Hp - 80] = _scHv9::P64;
           P64[Hp - 72] = _scHva::P64;
           P64[Hp - 64] = _scHvb::P64;
           P64[Hp - 56] = _scHvc::P64;
           P64[Hp - 48] = _scHvd::P64;
           P64[Hp - 40] = _scHve::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 96;
           R2 = lvl27_rcHpW_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxr_entry() //  [R1]
         { info_tbl: [(ccJk0,
                       label: sat_scHxr_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJk0: // global
           _scHxr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJk1; else goto ccJk2;
       ccJk2: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccJk4; else goto ccJk3;
       ccJk4: // global
           HpAlloc = 104;
           goto ccJk1;
       ccJk1: // global
           R1 = _scHxr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJk3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxr::P64;
           _scHv9::P64 = P64[_scHxr::P64 + 16];
           _scHva::P64 = P64[_scHxr::P64 + 24];
           _scHvb::P64 = P64[_scHxr::P64 + 32];
           _scHvc::P64 = P64[_scHxr::P64 + 40];
           _scHvd::P64 = P64[_scHxr::P64 + 48];
           _scHve::P64 = P64[_scHxr::P64 + 56];
           _scHvW::P64 = P64[_scHxr::P64 + 64];
           _scHw1::P64 = P64[_scHxr::P64 + 72];
           _scHw6::P64 = P64[_scHxr::P64 + 80];
           _scHwb::P64 = P64[_scHxr::P64 + 88];
           _scHwd::P64 = P64[_scHxr::P64 + 96];
           I64[Hp - 96] = sat_scHxq_info;
           P64[Hp - 80] = _scHv9::P64;
           P64[Hp - 72] = _scHva::P64;
           P64[Hp - 64] = _scHvb::P64;
           P64[Hp - 56] = _scHvc::P64;
           P64[Hp - 48] = _scHvd::P64;
           P64[Hp - 40] = _scHve::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 96;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxv_entry() //  [R1]
         { info_tbl: [(ccJk8,
                       label: sat_scHxv_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJk8: // global
           _scHxv::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJk9; else goto ccJka;
       ccJka: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccJkc; else goto ccJkb;
       ccJkc: // global
           HpAlloc = 104;
           goto ccJk9;
       ccJk9: // global
           R1 = _scHxv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJkb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxv::P64;
           _scHv9::P64 = P64[_scHxv::P64 + 16];
           _scHva::P64 = P64[_scHxv::P64 + 24];
           _scHvb::P64 = P64[_scHxv::P64 + 32];
           _scHvc::P64 = P64[_scHxv::P64 + 40];
           _scHvd::P64 = P64[_scHxv::P64 + 48];
           _scHve::P64 = P64[_scHxv::P64 + 56];
           _scHvR::P64 = P64[_scHxv::P64 + 64];
           _scHvW::P64 = P64[_scHxv::P64 + 72];
           _scHw1::P64 = P64[_scHxv::P64 + 80];
           _scHw6::P64 = P64[_scHxv::P64 + 88];
           _scHwb::P64 = P64[_scHxv::P64 + 96];
           _scHwd::P64 = P64[_scHxv::P64 + 104];
           I64[Hp - 96] = sat_scHxr_info;
           P64[Hp - 80] = _scHv9::P64;
           P64[Hp - 72] = _scHva::P64;
           P64[Hp - 64] = _scHvb::P64;
           P64[Hp - 56] = _scHvc::P64;
           P64[Hp - 48] = _scHvd::P64;
           P64[Hp - 40] = _scHve::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccJk5_info;
           R4 = Hp - 96;
           R3 = _scHvR::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJk5() //  [R1, R2]
         { info_tbl: [(ccJk5,
                       label: block_ccJk5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJk5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJkf; else goto ccJke;
       ccJkf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJke: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxw_entry() //  [R1]
         { info_tbl: [(ccJkg,
                       label: sat_scHxw_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJkg: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccJkk; else goto ccJkj;
       ccJkk: // global
           HpAlloc = 112;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJkj: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvR::P64 = P64[R1 + 64];
           _scHvW::P64 = P64[R1 + 72];
           _scHw1::P64 = P64[R1 + 80];
           _scHw6::P64 = P64[R1 + 88];
           _scHwb::P64 = P64[R1 + 96];
           _scHwd::P64 = P64[R1 + 104];
           I64[Hp - 104] = sat_scHxv_info;
           P64[Hp - 88] = _scHv9::P64;
           P64[Hp - 80] = _scHva::P64;
           P64[Hp - 72] = _scHvb::P64;
           P64[Hp - 64] = _scHvc::P64;
           P64[Hp - 56] = _scHvd::P64;
           P64[Hp - 48] = _scHve::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 104;
           R2 = lvl26_rcHpV_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxx_entry() //  [R1]
         { info_tbl: [(ccJkl,
                       label: sat_scHxx_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJkl: // global
           _scHxx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJkm; else goto ccJkn;
       ccJkn: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccJkp; else goto ccJko;
       ccJkp: // global
           HpAlloc = 112;
           goto ccJkm;
       ccJkm: // global
           R1 = _scHxx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJko: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxx::P64;
           _scHv9::P64 = P64[_scHxx::P64 + 16];
           _scHva::P64 = P64[_scHxx::P64 + 24];
           _scHvb::P64 = P64[_scHxx::P64 + 32];
           _scHvc::P64 = P64[_scHxx::P64 + 40];
           _scHvd::P64 = P64[_scHxx::P64 + 48];
           _scHve::P64 = P64[_scHxx::P64 + 56];
           _scHvR::P64 = P64[_scHxx::P64 + 64];
           _scHvW::P64 = P64[_scHxx::P64 + 72];
           _scHw1::P64 = P64[_scHxx::P64 + 80];
           _scHw6::P64 = P64[_scHxx::P64 + 88];
           _scHwb::P64 = P64[_scHxx::P64 + 96];
           _scHwd::P64 = P64[_scHxx::P64 + 104];
           I64[Hp - 104] = sat_scHxw_info;
           P64[Hp - 88] = _scHv9::P64;
           P64[Hp - 80] = _scHva::P64;
           P64[Hp - 72] = _scHvb::P64;
           P64[Hp - 64] = _scHvc::P64;
           P64[Hp - 56] = _scHvd::P64;
           P64[Hp - 48] = _scHve::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 104;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxB_entry() //  [R1]
         { info_tbl: [(ccJkt,
                       label: sat_scHxB_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJkt: // global
           _scHxB::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJku; else goto ccJkv;
       ccJkv: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccJkx; else goto ccJkw;
       ccJkx: // global
           HpAlloc = 112;
           goto ccJku;
       ccJku: // global
           R1 = _scHxB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJkw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxB::P64;
           _scHv9::P64 = P64[_scHxB::P64 + 16];
           _scHva::P64 = P64[_scHxB::P64 + 24];
           _scHvb::P64 = P64[_scHxB::P64 + 32];
           _scHvc::P64 = P64[_scHxB::P64 + 40];
           _scHvd::P64 = P64[_scHxB::P64 + 48];
           _scHve::P64 = P64[_scHxB::P64 + 56];
           _scHvM::P64 = P64[_scHxB::P64 + 64];
           _scHvR::P64 = P64[_scHxB::P64 + 72];
           _scHvW::P64 = P64[_scHxB::P64 + 80];
           _scHw1::P64 = P64[_scHxB::P64 + 88];
           _scHw6::P64 = P64[_scHxB::P64 + 96];
           _scHwb::P64 = P64[_scHxB::P64 + 104];
           _scHwd::P64 = P64[_scHxB::P64 + 112];
           I64[Hp - 104] = sat_scHxx_info;
           P64[Hp - 88] = _scHv9::P64;
           P64[Hp - 80] = _scHva::P64;
           P64[Hp - 72] = _scHvb::P64;
           P64[Hp - 64] = _scHvc::P64;
           P64[Hp - 56] = _scHvd::P64;
           P64[Hp - 48] = _scHve::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccJkq_info;
           R4 = Hp - 104;
           R3 = _scHvM::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJkq() //  [R1, R2]
         { info_tbl: [(ccJkq,
                       label: block_ccJkq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJkq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJkA; else goto ccJkz;
       ccJkA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJkz: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxC_entry() //  [R1]
         { info_tbl: [(ccJkB,
                       label: sat_scHxC_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJkB: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccJkF; else goto ccJkE;
       ccJkF: // global
           HpAlloc = 120;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJkE: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvM::P64 = P64[R1 + 64];
           _scHvR::P64 = P64[R1 + 72];
           _scHvW::P64 = P64[R1 + 80];
           _scHw1::P64 = P64[R1 + 88];
           _scHw6::P64 = P64[R1 + 96];
           _scHwb::P64 = P64[R1 + 104];
           _scHwd::P64 = P64[R1 + 112];
           I64[Hp - 112] = sat_scHxB_info;
           P64[Hp - 96] = _scHv9::P64;
           P64[Hp - 88] = _scHva::P64;
           P64[Hp - 80] = _scHvb::P64;
           P64[Hp - 72] = _scHvc::P64;
           P64[Hp - 64] = _scHvd::P64;
           P64[Hp - 56] = _scHve::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 112;
           R2 = lvl25_rcHpU_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxD_entry() //  [R1]
         { info_tbl: [(ccJkG,
                       label: sat_scHxD_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJkG: // global
           _scHxD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJkH; else goto ccJkI;
       ccJkI: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccJkK; else goto ccJkJ;
       ccJkK: // global
           HpAlloc = 120;
           goto ccJkH;
       ccJkH: // global
           R1 = _scHxD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJkJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxD::P64;
           _scHv9::P64 = P64[_scHxD::P64 + 16];
           _scHva::P64 = P64[_scHxD::P64 + 24];
           _scHvb::P64 = P64[_scHxD::P64 + 32];
           _scHvc::P64 = P64[_scHxD::P64 + 40];
           _scHvd::P64 = P64[_scHxD::P64 + 48];
           _scHve::P64 = P64[_scHxD::P64 + 56];
           _scHvM::P64 = P64[_scHxD::P64 + 64];
           _scHvR::P64 = P64[_scHxD::P64 + 72];
           _scHvW::P64 = P64[_scHxD::P64 + 80];
           _scHw1::P64 = P64[_scHxD::P64 + 88];
           _scHw6::P64 = P64[_scHxD::P64 + 96];
           _scHwb::P64 = P64[_scHxD::P64 + 104];
           _scHwd::P64 = P64[_scHxD::P64 + 112];
           I64[Hp - 112] = sat_scHxC_info;
           P64[Hp - 96] = _scHv9::P64;
           P64[Hp - 88] = _scHva::P64;
           P64[Hp - 80] = _scHvb::P64;
           P64[Hp - 72] = _scHvc::P64;
           P64[Hp - 64] = _scHvd::P64;
           P64[Hp - 56] = _scHve::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 112;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxH_entry() //  [R1]
         { info_tbl: [(ccJkO,
                       label: sat_scHxH_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJkO: // global
           _scHxH::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJkP; else goto ccJkQ;
       ccJkQ: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccJkS; else goto ccJkR;
       ccJkS: // global
           HpAlloc = 120;
           goto ccJkP;
       ccJkP: // global
           R1 = _scHxH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJkR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxH::P64;
           _scHv9::P64 = P64[_scHxH::P64 + 16];
           _scHva::P64 = P64[_scHxH::P64 + 24];
           _scHvb::P64 = P64[_scHxH::P64 + 32];
           _scHvc::P64 = P64[_scHxH::P64 + 40];
           _scHvd::P64 = P64[_scHxH::P64 + 48];
           _scHve::P64 = P64[_scHxH::P64 + 56];
           _scHvH::P64 = P64[_scHxH::P64 + 64];
           _scHvM::P64 = P64[_scHxH::P64 + 72];
           _scHvR::P64 = P64[_scHxH::P64 + 80];
           _scHvW::P64 = P64[_scHxH::P64 + 88];
           _scHw1::P64 = P64[_scHxH::P64 + 96];
           _scHw6::P64 = P64[_scHxH::P64 + 104];
           _scHwb::P64 = P64[_scHxH::P64 + 112];
           _scHwd::P64 = P64[_scHxH::P64 + 120];
           I64[Hp - 112] = sat_scHxD_info;
           P64[Hp - 96] = _scHv9::P64;
           P64[Hp - 88] = _scHva::P64;
           P64[Hp - 80] = _scHvb::P64;
           P64[Hp - 72] = _scHvc::P64;
           P64[Hp - 64] = _scHvd::P64;
           P64[Hp - 56] = _scHve::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccJkL_info;
           R4 = Hp - 112;
           R3 = _scHvH::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJkL() //  [R1, R2]
         { info_tbl: [(ccJkL,
                       label: block_ccJkL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJkL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJkV; else goto ccJkU;
       ccJkV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJkU: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxI_entry() //  [R1]
         { info_tbl: [(ccJkW,
                       label: sat_scHxI_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJkW: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccJl0; else goto ccJkZ;
       ccJl0: // global
           HpAlloc = 128;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJkZ: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvH::P64 = P64[R1 + 64];
           _scHvM::P64 = P64[R1 + 72];
           _scHvR::P64 = P64[R1 + 80];
           _scHvW::P64 = P64[R1 + 88];
           _scHw1::P64 = P64[R1 + 96];
           _scHw6::P64 = P64[R1 + 104];
           _scHwb::P64 = P64[R1 + 112];
           _scHwd::P64 = P64[R1 + 120];
           I64[Hp - 120] = sat_scHxH_info;
           P64[Hp - 104] = _scHv9::P64;
           P64[Hp - 96] = _scHva::P64;
           P64[Hp - 88] = _scHvb::P64;
           P64[Hp - 80] = _scHvc::P64;
           P64[Hp - 72] = _scHvd::P64;
           P64[Hp - 64] = _scHve::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 120;
           R2 = lvl24_rcHpT_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxJ_entry() //  [R1]
         { info_tbl: [(ccJl1,
                       label: sat_scHxJ_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJl1: // global
           _scHxJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJl2; else goto ccJl3;
       ccJl3: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccJl5; else goto ccJl4;
       ccJl5: // global
           HpAlloc = 128;
           goto ccJl2;
       ccJl2: // global
           R1 = _scHxJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJl4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxJ::P64;
           _scHv9::P64 = P64[_scHxJ::P64 + 16];
           _scHva::P64 = P64[_scHxJ::P64 + 24];
           _scHvb::P64 = P64[_scHxJ::P64 + 32];
           _scHvc::P64 = P64[_scHxJ::P64 + 40];
           _scHvd::P64 = P64[_scHxJ::P64 + 48];
           _scHve::P64 = P64[_scHxJ::P64 + 56];
           _scHvH::P64 = P64[_scHxJ::P64 + 64];
           _scHvM::P64 = P64[_scHxJ::P64 + 72];
           _scHvR::P64 = P64[_scHxJ::P64 + 80];
           _scHvW::P64 = P64[_scHxJ::P64 + 88];
           _scHw1::P64 = P64[_scHxJ::P64 + 96];
           _scHw6::P64 = P64[_scHxJ::P64 + 104];
           _scHwb::P64 = P64[_scHxJ::P64 + 112];
           _scHwd::P64 = P64[_scHxJ::P64 + 120];
           I64[Hp - 120] = sat_scHxI_info;
           P64[Hp - 104] = _scHv9::P64;
           P64[Hp - 96] = _scHva::P64;
           P64[Hp - 88] = _scHvb::P64;
           P64[Hp - 80] = _scHvc::P64;
           P64[Hp - 72] = _scHvd::P64;
           P64[Hp - 64] = _scHve::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 120;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxN_entry() //  [R1]
         { info_tbl: [(ccJl9,
                       label: sat_scHxN_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJl9: // global
           _scHxN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJla; else goto ccJlb;
       ccJlb: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccJld; else goto ccJlc;
       ccJld: // global
           HpAlloc = 128;
           goto ccJla;
       ccJla: // global
           R1 = _scHxN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJlc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxN::P64;
           _scHv9::P64 = P64[_scHxN::P64 + 16];
           _scHva::P64 = P64[_scHxN::P64 + 24];
           _scHvb::P64 = P64[_scHxN::P64 + 32];
           _scHvc::P64 = P64[_scHxN::P64 + 40];
           _scHvd::P64 = P64[_scHxN::P64 + 48];
           _scHve::P64 = P64[_scHxN::P64 + 56];
           _scHvC::P64 = P64[_scHxN::P64 + 64];
           _scHvH::P64 = P64[_scHxN::P64 + 72];
           _scHvM::P64 = P64[_scHxN::P64 + 80];
           _scHvR::P64 = P64[_scHxN::P64 + 88];
           _scHvW::P64 = P64[_scHxN::P64 + 96];
           _scHw1::P64 = P64[_scHxN::P64 + 104];
           _scHw6::P64 = P64[_scHxN::P64 + 112];
           _scHwb::P64 = P64[_scHxN::P64 + 120];
           _scHwd::P64 = P64[_scHxN::P64 + 128];
           I64[Hp - 120] = sat_scHxJ_info;
           P64[Hp - 104] = _scHv9::P64;
           P64[Hp - 96] = _scHva::P64;
           P64[Hp - 88] = _scHvb::P64;
           P64[Hp - 80] = _scHvc::P64;
           P64[Hp - 72] = _scHvd::P64;
           P64[Hp - 64] = _scHve::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccJl6_info;
           R4 = Hp - 120;
           R3 = _scHvC::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJl6() //  [R1, R2]
         { info_tbl: [(ccJl6,
                       label: block_ccJl6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJl6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJlg; else goto ccJlf;
       ccJlg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJlf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxO_entry() //  [R1]
         { info_tbl: [(ccJlh,
                       label: sat_scHxO_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJlh: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccJll; else goto ccJlk;
       ccJll: // global
           HpAlloc = 136;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJlk: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvC::P64 = P64[R1 + 64];
           _scHvH::P64 = P64[R1 + 72];
           _scHvM::P64 = P64[R1 + 80];
           _scHvR::P64 = P64[R1 + 88];
           _scHvW::P64 = P64[R1 + 96];
           _scHw1::P64 = P64[R1 + 104];
           _scHw6::P64 = P64[R1 + 112];
           _scHwb::P64 = P64[R1 + 120];
           _scHwd::P64 = P64[R1 + 128];
           I64[Hp - 128] = sat_scHxN_info;
           P64[Hp - 112] = _scHv9::P64;
           P64[Hp - 104] = _scHva::P64;
           P64[Hp - 96] = _scHvb::P64;
           P64[Hp - 88] = _scHvc::P64;
           P64[Hp - 80] = _scHvd::P64;
           P64[Hp - 72] = _scHve::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 128;
           R2 = lvl23_rcHpS_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxP_entry() //  [R1]
         { info_tbl: [(ccJlm,
                       label: sat_scHxP_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJlm: // global
           _scHxP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJln; else goto ccJlo;
       ccJlo: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccJlq; else goto ccJlp;
       ccJlq: // global
           HpAlloc = 136;
           goto ccJln;
       ccJln: // global
           R1 = _scHxP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJlp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxP::P64;
           _scHv9::P64 = P64[_scHxP::P64 + 16];
           _scHva::P64 = P64[_scHxP::P64 + 24];
           _scHvb::P64 = P64[_scHxP::P64 + 32];
           _scHvc::P64 = P64[_scHxP::P64 + 40];
           _scHvd::P64 = P64[_scHxP::P64 + 48];
           _scHve::P64 = P64[_scHxP::P64 + 56];
           _scHvC::P64 = P64[_scHxP::P64 + 64];
           _scHvH::P64 = P64[_scHxP::P64 + 72];
           _scHvM::P64 = P64[_scHxP::P64 + 80];
           _scHvR::P64 = P64[_scHxP::P64 + 88];
           _scHvW::P64 = P64[_scHxP::P64 + 96];
           _scHw1::P64 = P64[_scHxP::P64 + 104];
           _scHw6::P64 = P64[_scHxP::P64 + 112];
           _scHwb::P64 = P64[_scHxP::P64 + 120];
           _scHwd::P64 = P64[_scHxP::P64 + 128];
           I64[Hp - 128] = sat_scHxO_info;
           P64[Hp - 112] = _scHv9::P64;
           P64[Hp - 104] = _scHva::P64;
           P64[Hp - 96] = _scHvb::P64;
           P64[Hp - 88] = _scHvc::P64;
           P64[Hp - 80] = _scHvd::P64;
           P64[Hp - 72] = _scHve::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 128;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxT_entry() //  [R1]
         { info_tbl: [(ccJlu,
                       label: sat_scHxT_info
                       rep:HeapRep 16 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJlu: // global
           _scHxT::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJlv; else goto ccJlw;
       ccJlw: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccJly; else goto ccJlx;
       ccJly: // global
           HpAlloc = 136;
           goto ccJlv;
       ccJlv: // global
           R1 = _scHxT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJlx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxT::P64;
           _scHv9::P64 = P64[_scHxT::P64 + 16];
           _scHva::P64 = P64[_scHxT::P64 + 24];
           _scHvb::P64 = P64[_scHxT::P64 + 32];
           _scHvc::P64 = P64[_scHxT::P64 + 40];
           _scHvd::P64 = P64[_scHxT::P64 + 48];
           _scHve::P64 = P64[_scHxT::P64 + 56];
           _scHvx::P64 = P64[_scHxT::P64 + 64];
           _scHvC::P64 = P64[_scHxT::P64 + 72];
           _scHvH::P64 = P64[_scHxT::P64 + 80];
           _scHvM::P64 = P64[_scHxT::P64 + 88];
           _scHvR::P64 = P64[_scHxT::P64 + 96];
           _scHvW::P64 = P64[_scHxT::P64 + 104];
           _scHw1::P64 = P64[_scHxT::P64 + 112];
           _scHw6::P64 = P64[_scHxT::P64 + 120];
           _scHwb::P64 = P64[_scHxT::P64 + 128];
           _scHwd::P64 = P64[_scHxT::P64 + 136];
           I64[Hp - 128] = sat_scHxP_info;
           P64[Hp - 112] = _scHv9::P64;
           P64[Hp - 104] = _scHva::P64;
           P64[Hp - 96] = _scHvb::P64;
           P64[Hp - 88] = _scHvc::P64;
           P64[Hp - 80] = _scHvd::P64;
           P64[Hp - 72] = _scHve::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccJlr_info;
           R4 = Hp - 128;
           R3 = _scHvx::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJlr() //  [R1, R2]
         { info_tbl: [(ccJlr,
                       label: block_ccJlr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJlr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJlB; else goto ccJlA;
       ccJlB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJlA: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxU_entry() //  [R1]
         { info_tbl: [(ccJlC,
                       label: sat_scHxU_info
                       rep:HeapRep 16 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJlC: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccJlG; else goto ccJlF;
       ccJlG: // global
           HpAlloc = 144;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJlF: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvx::P64 = P64[R1 + 64];
           _scHvC::P64 = P64[R1 + 72];
           _scHvH::P64 = P64[R1 + 80];
           _scHvM::P64 = P64[R1 + 88];
           _scHvR::P64 = P64[R1 + 96];
           _scHvW::P64 = P64[R1 + 104];
           _scHw1::P64 = P64[R1 + 112];
           _scHw6::P64 = P64[R1 + 120];
           _scHwb::P64 = P64[R1 + 128];
           _scHwd::P64 = P64[R1 + 136];
           I64[Hp - 136] = sat_scHxT_info;
           P64[Hp - 120] = _scHv9::P64;
           P64[Hp - 112] = _scHva::P64;
           P64[Hp - 104] = _scHvb::P64;
           P64[Hp - 96] = _scHvc::P64;
           P64[Hp - 88] = _scHvd::P64;
           P64[Hp - 80] = _scHve::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 136;
           R2 = lvl22_rcHpR_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxV_entry() //  [R1]
         { info_tbl: [(ccJlH,
                       label: sat_scHxV_info
                       rep:HeapRep 16 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJlH: // global
           _scHxV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJlI; else goto ccJlJ;
       ccJlJ: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccJlL; else goto ccJlK;
       ccJlL: // global
           HpAlloc = 144;
           goto ccJlI;
       ccJlI: // global
           R1 = _scHxV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJlK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxV::P64;
           _scHv9::P64 = P64[_scHxV::P64 + 16];
           _scHva::P64 = P64[_scHxV::P64 + 24];
           _scHvb::P64 = P64[_scHxV::P64 + 32];
           _scHvc::P64 = P64[_scHxV::P64 + 40];
           _scHvd::P64 = P64[_scHxV::P64 + 48];
           _scHve::P64 = P64[_scHxV::P64 + 56];
           _scHvx::P64 = P64[_scHxV::P64 + 64];
           _scHvC::P64 = P64[_scHxV::P64 + 72];
           _scHvH::P64 = P64[_scHxV::P64 + 80];
           _scHvM::P64 = P64[_scHxV::P64 + 88];
           _scHvR::P64 = P64[_scHxV::P64 + 96];
           _scHvW::P64 = P64[_scHxV::P64 + 104];
           _scHw1::P64 = P64[_scHxV::P64 + 112];
           _scHw6::P64 = P64[_scHxV::P64 + 120];
           _scHwb::P64 = P64[_scHxV::P64 + 128];
           _scHwd::P64 = P64[_scHxV::P64 + 136];
           I64[Hp - 136] = sat_scHxU_info;
           P64[Hp - 120] = _scHv9::P64;
           P64[Hp - 112] = _scHva::P64;
           P64[Hp - 104] = _scHvb::P64;
           P64[Hp - 96] = _scHvc::P64;
           P64[Hp - 88] = _scHvd::P64;
           P64[Hp - 80] = _scHve::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 136;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxZ_entry() //  [R1]
         { info_tbl: [(ccJlP,
                       label: sat_scHxZ_info
                       rep:HeapRep 17 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJlP: // global
           _scHxZ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJlQ; else goto ccJlR;
       ccJlR: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccJlT; else goto ccJlS;
       ccJlT: // global
           HpAlloc = 144;
           goto ccJlQ;
       ccJlQ: // global
           R1 = _scHxZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJlS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxZ::P64;
           _scHv9::P64 = P64[_scHxZ::P64 + 16];
           _scHva::P64 = P64[_scHxZ::P64 + 24];
           _scHvb::P64 = P64[_scHxZ::P64 + 32];
           _scHvc::P64 = P64[_scHxZ::P64 + 40];
           _scHvd::P64 = P64[_scHxZ::P64 + 48];
           _scHve::P64 = P64[_scHxZ::P64 + 56];
           _scHvs::P64 = P64[_scHxZ::P64 + 64];
           _scHvx::P64 = P64[_scHxZ::P64 + 72];
           _scHvC::P64 = P64[_scHxZ::P64 + 80];
           _scHvH::P64 = P64[_scHxZ::P64 + 88];
           _scHvM::P64 = P64[_scHxZ::P64 + 96];
           _scHvR::P64 = P64[_scHxZ::P64 + 104];
           _scHvW::P64 = P64[_scHxZ::P64 + 112];
           _scHw1::P64 = P64[_scHxZ::P64 + 120];
           _scHw6::P64 = P64[_scHxZ::P64 + 128];
           _scHwb::P64 = P64[_scHxZ::P64 + 136];
           _scHwd::P64 = P64[_scHxZ::P64 + 144];
           I64[Hp - 136] = sat_scHxV_info;
           P64[Hp - 120] = _scHv9::P64;
           P64[Hp - 112] = _scHva::P64;
           P64[Hp - 104] = _scHvb::P64;
           P64[Hp - 96] = _scHvc::P64;
           P64[Hp - 88] = _scHvd::P64;
           P64[Hp - 80] = _scHve::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccJlM_info;
           R4 = Hp - 136;
           R3 = _scHvs::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJlM() //  [R1, R2]
         { info_tbl: [(ccJlM,
                       label: block_ccJlM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJlM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJlW; else goto ccJlV;
       ccJlW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJlV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHy0_entry() //  [R1]
         { info_tbl: [(ccJlX,
                       label: sat_scHy0_info
                       rep:HeapRep 17 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJlX: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccJm1; else goto ccJm0;
       ccJm1: // global
           HpAlloc = 152;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJm0: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvs::P64 = P64[R1 + 64];
           _scHvx::P64 = P64[R1 + 72];
           _scHvC::P64 = P64[R1 + 80];
           _scHvH::P64 = P64[R1 + 88];
           _scHvM::P64 = P64[R1 + 96];
           _scHvR::P64 = P64[R1 + 104];
           _scHvW::P64 = P64[R1 + 112];
           _scHw1::P64 = P64[R1 + 120];
           _scHw6::P64 = P64[R1 + 128];
           _scHwb::P64 = P64[R1 + 136];
           _scHwd::P64 = P64[R1 + 144];
           I64[Hp - 144] = sat_scHxZ_info;
           P64[Hp - 128] = _scHv9::P64;
           P64[Hp - 120] = _scHva::P64;
           P64[Hp - 112] = _scHvb::P64;
           P64[Hp - 104] = _scHvc::P64;
           P64[Hp - 96] = _scHvd::P64;
           P64[Hp - 88] = _scHve::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 144;
           R2 = lvl21_rcHpQ_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHy1_entry() //  [R1]
         { info_tbl: [(ccJm2,
                       label: sat_scHy1_info
                       rep:HeapRep 17 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJm2: // global
           _scHy1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJm3; else goto ccJm4;
       ccJm4: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccJm6; else goto ccJm5;
       ccJm6: // global
           HpAlloc = 152;
           goto ccJm3;
       ccJm3: // global
           R1 = _scHy1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJm5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHy1::P64;
           _scHv9::P64 = P64[_scHy1::P64 + 16];
           _scHva::P64 = P64[_scHy1::P64 + 24];
           _scHvb::P64 = P64[_scHy1::P64 + 32];
           _scHvc::P64 = P64[_scHy1::P64 + 40];
           _scHvd::P64 = P64[_scHy1::P64 + 48];
           _scHve::P64 = P64[_scHy1::P64 + 56];
           _scHvs::P64 = P64[_scHy1::P64 + 64];
           _scHvx::P64 = P64[_scHy1::P64 + 72];
           _scHvC::P64 = P64[_scHy1::P64 + 80];
           _scHvH::P64 = P64[_scHy1::P64 + 88];
           _scHvM::P64 = P64[_scHy1::P64 + 96];
           _scHvR::P64 = P64[_scHy1::P64 + 104];
           _scHvW::P64 = P64[_scHy1::P64 + 112];
           _scHw1::P64 = P64[_scHy1::P64 + 120];
           _scHw6::P64 = P64[_scHy1::P64 + 128];
           _scHwb::P64 = P64[_scHy1::P64 + 136];
           _scHwd::P64 = P64[_scHy1::P64 + 144];
           I64[Hp - 144] = sat_scHy0_info;
           P64[Hp - 128] = _scHv9::P64;
           P64[Hp - 120] = _scHva::P64;
           P64[Hp - 112] = _scHvb::P64;
           P64[Hp - 104] = _scHvc::P64;
           P64[Hp - 96] = _scHvd::P64;
           P64[Hp - 88] = _scHve::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 144;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHy5_entry() //  [R1]
         { info_tbl: [(ccJma,
                       label: sat_scHy5_info
                       rep:HeapRep 18 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJma: // global
           _scHy5::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJmb; else goto ccJmc;
       ccJmc: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccJme; else goto ccJmd;
       ccJme: // global
           HpAlloc = 152;
           goto ccJmb;
       ccJmb: // global
           R1 = _scHy5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJmd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHy5::P64;
           _scHv9::P64 = P64[_scHy5::P64 + 16];
           _scHva::P64 = P64[_scHy5::P64 + 24];
           _scHvb::P64 = P64[_scHy5::P64 + 32];
           _scHvc::P64 = P64[_scHy5::P64 + 40];
           _scHvd::P64 = P64[_scHy5::P64 + 48];
           _scHve::P64 = P64[_scHy5::P64 + 56];
           _scHvn::P64 = P64[_scHy5::P64 + 64];
           _scHvs::P64 = P64[_scHy5::P64 + 72];
           _scHvx::P64 = P64[_scHy5::P64 + 80];
           _scHvC::P64 = P64[_scHy5::P64 + 88];
           _scHvH::P64 = P64[_scHy5::P64 + 96];
           _scHvM::P64 = P64[_scHy5::P64 + 104];
           _scHvR::P64 = P64[_scHy5::P64 + 112];
           _scHvW::P64 = P64[_scHy5::P64 + 120];
           _scHw1::P64 = P64[_scHy5::P64 + 128];
           _scHw6::P64 = P64[_scHy5::P64 + 136];
           _scHwb::P64 = P64[_scHy5::P64 + 144];
           _scHwd::P64 = P64[_scHy5::P64 + 152];
           I64[Hp - 144] = sat_scHy1_info;
           P64[Hp - 128] = _scHv9::P64;
           P64[Hp - 120] = _scHva::P64;
           P64[Hp - 112] = _scHvb::P64;
           P64[Hp - 104] = _scHvc::P64;
           P64[Hp - 96] = _scHvd::P64;
           P64[Hp - 88] = _scHve::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccJm7_info;
           R4 = Hp - 144;
           R3 = _scHvn::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJm7() //  [R1, R2]
         { info_tbl: [(ccJm7,
                       label: block_ccJm7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJm7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJmh; else goto ccJmg;
       ccJmh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJmg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHy6_entry() //  [R1]
         { info_tbl: [(ccJmi,
                       label: sat_scHy6_info
                       rep:HeapRep 18 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJmi: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccJmm; else goto ccJml;
       ccJmm: // global
           HpAlloc = 160;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJml: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvn::P64 = P64[R1 + 64];
           _scHvs::P64 = P64[R1 + 72];
           _scHvx::P64 = P64[R1 + 80];
           _scHvC::P64 = P64[R1 + 88];
           _scHvH::P64 = P64[R1 + 96];
           _scHvM::P64 = P64[R1 + 104];
           _scHvR::P64 = P64[R1 + 112];
           _scHvW::P64 = P64[R1 + 120];
           _scHw1::P64 = P64[R1 + 128];
           _scHw6::P64 = P64[R1 + 136];
           _scHwb::P64 = P64[R1 + 144];
           _scHwd::P64 = P64[R1 + 152];
           I64[Hp - 152] = sat_scHy5_info;
           P64[Hp - 136] = _scHv9::P64;
           P64[Hp - 128] = _scHva::P64;
           P64[Hp - 120] = _scHvb::P64;
           P64[Hp - 112] = _scHvc::P64;
           P64[Hp - 104] = _scHvd::P64;
           P64[Hp - 96] = _scHve::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 152;
           R2 = lvl20_rcHpP_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHy7_entry() //  [R1]
         { info_tbl: [(ccJmn,
                       label: sat_scHy7_info
                       rep:HeapRep 18 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJmn: // global
           _scHy7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJmo; else goto ccJmp;
       ccJmp: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccJmr; else goto ccJmq;
       ccJmr: // global
           HpAlloc = 160;
           goto ccJmo;
       ccJmo: // global
           R1 = _scHy7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJmq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHy7::P64;
           _scHv9::P64 = P64[_scHy7::P64 + 16];
           _scHva::P64 = P64[_scHy7::P64 + 24];
           _scHvb::P64 = P64[_scHy7::P64 + 32];
           _scHvc::P64 = P64[_scHy7::P64 + 40];
           _scHvd::P64 = P64[_scHy7::P64 + 48];
           _scHve::P64 = P64[_scHy7::P64 + 56];
           _scHvn::P64 = P64[_scHy7::P64 + 64];
           _scHvs::P64 = P64[_scHy7::P64 + 72];
           _scHvx::P64 = P64[_scHy7::P64 + 80];
           _scHvC::P64 = P64[_scHy7::P64 + 88];
           _scHvH::P64 = P64[_scHy7::P64 + 96];
           _scHvM::P64 = P64[_scHy7::P64 + 104];
           _scHvR::P64 = P64[_scHy7::P64 + 112];
           _scHvW::P64 = P64[_scHy7::P64 + 120];
           _scHw1::P64 = P64[_scHy7::P64 + 128];
           _scHw6::P64 = P64[_scHy7::P64 + 136];
           _scHwb::P64 = P64[_scHy7::P64 + 144];
           _scHwd::P64 = P64[_scHy7::P64 + 152];
           I64[Hp - 152] = sat_scHy6_info;
           P64[Hp - 136] = _scHv9::P64;
           P64[Hp - 128] = _scHva::P64;
           P64[Hp - 120] = _scHvb::P64;
           P64[Hp - 112] = _scHvc::P64;
           P64[Hp - 104] = _scHvd::P64;
           P64[Hp - 96] = _scHve::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 152;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyb_entry() //  [R1]
         { info_tbl: [(ccJmv,
                       label: sat_scHyb_info
                       rep:HeapRep 19 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJmv: // global
           _scHyb::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccJmw; else goto ccJmx;
       ccJmx: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccJmz; else goto ccJmy;
       ccJmz: // global
           HpAlloc = 160;
           goto ccJmw;
       ccJmw: // global
           R1 = _scHyb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJmy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHyb::P64;
           _scHv9::P64 = P64[_scHyb::P64 + 16];
           _scHva::P64 = P64[_scHyb::P64 + 24];
           _scHvb::P64 = P64[_scHyb::P64 + 32];
           _scHvc::P64 = P64[_scHyb::P64 + 40];
           _scHvd::P64 = P64[_scHyb::P64 + 48];
           _scHve::P64 = P64[_scHyb::P64 + 56];
           _scHvi::P64 = P64[_scHyb::P64 + 64];
           _scHvn::P64 = P64[_scHyb::P64 + 72];
           _scHvs::P64 = P64[_scHyb::P64 + 80];
           _scHvx::P64 = P64[_scHyb::P64 + 88];
           _scHvC::P64 = P64[_scHyb::P64 + 96];
           _scHvH::P64 = P64[_scHyb::P64 + 104];
           _scHvM::P64 = P64[_scHyb::P64 + 112];
           _scHvR::P64 = P64[_scHyb::P64 + 120];
           _scHvW::P64 = P64[_scHyb::P64 + 128];
           _scHw1::P64 = P64[_scHyb::P64 + 136];
           _scHw6::P64 = P64[_scHyb::P64 + 144];
           _scHwb::P64 = P64[_scHyb::P64 + 152];
           _scHwd::P64 = P64[_scHyb::P64 + 160];
           I64[Hp - 152] = sat_scHy7_info;
           P64[Hp - 136] = _scHv9::P64;
           P64[Hp - 128] = _scHva::P64;
           P64[Hp - 120] = _scHvb::P64;
           P64[Hp - 112] = _scHvc::P64;
           P64[Hp - 104] = _scHvd::P64;
           P64[Hp - 96] = _scHve::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccJms_info;
           R4 = Hp - 152;
           R3 = _scHvi::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJms() //  [R1, R2]
         { info_tbl: [(ccJms,
                       label: block_ccJms_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJms: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJmC; else goto ccJmB;
       ccJmC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJmB: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyc_entry() //  [R1]
         { info_tbl: [(ccJmD,
                       label: sat_scHyc_info
                       rep:HeapRep 19 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJmD: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccJmH; else goto ccJmG;
       ccJmH: // global
           HpAlloc = 168;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJmG: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvi::P64 = P64[R1 + 64];
           _scHvn::P64 = P64[R1 + 72];
           _scHvs::P64 = P64[R1 + 80];
           _scHvx::P64 = P64[R1 + 88];
           _scHvC::P64 = P64[R1 + 96];
           _scHvH::P64 = P64[R1 + 104];
           _scHvM::P64 = P64[R1 + 112];
           _scHvR::P64 = P64[R1 + 120];
           _scHvW::P64 = P64[R1 + 128];
           _scHw1::P64 = P64[R1 + 136];
           _scHw6::P64 = P64[R1 + 144];
           _scHwb::P64 = P64[R1 + 152];
           _scHwd::P64 = P64[R1 + 160];
           I64[Hp - 160] = sat_scHyb_info;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 160;
           R2 = lvl19_rcHpO_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHyd_entry() //  [R1]
         { info_tbl: [(ccJmI,
                       label: sat_scHyd_info
                       rep:HeapRep 19 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJmI: // global
           _scHyd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJmJ; else goto ccJmK;
       ccJmK: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccJmM; else goto ccJmL;
       ccJmM: // global
           HpAlloc = 168;
           goto ccJmJ;
       ccJmJ: // global
           R1 = _scHyd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJmL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHyd::P64;
           _scHv9::P64 = P64[_scHyd::P64 + 16];
           _scHva::P64 = P64[_scHyd::P64 + 24];
           _scHvb::P64 = P64[_scHyd::P64 + 32];
           _scHvc::P64 = P64[_scHyd::P64 + 40];
           _scHvd::P64 = P64[_scHyd::P64 + 48];
           _scHve::P64 = P64[_scHyd::P64 + 56];
           _scHvi::P64 = P64[_scHyd::P64 + 64];
           _scHvn::P64 = P64[_scHyd::P64 + 72];
           _scHvs::P64 = P64[_scHyd::P64 + 80];
           _scHvx::P64 = P64[_scHyd::P64 + 88];
           _scHvC::P64 = P64[_scHyd::P64 + 96];
           _scHvH::P64 = P64[_scHyd::P64 + 104];
           _scHvM::P64 = P64[_scHyd::P64 + 112];
           _scHvR::P64 = P64[_scHyd::P64 + 120];
           _scHvW::P64 = P64[_scHyd::P64 + 128];
           _scHw1::P64 = P64[_scHyd::P64 + 136];
           _scHw6::P64 = P64[_scHyd::P64 + 144];
           _scHwb::P64 = P64[_scHyd::P64 + 152];
           _scHwd::P64 = P64[_scHyd::P64 + 160];
           I64[Hp - 160] = sat_scHyc_info;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 160;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyh_entry() //  [R1]
         { info_tbl: [(ccJmN,
                       label: sat_scHyh_info
                       rep:HeapRep 20 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJmN: // global
           if ((Sp + -176) < SpLim) (likely: False) goto ccJmU; else goto ccJmV;
       ccJmU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJmV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 176] = block_ccJcr_info;
           _scHv9::P64 = P64[R1 + 24];
           _scHva::P64 = P64[R1 + 32];
           _scHvb::P64 = P64[R1 + 40];
           _scHvc::P64 = P64[R1 + 48];
           _scHvd::P64 = P64[R1 + 56];
           _scHve::P64 = P64[R1 + 64];
           _scHvi::P64 = P64[R1 + 72];
           _scHvn::P64 = P64[R1 + 80];
           _scHvs::P64 = P64[R1 + 88];
           _scHvx::P64 = P64[R1 + 96];
           _scHvC::P64 = P64[R1 + 104];
           _scHvH::P64 = P64[R1 + 112];
           _scHvM::P64 = P64[R1 + 120];
           _scHvR::P64 = P64[R1 + 128];
           _scHvW::P64 = P64[R1 + 136];
           _scHw1::P64 = P64[R1 + 144];
           _scHw6::P64 = P64[R1 + 152];
           _scHwb::P64 = P64[R1 + 160];
           _scHwd::P64 = P64[R1 + 168];
           R1 = P64[R1 + 16];
           P64[Sp - 168] = _scHv9::P64;
           P64[Sp - 160] = _scHva::P64;
           P64[Sp - 152] = _scHvb::P64;
           P64[Sp - 144] = _scHvc::P64;
           P64[Sp - 136] = _scHvd::P64;
           P64[Sp - 128] = _scHve::P64;
           P64[Sp - 120] = _scHvi::P64;
           P64[Sp - 112] = _scHvn::P64;
           P64[Sp - 104] = _scHvs::P64;
           P64[Sp - 96] = _scHvx::P64;
           P64[Sp - 88] = _scHvC::P64;
           P64[Sp - 80] = _scHvH::P64;
           P64[Sp - 72] = _scHvM::P64;
           P64[Sp - 64] = _scHvR::P64;
           P64[Sp - 56] = _scHvW::P64;
           P64[Sp - 48] = _scHw1::P64;
           P64[Sp - 40] = _scHw6::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 176;
           if (R1 & 7 != 0) goto ucJn2; else goto ccJcs;
       ucJn2: // global
           call _ccJcr(R1) args: 0, res: 0, upd: 0;
       ccJcs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJcr() //  [R1]
         { info_tbl: [(ccJcr,
                       label: block_ccJcr_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJcr: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccJmY; else goto ccJmX;
       ccJmY: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccJmX: // global
           _scHwi::I64 = I64[R1 + 7];
           I64[Hp - 160] = sat_scHyd_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           P64[Hp - 128] = P64[Sp + 24];
           P64[Hp - 120] = P64[Sp + 32];
           P64[Hp - 112] = P64[Sp + 40];
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           P64[Hp - 16] = P64[Sp + 136];
           P64[Hp - 8] = P64[Sp + 144];
           P64[Hp] = P64[Sp + 152];
           I64[Sp + 152] = block_ccJmR_info;
           R3 = Hp - 160;
           R2 = _scHwi::I64;
           Sp = Sp + 152;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJmR() //  [R1, R2]
         { info_tbl: [(ccJmR,
                       label: block_ccJmR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJmR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJn1; else goto ccJn0;
       ccJn1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJn0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyi_entry() //  [R1]
         { info_tbl: [(ccJn3,
                       label: sat_scHyi_info
                       rep:HeapRep 20 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJn3: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccJn7; else goto ccJn6;
       ccJn7: // global
           HpAlloc = 176;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJn6: // global
           _scHuX::P64 = P64[R1 + 16];
           _scHv9::P64 = P64[R1 + 24];
           _scHva::P64 = P64[R1 + 32];
           _scHvb::P64 = P64[R1 + 40];
           _scHvc::P64 = P64[R1 + 48];
           _scHvd::P64 = P64[R1 + 56];
           _scHve::P64 = P64[R1 + 64];
           _scHvi::P64 = P64[R1 + 72];
           _scHvn::P64 = P64[R1 + 80];
           _scHvs::P64 = P64[R1 + 88];
           _scHvx::P64 = P64[R1 + 96];
           _scHvC::P64 = P64[R1 + 104];
           _scHvH::P64 = P64[R1 + 112];
           _scHvM::P64 = P64[R1 + 120];
           _scHvR::P64 = P64[R1 + 128];
           _scHvW::P64 = P64[R1 + 136];
           _scHw1::P64 = P64[R1 + 144];
           _scHw6::P64 = P64[R1 + 152];
           _scHwb::P64 = P64[R1 + 160];
           _scHwd::P64 = P64[R1 + 168];
           I64[Hp - 168] = sat_scHyh_info;
           P64[Hp - 152] = _scHuX::P64;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 168;
           R2 = lvl18_rcHpN_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHyj_entry() //  [R1]
         { info_tbl: [(ccJn8,
                       label: sat_scHyj_info
                       rep:HeapRep 20 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJn8: // global
           _scHyj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJn9; else goto ccJna;
       ccJna: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccJnc; else goto ccJnb;
       ccJnc: // global
           HpAlloc = 176;
           goto ccJn9;
       ccJn9: // global
           R1 = _scHyj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJnb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHyj::P64;
           _scHuX::P64 = P64[_scHyj::P64 + 16];
           _scHv9::P64 = P64[_scHyj::P64 + 24];
           _scHva::P64 = P64[_scHyj::P64 + 32];
           _scHvb::P64 = P64[_scHyj::P64 + 40];
           _scHvc::P64 = P64[_scHyj::P64 + 48];
           _scHvd::P64 = P64[_scHyj::P64 + 56];
           _scHve::P64 = P64[_scHyj::P64 + 64];
           _scHvi::P64 = P64[_scHyj::P64 + 72];
           _scHvn::P64 = P64[_scHyj::P64 + 80];
           _scHvs::P64 = P64[_scHyj::P64 + 88];
           _scHvx::P64 = P64[_scHyj::P64 + 96];
           _scHvC::P64 = P64[_scHyj::P64 + 104];
           _scHvH::P64 = P64[_scHyj::P64 + 112];
           _scHvM::P64 = P64[_scHyj::P64 + 120];
           _scHvR::P64 = P64[_scHyj::P64 + 128];
           _scHvW::P64 = P64[_scHyj::P64 + 136];
           _scHw1::P64 = P64[_scHyj::P64 + 144];
           _scHw6::P64 = P64[_scHyj::P64 + 152];
           _scHwb::P64 = P64[_scHyj::P64 + 160];
           _scHwd::P64 = P64[_scHyj::P64 + 168];
           I64[Hp - 168] = sat_scHyi_info;
           P64[Hp - 152] = _scHuX::P64;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 168;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyn_entry() //  [R1]
         { info_tbl: [(ccJnd,
                       label: sat_scHyn_info
                       rep:HeapRep 21 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJnd: // global
           if ((Sp + -184) < SpLim) (likely: False) goto ccJnk; else goto ccJnl;
       ccJnk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJnl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 184] = block_ccJca_info;
           _scHuX::P64 = P64[R1 + 24];
           _scHv9::P64 = P64[R1 + 32];
           _scHva::P64 = P64[R1 + 40];
           _scHvb::P64 = P64[R1 + 48];
           _scHvc::P64 = P64[R1 + 56];
           _scHvd::P64 = P64[R1 + 64];
           _scHve::P64 = P64[R1 + 72];
           _scHvi::P64 = P64[R1 + 80];
           _scHvn::P64 = P64[R1 + 88];
           _scHvs::P64 = P64[R1 + 96];
           _scHvx::P64 = P64[R1 + 104];
           _scHvC::P64 = P64[R1 + 112];
           _scHvH::P64 = P64[R1 + 120];
           _scHvM::P64 = P64[R1 + 128];
           _scHvR::P64 = P64[R1 + 136];
           _scHvW::P64 = P64[R1 + 144];
           _scHw1::P64 = P64[R1 + 152];
           _scHw6::P64 = P64[R1 + 160];
           _scHwb::P64 = P64[R1 + 168];
           _scHwd::P64 = P64[R1 + 176];
           R1 = P64[R1 + 16];
           P64[Sp - 176] = _scHuX::P64;
           P64[Sp - 168] = _scHv9::P64;
           P64[Sp - 160] = _scHva::P64;
           P64[Sp - 152] = _scHvb::P64;
           P64[Sp - 144] = _scHvc::P64;
           P64[Sp - 136] = _scHvd::P64;
           P64[Sp - 128] = _scHve::P64;
           P64[Sp - 120] = _scHvi::P64;
           P64[Sp - 112] = _scHvn::P64;
           P64[Sp - 104] = _scHvs::P64;
           P64[Sp - 96] = _scHvx::P64;
           P64[Sp - 88] = _scHvC::P64;
           P64[Sp - 80] = _scHvH::P64;
           P64[Sp - 72] = _scHvM::P64;
           P64[Sp - 64] = _scHvR::P64;
           P64[Sp - 56] = _scHvW::P64;
           P64[Sp - 48] = _scHw1::P64;
           P64[Sp - 40] = _scHw6::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 184;
           if (R1 & 7 != 0) goto ucJns; else goto ccJcb;
       ucJns: // global
           call _ccJca(R1) args: 0, res: 0, upd: 0;
       ccJcb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccJca() //  [R1]
         { info_tbl: [(ccJca,
                       label: block_ccJca_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJca: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccJno; else goto ccJnn;
       ccJno: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccJnn: // global
           _scHwf::I64 = I64[R1 + 7];
           I64[Hp - 168] = sat_scHyj_info;
           P64[Hp - 152] = P64[Sp + 8];
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = P64[Sp + 48];
           P64[Hp - 104] = P64[Sp + 56];
           P64[Hp - 96] = P64[Sp + 64];
           P64[Hp - 88] = P64[Sp + 72];
           P64[Hp - 80] = P64[Sp + 80];
           P64[Hp - 72] = P64[Sp + 88];
           P64[Hp - 64] = P64[Sp + 96];
           P64[Hp - 56] = P64[Sp + 104];
           P64[Hp - 48] = P64[Sp + 112];
           P64[Hp - 40] = P64[Sp + 120];
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 144];
           P64[Hp - 8] = P64[Sp + 152];
           P64[Hp] = P64[Sp + 160];
           I64[Sp + 160] = block_ccJnh_info;
           R3 = Hp - 168;
           R2 = _scHwf::I64;
           Sp = Sp + 160;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccJnh() //  [R1, R2]
         { info_tbl: [(ccJnh,
                       label: block_ccJnh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJnh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJnr; else goto ccJnq;
       ccJnr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccJnq: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyo_entry() //  [R1]
         { info_tbl: [(ccJnt,
                       label: sat_scHyo_info
                       rep:HeapRep 21 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJnt: // global
           _scHyo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJnu; else goto ccJnv;
       ccJnv: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto ccJnx; else goto ccJnw;
       ccJnx: // global
           HpAlloc = 184;
           goto ccJnu;
       ccJnu: // global
           R1 = _scHyo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJnw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHyo::P64;
           _scHuW::P64 = P64[_scHyo::P64 + 16];
           _scHuX::P64 = P64[_scHyo::P64 + 24];
           _scHv9::P64 = P64[_scHyo::P64 + 32];
           _scHva::P64 = P64[_scHyo::P64 + 40];
           _scHvb::P64 = P64[_scHyo::P64 + 48];
           _scHvc::P64 = P64[_scHyo::P64 + 56];
           _scHvd::P64 = P64[_scHyo::P64 + 64];
           _scHve::P64 = P64[_scHyo::P64 + 72];
           _scHvi::P64 = P64[_scHyo::P64 + 80];
           _scHvn::P64 = P64[_scHyo::P64 + 88];
           _scHvs::P64 = P64[_scHyo::P64 + 96];
           _scHvx::P64 = P64[_scHyo::P64 + 104];
           _scHvC::P64 = P64[_scHyo::P64 + 112];
           _scHvH::P64 = P64[_scHyo::P64 + 120];
           _scHvM::P64 = P64[_scHyo::P64 + 128];
           _scHvR::P64 = P64[_scHyo::P64 + 136];
           _scHvW::P64 = P64[_scHyo::P64 + 144];
           _scHw1::P64 = P64[_scHyo::P64 + 152];
           _scHw6::P64 = P64[_scHyo::P64 + 160];
           _scHwb::P64 = P64[_scHyo::P64 + 168];
           _scHwd::P64 = P64[_scHyo::P64 + 176];
           I64[Hp - 176] = sat_scHyn_info;
           P64[Hp - 160] = _scHuW::P64;
           P64[Hp - 152] = _scHuX::P64;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 176;
           R2 = lvl17_rcHpM_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_scHwc_entry() //  [R1, R2]
         { info_tbl: [(ccJny,
                       label: p_scHwc_info
                       rep:HeapRep 20 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJny: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto ccJnC; else goto ccJnB;
       ccJnC: // global
           HpAlloc = 184;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJnB: // global
           _scHuW::P64 = P64[R1 + 7];
           _scHuX::P64 = P64[R1 + 15];
           _scHv9::P64 = P64[R1 + 23];
           _scHva::P64 = P64[R1 + 31];
           _scHvb::P64 = P64[R1 + 39];
           _scHvc::P64 = P64[R1 + 47];
           _scHvd::P64 = P64[R1 + 55];
           _scHve::P64 = P64[R1 + 63];
           _scHvi::P64 = P64[R1 + 71];
           _scHvn::P64 = P64[R1 + 79];
           _scHvs::P64 = P64[R1 + 87];
           _scHvx::P64 = P64[R1 + 95];
           _scHvC::P64 = P64[R1 + 103];
           _scHvH::P64 = P64[R1 + 111];
           _scHvM::P64 = P64[R1 + 119];
           _scHvR::P64 = P64[R1 + 127];
           _scHvW::P64 = P64[R1 + 135];
           _scHw1::P64 = P64[R1 + 143];
           _scHw6::P64 = P64[R1 + 151];
           _scHwb::P64 = P64[R1 + 159];
           I64[Hp - 176] = sat_scHyo_info;
           P64[Hp - 160] = _scHuW::P64;
           P64[Hp - 152] = _scHuX::P64;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = R2;
           R3 = Hp - 176;
           R2 = lvl16_rcHpL_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHys_entry() //  [R1]
         { info_tbl: [(ccJnR,
                       label: sat_scHys_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJnR: // global
           _scHys::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccJnS; else goto ccJnT;
       ccJnT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJnV; else goto ccJnU;
       ccJnV: // global
           HpAlloc = 24;
           goto ccJnS;
       ccJnS: // global
           R1 = _scHys::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJnU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHys::P64;
           _scHwc::P64 = P64[_scHys::P64 + 16];
           _scHyq::P64 = P64[_scHys::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _scHyq::P64;
           R2 = Hp - 14;
           R1 = _scHwc::P64;
           Sp = Sp - 16;
           call p_scHwc_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyt_entry() //  [R1, R2]
         { info_tbl: [(ccJnX,
                       label: sat_scHyt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJnX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccJo1; else goto ccJo0;
       ccJo1: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJo0: // global
           _scHwc::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_scHys_info;
           P64[Hp - 32] = _scHwc::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stats.$fShowRTSStats_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(ccJo2,
                       label: GHC.Stats.$fShowRTSStats_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJo2: // global
           if ((Sp + -168) < SpLim) (likely: False) goto ccJo3; else goto ccJo4;
       ccJo3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fShowRTSStats_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccJo4: // global
           I64[Sp - 16] = block_ccJ7M_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucJod; else goto ccJ7N;
       ucJod: // global
           call _ccJ7M(R1) args: 0, res: 0, upd: 0;
       ccJ7N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJ7M() //  [R1]
         { info_tbl: [(ccJ7M,
                       label: block_ccJ7M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ7M: // global
           I64[Sp - 152] = block_ccJ7R_info;
           _scHuW::P64 = P64[R1 + 7];
           _scHuX::P64 = P64[R1 + 15];
           _scHuY::P64 = P64[R1 + 23];
           _scHuZ::P64 = P64[R1 + 31];
           _scHv0::P64 = P64[R1 + 39];
           _scHv1::P64 = P64[R1 + 47];
           _scHv2::P64 = P64[R1 + 55];
           _scHv3::P64 = P64[R1 + 63];
           _scHv4::P64 = P64[R1 + 71];
           _scHv5::P64 = P64[R1 + 79];
           _scHv6::P64 = P64[R1 + 87];
           _scHv7::P64 = P64[R1 + 95];
           _scHv8::P64 = P64[R1 + 103];
           _scHv9::P64 = P64[R1 + 111];
           _scHva::P64 = P64[R1 + 119];
           _scHvb::P64 = P64[R1 + 127];
           _scHvc::P64 = P64[R1 + 135];
           _scHvd::P64 = P64[R1 + 143];
           _scHve::P64 = P64[R1 + 151];
           _scHvf::P64 = P64[R1 + 159];
           R1 = P64[Sp + 8];
           P64[Sp - 144] = _scHuY::P64;
           P64[Sp - 136] = _scHuZ::P64;
           P64[Sp - 128] = _scHv0::P64;
           P64[Sp - 120] = _scHv1::P64;
           P64[Sp - 112] = _scHv2::P64;
           P64[Sp - 104] = _scHv3::P64;
           P64[Sp - 96] = _scHv4::P64;
           P64[Sp - 88] = _scHv5::P64;
           P64[Sp - 80] = _scHv6::P64;
           P64[Sp - 72] = _scHv7::P64;
           P64[Sp - 64] = _scHv8::P64;
           P64[Sp - 56] = _scHv9::P64;
           P64[Sp - 48] = _scHva::P64;
           P64[Sp - 40] = _scHvb::P64;
           P64[Sp - 32] = _scHvc::P64;
           P64[Sp - 24] = _scHvd::P64;
           P64[Sp - 16] = _scHve::P64;
           P64[Sp - 8] = _scHvf::P64;
           P64[Sp] = _scHuX::P64;
           P64[Sp + 8] = _scHuW::P64;
           Sp = Sp - 152;
           if (R1 & 7 != 0) goto ucJoc; else goto ccJ7S;
       ucJoc: // global
           call _ccJ7R(R1) args: 0, res: 0, upd: 0;
       ccJ7S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJ7R() //  [R1]
         { info_tbl: [(ccJ7R,
                       label: block_ccJ7R_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJ7R: // global
           Hp = Hp + 472;
           if (Hp > HpLim) (likely: False) goto ccJo8; else goto ccJo7;
       ccJo8: // global
           HpAlloc = 472;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJo7: // global
           _scHvh::I64 = I64[R1 + 7];
           I64[Hp - 464] = w1_scHvi_info;
           P64[Hp - 448] = P64[Sp + 8];
           I64[Hp - 440] = w2_scHvn_info;
           P64[Hp - 424] = P64[Sp + 16];
           I64[Hp - 416] = w3_scHvs_info;
           P64[Hp - 400] = P64[Sp + 24];
           I64[Hp - 392] = w4_scHvx_info;
           P64[Hp - 376] = P64[Sp + 32];
           I64[Hp - 368] = w5_scHvC_info;
           P64[Hp - 352] = P64[Sp + 40];
           I64[Hp - 344] = w6_scHvH_info;
           P64[Hp - 328] = P64[Sp + 48];
           I64[Hp - 320] = w7_scHvM_info;
           P64[Hp - 304] = P64[Sp + 56];
           I64[Hp - 296] = w8_scHvR_info;
           P64[Hp - 280] = P64[Sp + 64];
           I64[Hp - 272] = w9_scHvW_info;
           P64[Hp - 256] = P64[Sp + 72];
           I64[Hp - 248] = w10_scHw1_info;
           P64[Hp - 232] = P64[Sp + 80];
           I64[Hp - 224] = w11_scHw6_info;
           P64[Hp - 208] = P64[Sp + 88];
           I64[Hp - 200] = f_scHwb_info;
           P64[Hp - 184] = P64[Sp + 144];
           I64[Hp - 176] = p_scHwc_info;
           P64[Hp - 168] = P64[Sp + 160];
           P64[Hp - 160] = P64[Sp + 152];
           P64[Hp - 152] = P64[Sp + 96];
           P64[Hp - 144] = P64[Sp + 104];
           P64[Hp - 136] = P64[Sp + 112];
           P64[Hp - 128] = P64[Sp + 120];
           P64[Hp - 120] = P64[Sp + 128];
           P64[Hp - 112] = P64[Sp + 136];
           P64[Hp - 104] = Hp - 464;
           P64[Hp - 96] = Hp - 440;
           P64[Hp - 88] = Hp - 416;
           P64[Hp - 80] = Hp - 392;
           P64[Hp - 72] = Hp - 368;
           P64[Hp - 64] = Hp - 344;
           P64[Hp - 56] = Hp - 320;
           P64[Hp - 48] = Hp - 296;
           P64[Hp - 40] = Hp - 272;
           P64[Hp - 32] = Hp - 248;
           P64[Hp - 24] = Hp - 224;
           P64[Hp - 16] = Hp - 200;
           _ccJbX::P64 = Hp - 175;
           if (%MO_S_Lt_W64(_scHvh::I64, 11)) goto ccJoa; else goto ccJob;
       ccJoa: // global
           Hp = Hp - 16;
           R1 = _ccJbX::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccJob: // global
           I64[Hp - 8] = sat_scHyt_info;
           P64[Hp] = _ccJbX::P64;
           R1 = Hp - 7;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.331718917 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_$cshow_closure" {
     GHC.Stats.$fShowRTSStats_$cshow_closure:
         const GHC.Stats.$fShowRTSStats_$cshow_info;
         const 0;
 },
 GHC.Stats.$fShowRTSStats_$cshow_entry() //  [R2]
         { info_tbl: [(ccJoi,
                       label: GHC.Stats.$fShowRTSStats_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJoi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJoj; else goto ccJok;
       ccJoj: // global
           R2 = R2;
           R1 = GHC.Stats.$fShowRTSStats_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJok: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Stats.$fShowRTSStats_$cshowsPrec_entry(R3,
                                                           R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.332771462 UTC

[section ""data" . GHC.Stats.$fShowRTSStats1_closure" {
     GHC.Stats.$fShowRTSStats1_closure:
         const GHC.Stats.$fShowRTSStats1_info;
         const 0;
 },
 GHC.Stats.$fShowRTSStats1_entry() //  [R2]
         { info_tbl: [(ccJop,
                       label: GHC.Stats.$fShowRTSStats1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJop: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           call GHC.Stats.$fShowRTSStats_$cshowsPrec_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.333706508 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_$cshowList_closure" {
     GHC.Stats.$fShowRTSStats_$cshowList_closure:
         const GHC.Stats.$fShowRTSStats_$cshowList_info;
         const 0;
 },
 GHC.Stats.$fShowRTSStats_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(ccJow,
                       label: GHC.Stats.$fShowRTSStats_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJow: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fShowRTSStats1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.334456752 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_closure" {
     GHC.Stats.$fShowRTSStats_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Stats.$fShowRTSStats_$cshowsPrec_closure+2;
         const GHC.Stats.$fShowRTSStats_$cshow_closure+1;
         const GHC.Stats.$fShowRTSStats_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.335055497 UTC

[section ""cstring" . GHC.Stats.$tcGCDetails2_bytes" {
     GHC.Stats.$tcGCDetails2_bytes:
         I8[] [71,67,68,101,116,97,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.335810593 UTC

[section ""data" . lexeme_rcHq6_closure" {
     lexeme_rcHq6_closure:
         const lexeme_rcHq6_info;
         const 0;
         const 0;
         const 0;
 },
 lexeme_rcHq6_entry() //  [R1]
         { info_tbl: [(ccJoF,
                       label: lexeme_rcHq6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJoF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJoG; else goto ccJoH;
       ccJoG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJoH: // global
           (_ccJoC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJoC::I64 == 0) goto ccJoE; else goto ccJoD;
       ccJoE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJoD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJoC::I64;
           R2 = GHC.Stats.$tcGCDetails2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.336740766 UTC

[section ""data" . lexeme1_rcHq7_closure" {
     lexeme1_rcHq7_closure:
         const Text.Read.Lex.Ident_con_info;
         const lexeme_rcHq6_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.337369987 UTC

[section ""cstring" . lexeme2_rcHq8_bytes" {
     lexeme2_rcHq8_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.33810966 UTC

[section ""data" . lexeme3_rcHq9_closure" {
     lexeme3_rcHq9_closure:
         const lexeme3_rcHq9_info;
         const 0;
         const 0;
         const 0;
 },
 lexeme3_rcHq9_entry() //  [R1]
         { info_tbl: [(ccJoO,
                       label: lexeme3_rcHq9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJoO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJoP; else goto ccJoQ;
       ccJoP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJoQ: // global
           (_ccJoL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJoL::I64 == 0) goto ccJoN; else goto ccJoM;
       ccJoN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJoM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJoL::I64;
           R2 = lexeme2_rcHq8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.339011325 UTC

[section ""data" . lexeme4_rcHqa_closure" {
     lexeme4_rcHqa_closure:
         const Text.Read.Lex.Punc_con_info;
         const lexeme3_rcHq9_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.339580198 UTC

[section ""cstring" . ds_rcHqb_bytes" {
     ds_rcHqb_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,103,101,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.34029562 UTC

[section ""data" . ds1_rcHqc_closure" {
     ds1_rcHqc_closure:
         const ds1_rcHqc_info;
         const 0;
         const 0;
         const 0;
 },
 ds1_rcHqc_entry() //  [R1]
         { info_tbl: [(ccJoX,
                       label: ds1_rcHqc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJoX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJoY; else goto ccJoZ;
       ccJoY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJoZ: // global
           (_ccJoU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJoU::I64 == 0) goto ccJoW; else goto ccJoV;
       ccJoW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJoV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJoU::I64;
           R2 = ds_rcHqb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.341375042 UTC

[section ""data" . lvl37_rcHqd_closure" {
     lvl37_rcHqd_closure:
         const lvl37_rcHqd_info;
         const 0;
 },
 lvl37_rcHqd_entry() //  [R2]
         { info_tbl: [(ccJp4,
                       label: lvl37_rcHqd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJp4: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           call GHC.Read.$fReadWord32_$creadsPrec_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.34240442 UTC

[section ""data" . ds2_rcHqe_closure" {
     ds2_rcHqe_closure:
         const ds2_rcHqe_info;
         const 0;
 },
 ds2_rcHqe_entry() //  [R2, R3]
         { info_tbl: [(ccJpe,
                       label: ds2_rcHqe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJpe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJpf; else goto ccJpg;
       ccJpf: // global
           R3 = R3;
           R2 = R2;
           R1 = ds2_rcHqe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccJpg: // global
           I64[Sp - 8] = block_ccJpb_info;
           R3 = R3;
           R2 = lvl37_rcHqd_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJpb() //  [R1]
         { info_tbl: [(ccJpb,
                       label: block_ccJpb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJpb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJpj; else goto ccJpi;
       ccJpj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJpi: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.34351006 UTC

[section ""data" . n_rcHqf_closure" {
     n_rcHqf_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.344094156 UTC

[section ""cstring" . lvl38_rcHqg_bytes" {
     lvl38_rcHqg_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.344813034 UTC

[section ""data" . lvl39_rcHqh_closure" {
     lvl39_rcHqh_closure:
         const lvl39_rcHqh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl39_rcHqh_entry() //  [R1]
         { info_tbl: [(ccJpq,
                       label: lvl39_rcHqh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJpq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJpr; else goto ccJps;
       ccJpr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJps: // global
           (_ccJpn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJpn::I64 == 0) goto ccJpp; else goto ccJpo;
       ccJpp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJpo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJpn::I64;
           R2 = lvl38_rcHqg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.345775891 UTC

[section ""data" . lvl40_rcHqi_closure" {
     lvl40_rcHqi_closure:
         const Text.Read.Lex.Punc_con_info;
         const lvl39_rcHqh_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.346405199 UTC

[section ""cstring" . lvl41_rcHqj_bytes" {
     lvl41_rcHqj_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,116,104,114,101,97,100,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.347146599 UTC

[section ""data" . lvl42_rcHqk_closure" {
     lvl42_rcHqk_closure:
         const lvl42_rcHqk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_rcHqk_entry() //  [R1]
         { info_tbl: [(ccJpz,
                       label: lvl42_rcHqk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJpz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJpA; else goto ccJpB;
       ccJpA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJpB: // global
           (_ccJpw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJpw::I64 == 0) goto ccJpy; else goto ccJpx;
       ccJpy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJpx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJpw::I64;
           R2 = lvl41_rcHqj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.348162067 UTC

[section ""cstring" . lvl43_rcHql_bytes" {
     lvl43_rcHql_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,97,108,108,111,99,97,116,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.348957228 UTC

[section ""data" . lvl44_rcHqm_closure" {
     lvl44_rcHqm_closure:
         const lvl44_rcHqm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl44_rcHqm_entry() //  [R1]
         { info_tbl: [(ccJpI,
                       label: lvl44_rcHqm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJpI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJpJ; else goto ccJpK;
       ccJpJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJpK: // global
           (_ccJpF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJpF::I64 == 0) goto ccJpH; else goto ccJpG;
       ccJpH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJpG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJpF::I64;
           R2 = lvl43_rcHql_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.350066723 UTC

[section ""data" . lvl45_rcHqn_closure" {
     lvl45_rcHqn_closure:
         const lvl45_rcHqn_info;
         const 0;
 },
 lvl45_rcHqn_entry() //  [R2]
         { info_tbl: [(ccJpP,
                       label: lvl45_rcHqn_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJpP: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           call GHC.Read.$fReadWord64_$creadsPrec_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.35110913 UTC

[section ""data" . lvl46_rcHqo_closure" {
     lvl46_rcHqo_closure:
         const lvl46_rcHqo_info;
         const 0;
 },
 lvl46_rcHqo_entry() //  [R2, R3]
         { info_tbl: [(ccJpZ,
                       label: lvl46_rcHqo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJpZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJq0; else goto ccJq1;
       ccJq0: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl46_rcHqo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccJq1: // global
           I64[Sp - 8] = block_ccJpW_info;
           R3 = R3;
           R2 = lvl45_rcHqn_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJpW() //  [R1]
         { info_tbl: [(ccJpW,
                       label: block_ccJpW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJpW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJq4; else goto ccJq3;
       ccJq4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJq3: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.352994305 UTC

[section ""cstring" . lvl47_rcHqp_bytes" {
     lvl47_rcHqp_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,105,118,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.353757606 UTC

[section ""data" . lvl48_rcHqq_closure" {
     lvl48_rcHqq_closure:
         const lvl48_rcHqq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl48_rcHqq_entry() //  [R1]
         { info_tbl: [(ccJqb,
                       label: lvl48_rcHqq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJqb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJqc; else goto ccJqd;
       ccJqc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJqd: // global
           (_ccJq8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJq8::I64 == 0) goto ccJqa; else goto ccJq9;
       ccJqa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJq9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJq8::I64;
           R2 = lvl47_rcHqp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.354636805 UTC

[section ""cstring" . lvl49_rcHqr_bytes" {
     lvl49_rcHqr_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.355353136 UTC

[section ""data" . lvl50_rcHqs_closure" {
     lvl50_rcHqs_closure:
         const lvl50_rcHqs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl50_rcHqs_entry() //  [R1]
         { info_tbl: [(ccJqk,
                       label: lvl50_rcHqs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJqk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJql; else goto ccJqm;
       ccJql: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJqm: // global
           (_ccJqh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJqh::I64 == 0) goto ccJqj; else goto ccJqi;
       ccJqj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJqi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJqh::I64;
           R2 = lvl49_rcHqr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.35620939 UTC

[section ""cstring" . lvl51_rcHqt_bytes" {
     lvl51_rcHqt_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,109,112,97,99,116,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.356915472 UTC

[section ""data" . lvl52_rcHqu_closure" {
     lvl52_rcHqu_closure:
         const lvl52_rcHqu_info;
         const 0;
         const 0;
         const 0;
 },
 lvl52_rcHqu_entry() //  [R1]
         { info_tbl: [(ccJqt,
                       label: lvl52_rcHqu_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJqt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJqu; else goto ccJqv;
       ccJqu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJqv: // global
           (_ccJqq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJqq::I64 == 0) goto ccJqs; else goto ccJqr;
       ccJqs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJqr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJqq::I64;
           R2 = lvl51_rcHqt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.357809102 UTC

[section ""cstring" . lvl53_rcHqv_bytes" {
     lvl53_rcHqv_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,108,111,112,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.358553375 UTC

[section ""data" . lvl54_rcHqw_closure" {
     lvl54_rcHqw_closure:
         const lvl54_rcHqw_info;
         const 0;
         const 0;
         const 0;
 },
 lvl54_rcHqw_entry() //  [R1]
         { info_tbl: [(ccJqC,
                       label: lvl54_rcHqw_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJqC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJqD; else goto ccJqE;
       ccJqD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJqE: // global
           (_ccJqz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJqz::I64 == 0) goto ccJqB; else goto ccJqA;
       ccJqB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJqA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJqz::I64;
           R2 = lvl53_rcHqv_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.359388436 UTC

[section ""cstring" . lvl55_rcHqx_bytes" {
     lvl55_rcHqx_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.360126307 UTC

[section ""data" . lvl56_rcHqy_closure" {
     lvl56_rcHqy_closure:
         const lvl56_rcHqy_info;
         const 0;
         const 0;
         const 0;
 },
 lvl56_rcHqy_entry() //  [R1]
         { info_tbl: [(ccJqL,
                       label: lvl56_rcHqy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJqL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJqM; else goto ccJqN;
       ccJqM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJqN: // global
           (_ccJqI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJqI::I64 == 0) goto ccJqK; else goto ccJqJ;
       ccJqK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJqJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJqI::I64;
           R2 = lvl55_rcHqx_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.36101661 UTC

[section ""cstring" . lvl57_rcHqz_bytes" {
     lvl57_rcHqz_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.361863733 UTC

[section ""data" . lvl58_rcHqA_closure" {
     lvl58_rcHqA_closure:
         const lvl58_rcHqA_info;
         const 0;
         const 0;
         const 0;
 },
 lvl58_rcHqA_entry() //  [R1]
         { info_tbl: [(ccJqU,
                       label: lvl58_rcHqA_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJqU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJqV; else goto ccJqW;
       ccJqV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJqW: // global
           (_ccJqR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJqR::I64 == 0) goto ccJqT; else goto ccJqS;
       ccJqT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJqS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJqR::I64;
           R2 = lvl57_rcHqz_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.362748983 UTC

[section ""cstring" . lvl59_rcHqB_bytes" {
     lvl59_rcHqB_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.363499958 UTC

[section ""data" . lvl60_rcHqC_closure" {
     lvl60_rcHqC_closure:
         const lvl60_rcHqC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl60_rcHqC_entry() //  [R1]
         { info_tbl: [(ccJr3,
                       label: lvl60_rcHqC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJr3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJr4; else goto ccJr5;
       ccJr4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJr5: // global
           (_ccJr0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJr0::I64 == 0) goto ccJr2; else goto ccJr1;
       ccJr2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJr1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJr0::I64;
           R2 = lvl59_rcHqB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.364395421 UTC

[section ""cstring" . lvl61_rcHqD_bytes" {
     lvl61_rcHqD_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.365142711 UTC

[section ""data" . lvl62_rcHqE_closure" {
     lvl62_rcHqE_closure:
         const lvl62_rcHqE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl62_rcHqE_entry() //  [R1]
         { info_tbl: [(ccJrc,
                       label: lvl62_rcHqE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJrc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJrd; else goto ccJre;
       ccJrd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJre: // global
           (_ccJr9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJr9::I64 == 0) goto ccJrb; else goto ccJra;
       ccJrb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJra: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJr9::I64;
           R2 = lvl61_rcHqD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.366112714 UTC

[section ""cstring" . lvl63_rcHqF_bytes" {
     lvl63_rcHqF_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,121,110,99,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.366875144 UTC

[section ""data" . lvl64_rcHqG_closure" {
     lvl64_rcHqG_closure:
         const lvl64_rcHqG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl64_rcHqG_entry() //  [R1]
         { info_tbl: [(ccJrl,
                       label: lvl64_rcHqG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJrl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJrm; else goto ccJrn;
       ccJrm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJrn: // global
           (_ccJri::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJri::I64 == 0) goto ccJrk; else goto ccJrj;
       ccJrk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJrj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJri::I64;
           R2 = lvl63_rcHqF_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.367906064 UTC

[section ""data" . lvl65_rcHqH_closure" {
     lvl65_rcHqH_closure:
         const lvl65_rcHqH_info;
         const 0;
 },
 lvl65_rcHqH_entry() //  [R2]
         { info_tbl: [(ccJrs,
                       label: lvl65_rcHqH_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJrs: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           call GHC.Int.$fReadInt64_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.368896125 UTC

[section ""data" . lvl66_rcHqI_closure" {
     lvl66_rcHqI_closure:
         const lvl66_rcHqI_info;
         const 0;
 },
 lvl66_rcHqI_entry() //  [R2, R3]
         { info_tbl: [(ccJrC,
                       label: lvl66_rcHqI_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJrC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJrD; else goto ccJrE;
       ccJrD: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl66_rcHqI_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccJrE: // global
           I64[Sp - 8] = block_ccJrz_info;
           R3 = R3;
           R2 = lvl65_rcHqH_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJrz() //  [R1]
         { info_tbl: [(ccJrz,
                       label: block_ccJrz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJrz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJrH; else goto ccJrG;
       ccJrH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJrG: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.370000021 UTC

[section ""cstring" . lvl67_rcHqJ_bytes" {
     lvl67_rcHqJ_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.37071769 UTC

[section ""data" . lvl68_rcHqK_closure" {
     lvl68_rcHqK_closure:
         const lvl68_rcHqK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl68_rcHqK_entry() //  [R1]
         { info_tbl: [(ccJrO,
                       label: lvl68_rcHqK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJrO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJrP; else goto ccJrQ;
       ccJrP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJrQ: // global
           (_ccJrL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJrL::I64 == 0) goto ccJrN; else goto ccJrM;
       ccJrN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJrM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJrL::I64;
           R2 = lvl67_rcHqJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.371643749 UTC

[section ""cstring" . lvl69_rcHqL_bytes" {
     lvl69_rcHqL_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.372373763 UTC

[section ""data" . lvl70_rcHqM_closure" {
     lvl70_rcHqM_closure:
         const lvl70_rcHqM_info;
         const 0;
         const 0;
         const 0;
 },
 lvl70_rcHqM_entry() //  [R1]
         { info_tbl: [(ccJrX,
                       label: lvl70_rcHqM_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJrX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJrY; else goto ccJrZ;
       ccJrY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJrZ: // global
           (_ccJrU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJrU::I64 == 0) goto ccJrW; else goto ccJrV;
       ccJrW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJrV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJrU::I64;
           R2 = lvl69_rcHqL_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.373525747 UTC

[section ""data" . lvl71_rcHqN_closure" {
     lvl71_rcHqN_closure:
         const lvl71_rcHqN_info;
         const 0;
         const 0;
         const 0;
 },
 lvl71_rcHqN_entry() //  [R1]
         { info_tbl: [(ccJs6,
                       label: lvl71_rcHqN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJs6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJs7; else goto ccJs8;
       ccJs7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJs8: // global
           (_ccJs3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJs3::I64 == 0) goto ccJs5; else goto ccJs4;
       ccJs5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJs4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJs3::I64;
           R2 = lvl15_rcHpK_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.374478685 UTC

[section ""data" . lvl72_rcHqO_closure" {
     lvl72_rcHqO_closure:
         const Text.Read.Lex.Punc_con_info;
         const lvl71_rcHqN_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.383077011 UTC

[section ""data" . GHC.Stats.$w$creadPrec_closure" {
     GHC.Stats.$w$creadPrec_closure:
         const GHC.Stats.$w$creadPrec_info;
         const 0;
 },
 sat_scHzh_entry() //  [R1, R2]
         { info_tbl: [(ccJuI,
                       label: sat_scHzh_info
                       rep:HeapRep 15 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJuI: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccJuM; else goto ccJuL;
       ccJuM: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJuL: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           _scHz8::P64 = P64[R1 + 95];
           _scHza::P64 = P64[R1 + 103];
           _scHzc::P64 = P64[R1 + 111];
           _scHze::P64 = P64[R1 + 119];
           I64[Hp - 112] = GHC.Stats.GCDetails_con_info;
           P64[Hp - 104] = _scHyO::P64;
           P64[Hp - 96] = _scHyQ::P64;
           P64[Hp - 88] = _scHyS::P64;
           P64[Hp - 80] = _scHyU::P64;
           P64[Hp - 72] = _scHyW::P64;
           P64[Hp - 64] = _scHyY::P64;
           P64[Hp - 56] = _scHz0::P64;
           P64[Hp - 48] = _scHz2::P64;
           P64[Hp - 40] = _scHz4::P64;
           P64[Hp - 32] = _scHz6::P64;
           P64[Hp - 24] = _scHz8::P64;
           P64[Hp - 16] = _scHza::P64;
           P64[Hp - 8] = _scHzc::P64;
           P64[Hp] = _scHze::P64;
           R2 = Hp - 111;
           R1 = _scHyK::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzk_entry() //  [R1, R2]
         { info_tbl: [(ccJuQ,
                       label: sat_scHzk_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJuQ: // global
           _scHze::P64 = R2;
           _scHzk::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJuR; else goto ccJuS;
       ccJuS: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccJuU; else goto ccJuT;
       ccJuU: // global
           HpAlloc = 128;
           goto ccJuR;
       ccJuR: // global
           R2 = _scHze::P64;
           R1 = _scHzk::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJuT: // global
           _scHyK::P64 = P64[_scHzk::P64 + 7];
           _scHyO::P64 = P64[_scHzk::P64 + 15];
           _scHyQ::P64 = P64[_scHzk::P64 + 23];
           _scHyS::P64 = P64[_scHzk::P64 + 31];
           _scHyU::P64 = P64[_scHzk::P64 + 39];
           _scHyW::P64 = P64[_scHzk::P64 + 47];
           _scHyY::P64 = P64[_scHzk::P64 + 55];
           _scHz0::P64 = P64[_scHzk::P64 + 63];
           _scHz2::P64 = P64[_scHzk::P64 + 71];
           _scHz4::P64 = P64[_scHzk::P64 + 79];
           _scHz6::P64 = P64[_scHzk::P64 + 87];
           _scHz8::P64 = P64[_scHzk::P64 + 95];
           _scHza::P64 = P64[_scHzk::P64 + 103];
           _scHzc::P64 = P64[_scHzk::P64 + 111];
           I64[Hp - 120] = sat_scHzh_info;
           P64[Hp - 112] = _scHyK::P64;
           P64[Hp - 104] = _scHyO::P64;
           P64[Hp - 96] = _scHyQ::P64;
           P64[Hp - 88] = _scHyS::P64;
           P64[Hp - 80] = _scHyU::P64;
           P64[Hp - 72] = _scHyW::P64;
           P64[Hp - 64] = _scHyY::P64;
           P64[Hp - 56] = _scHz0::P64;
           P64[Hp - 48] = _scHz2::P64;
           P64[Hp - 40] = _scHz4::P64;
           P64[Hp - 32] = _scHz6::P64;
           P64[Hp - 24] = _scHz8::P64;
           P64[Hp - 16] = _scHza::P64;
           P64[Hp - 8] = _scHzc::P64;
           P64[Hp] = _scHze::P64;
           I64[Sp - 8] = block_ccJuN_info;
           R3 = Hp - 119;
           R2 = lvl72_rcHqO_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJuN() //  [R1]
         { info_tbl: [(ccJuN,
                       label: block_ccJuN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJuN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJuX; else goto ccJuW;
       ccJuX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJuW: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzl_entry() //  [R1, R2]
         { info_tbl: [(ccJuY,
                       label: sat_scHzl_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJuY: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccJv2; else goto ccJv1;
       ccJv2: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJv1: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           _scHz8::P64 = P64[R1 + 95];
           _scHza::P64 = P64[R1 + 103];
           _scHzc::P64 = P64[R1 + 111];
           I64[Hp - 112] = sat_scHzk_info;
           P64[Hp - 104] = _scHyK::P64;
           P64[Hp - 96] = _scHyO::P64;
           P64[Hp - 88] = _scHyQ::P64;
           P64[Hp - 80] = _scHyS::P64;
           P64[Hp - 72] = _scHyU::P64;
           P64[Hp - 64] = _scHyW::P64;
           P64[Hp - 56] = _scHyY::P64;
           P64[Hp - 48] = _scHz0::P64;
           P64[Hp - 40] = _scHz2::P64;
           P64[Hp - 32] = _scHz4::P64;
           P64[Hp - 24] = _scHz6::P64;
           P64[Hp - 16] = _scHz8::P64;
           P64[Hp - 8] = _scHza::P64;
           P64[Hp] = _scHzc::P64;
           R5 = Hp - 111;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl70_rcHqM_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzo_entry() //  [R1, R2]
         { info_tbl: [(ccJv6,
                       label: sat_scHzo_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJv6: // global
           _scHzc::P64 = R2;
           _scHzo::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJv7; else goto ccJv8;
       ccJv8: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccJva; else goto ccJv9;
       ccJva: // global
           HpAlloc = 120;
           goto ccJv7;
       ccJv7: // global
           R2 = _scHzc::P64;
           R1 = _scHzo::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJv9: // global
           _scHyK::P64 = P64[_scHzo::P64 + 7];
           _scHyO::P64 = P64[_scHzo::P64 + 15];
           _scHyQ::P64 = P64[_scHzo::P64 + 23];
           _scHyS::P64 = P64[_scHzo::P64 + 31];
           _scHyU::P64 = P64[_scHzo::P64 + 39];
           _scHyW::P64 = P64[_scHzo::P64 + 47];
           _scHyY::P64 = P64[_scHzo::P64 + 55];
           _scHz0::P64 = P64[_scHzo::P64 + 63];
           _scHz2::P64 = P64[_scHzo::P64 + 71];
           _scHz4::P64 = P64[_scHzo::P64 + 79];
           _scHz6::P64 = P64[_scHzo::P64 + 87];
           _scHz8::P64 = P64[_scHzo::P64 + 95];
           _scHza::P64 = P64[_scHzo::P64 + 103];
           I64[Hp - 112] = sat_scHzl_info;
           P64[Hp - 104] = _scHyK::P64;
           P64[Hp - 96] = _scHyO::P64;
           P64[Hp - 88] = _scHyQ::P64;
           P64[Hp - 80] = _scHyS::P64;
           P64[Hp - 72] = _scHyU::P64;
           P64[Hp - 64] = _scHyW::P64;
           P64[Hp - 56] = _scHyY::P64;
           P64[Hp - 48] = _scHz0::P64;
           P64[Hp - 40] = _scHz2::P64;
           P64[Hp - 32] = _scHz4::P64;
           P64[Hp - 24] = _scHz6::P64;
           P64[Hp - 16] = _scHz8::P64;
           P64[Hp - 8] = _scHza::P64;
           P64[Hp] = _scHzc::P64;
           I64[Sp - 8] = block_ccJv3_info;
           R3 = Hp - 111;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJv3() //  [R1]
         { info_tbl: [(ccJv3,
                       label: block_ccJv3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJv3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJvd; else goto ccJvc;
       ccJvd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJvc: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzp_entry() //  [R1, R2]
         { info_tbl: [(ccJve,
                       label: sat_scHzp_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJve: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccJvi; else goto ccJvh;
       ccJvi: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJvh: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           _scHz8::P64 = P64[R1 + 95];
           _scHza::P64 = P64[R1 + 103];
           I64[Hp - 104] = sat_scHzo_info;
           P64[Hp - 96] = _scHyK::P64;
           P64[Hp - 88] = _scHyO::P64;
           P64[Hp - 80] = _scHyQ::P64;
           P64[Hp - 72] = _scHyS::P64;
           P64[Hp - 64] = _scHyU::P64;
           P64[Hp - 56] = _scHyW::P64;
           P64[Hp - 48] = _scHyY::P64;
           P64[Hp - 40] = _scHz0::P64;
           P64[Hp - 32] = _scHz2::P64;
           P64[Hp - 24] = _scHz4::P64;
           P64[Hp - 16] = _scHz6::P64;
           P64[Hp - 8] = _scHz8::P64;
           P64[Hp] = _scHza::P64;
           R5 = Hp - 103;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl68_rcHqK_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzs_entry() //  [R1, R2]
         { info_tbl: [(ccJvm,
                       label: sat_scHzs_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJvm: // global
           _scHza::P64 = R2;
           _scHzs::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJvn; else goto ccJvo;
       ccJvo: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccJvq; else goto ccJvp;
       ccJvq: // global
           HpAlloc = 112;
           goto ccJvn;
       ccJvn: // global
           R2 = _scHza::P64;
           R1 = _scHzs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJvp: // global
           _scHyK::P64 = P64[_scHzs::P64 + 7];
           _scHyO::P64 = P64[_scHzs::P64 + 15];
           _scHyQ::P64 = P64[_scHzs::P64 + 23];
           _scHyS::P64 = P64[_scHzs::P64 + 31];
           _scHyU::P64 = P64[_scHzs::P64 + 39];
           _scHyW::P64 = P64[_scHzs::P64 + 47];
           _scHyY::P64 = P64[_scHzs::P64 + 55];
           _scHz0::P64 = P64[_scHzs::P64 + 63];
           _scHz2::P64 = P64[_scHzs::P64 + 71];
           _scHz4::P64 = P64[_scHzs::P64 + 79];
           _scHz6::P64 = P64[_scHzs::P64 + 87];
           _scHz8::P64 = P64[_scHzs::P64 + 95];
           I64[Hp - 104] = sat_scHzp_info;
           P64[Hp - 96] = _scHyK::P64;
           P64[Hp - 88] = _scHyO::P64;
           P64[Hp - 80] = _scHyQ::P64;
           P64[Hp - 72] = _scHyS::P64;
           P64[Hp - 64] = _scHyU::P64;
           P64[Hp - 56] = _scHyW::P64;
           P64[Hp - 48] = _scHyY::P64;
           P64[Hp - 40] = _scHz0::P64;
           P64[Hp - 32] = _scHz2::P64;
           P64[Hp - 24] = _scHz4::P64;
           P64[Hp - 16] = _scHz6::P64;
           P64[Hp - 8] = _scHz8::P64;
           P64[Hp] = _scHza::P64;
           I64[Sp - 8] = block_ccJvj_info;
           R3 = Hp - 103;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJvj() //  [R1]
         { info_tbl: [(ccJvj,
                       label: block_ccJvj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJvj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJvt; else goto ccJvs;
       ccJvt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJvs: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzt_entry() //  [R1, R2]
         { info_tbl: [(ccJvu,
                       label: sat_scHzt_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJvu: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccJvy; else goto ccJvx;
       ccJvy: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJvx: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           _scHz8::P64 = P64[R1 + 95];
           I64[Hp - 96] = sat_scHzs_info;
           P64[Hp - 88] = _scHyK::P64;
           P64[Hp - 80] = _scHyO::P64;
           P64[Hp - 72] = _scHyQ::P64;
           P64[Hp - 64] = _scHyS::P64;
           P64[Hp - 56] = _scHyU::P64;
           P64[Hp - 48] = _scHyW::P64;
           P64[Hp - 40] = _scHyY::P64;
           P64[Hp - 32] = _scHz0::P64;
           P64[Hp - 24] = _scHz2::P64;
           P64[Hp - 16] = _scHz4::P64;
           P64[Hp - 8] = _scHz6::P64;
           P64[Hp] = _scHz8::P64;
           R5 = Hp - 95;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl64_rcHqG_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzw_entry() //  [R1, R2]
         { info_tbl: [(ccJvC,
                       label: sat_scHzw_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJvC: // global
           _scHz8::P64 = R2;
           _scHzw::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJvD; else goto ccJvE;
       ccJvE: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccJvG; else goto ccJvF;
       ccJvG: // global
           HpAlloc = 104;
           goto ccJvD;
       ccJvD: // global
           R2 = _scHz8::P64;
           R1 = _scHzw::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJvF: // global
           _scHyK::P64 = P64[_scHzw::P64 + 7];
           _scHyO::P64 = P64[_scHzw::P64 + 15];
           _scHyQ::P64 = P64[_scHzw::P64 + 23];
           _scHyS::P64 = P64[_scHzw::P64 + 31];
           _scHyU::P64 = P64[_scHzw::P64 + 39];
           _scHyW::P64 = P64[_scHzw::P64 + 47];
           _scHyY::P64 = P64[_scHzw::P64 + 55];
           _scHz0::P64 = P64[_scHzw::P64 + 63];
           _scHz2::P64 = P64[_scHzw::P64 + 71];
           _scHz4::P64 = P64[_scHzw::P64 + 79];
           _scHz6::P64 = P64[_scHzw::P64 + 87];
           I64[Hp - 96] = sat_scHzt_info;
           P64[Hp - 88] = _scHyK::P64;
           P64[Hp - 80] = _scHyO::P64;
           P64[Hp - 72] = _scHyQ::P64;
           P64[Hp - 64] = _scHyS::P64;
           P64[Hp - 56] = _scHyU::P64;
           P64[Hp - 48] = _scHyW::P64;
           P64[Hp - 40] = _scHyY::P64;
           P64[Hp - 32] = _scHz0::P64;
           P64[Hp - 24] = _scHz2::P64;
           P64[Hp - 16] = _scHz4::P64;
           P64[Hp - 8] = _scHz6::P64;
           P64[Hp] = _scHz8::P64;
           I64[Sp - 8] = block_ccJvz_info;
           R3 = Hp - 95;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJvz() //  [R1]
         { info_tbl: [(ccJvz,
                       label: block_ccJvz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJvz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJvJ; else goto ccJvI;
       ccJvJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJvI: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzx_entry() //  [R1, R2]
         { info_tbl: [(ccJvK,
                       label: sat_scHzx_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJvK: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccJvO; else goto ccJvN;
       ccJvO: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJvN: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           I64[Hp - 88] = sat_scHzw_info;
           P64[Hp - 80] = _scHyK::P64;
           P64[Hp - 72] = _scHyO::P64;
           P64[Hp - 64] = _scHyQ::P64;
           P64[Hp - 56] = _scHyS::P64;
           P64[Hp - 48] = _scHyU::P64;
           P64[Hp - 40] = _scHyW::P64;
           P64[Hp - 32] = _scHyY::P64;
           P64[Hp - 24] = _scHz0::P64;
           P64[Hp - 16] = _scHz2::P64;
           P64[Hp - 8] = _scHz4::P64;
           P64[Hp] = _scHz6::P64;
           R5 = Hp - 87;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl62_rcHqE_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzA_entry() //  [R1, R2]
         { info_tbl: [(ccJvS,
                       label: sat_scHzA_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJvS: // global
           _scHz6::P64 = R2;
           _scHzA::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJvT; else goto ccJvU;
       ccJvU: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccJvW; else goto ccJvV;
       ccJvW: // global
           HpAlloc = 96;
           goto ccJvT;
       ccJvT: // global
           R2 = _scHz6::P64;
           R1 = _scHzA::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJvV: // global
           _scHyK::P64 = P64[_scHzA::P64 + 7];
           _scHyO::P64 = P64[_scHzA::P64 + 15];
           _scHyQ::P64 = P64[_scHzA::P64 + 23];
           _scHyS::P64 = P64[_scHzA::P64 + 31];
           _scHyU::P64 = P64[_scHzA::P64 + 39];
           _scHyW::P64 = P64[_scHzA::P64 + 47];
           _scHyY::P64 = P64[_scHzA::P64 + 55];
           _scHz0::P64 = P64[_scHzA::P64 + 63];
           _scHz2::P64 = P64[_scHzA::P64 + 71];
           _scHz4::P64 = P64[_scHzA::P64 + 79];
           I64[Hp - 88] = sat_scHzx_info;
           P64[Hp - 80] = _scHyK::P64;
           P64[Hp - 72] = _scHyO::P64;
           P64[Hp - 64] = _scHyQ::P64;
           P64[Hp - 56] = _scHyS::P64;
           P64[Hp - 48] = _scHyU::P64;
           P64[Hp - 40] = _scHyW::P64;
           P64[Hp - 32] = _scHyY::P64;
           P64[Hp - 24] = _scHz0::P64;
           P64[Hp - 16] = _scHz2::P64;
           P64[Hp - 8] = _scHz4::P64;
           P64[Hp] = _scHz6::P64;
           I64[Sp - 8] = block_ccJvP_info;
           R3 = Hp - 87;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJvP() //  [R1]
         { info_tbl: [(ccJvP,
                       label: block_ccJvP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJvP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJvZ; else goto ccJvY;
       ccJvZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJvY: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzB_entry() //  [R1, R2]
         { info_tbl: [(ccJw0,
                       label: sat_scHzB_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJw0: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccJw4; else goto ccJw3;
       ccJw4: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJw3: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           I64[Hp - 80] = sat_scHzA_info;
           P64[Hp - 72] = _scHyK::P64;
           P64[Hp - 64] = _scHyO::P64;
           P64[Hp - 56] = _scHyQ::P64;
           P64[Hp - 48] = _scHyS::P64;
           P64[Hp - 40] = _scHyU::P64;
           P64[Hp - 32] = _scHyW::P64;
           P64[Hp - 24] = _scHyY::P64;
           P64[Hp - 16] = _scHz0::P64;
           P64[Hp - 8] = _scHz2::P64;
           P64[Hp] = _scHz4::P64;
           R5 = Hp - 79;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl60_rcHqC_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzE_entry() //  [R1, R2]
         { info_tbl: [(ccJw8,
                       label: sat_scHzE_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJw8: // global
           _scHz4::P64 = R2;
           _scHzE::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJw9; else goto ccJwa;
       ccJwa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccJwc; else goto ccJwb;
       ccJwc: // global
           HpAlloc = 88;
           goto ccJw9;
       ccJw9: // global
           R2 = _scHz4::P64;
           R1 = _scHzE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJwb: // global
           _scHyK::P64 = P64[_scHzE::P64 + 7];
           _scHyO::P64 = P64[_scHzE::P64 + 15];
           _scHyQ::P64 = P64[_scHzE::P64 + 23];
           _scHyS::P64 = P64[_scHzE::P64 + 31];
           _scHyU::P64 = P64[_scHzE::P64 + 39];
           _scHyW::P64 = P64[_scHzE::P64 + 47];
           _scHyY::P64 = P64[_scHzE::P64 + 55];
           _scHz0::P64 = P64[_scHzE::P64 + 63];
           _scHz2::P64 = P64[_scHzE::P64 + 71];
           I64[Hp - 80] = sat_scHzB_info;
           P64[Hp - 72] = _scHyK::P64;
           P64[Hp - 64] = _scHyO::P64;
           P64[Hp - 56] = _scHyQ::P64;
           P64[Hp - 48] = _scHyS::P64;
           P64[Hp - 40] = _scHyU::P64;
           P64[Hp - 32] = _scHyW::P64;
           P64[Hp - 24] = _scHyY::P64;
           P64[Hp - 16] = _scHz0::P64;
           P64[Hp - 8] = _scHz2::P64;
           P64[Hp] = _scHz4::P64;
           I64[Sp - 8] = block_ccJw5_info;
           R3 = Hp - 79;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJw5() //  [R1]
         { info_tbl: [(ccJw5,
                       label: block_ccJw5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJw5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJwf; else goto ccJwe;
       ccJwf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJwe: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzF_entry() //  [R1, R2]
         { info_tbl: [(ccJwg,
                       label: sat_scHzF_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJwg: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccJwk; else goto ccJwj;
       ccJwk: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJwj: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           I64[Hp - 72] = sat_scHzE_info;
           P64[Hp - 64] = _scHyK::P64;
           P64[Hp - 56] = _scHyO::P64;
           P64[Hp - 48] = _scHyQ::P64;
           P64[Hp - 40] = _scHyS::P64;
           P64[Hp - 32] = _scHyU::P64;
           P64[Hp - 24] = _scHyW::P64;
           P64[Hp - 16] = _scHyY::P64;
           P64[Hp - 8] = _scHz0::P64;
           P64[Hp] = _scHz2::P64;
           R5 = Hp - 71;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl58_rcHqA_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzI_entry() //  [R1, R2]
         { info_tbl: [(ccJwo,
                       label: sat_scHzI_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJwo: // global
           _scHz2::P64 = R2;
           _scHzI::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJwp; else goto ccJwq;
       ccJwq: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccJws; else goto ccJwr;
       ccJws: // global
           HpAlloc = 80;
           goto ccJwp;
       ccJwp: // global
           R2 = _scHz2::P64;
           R1 = _scHzI::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJwr: // global
           _scHyK::P64 = P64[_scHzI::P64 + 7];
           _scHyO::P64 = P64[_scHzI::P64 + 15];
           _scHyQ::P64 = P64[_scHzI::P64 + 23];
           _scHyS::P64 = P64[_scHzI::P64 + 31];
           _scHyU::P64 = P64[_scHzI::P64 + 39];
           _scHyW::P64 = P64[_scHzI::P64 + 47];
           _scHyY::P64 = P64[_scHzI::P64 + 55];
           _scHz0::P64 = P64[_scHzI::P64 + 63];
           I64[Hp - 72] = sat_scHzF_info;
           P64[Hp - 64] = _scHyK::P64;
           P64[Hp - 56] = _scHyO::P64;
           P64[Hp - 48] = _scHyQ::P64;
           P64[Hp - 40] = _scHyS::P64;
           P64[Hp - 32] = _scHyU::P64;
           P64[Hp - 24] = _scHyW::P64;
           P64[Hp - 16] = _scHyY::P64;
           P64[Hp - 8] = _scHz0::P64;
           P64[Hp] = _scHz2::P64;
           I64[Sp - 8] = block_ccJwl_info;
           R3 = Hp - 71;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJwl() //  [R1]
         { info_tbl: [(ccJwl,
                       label: block_ccJwl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJwl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJwv; else goto ccJwu;
       ccJwv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJwu: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzJ_entry() //  [R1, R2]
         { info_tbl: [(ccJww,
                       label: sat_scHzJ_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJww: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccJwA; else goto ccJwz;
       ccJwA: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJwz: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           I64[Hp - 64] = sat_scHzI_info;
           P64[Hp - 56] = _scHyK::P64;
           P64[Hp - 48] = _scHyO::P64;
           P64[Hp - 40] = _scHyQ::P64;
           P64[Hp - 32] = _scHyS::P64;
           P64[Hp - 24] = _scHyU::P64;
           P64[Hp - 16] = _scHyW::P64;
           P64[Hp - 8] = _scHyY::P64;
           P64[Hp] = _scHz0::P64;
           R5 = Hp - 63;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl56_rcHqy_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzM_entry() //  [R1, R2]
         { info_tbl: [(ccJwE,
                       label: sat_scHzM_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJwE: // global
           _scHz0::P64 = R2;
           _scHzM::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJwF; else goto ccJwG;
       ccJwG: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccJwI; else goto ccJwH;
       ccJwI: // global
           HpAlloc = 72;
           goto ccJwF;
       ccJwF: // global
           R2 = _scHz0::P64;
           R1 = _scHzM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJwH: // global
           _scHyK::P64 = P64[_scHzM::P64 + 7];
           _scHyO::P64 = P64[_scHzM::P64 + 15];
           _scHyQ::P64 = P64[_scHzM::P64 + 23];
           _scHyS::P64 = P64[_scHzM::P64 + 31];
           _scHyU::P64 = P64[_scHzM::P64 + 39];
           _scHyW::P64 = P64[_scHzM::P64 + 47];
           _scHyY::P64 = P64[_scHzM::P64 + 55];
           I64[Hp - 64] = sat_scHzJ_info;
           P64[Hp - 56] = _scHyK::P64;
           P64[Hp - 48] = _scHyO::P64;
           P64[Hp - 40] = _scHyQ::P64;
           P64[Hp - 32] = _scHyS::P64;
           P64[Hp - 24] = _scHyU::P64;
           P64[Hp - 16] = _scHyW::P64;
           P64[Hp - 8] = _scHyY::P64;
           P64[Hp] = _scHz0::P64;
           I64[Sp - 8] = block_ccJwB_info;
           R3 = Hp - 63;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJwB() //  [R1]
         { info_tbl: [(ccJwB,
                       label: block_ccJwB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJwB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJwL; else goto ccJwK;
       ccJwL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJwK: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzN_entry() //  [R1, R2]
         { info_tbl: [(ccJwM,
                       label: sat_scHzN_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJwM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccJwQ; else goto ccJwP;
       ccJwQ: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJwP: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           I64[Hp - 56] = sat_scHzM_info;
           P64[Hp - 48] = _scHyK::P64;
           P64[Hp - 40] = _scHyO::P64;
           P64[Hp - 32] = _scHyQ::P64;
           P64[Hp - 24] = _scHyS::P64;
           P64[Hp - 16] = _scHyU::P64;
           P64[Hp - 8] = _scHyW::P64;
           P64[Hp] = _scHyY::P64;
           R5 = Hp - 55;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl54_rcHqw_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzQ_entry() //  [R1, R2]
         { info_tbl: [(ccJwU,
                       label: sat_scHzQ_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJwU: // global
           _scHyY::P64 = R2;
           _scHzQ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJwV; else goto ccJwW;
       ccJwW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccJwY; else goto ccJwX;
       ccJwY: // global
           HpAlloc = 64;
           goto ccJwV;
       ccJwV: // global
           R2 = _scHyY::P64;
           R1 = _scHzQ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJwX: // global
           _scHyK::P64 = P64[_scHzQ::P64 + 7];
           _scHyO::P64 = P64[_scHzQ::P64 + 15];
           _scHyQ::P64 = P64[_scHzQ::P64 + 23];
           _scHyS::P64 = P64[_scHzQ::P64 + 31];
           _scHyU::P64 = P64[_scHzQ::P64 + 39];
           _scHyW::P64 = P64[_scHzQ::P64 + 47];
           I64[Hp - 56] = sat_scHzN_info;
           P64[Hp - 48] = _scHyK::P64;
           P64[Hp - 40] = _scHyO::P64;
           P64[Hp - 32] = _scHyQ::P64;
           P64[Hp - 24] = _scHyS::P64;
           P64[Hp - 16] = _scHyU::P64;
           P64[Hp - 8] = _scHyW::P64;
           P64[Hp] = _scHyY::P64;
           I64[Sp - 8] = block_ccJwR_info;
           R3 = Hp - 55;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJwR() //  [R1]
         { info_tbl: [(ccJwR,
                       label: block_ccJwR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJwR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJx1; else goto ccJx0;
       ccJx1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJx0: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzR_entry() //  [R1, R2]
         { info_tbl: [(ccJx2,
                       label: sat_scHzR_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJx2: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccJx6; else goto ccJx5;
       ccJx6: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJx5: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           I64[Hp - 48] = sat_scHzQ_info;
           P64[Hp - 40] = _scHyK::P64;
           P64[Hp - 32] = _scHyO::P64;
           P64[Hp - 24] = _scHyQ::P64;
           P64[Hp - 16] = _scHyS::P64;
           P64[Hp - 8] = _scHyU::P64;
           P64[Hp] = _scHyW::P64;
           R5 = Hp - 47;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl52_rcHqu_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzU_entry() //  [R1, R2]
         { info_tbl: [(ccJxa,
                       label: sat_scHzU_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJxa: // global
           _scHyW::P64 = R2;
           _scHzU::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJxb; else goto ccJxc;
       ccJxc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccJxe; else goto ccJxd;
       ccJxe: // global
           HpAlloc = 56;
           goto ccJxb;
       ccJxb: // global
           R2 = _scHyW::P64;
           R1 = _scHzU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJxd: // global
           _scHyK::P64 = P64[_scHzU::P64 + 7];
           _scHyO::P64 = P64[_scHzU::P64 + 15];
           _scHyQ::P64 = P64[_scHzU::P64 + 23];
           _scHyS::P64 = P64[_scHzU::P64 + 31];
           _scHyU::P64 = P64[_scHzU::P64 + 39];
           I64[Hp - 48] = sat_scHzR_info;
           P64[Hp - 40] = _scHyK::P64;
           P64[Hp - 32] = _scHyO::P64;
           P64[Hp - 24] = _scHyQ::P64;
           P64[Hp - 16] = _scHyS::P64;
           P64[Hp - 8] = _scHyU::P64;
           P64[Hp] = _scHyW::P64;
           I64[Sp - 8] = block_ccJx7_info;
           R3 = Hp - 47;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJx7() //  [R1]
         { info_tbl: [(ccJx7,
                       label: block_ccJx7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJx7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJxh; else goto ccJxg;
       ccJxh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJxg: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzV_entry() //  [R1, R2]
         { info_tbl: [(ccJxi,
                       label: sat_scHzV_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJxi: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccJxm; else goto ccJxl;
       ccJxm: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJxl: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           I64[Hp - 40] = sat_scHzU_info;
           P64[Hp - 32] = _scHyK::P64;
           P64[Hp - 24] = _scHyO::P64;
           P64[Hp - 16] = _scHyQ::P64;
           P64[Hp - 8] = _scHyS::P64;
           P64[Hp] = _scHyU::P64;
           R5 = Hp - 39;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl50_rcHqs_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzY_entry() //  [R1, R2]
         { info_tbl: [(ccJxq,
                       label: sat_scHzY_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJxq: // global
           _scHyU::P64 = R2;
           _scHzY::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJxr; else goto ccJxs;
       ccJxs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccJxu; else goto ccJxt;
       ccJxu: // global
           HpAlloc = 48;
           goto ccJxr;
       ccJxr: // global
           R2 = _scHyU::P64;
           R1 = _scHzY::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJxt: // global
           _scHyK::P64 = P64[_scHzY::P64 + 7];
           _scHyO::P64 = P64[_scHzY::P64 + 15];
           _scHyQ::P64 = P64[_scHzY::P64 + 23];
           _scHyS::P64 = P64[_scHzY::P64 + 31];
           I64[Hp - 40] = sat_scHzV_info;
           P64[Hp - 32] = _scHyK::P64;
           P64[Hp - 24] = _scHyO::P64;
           P64[Hp - 16] = _scHyQ::P64;
           P64[Hp - 8] = _scHyS::P64;
           P64[Hp] = _scHyU::P64;
           I64[Sp - 8] = block_ccJxn_info;
           R3 = Hp - 39;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJxn() //  [R1]
         { info_tbl: [(ccJxn,
                       label: block_ccJxn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJxn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJxx; else goto ccJxw;
       ccJxx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJxw: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzZ_entry() //  [R1, R2]
         { info_tbl: [(ccJxy,
                       label: sat_scHzZ_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJxy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccJxC; else goto ccJxB;
       ccJxC: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJxB: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           I64[Hp - 32] = sat_scHzY_info;
           P64[Hp - 24] = _scHyK::P64;
           P64[Hp - 16] = _scHyO::P64;
           P64[Hp - 8] = _scHyQ::P64;
           P64[Hp] = _scHyS::P64;
           R5 = Hp - 31;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl48_rcHqq_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHA2_entry() //  [R1, R2]
         { info_tbl: [(ccJxG,
                       label: sat_scHA2_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJxG: // global
           _scHyS::P64 = R2;
           _scHA2::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJxH; else goto ccJxI;
       ccJxI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccJxK; else goto ccJxJ;
       ccJxK: // global
           HpAlloc = 40;
           goto ccJxH;
       ccJxH: // global
           R2 = _scHyS::P64;
           R1 = _scHA2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJxJ: // global
           _scHyK::P64 = P64[_scHA2::P64 + 7];
           _scHyO::P64 = P64[_scHA2::P64 + 15];
           _scHyQ::P64 = P64[_scHA2::P64 + 23];
           I64[Hp - 32] = sat_scHzZ_info;
           P64[Hp - 24] = _scHyK::P64;
           P64[Hp - 16] = _scHyO::P64;
           P64[Hp - 8] = _scHyQ::P64;
           P64[Hp] = _scHyS::P64;
           I64[Sp - 8] = block_ccJxD_info;
           R3 = Hp - 31;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJxD() //  [R1]
         { info_tbl: [(ccJxD,
                       label: block_ccJxD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJxD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJxN; else goto ccJxM;
       ccJxN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJxM: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHA3_entry() //  [R1, R2]
         { info_tbl: [(ccJxO,
                       label: sat_scHA3_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJxO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccJxS; else goto ccJxR;
       ccJxS: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJxR: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           I64[Hp - 24] = sat_scHA2_info;
           P64[Hp - 16] = _scHyK::P64;
           P64[Hp - 8] = _scHyO::P64;
           P64[Hp] = _scHyQ::P64;
           R5 = Hp - 23;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl44_rcHqm_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHA6_entry() //  [R1, R2]
         { info_tbl: [(ccJxW,
                       label: sat_scHA6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJxW: // global
           _scHyQ::P64 = R2;
           _scHA6::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJxX; else goto ccJxY;
       ccJxY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccJy0; else goto ccJxZ;
       ccJy0: // global
           HpAlloc = 32;
           goto ccJxX;
       ccJxX: // global
           R2 = _scHyQ::P64;
           R1 = _scHA6::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJxZ: // global
           _scHyK::P64 = P64[_scHA6::P64 + 7];
           _scHyO::P64 = P64[_scHA6::P64 + 15];
           I64[Hp - 24] = sat_scHA3_info;
           P64[Hp - 16] = _scHyK::P64;
           P64[Hp - 8] = _scHyO::P64;
           P64[Hp] = _scHyQ::P64;
           I64[Sp - 8] = block_ccJxT_info;
           R3 = Hp - 23;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJxT() //  [R1]
         { info_tbl: [(ccJxT,
                       label: block_ccJxT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJxT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJy3; else goto ccJy2;
       ccJy3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJy2: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHA7_entry() //  [R1, R2]
         { info_tbl: [(ccJy4,
                       label: sat_scHA7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJy4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJy8; else goto ccJy7;
       ccJy8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJy7: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_scHA6_info;
           P64[Hp - 8] = _scHyK::P64;
           P64[Hp] = _scHyO::P64;
           R5 = Hp - 15;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = lvl42_rcHqk_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHAa_entry() //  [R1, R2]
         { info_tbl: [(ccJyc,
                       label: sat_scHAa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJyc: // global
           _scHyO::P64 = R2;
           _scHAa::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJyd; else goto ccJye;
       ccJye: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJyg; else goto ccJyf;
       ccJyg: // global
           HpAlloc = 24;
           goto ccJyd;
       ccJyd: // global
           R2 = _scHyO::P64;
           R1 = _scHAa::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJyf: // global
           _scHyK::P64 = P64[_scHAa::P64 + 7];
           I64[Hp - 16] = sat_scHA7_info;
           P64[Hp - 8] = _scHyK::P64;
           P64[Hp] = _scHyO::P64;
           I64[Sp - 8] = block_ccJy9_info;
           R3 = Hp - 15;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJy9() //  [R1]
         { info_tbl: [(ccJy9,
                       label: block_ccJy9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJy9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJyj; else goto ccJyi;
       ccJyj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJyi: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHAb_entry() //  [R1, R2]
         { info_tbl: [(ccJyk,
                       label: sat_scHAb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJyk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJyo; else goto ccJyn;
       ccJyo: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJyn: // global
           _scHyK::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_scHAa_info;
           P64[Hp] = _scHyK::P64;
           R5 = Hp - 7;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = ds1_rcHqc_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHAe_entry() //  [R1, R2]
         { info_tbl: [(ccJys,
                       label: sat_scHAe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJys: // global
           _scHyM::P64 = R2;
           _scHAe::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJyt; else goto ccJyu;
       ccJyu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJyw; else goto ccJyv;
       ccJyw: // global
           HpAlloc = 16;
           goto ccJyt;
       ccJyt: // global
           R2 = _scHyM::P64;
           R1 = _scHAe::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJyv: // global
           _scHyK::P64 = P64[_scHAe::P64 + 7];
           I64[Hp - 8] = sat_scHAb_info;
           P64[Hp] = _scHyK::P64;
           I64[Sp - 8] = block_ccJyp_info;
           R3 = Hp - 7;
           R2 = lexeme4_rcHqa_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJyp() //  [R1]
         { info_tbl: [(ccJyp,
                       label: block_ccJyp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJyp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJyz; else goto ccJyy;
       ccJyz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJyy: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stats.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(ccJyD,
                       label: GHC.Stats.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJyD: // global
           _scHyK::P64 = R3;
           _scHyJ::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJyE; else goto ccJyF;
       ccJyF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJyH; else goto ccJyG;
       ccJyH: // global
           HpAlloc = 16;
           goto ccJyE;
       ccJyE: // global
           R3 = _scHyK::P64;
           R2 = _scHyJ::I64;
           R1 = GHC.Stats.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccJyG: // global
           if (%MO_S_Gt_W64(_scHyJ::I64, 11)) goto ccJyB; else goto ccJyC;
       ccJyB: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccJyC: // global
           I64[Hp - 8] = sat_scHAe_info;
           P64[Hp] = _scHyK::P64;
           I64[Sp - 8] = block_ccJyI_info;
           R3 = Hp - 7;
           R2 = lexeme1_rcHq7_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJyI() //  [R1]
         { info_tbl: [(ccJyI,
                       label: block_ccJyI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJyI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJyN; else goto ccJyM;
       ccJyN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJyM: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.404867199 UTC

[section ""data" . GHC.Stats.$fReadGCDetails2_closure" {
     GHC.Stats.$fReadGCDetails2_closure:
         const GHC.Stats.$fReadGCDetails2_info;
         const 0;
 },
 GHC.Stats.$fReadGCDetails2_entry() //  [R2, R3]
         { info_tbl: [(ccJyV,
                       label: GHC.Stats.$fReadGCDetails2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJyV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJyW; else goto ccJyX;
       ccJyW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fReadGCDetails2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccJyX: // global
           I64[Sp - 16] = block_ccJyS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucJz1; else goto ccJyT;
       ucJz1: // global
           call _ccJyS(R1) args: 0, res: 0, upd: 0;
       ccJyT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJyS() //  [R1]
         { info_tbl: [(ccJyS,
                       label: block_ccJyS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJyS: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Stats.$w$creadPrec_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.406138327 UTC

[section ""data" . GHC.Stats.$fReadGCDetails1_closure" {
     GHC.Stats.$fReadGCDetails1_closure:
         const GHC.Stats.$fReadGCDetails1_info;
         const 0;
 },
 GHC.Stats.$fReadGCDetails1_entry() //  [R2, R3]
         { info_tbl: [(ccJz6,
                       label: GHC.Stats.$fReadGCDetails1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJz6: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fReadGCDetails2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.407252403 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_$creadsPrec_closure" {
     GHC.Stats.$fReadGCDetails_$creadsPrec_closure:
         const GHC.Stats.$fReadGCDetails_$creadsPrec_info;
         const 0;
 },
 sat_scHAm_entry() //  [R1]
         { info_tbl: [(ccJzh,
                       label: sat_scHAm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJzh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJzi; else goto ccJzj;
       ccJzi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJzj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Stats.$fReadGCDetails2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stats.$fReadGCDetails_$creadsPrec_entry() //  [R2]
         { info_tbl: [(ccJzk,
                       label: GHC.Stats.$fReadGCDetails_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJzk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJzo; else goto ccJzn;
       ccJzo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stats.$fReadGCDetails_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJzn: // global
           I64[Hp - 16] = sat_scHAm_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.408564972 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_$creadListPrec_closure" {
     GHC.Stats.$fReadGCDetails_$creadListPrec_closure:
         const GHC.Stats.$fReadGCDetails_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadGCDetails_$creadListPrec_entry() //  [R1]
         { info_tbl: [(ccJzv,
                       label: GHC.Stats.$fReadGCDetails_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJzv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJzw; else goto ccJzx;
       ccJzw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJzx: // global
           (_ccJzs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJzs::I64 == 0) goto ccJzu; else goto ccJzt;
       ccJzu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJzt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJzs::I64;
           R2 = GHC.Stats.$fReadGCDetails1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.409744741 UTC

[section ""data" . GHC.Stats.$fReadGCDetails3_closure" {
     GHC.Stats.$fReadGCDetails3_closure:
         const GHC.Stats.$fReadGCDetails3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadGCDetails3_entry() //  [R1]
         { info_tbl: [(ccJzE,
                       label: GHC.Stats.$fReadGCDetails3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJzE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJzF; else goto ccJzG;
       ccJzF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJzG: // global
           (_ccJzB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJzB::I64 == 0) goto ccJzD; else goto ccJzC;
       ccJzD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJzC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJzB::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.Stats.$fReadGCDetails_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.410788976 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_$creadList_closure" {
     GHC.Stats.$fReadGCDetails_$creadList_closure:
         const GHC.Stats.$fReadGCDetails_$creadList_info;
         const 0;
 },
 GHC.Stats.$fReadGCDetails_$creadList_entry() //  [R2]
         { info_tbl: [(ccJzL,
                       label: GHC.Stats.$fReadGCDetails_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJzL: // global
           R3 = R2;
           R2 = GHC.Stats.$fReadGCDetails3_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.411569473 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_closure" {
     GHC.Stats.$fReadGCDetails_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Stats.$fReadGCDetails_$creadsPrec_closure+1;
         const GHC.Stats.$fReadGCDetails_$creadList_closure+1;
         const GHC.Stats.$fReadGCDetails1_closure+2;
         const GHC.Stats.$fReadGCDetails_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.412231789 UTC

[section ""cstring" . GHC.Stats.$tcRTSStats2_bytes" {
     GHC.Stats.$tcRTSStats2_bytes:
         I8[] [82,84,83,83,116,97,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.413035196 UTC

[section ""data" . lexeme5_rcHqP_closure" {
     lexeme5_rcHqP_closure:
         const lexeme5_rcHqP_info;
         const 0;
         const 0;
         const 0;
 },
 lexeme5_rcHqP_entry() //  [R1]
         { info_tbl: [(ccJzU,
                       label: lexeme5_rcHqP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJzU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJzV; else goto ccJzW;
       ccJzV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJzW: // global
           (_ccJzR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJzR::I64 == 0) goto ccJzT; else goto ccJzS;
       ccJzT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJzS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJzR::I64;
           R2 = GHC.Stats.$tcRTSStats2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.414055995 UTC

[section ""data" . lexeme6_rcHqQ_closure" {
     lexeme6_rcHqQ_closure:
         const Text.Read.Lex.Ident_con_info;
         const lexeme5_rcHqP_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.41464918 UTC

[section ""cstring" . ds3_rcHqR_bytes" {
     ds3_rcHqR_bytes:
         I8[] [103,99,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.415394199 UTC

[section ""data" . ds4_rcHqS_closure" {
     ds4_rcHqS_closure:
         const ds4_rcHqS_info;
         const 0;
         const 0;
         const 0;
 },
 ds4_rcHqS_entry() //  [R1]
         { info_tbl: [(ccJA3,
                       label: ds4_rcHqS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJA3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJA4; else goto ccJA5;
       ccJA4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJA5: // global
           (_ccJA0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJA0::I64 == 0) goto ccJA2; else goto ccJA1;
       ccJA2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJA1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJA0::I64;
           R2 = ds3_rcHqR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.41636426 UTC

[section ""cstring" . lvl73_rcHqT_bytes" {
     lvl73_rcHqT_bytes:
         I8[] [109,97,106,111,114,95,103,99,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.419745037 UTC

[section ""data" . lvl74_rcHqU_closure" {
     lvl74_rcHqU_closure:
         const lvl74_rcHqU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl74_rcHqU_entry() //  [R1]
         { info_tbl: [(ccJAc,
                       label: lvl74_rcHqU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJAc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJAd; else goto ccJAe;
       ccJAd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJAe: // global
           (_ccJA9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJA9::I64 == 0) goto ccJAb; else goto ccJAa;
       ccJAb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJAa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJA9::I64;
           R2 = lvl73_rcHqT_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.420676033 UTC

[section ""cstring" . lvl75_rcHqV_bytes" {
     lvl75_rcHqV_bytes:
         I8[] [97,108,108,111,99,97,116,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.421510216 UTC

[section ""data" . lvl76_rcHqW_closure" {
     lvl76_rcHqW_closure:
         const lvl76_rcHqW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl76_rcHqW_entry() //  [R1]
         { info_tbl: [(ccJAl,
                       label: lvl76_rcHqW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJAl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJAm; else goto ccJAn;
       ccJAm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJAn: // global
           (_ccJAi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJAi::I64 == 0) goto ccJAk; else goto ccJAj;
       ccJAk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJAj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJAi::I64;
           R2 = lvl75_rcHqV_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.422424744 UTC

[section ""cstring" . lvl77_rcHqX_bytes" {
     lvl77_rcHqX_bytes:
         I8[] [109,97,120,95,108,105,118,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.42320287 UTC

[section ""data" . lvl78_rcHqY_closure" {
     lvl78_rcHqY_closure:
         const lvl78_rcHqY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl78_rcHqY_entry() //  [R1]
         { info_tbl: [(ccJAu,
                       label: lvl78_rcHqY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJAu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJAv; else goto ccJAw;
       ccJAv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJAw: // global
           (_ccJAr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJAr::I64 == 0) goto ccJAt; else goto ccJAs;
       ccJAt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJAs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJAr::I64;
           R2 = lvl77_rcHqX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.424086171 UTC

[section ""cstring" . lvl79_rcHqZ_bytes" {
     lvl79_rcHqZ_bytes:
         I8[] [109,97,120,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.424832218 UTC

[section ""data" . lvl80_rcHr0_closure" {
     lvl80_rcHr0_closure:
         const lvl80_rcHr0_info;
         const 0;
         const 0;
         const 0;
 },
 lvl80_rcHr0_entry() //  [R1]
         { info_tbl: [(ccJAD,
                       label: lvl80_rcHr0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJAD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJAE; else goto ccJAF;
       ccJAE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJAF: // global
           (_ccJAA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJAA::I64 == 0) goto ccJAC; else goto ccJAB;
       ccJAC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJAB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJAA::I64;
           R2 = lvl79_rcHqZ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.425750939 UTC

[section ""cstring" . lvl81_rcHr1_bytes" {
     lvl81_rcHr1_bytes:
         I8[] [109,97,120,95,99,111,109,112,97,99,116,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.426527816 UTC

[section ""data" . lvl82_rcHr2_closure" {
     lvl82_rcHr2_closure:
         const lvl82_rcHr2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl82_rcHr2_entry() //  [R1]
         { info_tbl: [(ccJAM,
                       label: lvl82_rcHr2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJAM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJAN; else goto ccJAO;
       ccJAN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJAO: // global
           (_ccJAJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJAJ::I64 == 0) goto ccJAL; else goto ccJAK;
       ccJAL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJAK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJAJ::I64;
           R2 = lvl81_rcHr1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.427384519 UTC

[section ""cstring" . lvl83_rcHr3_bytes" {
     lvl83_rcHr3_bytes:
         I8[] [109,97,120,95,115,108,111,112,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.428103866 UTC

[section ""data" . lvl84_rcHr4_closure" {
     lvl84_rcHr4_closure:
         const lvl84_rcHr4_info;
         const 0;
         const 0;
         const 0;
 },
 lvl84_rcHr4_entry() //  [R1]
         { info_tbl: [(ccJAV,
                       label: lvl84_rcHr4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJAV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJAW; else goto ccJAX;
       ccJAW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJAX: // global
           (_ccJAS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJAS::I64 == 0) goto ccJAU; else goto ccJAT;
       ccJAU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJAT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJAS::I64;
           R2 = lvl83_rcHr3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.428953607 UTC

[section ""cstring" . lvl85_rcHr5_bytes" {
     lvl85_rcHr5_bytes:
         I8[] [109,97,120,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.429762444 UTC

[section ""data" . lvl86_rcHr6_closure" {
     lvl86_rcHr6_closure:
         const lvl86_rcHr6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl86_rcHr6_entry() //  [R1]
         { info_tbl: [(ccJB4,
                       label: lvl86_rcHr6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJB4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJB5; else goto ccJB6;
       ccJB5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJB6: // global
           (_ccJB1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJB1::I64 == 0) goto ccJB3; else goto ccJB2;
       ccJB3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJB2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJB1::I64;
           R2 = lvl85_rcHr5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.430728658 UTC

[section ""cstring" . lvl87_rcHr7_bytes" {
     lvl87_rcHr7_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,108,105,118,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.431513683 UTC

[section ""data" . lvl88_rcHr8_closure" {
     lvl88_rcHr8_closure:
         const lvl88_rcHr8_info;
         const 0;
         const 0;
         const 0;
 },
 lvl88_rcHr8_entry() //  [R1]
         { info_tbl: [(ccJBd,
                       label: lvl88_rcHr8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJBd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJBe; else goto ccJBf;
       ccJBe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJBf: // global
           (_ccJBa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJBa::I64 == 0) goto ccJBc; else goto ccJBb;
       ccJBc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJBb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJBa::I64;
           R2 = lvl87_rcHr7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.432447538 UTC

[section ""cstring" . lvl89_rcHr9_bytes" {
     lvl89_rcHr9_bytes:
         I8[] [99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.433222029 UTC

[section ""data" . lvl90_rcHra_closure" {
     lvl90_rcHra_closure:
         const lvl90_rcHra_info;
         const 0;
         const 0;
         const 0;
 },
 lvl90_rcHra_entry() //  [R1]
         { info_tbl: [(ccJBm,
                       label: lvl90_rcHra_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJBm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJBn; else goto ccJBo;
       ccJBn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJBo: // global
           (_ccJBj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJBj::I64 == 0) goto ccJBl; else goto ccJBk;
       ccJBl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJBk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJBj::I64;
           R2 = lvl89_rcHr9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.434370324 UTC

[section ""cstring" . lvl91_rcHrb_bytes" {
     lvl91_rcHrb_bytes:
         I8[] [112,97,114,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.435141244 UTC

[section ""data" . lvl92_rcHrc_closure" {
     lvl92_rcHrc_closure:
         const lvl92_rcHrc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl92_rcHrc_entry() //  [R1]
         { info_tbl: [(ccJBv,
                       label: lvl92_rcHrc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJBv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJBw; else goto ccJBx;
       ccJBw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJBx: // global
           (_ccJBs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJBs::I64 == 0) goto ccJBu; else goto ccJBt;
       ccJBu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJBt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJBs::I64;
           R2 = lvl91_rcHrb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.436097451 UTC

[section ""cstring" . lvl93_rcHrd_bytes" {
     lvl93_rcHrd_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.436842822 UTC

[section ""data" . lvl94_rcHre_closure" {
     lvl94_rcHre_closure:
         const lvl94_rcHre_info;
         const 0;
         const 0;
         const 0;
 },
 lvl94_rcHre_entry() //  [R1]
         { info_tbl: [(ccJBE,
                       label: lvl94_rcHre_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJBE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJBF; else goto ccJBG;
       ccJBF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJBG: // global
           (_ccJBB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJBB::I64 == 0) goto ccJBD; else goto ccJBC;
       ccJBD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJBC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJBB::I64;
           R2 = lvl93_rcHrd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.437786972 UTC

[section ""cstring" . lvl95_rcHrf_bytes" {
     lvl95_rcHrf_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.43854565 UTC

[section ""data" . lvl96_rcHrg_closure" {
     lvl96_rcHrg_closure:
         const lvl96_rcHrg_info;
         const 0;
         const 0;
         const 0;
 },
 lvl96_rcHrg_entry() //  [R1]
         { info_tbl: [(ccJBN,
                       label: lvl96_rcHrg_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJBN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJBO; else goto ccJBP;
       ccJBO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJBP: // global
           (_ccJBK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJBK::I64 == 0) goto ccJBM; else goto ccJBL;
       ccJBM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJBL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJBK::I64;
           R2 = lvl95_rcHrf_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.439490198 UTC

[section ""cstring" . lvl97_rcHrh_bytes" {
     lvl97_rcHrh_bytes:
         I8[] [109,117,116,97,116,111,114,95,99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.440250713 UTC

[section ""data" . lvl98_rcHri_closure" {
     lvl98_rcHri_closure:
         const lvl98_rcHri_info;
         const 0;
         const 0;
         const 0;
 },
 lvl98_rcHri_entry() //  [R1]
         { info_tbl: [(ccJBW,
                       label: lvl98_rcHri_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJBW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJBX; else goto ccJBY;
       ccJBX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJBY: // global
           (_ccJBT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJBT::I64 == 0) goto ccJBV; else goto ccJBU;
       ccJBV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJBU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJBT::I64;
           R2 = lvl97_rcHrh_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.441173496 UTC

[section ""cstring" . lvl99_rcHrj_bytes" {
     lvl99_rcHrj_bytes:
         I8[] [109,117,116,97,116,111,114,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.441951934 UTC

[section ""data" . lvl100_rcHrk_closure" {
     lvl100_rcHrk_closure:
         const lvl100_rcHrk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl100_rcHrk_entry() //  [R1]
         { info_tbl: [(ccJC5,
                       label: lvl100_rcHrk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJC5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJC6; else goto ccJC7;
       ccJC6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJC7: // global
           (_ccJC2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJC2::I64 == 0) goto ccJC4; else goto ccJC3;
       ccJC4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJC3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJC2::I64;
           R2 = lvl99_rcHrj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.442953465 UTC

[section ""cstring" . lvl101_rcHrl_bytes" {
     lvl101_rcHrl_bytes:
         I8[] [103,99,95,99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.443683761 UTC

[section ""data" . lvl102_rcHrm_closure" {
     lvl102_rcHrm_closure:
         const lvl102_rcHrm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl102_rcHrm_entry() //  [R1]
         { info_tbl: [(ccJCe,
                       label: lvl102_rcHrm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJCe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJCf; else goto ccJCg;
       ccJCf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJCg: // global
           (_ccJCb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJCb::I64 == 0) goto ccJCd; else goto ccJCc;
       ccJCd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJCc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJCb::I64;
           R2 = lvl101_rcHrl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.444706151 UTC

[section ""cstring" . lvl103_rcHrn_bytes" {
     lvl103_rcHrn_bytes:
         I8[] [103,99,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.445538893 UTC

[section ""data" . lvl104_rcHro_closure" {
     lvl104_rcHro_closure:
         const lvl104_rcHro_info;
         const 0;
         const 0;
         const 0;
 },
 lvl104_rcHro_entry() //  [R1]
         { info_tbl: [(ccJCn,
                       label: lvl104_rcHro_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJCn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJCo; else goto ccJCp;
       ccJCo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJCp: // global
           (_ccJCk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJCk::I64 == 0) goto ccJCm; else goto ccJCl;
       ccJCm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJCl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJCk::I64;
           R2 = lvl103_rcHrn_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.446547709 UTC

[section ""cstring" . lvl105_rcHrp_bytes" {
     lvl105_rcHrp_bytes:
         I8[] [99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.447354613 UTC

[section ""data" . lvl106_rcHrq_closure" {
     lvl106_rcHrq_closure:
         const lvl106_rcHrq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl106_rcHrq_entry() //  [R1]
         { info_tbl: [(ccJCw,
                       label: lvl106_rcHrq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJCw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJCx; else goto ccJCy;
       ccJCx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJCy: // global
           (_ccJCt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJCt::I64 == 0) goto ccJCv; else goto ccJCu;
       ccJCv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJCu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJCt::I64;
           R2 = lvl105_rcHrp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.448323089 UTC

[section ""cstring" . lvl107_rcHrr_bytes" {
     lvl107_rcHrr_bytes:
         I8[] [101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.44911799 UTC

[section ""data" . lvl108_rcHrs_closure" {
     lvl108_rcHrs_closure:
         const lvl108_rcHrs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl108_rcHrs_entry() //  [R1]
         { info_tbl: [(ccJCF,
                       label: lvl108_rcHrs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJCF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJCG; else goto ccJCH;
       ccJCG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJCH: // global
           (_ccJCC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJCC::I64 == 0) goto ccJCE; else goto ccJCD;
       ccJCE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJCD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJCC::I64;
           R2 = lvl107_rcHrr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.451609663 UTC

[section ""cstring" . lvl109_rcHrt_bytes" {
     lvl109_rcHrt_bytes:
         I8[] [103,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.452388536 UTC

[section ""data" . lvl110_rcHru_closure" {
     lvl110_rcHru_closure:
         const lvl110_rcHru_info;
         const 0;
         const 0;
         const 0;
 },
 lvl110_rcHru_entry() //  [R1]
         { info_tbl: [(ccJCO,
                       label: lvl110_rcHru_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJCO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJCP; else goto ccJCQ;
       ccJCP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJCQ: // global
           (_ccJCL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJCL::I64 == 0) goto ccJCN; else goto ccJCM;
       ccJCN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJCM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJCL::I64;
           R2 = lvl109_rcHrt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.453480753 UTC

[section ""data" . lvl111_rcHrv_closure" {
     lvl111_rcHrv_closure:
         const lvl111_rcHrv_info;
         const 0;
 },
 lvl111_rcHrv_entry() //  [R3]
         { info_tbl: [(ccJCV,
                       label: lvl111_rcHrv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJCV: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Stats.$fReadGCDetails2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.465871007 UTC

[section ""data" . GHC.Stats.$w$creadPrec1_closure" {
     GHC.Stats.$w$creadPrec1_closure:
         const GHC.Stats.$w$creadPrec1_info;
         const 0;
 },
 sat_scHB9_entry() //  [R1, R2]
         { info_tbl: [(ccJGv,
                       label: sat_scHB9_info
                       rep:HeapRep 21 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJGv: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccJGz; else goto ccJGy;
       ccJGz: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJGy: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           _scHB0::P64 = P64[R1 + 143];
           _scHB2::P64 = P64[R1 + 151];
           _scHB4::P64 = P64[R1 + 159];
           _scHB6::P64 = P64[R1 + 167];
           I64[Hp - 160] = GHC.Stats.RTSStats_con_info;
           P64[Hp - 152] = _scHAu::P64;
           P64[Hp - 144] = _scHAw::P64;
           P64[Hp - 136] = _scHAy::P64;
           P64[Hp - 128] = _scHAA::P64;
           P64[Hp - 120] = _scHAC::P64;
           P64[Hp - 112] = _scHAE::P64;
           P64[Hp - 104] = _scHAG::P64;
           P64[Hp - 96] = _scHAI::P64;
           P64[Hp - 88] = _scHAK::P64;
           P64[Hp - 80] = _scHAM::P64;
           P64[Hp - 72] = _scHAO::P64;
           P64[Hp - 64] = _scHAQ::P64;
           P64[Hp - 56] = _scHAS::P64;
           P64[Hp - 48] = _scHAU::P64;
           P64[Hp - 40] = _scHAW::P64;
           P64[Hp - 32] = _scHAY::P64;
           P64[Hp - 24] = _scHB0::P64;
           P64[Hp - 16] = _scHB2::P64;
           P64[Hp - 8] = _scHB4::P64;
           P64[Hp] = _scHB6::P64;
           R2 = Hp - 159;
           R1 = _scHAq::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBc_entry() //  [R1, R2]
         { info_tbl: [(ccJGD,
                       label: sat_scHBc_info
                       rep:HeapRep 20 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJGD: // global
           _scHB6::P64 = R2;
           _scHBc::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJGE; else goto ccJGF;
       ccJGF: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccJGH; else goto ccJGG;
       ccJGH: // global
           HpAlloc = 176;
           goto ccJGE;
       ccJGE: // global
           R2 = _scHB6::P64;
           R1 = _scHBc::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJGG: // global
           _scHAq::P64 = P64[_scHBc::P64 + 7];
           _scHAu::P64 = P64[_scHBc::P64 + 15];
           _scHAw::P64 = P64[_scHBc::P64 + 23];
           _scHAy::P64 = P64[_scHBc::P64 + 31];
           _scHAA::P64 = P64[_scHBc::P64 + 39];
           _scHAC::P64 = P64[_scHBc::P64 + 47];
           _scHAE::P64 = P64[_scHBc::P64 + 55];
           _scHAG::P64 = P64[_scHBc::P64 + 63];
           _scHAI::P64 = P64[_scHBc::P64 + 71];
           _scHAK::P64 = P64[_scHBc::P64 + 79];
           _scHAM::P64 = P64[_scHBc::P64 + 87];
           _scHAO::P64 = P64[_scHBc::P64 + 95];
           _scHAQ::P64 = P64[_scHBc::P64 + 103];
           _scHAS::P64 = P64[_scHBc::P64 + 111];
           _scHAU::P64 = P64[_scHBc::P64 + 119];
           _scHAW::P64 = P64[_scHBc::P64 + 127];
           _scHAY::P64 = P64[_scHBc::P64 + 135];
           _scHB0::P64 = P64[_scHBc::P64 + 143];
           _scHB2::P64 = P64[_scHBc::P64 + 151];
           _scHB4::P64 = P64[_scHBc::P64 + 159];
           I64[Hp - 168] = sat_scHB9_info;
           P64[Hp - 160] = _scHAq::P64;
           P64[Hp - 152] = _scHAu::P64;
           P64[Hp - 144] = _scHAw::P64;
           P64[Hp - 136] = _scHAy::P64;
           P64[Hp - 128] = _scHAA::P64;
           P64[Hp - 120] = _scHAC::P64;
           P64[Hp - 112] = _scHAE::P64;
           P64[Hp - 104] = _scHAG::P64;
           P64[Hp - 96] = _scHAI::P64;
           P64[Hp - 88] = _scHAK::P64;
           P64[Hp - 80] = _scHAM::P64;
           P64[Hp - 72] = _scHAO::P64;
           P64[Hp - 64] = _scHAQ::P64;
           P64[Hp - 56] = _scHAS::P64;
           P64[Hp - 48] = _scHAU::P64;
           P64[Hp - 40] = _scHAW::P64;
           P64[Hp - 32] = _scHAY::P64;
           P64[Hp - 24] = _scHB0::P64;
           P64[Hp - 16] = _scHB2::P64;
           P64[Hp - 8] = _scHB4::P64;
           P64[Hp] = _scHB6::P64;
           I64[Sp - 8] = block_ccJGA_info;
           R3 = Hp - 167;
           R2 = lvl72_rcHqO_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJGA() //  [R1]
         { info_tbl: [(ccJGA,
                       label: block_ccJGA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJGA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJGK; else goto ccJGJ;
       ccJGK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJGJ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBd_entry() //  [R1, R2]
         { info_tbl: [(ccJGL,
                       label: sat_scHBd_info
                       rep:HeapRep 20 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJGL: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccJGP; else goto ccJGO;
       ccJGP: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJGO: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           _scHB0::P64 = P64[R1 + 143];
           _scHB2::P64 = P64[R1 + 151];
           _scHB4::P64 = P64[R1 + 159];
           I64[Hp - 160] = sat_scHBc_info;
           P64[Hp - 152] = _scHAq::P64;
           P64[Hp - 144] = _scHAu::P64;
           P64[Hp - 136] = _scHAw::P64;
           P64[Hp - 128] = _scHAy::P64;
           P64[Hp - 120] = _scHAA::P64;
           P64[Hp - 112] = _scHAC::P64;
           P64[Hp - 104] = _scHAE::P64;
           P64[Hp - 96] = _scHAG::P64;
           P64[Hp - 88] = _scHAI::P64;
           P64[Hp - 80] = _scHAK::P64;
           P64[Hp - 72] = _scHAM::P64;
           P64[Hp - 64] = _scHAO::P64;
           P64[Hp - 56] = _scHAQ::P64;
           P64[Hp - 48] = _scHAS::P64;
           P64[Hp - 40] = _scHAU::P64;
           P64[Hp - 32] = _scHAW::P64;
           P64[Hp - 24] = _scHAY::P64;
           P64[Hp - 16] = _scHB0::P64;
           P64[Hp - 8] = _scHB2::P64;
           P64[Hp] = _scHB4::P64;
           R5 = Hp - 159;
           R4 = n_rcHqf_closure+1;
           R3 = lvl111_rcHrv_closure+2;
           R2 = lvl110_rcHru_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBg_entry() //  [R1, R2]
         { info_tbl: [(ccJGT,
                       label: sat_scHBg_info
                       rep:HeapRep 19 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJGT: // global
           _scHB4::P64 = R2;
           _scHBg::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJGU; else goto ccJGV;
       ccJGV: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccJGX; else goto ccJGW;
       ccJGX: // global
           HpAlloc = 168;
           goto ccJGU;
       ccJGU: // global
           R2 = _scHB4::P64;
           R1 = _scHBg::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJGW: // global
           _scHAq::P64 = P64[_scHBg::P64 + 7];
           _scHAu::P64 = P64[_scHBg::P64 + 15];
           _scHAw::P64 = P64[_scHBg::P64 + 23];
           _scHAy::P64 = P64[_scHBg::P64 + 31];
           _scHAA::P64 = P64[_scHBg::P64 + 39];
           _scHAC::P64 = P64[_scHBg::P64 + 47];
           _scHAE::P64 = P64[_scHBg::P64 + 55];
           _scHAG::P64 = P64[_scHBg::P64 + 63];
           _scHAI::P64 = P64[_scHBg::P64 + 71];
           _scHAK::P64 = P64[_scHBg::P64 + 79];
           _scHAM::P64 = P64[_scHBg::P64 + 87];
           _scHAO::P64 = P64[_scHBg::P64 + 95];
           _scHAQ::P64 = P64[_scHBg::P64 + 103];
           _scHAS::P64 = P64[_scHBg::P64 + 111];
           _scHAU::P64 = P64[_scHBg::P64 + 119];
           _scHAW::P64 = P64[_scHBg::P64 + 127];
           _scHAY::P64 = P64[_scHBg::P64 + 135];
           _scHB0::P64 = P64[_scHBg::P64 + 143];
           _scHB2::P64 = P64[_scHBg::P64 + 151];
           I64[Hp - 160] = sat_scHBd_info;
           P64[Hp - 152] = _scHAq::P64;
           P64[Hp - 144] = _scHAu::P64;
           P64[Hp - 136] = _scHAw::P64;
           P64[Hp - 128] = _scHAy::P64;
           P64[Hp - 120] = _scHAA::P64;
           P64[Hp - 112] = _scHAC::P64;
           P64[Hp - 104] = _scHAE::P64;
           P64[Hp - 96] = _scHAG::P64;
           P64[Hp - 88] = _scHAI::P64;
           P64[Hp - 80] = _scHAK::P64;
           P64[Hp - 72] = _scHAM::P64;
           P64[Hp - 64] = _scHAO::P64;
           P64[Hp - 56] = _scHAQ::P64;
           P64[Hp - 48] = _scHAS::P64;
           P64[Hp - 40] = _scHAU::P64;
           P64[Hp - 32] = _scHAW::P64;
           P64[Hp - 24] = _scHAY::P64;
           P64[Hp - 16] = _scHB0::P64;
           P64[Hp - 8] = _scHB2::P64;
           P64[Hp] = _scHB4::P64;
           I64[Sp - 8] = block_ccJGQ_info;
           R3 = Hp - 159;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJGQ() //  [R1]
         { info_tbl: [(ccJGQ,
                       label: block_ccJGQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJGQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJH0; else goto ccJGZ;
       ccJH0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJGZ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBh_entry() //  [R1, R2]
         { info_tbl: [(ccJH1,
                       label: sat_scHBh_info
                       rep:HeapRep 19 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJH1: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccJH5; else goto ccJH4;
       ccJH5: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJH4: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           _scHB0::P64 = P64[R1 + 143];
           _scHB2::P64 = P64[R1 + 151];
           I64[Hp - 152] = sat_scHBg_info;
           P64[Hp - 144] = _scHAq::P64;
           P64[Hp - 136] = _scHAu::P64;
           P64[Hp - 128] = _scHAw::P64;
           P64[Hp - 120] = _scHAy::P64;
           P64[Hp - 112] = _scHAA::P64;
           P64[Hp - 104] = _scHAC::P64;
           P64[Hp - 96] = _scHAE::P64;
           P64[Hp - 88] = _scHAG::P64;
           P64[Hp - 80] = _scHAI::P64;
           P64[Hp - 72] = _scHAK::P64;
           P64[Hp - 64] = _scHAM::P64;
           P64[Hp - 56] = _scHAO::P64;
           P64[Hp - 48] = _scHAQ::P64;
           P64[Hp - 40] = _scHAS::P64;
           P64[Hp - 32] = _scHAU::P64;
           P64[Hp - 24] = _scHAW::P64;
           P64[Hp - 16] = _scHAY::P64;
           P64[Hp - 8] = _scHB0::P64;
           P64[Hp] = _scHB2::P64;
           R5 = Hp - 151;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl108_rcHrs_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBk_entry() //  [R1, R2]
         { info_tbl: [(ccJH9,
                       label: sat_scHBk_info
                       rep:HeapRep 18 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJH9: // global
           _scHB2::P64 = R2;
           _scHBk::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJHa; else goto ccJHb;
       ccJHb: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccJHd; else goto ccJHc;
       ccJHd: // global
           HpAlloc = 160;
           goto ccJHa;
       ccJHa: // global
           R2 = _scHB2::P64;
           R1 = _scHBk::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJHc: // global
           _scHAq::P64 = P64[_scHBk::P64 + 7];
           _scHAu::P64 = P64[_scHBk::P64 + 15];
           _scHAw::P64 = P64[_scHBk::P64 + 23];
           _scHAy::P64 = P64[_scHBk::P64 + 31];
           _scHAA::P64 = P64[_scHBk::P64 + 39];
           _scHAC::P64 = P64[_scHBk::P64 + 47];
           _scHAE::P64 = P64[_scHBk::P64 + 55];
           _scHAG::P64 = P64[_scHBk::P64 + 63];
           _scHAI::P64 = P64[_scHBk::P64 + 71];
           _scHAK::P64 = P64[_scHBk::P64 + 79];
           _scHAM::P64 = P64[_scHBk::P64 + 87];
           _scHAO::P64 = P64[_scHBk::P64 + 95];
           _scHAQ::P64 = P64[_scHBk::P64 + 103];
           _scHAS::P64 = P64[_scHBk::P64 + 111];
           _scHAU::P64 = P64[_scHBk::P64 + 119];
           _scHAW::P64 = P64[_scHBk::P64 + 127];
           _scHAY::P64 = P64[_scHBk::P64 + 135];
           _scHB0::P64 = P64[_scHBk::P64 + 143];
           I64[Hp - 152] = sat_scHBh_info;
           P64[Hp - 144] = _scHAq::P64;
           P64[Hp - 136] = _scHAu::P64;
           P64[Hp - 128] = _scHAw::P64;
           P64[Hp - 120] = _scHAy::P64;
           P64[Hp - 112] = _scHAA::P64;
           P64[Hp - 104] = _scHAC::P64;
           P64[Hp - 96] = _scHAE::P64;
           P64[Hp - 88] = _scHAG::P64;
           P64[Hp - 80] = _scHAI::P64;
           P64[Hp - 72] = _scHAK::P64;
           P64[Hp - 64] = _scHAM::P64;
           P64[Hp - 56] = _scHAO::P64;
           P64[Hp - 48] = _scHAQ::P64;
           P64[Hp - 40] = _scHAS::P64;
           P64[Hp - 32] = _scHAU::P64;
           P64[Hp - 24] = _scHAW::P64;
           P64[Hp - 16] = _scHAY::P64;
           P64[Hp - 8] = _scHB0::P64;
           P64[Hp] = _scHB2::P64;
           I64[Sp - 8] = block_ccJH6_info;
           R3 = Hp - 151;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJH6() //  [R1]
         { info_tbl: [(ccJH6,
                       label: block_ccJH6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJH6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJHg; else goto ccJHf;
       ccJHg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJHf: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJM9_srtd" {
     ucJM9_srtd:
         const ScI2G_srt+128;
         const 33;
         const 8053063727;
 },
 sat_scHBl_entry() //  [R1, R2]
         { info_tbl: [(ccJHh,
                       label: sat_scHBl_info
                       rep:HeapRep 18 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJHh: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccJHl; else goto ccJHk;
       ccJHl: // global
           HpAlloc = 152;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJHk: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           _scHB0::P64 = P64[R1 + 143];
           I64[Hp - 144] = sat_scHBk_info;
           P64[Hp - 136] = _scHAq::P64;
           P64[Hp - 128] = _scHAu::P64;
           P64[Hp - 120] = _scHAw::P64;
           P64[Hp - 112] = _scHAy::P64;
           P64[Hp - 104] = _scHAA::P64;
           P64[Hp - 96] = _scHAC::P64;
           P64[Hp - 88] = _scHAE::P64;
           P64[Hp - 80] = _scHAG::P64;
           P64[Hp - 72] = _scHAI::P64;
           P64[Hp - 64] = _scHAK::P64;
           P64[Hp - 56] = _scHAM::P64;
           P64[Hp - 48] = _scHAO::P64;
           P64[Hp - 40] = _scHAQ::P64;
           P64[Hp - 32] = _scHAS::P64;
           P64[Hp - 24] = _scHAU::P64;
           P64[Hp - 16] = _scHAW::P64;
           P64[Hp - 8] = _scHAY::P64;
           P64[Hp] = _scHB0::P64;
           R5 = Hp - 143;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl106_rcHrq_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMa_srtd" {
     ucJMa_srtd:
         const ScI2G_srt+128;
         const 33;
         const 8053063727;
 },
 sat_scHBo_entry() //  [R1, R2]
         { info_tbl: [(ccJHp,
                       label: sat_scHBo_info
                       rep:HeapRep 17 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJHp: // global
           _scHB0::P64 = R2;
           _scHBo::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJHq; else goto ccJHr;
       ccJHr: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccJHt; else goto ccJHs;
       ccJHt: // global
           HpAlloc = 152;
           goto ccJHq;
       ccJHq: // global
           R2 = _scHB0::P64;
           R1 = _scHBo::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJHs: // global
           _scHAq::P64 = P64[_scHBo::P64 + 7];
           _scHAu::P64 = P64[_scHBo::P64 + 15];
           _scHAw::P64 = P64[_scHBo::P64 + 23];
           _scHAy::P64 = P64[_scHBo::P64 + 31];
           _scHAA::P64 = P64[_scHBo::P64 + 39];
           _scHAC::P64 = P64[_scHBo::P64 + 47];
           _scHAE::P64 = P64[_scHBo::P64 + 55];
           _scHAG::P64 = P64[_scHBo::P64 + 63];
           _scHAI::P64 = P64[_scHBo::P64 + 71];
           _scHAK::P64 = P64[_scHBo::P64 + 79];
           _scHAM::P64 = P64[_scHBo::P64 + 87];
           _scHAO::P64 = P64[_scHBo::P64 + 95];
           _scHAQ::P64 = P64[_scHBo::P64 + 103];
           _scHAS::P64 = P64[_scHBo::P64 + 111];
           _scHAU::P64 = P64[_scHBo::P64 + 119];
           _scHAW::P64 = P64[_scHBo::P64 + 127];
           _scHAY::P64 = P64[_scHBo::P64 + 135];
           I64[Hp - 144] = sat_scHBl_info;
           P64[Hp - 136] = _scHAq::P64;
           P64[Hp - 128] = _scHAu::P64;
           P64[Hp - 120] = _scHAw::P64;
           P64[Hp - 112] = _scHAy::P64;
           P64[Hp - 104] = _scHAA::P64;
           P64[Hp - 96] = _scHAC::P64;
           P64[Hp - 88] = _scHAE::P64;
           P64[Hp - 80] = _scHAG::P64;
           P64[Hp - 72] = _scHAI::P64;
           P64[Hp - 64] = _scHAK::P64;
           P64[Hp - 56] = _scHAM::P64;
           P64[Hp - 48] = _scHAO::P64;
           P64[Hp - 40] = _scHAQ::P64;
           P64[Hp - 32] = _scHAS::P64;
           P64[Hp - 24] = _scHAU::P64;
           P64[Hp - 16] = _scHAW::P64;
           P64[Hp - 8] = _scHAY::P64;
           P64[Hp] = _scHB0::P64;
           I64[Sp - 8] = block_ccJHm_info;
           R3 = Hp - 143;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJHm() //  [R1]
         { info_tbl: [(ccJHm,
                       label: block_ccJHm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJHm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJHw; else goto ccJHv;
       ccJHw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJHv: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMb_srtd" {
     ucJMb_srtd:
         const ScI2G_srt+128;
         const 34;
         const 16642998319;
 },
 sat_scHBp_entry() //  [R1, R2]
         { info_tbl: [(ccJHx,
                       label: sat_scHBp_info
                       rep:HeapRep 17 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJHx: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccJHB; else goto ccJHA;
       ccJHB: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJHA: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           I64[Hp - 136] = sat_scHBo_info;
           P64[Hp - 128] = _scHAq::P64;
           P64[Hp - 120] = _scHAu::P64;
           P64[Hp - 112] = _scHAw::P64;
           P64[Hp - 104] = _scHAy::P64;
           P64[Hp - 96] = _scHAA::P64;
           P64[Hp - 88] = _scHAC::P64;
           P64[Hp - 80] = _scHAE::P64;
           P64[Hp - 72] = _scHAG::P64;
           P64[Hp - 64] = _scHAI::P64;
           P64[Hp - 56] = _scHAK::P64;
           P64[Hp - 48] = _scHAM::P64;
           P64[Hp - 40] = _scHAO::P64;
           P64[Hp - 32] = _scHAQ::P64;
           P64[Hp - 24] = _scHAS::P64;
           P64[Hp - 16] = _scHAU::P64;
           P64[Hp - 8] = _scHAW::P64;
           P64[Hp] = _scHAY::P64;
           R5 = Hp - 135;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl104_rcHro_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMc_srtd" {
     ucJMc_srtd:
         const ScI2G_srt+128;
         const 34;
         const 16642998319;
 },
 sat_scHBs_entry() //  [R1, R2]
         { info_tbl: [(ccJHF,
                       label: sat_scHBs_info
                       rep:HeapRep 16 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJHF: // global
           _scHAY::P64 = R2;
           _scHBs::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJHG; else goto ccJHH;
       ccJHH: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccJHJ; else goto ccJHI;
       ccJHJ: // global
           HpAlloc = 144;
           goto ccJHG;
       ccJHG: // global
           R2 = _scHAY::P64;
           R1 = _scHBs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJHI: // global
           _scHAq::P64 = P64[_scHBs::P64 + 7];
           _scHAu::P64 = P64[_scHBs::P64 + 15];
           _scHAw::P64 = P64[_scHBs::P64 + 23];
           _scHAy::P64 = P64[_scHBs::P64 + 31];
           _scHAA::P64 = P64[_scHBs::P64 + 39];
           _scHAC::P64 = P64[_scHBs::P64 + 47];
           _scHAE::P64 = P64[_scHBs::P64 + 55];
           _scHAG::P64 = P64[_scHBs::P64 + 63];
           _scHAI::P64 = P64[_scHBs::P64 + 71];
           _scHAK::P64 = P64[_scHBs::P64 + 79];
           _scHAM::P64 = P64[_scHBs::P64 + 87];
           _scHAO::P64 = P64[_scHBs::P64 + 95];
           _scHAQ::P64 = P64[_scHBs::P64 + 103];
           _scHAS::P64 = P64[_scHBs::P64 + 111];
           _scHAU::P64 = P64[_scHBs::P64 + 119];
           _scHAW::P64 = P64[_scHBs::P64 + 127];
           I64[Hp - 136] = sat_scHBp_info;
           P64[Hp - 128] = _scHAq::P64;
           P64[Hp - 120] = _scHAu::P64;
           P64[Hp - 112] = _scHAw::P64;
           P64[Hp - 104] = _scHAy::P64;
           P64[Hp - 96] = _scHAA::P64;
           P64[Hp - 88] = _scHAC::P64;
           P64[Hp - 80] = _scHAE::P64;
           P64[Hp - 72] = _scHAG::P64;
           P64[Hp - 64] = _scHAI::P64;
           P64[Hp - 56] = _scHAK::P64;
           P64[Hp - 48] = _scHAM::P64;
           P64[Hp - 40] = _scHAO::P64;
           P64[Hp - 32] = _scHAQ::P64;
           P64[Hp - 24] = _scHAS::P64;
           P64[Hp - 16] = _scHAU::P64;
           P64[Hp - 8] = _scHAW::P64;
           P64[Hp] = _scHAY::P64;
           I64[Sp - 8] = block_ccJHC_info;
           R3 = Hp - 135;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJHC() //  [R1]
         { info_tbl: [(ccJHC,
                       label: block_ccJHC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJHC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJHM; else goto ccJHL;
       ccJHM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJHL: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMd_srtd" {
     ucJMd_srtd:
         const ScI2G_srt+128;
         const 35;
         const 33822867503;
 },
 sat_scHBt_entry() //  [R1, R2]
         { info_tbl: [(ccJHN,
                       label: sat_scHBt_info
                       rep:HeapRep 16 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJHN: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccJHR; else goto ccJHQ;
       ccJHR: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJHQ: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           I64[Hp - 128] = sat_scHBs_info;
           P64[Hp - 120] = _scHAq::P64;
           P64[Hp - 112] = _scHAu::P64;
           P64[Hp - 104] = _scHAw::P64;
           P64[Hp - 96] = _scHAy::P64;
           P64[Hp - 88] = _scHAA::P64;
           P64[Hp - 80] = _scHAC::P64;
           P64[Hp - 72] = _scHAE::P64;
           P64[Hp - 64] = _scHAG::P64;
           P64[Hp - 56] = _scHAI::P64;
           P64[Hp - 48] = _scHAK::P64;
           P64[Hp - 40] = _scHAM::P64;
           P64[Hp - 32] = _scHAO::P64;
           P64[Hp - 24] = _scHAQ::P64;
           P64[Hp - 16] = _scHAS::P64;
           P64[Hp - 8] = _scHAU::P64;
           P64[Hp] = _scHAW::P64;
           R5 = Hp - 127;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl102_rcHrm_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMe_srtd" {
     ucJMe_srtd:
         const ScI2G_srt+128;
         const 35;
         const 33822867503;
 },
 sat_scHBw_entry() //  [R1, R2]
         { info_tbl: [(ccJHV,
                       label: sat_scHBw_info
                       rep:HeapRep 15 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJHV: // global
           _scHAW::P64 = R2;
           _scHBw::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJHW; else goto ccJHX;
       ccJHX: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccJHZ; else goto ccJHY;
       ccJHZ: // global
           HpAlloc = 136;
           goto ccJHW;
       ccJHW: // global
           R2 = _scHAW::P64;
           R1 = _scHBw::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJHY: // global
           _scHAq::P64 = P64[_scHBw::P64 + 7];
           _scHAu::P64 = P64[_scHBw::P64 + 15];
           _scHAw::P64 = P64[_scHBw::P64 + 23];
           _scHAy::P64 = P64[_scHBw::P64 + 31];
           _scHAA::P64 = P64[_scHBw::P64 + 39];
           _scHAC::P64 = P64[_scHBw::P64 + 47];
           _scHAE::P64 = P64[_scHBw::P64 + 55];
           _scHAG::P64 = P64[_scHBw::P64 + 63];
           _scHAI::P64 = P64[_scHBw::P64 + 71];
           _scHAK::P64 = P64[_scHBw::P64 + 79];
           _scHAM::P64 = P64[_scHBw::P64 + 87];
           _scHAO::P64 = P64[_scHBw::P64 + 95];
           _scHAQ::P64 = P64[_scHBw::P64 + 103];
           _scHAS::P64 = P64[_scHBw::P64 + 111];
           _scHAU::P64 = P64[_scHBw::P64 + 119];
           I64[Hp - 128] = sat_scHBt_info;
           P64[Hp - 120] = _scHAq::P64;
           P64[Hp - 112] = _scHAu::P64;
           P64[Hp - 104] = _scHAw::P64;
           P64[Hp - 96] = _scHAy::P64;
           P64[Hp - 88] = _scHAA::P64;
           P64[Hp - 80] = _scHAC::P64;
           P64[Hp - 72] = _scHAE::P64;
           P64[Hp - 64] = _scHAG::P64;
           P64[Hp - 56] = _scHAI::P64;
           P64[Hp - 48] = _scHAK::P64;
           P64[Hp - 40] = _scHAM::P64;
           P64[Hp - 32] = _scHAO::P64;
           P64[Hp - 24] = _scHAQ::P64;
           P64[Hp - 16] = _scHAS::P64;
           P64[Hp - 8] = _scHAU::P64;
           P64[Hp] = _scHAW::P64;
           I64[Sp - 8] = block_ccJHS_info;
           R3 = Hp - 127;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJHS() //  [R1]
         { info_tbl: [(ccJHS,
                       label: block_ccJHS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJHS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJI2; else goto ccJI1;
       ccJI2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJI1: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMf_srtd" {
     ucJMf_srtd:
         const ScI2G_srt+128;
         const 36;
         const 68182605871;
 },
 sat_scHBx_entry() //  [R1, R2]
         { info_tbl: [(ccJI3,
                       label: sat_scHBx_info
                       rep:HeapRep 15 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJI3: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccJI7; else goto ccJI6;
       ccJI7: // global
           HpAlloc = 128;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJI6: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           I64[Hp - 120] = sat_scHBw_info;
           P64[Hp - 112] = _scHAq::P64;
           P64[Hp - 104] = _scHAu::P64;
           P64[Hp - 96] = _scHAw::P64;
           P64[Hp - 88] = _scHAy::P64;
           P64[Hp - 80] = _scHAA::P64;
           P64[Hp - 72] = _scHAC::P64;
           P64[Hp - 64] = _scHAE::P64;
           P64[Hp - 56] = _scHAG::P64;
           P64[Hp - 48] = _scHAI::P64;
           P64[Hp - 40] = _scHAK::P64;
           P64[Hp - 32] = _scHAM::P64;
           P64[Hp - 24] = _scHAO::P64;
           P64[Hp - 16] = _scHAQ::P64;
           P64[Hp - 8] = _scHAS::P64;
           P64[Hp] = _scHAU::P64;
           R5 = Hp - 119;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl100_rcHrk_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMg_srtd" {
     ucJMg_srtd:
         const ScI2G_srt+128;
         const 36;
         const 68182605871;
 },
 sat_scHBA_entry() //  [R1, R2]
         { info_tbl: [(ccJIb,
                       label: sat_scHBA_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJIb: // global
           _scHAU::P64 = R2;
           _scHBA::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJIc; else goto ccJId;
       ccJId: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccJIf; else goto ccJIe;
       ccJIf: // global
           HpAlloc = 128;
           goto ccJIc;
       ccJIc: // global
           R2 = _scHAU::P64;
           R1 = _scHBA::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJIe: // global
           _scHAq::P64 = P64[_scHBA::P64 + 7];
           _scHAu::P64 = P64[_scHBA::P64 + 15];
           _scHAw::P64 = P64[_scHBA::P64 + 23];
           _scHAy::P64 = P64[_scHBA::P64 + 31];
           _scHAA::P64 = P64[_scHBA::P64 + 39];
           _scHAC::P64 = P64[_scHBA::P64 + 47];
           _scHAE::P64 = P64[_scHBA::P64 + 55];
           _scHAG::P64 = P64[_scHBA::P64 + 63];
           _scHAI::P64 = P64[_scHBA::P64 + 71];
           _scHAK::P64 = P64[_scHBA::P64 + 79];
           _scHAM::P64 = P64[_scHBA::P64 + 87];
           _scHAO::P64 = P64[_scHBA::P64 + 95];
           _scHAQ::P64 = P64[_scHBA::P64 + 103];
           _scHAS::P64 = P64[_scHBA::P64 + 111];
           I64[Hp - 120] = sat_scHBx_info;
           P64[Hp - 112] = _scHAq::P64;
           P64[Hp - 104] = _scHAu::P64;
           P64[Hp - 96] = _scHAw::P64;
           P64[Hp - 88] = _scHAy::P64;
           P64[Hp - 80] = _scHAA::P64;
           P64[Hp - 72] = _scHAC::P64;
           P64[Hp - 64] = _scHAE::P64;
           P64[Hp - 56] = _scHAG::P64;
           P64[Hp - 48] = _scHAI::P64;
           P64[Hp - 40] = _scHAK::P64;
           P64[Hp - 32] = _scHAM::P64;
           P64[Hp - 24] = _scHAO::P64;
           P64[Hp - 16] = _scHAQ::P64;
           P64[Hp - 8] = _scHAS::P64;
           P64[Hp] = _scHAU::P64;
           I64[Sp - 8] = block_ccJI8_info;
           R3 = Hp - 119;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJI8() //  [R1]
         { info_tbl: [(ccJI8,
                       label: block_ccJI8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJI8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJIi; else goto ccJIh;
       ccJIi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJIh: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMh_srtd" {
     ucJMh_srtd:
         const ScI2G_srt+128;
         const 37;
         const 136902082607;
 },
 sat_scHBB_entry() //  [R1, R2]
         { info_tbl: [(ccJIj,
                       label: sat_scHBB_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJIj: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccJIn; else goto ccJIm;
       ccJIn: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJIm: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           I64[Hp - 112] = sat_scHBA_info;
           P64[Hp - 104] = _scHAq::P64;
           P64[Hp - 96] = _scHAu::P64;
           P64[Hp - 88] = _scHAw::P64;
           P64[Hp - 80] = _scHAy::P64;
           P64[Hp - 72] = _scHAA::P64;
           P64[Hp - 64] = _scHAC::P64;
           P64[Hp - 56] = _scHAE::P64;
           P64[Hp - 48] = _scHAG::P64;
           P64[Hp - 40] = _scHAI::P64;
           P64[Hp - 32] = _scHAK::P64;
           P64[Hp - 24] = _scHAM::P64;
           P64[Hp - 16] = _scHAO::P64;
           P64[Hp - 8] = _scHAQ::P64;
           P64[Hp] = _scHAS::P64;
           R5 = Hp - 111;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl98_rcHri_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMi_srtd" {
     ucJMi_srtd:
         const ScI2G_srt+128;
         const 37;
         const 136902082607;
 },
 sat_scHBE_entry() //  [R1, R2]
         { info_tbl: [(ccJIr,
                       label: sat_scHBE_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJIr: // global
           _scHAS::P64 = R2;
           _scHBE::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJIs; else goto ccJIt;
       ccJIt: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccJIv; else goto ccJIu;
       ccJIv: // global
           HpAlloc = 120;
           goto ccJIs;
       ccJIs: // global
           R2 = _scHAS::P64;
           R1 = _scHBE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJIu: // global
           _scHAq::P64 = P64[_scHBE::P64 + 7];
           _scHAu::P64 = P64[_scHBE::P64 + 15];
           _scHAw::P64 = P64[_scHBE::P64 + 23];
           _scHAy::P64 = P64[_scHBE::P64 + 31];
           _scHAA::P64 = P64[_scHBE::P64 + 39];
           _scHAC::P64 = P64[_scHBE::P64 + 47];
           _scHAE::P64 = P64[_scHBE::P64 + 55];
           _scHAG::P64 = P64[_scHBE::P64 + 63];
           _scHAI::P64 = P64[_scHBE::P64 + 71];
           _scHAK::P64 = P64[_scHBE::P64 + 79];
           _scHAM::P64 = P64[_scHBE::P64 + 87];
           _scHAO::P64 = P64[_scHBE::P64 + 95];
           _scHAQ::P64 = P64[_scHBE::P64 + 103];
           I64[Hp - 112] = sat_scHBB_info;
           P64[Hp - 104] = _scHAq::P64;
           P64[Hp - 96] = _scHAu::P64;
           P64[Hp - 88] = _scHAw::P64;
           P64[Hp - 80] = _scHAy::P64;
           P64[Hp - 72] = _scHAA::P64;
           P64[Hp - 64] = _scHAC::P64;
           P64[Hp - 56] = _scHAE::P64;
           P64[Hp - 48] = _scHAG::P64;
           P64[Hp - 40] = _scHAI::P64;
           P64[Hp - 32] = _scHAK::P64;
           P64[Hp - 24] = _scHAM::P64;
           P64[Hp - 16] = _scHAO::P64;
           P64[Hp - 8] = _scHAQ::P64;
           P64[Hp] = _scHAS::P64;
           I64[Sp - 8] = block_ccJIo_info;
           R3 = Hp - 111;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJIo() //  [R1]
         { info_tbl: [(ccJIo,
                       label: block_ccJIo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJIo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJIy; else goto ccJIx;
       ccJIy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJIx: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMj_srtd" {
     ucJMj_srtd:
         const ScI2G_srt+104;
         const 41;
         const 2194728288633;
 },
 sat_scHBF_entry() //  [R1, R2]
         { info_tbl: [(ccJIz,
                       label: sat_scHBF_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJIz: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccJID; else goto ccJIC;
       ccJID: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJIC: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           I64[Hp - 104] = sat_scHBE_info;
           P64[Hp - 96] = _scHAq::P64;
           P64[Hp - 88] = _scHAu::P64;
           P64[Hp - 80] = _scHAw::P64;
           P64[Hp - 72] = _scHAy::P64;
           P64[Hp - 64] = _scHAA::P64;
           P64[Hp - 56] = _scHAC::P64;
           P64[Hp - 48] = _scHAE::P64;
           P64[Hp - 40] = _scHAG::P64;
           P64[Hp - 32] = _scHAI::P64;
           P64[Hp - 24] = _scHAK::P64;
           P64[Hp - 16] = _scHAM::P64;
           P64[Hp - 8] = _scHAO::P64;
           P64[Hp] = _scHAQ::P64;
           R5 = Hp - 103;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl96_rcHrg_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMk_srtd" {
     ucJMk_srtd:
         const ScI2G_srt+104;
         const 41;
         const 2194728288633;
 },
 sat_scHBI_entry() //  [R1, R2]
         { info_tbl: [(ccJIH,
                       label: sat_scHBI_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJIH: // global
           _scHAQ::P64 = R2;
           _scHBI::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJII; else goto ccJIJ;
       ccJIJ: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccJIL; else goto ccJIK;
       ccJIL: // global
           HpAlloc = 112;
           goto ccJII;
       ccJII: // global
           R2 = _scHAQ::P64;
           R1 = _scHBI::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJIK: // global
           _scHAq::P64 = P64[_scHBI::P64 + 7];
           _scHAu::P64 = P64[_scHBI::P64 + 15];
           _scHAw::P64 = P64[_scHBI::P64 + 23];
           _scHAy::P64 = P64[_scHBI::P64 + 31];
           _scHAA::P64 = P64[_scHBI::P64 + 39];
           _scHAC::P64 = P64[_scHBI::P64 + 47];
           _scHAE::P64 = P64[_scHBI::P64 + 55];
           _scHAG::P64 = P64[_scHBI::P64 + 63];
           _scHAI::P64 = P64[_scHBI::P64 + 71];
           _scHAK::P64 = P64[_scHBI::P64 + 79];
           _scHAM::P64 = P64[_scHBI::P64 + 87];
           _scHAO::P64 = P64[_scHBI::P64 + 95];
           I64[Hp - 104] = sat_scHBF_info;
           P64[Hp - 96] = _scHAq::P64;
           P64[Hp - 88] = _scHAu::P64;
           P64[Hp - 80] = _scHAw::P64;
           P64[Hp - 72] = _scHAy::P64;
           P64[Hp - 64] = _scHAA::P64;
           P64[Hp - 56] = _scHAC::P64;
           P64[Hp - 48] = _scHAE::P64;
           P64[Hp - 40] = _scHAG::P64;
           P64[Hp - 32] = _scHAI::P64;
           P64[Hp - 24] = _scHAK::P64;
           P64[Hp - 16] = _scHAM::P64;
           P64[Hp - 8] = _scHAO::P64;
           P64[Hp] = _scHAQ::P64;
           I64[Sp - 8] = block_ccJIE_info;
           R3 = Hp - 103;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJIE() //  [R1]
         { info_tbl: [(ccJIE,
                       label: block_ccJIE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJIE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJIO; else goto ccJIN;
       ccJIO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJIN: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMl_srtd" {
     ucJMl_srtd:
         const ScI2G_srt+104;
         const 42;
         const 4393751544185;
 },
 sat_scHBJ_entry() //  [R1, R2]
         { info_tbl: [(ccJIP,
                       label: sat_scHBJ_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJIP: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccJIT; else goto ccJIS;
       ccJIT: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJIS: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           I64[Hp - 96] = sat_scHBI_info;
           P64[Hp - 88] = _scHAq::P64;
           P64[Hp - 80] = _scHAu::P64;
           P64[Hp - 72] = _scHAw::P64;
           P64[Hp - 64] = _scHAy::P64;
           P64[Hp - 56] = _scHAA::P64;
           P64[Hp - 48] = _scHAC::P64;
           P64[Hp - 40] = _scHAE::P64;
           P64[Hp - 32] = _scHAG::P64;
           P64[Hp - 24] = _scHAI::P64;
           P64[Hp - 16] = _scHAK::P64;
           P64[Hp - 8] = _scHAM::P64;
           P64[Hp] = _scHAO::P64;
           R5 = Hp - 95;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl94_rcHre_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMm_srtd" {
     ucJMm_srtd:
         const ScI2G_srt+104;
         const 42;
         const 4393751544185;
 },
 sat_scHBM_entry() //  [R1, R2]
         { info_tbl: [(ccJIX,
                       label: sat_scHBM_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJIX: // global
           _scHAO::P64 = R2;
           _scHBM::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJIY; else goto ccJIZ;
       ccJIZ: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccJJ1; else goto ccJJ0;
       ccJJ1: // global
           HpAlloc = 104;
           goto ccJIY;
       ccJIY: // global
           R2 = _scHAO::P64;
           R1 = _scHBM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJJ0: // global
           _scHAq::P64 = P64[_scHBM::P64 + 7];
           _scHAu::P64 = P64[_scHBM::P64 + 15];
           _scHAw::P64 = P64[_scHBM::P64 + 23];
           _scHAy::P64 = P64[_scHBM::P64 + 31];
           _scHAA::P64 = P64[_scHBM::P64 + 39];
           _scHAC::P64 = P64[_scHBM::P64 + 47];
           _scHAE::P64 = P64[_scHBM::P64 + 55];
           _scHAG::P64 = P64[_scHBM::P64 + 63];
           _scHAI::P64 = P64[_scHBM::P64 + 71];
           _scHAK::P64 = P64[_scHBM::P64 + 79];
           _scHAM::P64 = P64[_scHBM::P64 + 87];
           I64[Hp - 96] = sat_scHBJ_info;
           P64[Hp - 88] = _scHAq::P64;
           P64[Hp - 80] = _scHAu::P64;
           P64[Hp - 72] = _scHAw::P64;
           P64[Hp - 64] = _scHAy::P64;
           P64[Hp - 56] = _scHAA::P64;
           P64[Hp - 48] = _scHAC::P64;
           P64[Hp - 40] = _scHAE::P64;
           P64[Hp - 32] = _scHAG::P64;
           P64[Hp - 24] = _scHAI::P64;
           P64[Hp - 16] = _scHAK::P64;
           P64[Hp - 8] = _scHAM::P64;
           P64[Hp] = _scHAO::P64;
           I64[Sp - 8] = block_ccJIU_info;
           R3 = Hp - 95;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJIU() //  [R1]
         { info_tbl: [(ccJIU,
                       label: block_ccJIU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJIU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJJ4; else goto ccJJ3;
       ccJJ4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJJ3: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMn_srtd" {
     ucJMn_srtd:
         const ScI2G_srt+104;
         const 43;
         const 8791798055289;
 },
 sat_scHBN_entry() //  [R1, R2]
         { info_tbl: [(ccJJ5,
                       label: sat_scHBN_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJJ5: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccJJ9; else goto ccJJ8;
       ccJJ9: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJJ8: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           I64[Hp - 88] = sat_scHBM_info;
           P64[Hp - 80] = _scHAq::P64;
           P64[Hp - 72] = _scHAu::P64;
           P64[Hp - 64] = _scHAw::P64;
           P64[Hp - 56] = _scHAy::P64;
           P64[Hp - 48] = _scHAA::P64;
           P64[Hp - 40] = _scHAC::P64;
           P64[Hp - 32] = _scHAE::P64;
           P64[Hp - 24] = _scHAG::P64;
           P64[Hp - 16] = _scHAI::P64;
           P64[Hp - 8] = _scHAK::P64;
           P64[Hp] = _scHAM::P64;
           R5 = Hp - 87;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl92_rcHrc_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMo_srtd" {
     ucJMo_srtd:
         const ScI2G_srt+104;
         const 43;
         const 8791798055289;
 },
 sat_scHBQ_entry() //  [R1, R2]
         { info_tbl: [(ccJJd,
                       label: sat_scHBQ_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJJd: // global
           _scHAM::P64 = R2;
           _scHBQ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJJe; else goto ccJJf;
       ccJJf: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccJJh; else goto ccJJg;
       ccJJh: // global
           HpAlloc = 96;
           goto ccJJe;
       ccJJe: // global
           R2 = _scHAM::P64;
           R1 = _scHBQ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJJg: // global
           _scHAq::P64 = P64[_scHBQ::P64 + 7];
           _scHAu::P64 = P64[_scHBQ::P64 + 15];
           _scHAw::P64 = P64[_scHBQ::P64 + 23];
           _scHAy::P64 = P64[_scHBQ::P64 + 31];
           _scHAA::P64 = P64[_scHBQ::P64 + 39];
           _scHAC::P64 = P64[_scHBQ::P64 + 47];
           _scHAE::P64 = P64[_scHBQ::P64 + 55];
           _scHAG::P64 = P64[_scHBQ::P64 + 63];
           _scHAI::P64 = P64[_scHBQ::P64 + 71];
           _scHAK::P64 = P64[_scHBQ::P64 + 79];
           I64[Hp - 88] = sat_scHBN_info;
           P64[Hp - 80] = _scHAq::P64;
           P64[Hp - 72] = _scHAu::P64;
           P64[Hp - 64] = _scHAw::P64;
           P64[Hp - 56] = _scHAy::P64;
           P64[Hp - 48] = _scHAA::P64;
           P64[Hp - 40] = _scHAC::P64;
           P64[Hp - 32] = _scHAE::P64;
           P64[Hp - 24] = _scHAG::P64;
           P64[Hp - 16] = _scHAI::P64;
           P64[Hp - 8] = _scHAK::P64;
           P64[Hp] = _scHAM::P64;
           I64[Sp - 8] = block_ccJJa_info;
           R3 = Hp - 87;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJJa() //  [R1]
         { info_tbl: [(ccJJa,
                       label: block_ccJJa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJJa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJJk; else goto ccJJj;
       ccJJk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJJj: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMp_srtd" {
     ucJMp_srtd:
         const ScI2G_srt+104;
         const 44;
         const 17587891077497;
 },
 sat_scHBR_entry() //  [R1, R2]
         { info_tbl: [(ccJJl,
                       label: sat_scHBR_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJJl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccJJp; else goto ccJJo;
       ccJJp: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJJo: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           I64[Hp - 80] = sat_scHBQ_info;
           P64[Hp - 72] = _scHAq::P64;
           P64[Hp - 64] = _scHAu::P64;
           P64[Hp - 56] = _scHAw::P64;
           P64[Hp - 48] = _scHAy::P64;
           P64[Hp - 40] = _scHAA::P64;
           P64[Hp - 32] = _scHAC::P64;
           P64[Hp - 24] = _scHAE::P64;
           P64[Hp - 16] = _scHAG::P64;
           P64[Hp - 8] = _scHAI::P64;
           P64[Hp] = _scHAK::P64;
           R5 = Hp - 79;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl90_rcHra_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMq_srtd" {
     ucJMq_srtd:
         const ScI2G_srt+104;
         const 44;
         const 17587891077497;
 },
 sat_scHBU_entry() //  [R1, R2]
         { info_tbl: [(ccJJt,
                       label: sat_scHBU_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJJt: // global
           _scHAK::P64 = R2;
           _scHBU::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJJu; else goto ccJJv;
       ccJJv: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccJJx; else goto ccJJw;
       ccJJx: // global
           HpAlloc = 88;
           goto ccJJu;
       ccJJu: // global
           R2 = _scHAK::P64;
           R1 = _scHBU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJJw: // global
           _scHAq::P64 = P64[_scHBU::P64 + 7];
           _scHAu::P64 = P64[_scHBU::P64 + 15];
           _scHAw::P64 = P64[_scHBU::P64 + 23];
           _scHAy::P64 = P64[_scHBU::P64 + 31];
           _scHAA::P64 = P64[_scHBU::P64 + 39];
           _scHAC::P64 = P64[_scHBU::P64 + 47];
           _scHAE::P64 = P64[_scHBU::P64 + 55];
           _scHAG::P64 = P64[_scHBU::P64 + 63];
           _scHAI::P64 = P64[_scHBU::P64 + 71];
           I64[Hp - 80] = sat_scHBR_info;
           P64[Hp - 72] = _scHAq::P64;
           P64[Hp - 64] = _scHAu::P64;
           P64[Hp - 56] = _scHAw::P64;
           P64[Hp - 48] = _scHAy::P64;
           P64[Hp - 40] = _scHAA::P64;
           P64[Hp - 32] = _scHAC::P64;
           P64[Hp - 24] = _scHAE::P64;
           P64[Hp - 16] = _scHAG::P64;
           P64[Hp - 8] = _scHAI::P64;
           P64[Hp] = _scHAK::P64;
           I64[Sp - 8] = block_ccJJq_info;
           R3 = Hp - 79;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJJq() //  [R1]
         { info_tbl: [(ccJJq,
                       label: block_ccJJq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJJq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJJA; else goto ccJJz;
       ccJJA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJJz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMr_srtd" {
     ucJMr_srtd:
         const ScI2G_srt+104;
         const 45;
         const 35180077121913;
 },
 sat_scHBV_entry() //  [R1, R2]
         { info_tbl: [(ccJJB,
                       label: sat_scHBV_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJJB: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccJJF; else goto ccJJE;
       ccJJF: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJJE: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           I64[Hp - 72] = sat_scHBU_info;
           P64[Hp - 64] = _scHAq::P64;
           P64[Hp - 56] = _scHAu::P64;
           P64[Hp - 48] = _scHAw::P64;
           P64[Hp - 40] = _scHAy::P64;
           P64[Hp - 32] = _scHAA::P64;
           P64[Hp - 24] = _scHAC::P64;
           P64[Hp - 16] = _scHAE::P64;
           P64[Hp - 8] = _scHAG::P64;
           P64[Hp] = _scHAI::P64;
           R5 = Hp - 71;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl88_rcHr8_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMs_srtd" {
     ucJMs_srtd:
         const ScI2G_srt+104;
         const 45;
         const 35180077121913;
 },
 sat_scHBY_entry() //  [R1, R2]
         { info_tbl: [(ccJJJ,
                       label: sat_scHBY_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJJJ: // global
           _scHAI::P64 = R2;
           _scHBY::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJJK; else goto ccJJL;
       ccJJL: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccJJN; else goto ccJJM;
       ccJJN: // global
           HpAlloc = 80;
           goto ccJJK;
       ccJJK: // global
           R2 = _scHAI::P64;
           R1 = _scHBY::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJJM: // global
           _scHAq::P64 = P64[_scHBY::P64 + 7];
           _scHAu::P64 = P64[_scHBY::P64 + 15];
           _scHAw::P64 = P64[_scHBY::P64 + 23];
           _scHAy::P64 = P64[_scHBY::P64 + 31];
           _scHAA::P64 = P64[_scHBY::P64 + 39];
           _scHAC::P64 = P64[_scHBY::P64 + 47];
           _scHAE::P64 = P64[_scHBY::P64 + 55];
           _scHAG::P64 = P64[_scHBY::P64 + 63];
           I64[Hp - 72] = sat_scHBV_info;
           P64[Hp - 64] = _scHAq::P64;
           P64[Hp - 56] = _scHAu::P64;
           P64[Hp - 48] = _scHAw::P64;
           P64[Hp - 40] = _scHAy::P64;
           P64[Hp - 32] = _scHAA::P64;
           P64[Hp - 24] = _scHAC::P64;
           P64[Hp - 16] = _scHAE::P64;
           P64[Hp - 8] = _scHAG::P64;
           P64[Hp] = _scHAI::P64;
           I64[Sp - 8] = block_ccJJG_info;
           R3 = Hp - 71;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJJG() //  [R1]
         { info_tbl: [(ccJJG,
                       label: block_ccJJG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJJG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJJQ; else goto ccJJP;
       ccJJQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJJP: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMt_srtd" {
     ucJMt_srtd:
         const ScI2G_srt+104;
         const 46;
         const 70364449210745;
 },
 sat_scHBZ_entry() //  [R1, R2]
         { info_tbl: [(ccJJR,
                       label: sat_scHBZ_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJJR: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccJJV; else goto ccJJU;
       ccJJV: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJJU: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           I64[Hp - 64] = sat_scHBY_info;
           P64[Hp - 56] = _scHAq::P64;
           P64[Hp - 48] = _scHAu::P64;
           P64[Hp - 40] = _scHAw::P64;
           P64[Hp - 32] = _scHAy::P64;
           P64[Hp - 24] = _scHAA::P64;
           P64[Hp - 16] = _scHAC::P64;
           P64[Hp - 8] = _scHAE::P64;
           P64[Hp] = _scHAG::P64;
           R5 = Hp - 63;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl86_rcHr6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMu_srtd" {
     ucJMu_srtd:
         const ScI2G_srt+104;
         const 46;
         const 70364449210745;
 },
 sat_scHC2_entry() //  [R1, R2]
         { info_tbl: [(ccJJZ,
                       label: sat_scHC2_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJJZ: // global
           _scHAG::P64 = R2;
           _scHC2::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJK0; else goto ccJK1;
       ccJK1: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccJK3; else goto ccJK2;
       ccJK3: // global
           HpAlloc = 72;
           goto ccJK0;
       ccJK0: // global
           R2 = _scHAG::P64;
           R1 = _scHC2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJK2: // global
           _scHAq::P64 = P64[_scHC2::P64 + 7];
           _scHAu::P64 = P64[_scHC2::P64 + 15];
           _scHAw::P64 = P64[_scHC2::P64 + 23];
           _scHAy::P64 = P64[_scHC2::P64 + 31];
           _scHAA::P64 = P64[_scHC2::P64 + 39];
           _scHAC::P64 = P64[_scHC2::P64 + 47];
           _scHAE::P64 = P64[_scHC2::P64 + 55];
           I64[Hp - 64] = sat_scHBZ_info;
           P64[Hp - 56] = _scHAq::P64;
           P64[Hp - 48] = _scHAu::P64;
           P64[Hp - 40] = _scHAw::P64;
           P64[Hp - 32] = _scHAy::P64;
           P64[Hp - 24] = _scHAA::P64;
           P64[Hp - 16] = _scHAC::P64;
           P64[Hp - 8] = _scHAE::P64;
           P64[Hp] = _scHAG::P64;
           I64[Sp - 8] = block_ccJJW_info;
           R3 = Hp - 63;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJJW() //  [R1]
         { info_tbl: [(ccJJW,
                       label: block_ccJJW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJJW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJK6; else goto ccJK5;
       ccJK6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJK5: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMv_srtd" {
     ucJMv_srtd:
         const ScI2G_srt+104;
         const 47;
         const 140733193388409;
 },
 sat_scHC3_entry() //  [R1, R2]
         { info_tbl: [(ccJK7,
                       label: sat_scHC3_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJK7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccJKb; else goto ccJKa;
       ccJKb: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJKa: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           I64[Hp - 56] = sat_scHC2_info;
           P64[Hp - 48] = _scHAq::P64;
           P64[Hp - 40] = _scHAu::P64;
           P64[Hp - 32] = _scHAw::P64;
           P64[Hp - 24] = _scHAy::P64;
           P64[Hp - 16] = _scHAA::P64;
           P64[Hp - 8] = _scHAC::P64;
           P64[Hp] = _scHAE::P64;
           R5 = Hp - 55;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl84_rcHr4_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMw_srtd" {
     ucJMw_srtd:
         const ScI2G_srt+104;
         const 47;
         const 140733193388409;
 },
 sat_scHC6_entry() //  [R1, R2]
         { info_tbl: [(ccJKf,
                       label: sat_scHC6_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJKf: // global
           _scHAE::P64 = R2;
           _scHC6::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJKg; else goto ccJKh;
       ccJKh: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccJKj; else goto ccJKi;
       ccJKj: // global
           HpAlloc = 64;
           goto ccJKg;
       ccJKg: // global
           R2 = _scHAE::P64;
           R1 = _scHC6::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJKi: // global
           _scHAq::P64 = P64[_scHC6::P64 + 7];
           _scHAu::P64 = P64[_scHC6::P64 + 15];
           _scHAw::P64 = P64[_scHC6::P64 + 23];
           _scHAy::P64 = P64[_scHC6::P64 + 31];
           _scHAA::P64 = P64[_scHC6::P64 + 39];
           _scHAC::P64 = P64[_scHC6::P64 + 47];
           I64[Hp - 56] = sat_scHC3_info;
           P64[Hp - 48] = _scHAq::P64;
           P64[Hp - 40] = _scHAu::P64;
           P64[Hp - 32] = _scHAw::P64;
           P64[Hp - 24] = _scHAy::P64;
           P64[Hp - 16] = _scHAA::P64;
           P64[Hp - 8] = _scHAC::P64;
           P64[Hp] = _scHAE::P64;
           I64[Sp - 8] = block_ccJKc_info;
           R3 = Hp - 55;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJKc() //  [R1]
         { info_tbl: [(ccJKc,
                       label: block_ccJKc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJKc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJKm; else goto ccJKl;
       ccJKm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJKl: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMx_srtd" {
     ucJMx_srtd:
         const ScI2G_srt+104;
         const 48;
         const 281470681743737;
 },
 sat_scHC7_entry() //  [R1, R2]
         { info_tbl: [(ccJKn,
                       label: sat_scHC7_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJKn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccJKr; else goto ccJKq;
       ccJKr: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJKq: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           I64[Hp - 48] = sat_scHC6_info;
           P64[Hp - 40] = _scHAq::P64;
           P64[Hp - 32] = _scHAu::P64;
           P64[Hp - 24] = _scHAw::P64;
           P64[Hp - 16] = _scHAy::P64;
           P64[Hp - 8] = _scHAA::P64;
           P64[Hp] = _scHAC::P64;
           R5 = Hp - 47;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl82_rcHr2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMy_srtd" {
     ucJMy_srtd:
         const ScI2G_srt+104;
         const 48;
         const 281470681743737;
 },
 sat_scHCa_entry() //  [R1, R2]
         { info_tbl: [(ccJKv,
                       label: sat_scHCa_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJKv: // global
           _scHAC::P64 = R2;
           _scHCa::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJKw; else goto ccJKx;
       ccJKx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccJKz; else goto ccJKy;
       ccJKz: // global
           HpAlloc = 56;
           goto ccJKw;
       ccJKw: // global
           R2 = _scHAC::P64;
           R1 = _scHCa::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJKy: // global
           _scHAq::P64 = P64[_scHCa::P64 + 7];
           _scHAu::P64 = P64[_scHCa::P64 + 15];
           _scHAw::P64 = P64[_scHCa::P64 + 23];
           _scHAy::P64 = P64[_scHCa::P64 + 31];
           _scHAA::P64 = P64[_scHCa::P64 + 39];
           I64[Hp - 48] = sat_scHC7_info;
           P64[Hp - 40] = _scHAq::P64;
           P64[Hp - 32] = _scHAu::P64;
           P64[Hp - 24] = _scHAw::P64;
           P64[Hp - 16] = _scHAy::P64;
           P64[Hp - 8] = _scHAA::P64;
           P64[Hp] = _scHAC::P64;
           I64[Sp - 8] = block_ccJKs_info;
           R3 = Hp - 47;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJKs() //  [R1]
         { info_tbl: [(ccJKs,
                       label: block_ccJKs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJKs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJKC; else goto ccJKB;
       ccJKC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJKB: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMz_srtd" {
     ucJMz_srtd:
         const ScI2G_srt+104;
         const 49;
         const 562945658454393;
 },
 sat_scHCb_entry() //  [R1, R2]
         { info_tbl: [(ccJKD,
                       label: sat_scHCb_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJKD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccJKH; else goto ccJKG;
       ccJKH: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJKG: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           I64[Hp - 40] = sat_scHCa_info;
           P64[Hp - 32] = _scHAq::P64;
           P64[Hp - 24] = _scHAu::P64;
           P64[Hp - 16] = _scHAw::P64;
           P64[Hp - 8] = _scHAy::P64;
           P64[Hp] = _scHAA::P64;
           R5 = Hp - 39;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl80_rcHr0_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMA_srtd" {
     ucJMA_srtd:
         const ScI2G_srt+104;
         const 49;
         const 562945658454393;
 },
 sat_scHCe_entry() //  [R1, R2]
         { info_tbl: [(ccJKL,
                       label: sat_scHCe_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJKL: // global
           _scHAA::P64 = R2;
           _scHCe::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJKM; else goto ccJKN;
       ccJKN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccJKP; else goto ccJKO;
       ccJKP: // global
           HpAlloc = 48;
           goto ccJKM;
       ccJKM: // global
           R2 = _scHAA::P64;
           R1 = _scHCe::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJKO: // global
           _scHAq::P64 = P64[_scHCe::P64 + 7];
           _scHAu::P64 = P64[_scHCe::P64 + 15];
           _scHAw::P64 = P64[_scHCe::P64 + 23];
           _scHAy::P64 = P64[_scHCe::P64 + 31];
           I64[Hp - 40] = sat_scHCb_info;
           P64[Hp - 32] = _scHAq::P64;
           P64[Hp - 24] = _scHAu::P64;
           P64[Hp - 16] = _scHAw::P64;
           P64[Hp - 8] = _scHAy::P64;
           P64[Hp] = _scHAA::P64;
           I64[Sp - 8] = block_ccJKI_info;
           R3 = Hp - 39;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJKI() //  [R1]
         { info_tbl: [(ccJKI,
                       label: block_ccJKI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJKI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJKS; else goto ccJKR;
       ccJKS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJKR: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMB_srtd" {
     ucJMB_srtd:
         const ScI2G_srt+104;
         const 50;
         const 1125895611875705;
 },
 sat_scHCf_entry() //  [R1, R2]
         { info_tbl: [(ccJKT,
                       label: sat_scHCf_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJKT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccJKX; else goto ccJKW;
       ccJKX: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJKW: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           I64[Hp - 32] = sat_scHCe_info;
           P64[Hp - 24] = _scHAq::P64;
           P64[Hp - 16] = _scHAu::P64;
           P64[Hp - 8] = _scHAw::P64;
           P64[Hp] = _scHAy::P64;
           R5 = Hp - 31;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl78_rcHqY_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMC_srtd" {
     ucJMC_srtd:
         const ScI2G_srt+104;
         const 50;
         const 1125895611875705;
 },
 sat_scHCi_entry() //  [R1, R2]
         { info_tbl: [(ccJL1,
                       label: sat_scHCi_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJL1: // global
           _scHAy::P64 = R2;
           _scHCi::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJL2; else goto ccJL3;
       ccJL3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccJL5; else goto ccJL4;
       ccJL5: // global
           HpAlloc = 40;
           goto ccJL2;
       ccJL2: // global
           R2 = _scHAy::P64;
           R1 = _scHCi::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJL4: // global
           _scHAq::P64 = P64[_scHCi::P64 + 7];
           _scHAu::P64 = P64[_scHCi::P64 + 15];
           _scHAw::P64 = P64[_scHCi::P64 + 23];
           I64[Hp - 32] = sat_scHCf_info;
           P64[Hp - 24] = _scHAq::P64;
           P64[Hp - 16] = _scHAu::P64;
           P64[Hp - 8] = _scHAw::P64;
           P64[Hp] = _scHAy::P64;
           I64[Sp - 8] = block_ccJKY_info;
           R3 = Hp - 31;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJKY() //  [R1]
         { info_tbl: [(ccJKY,
                       label: block_ccJKY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJKY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJL8; else goto ccJL7;
       ccJL8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJL7: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMD_srtd" {
     ucJMD_srtd:
         const ScI2G_srt+104;
         const 51;
         const 2251795518718329;
 },
 sat_scHCj_entry() //  [R1, R2]
         { info_tbl: [(ccJL9,
                       label: sat_scHCj_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJL9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccJLd; else goto ccJLc;
       ccJLd: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJLc: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           I64[Hp - 24] = sat_scHCi_info;
           P64[Hp - 16] = _scHAq::P64;
           P64[Hp - 8] = _scHAu::P64;
           P64[Hp] = _scHAw::P64;
           R5 = Hp - 23;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl76_rcHqW_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJME_srtd" {
     ucJME_srtd:
         const ScI2G_srt+104;
         const 51;
         const 2251795518718329;
 },
 sat_scHCm_entry() //  [R1, R2]
         { info_tbl: [(ccJLh,
                       label: sat_scHCm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJLh: // global
           _scHAw::P64 = R2;
           _scHCm::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJLi; else goto ccJLj;
       ccJLj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccJLl; else goto ccJLk;
       ccJLl: // global
           HpAlloc = 32;
           goto ccJLi;
       ccJLi: // global
           R2 = _scHAw::P64;
           R1 = _scHCm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJLk: // global
           _scHAq::P64 = P64[_scHCm::P64 + 7];
           _scHAu::P64 = P64[_scHCm::P64 + 15];
           I64[Hp - 24] = sat_scHCj_info;
           P64[Hp - 16] = _scHAq::P64;
           P64[Hp - 8] = _scHAu::P64;
           P64[Hp] = _scHAw::P64;
           I64[Sp - 8] = block_ccJLe_info;
           R3 = Hp - 23;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJLe() //  [R1]
         { info_tbl: [(ccJLe,
                       label: block_ccJLe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJLe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJLo; else goto ccJLn;
       ccJLo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJLn: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMF_srtd" {
     ucJMF_srtd:
         const ScI2G_srt+80;
         const 55;
         const 36028762659228617;
 },
 sat_scHCn_entry() //  [R1, R2]
         { info_tbl: [(ccJLp,
                       label: sat_scHCn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJLp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJLt; else goto ccJLs;
       ccJLt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJLs: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_scHCm_info;
           P64[Hp - 8] = _scHAq::P64;
           P64[Hp] = _scHAu::P64;
           R5 = Hp - 15;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = lvl74_rcHqU_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMG_srtd" {
     ucJMG_srtd:
         const ScI2G_srt+80;
         const 55;
         const 36028762659228617;
 },
 sat_scHCq_entry() //  [R1, R2]
         { info_tbl: [(ccJLx,
                       label: sat_scHCq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJLx: // global
           _scHAu::P64 = R2;
           _scHCq::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJLy; else goto ccJLz;
       ccJLz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJLB; else goto ccJLA;
       ccJLB: // global
           HpAlloc = 24;
           goto ccJLy;
       ccJLy: // global
           R2 = _scHAu::P64;
           R1 = _scHCq::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJLA: // global
           _scHAq::P64 = P64[_scHCq::P64 + 7];
           I64[Hp - 16] = sat_scHCn_info;
           P64[Hp - 8] = _scHAq::P64;
           P64[Hp] = _scHAu::P64;
           I64[Sp - 8] = block_ccJLu_info;
           R3 = Hp - 15;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJLu() //  [R1]
         { info_tbl: [(ccJLu,
                       label: block_ccJLu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJLu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJLE; else goto ccJLD;
       ccJLE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJLD: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMH_srtd" {
     ucJMH_srtd:
         const ScI2G_srt+80;
         const 56;
         const 72057559678192585;
 },
 sat_scHCr_entry() //  [R1, R2]
         { info_tbl: [(ccJLF,
                       label: sat_scHCr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJLF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJLJ; else goto ccJLI;
       ccJLJ: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJLI: // global
           _scHAq::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_scHCq_info;
           P64[Hp] = _scHAq::P64;
           R5 = Hp - 7;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = ds4_rcHqS_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMI_srtd" {
     ucJMI_srtd:
         const ScI2G_srt+80;
         const 56;
         const 72057559711747017;
 },
 sat_scHCu_entry() //  [R1, R2]
         { info_tbl: [(ccJLN,
                       label: sat_scHCu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJLN: // global
           _scHAs::P64 = R2;
           _scHCu::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJLO; else goto ccJLP;
       ccJLP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJLR; else goto ccJLQ;
       ccJLR: // global
           HpAlloc = 16;
           goto ccJLO;
       ccJLO: // global
           R2 = _scHAs::P64;
           R1 = _scHCu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJLQ: // global
           _scHAq::P64 = P64[_scHCu::P64 + 7];
           I64[Hp - 8] = sat_scHCr_info;
           P64[Hp] = _scHAq::P64;
           I64[Sp - 8] = block_ccJLK_info;
           R3 = Hp - 7;
           R2 = lexeme4_rcHqa_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJLK() //  [R1]
         { info_tbl: [(ccJLK,
                       label: block_ccJLK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJLK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJLU; else goto ccJLT;
       ccJLU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJLT: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucJMJ_srtd" {
     ucJMJ_srtd:
         const ScI2G_srt+80;
         const 58;
         const 288230341825530825;
 },
 GHC.Stats.$w$creadPrec1_entry() //  [R2, R3]
         { info_tbl: [(ccJLY,
                       label: GHC.Stats.$w$creadPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJLY: // global
           _scHAq::P64 = R3;
           _scHAp::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccJLZ; else goto ccJM0;
       ccJM0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJM2; else goto ccJM1;
       ccJM2: // global
           HpAlloc = 16;
           goto ccJLZ;
       ccJLZ: // global
           R3 = _scHAq::P64;
           R2 = _scHAp::I64;
           R1 = GHC.Stats.$w$creadPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccJM1: // global
           if (%MO_S_Gt_W64(_scHAp::I64, 11)) goto ccJLW; else goto ccJLX;
       ccJLW: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccJLX: // global
           I64[Hp - 8] = sat_scHCu_info;
           P64[Hp] = _scHAq::P64;
           I64[Sp - 8] = block_ccJM3_info;
           R3 = Hp - 7;
           R2 = lexeme6_rcHqQ_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccJM3() //  [R1]
         { info_tbl: [(ccJM3,
                       label: block_ccJM3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJM3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccJM8; else goto ccJM7;
       ccJM8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccJM7: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.501640843 UTC

[section ""data" . GHC.Stats.$fReadRTSStats2_closure" {
     GHC.Stats.$fReadRTSStats2_closure:
         const GHC.Stats.$fReadRTSStats2_info;
         const 0;
 },
 GHC.Stats.$fReadRTSStats2_entry() //  [R2, R3]
         { info_tbl: [(ccJMR,
                       label: GHC.Stats.$fReadRTSStats2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJMR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJMS; else goto ccJMT;
       ccJMS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fReadRTSStats2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccJMT: // global
           I64[Sp - 16] = block_ccJMO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucJMX; else goto ccJMP;
       ucJMX: // global
           call _ccJMO(R1) args: 0, res: 0, upd: 0;
       ccJMP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJMO() //  [R1]
         { info_tbl: [(ccJMO,
                       label: block_ccJMO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJMO: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Stats.$w$creadPrec1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.502916264 UTC

[section ""data" . GHC.Stats.$fReadRTSStats1_closure" {
     GHC.Stats.$fReadRTSStats1_closure:
         const GHC.Stats.$fReadRTSStats1_info;
         const 0;
 },
 GHC.Stats.$fReadRTSStats1_entry() //  [R2, R3]
         { info_tbl: [(ccJN2,
                       label: GHC.Stats.$fReadRTSStats1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJN2: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fReadRTSStats2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.50401502 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_$creadsPrec_closure" {
     GHC.Stats.$fReadRTSStats_$creadsPrec_closure:
         const GHC.Stats.$fReadRTSStats_$creadsPrec_info;
         const 0;
 },
 sat_scHCC_entry() //  [R1]
         { info_tbl: [(ccJNd,
                       label: sat_scHCC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJNd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJNe; else goto ccJNf;
       ccJNe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJNf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Stats.$fReadRTSStats2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stats.$fReadRTSStats_$creadsPrec_entry() //  [R2]
         { info_tbl: [(ccJNg,
                       label: GHC.Stats.$fReadRTSStats_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJNg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJNk; else goto ccJNj;
       ccJNk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stats.$fReadRTSStats_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJNj: // global
           I64[Hp - 16] = sat_scHCC_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.505350973 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_$creadListPrec_closure" {
     GHC.Stats.$fReadRTSStats_$creadListPrec_closure:
         const GHC.Stats.$fReadRTSStats_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadRTSStats_$creadListPrec_entry() //  [R1]
         { info_tbl: [(ccJNr,
                       label: GHC.Stats.$fReadRTSStats_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJNr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJNs; else goto ccJNt;
       ccJNs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJNt: // global
           (_ccJNo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJNo::I64 == 0) goto ccJNq; else goto ccJNp;
       ccJNq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJNp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJNo::I64;
           R2 = GHC.Stats.$fReadRTSStats1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.506483198 UTC

[section ""data" . GHC.Stats.$fReadRTSStats3_closure" {
     GHC.Stats.$fReadRTSStats3_closure:
         const GHC.Stats.$fReadRTSStats3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadRTSStats3_entry() //  [R1]
         { info_tbl: [(ccJNA,
                       label: GHC.Stats.$fReadRTSStats3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJNA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJNB; else goto ccJNC;
       ccJNB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJNC: // global
           (_ccJNx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJNx::I64 == 0) goto ccJNz; else goto ccJNy;
       ccJNz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJNy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJNx::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.Stats.$fReadRTSStats_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.507556254 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_$creadList_closure" {
     GHC.Stats.$fReadRTSStats_$creadList_closure:
         const GHC.Stats.$fReadRTSStats_$creadList_info;
         const 0;
 },
 GHC.Stats.$fReadRTSStats_$creadList_entry() //  [R2]
         { info_tbl: [(ccJNH,
                       label: GHC.Stats.$fReadRTSStats_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJNH: // global
           R3 = R2;
           R2 = GHC.Stats.$fReadRTSStats3_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.508351139 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_closure" {
     GHC.Stats.$fReadRTSStats_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Stats.$fReadRTSStats_$creadsPrec_closure+1;
         const GHC.Stats.$fReadRTSStats_$creadList_closure+1;
         const GHC.Stats.$fReadRTSStats1_closure+2;
         const GHC.Stats.$fReadRTSStats_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.509299819 UTC

[section ""data" . GHC.Stats.gcdetails_elapsed_ns_closure" {
     GHC.Stats.gcdetails_elapsed_ns_closure:
         const GHC.Stats.gcdetails_elapsed_ns_info;
 },
 GHC.Stats.gcdetails_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccJNR,
                       label: GHC.Stats.gcdetails_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJNR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJNS; else goto ccJNT;
       ccJNS: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJNT: // global
           I64[Sp - 8] = block_ccJNO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJNX; else goto ccJNP;
       ucJNX: // global
           call _ccJNO(R1) args: 0, res: 0, upd: 0;
       ccJNP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJNO() //  [R1]
         { info_tbl: [(ccJNO,
                       label: block_ccJNO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJNO: // global
           R1 = P64[R1 + 111] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.510535482 UTC

[section ""data" . GHC.Stats.gcdetails_cpu_ns_closure" {
     GHC.Stats.gcdetails_cpu_ns_closure:
         const GHC.Stats.gcdetails_cpu_ns_info;
 },
 GHC.Stats.gcdetails_cpu_ns_entry() //  [R2]
         { info_tbl: [(ccJO5,
                       label: GHC.Stats.gcdetails_cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJO5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJO6; else goto ccJO7;
       ccJO6: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJO7: // global
           I64[Sp - 8] = block_ccJO2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJOb; else goto ccJO3;
       ucJOb: // global
           call _ccJO2(R1) args: 0, res: 0, upd: 0;
       ccJO3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJO2() //  [R1]
         { info_tbl: [(ccJO2,
                       label: block_ccJO2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJO2: // global
           R1 = P64[R1 + 103] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.511805504 UTC

[section ""data" . GHC.Stats.gcdetails_sync_elapsed_ns_closure" {
     GHC.Stats.gcdetails_sync_elapsed_ns_closure:
         const GHC.Stats.gcdetails_sync_elapsed_ns_info;
 },
 GHC.Stats.gcdetails_sync_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccJOj,
                       label: GHC.Stats.gcdetails_sync_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJOj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJOk; else goto ccJOl;
       ccJOk: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_sync_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJOl: // global
           I64[Sp - 8] = block_ccJOg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJOp; else goto ccJOh;
       ucJOp: // global
           call _ccJOg(R1) args: 0, res: 0, upd: 0;
       ccJOh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJOg() //  [R1]
         { info_tbl: [(ccJOg,
                       label: block_ccJOg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJOg: // global
           R1 = P64[R1 + 95] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.513040637 UTC

[section ""data" . GHC.Stats.gcdetails_par_balanced_copied_bytes_closure" {
     GHC.Stats.gcdetails_par_balanced_copied_bytes_closure:
         const GHC.Stats.gcdetails_par_balanced_copied_bytes_info;
 },
 GHC.Stats.gcdetails_par_balanced_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccJOx,
                       label: GHC.Stats.gcdetails_par_balanced_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJOx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJOy; else goto ccJOz;
       ccJOy: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_par_balanced_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJOz: // global
           I64[Sp - 8] = block_ccJOu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJOD; else goto ccJOv;
       ucJOD: // global
           call _ccJOu(R1) args: 0, res: 0, upd: 0;
       ccJOv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJOu() //  [R1]
         { info_tbl: [(ccJOu,
                       label: block_ccJOu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJOu: // global
           R1 = P64[R1 + 87] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.514395038 UTC

[section ""data" . GHC.Stats.gcdetails_par_max_copied_bytes_closure" {
     GHC.Stats.gcdetails_par_max_copied_bytes_closure:
         const GHC.Stats.gcdetails_par_max_copied_bytes_info;
 },
 GHC.Stats.gcdetails_par_max_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccJOL,
                       label: GHC.Stats.gcdetails_par_max_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJOL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJOM; else goto ccJON;
       ccJOM: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_par_max_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJON: // global
           I64[Sp - 8] = block_ccJOI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJOR; else goto ccJOJ;
       ucJOR: // global
           call _ccJOI(R1) args: 0, res: 0, upd: 0;
       ccJOJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJOI() //  [R1]
         { info_tbl: [(ccJOI,
                       label: block_ccJOI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJOI: // global
           R1 = P64[R1 + 79] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.515705888 UTC

[section ""data" . GHC.Stats.gcdetails_copied_bytes_closure" {
     GHC.Stats.gcdetails_copied_bytes_closure:
         const GHC.Stats.gcdetails_copied_bytes_info;
 },
 GHC.Stats.gcdetails_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccJOZ,
                       label: GHC.Stats.gcdetails_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJOZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJP0; else goto ccJP1;
       ccJP0: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJP1: // global
           I64[Sp - 8] = block_ccJOW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJP5; else goto ccJOX;
       ucJP5: // global
           call _ccJOW(R1) args: 0, res: 0, upd: 0;
       ccJOX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJOW() //  [R1]
         { info_tbl: [(ccJOW,
                       label: block_ccJOW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJOW: // global
           R1 = P64[R1 + 71] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.516974294 UTC

[section ""data" . GHC.Stats.gcdetails_mem_in_use_bytes_closure" {
     GHC.Stats.gcdetails_mem_in_use_bytes_closure:
         const GHC.Stats.gcdetails_mem_in_use_bytes_info;
 },
 GHC.Stats.gcdetails_mem_in_use_bytes_entry() //  [R2]
         { info_tbl: [(ccJPd,
                       label: GHC.Stats.gcdetails_mem_in_use_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJPd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJPe; else goto ccJPf;
       ccJPe: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_mem_in_use_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJPf: // global
           I64[Sp - 8] = block_ccJPa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJPj; else goto ccJPb;
       ucJPj: // global
           call _ccJPa(R1) args: 0, res: 0, upd: 0;
       ccJPb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJPa() //  [R1]
         { info_tbl: [(ccJPa,
                       label: block_ccJPa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJPa: // global
           R1 = P64[R1 + 63] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.519769806 UTC

[section ""data" . GHC.Stats.gcdetails_slop_bytes_closure" {
     GHC.Stats.gcdetails_slop_bytes_closure:
         const GHC.Stats.gcdetails_slop_bytes_info;
 },
 GHC.Stats.gcdetails_slop_bytes_entry() //  [R2]
         { info_tbl: [(ccJPr,
                       label: GHC.Stats.gcdetails_slop_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJPr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJPs; else goto ccJPt;
       ccJPs: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_slop_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJPt: // global
           I64[Sp - 8] = block_ccJPo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJPx; else goto ccJPp;
       ucJPx: // global
           call _ccJPo(R1) args: 0, res: 0, upd: 0;
       ccJPp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJPo() //  [R1]
         { info_tbl: [(ccJPo,
                       label: block_ccJPo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJPo: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.521018536 UTC

[section ""data" . GHC.Stats.gcdetails_compact_bytes_closure" {
     GHC.Stats.gcdetails_compact_bytes_closure:
         const GHC.Stats.gcdetails_compact_bytes_info;
 },
 GHC.Stats.gcdetails_compact_bytes_entry() //  [R2]
         { info_tbl: [(ccJPF,
                       label: GHC.Stats.gcdetails_compact_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJPF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJPG; else goto ccJPH;
       ccJPG: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_compact_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJPH: // global
           I64[Sp - 8] = block_ccJPC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJPL; else goto ccJPD;
       ucJPL: // global
           call _ccJPC(R1) args: 0, res: 0, upd: 0;
       ccJPD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJPC() //  [R1]
         { info_tbl: [(ccJPC,
                       label: block_ccJPC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJPC: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.522238401 UTC

[section ""data" . GHC.Stats.gcdetails_large_objects_bytes_closure" {
     GHC.Stats.gcdetails_large_objects_bytes_closure:
         const GHC.Stats.gcdetails_large_objects_bytes_info;
 },
 GHC.Stats.gcdetails_large_objects_bytes_entry() //  [R2]
         { info_tbl: [(ccJPT,
                       label: GHC.Stats.gcdetails_large_objects_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJPT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJPU; else goto ccJPV;
       ccJPU: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_large_objects_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJPV: // global
           I64[Sp - 8] = block_ccJPQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJPZ; else goto ccJPR;
       ucJPZ: // global
           call _ccJPQ(R1) args: 0, res: 0, upd: 0;
       ccJPR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJPQ() //  [R1]
         { info_tbl: [(ccJPQ,
                       label: block_ccJPQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJPQ: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.523469157 UTC

[section ""data" . GHC.Stats.gcdetails_live_bytes_closure" {
     GHC.Stats.gcdetails_live_bytes_closure:
         const GHC.Stats.gcdetails_live_bytes_info;
 },
 GHC.Stats.gcdetails_live_bytes_entry() //  [R2]
         { info_tbl: [(ccJQ7,
                       label: GHC.Stats.gcdetails_live_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJQ7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJQ8; else goto ccJQ9;
       ccJQ8: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_live_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJQ9: // global
           I64[Sp - 8] = block_ccJQ4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJQd; else goto ccJQ5;
       ucJQd: // global
           call _ccJQ4(R1) args: 0, res: 0, upd: 0;
       ccJQ5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJQ4() //  [R1]
         { info_tbl: [(ccJQ4,
                       label: block_ccJQ4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJQ4: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.524675421 UTC

[section ""data" . GHC.Stats.gcdetails_allocated_bytes_closure" {
     GHC.Stats.gcdetails_allocated_bytes_closure:
         const GHC.Stats.gcdetails_allocated_bytes_info;
 },
 GHC.Stats.gcdetails_allocated_bytes_entry() //  [R2]
         { info_tbl: [(ccJQl,
                       label: GHC.Stats.gcdetails_allocated_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJQl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJQm; else goto ccJQn;
       ccJQm: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_allocated_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJQn: // global
           I64[Sp - 8] = block_ccJQi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJQr; else goto ccJQj;
       ucJQr: // global
           call _ccJQi(R1) args: 0, res: 0, upd: 0;
       ccJQj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJQi() //  [R1]
         { info_tbl: [(ccJQi,
                       label: block_ccJQi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJQi: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.525946255 UTC

[section ""data" . GHC.Stats.gcdetails_threads_closure" {
     GHC.Stats.gcdetails_threads_closure:
         const GHC.Stats.gcdetails_threads_info;
 },
 GHC.Stats.gcdetails_threads_entry() //  [R2]
         { info_tbl: [(ccJQz,
                       label: GHC.Stats.gcdetails_threads_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJQz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJQA; else goto ccJQB;
       ccJQA: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_threads_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJQB: // global
           I64[Sp - 8] = block_ccJQw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJQF; else goto ccJQx;
       ucJQF: // global
           call _ccJQw(R1) args: 0, res: 0, upd: 0;
       ccJQx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJQw() //  [R1]
         { info_tbl: [(ccJQw,
                       label: block_ccJQw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJQw: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.527124194 UTC

[section ""data" . GHC.Stats.gcdetails_gen_closure" {
     GHC.Stats.gcdetails_gen_closure:
         const GHC.Stats.gcdetails_gen_info;
 },
 GHC.Stats.gcdetails_gen_entry() //  [R2]
         { info_tbl: [(ccJQN,
                       label: GHC.Stats.gcdetails_gen_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJQN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJQO; else goto ccJQP;
       ccJQO: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_gen_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJQP: // global
           I64[Sp - 8] = block_ccJQK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJQT; else goto ccJQL;
       ucJQT: // global
           call _ccJQK(R1) args: 0, res: 0, upd: 0;
       ccJQL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJQK() //  [R1]
         { info_tbl: [(ccJQK,
                       label: block_ccJQK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJQK: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.528326823 UTC

[section ""data" . GHC.Stats.gc_closure" {
     GHC.Stats.gc_closure:
         const GHC.Stats.gc_info;
 },
 GHC.Stats.gc_entry() //  [R2]
         { info_tbl: [(ccJR1,
                       label: GHC.Stats.gc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJR1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJR2; else goto ccJR3;
       ccJR2: // global
           R2 = R2;
           R1 = GHC.Stats.gc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJR3: // global
           I64[Sp - 8] = block_ccJQY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJR7; else goto ccJQZ;
       ucJR7: // global
           call _ccJQY(R1) args: 0, res: 0, upd: 0;
       ccJQZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJQY() //  [R1]
         { info_tbl: [(ccJQY,
                       label: block_ccJQY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJQY: // global
           R1 = P64[R1 + 159] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.529542503 UTC

[section ""data" . GHC.Stats.elapsed_ns_closure" {
     GHC.Stats.elapsed_ns_closure:
         const GHC.Stats.elapsed_ns_info;
 },
 GHC.Stats.elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccJRf,
                       label: GHC.Stats.elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJRf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJRg; else goto ccJRh;
       ccJRg: // global
           R2 = R2;
           R1 = GHC.Stats.elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJRh: // global
           I64[Sp - 8] = block_ccJRc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJRl; else goto ccJRd;
       ucJRl: // global
           call _ccJRc(R1) args: 0, res: 0, upd: 0;
       ccJRd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJRc() //  [R1]
         { info_tbl: [(ccJRc,
                       label: block_ccJRc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJRc: // global
           R1 = P64[R1 + 151] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.530823474 UTC

[section ""data" . GHC.Stats.cpu_ns_closure" {
     GHC.Stats.cpu_ns_closure:
         const GHC.Stats.cpu_ns_info;
 },
 GHC.Stats.cpu_ns_entry() //  [R2]
         { info_tbl: [(ccJRt,
                       label: GHC.Stats.cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJRt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJRu; else goto ccJRv;
       ccJRu: // global
           R2 = R2;
           R1 = GHC.Stats.cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJRv: // global
           I64[Sp - 8] = block_ccJRq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJRz; else goto ccJRr;
       ucJRz: // global
           call _ccJRq(R1) args: 0, res: 0, upd: 0;
       ccJRr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJRq() //  [R1]
         { info_tbl: [(ccJRq,
                       label: block_ccJRq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJRq: // global
           R1 = P64[R1 + 143] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.532070793 UTC

[section ""data" . GHC.Stats.gc_elapsed_ns_closure" {
     GHC.Stats.gc_elapsed_ns_closure:
         const GHC.Stats.gc_elapsed_ns_info;
 },
 GHC.Stats.gc_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccJRH,
                       label: GHC.Stats.gc_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJRH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJRI; else goto ccJRJ;
       ccJRI: // global
           R2 = R2;
           R1 = GHC.Stats.gc_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJRJ: // global
           I64[Sp - 8] = block_ccJRE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJRN; else goto ccJRF;
       ucJRN: // global
           call _ccJRE(R1) args: 0, res: 0, upd: 0;
       ccJRF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJRE() //  [R1]
         { info_tbl: [(ccJRE,
                       label: block_ccJRE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJRE: // global
           R1 = P64[R1 + 135] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.533628375 UTC

[section ""data" . GHC.Stats.gc_cpu_ns_closure" {
     GHC.Stats.gc_cpu_ns_closure:
         const GHC.Stats.gc_cpu_ns_info;
 },
 GHC.Stats.gc_cpu_ns_entry() //  [R2]
         { info_tbl: [(ccJRV,
                       label: GHC.Stats.gc_cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJRV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJRW; else goto ccJRX;
       ccJRW: // global
           R2 = R2;
           R1 = GHC.Stats.gc_cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJRX: // global
           I64[Sp - 8] = block_ccJRS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJS1; else goto ccJRT;
       ucJS1: // global
           call _ccJRS(R1) args: 0, res: 0, upd: 0;
       ccJRT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJRS() //  [R1]
         { info_tbl: [(ccJRS,
                       label: block_ccJRS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJRS: // global
           R1 = P64[R1 + 127] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.534809345 UTC

[section ""data" . GHC.Stats.mutator_elapsed_ns_closure" {
     GHC.Stats.mutator_elapsed_ns_closure:
         const GHC.Stats.mutator_elapsed_ns_info;
 },
 GHC.Stats.mutator_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccJS9,
                       label: GHC.Stats.mutator_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJS9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJSa; else goto ccJSb;
       ccJSa: // global
           R2 = R2;
           R1 = GHC.Stats.mutator_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJSb: // global
           I64[Sp - 8] = block_ccJS6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJSf; else goto ccJS7;
       ucJSf: // global
           call _ccJS6(R1) args: 0, res: 0, upd: 0;
       ccJS7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJS6() //  [R1]
         { info_tbl: [(ccJS6,
                       label: block_ccJS6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJS6: // global
           R1 = P64[R1 + 119] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.53605978 UTC

[section ""data" . GHC.Stats.mutator_cpu_ns_closure" {
     GHC.Stats.mutator_cpu_ns_closure:
         const GHC.Stats.mutator_cpu_ns_info;
 },
 GHC.Stats.mutator_cpu_ns_entry() //  [R2]
         { info_tbl: [(ccJSn,
                       label: GHC.Stats.mutator_cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJSn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJSo; else goto ccJSp;
       ccJSo: // global
           R2 = R2;
           R1 = GHC.Stats.mutator_cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJSp: // global
           I64[Sp - 8] = block_ccJSk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJSt; else goto ccJSl;
       ucJSt: // global
           call _ccJSk(R1) args: 0, res: 0, upd: 0;
       ccJSl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJSk() //  [R1]
         { info_tbl: [(ccJSk,
                       label: block_ccJSk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJSk: // global
           R1 = P64[R1 + 111] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.537315107 UTC

[section ""data" . GHC.Stats.cumulative_par_balanced_copied_bytes_closure" {
     GHC.Stats.cumulative_par_balanced_copied_bytes_closure:
         const GHC.Stats.cumulative_par_balanced_copied_bytes_info;
 },
 GHC.Stats.cumulative_par_balanced_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccJSB,
                       label: GHC.Stats.cumulative_par_balanced_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJSB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJSC; else goto ccJSD;
       ccJSC: // global
           R2 = R2;
           R1 = GHC.Stats.cumulative_par_balanced_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJSD: // global
           I64[Sp - 8] = block_ccJSy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJSH; else goto ccJSz;
       ucJSH: // global
           call _ccJSy(R1) args: 0, res: 0, upd: 0;
       ccJSz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJSy() //  [R1]
         { info_tbl: [(ccJSy,
                       label: block_ccJSy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJSy: // global
           R1 = P64[R1 + 103] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.538515337 UTC

[section ""data" . GHC.Stats.cumulative_par_max_copied_bytes_closure" {
     GHC.Stats.cumulative_par_max_copied_bytes_closure:
         const GHC.Stats.cumulative_par_max_copied_bytes_info;
 },
 GHC.Stats.cumulative_par_max_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccJSP,
                       label: GHC.Stats.cumulative_par_max_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJSP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJSQ; else goto ccJSR;
       ccJSQ: // global
           R2 = R2;
           R1 = GHC.Stats.cumulative_par_max_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJSR: // global
           I64[Sp - 8] = block_ccJSM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJSV; else goto ccJSN;
       ucJSV: // global
           call _ccJSM(R1) args: 0, res: 0, upd: 0;
       ccJSN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJSM() //  [R1]
         { info_tbl: [(ccJSM,
                       label: block_ccJSM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJSM: // global
           R1 = P64[R1 + 95] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.539735045 UTC

[section ""data" . GHC.Stats.par_copied_bytes_closure" {
     GHC.Stats.par_copied_bytes_closure:
         const GHC.Stats.par_copied_bytes_info;
 },
 GHC.Stats.par_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccJT3,
                       label: GHC.Stats.par_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJT3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJT4; else goto ccJT5;
       ccJT4: // global
           R2 = R2;
           R1 = GHC.Stats.par_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJT5: // global
           I64[Sp - 8] = block_ccJT0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJT9; else goto ccJT1;
       ucJT9: // global
           call _ccJT0(R1) args: 0, res: 0, upd: 0;
       ccJT1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJT0() //  [R1]
         { info_tbl: [(ccJT0,
                       label: block_ccJT0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJT0: // global
           R1 = P64[R1 + 87] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.540952117 UTC

[section ""data" . GHC.Stats.copied_bytes_closure" {
     GHC.Stats.copied_bytes_closure:
         const GHC.Stats.copied_bytes_info;
 },
 GHC.Stats.copied_bytes_entry() //  [R2]
         { info_tbl: [(ccJTh,
                       label: GHC.Stats.copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJTh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJTi; else goto ccJTj;
       ccJTi: // global
           R2 = R2;
           R1 = GHC.Stats.copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJTj: // global
           I64[Sp - 8] = block_ccJTe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJTn; else goto ccJTf;
       ucJTn: // global
           call _ccJTe(R1) args: 0, res: 0, upd: 0;
       ccJTf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJTe() //  [R1]
         { info_tbl: [(ccJTe,
                       label: block_ccJTe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJTe: // global
           R1 = P64[R1 + 79] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.542233646 UTC

[section ""data" . GHC.Stats.cumulative_live_bytes_closure" {
     GHC.Stats.cumulative_live_bytes_closure:
         const GHC.Stats.cumulative_live_bytes_info;
 },
 GHC.Stats.cumulative_live_bytes_entry() //  [R2]
         { info_tbl: [(ccJTv,
                       label: GHC.Stats.cumulative_live_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJTv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJTw; else goto ccJTx;
       ccJTw: // global
           R2 = R2;
           R1 = GHC.Stats.cumulative_live_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJTx: // global
           I64[Sp - 8] = block_ccJTs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJTB; else goto ccJTt;
       ucJTB: // global
           call _ccJTs(R1) args: 0, res: 0, upd: 0;
       ccJTt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJTs() //  [R1]
         { info_tbl: [(ccJTs,
                       label: block_ccJTs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJTs: // global
           R1 = P64[R1 + 71] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.543453471 UTC

[section ""data" . GHC.Stats.max_mem_in_use_bytes_closure" {
     GHC.Stats.max_mem_in_use_bytes_closure:
         const GHC.Stats.max_mem_in_use_bytes_info;
 },
 GHC.Stats.max_mem_in_use_bytes_entry() //  [R2]
         { info_tbl: [(ccJTJ,
                       label: GHC.Stats.max_mem_in_use_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJTJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJTK; else goto ccJTL;
       ccJTK: // global
           R2 = R2;
           R1 = GHC.Stats.max_mem_in_use_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJTL: // global
           I64[Sp - 8] = block_ccJTG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJTP; else goto ccJTH;
       ucJTP: // global
           call _ccJTG(R1) args: 0, res: 0, upd: 0;
       ccJTH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJTG() //  [R1]
         { info_tbl: [(ccJTG,
                       label: block_ccJTG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJTG: // global
           R1 = P64[R1 + 63] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.544692338 UTC

[section ""data" . GHC.Stats.max_slop_bytes_closure" {
     GHC.Stats.max_slop_bytes_closure:
         const GHC.Stats.max_slop_bytes_info;
 },
 GHC.Stats.max_slop_bytes_entry() //  [R2]
         { info_tbl: [(ccJTX,
                       label: GHC.Stats.max_slop_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJTX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJTY; else goto ccJTZ;
       ccJTY: // global
           R2 = R2;
           R1 = GHC.Stats.max_slop_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJTZ: // global
           I64[Sp - 8] = block_ccJTU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJU3; else goto ccJTV;
       ucJU3: // global
           call _ccJTU(R1) args: 0, res: 0, upd: 0;
       ccJTV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJTU() //  [R1]
         { info_tbl: [(ccJTU,
                       label: block_ccJTU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJTU: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.546254796 UTC

[section ""data" . GHC.Stats.max_compact_bytes_closure" {
     GHC.Stats.max_compact_bytes_closure:
         const GHC.Stats.max_compact_bytes_info;
 },
 GHC.Stats.max_compact_bytes_entry() //  [R2]
         { info_tbl: [(ccJUb,
                       label: GHC.Stats.max_compact_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJUb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJUc; else goto ccJUd;
       ccJUc: // global
           R2 = R2;
           R1 = GHC.Stats.max_compact_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJUd: // global
           I64[Sp - 8] = block_ccJU8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJUh; else goto ccJU9;
       ucJUh: // global
           call _ccJU8(R1) args: 0, res: 0, upd: 0;
       ccJU9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJU8() //  [R1]
         { info_tbl: [(ccJU8,
                       label: block_ccJU8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJU8: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.547507739 UTC

[section ""data" . GHC.Stats.max_large_objects_bytes_closure" {
     GHC.Stats.max_large_objects_bytes_closure:
         const GHC.Stats.max_large_objects_bytes_info;
 },
 GHC.Stats.max_large_objects_bytes_entry() //  [R2]
         { info_tbl: [(ccJUp,
                       label: GHC.Stats.max_large_objects_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJUp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJUq; else goto ccJUr;
       ccJUq: // global
           R2 = R2;
           R1 = GHC.Stats.max_large_objects_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJUr: // global
           I64[Sp - 8] = block_ccJUm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJUv; else goto ccJUn;
       ucJUv: // global
           call _ccJUm(R1) args: 0, res: 0, upd: 0;
       ccJUn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJUm() //  [R1]
         { info_tbl: [(ccJUm,
                       label: block_ccJUm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJUm: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.548823625 UTC

[section ""data" . GHC.Stats.max_live_bytes_closure" {
     GHC.Stats.max_live_bytes_closure:
         const GHC.Stats.max_live_bytes_info;
 },
 GHC.Stats.max_live_bytes_entry() //  [R2]
         { info_tbl: [(ccJUD,
                       label: GHC.Stats.max_live_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJUD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJUE; else goto ccJUF;
       ccJUE: // global
           R2 = R2;
           R1 = GHC.Stats.max_live_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJUF: // global
           I64[Sp - 8] = block_ccJUA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJUJ; else goto ccJUB;
       ucJUJ: // global
           call _ccJUA(R1) args: 0, res: 0, upd: 0;
       ccJUB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJUA() //  [R1]
         { info_tbl: [(ccJUA,
                       label: block_ccJUA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJUA: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.550168577 UTC

[section ""data" . GHC.Stats.allocated_bytes_closure" {
     GHC.Stats.allocated_bytes_closure:
         const GHC.Stats.allocated_bytes_info;
 },
 GHC.Stats.allocated_bytes_entry() //  [R2]
         { info_tbl: [(ccJUR,
                       label: GHC.Stats.allocated_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJUR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJUS; else goto ccJUT;
       ccJUS: // global
           R2 = R2;
           R1 = GHC.Stats.allocated_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJUT: // global
           I64[Sp - 8] = block_ccJUO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJUX; else goto ccJUP;
       ucJUX: // global
           call _ccJUO(R1) args: 0, res: 0, upd: 0;
       ccJUP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJUO() //  [R1]
         { info_tbl: [(ccJUO,
                       label: block_ccJUO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJUO: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.5514755 UTC

[section ""data" . GHC.Stats.major_gcs_closure" {
     GHC.Stats.major_gcs_closure:
         const GHC.Stats.major_gcs_info;
 },
 GHC.Stats.major_gcs_entry() //  [R2]
         { info_tbl: [(ccJV5,
                       label: GHC.Stats.major_gcs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJV5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJV6; else goto ccJV7;
       ccJV6: // global
           R2 = R2;
           R1 = GHC.Stats.major_gcs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJV7: // global
           I64[Sp - 8] = block_ccJV2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJVb; else goto ccJV3;
       ucJVb: // global
           call _ccJV2(R1) args: 0, res: 0, upd: 0;
       ccJV3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJV2() //  [R1]
         { info_tbl: [(ccJV2,
                       label: block_ccJV2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJV2: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.55391389 UTC

[section ""data" . GHC.Stats.gcs_closure" {
     GHC.Stats.gcs_closure:
         const GHC.Stats.gcs_info;
 },
 GHC.Stats.gcs_entry() //  [R2]
         { info_tbl: [(ccJVj,
                       label: GHC.Stats.gcs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJVj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJVk; else goto ccJVl;
       ccJVk: // global
           R2 = R2;
           R1 = GHC.Stats.gcs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccJVl: // global
           I64[Sp - 8] = block_ccJVg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucJVp; else goto ccJVh;
       ucJVp: // global
           call _ccJVg(R1) args: 0, res: 0, upd: 0;
       ccJVh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJVg() //  [R1]
         { info_tbl: [(ccJVg,
                       label: block_ccJVg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJVg: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.55489617 UTC

[section ""cstring" . GHC.Stats.$trModule4_bytes" {
     GHC.Stats.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.555473105 UTC

[section ""data" . GHC.Stats.$trModule3_closure" {
     GHC.Stats.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.55604309 UTC

[section ""cstring" . GHC.Stats.$trModule2_bytes" {
     GHC.Stats.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.556609778 UTC

[section ""data" . GHC.Stats.$trModule1_closure" {
     GHC.Stats.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.557228601 UTC

[section ""data" . GHC.Stats.$trModule_closure" {
     GHC.Stats.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Stats.$trModule3_closure+1;
         const GHC.Stats.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.557902252 UTC

[section ""data" . $krep_rcHrw_closure" {
     $krep_rcHrw_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt64_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.558521001 UTC

[section ""data" . $krep1_rcHrx_closure" {
     $krep1_rcHrx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.55915602 UTC

[section ""data" . $krep2_rcHry_closure" {
     $krep2_rcHry_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord32_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.559721374 UTC

[section ""data" . GHC.Stats.$tcGCDetails1_closure" {
     GHC.Stats.$tcGCDetails1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tcGCDetails2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.560348881 UTC

[section ""data" . GHC.Stats.$tcGCDetails_closure" {
     GHC.Stats.$tcGCDetails_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tcGCDetails1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1853976479346877039;
         const 12435514499433877542;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.561008732 UTC

[section ""data" . $krep3_rcHrz_closure" {
     $krep3_rcHrz_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Stats.$tcGCDetails_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.561649837 UTC

[section ""data" . $krep4_rcHrA_closure" {
     $krep4_rcHrA_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep3_rcHrz_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.562282675 UTC

[section ""data" . $krep5_rcHrB_closure" {
     $krep5_rcHrB_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep4_rcHrA_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.562870476 UTC

[section ""data" . $krep6_rcHrC_closure" {
     $krep6_rcHrC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep5_rcHrB_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.563488053 UTC

[section ""data" . $krep7_rcHrD_closure" {
     $krep7_rcHrD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep6_rcHrC_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.564081123 UTC

[section ""data" . $krep8_rcHrE_closure" {
     $krep8_rcHrE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep7_rcHrD_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.564707894 UTC

[section ""data" . $krep9_rcHrF_closure" {
     $krep9_rcHrF_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep8_rcHrE_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.565530311 UTC

[section ""data" . $krep10_rcHrG_closure" {
     $krep10_rcHrG_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep9_rcHrF_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.566163194 UTC

[section ""data" . $krep11_rcHrH_closure" {
     $krep11_rcHrH_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep10_rcHrG_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.566820032 UTC

[section ""data" . $krep12_rcHrI_closure" {
     $krep12_rcHrI_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep11_rcHrH_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.567440566 UTC

[section ""data" . $krep13_rcHrJ_closure" {
     $krep13_rcHrJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep12_rcHrI_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.56807357 UTC

[section ""data" . $krep14_rcHrK_closure" {
     $krep14_rcHrK_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep13_rcHrJ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.568701679 UTC

[section ""data" . $krep15_rcHrL_closure" {
     $krep15_rcHrL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep14_rcHrK_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.569379325 UTC

[section ""data" . $krep16_rcHrM_closure" {
     $krep16_rcHrM_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep15_rcHrL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.569955395 UTC

[section ""data" . GHC.Stats.$tc'GCDetails1_closure" {
     GHC.Stats.$tc'GCDetails1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep16_rcHrM_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.570562634 UTC

[section ""cstring" . GHC.Stats.$tc'GCDetails3_bytes" {
     GHC.Stats.$tc'GCDetails3_bytes:
         I8[] [39,71,67,68,101,116,97,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.571167255 UTC

[section ""data" . GHC.Stats.$tc'GCDetails2_closure" {
     GHC.Stats.$tc'GCDetails2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tc'GCDetails3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.571789233 UTC

[section ""data" . GHC.Stats.$tc'GCDetails_closure" {
     GHC.Stats.$tc'GCDetails_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tc'GCDetails2_closure+1;
         const GHC.Stats.$tc'GCDetails1_closure+4;
         const 5964953867232766897;
         const 8889994537819840032;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.572438662 UTC

[section ""data" . GHC.Stats.$tcRTSStats1_closure" {
     GHC.Stats.$tcRTSStats1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tcRTSStats2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.57303278 UTC

[section ""data" . GHC.Stats.$tcRTSStats_closure" {
     GHC.Stats.$tcRTSStats_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tcRTSStats1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1006825398788898151;
         const 9122067856566178937;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.573676283 UTC

[section ""data" . $krep17_rcHrN_closure" {
     $krep17_rcHrN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Stats.$tcRTSStats_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.574314689 UTC

[section ""data" . $krep18_rcHrO_closure" {
     $krep18_rcHrO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rcHrz_closure+1;
         const $krep17_rcHrN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.574969197 UTC

[section ""data" . $krep19_rcHrP_closure" {
     $krep19_rcHrP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep18_rcHrO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.575680558 UTC

[section ""data" . $krep20_rcHrQ_closure" {
     $krep20_rcHrQ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep19_rcHrP_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.57631821 UTC

[section ""data" . $krep21_rcHrR_closure" {
     $krep21_rcHrR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep20_rcHrQ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.576988777 UTC

[section ""data" . $krep22_rcHrS_closure" {
     $krep22_rcHrS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep21_rcHrR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.577697631 UTC

[section ""data" . $krep23_rcHrT_closure" {
     $krep23_rcHrT_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep22_rcHrS_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.578332625 UTC

[section ""data" . $krep24_rcHrU_closure" {
     $krep24_rcHrU_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep23_rcHrT_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.578972258 UTC

[section ""data" . $krep25_rcHrV_closure" {
     $krep25_rcHrV_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep24_rcHrU_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.579610845 UTC

[section ""data" . $krep26_rcHrW_closure" {
     $krep26_rcHrW_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep25_rcHrV_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.58111235 UTC

[section ""data" . $krep27_rcHrX_closure" {
     $krep27_rcHrX_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep26_rcHrW_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.581755462 UTC

[section ""data" . $krep28_rcHrY_closure" {
     $krep28_rcHrY_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep27_rcHrX_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.582357645 UTC

[section ""data" . $krep29_rcHrZ_closure" {
     $krep29_rcHrZ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep28_rcHrY_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.582971483 UTC

[section ""data" . $krep30_rcHs0_closure" {
     $krep30_rcHs0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep29_rcHrZ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.583604472 UTC

[section ""data" . $krep31_rcHs1_closure" {
     $krep31_rcHs1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep30_rcHs0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.584197737 UTC

[section ""data" . $krep32_rcHs2_closure" {
     $krep32_rcHs2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep31_rcHs1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.584816081 UTC

[section ""data" . $krep33_rcHs3_closure" {
     $krep33_rcHs3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep32_rcHs2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.585513439 UTC

[section ""data" . $krep34_rcHs4_closure" {
     $krep34_rcHs4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep33_rcHs3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.586176928 UTC

[section ""data" . $krep35_rcHs5_closure" {
     $krep35_rcHs5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep34_rcHs4_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.586745384 UTC

[section ""data" . $krep36_rcHs6_closure" {
     $krep36_rcHs6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep35_rcHs5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.587380953 UTC

[section ""data" . GHC.Stats.$tc'RTSStats1_closure" {
     GHC.Stats.$tc'RTSStats1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep36_rcHs6_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.587955137 UTC

[section ""cstring" . GHC.Stats.$tc'RTSStats3_bytes" {
     GHC.Stats.$tc'RTSStats3_bytes:
         I8[] [39,82,84,83,83,116,97,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.588555043 UTC

[section ""data" . GHC.Stats.$tc'RTSStats2_closure" {
     GHC.Stats.$tc'RTSStats2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tc'RTSStats3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.589165653 UTC

[section ""data" . GHC.Stats.$tc'RTSStats_closure" {
     GHC.Stats.$tc'RTSStats_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tc'RTSStats2_closure+1;
         const GHC.Stats.$tc'RTSStats1_closure+4;
         const 10718900236833312508;
         const 16334729378492634062;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.590486649 UTC

[section ""data" . getRTSStatsEnabled1_rcHs7_closure" {
     getRTSStatsEnabled1_rcHs7_closure:
         const getRTSStatsEnabled1_rcHs7_info;
 },
 sat_scHNr_entry() //  [R1]
         { info_tbl: [(ccJVF,
                       label: sat_scHNr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJVF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJVG; else goto ccJVH;
       ccJVG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJVH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto ccJVE; else goto ccJVD;
       ccJVE: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccJVD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 getRTSStatsEnabled1_rcHs7_entry() //  []
         { info_tbl: [(ccJVI,
                       label: getRTSStatsEnabled1_rcHs7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJVI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccJVJ; else goto ccJVK;
       ccJVJ: // global
           R1 = getRTSStatsEnabled1_rcHs7_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccJVK: // global
           I64[Sp - 8] = block_ccJVv_info;
           Sp = Sp - 8;
           _ucJVQ::P64 = CurrentTSO;
           I64[I64[_ucJVQ::P64 + 24] + 16] = Sp;
           _ucJVR::I64 = CurrentNursery;
           P64[_ucJVR::I64 + 8] = Hp + 8;
           I64[_ucJVQ::P64 + 104] = I64[_ucJVQ::P64 + 104] - ((Hp + 8) - I64[_ucJVR::I64]);
           (_ucJVO::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_scHNp::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] getRTSStatsEnabled();
           (_ucJVP::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ucJVO::I64);
           BaseReg = _ucJVP::I64;
           _ucJVS::P64 = CurrentTSO;
           _ucJVT::P64 = I64[_ucJVS::P64 + 24];
           Sp = I64[_ucJVT::P64 + 16];
           SpLim = _ucJVT::P64 + 192;
           HpAlloc = 0;
           _ucJVU::I64 = CurrentNursery;
           _ucJVV::I64 = I64[_ucJVU::I64 + 8];
           Hp = _ucJVV::I64 - 8;
           _ucJVW::I64 = I64[_ucJVU::I64];
           HpLim = _ucJVW::I64 + ((%MO_SS_Conv_W32_W64(I32[_ucJVU::I64 + 48]) << 12) - 1);
           I64[_ucJVS::P64 + 104] = I64[_ucJVS::P64 + 104] + (_ucJVV::I64 - _ucJVW::I64);
           R1 = _scHNp::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJVv() //  [R1]
         { info_tbl: [(ccJVv,
                       label: block_ccJVv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJVv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccJVN; else goto ccJVM;
       ccJVN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccJVM: // global
           I64[Hp - 16] = sat_scHNr_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.592346423 UTC

[section ""data" . GHC.Stats.getRTSStatsEnabled_closure" {
     GHC.Stats.getRTSStatsEnabled_closure:
         const GHC.Stats.getRTSStatsEnabled_info;
 },
 GHC.Stats.getRTSStatsEnabled_entry() //  []
         { info_tbl: [(ccJW2,
                       label: GHC.Stats.getRTSStatsEnabled_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJW2: // global
           call getRTSStatsEnabled1_rcHs7_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.593085013 UTC

[section ""cstring" . GHC.Stats.getRTSStats5_bytes" {
     GHC.Stats.getRTSStats5_bytes:
         I8[] [71,72,67,46,83,116,97,116,115,46,103,101,116,82,84,83,83,116,97,116,115,58,32,71,67,32,115,116,97,116,115,32,110,111,116,32,101,110,97,98,108,101,100,46,32,85,115,101,32,96,43,82,84,83,32,45,84,32,45,82,84,83,39,32,116,111,32,101,110,97,98,108,101,32,116,104,101,109,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.593901293 UTC

[section ""data" . GHC.Stats.getRTSStats4_closure" {
     GHC.Stats.getRTSStats4_closure:
         const GHC.Stats.getRTSStats4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.getRTSStats4_entry() //  [R1]
         { info_tbl: [(ccJWb,
                       label: GHC.Stats.getRTSStats4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJWb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJWc; else goto ccJWd;
       ccJWc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJWd: // global
           (_ccJW8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJW8::I64 == 0) goto ccJWa; else goto ccJW9;
       ccJWa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJW9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJW8::I64;
           R2 = GHC.Stats.getRTSStats5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.594886168 UTC

[section ""data" . GHC.Stats.getRTSStats3_closure" {
     GHC.Stats.getRTSStats3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UnsupportedOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Stats.getRTSStats4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.595703444 UTC

[section ""data" . GHC.Stats.getRTSStats2_closure" {
     GHC.Stats.getRTSStats2_closure:
         const GHC.Stats.getRTSStats2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.getRTSStats2_entry() //  [R1]
         { info_tbl: [(ccJWk,
                       label: GHC.Stats.getRTSStats2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJWk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccJWl; else goto ccJWm;
       ccJWl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccJWm: // global
           (_ccJWh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccJWh::I64 == 0) goto ccJWj; else goto ccJWi;
       ccJWj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccJWi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccJWh::I64;
           R2 = GHC.Stats.getRTSStats3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.598927032 UTC

[section ""data" . GHC.Stats.getRTSStats1_closure" {
     GHC.Stats.getRTSStats1_closure:
         const GHC.Stats.getRTSStats1_info;
         const 0;
 },
 GHC.Stats.getRTSStats1_entry() //  []
         { info_tbl: [(ccJWy,
                       label: GHC.Stats.getRTSStats1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJWy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccJWz; else goto ccJWA;
       ccJWz: // global
           R1 = GHC.Stats.getRTSStats1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccJWA: // global
           I64[Sp - 8] = block_ccJWs_info;
           Sp = Sp - 8;
           _ucJZ0::P64 = CurrentTSO;
           I64[I64[_ucJZ0::P64 + 24] + 16] = Sp;
           _ucJZ1::I64 = CurrentNursery;
           P64[_ucJZ1::I64 + 8] = Hp + 8;
           I64[_ucJZ0::P64 + 104] = I64[_ucJZ0::P64 + 104] - ((Hp + 8) - I64[_ucJZ1::I64]);
           (_ucJYY::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_scHNw::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] getRTSStatsEnabled();
           (_ucJYZ::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ucJYY::I64);
           BaseReg = _ucJYZ::I64;
           _ucJZ2::P64 = CurrentTSO;
           _ucJZ3::P64 = I64[_ucJZ2::P64 + 24];
           Sp = I64[_ucJZ3::P64 + 16];
           SpLim = _ucJZ3::P64 + 192;
           HpAlloc = 0;
           _ucJZ4::I64 = CurrentNursery;
           _ucJZ5::I64 = I64[_ucJZ4::I64 + 8];
           Hp = _ucJZ5::I64 - 8;
           _ucJZ6::I64 = I64[_ucJZ4::I64];
           HpLim = _ucJZ6::I64 + ((%MO_SS_Conv_W32_W64(I32[_ucJZ4::I64 + 48]) << 12) - 1);
           I64[_ucJZ2::P64 + 104] = I64[_ucJZ2::P64 + 104] + (_ucJZ5::I64 - _ucJZ6::I64);
           R1 = _scHNw::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJWs() //  [R1]
         { info_tbl: [(ccJWs,
                       label: block_ccJWs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJWs: // global
           if (R1 == 0) goto ccJWx; else goto ccJWw;
       ccJWx: // global
           R1 = GHC.Stats.getRTSStats2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ccJWw: // global
           I64[Sp] = block_ccJWD_info;
           R1 = 248;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccJWD() //  [R1]
         { info_tbl: [(ccJWD,
                       label: block_ccJWD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJWD: // global
           I64[Sp - 16] = block_ccJWK_info;
           _scHNE::I64 = R1 + 16;
           I64[Sp - 8] = _scHNE::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           _ucJZa::P64 = CurrentTSO;
           I64[I64[_ucJZa::P64 + 24] + 16] = Sp;
           _ucJZb::I64 = CurrentNursery;
           P64[_ucJZb::I64 + 8] = Hp + 8;
           I64[_ucJZa::P64 + 104] = I64[_ucJZa::P64 + 104] - ((Hp + 8) - I64[_ucJZb::I64]);
           (_ucJZ8::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] getRTSStats(_scHNE::I64);
           (_ucJZ9::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ucJZ8::I64);
           BaseReg = _ucJZ9::I64;
           _ucJZc::P64 = CurrentTSO;
           _ucJZd::P64 = I64[_ucJZc::P64 + 24];
           Sp = I64[_ucJZd::P64 + 16];
           SpLim = _ucJZd::P64 + 192;
           HpAlloc = 0;
           _ucJZe::I64 = CurrentNursery;
           _ucJZf::I64 = I64[_ucJZe::I64 + 8];
           Hp = _ucJZf::I64 - 8;
           _ucJZg::I64 = I64[_ucJZe::I64];
           HpLim = _ucJZg::I64 + ((%MO_SS_Conv_W32_W64(I32[_ucJZe::I64 + 48]) << 12) - 1);
           I64[_ucJZc::P64 + 104] = I64[_ucJZc::P64 + 104] + (_ucJZf::I64 - _ucJZg::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _ccJWK() //  []
         { info_tbl: [(ccJWK,
                       label: block_ccJWK_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJWK: // global
           Hp = Hp + 816;
           if (Hp > HpLim) (likely: False) goto ccJYX; else goto ccJYW;
       ccJYX: // global
           HpAlloc = 816;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccJYW: // global
           _scHNE::I64 = I64[Sp + 8];
           _scHNK::I64 = %MO_UU_Conv_W32_W64(I32[_scHNE::I64]);
           _scHNO::I64 = %MO_UU_Conv_W32_W64(I32[_scHNE::I64 + 4]);
           _scHNS::I64 = I64[_scHNE::I64 + 8];
           _scHNW::I64 = I64[_scHNE::I64 + 16];
           _scHO0::I64 = I64[_scHNE::I64 + 24];
           _scHO4::I64 = I64[_scHNE::I64 + 32];
           _scHO8::I64 = I64[_scHNE::I64 + 40];
           _scHOc::I64 = I64[_scHNE::I64 + 48];
           _scHOg::I64 = I64[_scHNE::I64 + 56];
           _scHOk::I64 = I64[_scHNE::I64 + 64];
           _scHOo::I64 = I64[_scHNE::I64 + 72];
           _scHOs::I64 = I64[_scHNE::I64 + 80];
           _scHOw::I64 = I64[_scHNE::I64 + 88];
           _scHOA::I64 = I64[_scHNE::I64 + 96];
           _scHOE::I64 = I64[_scHNE::I64 + 104];
           _scHOI::I64 = I64[_scHNE::I64 + 112];
           _scHOM::I64 = I64[_scHNE::I64 + 120];
           _scHOQ::I64 = I64[_scHNE::I64 + 128];
           _scHOU::I64 = I64[_scHNE::I64 + 136];
           _scHOV::I64 = _scHNE::I64 + 144;
           _scHOY::I64 = %MO_UU_Conv_W32_W64(I32[_scHOV::I64]);
           _scHP2::I64 = %MO_UU_Conv_W32_W64(I32[_scHOV::I64 + 4]);
           _scHP6::I64 = I64[_scHOV::I64 + 8];
           _scHPa::I64 = I64[_scHOV::I64 + 16];
           _scHPe::I64 = I64[_scHOV::I64 + 24];
           _scHPi::I64 = I64[_scHOV::I64 + 32];
           _scHPm::I64 = I64[_scHOV::I64 + 40];
           _scHPq::I64 = I64[_scHOV::I64 + 48];
           _scHPu::I64 = I64[_scHOV::I64 + 56];
           _scHPy::I64 = I64[_scHOV::I64 + 64];
           _scHPC::I64 = I64[_scHOV::I64 + 72];
           _scHPG::I64 = I64[_scHOV::I64 + 80];
           _scHPK::I64 = I64[_scHOV::I64 + 88];
           _scHPO::I64 = I64[_scHOV::I64 + 96];
           call MO_Touch(P64[Sp + 16]);
           I64[Hp - 808] = GHC.Int.I64#_con_info;
           I64[Hp - 800] = _scHPO::I64;
           I64[Hp - 792] = GHC.Int.I64#_con_info;
           I64[Hp - 784] = _scHPK::I64;
           I64[Hp - 776] = GHC.Int.I64#_con_info;
           I64[Hp - 768] = _scHPG::I64;
           I64[Hp - 760] = GHC.Word.W64#_con_info;
           I64[Hp - 752] = _scHPC::I64;
           I64[Hp - 744] = GHC.Word.W64#_con_info;
           I64[Hp - 736] = _scHPy::I64;
           I64[Hp - 728] = GHC.Word.W64#_con_info;
           I64[Hp - 720] = _scHPu::I64;
           I64[Hp - 712] = GHC.Word.W64#_con_info;
           I64[Hp - 704] = _scHPq::I64;
           I64[Hp - 696] = GHC.Word.W64#_con_info;
           I64[Hp - 688] = _scHPm::I64;
           I64[Hp - 680] = GHC.Word.W64#_con_info;
           I64[Hp - 672] = _scHPi::I64;
           I64[Hp - 664] = GHC.Word.W64#_con_info;
           I64[Hp - 656] = _scHPe::I64;
           I64[Hp - 648] = GHC.Word.W64#_con_info;
           I64[Hp - 640] = _scHPa::I64;
           I64[Hp - 632] = GHC.Word.W64#_con_info;
           I64[Hp - 624] = _scHP6::I64;
           I64[Hp - 616] = GHC.Word.W32#_con_info;
           I64[Hp - 608] = _scHP2::I64;
           I64[Hp - 600] = GHC.Word.W32#_con_info;
           I64[Hp - 592] = _scHOY::I64;
           I64[Hp - 584] = GHC.Stats.GCDetails_con_info;
           P64[Hp - 576] = Hp - 599;
           P64[Hp - 568] = Hp - 615;
           P64[Hp - 560] = Hp - 631;
           P64[Hp - 552] = Hp - 647;
           P64[Hp - 544] = Hp - 663;
           P64[Hp - 536] = Hp - 679;
           P64[Hp - 528] = Hp - 695;
           P64[Hp - 520] = Hp - 711;
           P64[Hp - 512] = Hp - 727;
           P64[Hp - 504] = Hp - 743;
           P64[Hp - 496] = Hp - 759;
           P64[Hp - 488] = Hp - 775;
           P64[Hp - 480] = Hp - 791;
           P64[Hp - 472] = Hp - 807;
           I64[Hp - 464] = GHC.Int.I64#_con_info;
           I64[Hp - 456] = _scHOU::I64;
           I64[Hp - 448] = GHC.Int.I64#_con_info;
           I64[Hp - 440] = _scHOQ::I64;
           I64[Hp - 432] = GHC.Int.I64#_con_info;
           I64[Hp - 424] = _scHOM::I64;
           I64[Hp - 416] = GHC.Int.I64#_con_info;
           I64[Hp - 408] = _scHOI::I64;
           I64[Hp - 400] = GHC.Int.I64#_con_info;
           I64[Hp - 392] = _scHOE::I64;
           I64[Hp - 384] = GHC.Int.I64#_con_info;
           I64[Hp - 376] = _scHOA::I64;
           I64[Hp - 368] = GHC.Word.W64#_con_info;
           I64[Hp - 360] = _scHOw::I64;
           I64[Hp - 352] = GHC.Word.W64#_con_info;
           I64[Hp - 344] = _scHOs::I64;
           I64[Hp - 336] = GHC.Word.W64#_con_info;
           I64[Hp - 328] = _scHOo::I64;
           I64[Hp - 320] = GHC.Word.W64#_con_info;
           I64[Hp - 312] = _scHOk::I64;
           I64[Hp - 304] = GHC.Word.W64#_con_info;
           I64[Hp - 296] = _scHOg::I64;
           I64[Hp - 288] = GHC.Word.W64#_con_info;
           I64[Hp - 280] = _scHOc::I64;
           I64[Hp - 272] = GHC.Word.W64#_con_info;
           I64[Hp - 264] = _scHO8::I64;
           I64[Hp - 256] = GHC.Word.W64#_con_info;
           I64[Hp - 248] = _scHO4::I64;
           I64[Hp - 240] = GHC.Word.W64#_con_info;
           I64[Hp - 232] = _scHO0::I64;
           I64[Hp - 224] = GHC.Word.W64#_con_info;
           I64[Hp - 216] = _scHNW::I64;
           I64[Hp - 208] = GHC.Word.W64#_con_info;
           I64[Hp - 200] = _scHNS::I64;
           I64[Hp - 192] = GHC.Word.W32#_con_info;
           I64[Hp - 184] = _scHNO::I64;
           I64[Hp - 176] = GHC.Word.W32#_con_info;
           I64[Hp - 168] = _scHNK::I64;
           I64[Hp - 160] = GHC.Stats.RTSStats_con_info;
           P64[Hp - 152] = Hp - 175;
           P64[Hp - 144] = Hp - 191;
           P64[Hp - 136] = Hp - 207;
           P64[Hp - 128] = Hp - 223;
           P64[Hp - 120] = Hp - 239;
           P64[Hp - 112] = Hp - 255;
           P64[Hp - 104] = Hp - 271;
           P64[Hp - 96] = Hp - 287;
           P64[Hp - 88] = Hp - 303;
           P64[Hp - 80] = Hp - 319;
           P64[Hp - 72] = Hp - 335;
           P64[Hp - 64] = Hp - 351;
           P64[Hp - 56] = Hp - 367;
           P64[Hp - 48] = Hp - 383;
           P64[Hp - 40] = Hp - 399;
           P64[Hp - 32] = Hp - 415;
           P64[Hp - 24] = Hp - 431;
           P64[Hp - 16] = Hp - 447;
           P64[Hp - 8] = Hp - 463;
           P64[Hp] = Hp - 583;
           R1 = Hp - 159;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.602809565 UTC

[section ""data" . GHC.Stats.getRTSStats_closure" {
     GHC.Stats.getRTSStats_closure:
         const GHC.Stats.getRTSStats_info;
         const 0;
 },
 GHC.Stats.getRTSStats_entry() //  []
         { info_tbl: [(ccJZm,
                       label: GHC.Stats.getRTSStats_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJZm: // global
           call GHC.Stats.getRTSStats1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.604085965 UTC

[section ""data" . GHC.Stats.GCDetails_closure" {
     GHC.Stats.GCDetails_closure:
         const GHC.Stats.GCDetails_info;
 },
 GHC.Stats.GCDetails_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJZq: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Stats.GCDetails_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 80, res: 0, upd: 8;
     }
 },
 GHC.Stats.GCDetails_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccJZv,
                       label: GHC.Stats.GCDetails_info
                       rep:HeapRep static {
                             Fun {arity: 14
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJZv: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccJZz; else goto ccJZy;
       ccJZz: // global
           HpAlloc = 120;
           R1 = GHC.Stats.GCDetails_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 120, res: 0, upd: 8;
       ccJZy: // global
           I64[Hp - 112] = GHC.Stats.GCDetails_con_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           P64[Hp - 88] = R4;
           P64[Hp - 80] = R5;
           P64[Hp - 72] = R6;
           P64[Hp - 64] = P64[Sp];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = P64[Sp + 56];
           P64[Hp] = P64[Sp + 64];
           R1 = Hp - 111;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.606655177 UTC

[section ""data" . GHC.Stats.RTSStats_closure" {
     GHC.Stats.RTSStats_closure:
         const GHC.Stats.RTSStats_info;
 },
 GHC.Stats.RTSStats_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJZB: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Stats.RTSStats_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2,
                                         R1) args: 128, res: 0, upd: 8;
     }
 },
 GHC.Stats.RTSStats_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccJZG,
                       label: GHC.Stats.RTSStats_info
                       rep:HeapRep static {
                             Fun {arity: 20
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJZG: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccJZK; else goto ccJZJ;
       ccJZK: // global
           HpAlloc = 168;
           R1 = GHC.Stats.RTSStats_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 168, res: 0, upd: 8;
       ccJZJ: // global
           I64[Hp - 160] = GHC.Stats.RTSStats_con_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           P64[Hp - 136] = R4;
           P64[Hp - 128] = R5;
           P64[Hp - 120] = R6;
           P64[Hp - 112] = P64[Sp];
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = P64[Sp + 16];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = P64[Sp + 56];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = P64[Sp + 72];
           P64[Hp - 32] = P64[Sp + 80];
           P64[Hp - 24] = P64[Sp + 88];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 159;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.60812771 UTC

[GHC.Stats.GCDetails_con_entry() //  [R1]
         { info_tbl: [(ccJZL,
                       label: GHC.Stats.GCDetails_con_info
                       rep:HeapRep 14 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,115,46,71,67,68,101,116,97,105,108,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJZL: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.608946329 UTC

[GHC.Stats.RTSStats_con_entry() //  [R1]
         { info_tbl: [(ccJZN,
                       label: GHC.Stats.RTSStats_con_info
                       rep:HeapRep 20 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,115,46,82,84,83,83,116,97,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccJZN: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.609724542 UTC

[section ""relreadonly" . ScI2G_srt" {
     ScI2G_srt:
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Stats.$fShowGCDetails_$cshowsPrec_closure;
         const GHC.Stats.$fShowGCDetails_$cshow_closure;
         const GHC.Stats.$fShowGCDetails1_closure;
         const GHC.Stats.$fShowRTSStats_$cshowsPrec_closure;
         const GHC.Stats.$fShowRTSStats_$cshow_closure;
         const GHC.Stats.$fShowRTSStats1_closure;
         const GHC.Read.$fReadWord32_$creadsPrec_closure;
         const lvl37_rcHqd_closure;
         const ds2_rcHqe_closure;
         const GHC.Read.$fReadWord64_$creadsPrec_closure;
         const lvl45_rcHqn_closure;
         const lvl46_rcHqo_closure;
         const GHC.Int.$fReadInt64_$creadsPrec_closure;
         const lvl65_rcHqH_closure;
         const lvl66_rcHqI_closure;
         const Text.Read.Lex.$wexpect_closure;
         const lvl72_rcHqO_closure;
         const GHC.Read.readField_closure;
         const lvl70_rcHqM_closure;
         const lvl40_rcHqi_closure;
         const lvl68_rcHqK_closure;
         const lvl64_rcHqG_closure;
         const lvl62_rcHqE_closure;
         const lvl60_rcHqC_closure;
         const lvl58_rcHqA_closure;
         const lvl56_rcHqy_closure;
         const lvl54_rcHqw_closure;
         const lvl52_rcHqu_closure;
         const lvl50_rcHqs_closure;
         const lvl48_rcHqq_closure;
         const lvl44_rcHqm_closure;
         const lvl42_rcHqk_closure;
         const ds1_rcHqc_closure;
         const lexeme4_rcHqa_closure;
         const GHC.Stats.$w$creadPrec_closure;
         const lexeme1_rcHq7_closure;
         const GHC.Stats.$fReadGCDetails2_closure;
         const GHC.Read.list3_closure;
         const GHC.Stats.$fReadGCDetails_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.Stats.$fReadGCDetails1_closure;
         const GHC.Stats.$fReadGCDetails_$creadListPrec_closure;
         const GHC.Stats.$fReadGCDetails3_closure;
         const lvl110_rcHru_closure;
         const lvl111_rcHrv_closure;
         const lvl108_rcHrs_closure;
         const lvl106_rcHrq_closure;
         const lvl104_rcHro_closure;
         const lvl102_rcHrm_closure;
         const lvl100_rcHrk_closure;
         const lvl98_rcHri_closure;
         const lvl96_rcHrg_closure;
         const lvl94_rcHre_closure;
         const lvl92_rcHrc_closure;
         const lvl90_rcHra_closure;
         const lvl88_rcHr8_closure;
         const lvl86_rcHr6_closure;
         const lvl84_rcHr4_closure;
         const lvl82_rcHr2_closure;
         const lvl80_rcHr0_closure;
         const lvl78_rcHqY_closure;
         const lvl76_rcHqW_closure;
         const lvl74_rcHqU_closure;
         const ds4_rcHqS_closure;
         const GHC.Stats.$w$creadPrec1_closure;
         const lexeme6_rcHqQ_closure;
         const GHC.Stats.$fReadRTSStats2_closure;
         const GHC.Stats.$fReadRTSStats_$creadsPrec_closure;
         const GHC.Stats.$fReadRTSStats1_closure;
         const GHC.Stats.$fReadRTSStats_$creadListPrec_closure;
         const GHC.Stats.$fReadRTSStats3_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.Stats.getRTSStats3_closure;
         const GHC.Stats.getRTSStats1_closure;
         const GHC.Stats.getRTSStats2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.611920884 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:36.613121595 UTC

[section ""cstring" . lvl_rcHpv_bytes" {
     lvl_rcHpv_bytes:
         I8[] [71,67,68,101,116,97,105,108,115,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.614961583 UTC

[section ""cstring" . lvl1_rcHpw_bytes" {
     lvl1_rcHpw_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,103,101,110,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.616726571 UTC

[section ""cstring" . lvl2_rcHpx_bytes" {
     lvl2_rcHpx_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,116,104,114,101,97,100,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.618841971 UTC

[section ""cstring" . lvl3_rcHpy_bytes" {
     lvl3_rcHpy_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,97,108,108,111,99,97,116,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.620639524 UTC

[section ""cstring" . lvl4_rcHpz_bytes" {
     lvl4_rcHpz_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,105,118,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.622400771 UTC

[section ""cstring" . lvl5_rcHpA_bytes" {
     lvl5_rcHpA_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.624160438 UTC

[section ""cstring" . lvl6_rcHpB_bytes" {
     lvl6_rcHpB_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,109,112,97,99,116,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.625879096 UTC

[section ""cstring" . lvl7_rcHpC_bytes" {
     lvl7_rcHpC_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,108,111,112,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.627558838 UTC

[section ""cstring" . lvl8_rcHpD_bytes" {
     lvl8_rcHpD_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.629438934 UTC

[section ""cstring" . lvl9_rcHpE_bytes" {
     lvl9_rcHpE_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.631206675 UTC

[section ""cstring" . lvl10_rcHpF_bytes" {
     lvl10_rcHpF_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.632943819 UTC

[section ""cstring" . lvl11_rcHpG_bytes" {
     lvl11_rcHpG_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.63484947 UTC

[section ""cstring" . lvl12_rcHpH_bytes" {
     lvl12_rcHpH_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,121,110,99,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.636757278 UTC

[section ""cstring" . lvl13_rcHpI_bytes" {
     lvl13_rcHpI_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.639179513 UTC

[section ""cstring" . lvl14_rcHpJ_bytes" {
     lvl14_rcHpJ_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.640883763 UTC

[section ""cstring" . lvl15_rcHpK_bytes" {
     lvl15_rcHpK_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.656378905 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_$cshowsPrec_closure" {
     GHC.Stats.$fShowGCDetails_$cshowsPrec_closure:
         const GHC.Stats.$fShowGCDetails_$cshowsPrec_info;
         const 0;
 },
 w1_scHss_entry() //  [R1]
         { info_tbl: [(ccK0q,
                       label: w1_scHss_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK0q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccK0r; else goto ccK0s;
       ccK0r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK0s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccK0n_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucK0E; else goto ccK0o;
       ucK0E: // global
           call _ccK0n(R1) args: 0, res: 0, upd: 0;
       ccK0o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK0n() //  [R1]
         { info_tbl: [(ccK0n,
                       label: block_ccK0n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK0n: // global
           _scHsu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsu::I64, 0)) goto ccK0C; else goto ccK0D;
       ccK0C: // global
           R2 = _scHsu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccK0D: // global
           R2 = _scHsu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w2_scHsx_entry() //  [R1]
         { info_tbl: [(ccK0M,
                       label: w2_scHsx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK0M: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccK0N; else goto ccK0O;
       ccK0N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK0O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccK0J_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucK10; else goto ccK0K;
       ucK10: // global
           call _ccK0J(R1) args: 0, res: 0, upd: 0;
       ccK0K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK0J() //  [R1]
         { info_tbl: [(ccK0J,
                       label: block_ccK0J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK0J: // global
           _scHsz::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsz::I64, 0)) goto ccK0Y; else goto ccK0Z;
       ccK0Y: // global
           R2 = _scHsz::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccK0Z: // global
           R2 = _scHsz::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w3_scHsC_entry() //  [R1]
         { info_tbl: [(ccK18,
                       label: w3_scHsC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK18: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccK19; else goto ccK1a;
       ccK19: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK1a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccK15_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucK1m; else goto ccK16;
       ucK1m: // global
           call _ccK15(R1) args: 0, res: 0, upd: 0;
       ccK16: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK15() //  [R1]
         { info_tbl: [(ccK15,
                       label: block_ccK15_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK15: // global
           _scHsE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsE::I64, 0)) goto ccK1k; else goto ccK1l;
       ccK1k: // global
           R2 = _scHsE::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccK1l: // global
           R2 = _scHsE::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w4_scHsH_entry() //  [R1]
         { info_tbl: [(ccK1u,
                       label: w4_scHsH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK1u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccK1v; else goto ccK1w;
       ccK1v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK1w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccK1r_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucK1I; else goto ccK1s;
       ucK1I: // global
           call _ccK1r(R1) args: 0, res: 0, upd: 0;
       ccK1s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK1r() //  [R1]
         { info_tbl: [(ccK1r,
                       label: block_ccK1r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK1r: // global
           _scHsJ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsJ::I64, 0)) goto ccK1G; else goto ccK1H;
       ccK1G: // global
           R2 = _scHsJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccK1H: // global
           R2 = _scHsJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_scHsM_entry() //  [R1]
         { info_tbl: [(ccK1Q,
                       label: w5_scHsM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK1Q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccK1R; else goto ccK1S;
       ccK1R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK1S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccK1N_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucK24; else goto ccK1O;
       ucK24: // global
           call _ccK1N(R1) args: 0, res: 0, upd: 0;
       ccK1O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK1N() //  [R1]
         { info_tbl: [(ccK1N,
                       label: block_ccK1N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK1N: // global
           _scHsO::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsO::I64, 0)) goto ccK22; else goto ccK23;
       ccK22: // global
           R2 = _scHsO::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccK23: // global
           R2 = _scHsO::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_scHsR_entry() //  [R1]
         { info_tbl: [(ccK2c,
                       label: w6_scHsR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK2c: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccK2d; else goto ccK2e;
       ccK2d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK2e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccK29_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucK2q; else goto ccK2a;
       ucK2q: // global
           call _ccK29(R1) args: 0, res: 0, upd: 0;
       ccK2a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK29() //  [R1]
         { info_tbl: [(ccK29,
                       label: block_ccK29_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK29: // global
           _scHsT::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsT::I64, 0)) goto ccK2o; else goto ccK2p;
       ccK2o: // global
           R2 = _scHsT::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccK2p: // global
           R2 = _scHsT::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_scHsW_entry() //  [R1]
         { info_tbl: [(ccK2y,
                       label: w7_scHsW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK2y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccK2z; else goto ccK2A;
       ccK2z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK2A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccK2v_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucK2M; else goto ccK2w;
       ucK2M: // global
           call _ccK2v(R1) args: 0, res: 0, upd: 0;
       ccK2w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK2v() //  [R1]
         { info_tbl: [(ccK2v,
                       label: block_ccK2v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK2v: // global
           _scHsY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHsY::I64, 0)) goto ccK2K; else goto ccK2L;
       ccK2K: // global
           R2 = _scHsY::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccK2L: // global
           R2 = _scHsY::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w8_scHt1_entry() //  [R1]
         { info_tbl: [(ccK2U,
                       label: w8_scHt1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK2U: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccK2V; else goto ccK2W;
       ccK2V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK2W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccK2R_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucK38; else goto ccK2S;
       ucK38: // global
           call _ccK2R(R1) args: 0, res: 0, upd: 0;
       ccK2S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK2R() //  [R1]
         { info_tbl: [(ccK2R,
                       label: block_ccK2R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK2R: // global
           _scHt3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHt3::I64, 0)) goto ccK36; else goto ccK37;
       ccK36: // global
           R2 = _scHt3::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccK37: // global
           R2 = _scHt3::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w9_scHt6_entry() //  [R1]
         { info_tbl: [(ccK3g,
                       label: w9_scHt6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK3g: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccK3h; else goto ccK3i;
       ccK3h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK3i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccK3d_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucK3u; else goto ccK3e;
       ucK3u: // global
           call _ccK3d(R1) args: 0, res: 0, upd: 0;
       ccK3e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK3d() //  [R1]
         { info_tbl: [(ccK3d,
                       label: block_ccK3d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK3d: // global
           _scHt8::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHt8::I64, 0)) goto ccK3s; else goto ccK3t;
       ccK3s: // global
           R2 = _scHt8::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccK3t: // global
           R2 = _scHt8::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtp_entry() //  [R1]
         { info_tbl: [(ccK6H,
                       label: sat_scHtp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK6H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccK6I; else goto ccK6J;
       ccK6I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK6J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = lvl15_rcHpK_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtt_entry() //  [R1]
         { info_tbl: [(ccK6K,
                       label: sat_scHtt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK6K: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccK6O; else goto ccK6P;
       ccK6O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK6P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccK6y_info;
           _scHtc::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucK6W; else goto ccK6z;
       ucK6W: // global
           call _ccK6y(R1) args: 0, res: 0, upd: 0;
       ccK6z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK6y() //  [R1]
         { info_tbl: [(ccK6y,
                       label: block_ccK6y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK6y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccK6S; else goto ccK6R;
       ccK6S: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccK6R: // global
           _scHto::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_scHtp_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccK6L_info;
           R4 = Hp - 16;
           R3 = _scHto::I64;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccK6L() //  [R1, R2]
         { info_tbl: [(ccK6L,
                       label: block_ccK6L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK6L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccK6V; else goto ccK6U;
       ccK6V: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccK6U: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtu_entry() //  [R1]
         { info_tbl: [(ccK6X,
                       label: sat_scHtu_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK6X: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccK71; else goto ccK70;
       ccK71: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK70: // global
           _scHsp::P64 = P64[R1 + 16];
           _scHtc::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_scHtt_info;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 24;
           R2 = lvl14_rcHpJ_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtv_entry() //  [R1]
         { info_tbl: [(ccK72,
                       label: sat_scHtv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK72: // global
           _scHtv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccK73; else goto ccK74;
       ccK74: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccK76; else goto ccK75;
       ccK76: // global
           HpAlloc = 32;
           goto ccK73;
       ccK73: // global
           R1 = _scHtv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK75: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtv::P64;
           _scHsp::P64 = P64[_scHtv::P64 + 16];
           _scHtc::P64 = P64[_scHtv::P64 + 24];
           I64[Hp - 24] = sat_scHtu_info;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtz_entry() //  [R1]
         { info_tbl: [(ccK77,
                       label: sat_scHtz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK77: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccK7b; else goto ccK7c;
       ccK7b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK7c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccK6h_info;
           _scHsp::P64 = P64[R1 + 24];
           _scHtc::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _scHsp::P64;
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucK7j; else goto ccK6i;
       ucK7j: // global
           call _ccK6h(R1) args: 0, res: 0, upd: 0;
       ccK6i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK6h() //  [R1]
         { info_tbl: [(ccK6h,
                       label: block_ccK6h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK6h: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccK7f; else goto ccK7e;
       ccK7f: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccK7e: // global
           _scHtm::I64 = I64[R1 + 7];
           I64[Hp - 24] = sat_scHtv_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_ccK78_info;
           R4 = Hp - 24;
           R3 = _scHtm::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccK78() //  [R1, R2]
         { info_tbl: [(ccK78,
                       label: block_ccK78_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK78: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccK7i; else goto ccK7h;
       ccK7i: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccK7h: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtA_entry() //  [R1]
         { info_tbl: [(ccK7k,
                       label: sat_scHtA_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK7k: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccK7o; else goto ccK7n;
       ccK7o: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK7n: // global
           _scHso::P64 = P64[R1 + 16];
           _scHsp::P64 = P64[R1 + 24];
           _scHtc::P64 = P64[R1 + 32];
           I64[Hp - 32] = sat_scHtz_info;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 32;
           R2 = lvl13_rcHpI_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtB_entry() //  [R1]
         { info_tbl: [(ccK7p,
                       label: sat_scHtB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK7p: // global
           _scHtB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccK7q; else goto ccK7r;
       ccK7r: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccK7t; else goto ccK7s;
       ccK7t: // global
           HpAlloc = 40;
           goto ccK7q;
       ccK7q: // global
           R1 = _scHtB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK7s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtB::P64;
           _scHso::P64 = P64[_scHtB::P64 + 16];
           _scHsp::P64 = P64[_scHtB::P64 + 24];
           _scHtc::P64 = P64[_scHtB::P64 + 32];
           I64[Hp - 32] = sat_scHtA_info;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtF_entry() //  [R1]
         { info_tbl: [(ccK7u,
                       label: sat_scHtF_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK7u: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccK7y; else goto ccK7z;
       ccK7y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK7z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccK60_info;
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHtc::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _scHso::P64;
           P64[Sp - 32] = _scHsp::P64;
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucK7G; else goto ccK61;
       ucK7G: // global
           call _ccK60(R1) args: 0, res: 0, upd: 0;
       ccK61: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK60() //  [R1]
         { info_tbl: [(ccK60,
                       label: block_ccK60_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK60: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccK7C; else goto ccK7B;
       ccK7C: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccK7B: // global
           _scHtk::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_scHtB_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_ccK7v_info;
           R4 = Hp - 32;
           R3 = _scHtk::I64;
           R2 = 0;
           Sp = Sp + 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccK7v() //  [R1, R2]
         { info_tbl: [(ccK7v,
                       label: block_ccK7v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK7v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccK7F; else goto ccK7E;
       ccK7F: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccK7E: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtG_entry() //  [R1]
         { info_tbl: [(ccK7H,
                       label: sat_scHtG_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK7H: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccK7L; else goto ccK7K;
       ccK7L: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK7K: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHtc::P64 = P64[R1 + 40];
           I64[Hp - 40] = sat_scHtF_info;
           P64[Hp - 24] = _scHsn::P64;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 40;
           R2 = lvl12_rcHpH_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtH_entry() //  [R1]
         { info_tbl: [(ccK7M,
                       label: sat_scHtH_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK7M: // global
           _scHtH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccK7N; else goto ccK7O;
       ccK7O: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccK7Q; else goto ccK7P;
       ccK7Q: // global
           HpAlloc = 48;
           goto ccK7N;
       ccK7N: // global
           R1 = _scHtH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK7P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtH::P64;
           _scHsn::P64 = P64[_scHtH::P64 + 16];
           _scHso::P64 = P64[_scHtH::P64 + 24];
           _scHsp::P64 = P64[_scHtH::P64 + 32];
           _scHtc::P64 = P64[_scHtH::P64 + 40];
           I64[Hp - 40] = sat_scHtG_info;
           P64[Hp - 24] = _scHsn::P64;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 40;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtL_entry() //  [R1]
         { info_tbl: [(ccK7U,
                       label: sat_scHtL_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK7U: // global
           _scHtL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccK7V; else goto ccK7W;
       ccK7W: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccK7Y; else goto ccK7X;
       ccK7Y: // global
           HpAlloc = 48;
           goto ccK7V;
       ccK7V: // global
           R1 = _scHtL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK7X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtL::P64;
           _scHsn::P64 = P64[_scHtL::P64 + 16];
           _scHso::P64 = P64[_scHtL::P64 + 24];
           _scHsp::P64 = P64[_scHtL::P64 + 32];
           _scHt6::P64 = P64[_scHtL::P64 + 40];
           _scHtc::P64 = P64[_scHtL::P64 + 48];
           I64[Hp - 40] = sat_scHtH_info;
           P64[Hp - 24] = _scHsn::P64;
           P64[Hp - 16] = _scHso::P64;
           P64[Hp - 8] = _scHsp::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccK7R_info;
           R4 = Hp - 40;
           R3 = _scHt6::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccK7R() //  [R1, R2]
         { info_tbl: [(ccK7R,
                       label: block_ccK7R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK7R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccK81; else goto ccK80;
       ccK81: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccK80: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtM_entry() //  [R1]
         { info_tbl: [(ccK82,
                       label: sat_scHtM_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK82: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccK86; else goto ccK85;
       ccK86: // global
           HpAlloc = 56;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK85: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHt6::P64 = P64[R1 + 40];
           _scHtc::P64 = P64[R1 + 48];
           I64[Hp - 48] = sat_scHtL_info;
           P64[Hp - 32] = _scHsn::P64;
           P64[Hp - 24] = _scHso::P64;
           P64[Hp - 16] = _scHsp::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 48;
           R2 = lvl11_rcHpG_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtN_entry() //  [R1]
         { info_tbl: [(ccK87,
                       label: sat_scHtN_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK87: // global
           _scHtN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccK88; else goto ccK89;
       ccK89: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccK8b; else goto ccK8a;
       ccK8b: // global
           HpAlloc = 56;
           goto ccK88;
       ccK88: // global
           R1 = _scHtN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK8a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtN::P64;
           _scHsn::P64 = P64[_scHtN::P64 + 16];
           _scHso::P64 = P64[_scHtN::P64 + 24];
           _scHsp::P64 = P64[_scHtN::P64 + 32];
           _scHt6::P64 = P64[_scHtN::P64 + 40];
           _scHtc::P64 = P64[_scHtN::P64 + 48];
           I64[Hp - 48] = sat_scHtM_info;
           P64[Hp - 32] = _scHsn::P64;
           P64[Hp - 24] = _scHso::P64;
           P64[Hp - 16] = _scHsp::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 48;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtR_entry() //  [R1]
         { info_tbl: [(ccK8f,
                       label: sat_scHtR_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK8f: // global
           _scHtR::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccK8g; else goto ccK8h;
       ccK8h: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccK8j; else goto ccK8i;
       ccK8j: // global
           HpAlloc = 56;
           goto ccK8g;
       ccK8g: // global
           R1 = _scHtR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK8i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtR::P64;
           _scHsn::P64 = P64[_scHtR::P64 + 16];
           _scHso::P64 = P64[_scHtR::P64 + 24];
           _scHsp::P64 = P64[_scHtR::P64 + 32];
           _scHt1::P64 = P64[_scHtR::P64 + 40];
           _scHt6::P64 = P64[_scHtR::P64 + 48];
           _scHtc::P64 = P64[_scHtR::P64 + 56];
           I64[Hp - 48] = sat_scHtN_info;
           P64[Hp - 32] = _scHsn::P64;
           P64[Hp - 24] = _scHso::P64;
           P64[Hp - 16] = _scHsp::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccK8c_info;
           R4 = Hp - 48;
           R3 = _scHt1::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccK8c() //  [R1, R2]
         { info_tbl: [(ccK8c,
                       label: block_ccK8c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK8c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccK8m; else goto ccK8l;
       ccK8m: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccK8l: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtS_entry() //  [R1]
         { info_tbl: [(ccK8n,
                       label: sat_scHtS_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK8n: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccK8r; else goto ccK8q;
       ccK8r: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK8q: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHt1::P64 = P64[R1 + 40];
           _scHt6::P64 = P64[R1 + 48];
           _scHtc::P64 = P64[R1 + 56];
           I64[Hp - 56] = sat_scHtR_info;
           P64[Hp - 40] = _scHsn::P64;
           P64[Hp - 32] = _scHso::P64;
           P64[Hp - 24] = _scHsp::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 56;
           R2 = lvl10_rcHpF_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtT_entry() //  [R1]
         { info_tbl: [(ccK8s,
                       label: sat_scHtT_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK8s: // global
           _scHtT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccK8t; else goto ccK8u;
       ccK8u: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccK8w; else goto ccK8v;
       ccK8w: // global
           HpAlloc = 64;
           goto ccK8t;
       ccK8t: // global
           R1 = _scHtT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK8v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtT::P64;
           _scHsn::P64 = P64[_scHtT::P64 + 16];
           _scHso::P64 = P64[_scHtT::P64 + 24];
           _scHsp::P64 = P64[_scHtT::P64 + 32];
           _scHt1::P64 = P64[_scHtT::P64 + 40];
           _scHt6::P64 = P64[_scHtT::P64 + 48];
           _scHtc::P64 = P64[_scHtT::P64 + 56];
           I64[Hp - 56] = sat_scHtS_info;
           P64[Hp - 40] = _scHsn::P64;
           P64[Hp - 32] = _scHso::P64;
           P64[Hp - 24] = _scHsp::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 56;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtX_entry() //  [R1]
         { info_tbl: [(ccK8A,
                       label: sat_scHtX_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK8A: // global
           _scHtX::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccK8B; else goto ccK8C;
       ccK8C: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccK8E; else goto ccK8D;
       ccK8E: // global
           HpAlloc = 64;
           goto ccK8B;
       ccK8B: // global
           R1 = _scHtX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK8D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtX::P64;
           _scHsn::P64 = P64[_scHtX::P64 + 16];
           _scHso::P64 = P64[_scHtX::P64 + 24];
           _scHsp::P64 = P64[_scHtX::P64 + 32];
           _scHsW::P64 = P64[_scHtX::P64 + 40];
           _scHt1::P64 = P64[_scHtX::P64 + 48];
           _scHt6::P64 = P64[_scHtX::P64 + 56];
           _scHtc::P64 = P64[_scHtX::P64 + 64];
           I64[Hp - 56] = sat_scHtT_info;
           P64[Hp - 40] = _scHsn::P64;
           P64[Hp - 32] = _scHso::P64;
           P64[Hp - 24] = _scHsp::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccK8x_info;
           R4 = Hp - 56;
           R3 = _scHsW::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccK8x() //  [R1, R2]
         { info_tbl: [(ccK8x,
                       label: block_ccK8x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK8x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccK8H; else goto ccK8G;
       ccK8H: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccK8G: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHtY_entry() //  [R1]
         { info_tbl: [(ccK8I,
                       label: sat_scHtY_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK8I: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccK8M; else goto ccK8L;
       ccK8M: // global
           HpAlloc = 72;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK8L: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsW::P64 = P64[R1 + 40];
           _scHt1::P64 = P64[R1 + 48];
           _scHt6::P64 = P64[R1 + 56];
           _scHtc::P64 = P64[R1 + 64];
           I64[Hp - 64] = sat_scHtX_info;
           P64[Hp - 48] = _scHsn::P64;
           P64[Hp - 40] = _scHso::P64;
           P64[Hp - 32] = _scHsp::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 64;
           R2 = lvl9_rcHpE_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHtZ_entry() //  [R1]
         { info_tbl: [(ccK8N,
                       label: sat_scHtZ_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK8N: // global
           _scHtZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccK8O; else goto ccK8P;
       ccK8P: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccK8R; else goto ccK8Q;
       ccK8R: // global
           HpAlloc = 72;
           goto ccK8O;
       ccK8O: // global
           R1 = _scHtZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK8Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHtZ::P64;
           _scHsn::P64 = P64[_scHtZ::P64 + 16];
           _scHso::P64 = P64[_scHtZ::P64 + 24];
           _scHsp::P64 = P64[_scHtZ::P64 + 32];
           _scHsW::P64 = P64[_scHtZ::P64 + 40];
           _scHt1::P64 = P64[_scHtZ::P64 + 48];
           _scHt6::P64 = P64[_scHtZ::P64 + 56];
           _scHtc::P64 = P64[_scHtZ::P64 + 64];
           I64[Hp - 64] = sat_scHtY_info;
           P64[Hp - 48] = _scHsn::P64;
           P64[Hp - 40] = _scHso::P64;
           P64[Hp - 32] = _scHsp::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 64;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHu3_entry() //  [R1]
         { info_tbl: [(ccK8V,
                       label: sat_scHu3_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK8V: // global
           _scHu3::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccK8W; else goto ccK8X;
       ccK8X: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccK8Z; else goto ccK8Y;
       ccK8Z: // global
           HpAlloc = 72;
           goto ccK8W;
       ccK8W: // global
           R1 = _scHu3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK8Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHu3::P64;
           _scHsn::P64 = P64[_scHu3::P64 + 16];
           _scHso::P64 = P64[_scHu3::P64 + 24];
           _scHsp::P64 = P64[_scHu3::P64 + 32];
           _scHsR::P64 = P64[_scHu3::P64 + 40];
           _scHsW::P64 = P64[_scHu3::P64 + 48];
           _scHt1::P64 = P64[_scHu3::P64 + 56];
           _scHt6::P64 = P64[_scHu3::P64 + 64];
           _scHtc::P64 = P64[_scHu3::P64 + 72];
           I64[Hp - 64] = sat_scHtZ_info;
           P64[Hp - 48] = _scHsn::P64;
           P64[Hp - 40] = _scHso::P64;
           P64[Hp - 32] = _scHsp::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccK8S_info;
           R4 = Hp - 64;
           R3 = _scHsR::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccK8S() //  [R1, R2]
         { info_tbl: [(ccK8S,
                       label: block_ccK8S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK8S: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccK92; else goto ccK91;
       ccK92: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccK91: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHu4_entry() //  [R1]
         { info_tbl: [(ccK93,
                       label: sat_scHu4_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK93: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccK97; else goto ccK96;
       ccK97: // global
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK96: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsR::P64 = P64[R1 + 40];
           _scHsW::P64 = P64[R1 + 48];
           _scHt1::P64 = P64[R1 + 56];
           _scHt6::P64 = P64[R1 + 64];
           _scHtc::P64 = P64[R1 + 72];
           I64[Hp - 72] = sat_scHu3_info;
           P64[Hp - 56] = _scHsn::P64;
           P64[Hp - 48] = _scHso::P64;
           P64[Hp - 40] = _scHsp::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 72;
           R2 = lvl8_rcHpD_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHu5_entry() //  [R1]
         { info_tbl: [(ccK98,
                       label: sat_scHu5_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK98: // global
           _scHu5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccK99; else goto ccK9a;
       ccK9a: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccK9c; else goto ccK9b;
       ccK9c: // global
           HpAlloc = 80;
           goto ccK99;
       ccK99: // global
           R1 = _scHu5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK9b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHu5::P64;
           _scHsn::P64 = P64[_scHu5::P64 + 16];
           _scHso::P64 = P64[_scHu5::P64 + 24];
           _scHsp::P64 = P64[_scHu5::P64 + 32];
           _scHsR::P64 = P64[_scHu5::P64 + 40];
           _scHsW::P64 = P64[_scHu5::P64 + 48];
           _scHt1::P64 = P64[_scHu5::P64 + 56];
           _scHt6::P64 = P64[_scHu5::P64 + 64];
           _scHtc::P64 = P64[_scHu5::P64 + 72];
           I64[Hp - 72] = sat_scHu4_info;
           P64[Hp - 56] = _scHsn::P64;
           P64[Hp - 48] = _scHso::P64;
           P64[Hp - 40] = _scHsp::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 72;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHu9_entry() //  [R1]
         { info_tbl: [(ccK9g,
                       label: sat_scHu9_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK9g: // global
           _scHu9::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccK9h; else goto ccK9i;
       ccK9i: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccK9k; else goto ccK9j;
       ccK9k: // global
           HpAlloc = 80;
           goto ccK9h;
       ccK9h: // global
           R1 = _scHu9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK9j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHu9::P64;
           _scHsn::P64 = P64[_scHu9::P64 + 16];
           _scHso::P64 = P64[_scHu9::P64 + 24];
           _scHsp::P64 = P64[_scHu9::P64 + 32];
           _scHsM::P64 = P64[_scHu9::P64 + 40];
           _scHsR::P64 = P64[_scHu9::P64 + 48];
           _scHsW::P64 = P64[_scHu9::P64 + 56];
           _scHt1::P64 = P64[_scHu9::P64 + 64];
           _scHt6::P64 = P64[_scHu9::P64 + 72];
           _scHtc::P64 = P64[_scHu9::P64 + 80];
           I64[Hp - 72] = sat_scHu5_info;
           P64[Hp - 56] = _scHsn::P64;
           P64[Hp - 48] = _scHso::P64;
           P64[Hp - 40] = _scHsp::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccK9d_info;
           R4 = Hp - 72;
           R3 = _scHsM::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccK9d() //  [R1, R2]
         { info_tbl: [(ccK9d,
                       label: block_ccK9d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK9d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccK9n; else goto ccK9m;
       ccK9n: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccK9m: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHua_entry() //  [R1]
         { info_tbl: [(ccK9o,
                       label: sat_scHua_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK9o: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccK9s; else goto ccK9r;
       ccK9s: // global
           HpAlloc = 88;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK9r: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsM::P64 = P64[R1 + 40];
           _scHsR::P64 = P64[R1 + 48];
           _scHsW::P64 = P64[R1 + 56];
           _scHt1::P64 = P64[R1 + 64];
           _scHt6::P64 = P64[R1 + 72];
           _scHtc::P64 = P64[R1 + 80];
           I64[Hp - 80] = sat_scHu9_info;
           P64[Hp - 64] = _scHsn::P64;
           P64[Hp - 56] = _scHso::P64;
           P64[Hp - 48] = _scHsp::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 80;
           R2 = lvl7_rcHpC_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHub_entry() //  [R1]
         { info_tbl: [(ccK9t,
                       label: sat_scHub_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK9t: // global
           _scHub::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccK9u; else goto ccK9v;
       ccK9v: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccK9x; else goto ccK9w;
       ccK9x: // global
           HpAlloc = 88;
           goto ccK9u;
       ccK9u: // global
           R1 = _scHub::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK9w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHub::P64;
           _scHsn::P64 = P64[_scHub::P64 + 16];
           _scHso::P64 = P64[_scHub::P64 + 24];
           _scHsp::P64 = P64[_scHub::P64 + 32];
           _scHsM::P64 = P64[_scHub::P64 + 40];
           _scHsR::P64 = P64[_scHub::P64 + 48];
           _scHsW::P64 = P64[_scHub::P64 + 56];
           _scHt1::P64 = P64[_scHub::P64 + 64];
           _scHt6::P64 = P64[_scHub::P64 + 72];
           _scHtc::P64 = P64[_scHub::P64 + 80];
           I64[Hp - 80] = sat_scHua_info;
           P64[Hp - 64] = _scHsn::P64;
           P64[Hp - 56] = _scHso::P64;
           P64[Hp - 48] = _scHsp::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 80;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuf_entry() //  [R1]
         { info_tbl: [(ccK9B,
                       label: sat_scHuf_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK9B: // global
           _scHuf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccK9C; else goto ccK9D;
       ccK9D: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccK9F; else goto ccK9E;
       ccK9F: // global
           HpAlloc = 88;
           goto ccK9C;
       ccK9C: // global
           R1 = _scHuf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK9E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuf::P64;
           _scHsn::P64 = P64[_scHuf::P64 + 16];
           _scHso::P64 = P64[_scHuf::P64 + 24];
           _scHsp::P64 = P64[_scHuf::P64 + 32];
           _scHsH::P64 = P64[_scHuf::P64 + 40];
           _scHsM::P64 = P64[_scHuf::P64 + 48];
           _scHsR::P64 = P64[_scHuf::P64 + 56];
           _scHsW::P64 = P64[_scHuf::P64 + 64];
           _scHt1::P64 = P64[_scHuf::P64 + 72];
           _scHt6::P64 = P64[_scHuf::P64 + 80];
           _scHtc::P64 = P64[_scHuf::P64 + 88];
           I64[Hp - 80] = sat_scHub_info;
           P64[Hp - 64] = _scHsn::P64;
           P64[Hp - 56] = _scHso::P64;
           P64[Hp - 48] = _scHsp::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccK9y_info;
           R4 = Hp - 80;
           R3 = _scHsH::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccK9y() //  [R1, R2]
         { info_tbl: [(ccK9y,
                       label: block_ccK9y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK9y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccK9I; else goto ccK9H;
       ccK9I: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccK9H: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHug_entry() //  [R1]
         { info_tbl: [(ccK9J,
                       label: sat_scHug_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK9J: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccK9N; else goto ccK9M;
       ccK9N: // global
           HpAlloc = 96;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK9M: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsH::P64 = P64[R1 + 40];
           _scHsM::P64 = P64[R1 + 48];
           _scHsR::P64 = P64[R1 + 56];
           _scHsW::P64 = P64[R1 + 64];
           _scHt1::P64 = P64[R1 + 72];
           _scHt6::P64 = P64[R1 + 80];
           _scHtc::P64 = P64[R1 + 88];
           I64[Hp - 88] = sat_scHuf_info;
           P64[Hp - 72] = _scHsn::P64;
           P64[Hp - 64] = _scHso::P64;
           P64[Hp - 56] = _scHsp::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 88;
           R2 = lvl6_rcHpB_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHuh_entry() //  [R1]
         { info_tbl: [(ccK9O,
                       label: sat_scHuh_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK9O: // global
           _scHuh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccK9P; else goto ccK9Q;
       ccK9Q: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccK9S; else goto ccK9R;
       ccK9S: // global
           HpAlloc = 96;
           goto ccK9P;
       ccK9P: // global
           R1 = _scHuh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK9R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuh::P64;
           _scHsn::P64 = P64[_scHuh::P64 + 16];
           _scHso::P64 = P64[_scHuh::P64 + 24];
           _scHsp::P64 = P64[_scHuh::P64 + 32];
           _scHsH::P64 = P64[_scHuh::P64 + 40];
           _scHsM::P64 = P64[_scHuh::P64 + 48];
           _scHsR::P64 = P64[_scHuh::P64 + 56];
           _scHsW::P64 = P64[_scHuh::P64 + 64];
           _scHt1::P64 = P64[_scHuh::P64 + 72];
           _scHt6::P64 = P64[_scHuh::P64 + 80];
           _scHtc::P64 = P64[_scHuh::P64 + 88];
           I64[Hp - 88] = sat_scHug_info;
           P64[Hp - 72] = _scHsn::P64;
           P64[Hp - 64] = _scHso::P64;
           P64[Hp - 56] = _scHsp::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 88;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHul_entry() //  [R1]
         { info_tbl: [(ccK9W,
                       label: sat_scHul_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK9W: // global
           _scHul::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccK9X; else goto ccK9Y;
       ccK9Y: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccKa0; else goto ccK9Z;
       ccKa0: // global
           HpAlloc = 96;
           goto ccK9X;
       ccK9X: // global
           R1 = _scHul::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccK9Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHul::P64;
           _scHsn::P64 = P64[_scHul::P64 + 16];
           _scHso::P64 = P64[_scHul::P64 + 24];
           _scHsp::P64 = P64[_scHul::P64 + 32];
           _scHsC::P64 = P64[_scHul::P64 + 40];
           _scHsH::P64 = P64[_scHul::P64 + 48];
           _scHsM::P64 = P64[_scHul::P64 + 56];
           _scHsR::P64 = P64[_scHul::P64 + 64];
           _scHsW::P64 = P64[_scHul::P64 + 72];
           _scHt1::P64 = P64[_scHul::P64 + 80];
           _scHt6::P64 = P64[_scHul::P64 + 88];
           _scHtc::P64 = P64[_scHul::P64 + 96];
           I64[Hp - 88] = sat_scHuh_info;
           P64[Hp - 72] = _scHsn::P64;
           P64[Hp - 64] = _scHso::P64;
           P64[Hp - 56] = _scHsp::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccK9T_info;
           R4 = Hp - 88;
           R3 = _scHsC::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccK9T() //  [R1, R2]
         { info_tbl: [(ccK9T,
                       label: block_ccK9T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK9T: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKa3; else goto ccKa2;
       ccKa3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKa2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHum_entry() //  [R1]
         { info_tbl: [(ccKa4,
                       label: sat_scHum_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKa4: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccKa8; else goto ccKa7;
       ccKa8: // global
           HpAlloc = 104;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKa7: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsC::P64 = P64[R1 + 40];
           _scHsH::P64 = P64[R1 + 48];
           _scHsM::P64 = P64[R1 + 56];
           _scHsR::P64 = P64[R1 + 64];
           _scHsW::P64 = P64[R1 + 72];
           _scHt1::P64 = P64[R1 + 80];
           _scHt6::P64 = P64[R1 + 88];
           _scHtc::P64 = P64[R1 + 96];
           I64[Hp - 96] = sat_scHul_info;
           P64[Hp - 80] = _scHsn::P64;
           P64[Hp - 72] = _scHso::P64;
           P64[Hp - 64] = _scHsp::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 96;
           R2 = lvl5_rcHpA_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHun_entry() //  [R1]
         { info_tbl: [(ccKa9,
                       label: sat_scHun_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKa9: // global
           _scHun::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKaa; else goto ccKab;
       ccKab: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccKad; else goto ccKac;
       ccKad: // global
           HpAlloc = 104;
           goto ccKaa;
       ccKaa: // global
           R1 = _scHun::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKac: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHun::P64;
           _scHsn::P64 = P64[_scHun::P64 + 16];
           _scHso::P64 = P64[_scHun::P64 + 24];
           _scHsp::P64 = P64[_scHun::P64 + 32];
           _scHsC::P64 = P64[_scHun::P64 + 40];
           _scHsH::P64 = P64[_scHun::P64 + 48];
           _scHsM::P64 = P64[_scHun::P64 + 56];
           _scHsR::P64 = P64[_scHun::P64 + 64];
           _scHsW::P64 = P64[_scHun::P64 + 72];
           _scHt1::P64 = P64[_scHun::P64 + 80];
           _scHt6::P64 = P64[_scHun::P64 + 88];
           _scHtc::P64 = P64[_scHun::P64 + 96];
           I64[Hp - 96] = sat_scHum_info;
           P64[Hp - 80] = _scHsn::P64;
           P64[Hp - 72] = _scHso::P64;
           P64[Hp - 64] = _scHsp::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 96;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHur_entry() //  [R1]
         { info_tbl: [(ccKah,
                       label: sat_scHur_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKah: // global
           _scHur::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccKai; else goto ccKaj;
       ccKaj: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccKal; else goto ccKak;
       ccKal: // global
           HpAlloc = 104;
           goto ccKai;
       ccKai: // global
           R1 = _scHur::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKak: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHur::P64;
           _scHsn::P64 = P64[_scHur::P64 + 16];
           _scHso::P64 = P64[_scHur::P64 + 24];
           _scHsp::P64 = P64[_scHur::P64 + 32];
           _scHsx::P64 = P64[_scHur::P64 + 40];
           _scHsC::P64 = P64[_scHur::P64 + 48];
           _scHsH::P64 = P64[_scHur::P64 + 56];
           _scHsM::P64 = P64[_scHur::P64 + 64];
           _scHsR::P64 = P64[_scHur::P64 + 72];
           _scHsW::P64 = P64[_scHur::P64 + 80];
           _scHt1::P64 = P64[_scHur::P64 + 88];
           _scHt6::P64 = P64[_scHur::P64 + 96];
           _scHtc::P64 = P64[_scHur::P64 + 104];
           I64[Hp - 96] = sat_scHun_info;
           P64[Hp - 80] = _scHsn::P64;
           P64[Hp - 72] = _scHso::P64;
           P64[Hp - 64] = _scHsp::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccKae_info;
           R4 = Hp - 96;
           R3 = _scHsx::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKae() //  [R1, R2]
         { info_tbl: [(ccKae,
                       label: block_ccKae_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKae: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKao; else goto ccKan;
       ccKao: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKan: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHus_entry() //  [R1]
         { info_tbl: [(ccKap,
                       label: sat_scHus_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKap: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccKat; else goto ccKas;
       ccKat: // global
           HpAlloc = 112;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKas: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHsx::P64 = P64[R1 + 40];
           _scHsC::P64 = P64[R1 + 48];
           _scHsH::P64 = P64[R1 + 56];
           _scHsM::P64 = P64[R1 + 64];
           _scHsR::P64 = P64[R1 + 72];
           _scHsW::P64 = P64[R1 + 80];
           _scHt1::P64 = P64[R1 + 88];
           _scHt6::P64 = P64[R1 + 96];
           _scHtc::P64 = P64[R1 + 104];
           I64[Hp - 104] = sat_scHur_info;
           P64[Hp - 88] = _scHsn::P64;
           P64[Hp - 80] = _scHso::P64;
           P64[Hp - 72] = _scHsp::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 104;
           R2 = lvl4_rcHpz_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHut_entry() //  [R1]
         { info_tbl: [(ccKau,
                       label: sat_scHut_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKau: // global
           _scHut::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKav; else goto ccKaw;
       ccKaw: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccKay; else goto ccKax;
       ccKay: // global
           HpAlloc = 112;
           goto ccKav;
       ccKav: // global
           R1 = _scHut::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKax: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHut::P64;
           _scHsn::P64 = P64[_scHut::P64 + 16];
           _scHso::P64 = P64[_scHut::P64 + 24];
           _scHsp::P64 = P64[_scHut::P64 + 32];
           _scHsx::P64 = P64[_scHut::P64 + 40];
           _scHsC::P64 = P64[_scHut::P64 + 48];
           _scHsH::P64 = P64[_scHut::P64 + 56];
           _scHsM::P64 = P64[_scHut::P64 + 64];
           _scHsR::P64 = P64[_scHut::P64 + 72];
           _scHsW::P64 = P64[_scHut::P64 + 80];
           _scHt1::P64 = P64[_scHut::P64 + 88];
           _scHt6::P64 = P64[_scHut::P64 + 96];
           _scHtc::P64 = P64[_scHut::P64 + 104];
           I64[Hp - 104] = sat_scHus_info;
           P64[Hp - 88] = _scHsn::P64;
           P64[Hp - 80] = _scHso::P64;
           P64[Hp - 72] = _scHsp::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 104;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHux_entry() //  [R1]
         { info_tbl: [(ccKaC,
                       label: sat_scHux_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKaC: // global
           _scHux::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccKaD; else goto ccKaE;
       ccKaE: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccKaG; else goto ccKaF;
       ccKaG: // global
           HpAlloc = 112;
           goto ccKaD;
       ccKaD: // global
           R1 = _scHux::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKaF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHux::P64;
           _scHsn::P64 = P64[_scHux::P64 + 16];
           _scHso::P64 = P64[_scHux::P64 + 24];
           _scHsp::P64 = P64[_scHux::P64 + 32];
           _scHss::P64 = P64[_scHux::P64 + 40];
           _scHsx::P64 = P64[_scHux::P64 + 48];
           _scHsC::P64 = P64[_scHux::P64 + 56];
           _scHsH::P64 = P64[_scHux::P64 + 64];
           _scHsM::P64 = P64[_scHux::P64 + 72];
           _scHsR::P64 = P64[_scHux::P64 + 80];
           _scHsW::P64 = P64[_scHux::P64 + 88];
           _scHt1::P64 = P64[_scHux::P64 + 96];
           _scHt6::P64 = P64[_scHux::P64 + 104];
           _scHtc::P64 = P64[_scHux::P64 + 112];
           I64[Hp - 104] = sat_scHut_info;
           P64[Hp - 88] = _scHsn::P64;
           P64[Hp - 80] = _scHso::P64;
           P64[Hp - 72] = _scHsp::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           I64[Sp - 24] = block_ccKaz_info;
           R4 = Hp - 104;
           R3 = _scHss::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKaz() //  [R1, R2]
         { info_tbl: [(ccKaz,
                       label: block_ccKaz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKaz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKaJ; else goto ccKaI;
       ccKaJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKaI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuy_entry() //  [R1]
         { info_tbl: [(ccKaK,
                       label: sat_scHuy_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKaK: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccKaO; else goto ccKaN;
       ccKaO: // global
           HpAlloc = 120;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKaN: // global
           _scHsn::P64 = P64[R1 + 16];
           _scHso::P64 = P64[R1 + 24];
           _scHsp::P64 = P64[R1 + 32];
           _scHss::P64 = P64[R1 + 40];
           _scHsx::P64 = P64[R1 + 48];
           _scHsC::P64 = P64[R1 + 56];
           _scHsH::P64 = P64[R1 + 64];
           _scHsM::P64 = P64[R1 + 72];
           _scHsR::P64 = P64[R1 + 80];
           _scHsW::P64 = P64[R1 + 88];
           _scHt1::P64 = P64[R1 + 96];
           _scHt6::P64 = P64[R1 + 104];
           _scHtc::P64 = P64[R1 + 112];
           I64[Hp - 112] = sat_scHux_info;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 112;
           R2 = lvl3_rcHpy_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHuz_entry() //  [R1]
         { info_tbl: [(ccKaP,
                       label: sat_scHuz_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKaP: // global
           _scHuz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKaQ; else goto ccKaR;
       ccKaR: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccKaT; else goto ccKaS;
       ccKaT: // global
           HpAlloc = 120;
           goto ccKaQ;
       ccKaQ: // global
           R1 = _scHuz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKaS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuz::P64;
           _scHsn::P64 = P64[_scHuz::P64 + 16];
           _scHso::P64 = P64[_scHuz::P64 + 24];
           _scHsp::P64 = P64[_scHuz::P64 + 32];
           _scHss::P64 = P64[_scHuz::P64 + 40];
           _scHsx::P64 = P64[_scHuz::P64 + 48];
           _scHsC::P64 = P64[_scHuz::P64 + 56];
           _scHsH::P64 = P64[_scHuz::P64 + 64];
           _scHsM::P64 = P64[_scHuz::P64 + 72];
           _scHsR::P64 = P64[_scHuz::P64 + 80];
           _scHsW::P64 = P64[_scHuz::P64 + 88];
           _scHt1::P64 = P64[_scHuz::P64 + 96];
           _scHt6::P64 = P64[_scHuz::P64 + 104];
           _scHtc::P64 = P64[_scHuz::P64 + 112];
           I64[Hp - 112] = sat_scHuy_info;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 112;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuD_entry() //  [R1]
         { info_tbl: [(ccKaU,
                       label: sat_scHuD_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKaU: // global
           if ((Sp + -128) < SpLim) (likely: False) goto ccKb1; else goto ccKb2;
       ccKb1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKb2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 128] = block_ccK3Z_info;
           _scHsn::P64 = P64[R1 + 24];
           _scHso::P64 = P64[R1 + 32];
           _scHsp::P64 = P64[R1 + 40];
           _scHss::P64 = P64[R1 + 48];
           _scHsx::P64 = P64[R1 + 56];
           _scHsC::P64 = P64[R1 + 64];
           _scHsH::P64 = P64[R1 + 72];
           _scHsM::P64 = P64[R1 + 80];
           _scHsR::P64 = P64[R1 + 88];
           _scHsW::P64 = P64[R1 + 96];
           _scHt1::P64 = P64[R1 + 104];
           _scHt6::P64 = P64[R1 + 112];
           _scHtc::P64 = P64[R1 + 120];
           R1 = P64[R1 + 16];
           P64[Sp - 120] = _scHsn::P64;
           P64[Sp - 112] = _scHso::P64;
           P64[Sp - 104] = _scHsp::P64;
           P64[Sp - 96] = _scHss::P64;
           P64[Sp - 88] = _scHsx::P64;
           P64[Sp - 80] = _scHsC::P64;
           P64[Sp - 72] = _scHsH::P64;
           P64[Sp - 64] = _scHsM::P64;
           P64[Sp - 56] = _scHsR::P64;
           P64[Sp - 48] = _scHsW::P64;
           P64[Sp - 40] = _scHt1::P64;
           P64[Sp - 32] = _scHt6::P64;
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto ucKb9; else goto ccK40;
       ucKb9: // global
           call _ccK3Z(R1) args: 0, res: 0, upd: 0;
       ccK40: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK3Z() //  [R1]
         { info_tbl: [(ccK3Z,
                       label: block_ccK3Z_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK3Z: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccKb5; else goto ccKb4;
       ccKb5: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccKb4: // global
           _scHth::I64 = I64[R1 + 7];
           I64[Hp - 112] = sat_scHuz_info;
           P64[Hp - 96] = P64[Sp + 8];
           P64[Hp - 88] = P64[Sp + 16];
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 32];
           P64[Hp - 64] = P64[Sp + 40];
           P64[Hp - 56] = P64[Sp + 48];
           P64[Hp - 48] = P64[Sp + 56];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           P64[Hp - 24] = P64[Sp + 80];
           P64[Hp - 16] = P64[Sp + 88];
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 104];
           I64[Sp + 104] = block_ccKaY_info;
           R3 = Hp - 112;
           R2 = _scHth::I64;
           Sp = Sp + 104;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKaY() //  [R1, R2]
         { info_tbl: [(ccKaY,
                       label: block_ccKaY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKaY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKb8; else goto ccKb7;
       ccKb8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKb7: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuE_entry() //  [R1]
         { info_tbl: [(ccKba,
                       label: sat_scHuE_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKba: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccKbe; else goto ccKbd;
       ccKbe: // global
           HpAlloc = 128;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKbd: // global
           _scHsd::P64 = P64[R1 + 16];
           _scHsn::P64 = P64[R1 + 24];
           _scHso::P64 = P64[R1 + 32];
           _scHsp::P64 = P64[R1 + 40];
           _scHss::P64 = P64[R1 + 48];
           _scHsx::P64 = P64[R1 + 56];
           _scHsC::P64 = P64[R1 + 64];
           _scHsH::P64 = P64[R1 + 72];
           _scHsM::P64 = P64[R1 + 80];
           _scHsR::P64 = P64[R1 + 88];
           _scHsW::P64 = P64[R1 + 96];
           _scHt1::P64 = P64[R1 + 104];
           _scHt6::P64 = P64[R1 + 112];
           _scHtc::P64 = P64[R1 + 120];
           I64[Hp - 120] = sat_scHuD_info;
           P64[Hp - 104] = _scHsd::P64;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 120;
           R2 = lvl2_rcHpx_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHuF_entry() //  [R1]
         { info_tbl: [(ccKbf,
                       label: sat_scHuF_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKbf: // global
           _scHuF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKbg; else goto ccKbh;
       ccKbh: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccKbj; else goto ccKbi;
       ccKbj: // global
           HpAlloc = 128;
           goto ccKbg;
       ccKbg: // global
           R1 = _scHuF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKbi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuF::P64;
           _scHsd::P64 = P64[_scHuF::P64 + 16];
           _scHsn::P64 = P64[_scHuF::P64 + 24];
           _scHso::P64 = P64[_scHuF::P64 + 32];
           _scHsp::P64 = P64[_scHuF::P64 + 40];
           _scHss::P64 = P64[_scHuF::P64 + 48];
           _scHsx::P64 = P64[_scHuF::P64 + 56];
           _scHsC::P64 = P64[_scHuF::P64 + 64];
           _scHsH::P64 = P64[_scHuF::P64 + 72];
           _scHsM::P64 = P64[_scHuF::P64 + 80];
           _scHsR::P64 = P64[_scHuF::P64 + 88];
           _scHsW::P64 = P64[_scHuF::P64 + 96];
           _scHt1::P64 = P64[_scHuF::P64 + 104];
           _scHt6::P64 = P64[_scHuF::P64 + 112];
           _scHtc::P64 = P64[_scHuF::P64 + 120];
           I64[Hp - 120] = sat_scHuE_info;
           P64[Hp - 104] = _scHsd::P64;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 120;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuJ_entry() //  [R1]
         { info_tbl: [(ccKbk,
                       label: sat_scHuJ_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKbk: // global
           if ((Sp + -136) < SpLim) (likely: False) goto ccKbr; else goto ccKbs;
       ccKbr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKbs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 136] = block_ccK3I_info;
           _scHsd::P64 = P64[R1 + 24];
           _scHsn::P64 = P64[R1 + 32];
           _scHso::P64 = P64[R1 + 40];
           _scHsp::P64 = P64[R1 + 48];
           _scHss::P64 = P64[R1 + 56];
           _scHsx::P64 = P64[R1 + 64];
           _scHsC::P64 = P64[R1 + 72];
           _scHsH::P64 = P64[R1 + 80];
           _scHsM::P64 = P64[R1 + 88];
           _scHsR::P64 = P64[R1 + 96];
           _scHsW::P64 = P64[R1 + 104];
           _scHt1::P64 = P64[R1 + 112];
           _scHt6::P64 = P64[R1 + 120];
           _scHtc::P64 = P64[R1 + 128];
           R1 = P64[R1 + 16];
           P64[Sp - 128] = _scHsd::P64;
           P64[Sp - 120] = _scHsn::P64;
           P64[Sp - 112] = _scHso::P64;
           P64[Sp - 104] = _scHsp::P64;
           P64[Sp - 96] = _scHss::P64;
           P64[Sp - 88] = _scHsx::P64;
           P64[Sp - 80] = _scHsC::P64;
           P64[Sp - 72] = _scHsH::P64;
           P64[Sp - 64] = _scHsM::P64;
           P64[Sp - 56] = _scHsR::P64;
           P64[Sp - 48] = _scHsW::P64;
           P64[Sp - 40] = _scHt1::P64;
           P64[Sp - 32] = _scHt6::P64;
           P64[Sp - 24] = _scHtc::P64;
           Sp = Sp - 136;
           if (R1 & 7 != 0) goto ucKbz; else goto ccK3J;
       ucKbz: // global
           call _ccK3I(R1) args: 0, res: 0, upd: 0;
       ccK3J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccK3I() //  [R1]
         { info_tbl: [(ccK3I,
                       label: block_ccK3I_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK3I: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccKbv; else goto ccKbu;
       ccKbv: // global
           HpAlloc = 128;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccKbu: // global
           _scHte::I64 = I64[R1 + 7];
           I64[Hp - 120] = sat_scHuF_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = P64[Sp + 16];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = P64[Sp + 56];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = P64[Sp + 72];
           P64[Hp - 32] = P64[Sp + 80];
           P64[Hp - 24] = P64[Sp + 88];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           I64[Sp + 112] = block_ccKbo_info;
           R3 = Hp - 120;
           R2 = _scHte::I64;
           Sp = Sp + 112;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKbo() //  [R1, R2]
         { info_tbl: [(ccKbo,
                       label: block_ccKbo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKbo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKby; else goto ccKbx;
       ccKby: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKbx: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuK_entry() //  [R1]
         { info_tbl: [(ccKbA,
                       label: sat_scHuK_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKbA: // global
           _scHuK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKbB; else goto ccKbC;
       ccKbC: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccKbE; else goto ccKbD;
       ccKbE: // global
           HpAlloc = 136;
           goto ccKbB;
       ccKbB: // global
           R1 = _scHuK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKbD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuK::P64;
           _scHsc::P64 = P64[_scHuK::P64 + 16];
           _scHsd::P64 = P64[_scHuK::P64 + 24];
           _scHsn::P64 = P64[_scHuK::P64 + 32];
           _scHso::P64 = P64[_scHuK::P64 + 40];
           _scHsp::P64 = P64[_scHuK::P64 + 48];
           _scHss::P64 = P64[_scHuK::P64 + 56];
           _scHsx::P64 = P64[_scHuK::P64 + 64];
           _scHsC::P64 = P64[_scHuK::P64 + 72];
           _scHsH::P64 = P64[_scHuK::P64 + 80];
           _scHsM::P64 = P64[_scHuK::P64 + 88];
           _scHsR::P64 = P64[_scHuK::P64 + 96];
           _scHsW::P64 = P64[_scHuK::P64 + 104];
           _scHt1::P64 = P64[_scHuK::P64 + 112];
           _scHt6::P64 = P64[_scHuK::P64 + 120];
           _scHtc::P64 = P64[_scHuK::P64 + 128];
           I64[Hp - 128] = sat_scHuJ_info;
           P64[Hp - 112] = _scHsc::P64;
           P64[Hp - 104] = _scHsd::P64;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = _scHtc::P64;
           R3 = Hp - 128;
           R2 = lvl1_rcHpw_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_scHtb_entry() //  [R1, R2]
         { info_tbl: [(ccKbF,
                       label: p_scHtb_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKbF: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccKbJ; else goto ccKbI;
       ccKbJ: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKbI: // global
           _scHsc::P64 = P64[R1 + 7];
           _scHsd::P64 = P64[R1 + 15];
           _scHsn::P64 = P64[R1 + 23];
           _scHso::P64 = P64[R1 + 31];
           _scHsp::P64 = P64[R1 + 39];
           _scHss::P64 = P64[R1 + 47];
           _scHsx::P64 = P64[R1 + 55];
           _scHsC::P64 = P64[R1 + 63];
           _scHsH::P64 = P64[R1 + 71];
           _scHsM::P64 = P64[R1 + 79];
           _scHsR::P64 = P64[R1 + 87];
           _scHsW::P64 = P64[R1 + 95];
           _scHt1::P64 = P64[R1 + 103];
           _scHt6::P64 = P64[R1 + 111];
           I64[Hp - 128] = sat_scHuK_info;
           P64[Hp - 112] = _scHsc::P64;
           P64[Hp - 104] = _scHsd::P64;
           P64[Hp - 96] = _scHsn::P64;
           P64[Hp - 88] = _scHso::P64;
           P64[Hp - 80] = _scHsp::P64;
           P64[Hp - 72] = _scHss::P64;
           P64[Hp - 64] = _scHsx::P64;
           P64[Hp - 56] = _scHsC::P64;
           P64[Hp - 48] = _scHsH::P64;
           P64[Hp - 40] = _scHsM::P64;
           P64[Hp - 32] = _scHsR::P64;
           P64[Hp - 24] = _scHsW::P64;
           P64[Hp - 16] = _scHt1::P64;
           P64[Hp - 8] = _scHt6::P64;
           P64[Hp] = R2;
           R3 = Hp - 128;
           R2 = lvl_rcHpv_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHuO_entry() //  [R1]
         { info_tbl: [(ccKbY,
                       label: sat_scHuO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKbY: // global
           _scHuO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKbZ; else goto ccKc0;
       ccKc0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKc2; else goto ccKc1;
       ccKc2: // global
           HpAlloc = 24;
           goto ccKbZ;
       ccKbZ: // global
           R1 = _scHuO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKc1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHuO::P64;
           _scHtb::P64 = P64[_scHuO::P64 + 16];
           _scHuM::P64 = P64[_scHuO::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _scHuM::P64;
           R2 = Hp - 14;
           R1 = _scHtb::P64;
           Sp = Sp - 16;
           call p_scHtb_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHuP_entry() //  [R1, R2]
         { info_tbl: [(ccKc4,
                       label: sat_scHuP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKc4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccKc8; else goto ccKc7;
       ccKc8: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKc7: // global
           _scHtb::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_scHuO_info;
           P64[Hp - 32] = _scHtb::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stats.$fShowGCDetails_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(ccKc9,
                       label: GHC.Stats.$fShowGCDetails_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKc9: // global
           if ((Sp + -120) < SpLim) (likely: False) goto ccKca; else goto ccKcb;
       ccKca: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fShowGCDetails_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccKcb: // global
           I64[Sp - 16] = block_ccK09_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucKck; else goto ccK0a;
       ucKck: // global
           call _ccK09(R1) args: 0, res: 0, upd: 0;
       ccK0a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccK09() //  [R1]
         { info_tbl: [(ccK09,
                       label: block_ccK09_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK09: // global
           I64[Sp - 104] = block_ccK0e_info;
           _scHsc::P64 = P64[R1 + 7];
           _scHsd::P64 = P64[R1 + 15];
           _scHse::P64 = P64[R1 + 23];
           _scHsf::P64 = P64[R1 + 31];
           _scHsg::P64 = P64[R1 + 39];
           _scHsh::P64 = P64[R1 + 47];
           _scHsi::P64 = P64[R1 + 55];
           _scHsj::P64 = P64[R1 + 63];
           _scHsk::P64 = P64[R1 + 71];
           _scHsl::P64 = P64[R1 + 79];
           _scHsm::P64 = P64[R1 + 87];
           _scHsn::P64 = P64[R1 + 95];
           _scHso::P64 = P64[R1 + 103];
           _scHsp::P64 = P64[R1 + 111];
           R1 = P64[Sp + 8];
           P64[Sp - 96] = _scHse::P64;
           P64[Sp - 88] = _scHsf::P64;
           P64[Sp - 80] = _scHsg::P64;
           P64[Sp - 72] = _scHsh::P64;
           P64[Sp - 64] = _scHsi::P64;
           P64[Sp - 56] = _scHsj::P64;
           P64[Sp - 48] = _scHsk::P64;
           P64[Sp - 40] = _scHsl::P64;
           P64[Sp - 32] = _scHsm::P64;
           P64[Sp - 24] = _scHsn::P64;
           P64[Sp - 16] = _scHso::P64;
           P64[Sp - 8] = _scHsp::P64;
           P64[Sp] = _scHsd::P64;
           P64[Sp + 8] = _scHsc::P64;
           Sp = Sp - 104;
           if (R1 & 7 != 0) goto ucKcj; else goto ccK0f;
       ucKcj: // global
           call _ccK0e(R1) args: 0, res: 0, upd: 0;
       ccK0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccK0e() //  [R1]
         { info_tbl: [(ccK0e,
                       label: block_ccK0e_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccK0e: // global
           Hp = Hp + 352;
           if (Hp > HpLim) (likely: False) goto ccKcf; else goto ccKce;
       ccKcf: // global
           HpAlloc = 352;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKce: // global
           _scHsr::I64 = I64[R1 + 7];
           I64[Hp - 344] = w1_scHss_info;
           P64[Hp - 328] = P64[Sp + 8];
           I64[Hp - 320] = w2_scHsx_info;
           P64[Hp - 304] = P64[Sp + 16];
           I64[Hp - 296] = w3_scHsC_info;
           P64[Hp - 280] = P64[Sp + 24];
           I64[Hp - 272] = w4_scHsH_info;
           P64[Hp - 256] = P64[Sp + 32];
           I64[Hp - 248] = w5_scHsM_info;
           P64[Hp - 232] = P64[Sp + 40];
           I64[Hp - 224] = w6_scHsR_info;
           P64[Hp - 208] = P64[Sp + 48];
           I64[Hp - 200] = w7_scHsW_info;
           P64[Hp - 184] = P64[Sp + 56];
           I64[Hp - 176] = w8_scHt1_info;
           P64[Hp - 160] = P64[Sp + 64];
           I64[Hp - 152] = w9_scHt6_info;
           P64[Hp - 136] = P64[Sp + 72];
           I64[Hp - 128] = p_scHtb_info;
           P64[Hp - 120] = P64[Sp + 112];
           P64[Hp - 112] = P64[Sp + 104];
           P64[Hp - 104] = P64[Sp + 80];
           P64[Hp - 96] = P64[Sp + 88];
           P64[Hp - 88] = P64[Sp + 96];
           P64[Hp - 80] = Hp - 344;
           P64[Hp - 72] = Hp - 320;
           P64[Hp - 64] = Hp - 296;
           P64[Hp - 56] = Hp - 272;
           P64[Hp - 48] = Hp - 248;
           P64[Hp - 40] = Hp - 224;
           P64[Hp - 32] = Hp - 200;
           P64[Hp - 24] = Hp - 176;
           P64[Hp - 16] = Hp - 152;
           _ccK3v::P64 = Hp - 127;
           if (%MO_S_Lt_W64(_scHsr::I64, 11)) goto ccKch; else goto ccKci;
       ccKch: // global
           Hp = Hp - 16;
           R1 = _ccK3v::P64;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccKci: // global
           I64[Hp - 8] = sat_scHuP_info;
           P64[Hp] = _ccK3v::P64;
           R1 = Hp - 7;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.862531931 UTC

[section ""data" . GHC.Stats.$fShowGCDetails2_closure" {
     GHC.Stats.$fShowGCDetails2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.864639745 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_$cshow_closure" {
     GHC.Stats.$fShowGCDetails_$cshow_closure:
         const GHC.Stats.$fShowGCDetails_$cshow_info;
         const 0;
 },
 GHC.Stats.$fShowGCDetails_$cshow_entry() //  [R2]
         { info_tbl: [(ccKiE,
                       label: GHC.Stats.$fShowGCDetails_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKiE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKiF; else goto ccKiG;
       ccKiF: // global
           R2 = R2;
           R1 = GHC.Stats.$fShowGCDetails_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKiG: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Stats.$fShowGCDetails_$cshowsPrec_entry(R3,
                                                            R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.869325363 UTC

[section ""data" . GHC.Stats.$fShowGCDetails1_closure" {
     GHC.Stats.$fShowGCDetails1_closure:
         const GHC.Stats.$fShowGCDetails1_info;
         const 0;
 },
 GHC.Stats.$fShowGCDetails1_entry() //  [R2]
         { info_tbl: [(ccKiQ,
                       label: GHC.Stats.$fShowGCDetails1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKiQ: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           call GHC.Stats.$fShowGCDetails_$cshowsPrec_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.873031809 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_$cshowList_closure" {
     GHC.Stats.$fShowGCDetails_$cshowList_closure:
         const GHC.Stats.$fShowGCDetails_$cshowList_info;
         const 0;
 },
 GHC.Stats.$fShowGCDetails_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(ccKj1,
                       label: GHC.Stats.$fShowGCDetails_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKj1: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.877111731 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_closure" {
     GHC.Stats.$fShowGCDetails_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Stats.$fShowGCDetails_$cshowsPrec_closure+2;
         const GHC.Stats.$fShowGCDetails_$cshow_closure+1;
         const GHC.Stats.$fShowGCDetails_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.878982327 UTC

[section ""cstring" . lvl16_rcHpL_bytes" {
     lvl16_rcHpL_bytes:
         I8[] [82,84,83,83,116,97,116,115,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.880671637 UTC

[section ""cstring" . lvl17_rcHpM_bytes" {
     lvl17_rcHpM_bytes:
         I8[] [103,99,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.882745103 UTC

[section ""cstring" . lvl18_rcHpN_bytes" {
     lvl18_rcHpN_bytes:
         I8[] [109,97,106,111,114,95,103,99,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.884498366 UTC

[section ""cstring" . lvl19_rcHpO_bytes" {
     lvl19_rcHpO_bytes:
         I8[] [97,108,108,111,99,97,116,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.886220324 UTC

[section ""cstring" . lvl20_rcHpP_bytes" {
     lvl20_rcHpP_bytes:
         I8[] [109,97,120,95,108,105,118,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.887931566 UTC

[section ""cstring" . lvl21_rcHpQ_bytes" {
     lvl21_rcHpQ_bytes:
         I8[] [109,97,120,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.889676549 UTC

[section ""cstring" . lvl22_rcHpR_bytes" {
     lvl22_rcHpR_bytes:
         I8[] [109,97,120,95,99,111,109,112,97,99,116,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.891411007 UTC

[section ""cstring" . lvl23_rcHpS_bytes" {
     lvl23_rcHpS_bytes:
         I8[] [109,97,120,95,115,108,111,112,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.893164748 UTC

[section ""cstring" . lvl24_rcHpT_bytes" {
     lvl24_rcHpT_bytes:
         I8[] [109,97,120,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.894979886 UTC

[section ""cstring" . lvl25_rcHpU_bytes" {
     lvl25_rcHpU_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,108,105,118,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.896794608 UTC

[section ""cstring" . lvl26_rcHpV_bytes" {
     lvl26_rcHpV_bytes:
         I8[] [99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.899048911 UTC

[section ""cstring" . lvl27_rcHpW_bytes" {
     lvl27_rcHpW_bytes:
         I8[] [112,97,114,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.900881111 UTC

[section ""cstring" . lvl28_rcHpX_bytes" {
     lvl28_rcHpX_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.903154055 UTC

[section ""cstring" . lvl29_rcHpY_bytes" {
     lvl29_rcHpY_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.904801837 UTC

[section ""cstring" . lvl30_rcHpZ_bytes" {
     lvl30_rcHpZ_bytes:
         I8[] [109,117,116,97,116,111,114,95,99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.906518457 UTC

[section ""cstring" . lvl31_rcHq0_bytes" {
     lvl31_rcHq0_bytes:
         I8[] [109,117,116,97,116,111,114,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.908252488 UTC

[section ""cstring" . lvl32_rcHq1_bytes" {
     lvl32_rcHq1_bytes:
         I8[] [103,99,95,99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.909898108 UTC

[section ""cstring" . lvl33_rcHq2_bytes" {
     lvl33_rcHq2_bytes:
         I8[] [103,99,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.91155536 UTC

[section ""cstring" . lvl34_rcHq3_bytes" {
     lvl34_rcHq3_bytes:
         I8[] [99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.913176998 UTC

[section ""cstring" . lvl35_rcHq4_bytes" {
     lvl35_rcHq4_bytes:
         I8[] [101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.915028459 UTC

[section ""cstring" . lvl36_rcHq5_bytes" {
     lvl36_rcHq5_bytes:
         I8[] [103,99,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:36.938428059 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_$cshowsPrec_closure" {
     GHC.Stats.$fShowRTSStats_$cshowsPrec_closure:
         const GHC.Stats.$fShowRTSStats_$cshowsPrec_info;
         const 0;
 },
 w1_scHvi_entry() //  [R1]
         { info_tbl: [(ccKjP,
                       label: w1_scHvi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKjP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccKjQ; else goto ccKjR;
       ccKjQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKjR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccKjM_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucKk3; else goto ccKjN;
       ucKk3: // global
           call _ccKjM(R1) args: 0, res: 0, upd: 0;
       ccKjN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKjM() //  [R1]
         { info_tbl: [(ccKjM,
                       label: block_ccKjM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKjM: // global
           _scHvk::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvk::I64, 0)) goto ccKk1; else goto ccKk2;
       ccKk1: // global
           R2 = _scHvk::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccKk2: // global
           R2 = _scHvk::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w2_scHvn_entry() //  [R1]
         { info_tbl: [(ccKkb,
                       label: w2_scHvn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKkb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccKkc; else goto ccKkd;
       ccKkc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKkd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccKk8_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucKkp; else goto ccKk9;
       ucKkp: // global
           call _ccKk8(R1) args: 0, res: 0, upd: 0;
       ccKk9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKk8() //  [R1]
         { info_tbl: [(ccKk8,
                       label: block_ccKk8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKk8: // global
           _scHvp::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvp::I64, 0)) goto ccKkn; else goto ccKko;
       ccKkn: // global
           R2 = _scHvp::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccKko: // global
           R2 = _scHvp::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w3_scHvs_entry() //  [R1]
         { info_tbl: [(ccKkx,
                       label: w3_scHvs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKkx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccKky; else goto ccKkz;
       ccKky: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKkz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccKku_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucKkL; else goto ccKkv;
       ucKkL: // global
           call _ccKku(R1) args: 0, res: 0, upd: 0;
       ccKkv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKku() //  [R1]
         { info_tbl: [(ccKku,
                       label: block_ccKku_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKku: // global
           _scHvu::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvu::I64, 0)) goto ccKkJ; else goto ccKkK;
       ccKkJ: // global
           R2 = _scHvu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccKkK: // global
           R2 = _scHvu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w4_scHvx_entry() //  [R1]
         { info_tbl: [(ccKkT,
                       label: w4_scHvx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKkT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccKkU; else goto ccKkV;
       ccKkU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKkV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccKkQ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucKl7; else goto ccKkR;
       ucKl7: // global
           call _ccKkQ(R1) args: 0, res: 0, upd: 0;
       ccKkR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKkQ() //  [R1]
         { info_tbl: [(ccKkQ,
                       label: block_ccKkQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKkQ: // global
           _scHvz::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvz::I64, 0)) goto ccKl5; else goto ccKl6;
       ccKl5: // global
           R2 = _scHvz::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccKl6: // global
           R2 = _scHvz::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_scHvC_entry() //  [R1]
         { info_tbl: [(ccKlf,
                       label: w5_scHvC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKlf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccKlg; else goto ccKlh;
       ccKlg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKlh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccKlc_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucKlt; else goto ccKld;
       ucKlt: // global
           call _ccKlc(R1) args: 0, res: 0, upd: 0;
       ccKld: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKlc() //  [R1]
         { info_tbl: [(ccKlc,
                       label: block_ccKlc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKlc: // global
           _scHvE::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvE::I64, 0)) goto ccKlr; else goto ccKls;
       ccKlr: // global
           R2 = _scHvE::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccKls: // global
           R2 = _scHvE::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_scHvH_entry() //  [R1]
         { info_tbl: [(ccKlB,
                       label: w6_scHvH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKlB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccKlC; else goto ccKlD;
       ccKlC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKlD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccKly_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucKlP; else goto ccKlz;
       ucKlP: // global
           call _ccKly(R1) args: 0, res: 0, upd: 0;
       ccKlz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKly() //  [R1]
         { info_tbl: [(ccKly,
                       label: block_ccKly_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKly: // global
           _scHvJ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvJ::I64, 0)) goto ccKlN; else goto ccKlO;
       ccKlN: // global
           R2 = _scHvJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccKlO: // global
           R2 = _scHvJ::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_scHvM_entry() //  [R1]
         { info_tbl: [(ccKlX,
                       label: w7_scHvM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKlX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccKlY; else goto ccKlZ;
       ccKlY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKlZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccKlU_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucKmb; else goto ccKlV;
       ucKmb: // global
           call _ccKlU(R1) args: 0, res: 0, upd: 0;
       ccKlV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKlU() //  [R1]
         { info_tbl: [(ccKlU,
                       label: block_ccKlU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKlU: // global
           _scHvO::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvO::I64, 0)) goto ccKm9; else goto ccKma;
       ccKm9: // global
           R2 = _scHvO::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccKma: // global
           R2 = _scHvO::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w8_scHvR_entry() //  [R1]
         { info_tbl: [(ccKmj,
                       label: w8_scHvR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKmj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccKmk; else goto ccKml;
       ccKmk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKml: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccKmg_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucKmx; else goto ccKmh;
       ucKmx: // global
           call _ccKmg(R1) args: 0, res: 0, upd: 0;
       ccKmh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKmg() //  [R1]
         { info_tbl: [(ccKmg,
                       label: block_ccKmg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKmg: // global
           _scHvT::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvT::I64, 0)) goto ccKmv; else goto ccKmw;
       ccKmv: // global
           R2 = _scHvT::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccKmw: // global
           R2 = _scHvT::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w9_scHvW_entry() //  [R1]
         { info_tbl: [(ccKmF,
                       label: w9_scHvW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKmF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccKmG; else goto ccKmH;
       ccKmG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKmH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccKmC_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucKmT; else goto ccKmD;
       ucKmT: // global
           call _ccKmC(R1) args: 0, res: 0, upd: 0;
       ccKmD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKmC() //  [R1]
         { info_tbl: [(ccKmC,
                       label: block_ccKmC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKmC: // global
           _scHvY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHvY::I64, 0)) goto ccKmR; else goto ccKmS;
       ccKmR: // global
           R2 = _scHvY::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccKmS: // global
           R2 = _scHvY::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w10_scHw1_entry() //  [R1]
         { info_tbl: [(ccKn1,
                       label: w10_scHw1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKn1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccKn2; else goto ccKn3;
       ccKn2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKn3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccKmY_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucKnf; else goto ccKmZ;
       ucKnf: // global
           call _ccKmY(R1) args: 0, res: 0, upd: 0;
       ccKmZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKmY() //  [R1]
         { info_tbl: [(ccKmY,
                       label: block_ccKmY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKmY: // global
           _scHw3::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHw3::I64, 0)) goto ccKnd; else goto ccKne;
       ccKnd: // global
           R2 = _scHw3::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccKne: // global
           R2 = _scHw3::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w11_scHw6_entry() //  [R1]
         { info_tbl: [(ccKnn,
                       label: w11_scHw6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKnn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccKno; else goto ccKnp;
       ccKno: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKnp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccKnk_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucKnB; else goto ccKnl;
       ucKnB: // global
           call _ccKnk(R1) args: 0, res: 0, upd: 0;
       ccKnl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKnk() //  [R1]
         { info_tbl: [(ccKnk,
                       label: block_ccKnk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKnk: // global
           _scHw8::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scHw8::I64, 0)) goto ccKnz; else goto ccKnA;
       ccKnz: // global
           R2 = _scHw8::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccKnA: // global
           R2 = _scHw8::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 f_scHwb_entry() //  [R1]
         { info_tbl: [(ccKnG,
                       label: f_scHwb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKnG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKnH; else goto ccKnI;
       ccKnH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKnI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           Sp = Sp - 16;
           call GHC.Stats.$fShowGCDetails_$cshowsPrec_entry(R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHww_entry() //  [R1]
         { info_tbl: [(ccKsk,
                       label: sat_scHww_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKsk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKsl; else goto ccKsm;
       ccKsl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKsm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = lvl15_rcHpK_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwx_entry() //  [R1]
         { info_tbl: [(ccKsn,
                       label: sat_scHwx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKsn: // global
           _scHwx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKso; else goto ccKsp;
       ccKsp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKsr; else goto ccKsq;
       ccKsr: // global
           HpAlloc = 24;
           goto ccKso;
       ccKso: // global
           R1 = _scHwx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKsq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwx::P64;
           _scHwb::P64 = P64[_scHwx::P64 + 16];
           _scHwd::P64 = P64[_scHwx::P64 + 24];
           I64[Hp - 16] = sat_scHww_info;
           P64[Hp] = _scHwd::P64;
           R2 = Hp - 16;
           R1 = _scHwb::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwy_entry() //  [R1]
         { info_tbl: [(ccKss,
                       label: sat_scHwy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKss: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccKsw; else goto ccKsv;
       ccKsw: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKsv: // global
           _scHwb::P64 = P64[R1 + 16];
           _scHwd::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_scHwx_info;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 24;
           R2 = lvl36_rcHq5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwz_entry() //  [R1]
         { info_tbl: [(ccKsx,
                       label: sat_scHwz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKsx: // global
           _scHwz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKsy; else goto ccKsz;
       ccKsz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccKsB; else goto ccKsA;
       ccKsB: // global
           HpAlloc = 32;
           goto ccKsy;
       ccKsy: // global
           R1 = _scHwz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKsA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwz::P64;
           _scHwb::P64 = P64[_scHwz::P64 + 16];
           _scHwd::P64 = P64[_scHwz::P64 + 24];
           I64[Hp - 24] = sat_scHwy_info;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwD_entry() //  [R1]
         { info_tbl: [(ccKsC,
                       label: sat_scHwD_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKsC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccKsG; else goto ccKsH;
       ccKsG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKsH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccKrZ_info;
           _scHwb::P64 = P64[R1 + 24];
           _scHwd::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucKsO; else goto ccKs0;
       ucKsO: // global
           call _ccKrZ(R1) args: 0, res: 0, upd: 0;
       ccKs0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKrZ() //  [R1]
         { info_tbl: [(ccKrZ,
                       label: block_ccKrZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKrZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccKsK; else goto ccKsJ;
       ccKsK: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccKsJ: // global
           _scHwv::I64 = I64[R1 + 7];
           I64[Hp - 24] = sat_scHwz_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_ccKsD_info;
           R4 = Hp - 24;
           R3 = _scHwv::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKsD() //  [R1, R2]
         { info_tbl: [(ccKsD,
                       label: block_ccKsD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKsD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKsN; else goto ccKsM;
       ccKsN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKsM: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwE_entry() //  [R1]
         { info_tbl: [(ccKsP,
                       label: sat_scHwE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKsP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccKsT; else goto ccKsS;
       ccKsT: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKsS: // global
           _scHve::P64 = P64[R1 + 16];
           _scHwb::P64 = P64[R1 + 24];
           _scHwd::P64 = P64[R1 + 32];
           I64[Hp - 32] = sat_scHwD_info;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 32;
           R2 = lvl35_rcHq4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwF_entry() //  [R1]
         { info_tbl: [(ccKsU,
                       label: sat_scHwF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKsU: // global
           _scHwF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKsV; else goto ccKsW;
       ccKsW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccKsY; else goto ccKsX;
       ccKsY: // global
           HpAlloc = 40;
           goto ccKsV;
       ccKsV: // global
           R1 = _scHwF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKsX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwF::P64;
           _scHve::P64 = P64[_scHwF::P64 + 16];
           _scHwb::P64 = P64[_scHwF::P64 + 24];
           _scHwd::P64 = P64[_scHwF::P64 + 32];
           I64[Hp - 32] = sat_scHwE_info;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwJ_entry() //  [R1]
         { info_tbl: [(ccKsZ,
                       label: sat_scHwJ_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKsZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccKt3; else goto ccKt4;
       ccKt3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKt4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccKrI_info;
           _scHve::P64 = P64[R1 + 24];
           _scHwb::P64 = P64[R1 + 32];
           _scHwd::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucKtb; else goto ccKrJ;
       ucKtb: // global
           call _ccKrI(R1) args: 0, res: 0, upd: 0;
       ccKrJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKrI() //  [R1]
         { info_tbl: [(ccKrI,
                       label: block_ccKrI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKrI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccKt7; else goto ccKt6;
       ccKt7: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccKt6: // global
           _scHwt::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_scHwF_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_ccKt0_info;
           R4 = Hp - 32;
           R3 = _scHwt::I64;
           R2 = 0;
           Sp = Sp + 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKt0() //  [R1, R2]
         { info_tbl: [(ccKt0,
                       label: block_ccKt0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKt0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKta; else goto ccKt9;
       ccKta: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKt9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwK_entry() //  [R1]
         { info_tbl: [(ccKtc,
                       label: sat_scHwK_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKtc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccKtg; else goto ccKtf;
       ccKtg: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKtf: // global
           _scHvd::P64 = P64[R1 + 16];
           _scHve::P64 = P64[R1 + 24];
           _scHwb::P64 = P64[R1 + 32];
           _scHwd::P64 = P64[R1 + 40];
           I64[Hp - 40] = sat_scHwJ_info;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 40;
           R2 = lvl34_rcHq3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwL_entry() //  [R1]
         { info_tbl: [(ccKth,
                       label: sat_scHwL_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKth: // global
           _scHwL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKti; else goto ccKtj;
       ccKtj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccKtl; else goto ccKtk;
       ccKtl: // global
           HpAlloc = 48;
           goto ccKti;
       ccKti: // global
           R1 = _scHwL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKtk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwL::P64;
           _scHvd::P64 = P64[_scHwL::P64 + 16];
           _scHve::P64 = P64[_scHwL::P64 + 24];
           _scHwb::P64 = P64[_scHwL::P64 + 32];
           _scHwd::P64 = P64[_scHwL::P64 + 40];
           I64[Hp - 40] = sat_scHwK_info;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 40;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwP_entry() //  [R1]
         { info_tbl: [(ccKtm,
                       label: sat_scHwP_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKtm: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccKtq; else goto ccKtr;
       ccKtq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKtr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_ccKrr_info;
           _scHvd::P64 = P64[R1 + 24];
           _scHve::P64 = P64[R1 + 32];
           _scHwb::P64 = P64[R1 + 40];
           _scHwd::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _scHvd::P64;
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ucKty; else goto ccKrs;
       ucKty: // global
           call _ccKrr(R1) args: 0, res: 0, upd: 0;
       ccKrs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKrr() //  [R1]
         { info_tbl: [(ccKrr,
                       label: block_ccKrr_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKrr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccKtu; else goto ccKtt;
       ccKtu: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccKtt: // global
           _scHwr::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_scHwL_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           I64[Sp + 32] = block_ccKtn_info;
           R4 = Hp - 40;
           R3 = _scHwr::I64;
           R2 = 0;
           Sp = Sp + 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKtn() //  [R1, R2]
         { info_tbl: [(ccKtn,
                       label: block_ccKtn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKtn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKtx; else goto ccKtw;
       ccKtx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKtw: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwQ_entry() //  [R1]
         { info_tbl: [(ccKtz,
                       label: sat_scHwQ_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKtz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccKtD; else goto ccKtC;
       ccKtD: // global
           HpAlloc = 56;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKtC: // global
           _scHvc::P64 = P64[R1 + 16];
           _scHvd::P64 = P64[R1 + 24];
           _scHve::P64 = P64[R1 + 32];
           _scHwb::P64 = P64[R1 + 40];
           _scHwd::P64 = P64[R1 + 48];
           I64[Hp - 48] = sat_scHwP_info;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 48;
           R2 = lvl33_rcHq2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwR_entry() //  [R1]
         { info_tbl: [(ccKtE,
                       label: sat_scHwR_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKtE: // global
           _scHwR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKtF; else goto ccKtG;
       ccKtG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccKtI; else goto ccKtH;
       ccKtI: // global
           HpAlloc = 56;
           goto ccKtF;
       ccKtF: // global
           R1 = _scHwR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKtH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwR::P64;
           _scHvc::P64 = P64[_scHwR::P64 + 16];
           _scHvd::P64 = P64[_scHwR::P64 + 24];
           _scHve::P64 = P64[_scHwR::P64 + 32];
           _scHwb::P64 = P64[_scHwR::P64 + 40];
           _scHwd::P64 = P64[_scHwR::P64 + 48];
           I64[Hp - 48] = sat_scHwQ_info;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 48;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwV_entry() //  [R1]
         { info_tbl: [(ccKtJ,
                       label: sat_scHwV_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKtJ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccKtN; else goto ccKtO;
       ccKtN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKtO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_ccKra_info;
           _scHvc::P64 = P64[R1 + 24];
           _scHvd::P64 = P64[R1 + 32];
           _scHve::P64 = P64[R1 + 40];
           _scHwb::P64 = P64[R1 + 48];
           _scHwd::P64 = P64[R1 + 56];
           R1 = P64[R1 + 16];
           P64[Sp - 56] = _scHvc::P64;
           P64[Sp - 48] = _scHvd::P64;
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ucKtV; else goto ccKrb;
       ucKtV: // global
           call _ccKra(R1) args: 0, res: 0, upd: 0;
       ccKrb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKra() //  [R1]
         { info_tbl: [(ccKra,
                       label: block_ccKra_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKra: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccKtR; else goto ccKtQ;
       ccKtR: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccKtQ: // global
           _scHwp::I64 = I64[R1 + 7];
           I64[Hp - 48] = sat_scHwR_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 40] = block_ccKtK_info;
           R4 = Hp - 48;
           R3 = _scHwp::I64;
           R2 = 0;
           Sp = Sp + 40;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKtK() //  [R1, R2]
         { info_tbl: [(ccKtK,
                       label: block_ccKtK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKtK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKtU; else goto ccKtT;
       ccKtU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKtT: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHwW_entry() //  [R1]
         { info_tbl: [(ccKtW,
                       label: sat_scHwW_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKtW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccKu0; else goto ccKtZ;
       ccKu0: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKtZ: // global
           _scHvb::P64 = P64[R1 + 16];
           _scHvc::P64 = P64[R1 + 24];
           _scHvd::P64 = P64[R1 + 32];
           _scHve::P64 = P64[R1 + 40];
           _scHwb::P64 = P64[R1 + 48];
           _scHwd::P64 = P64[R1 + 56];
           I64[Hp - 56] = sat_scHwV_info;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 56;
           R2 = lvl32_rcHq1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHwX_entry() //  [R1]
         { info_tbl: [(ccKu1,
                       label: sat_scHwX_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKu1: // global
           _scHwX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKu2; else goto ccKu3;
       ccKu3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccKu5; else goto ccKu4;
       ccKu5: // global
           HpAlloc = 64;
           goto ccKu2;
       ccKu2: // global
           R1 = _scHwX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKu4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHwX::P64;
           _scHvb::P64 = P64[_scHwX::P64 + 16];
           _scHvc::P64 = P64[_scHwX::P64 + 24];
           _scHvd::P64 = P64[_scHwX::P64 + 32];
           _scHve::P64 = P64[_scHwX::P64 + 40];
           _scHwb::P64 = P64[_scHwX::P64 + 48];
           _scHwd::P64 = P64[_scHwX::P64 + 56];
           I64[Hp - 56] = sat_scHwW_info;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 56;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHx1_entry() //  [R1]
         { info_tbl: [(ccKu6,
                       label: sat_scHx1_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKu6: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccKua; else goto ccKub;
       ccKua: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKub: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_ccKqT_info;
           _scHvb::P64 = P64[R1 + 24];
           _scHvc::P64 = P64[R1 + 32];
           _scHvd::P64 = P64[R1 + 40];
           _scHve::P64 = P64[R1 + 48];
           _scHwb::P64 = P64[R1 + 56];
           _scHwd::P64 = P64[R1 + 64];
           R1 = P64[R1 + 16];
           P64[Sp - 64] = _scHvb::P64;
           P64[Sp - 56] = _scHvc::P64;
           P64[Sp - 48] = _scHvd::P64;
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto ucKui; else goto ccKqU;
       ucKui: // global
           call _ccKqT(R1) args: 0, res: 0, upd: 0;
       ccKqU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKqT() //  [R1]
         { info_tbl: [(ccKqT,
                       label: block_ccKqT_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKqT: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccKue; else goto ccKud;
       ccKue: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccKud: // global
           _scHwn::I64 = I64[R1 + 7];
           I64[Hp - 56] = sat_scHwX_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 48];
           I64[Sp + 48] = block_ccKu7_info;
           R4 = Hp - 56;
           R3 = _scHwn::I64;
           R2 = 0;
           Sp = Sp + 48;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKu7() //  [R1, R2]
         { info_tbl: [(ccKu7,
                       label: block_ccKu7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKu7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKuh; else goto ccKug;
       ccKuh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKug: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHx2_entry() //  [R1]
         { info_tbl: [(ccKuj,
                       label: sat_scHx2_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKuj: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccKun; else goto ccKum;
       ccKun: // global
           HpAlloc = 72;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKum: // global
           _scHva::P64 = P64[R1 + 16];
           _scHvb::P64 = P64[R1 + 24];
           _scHvc::P64 = P64[R1 + 32];
           _scHvd::P64 = P64[R1 + 40];
           _scHve::P64 = P64[R1 + 48];
           _scHwb::P64 = P64[R1 + 56];
           _scHwd::P64 = P64[R1 + 64];
           I64[Hp - 64] = sat_scHx1_info;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 64;
           R2 = lvl31_rcHq0_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHx3_entry() //  [R1]
         { info_tbl: [(ccKuo,
                       label: sat_scHx3_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKuo: // global
           _scHx3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKup; else goto ccKuq;
       ccKuq: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccKus; else goto ccKur;
       ccKus: // global
           HpAlloc = 72;
           goto ccKup;
       ccKup: // global
           R1 = _scHx3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKur: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHx3::P64;
           _scHva::P64 = P64[_scHx3::P64 + 16];
           _scHvb::P64 = P64[_scHx3::P64 + 24];
           _scHvc::P64 = P64[_scHx3::P64 + 32];
           _scHvd::P64 = P64[_scHx3::P64 + 40];
           _scHve::P64 = P64[_scHx3::P64 + 48];
           _scHwb::P64 = P64[_scHx3::P64 + 56];
           _scHwd::P64 = P64[_scHx3::P64 + 64];
           I64[Hp - 64] = sat_scHx2_info;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 64;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHx7_entry() //  [R1]
         { info_tbl: [(ccKut,
                       label: sat_scHx7_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKut: // global
           if ((Sp + -80) < SpLim) (likely: False) goto ccKux; else goto ccKuy;
       ccKux: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKuy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 80] = block_ccKqC_info;
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHwb::P64 = P64[R1 + 64];
           _scHwd::P64 = P64[R1 + 72];
           R1 = P64[R1 + 16];
           P64[Sp - 72] = _scHva::P64;
           P64[Sp - 64] = _scHvb::P64;
           P64[Sp - 56] = _scHvc::P64;
           P64[Sp - 48] = _scHvd::P64;
           P64[Sp - 40] = _scHve::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto ucKuF; else goto ccKqD;
       ucKuF: // global
           call _ccKqC(R1) args: 0, res: 0, upd: 0;
       ccKqD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKqC() //  [R1]
         { info_tbl: [(ccKqC,
                       label: block_ccKqC_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKqC: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccKuB; else goto ccKuA;
       ccKuB: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccKuA: // global
           _scHwl::I64 = I64[R1 + 7];
           I64[Hp - 64] = sat_scHx3_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 56];
           I64[Sp + 56] = block_ccKuu_info;
           R4 = Hp - 64;
           R3 = _scHwl::I64;
           R2 = 0;
           Sp = Sp + 56;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKuu() //  [R1, R2]
         { info_tbl: [(ccKuu,
                       label: block_ccKuu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKuu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKuE; else goto ccKuD;
       ccKuE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKuD: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHx8_entry() //  [R1]
         { info_tbl: [(ccKuG,
                       label: sat_scHx8_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKuG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccKuK; else goto ccKuJ;
       ccKuK: // global
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKuJ: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHwb::P64 = P64[R1 + 64];
           _scHwd::P64 = P64[R1 + 72];
           I64[Hp - 72] = sat_scHx7_info;
           P64[Hp - 56] = _scHv9::P64;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 72;
           R2 = lvl30_rcHpZ_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHx9_entry() //  [R1]
         { info_tbl: [(ccKuL,
                       label: sat_scHx9_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKuL: // global
           _scHx9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKuM; else goto ccKuN;
       ccKuN: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccKuP; else goto ccKuO;
       ccKuP: // global
           HpAlloc = 80;
           goto ccKuM;
       ccKuM: // global
           R1 = _scHx9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKuO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHx9::P64;
           _scHv9::P64 = P64[_scHx9::P64 + 16];
           _scHva::P64 = P64[_scHx9::P64 + 24];
           _scHvb::P64 = P64[_scHx9::P64 + 32];
           _scHvc::P64 = P64[_scHx9::P64 + 40];
           _scHvd::P64 = P64[_scHx9::P64 + 48];
           _scHve::P64 = P64[_scHx9::P64 + 56];
           _scHwb::P64 = P64[_scHx9::P64 + 64];
           _scHwd::P64 = P64[_scHx9::P64 + 72];
           I64[Hp - 72] = sat_scHx8_info;
           P64[Hp - 56] = _scHv9::P64;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 72;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxd_entry() //  [R1]
         { info_tbl: [(ccKuT,
                       label: sat_scHxd_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKuT: // global
           _scHxd::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccKuU; else goto ccKuV;
       ccKuV: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccKuX; else goto ccKuW;
       ccKuX: // global
           HpAlloc = 80;
           goto ccKuU;
       ccKuU: // global
           R1 = _scHxd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKuW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxd::P64;
           _scHv9::P64 = P64[_scHxd::P64 + 16];
           _scHva::P64 = P64[_scHxd::P64 + 24];
           _scHvb::P64 = P64[_scHxd::P64 + 32];
           _scHvc::P64 = P64[_scHxd::P64 + 40];
           _scHvd::P64 = P64[_scHxd::P64 + 48];
           _scHve::P64 = P64[_scHxd::P64 + 56];
           _scHw6::P64 = P64[_scHxd::P64 + 64];
           _scHwb::P64 = P64[_scHxd::P64 + 72];
           _scHwd::P64 = P64[_scHxd::P64 + 80];
           I64[Hp - 72] = sat_scHx9_info;
           P64[Hp - 56] = _scHv9::P64;
           P64[Hp - 48] = _scHva::P64;
           P64[Hp - 40] = _scHvb::P64;
           P64[Hp - 32] = _scHvc::P64;
           P64[Hp - 24] = _scHvd::P64;
           P64[Hp - 16] = _scHve::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccKuQ_info;
           R4 = Hp - 72;
           R3 = _scHw6::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKuQ() //  [R1, R2]
         { info_tbl: [(ccKuQ,
                       label: block_ccKuQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKuQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKv0; else goto ccKuZ;
       ccKv0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKuZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxe_entry() //  [R1]
         { info_tbl: [(ccKv1,
                       label: sat_scHxe_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKv1: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccKv5; else goto ccKv4;
       ccKv5: // global
           HpAlloc = 88;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKv4: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHw6::P64 = P64[R1 + 64];
           _scHwb::P64 = P64[R1 + 72];
           _scHwd::P64 = P64[R1 + 80];
           I64[Hp - 80] = sat_scHxd_info;
           P64[Hp - 64] = _scHv9::P64;
           P64[Hp - 56] = _scHva::P64;
           P64[Hp - 48] = _scHvb::P64;
           P64[Hp - 40] = _scHvc::P64;
           P64[Hp - 32] = _scHvd::P64;
           P64[Hp - 24] = _scHve::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 80;
           R2 = lvl29_rcHpY_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxf_entry() //  [R1]
         { info_tbl: [(ccKv6,
                       label: sat_scHxf_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKv6: // global
           _scHxf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKv7; else goto ccKv8;
       ccKv8: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccKva; else goto ccKv9;
       ccKva: // global
           HpAlloc = 88;
           goto ccKv7;
       ccKv7: // global
           R1 = _scHxf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKv9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxf::P64;
           _scHv9::P64 = P64[_scHxf::P64 + 16];
           _scHva::P64 = P64[_scHxf::P64 + 24];
           _scHvb::P64 = P64[_scHxf::P64 + 32];
           _scHvc::P64 = P64[_scHxf::P64 + 40];
           _scHvd::P64 = P64[_scHxf::P64 + 48];
           _scHve::P64 = P64[_scHxf::P64 + 56];
           _scHw6::P64 = P64[_scHxf::P64 + 64];
           _scHwb::P64 = P64[_scHxf::P64 + 72];
           _scHwd::P64 = P64[_scHxf::P64 + 80];
           I64[Hp - 80] = sat_scHxe_info;
           P64[Hp - 64] = _scHv9::P64;
           P64[Hp - 56] = _scHva::P64;
           P64[Hp - 48] = _scHvb::P64;
           P64[Hp - 40] = _scHvc::P64;
           P64[Hp - 32] = _scHvd::P64;
           P64[Hp - 24] = _scHve::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 80;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxj_entry() //  [R1]
         { info_tbl: [(ccKve,
                       label: sat_scHxj_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKve: // global
           _scHxj::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccKvf; else goto ccKvg;
       ccKvg: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccKvi; else goto ccKvh;
       ccKvi: // global
           HpAlloc = 88;
           goto ccKvf;
       ccKvf: // global
           R1 = _scHxj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKvh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxj::P64;
           _scHv9::P64 = P64[_scHxj::P64 + 16];
           _scHva::P64 = P64[_scHxj::P64 + 24];
           _scHvb::P64 = P64[_scHxj::P64 + 32];
           _scHvc::P64 = P64[_scHxj::P64 + 40];
           _scHvd::P64 = P64[_scHxj::P64 + 48];
           _scHve::P64 = P64[_scHxj::P64 + 56];
           _scHw1::P64 = P64[_scHxj::P64 + 64];
           _scHw6::P64 = P64[_scHxj::P64 + 72];
           _scHwb::P64 = P64[_scHxj::P64 + 80];
           _scHwd::P64 = P64[_scHxj::P64 + 88];
           I64[Hp - 80] = sat_scHxf_info;
           P64[Hp - 64] = _scHv9::P64;
           P64[Hp - 56] = _scHva::P64;
           P64[Hp - 48] = _scHvb::P64;
           P64[Hp - 40] = _scHvc::P64;
           P64[Hp - 32] = _scHvd::P64;
           P64[Hp - 24] = _scHve::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccKvb_info;
           R4 = Hp - 80;
           R3 = _scHw1::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKvb() //  [R1, R2]
         { info_tbl: [(ccKvb,
                       label: block_ccKvb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKvb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKvl; else goto ccKvk;
       ccKvl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKvk: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxk_entry() //  [R1]
         { info_tbl: [(ccKvm,
                       label: sat_scHxk_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKvm: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccKvq; else goto ccKvp;
       ccKvq: // global
           HpAlloc = 96;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKvp: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHw1::P64 = P64[R1 + 64];
           _scHw6::P64 = P64[R1 + 72];
           _scHwb::P64 = P64[R1 + 80];
           _scHwd::P64 = P64[R1 + 88];
           I64[Hp - 88] = sat_scHxj_info;
           P64[Hp - 72] = _scHv9::P64;
           P64[Hp - 64] = _scHva::P64;
           P64[Hp - 56] = _scHvb::P64;
           P64[Hp - 48] = _scHvc::P64;
           P64[Hp - 40] = _scHvd::P64;
           P64[Hp - 32] = _scHve::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 88;
           R2 = lvl28_rcHpX_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxl_entry() //  [R1]
         { info_tbl: [(ccKvr,
                       label: sat_scHxl_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKvr: // global
           _scHxl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKvs; else goto ccKvt;
       ccKvt: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccKvv; else goto ccKvu;
       ccKvv: // global
           HpAlloc = 96;
           goto ccKvs;
       ccKvs: // global
           R1 = _scHxl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKvu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxl::P64;
           _scHv9::P64 = P64[_scHxl::P64 + 16];
           _scHva::P64 = P64[_scHxl::P64 + 24];
           _scHvb::P64 = P64[_scHxl::P64 + 32];
           _scHvc::P64 = P64[_scHxl::P64 + 40];
           _scHvd::P64 = P64[_scHxl::P64 + 48];
           _scHve::P64 = P64[_scHxl::P64 + 56];
           _scHw1::P64 = P64[_scHxl::P64 + 64];
           _scHw6::P64 = P64[_scHxl::P64 + 72];
           _scHwb::P64 = P64[_scHxl::P64 + 80];
           _scHwd::P64 = P64[_scHxl::P64 + 88];
           I64[Hp - 88] = sat_scHxk_info;
           P64[Hp - 72] = _scHv9::P64;
           P64[Hp - 64] = _scHva::P64;
           P64[Hp - 56] = _scHvb::P64;
           P64[Hp - 48] = _scHvc::P64;
           P64[Hp - 40] = _scHvd::P64;
           P64[Hp - 32] = _scHve::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 88;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxp_entry() //  [R1]
         { info_tbl: [(ccKvz,
                       label: sat_scHxp_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKvz: // global
           _scHxp::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccKvA; else goto ccKvB;
       ccKvB: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccKvD; else goto ccKvC;
       ccKvD: // global
           HpAlloc = 96;
           goto ccKvA;
       ccKvA: // global
           R1 = _scHxp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKvC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxp::P64;
           _scHv9::P64 = P64[_scHxp::P64 + 16];
           _scHva::P64 = P64[_scHxp::P64 + 24];
           _scHvb::P64 = P64[_scHxp::P64 + 32];
           _scHvc::P64 = P64[_scHxp::P64 + 40];
           _scHvd::P64 = P64[_scHxp::P64 + 48];
           _scHve::P64 = P64[_scHxp::P64 + 56];
           _scHvW::P64 = P64[_scHxp::P64 + 64];
           _scHw1::P64 = P64[_scHxp::P64 + 72];
           _scHw6::P64 = P64[_scHxp::P64 + 80];
           _scHwb::P64 = P64[_scHxp::P64 + 88];
           _scHwd::P64 = P64[_scHxp::P64 + 96];
           I64[Hp - 88] = sat_scHxl_info;
           P64[Hp - 72] = _scHv9::P64;
           P64[Hp - 64] = _scHva::P64;
           P64[Hp - 56] = _scHvb::P64;
           P64[Hp - 48] = _scHvc::P64;
           P64[Hp - 40] = _scHvd::P64;
           P64[Hp - 32] = _scHve::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccKvw_info;
           R4 = Hp - 88;
           R3 = _scHvW::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKvw() //  [R1, R2]
         { info_tbl: [(ccKvw,
                       label: block_ccKvw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKvw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKvG; else goto ccKvF;
       ccKvG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKvF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxq_entry() //  [R1]
         { info_tbl: [(ccKvH,
                       label: sat_scHxq_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKvH: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccKvL; else goto ccKvK;
       ccKvL: // global
           HpAlloc = 104;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKvK: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvW::P64 = P64[R1 + 64];
           _scHw1::P64 = P64[R1 + 72];
           _scHw6::P64 = P64[R1 + 80];
           _scHwb::P64 = P64[R1 + 88];
           _scHwd::P64 = P64[R1 + 96];
           I64[Hp - 96] = sat_scHxp_info;
           P64[Hp - 80] = _scHv9::P64;
           P64[Hp - 72] = _scHva::P64;
           P64[Hp - 64] = _scHvb::P64;
           P64[Hp - 56] = _scHvc::P64;
           P64[Hp - 48] = _scHvd::P64;
           P64[Hp - 40] = _scHve::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 96;
           R2 = lvl27_rcHpW_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxr_entry() //  [R1]
         { info_tbl: [(ccKvM,
                       label: sat_scHxr_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKvM: // global
           _scHxr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKvN; else goto ccKvO;
       ccKvO: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccKvQ; else goto ccKvP;
       ccKvQ: // global
           HpAlloc = 104;
           goto ccKvN;
       ccKvN: // global
           R1 = _scHxr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKvP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxr::P64;
           _scHv9::P64 = P64[_scHxr::P64 + 16];
           _scHva::P64 = P64[_scHxr::P64 + 24];
           _scHvb::P64 = P64[_scHxr::P64 + 32];
           _scHvc::P64 = P64[_scHxr::P64 + 40];
           _scHvd::P64 = P64[_scHxr::P64 + 48];
           _scHve::P64 = P64[_scHxr::P64 + 56];
           _scHvW::P64 = P64[_scHxr::P64 + 64];
           _scHw1::P64 = P64[_scHxr::P64 + 72];
           _scHw6::P64 = P64[_scHxr::P64 + 80];
           _scHwb::P64 = P64[_scHxr::P64 + 88];
           _scHwd::P64 = P64[_scHxr::P64 + 96];
           I64[Hp - 96] = sat_scHxq_info;
           P64[Hp - 80] = _scHv9::P64;
           P64[Hp - 72] = _scHva::P64;
           P64[Hp - 64] = _scHvb::P64;
           P64[Hp - 56] = _scHvc::P64;
           P64[Hp - 48] = _scHvd::P64;
           P64[Hp - 40] = _scHve::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 96;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxv_entry() //  [R1]
         { info_tbl: [(ccKvU,
                       label: sat_scHxv_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKvU: // global
           _scHxv::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccKvV; else goto ccKvW;
       ccKvW: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccKvY; else goto ccKvX;
       ccKvY: // global
           HpAlloc = 104;
           goto ccKvV;
       ccKvV: // global
           R1 = _scHxv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKvX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxv::P64;
           _scHv9::P64 = P64[_scHxv::P64 + 16];
           _scHva::P64 = P64[_scHxv::P64 + 24];
           _scHvb::P64 = P64[_scHxv::P64 + 32];
           _scHvc::P64 = P64[_scHxv::P64 + 40];
           _scHvd::P64 = P64[_scHxv::P64 + 48];
           _scHve::P64 = P64[_scHxv::P64 + 56];
           _scHvR::P64 = P64[_scHxv::P64 + 64];
           _scHvW::P64 = P64[_scHxv::P64 + 72];
           _scHw1::P64 = P64[_scHxv::P64 + 80];
           _scHw6::P64 = P64[_scHxv::P64 + 88];
           _scHwb::P64 = P64[_scHxv::P64 + 96];
           _scHwd::P64 = P64[_scHxv::P64 + 104];
           I64[Hp - 96] = sat_scHxr_info;
           P64[Hp - 80] = _scHv9::P64;
           P64[Hp - 72] = _scHva::P64;
           P64[Hp - 64] = _scHvb::P64;
           P64[Hp - 56] = _scHvc::P64;
           P64[Hp - 48] = _scHvd::P64;
           P64[Hp - 40] = _scHve::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccKvR_info;
           R4 = Hp - 96;
           R3 = _scHvR::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKvR() //  [R1, R2]
         { info_tbl: [(ccKvR,
                       label: block_ccKvR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKvR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKw1; else goto ccKw0;
       ccKw1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKw0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxw_entry() //  [R1]
         { info_tbl: [(ccKw2,
                       label: sat_scHxw_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKw2: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccKw6; else goto ccKw5;
       ccKw6: // global
           HpAlloc = 112;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKw5: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvR::P64 = P64[R1 + 64];
           _scHvW::P64 = P64[R1 + 72];
           _scHw1::P64 = P64[R1 + 80];
           _scHw6::P64 = P64[R1 + 88];
           _scHwb::P64 = P64[R1 + 96];
           _scHwd::P64 = P64[R1 + 104];
           I64[Hp - 104] = sat_scHxv_info;
           P64[Hp - 88] = _scHv9::P64;
           P64[Hp - 80] = _scHva::P64;
           P64[Hp - 72] = _scHvb::P64;
           P64[Hp - 64] = _scHvc::P64;
           P64[Hp - 56] = _scHvd::P64;
           P64[Hp - 48] = _scHve::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 104;
           R2 = lvl26_rcHpV_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxx_entry() //  [R1]
         { info_tbl: [(ccKw7,
                       label: sat_scHxx_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKw7: // global
           _scHxx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKw8; else goto ccKw9;
       ccKw9: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccKwb; else goto ccKwa;
       ccKwb: // global
           HpAlloc = 112;
           goto ccKw8;
       ccKw8: // global
           R1 = _scHxx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKwa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxx::P64;
           _scHv9::P64 = P64[_scHxx::P64 + 16];
           _scHva::P64 = P64[_scHxx::P64 + 24];
           _scHvb::P64 = P64[_scHxx::P64 + 32];
           _scHvc::P64 = P64[_scHxx::P64 + 40];
           _scHvd::P64 = P64[_scHxx::P64 + 48];
           _scHve::P64 = P64[_scHxx::P64 + 56];
           _scHvR::P64 = P64[_scHxx::P64 + 64];
           _scHvW::P64 = P64[_scHxx::P64 + 72];
           _scHw1::P64 = P64[_scHxx::P64 + 80];
           _scHw6::P64 = P64[_scHxx::P64 + 88];
           _scHwb::P64 = P64[_scHxx::P64 + 96];
           _scHwd::P64 = P64[_scHxx::P64 + 104];
           I64[Hp - 104] = sat_scHxw_info;
           P64[Hp - 88] = _scHv9::P64;
           P64[Hp - 80] = _scHva::P64;
           P64[Hp - 72] = _scHvb::P64;
           P64[Hp - 64] = _scHvc::P64;
           P64[Hp - 56] = _scHvd::P64;
           P64[Hp - 48] = _scHve::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 104;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxB_entry() //  [R1]
         { info_tbl: [(ccKwf,
                       label: sat_scHxB_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKwf: // global
           _scHxB::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccKwg; else goto ccKwh;
       ccKwh: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccKwj; else goto ccKwi;
       ccKwj: // global
           HpAlloc = 112;
           goto ccKwg;
       ccKwg: // global
           R1 = _scHxB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKwi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxB::P64;
           _scHv9::P64 = P64[_scHxB::P64 + 16];
           _scHva::P64 = P64[_scHxB::P64 + 24];
           _scHvb::P64 = P64[_scHxB::P64 + 32];
           _scHvc::P64 = P64[_scHxB::P64 + 40];
           _scHvd::P64 = P64[_scHxB::P64 + 48];
           _scHve::P64 = P64[_scHxB::P64 + 56];
           _scHvM::P64 = P64[_scHxB::P64 + 64];
           _scHvR::P64 = P64[_scHxB::P64 + 72];
           _scHvW::P64 = P64[_scHxB::P64 + 80];
           _scHw1::P64 = P64[_scHxB::P64 + 88];
           _scHw6::P64 = P64[_scHxB::P64 + 96];
           _scHwb::P64 = P64[_scHxB::P64 + 104];
           _scHwd::P64 = P64[_scHxB::P64 + 112];
           I64[Hp - 104] = sat_scHxx_info;
           P64[Hp - 88] = _scHv9::P64;
           P64[Hp - 80] = _scHva::P64;
           P64[Hp - 72] = _scHvb::P64;
           P64[Hp - 64] = _scHvc::P64;
           P64[Hp - 56] = _scHvd::P64;
           P64[Hp - 48] = _scHve::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccKwc_info;
           R4 = Hp - 104;
           R3 = _scHvM::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKwc() //  [R1, R2]
         { info_tbl: [(ccKwc,
                       label: block_ccKwc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKwc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKwm; else goto ccKwl;
       ccKwm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKwl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxC_entry() //  [R1]
         { info_tbl: [(ccKwn,
                       label: sat_scHxC_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKwn: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccKwr; else goto ccKwq;
       ccKwr: // global
           HpAlloc = 120;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKwq: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvM::P64 = P64[R1 + 64];
           _scHvR::P64 = P64[R1 + 72];
           _scHvW::P64 = P64[R1 + 80];
           _scHw1::P64 = P64[R1 + 88];
           _scHw6::P64 = P64[R1 + 96];
           _scHwb::P64 = P64[R1 + 104];
           _scHwd::P64 = P64[R1 + 112];
           I64[Hp - 112] = sat_scHxB_info;
           P64[Hp - 96] = _scHv9::P64;
           P64[Hp - 88] = _scHva::P64;
           P64[Hp - 80] = _scHvb::P64;
           P64[Hp - 72] = _scHvc::P64;
           P64[Hp - 64] = _scHvd::P64;
           P64[Hp - 56] = _scHve::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 112;
           R2 = lvl25_rcHpU_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxD_entry() //  [R1]
         { info_tbl: [(ccKws,
                       label: sat_scHxD_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKws: // global
           _scHxD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKwt; else goto ccKwu;
       ccKwu: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccKww; else goto ccKwv;
       ccKww: // global
           HpAlloc = 120;
           goto ccKwt;
       ccKwt: // global
           R1 = _scHxD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKwv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxD::P64;
           _scHv9::P64 = P64[_scHxD::P64 + 16];
           _scHva::P64 = P64[_scHxD::P64 + 24];
           _scHvb::P64 = P64[_scHxD::P64 + 32];
           _scHvc::P64 = P64[_scHxD::P64 + 40];
           _scHvd::P64 = P64[_scHxD::P64 + 48];
           _scHve::P64 = P64[_scHxD::P64 + 56];
           _scHvM::P64 = P64[_scHxD::P64 + 64];
           _scHvR::P64 = P64[_scHxD::P64 + 72];
           _scHvW::P64 = P64[_scHxD::P64 + 80];
           _scHw1::P64 = P64[_scHxD::P64 + 88];
           _scHw6::P64 = P64[_scHxD::P64 + 96];
           _scHwb::P64 = P64[_scHxD::P64 + 104];
           _scHwd::P64 = P64[_scHxD::P64 + 112];
           I64[Hp - 112] = sat_scHxC_info;
           P64[Hp - 96] = _scHv9::P64;
           P64[Hp - 88] = _scHva::P64;
           P64[Hp - 80] = _scHvb::P64;
           P64[Hp - 72] = _scHvc::P64;
           P64[Hp - 64] = _scHvd::P64;
           P64[Hp - 56] = _scHve::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 112;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxH_entry() //  [R1]
         { info_tbl: [(ccKwA,
                       label: sat_scHxH_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKwA: // global
           _scHxH::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccKwB; else goto ccKwC;
       ccKwC: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccKwE; else goto ccKwD;
       ccKwE: // global
           HpAlloc = 120;
           goto ccKwB;
       ccKwB: // global
           R1 = _scHxH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKwD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxH::P64;
           _scHv9::P64 = P64[_scHxH::P64 + 16];
           _scHva::P64 = P64[_scHxH::P64 + 24];
           _scHvb::P64 = P64[_scHxH::P64 + 32];
           _scHvc::P64 = P64[_scHxH::P64 + 40];
           _scHvd::P64 = P64[_scHxH::P64 + 48];
           _scHve::P64 = P64[_scHxH::P64 + 56];
           _scHvH::P64 = P64[_scHxH::P64 + 64];
           _scHvM::P64 = P64[_scHxH::P64 + 72];
           _scHvR::P64 = P64[_scHxH::P64 + 80];
           _scHvW::P64 = P64[_scHxH::P64 + 88];
           _scHw1::P64 = P64[_scHxH::P64 + 96];
           _scHw6::P64 = P64[_scHxH::P64 + 104];
           _scHwb::P64 = P64[_scHxH::P64 + 112];
           _scHwd::P64 = P64[_scHxH::P64 + 120];
           I64[Hp - 112] = sat_scHxD_info;
           P64[Hp - 96] = _scHv9::P64;
           P64[Hp - 88] = _scHva::P64;
           P64[Hp - 80] = _scHvb::P64;
           P64[Hp - 72] = _scHvc::P64;
           P64[Hp - 64] = _scHvd::P64;
           P64[Hp - 56] = _scHve::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccKwx_info;
           R4 = Hp - 112;
           R3 = _scHvH::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKwx() //  [R1, R2]
         { info_tbl: [(ccKwx,
                       label: block_ccKwx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKwx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKwH; else goto ccKwG;
       ccKwH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKwG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxI_entry() //  [R1]
         { info_tbl: [(ccKwI,
                       label: sat_scHxI_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKwI: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccKwM; else goto ccKwL;
       ccKwM: // global
           HpAlloc = 128;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKwL: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvH::P64 = P64[R1 + 64];
           _scHvM::P64 = P64[R1 + 72];
           _scHvR::P64 = P64[R1 + 80];
           _scHvW::P64 = P64[R1 + 88];
           _scHw1::P64 = P64[R1 + 96];
           _scHw6::P64 = P64[R1 + 104];
           _scHwb::P64 = P64[R1 + 112];
           _scHwd::P64 = P64[R1 + 120];
           I64[Hp - 120] = sat_scHxH_info;
           P64[Hp - 104] = _scHv9::P64;
           P64[Hp - 96] = _scHva::P64;
           P64[Hp - 88] = _scHvb::P64;
           P64[Hp - 80] = _scHvc::P64;
           P64[Hp - 72] = _scHvd::P64;
           P64[Hp - 64] = _scHve::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 120;
           R2 = lvl24_rcHpT_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxJ_entry() //  [R1]
         { info_tbl: [(ccKwN,
                       label: sat_scHxJ_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKwN: // global
           _scHxJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKwO; else goto ccKwP;
       ccKwP: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccKwR; else goto ccKwQ;
       ccKwR: // global
           HpAlloc = 128;
           goto ccKwO;
       ccKwO: // global
           R1 = _scHxJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKwQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxJ::P64;
           _scHv9::P64 = P64[_scHxJ::P64 + 16];
           _scHva::P64 = P64[_scHxJ::P64 + 24];
           _scHvb::P64 = P64[_scHxJ::P64 + 32];
           _scHvc::P64 = P64[_scHxJ::P64 + 40];
           _scHvd::P64 = P64[_scHxJ::P64 + 48];
           _scHve::P64 = P64[_scHxJ::P64 + 56];
           _scHvH::P64 = P64[_scHxJ::P64 + 64];
           _scHvM::P64 = P64[_scHxJ::P64 + 72];
           _scHvR::P64 = P64[_scHxJ::P64 + 80];
           _scHvW::P64 = P64[_scHxJ::P64 + 88];
           _scHw1::P64 = P64[_scHxJ::P64 + 96];
           _scHw6::P64 = P64[_scHxJ::P64 + 104];
           _scHwb::P64 = P64[_scHxJ::P64 + 112];
           _scHwd::P64 = P64[_scHxJ::P64 + 120];
           I64[Hp - 120] = sat_scHxI_info;
           P64[Hp - 104] = _scHv9::P64;
           P64[Hp - 96] = _scHva::P64;
           P64[Hp - 88] = _scHvb::P64;
           P64[Hp - 80] = _scHvc::P64;
           P64[Hp - 72] = _scHvd::P64;
           P64[Hp - 64] = _scHve::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 120;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxN_entry() //  [R1]
         { info_tbl: [(ccKwV,
                       label: sat_scHxN_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKwV: // global
           _scHxN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccKwW; else goto ccKwX;
       ccKwX: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccKwZ; else goto ccKwY;
       ccKwZ: // global
           HpAlloc = 128;
           goto ccKwW;
       ccKwW: // global
           R1 = _scHxN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKwY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxN::P64;
           _scHv9::P64 = P64[_scHxN::P64 + 16];
           _scHva::P64 = P64[_scHxN::P64 + 24];
           _scHvb::P64 = P64[_scHxN::P64 + 32];
           _scHvc::P64 = P64[_scHxN::P64 + 40];
           _scHvd::P64 = P64[_scHxN::P64 + 48];
           _scHve::P64 = P64[_scHxN::P64 + 56];
           _scHvC::P64 = P64[_scHxN::P64 + 64];
           _scHvH::P64 = P64[_scHxN::P64 + 72];
           _scHvM::P64 = P64[_scHxN::P64 + 80];
           _scHvR::P64 = P64[_scHxN::P64 + 88];
           _scHvW::P64 = P64[_scHxN::P64 + 96];
           _scHw1::P64 = P64[_scHxN::P64 + 104];
           _scHw6::P64 = P64[_scHxN::P64 + 112];
           _scHwb::P64 = P64[_scHxN::P64 + 120];
           _scHwd::P64 = P64[_scHxN::P64 + 128];
           I64[Hp - 120] = sat_scHxJ_info;
           P64[Hp - 104] = _scHv9::P64;
           P64[Hp - 96] = _scHva::P64;
           P64[Hp - 88] = _scHvb::P64;
           P64[Hp - 80] = _scHvc::P64;
           P64[Hp - 72] = _scHvd::P64;
           P64[Hp - 64] = _scHve::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccKwS_info;
           R4 = Hp - 120;
           R3 = _scHvC::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKwS() //  [R1, R2]
         { info_tbl: [(ccKwS,
                       label: block_ccKwS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKwS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKx2; else goto ccKx1;
       ccKx2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKx1: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxO_entry() //  [R1]
         { info_tbl: [(ccKx3,
                       label: sat_scHxO_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKx3: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccKx7; else goto ccKx6;
       ccKx7: // global
           HpAlloc = 136;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKx6: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvC::P64 = P64[R1 + 64];
           _scHvH::P64 = P64[R1 + 72];
           _scHvM::P64 = P64[R1 + 80];
           _scHvR::P64 = P64[R1 + 88];
           _scHvW::P64 = P64[R1 + 96];
           _scHw1::P64 = P64[R1 + 104];
           _scHw6::P64 = P64[R1 + 112];
           _scHwb::P64 = P64[R1 + 120];
           _scHwd::P64 = P64[R1 + 128];
           I64[Hp - 128] = sat_scHxN_info;
           P64[Hp - 112] = _scHv9::P64;
           P64[Hp - 104] = _scHva::P64;
           P64[Hp - 96] = _scHvb::P64;
           P64[Hp - 88] = _scHvc::P64;
           P64[Hp - 80] = _scHvd::P64;
           P64[Hp - 72] = _scHve::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 128;
           R2 = lvl23_rcHpS_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxP_entry() //  [R1]
         { info_tbl: [(ccKx8,
                       label: sat_scHxP_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKx8: // global
           _scHxP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKx9; else goto ccKxa;
       ccKxa: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccKxc; else goto ccKxb;
       ccKxc: // global
           HpAlloc = 136;
           goto ccKx9;
       ccKx9: // global
           R1 = _scHxP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKxb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxP::P64;
           _scHv9::P64 = P64[_scHxP::P64 + 16];
           _scHva::P64 = P64[_scHxP::P64 + 24];
           _scHvb::P64 = P64[_scHxP::P64 + 32];
           _scHvc::P64 = P64[_scHxP::P64 + 40];
           _scHvd::P64 = P64[_scHxP::P64 + 48];
           _scHve::P64 = P64[_scHxP::P64 + 56];
           _scHvC::P64 = P64[_scHxP::P64 + 64];
           _scHvH::P64 = P64[_scHxP::P64 + 72];
           _scHvM::P64 = P64[_scHxP::P64 + 80];
           _scHvR::P64 = P64[_scHxP::P64 + 88];
           _scHvW::P64 = P64[_scHxP::P64 + 96];
           _scHw1::P64 = P64[_scHxP::P64 + 104];
           _scHw6::P64 = P64[_scHxP::P64 + 112];
           _scHwb::P64 = P64[_scHxP::P64 + 120];
           _scHwd::P64 = P64[_scHxP::P64 + 128];
           I64[Hp - 128] = sat_scHxO_info;
           P64[Hp - 112] = _scHv9::P64;
           P64[Hp - 104] = _scHva::P64;
           P64[Hp - 96] = _scHvb::P64;
           P64[Hp - 88] = _scHvc::P64;
           P64[Hp - 80] = _scHvd::P64;
           P64[Hp - 72] = _scHve::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 128;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxT_entry() //  [R1]
         { info_tbl: [(ccKxg,
                       label: sat_scHxT_info
                       rep:HeapRep 16 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKxg: // global
           _scHxT::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccKxh; else goto ccKxi;
       ccKxi: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccKxk; else goto ccKxj;
       ccKxk: // global
           HpAlloc = 136;
           goto ccKxh;
       ccKxh: // global
           R1 = _scHxT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKxj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxT::P64;
           _scHv9::P64 = P64[_scHxT::P64 + 16];
           _scHva::P64 = P64[_scHxT::P64 + 24];
           _scHvb::P64 = P64[_scHxT::P64 + 32];
           _scHvc::P64 = P64[_scHxT::P64 + 40];
           _scHvd::P64 = P64[_scHxT::P64 + 48];
           _scHve::P64 = P64[_scHxT::P64 + 56];
           _scHvx::P64 = P64[_scHxT::P64 + 64];
           _scHvC::P64 = P64[_scHxT::P64 + 72];
           _scHvH::P64 = P64[_scHxT::P64 + 80];
           _scHvM::P64 = P64[_scHxT::P64 + 88];
           _scHvR::P64 = P64[_scHxT::P64 + 96];
           _scHvW::P64 = P64[_scHxT::P64 + 104];
           _scHw1::P64 = P64[_scHxT::P64 + 112];
           _scHw6::P64 = P64[_scHxT::P64 + 120];
           _scHwb::P64 = P64[_scHxT::P64 + 128];
           _scHwd::P64 = P64[_scHxT::P64 + 136];
           I64[Hp - 128] = sat_scHxP_info;
           P64[Hp - 112] = _scHv9::P64;
           P64[Hp - 104] = _scHva::P64;
           P64[Hp - 96] = _scHvb::P64;
           P64[Hp - 88] = _scHvc::P64;
           P64[Hp - 80] = _scHvd::P64;
           P64[Hp - 72] = _scHve::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccKxd_info;
           R4 = Hp - 128;
           R3 = _scHvx::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKxd() //  [R1, R2]
         { info_tbl: [(ccKxd,
                       label: block_ccKxd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKxd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKxn; else goto ccKxm;
       ccKxn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKxm: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxU_entry() //  [R1]
         { info_tbl: [(ccKxo,
                       label: sat_scHxU_info
                       rep:HeapRep 16 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKxo: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccKxs; else goto ccKxr;
       ccKxs: // global
           HpAlloc = 144;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKxr: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvx::P64 = P64[R1 + 64];
           _scHvC::P64 = P64[R1 + 72];
           _scHvH::P64 = P64[R1 + 80];
           _scHvM::P64 = P64[R1 + 88];
           _scHvR::P64 = P64[R1 + 96];
           _scHvW::P64 = P64[R1 + 104];
           _scHw1::P64 = P64[R1 + 112];
           _scHw6::P64 = P64[R1 + 120];
           _scHwb::P64 = P64[R1 + 128];
           _scHwd::P64 = P64[R1 + 136];
           I64[Hp - 136] = sat_scHxT_info;
           P64[Hp - 120] = _scHv9::P64;
           P64[Hp - 112] = _scHva::P64;
           P64[Hp - 104] = _scHvb::P64;
           P64[Hp - 96] = _scHvc::P64;
           P64[Hp - 88] = _scHvd::P64;
           P64[Hp - 80] = _scHve::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 136;
           R2 = lvl22_rcHpR_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHxV_entry() //  [R1]
         { info_tbl: [(ccKxt,
                       label: sat_scHxV_info
                       rep:HeapRep 16 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKxt: // global
           _scHxV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKxu; else goto ccKxv;
       ccKxv: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccKxx; else goto ccKxw;
       ccKxx: // global
           HpAlloc = 144;
           goto ccKxu;
       ccKxu: // global
           R1 = _scHxV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKxw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxV::P64;
           _scHv9::P64 = P64[_scHxV::P64 + 16];
           _scHva::P64 = P64[_scHxV::P64 + 24];
           _scHvb::P64 = P64[_scHxV::P64 + 32];
           _scHvc::P64 = P64[_scHxV::P64 + 40];
           _scHvd::P64 = P64[_scHxV::P64 + 48];
           _scHve::P64 = P64[_scHxV::P64 + 56];
           _scHvx::P64 = P64[_scHxV::P64 + 64];
           _scHvC::P64 = P64[_scHxV::P64 + 72];
           _scHvH::P64 = P64[_scHxV::P64 + 80];
           _scHvM::P64 = P64[_scHxV::P64 + 88];
           _scHvR::P64 = P64[_scHxV::P64 + 96];
           _scHvW::P64 = P64[_scHxV::P64 + 104];
           _scHw1::P64 = P64[_scHxV::P64 + 112];
           _scHw6::P64 = P64[_scHxV::P64 + 120];
           _scHwb::P64 = P64[_scHxV::P64 + 128];
           _scHwd::P64 = P64[_scHxV::P64 + 136];
           I64[Hp - 136] = sat_scHxU_info;
           P64[Hp - 120] = _scHv9::P64;
           P64[Hp - 112] = _scHva::P64;
           P64[Hp - 104] = _scHvb::P64;
           P64[Hp - 96] = _scHvc::P64;
           P64[Hp - 88] = _scHvd::P64;
           P64[Hp - 80] = _scHve::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 136;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHxZ_entry() //  [R1]
         { info_tbl: [(ccKxB,
                       label: sat_scHxZ_info
                       rep:HeapRep 17 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKxB: // global
           _scHxZ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccKxC; else goto ccKxD;
       ccKxD: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccKxF; else goto ccKxE;
       ccKxF: // global
           HpAlloc = 144;
           goto ccKxC;
       ccKxC: // global
           R1 = _scHxZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKxE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHxZ::P64;
           _scHv9::P64 = P64[_scHxZ::P64 + 16];
           _scHva::P64 = P64[_scHxZ::P64 + 24];
           _scHvb::P64 = P64[_scHxZ::P64 + 32];
           _scHvc::P64 = P64[_scHxZ::P64 + 40];
           _scHvd::P64 = P64[_scHxZ::P64 + 48];
           _scHve::P64 = P64[_scHxZ::P64 + 56];
           _scHvs::P64 = P64[_scHxZ::P64 + 64];
           _scHvx::P64 = P64[_scHxZ::P64 + 72];
           _scHvC::P64 = P64[_scHxZ::P64 + 80];
           _scHvH::P64 = P64[_scHxZ::P64 + 88];
           _scHvM::P64 = P64[_scHxZ::P64 + 96];
           _scHvR::P64 = P64[_scHxZ::P64 + 104];
           _scHvW::P64 = P64[_scHxZ::P64 + 112];
           _scHw1::P64 = P64[_scHxZ::P64 + 120];
           _scHw6::P64 = P64[_scHxZ::P64 + 128];
           _scHwb::P64 = P64[_scHxZ::P64 + 136];
           _scHwd::P64 = P64[_scHxZ::P64 + 144];
           I64[Hp - 136] = sat_scHxV_info;
           P64[Hp - 120] = _scHv9::P64;
           P64[Hp - 112] = _scHva::P64;
           P64[Hp - 104] = _scHvb::P64;
           P64[Hp - 96] = _scHvc::P64;
           P64[Hp - 88] = _scHvd::P64;
           P64[Hp - 80] = _scHve::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccKxy_info;
           R4 = Hp - 136;
           R3 = _scHvs::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKxy() //  [R1, R2]
         { info_tbl: [(ccKxy,
                       label: block_ccKxy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKxy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKxI; else goto ccKxH;
       ccKxI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKxH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHy0_entry() //  [R1]
         { info_tbl: [(ccKxJ,
                       label: sat_scHy0_info
                       rep:HeapRep 17 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKxJ: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccKxN; else goto ccKxM;
       ccKxN: // global
           HpAlloc = 152;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKxM: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvs::P64 = P64[R1 + 64];
           _scHvx::P64 = P64[R1 + 72];
           _scHvC::P64 = P64[R1 + 80];
           _scHvH::P64 = P64[R1 + 88];
           _scHvM::P64 = P64[R1 + 96];
           _scHvR::P64 = P64[R1 + 104];
           _scHvW::P64 = P64[R1 + 112];
           _scHw1::P64 = P64[R1 + 120];
           _scHw6::P64 = P64[R1 + 128];
           _scHwb::P64 = P64[R1 + 136];
           _scHwd::P64 = P64[R1 + 144];
           I64[Hp - 144] = sat_scHxZ_info;
           P64[Hp - 128] = _scHv9::P64;
           P64[Hp - 120] = _scHva::P64;
           P64[Hp - 112] = _scHvb::P64;
           P64[Hp - 104] = _scHvc::P64;
           P64[Hp - 96] = _scHvd::P64;
           P64[Hp - 88] = _scHve::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 144;
           R2 = lvl21_rcHpQ_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHy1_entry() //  [R1]
         { info_tbl: [(ccKxO,
                       label: sat_scHy1_info
                       rep:HeapRep 17 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKxO: // global
           _scHy1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKxP; else goto ccKxQ;
       ccKxQ: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccKxS; else goto ccKxR;
       ccKxS: // global
           HpAlloc = 152;
           goto ccKxP;
       ccKxP: // global
           R1 = _scHy1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKxR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHy1::P64;
           _scHv9::P64 = P64[_scHy1::P64 + 16];
           _scHva::P64 = P64[_scHy1::P64 + 24];
           _scHvb::P64 = P64[_scHy1::P64 + 32];
           _scHvc::P64 = P64[_scHy1::P64 + 40];
           _scHvd::P64 = P64[_scHy1::P64 + 48];
           _scHve::P64 = P64[_scHy1::P64 + 56];
           _scHvs::P64 = P64[_scHy1::P64 + 64];
           _scHvx::P64 = P64[_scHy1::P64 + 72];
           _scHvC::P64 = P64[_scHy1::P64 + 80];
           _scHvH::P64 = P64[_scHy1::P64 + 88];
           _scHvM::P64 = P64[_scHy1::P64 + 96];
           _scHvR::P64 = P64[_scHy1::P64 + 104];
           _scHvW::P64 = P64[_scHy1::P64 + 112];
           _scHw1::P64 = P64[_scHy1::P64 + 120];
           _scHw6::P64 = P64[_scHy1::P64 + 128];
           _scHwb::P64 = P64[_scHy1::P64 + 136];
           _scHwd::P64 = P64[_scHy1::P64 + 144];
           I64[Hp - 144] = sat_scHy0_info;
           P64[Hp - 128] = _scHv9::P64;
           P64[Hp - 120] = _scHva::P64;
           P64[Hp - 112] = _scHvb::P64;
           P64[Hp - 104] = _scHvc::P64;
           P64[Hp - 96] = _scHvd::P64;
           P64[Hp - 88] = _scHve::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 144;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHy5_entry() //  [R1]
         { info_tbl: [(ccKxW,
                       label: sat_scHy5_info
                       rep:HeapRep 18 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKxW: // global
           _scHy5::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccKxX; else goto ccKxY;
       ccKxY: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccKy0; else goto ccKxZ;
       ccKy0: // global
           HpAlloc = 152;
           goto ccKxX;
       ccKxX: // global
           R1 = _scHy5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKxZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHy5::P64;
           _scHv9::P64 = P64[_scHy5::P64 + 16];
           _scHva::P64 = P64[_scHy5::P64 + 24];
           _scHvb::P64 = P64[_scHy5::P64 + 32];
           _scHvc::P64 = P64[_scHy5::P64 + 40];
           _scHvd::P64 = P64[_scHy5::P64 + 48];
           _scHve::P64 = P64[_scHy5::P64 + 56];
           _scHvn::P64 = P64[_scHy5::P64 + 64];
           _scHvs::P64 = P64[_scHy5::P64 + 72];
           _scHvx::P64 = P64[_scHy5::P64 + 80];
           _scHvC::P64 = P64[_scHy5::P64 + 88];
           _scHvH::P64 = P64[_scHy5::P64 + 96];
           _scHvM::P64 = P64[_scHy5::P64 + 104];
           _scHvR::P64 = P64[_scHy5::P64 + 112];
           _scHvW::P64 = P64[_scHy5::P64 + 120];
           _scHw1::P64 = P64[_scHy5::P64 + 128];
           _scHw6::P64 = P64[_scHy5::P64 + 136];
           _scHwb::P64 = P64[_scHy5::P64 + 144];
           _scHwd::P64 = P64[_scHy5::P64 + 152];
           I64[Hp - 144] = sat_scHy1_info;
           P64[Hp - 128] = _scHv9::P64;
           P64[Hp - 120] = _scHva::P64;
           P64[Hp - 112] = _scHvb::P64;
           P64[Hp - 104] = _scHvc::P64;
           P64[Hp - 96] = _scHvd::P64;
           P64[Hp - 88] = _scHve::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccKxT_info;
           R4 = Hp - 144;
           R3 = _scHvn::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKxT() //  [R1, R2]
         { info_tbl: [(ccKxT,
                       label: block_ccKxT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKxT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKy3; else goto ccKy2;
       ccKy3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKy2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHy6_entry() //  [R1]
         { info_tbl: [(ccKy4,
                       label: sat_scHy6_info
                       rep:HeapRep 18 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKy4: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccKy8; else goto ccKy7;
       ccKy8: // global
           HpAlloc = 160;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKy7: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvn::P64 = P64[R1 + 64];
           _scHvs::P64 = P64[R1 + 72];
           _scHvx::P64 = P64[R1 + 80];
           _scHvC::P64 = P64[R1 + 88];
           _scHvH::P64 = P64[R1 + 96];
           _scHvM::P64 = P64[R1 + 104];
           _scHvR::P64 = P64[R1 + 112];
           _scHvW::P64 = P64[R1 + 120];
           _scHw1::P64 = P64[R1 + 128];
           _scHw6::P64 = P64[R1 + 136];
           _scHwb::P64 = P64[R1 + 144];
           _scHwd::P64 = P64[R1 + 152];
           I64[Hp - 152] = sat_scHy5_info;
           P64[Hp - 136] = _scHv9::P64;
           P64[Hp - 128] = _scHva::P64;
           P64[Hp - 120] = _scHvb::P64;
           P64[Hp - 112] = _scHvc::P64;
           P64[Hp - 104] = _scHvd::P64;
           P64[Hp - 96] = _scHve::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 152;
           R2 = lvl20_rcHpP_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHy7_entry() //  [R1]
         { info_tbl: [(ccKy9,
                       label: sat_scHy7_info
                       rep:HeapRep 18 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKy9: // global
           _scHy7::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKya; else goto ccKyb;
       ccKyb: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccKyd; else goto ccKyc;
       ccKyd: // global
           HpAlloc = 160;
           goto ccKya;
       ccKya: // global
           R1 = _scHy7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKyc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHy7::P64;
           _scHv9::P64 = P64[_scHy7::P64 + 16];
           _scHva::P64 = P64[_scHy7::P64 + 24];
           _scHvb::P64 = P64[_scHy7::P64 + 32];
           _scHvc::P64 = P64[_scHy7::P64 + 40];
           _scHvd::P64 = P64[_scHy7::P64 + 48];
           _scHve::P64 = P64[_scHy7::P64 + 56];
           _scHvn::P64 = P64[_scHy7::P64 + 64];
           _scHvs::P64 = P64[_scHy7::P64 + 72];
           _scHvx::P64 = P64[_scHy7::P64 + 80];
           _scHvC::P64 = P64[_scHy7::P64 + 88];
           _scHvH::P64 = P64[_scHy7::P64 + 96];
           _scHvM::P64 = P64[_scHy7::P64 + 104];
           _scHvR::P64 = P64[_scHy7::P64 + 112];
           _scHvW::P64 = P64[_scHy7::P64 + 120];
           _scHw1::P64 = P64[_scHy7::P64 + 128];
           _scHw6::P64 = P64[_scHy7::P64 + 136];
           _scHwb::P64 = P64[_scHy7::P64 + 144];
           _scHwd::P64 = P64[_scHy7::P64 + 152];
           I64[Hp - 152] = sat_scHy6_info;
           P64[Hp - 136] = _scHv9::P64;
           P64[Hp - 128] = _scHva::P64;
           P64[Hp - 120] = _scHvb::P64;
           P64[Hp - 112] = _scHvc::P64;
           P64[Hp - 104] = _scHvd::P64;
           P64[Hp - 96] = _scHve::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 152;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyb_entry() //  [R1]
         { info_tbl: [(ccKyh,
                       label: sat_scHyb_info
                       rep:HeapRep 19 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKyh: // global
           _scHyb::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccKyi; else goto ccKyj;
       ccKyj: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccKyl; else goto ccKyk;
       ccKyl: // global
           HpAlloc = 160;
           goto ccKyi;
       ccKyi: // global
           R1 = _scHyb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKyk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHyb::P64;
           _scHv9::P64 = P64[_scHyb::P64 + 16];
           _scHva::P64 = P64[_scHyb::P64 + 24];
           _scHvb::P64 = P64[_scHyb::P64 + 32];
           _scHvc::P64 = P64[_scHyb::P64 + 40];
           _scHvd::P64 = P64[_scHyb::P64 + 48];
           _scHve::P64 = P64[_scHyb::P64 + 56];
           _scHvi::P64 = P64[_scHyb::P64 + 64];
           _scHvn::P64 = P64[_scHyb::P64 + 72];
           _scHvs::P64 = P64[_scHyb::P64 + 80];
           _scHvx::P64 = P64[_scHyb::P64 + 88];
           _scHvC::P64 = P64[_scHyb::P64 + 96];
           _scHvH::P64 = P64[_scHyb::P64 + 104];
           _scHvM::P64 = P64[_scHyb::P64 + 112];
           _scHvR::P64 = P64[_scHyb::P64 + 120];
           _scHvW::P64 = P64[_scHyb::P64 + 128];
           _scHw1::P64 = P64[_scHyb::P64 + 136];
           _scHw6::P64 = P64[_scHyb::P64 + 144];
           _scHwb::P64 = P64[_scHyb::P64 + 152];
           _scHwd::P64 = P64[_scHyb::P64 + 160];
           I64[Hp - 152] = sat_scHy7_info;
           P64[Hp - 136] = _scHv9::P64;
           P64[Hp - 128] = _scHva::P64;
           P64[Hp - 120] = _scHvb::P64;
           P64[Hp - 112] = _scHvc::P64;
           P64[Hp - 104] = _scHvd::P64;
           P64[Hp - 96] = _scHve::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           I64[Sp - 24] = block_ccKye_info;
           R4 = Hp - 152;
           R3 = _scHvi::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKye() //  [R1, R2]
         { info_tbl: [(ccKye,
                       label: block_ccKye_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKye: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKyo; else goto ccKyn;
       ccKyo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKyn: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyc_entry() //  [R1]
         { info_tbl: [(ccKyp,
                       label: sat_scHyc_info
                       rep:HeapRep 19 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKyp: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccKyt; else goto ccKys;
       ccKyt: // global
           HpAlloc = 168;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKys: // global
           _scHv9::P64 = P64[R1 + 16];
           _scHva::P64 = P64[R1 + 24];
           _scHvb::P64 = P64[R1 + 32];
           _scHvc::P64 = P64[R1 + 40];
           _scHvd::P64 = P64[R1 + 48];
           _scHve::P64 = P64[R1 + 56];
           _scHvi::P64 = P64[R1 + 64];
           _scHvn::P64 = P64[R1 + 72];
           _scHvs::P64 = P64[R1 + 80];
           _scHvx::P64 = P64[R1 + 88];
           _scHvC::P64 = P64[R1 + 96];
           _scHvH::P64 = P64[R1 + 104];
           _scHvM::P64 = P64[R1 + 112];
           _scHvR::P64 = P64[R1 + 120];
           _scHvW::P64 = P64[R1 + 128];
           _scHw1::P64 = P64[R1 + 136];
           _scHw6::P64 = P64[R1 + 144];
           _scHwb::P64 = P64[R1 + 152];
           _scHwd::P64 = P64[R1 + 160];
           I64[Hp - 160] = sat_scHyb_info;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 160;
           R2 = lvl19_rcHpO_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHyd_entry() //  [R1]
         { info_tbl: [(ccKyu,
                       label: sat_scHyd_info
                       rep:HeapRep 19 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKyu: // global
           _scHyd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKyv; else goto ccKyw;
       ccKyw: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccKyy; else goto ccKyx;
       ccKyy: // global
           HpAlloc = 168;
           goto ccKyv;
       ccKyv: // global
           R1 = _scHyd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKyx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHyd::P64;
           _scHv9::P64 = P64[_scHyd::P64 + 16];
           _scHva::P64 = P64[_scHyd::P64 + 24];
           _scHvb::P64 = P64[_scHyd::P64 + 32];
           _scHvc::P64 = P64[_scHyd::P64 + 40];
           _scHvd::P64 = P64[_scHyd::P64 + 48];
           _scHve::P64 = P64[_scHyd::P64 + 56];
           _scHvi::P64 = P64[_scHyd::P64 + 64];
           _scHvn::P64 = P64[_scHyd::P64 + 72];
           _scHvs::P64 = P64[_scHyd::P64 + 80];
           _scHvx::P64 = P64[_scHyd::P64 + 88];
           _scHvC::P64 = P64[_scHyd::P64 + 96];
           _scHvH::P64 = P64[_scHyd::P64 + 104];
           _scHvM::P64 = P64[_scHyd::P64 + 112];
           _scHvR::P64 = P64[_scHyd::P64 + 120];
           _scHvW::P64 = P64[_scHyd::P64 + 128];
           _scHw1::P64 = P64[_scHyd::P64 + 136];
           _scHw6::P64 = P64[_scHyd::P64 + 144];
           _scHwb::P64 = P64[_scHyd::P64 + 152];
           _scHwd::P64 = P64[_scHyd::P64 + 160];
           I64[Hp - 160] = sat_scHyc_info;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 160;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyh_entry() //  [R1]
         { info_tbl: [(ccKyz,
                       label: sat_scHyh_info
                       rep:HeapRep 20 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKyz: // global
           if ((Sp + -176) < SpLim) (likely: False) goto ccKyG; else goto ccKyH;
       ccKyG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKyH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 176] = block_ccKod_info;
           _scHv9::P64 = P64[R1 + 24];
           _scHva::P64 = P64[R1 + 32];
           _scHvb::P64 = P64[R1 + 40];
           _scHvc::P64 = P64[R1 + 48];
           _scHvd::P64 = P64[R1 + 56];
           _scHve::P64 = P64[R1 + 64];
           _scHvi::P64 = P64[R1 + 72];
           _scHvn::P64 = P64[R1 + 80];
           _scHvs::P64 = P64[R1 + 88];
           _scHvx::P64 = P64[R1 + 96];
           _scHvC::P64 = P64[R1 + 104];
           _scHvH::P64 = P64[R1 + 112];
           _scHvM::P64 = P64[R1 + 120];
           _scHvR::P64 = P64[R1 + 128];
           _scHvW::P64 = P64[R1 + 136];
           _scHw1::P64 = P64[R1 + 144];
           _scHw6::P64 = P64[R1 + 152];
           _scHwb::P64 = P64[R1 + 160];
           _scHwd::P64 = P64[R1 + 168];
           R1 = P64[R1 + 16];
           P64[Sp - 168] = _scHv9::P64;
           P64[Sp - 160] = _scHva::P64;
           P64[Sp - 152] = _scHvb::P64;
           P64[Sp - 144] = _scHvc::P64;
           P64[Sp - 136] = _scHvd::P64;
           P64[Sp - 128] = _scHve::P64;
           P64[Sp - 120] = _scHvi::P64;
           P64[Sp - 112] = _scHvn::P64;
           P64[Sp - 104] = _scHvs::P64;
           P64[Sp - 96] = _scHvx::P64;
           P64[Sp - 88] = _scHvC::P64;
           P64[Sp - 80] = _scHvH::P64;
           P64[Sp - 72] = _scHvM::P64;
           P64[Sp - 64] = _scHvR::P64;
           P64[Sp - 56] = _scHvW::P64;
           P64[Sp - 48] = _scHw1::P64;
           P64[Sp - 40] = _scHw6::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 176;
           if (R1 & 7 != 0) goto ucKyO; else goto ccKoe;
       ucKyO: // global
           call _ccKod(R1) args: 0, res: 0, upd: 0;
       ccKoe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKod() //  [R1]
         { info_tbl: [(ccKod,
                       label: block_ccKod_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKod: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccKyK; else goto ccKyJ;
       ccKyK: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccKyJ: // global
           _scHwi::I64 = I64[R1 + 7];
           I64[Hp - 160] = sat_scHyd_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           P64[Hp - 128] = P64[Sp + 24];
           P64[Hp - 120] = P64[Sp + 32];
           P64[Hp - 112] = P64[Sp + 40];
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           P64[Hp - 16] = P64[Sp + 136];
           P64[Hp - 8] = P64[Sp + 144];
           P64[Hp] = P64[Sp + 152];
           I64[Sp + 152] = block_ccKyD_info;
           R3 = Hp - 160;
           R2 = _scHwi::I64;
           Sp = Sp + 152;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKyD() //  [R1, R2]
         { info_tbl: [(ccKyD,
                       label: block_ccKyD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKyD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKyN; else goto ccKyM;
       ccKyN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKyM: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyi_entry() //  [R1]
         { info_tbl: [(ccKyP,
                       label: sat_scHyi_info
                       rep:HeapRep 20 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKyP: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccKyT; else goto ccKyS;
       ccKyT: // global
           HpAlloc = 176;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKyS: // global
           _scHuX::P64 = P64[R1 + 16];
           _scHv9::P64 = P64[R1 + 24];
           _scHva::P64 = P64[R1 + 32];
           _scHvb::P64 = P64[R1 + 40];
           _scHvc::P64 = P64[R1 + 48];
           _scHvd::P64 = P64[R1 + 56];
           _scHve::P64 = P64[R1 + 64];
           _scHvi::P64 = P64[R1 + 72];
           _scHvn::P64 = P64[R1 + 80];
           _scHvs::P64 = P64[R1 + 88];
           _scHvx::P64 = P64[R1 + 96];
           _scHvC::P64 = P64[R1 + 104];
           _scHvH::P64 = P64[R1 + 112];
           _scHvM::P64 = P64[R1 + 120];
           _scHvR::P64 = P64[R1 + 128];
           _scHvW::P64 = P64[R1 + 136];
           _scHw1::P64 = P64[R1 + 144];
           _scHw6::P64 = P64[R1 + 152];
           _scHwb::P64 = P64[R1 + 160];
           _scHwd::P64 = P64[R1 + 168];
           I64[Hp - 168] = sat_scHyh_info;
           P64[Hp - 152] = _scHuX::P64;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 168;
           R2 = lvl18_rcHpN_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHyj_entry() //  [R1]
         { info_tbl: [(ccKyU,
                       label: sat_scHyj_info
                       rep:HeapRep 20 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKyU: // global
           _scHyj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKyV; else goto ccKyW;
       ccKyW: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccKyY; else goto ccKyX;
       ccKyY: // global
           HpAlloc = 176;
           goto ccKyV;
       ccKyV: // global
           R1 = _scHyj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKyX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHyj::P64;
           _scHuX::P64 = P64[_scHyj::P64 + 16];
           _scHv9::P64 = P64[_scHyj::P64 + 24];
           _scHva::P64 = P64[_scHyj::P64 + 32];
           _scHvb::P64 = P64[_scHyj::P64 + 40];
           _scHvc::P64 = P64[_scHyj::P64 + 48];
           _scHvd::P64 = P64[_scHyj::P64 + 56];
           _scHve::P64 = P64[_scHyj::P64 + 64];
           _scHvi::P64 = P64[_scHyj::P64 + 72];
           _scHvn::P64 = P64[_scHyj::P64 + 80];
           _scHvs::P64 = P64[_scHyj::P64 + 88];
           _scHvx::P64 = P64[_scHyj::P64 + 96];
           _scHvC::P64 = P64[_scHyj::P64 + 104];
           _scHvH::P64 = P64[_scHyj::P64 + 112];
           _scHvM::P64 = P64[_scHyj::P64 + 120];
           _scHvR::P64 = P64[_scHyj::P64 + 128];
           _scHvW::P64 = P64[_scHyj::P64 + 136];
           _scHw1::P64 = P64[_scHyj::P64 + 144];
           _scHw6::P64 = P64[_scHyj::P64 + 152];
           _scHwb::P64 = P64[_scHyj::P64 + 160];
           _scHwd::P64 = P64[_scHyj::P64 + 168];
           I64[Hp - 168] = sat_scHyi_info;
           P64[Hp - 152] = _scHuX::P64;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 168;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyn_entry() //  [R1]
         { info_tbl: [(ccKyZ,
                       label: sat_scHyn_info
                       rep:HeapRep 21 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKyZ: // global
           if ((Sp + -184) < SpLim) (likely: False) goto ccKz6; else goto ccKz7;
       ccKz6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKz7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 184] = block_ccKnW_info;
           _scHuX::P64 = P64[R1 + 24];
           _scHv9::P64 = P64[R1 + 32];
           _scHva::P64 = P64[R1 + 40];
           _scHvb::P64 = P64[R1 + 48];
           _scHvc::P64 = P64[R1 + 56];
           _scHvd::P64 = P64[R1 + 64];
           _scHve::P64 = P64[R1 + 72];
           _scHvi::P64 = P64[R1 + 80];
           _scHvn::P64 = P64[R1 + 88];
           _scHvs::P64 = P64[R1 + 96];
           _scHvx::P64 = P64[R1 + 104];
           _scHvC::P64 = P64[R1 + 112];
           _scHvH::P64 = P64[R1 + 120];
           _scHvM::P64 = P64[R1 + 128];
           _scHvR::P64 = P64[R1 + 136];
           _scHvW::P64 = P64[R1 + 144];
           _scHw1::P64 = P64[R1 + 152];
           _scHw6::P64 = P64[R1 + 160];
           _scHwb::P64 = P64[R1 + 168];
           _scHwd::P64 = P64[R1 + 176];
           R1 = P64[R1 + 16];
           P64[Sp - 176] = _scHuX::P64;
           P64[Sp - 168] = _scHv9::P64;
           P64[Sp - 160] = _scHva::P64;
           P64[Sp - 152] = _scHvb::P64;
           P64[Sp - 144] = _scHvc::P64;
           P64[Sp - 136] = _scHvd::P64;
           P64[Sp - 128] = _scHve::P64;
           P64[Sp - 120] = _scHvi::P64;
           P64[Sp - 112] = _scHvn::P64;
           P64[Sp - 104] = _scHvs::P64;
           P64[Sp - 96] = _scHvx::P64;
           P64[Sp - 88] = _scHvC::P64;
           P64[Sp - 80] = _scHvH::P64;
           P64[Sp - 72] = _scHvM::P64;
           P64[Sp - 64] = _scHvR::P64;
           P64[Sp - 56] = _scHvW::P64;
           P64[Sp - 48] = _scHw1::P64;
           P64[Sp - 40] = _scHw6::P64;
           P64[Sp - 32] = _scHwb::P64;
           P64[Sp - 24] = _scHwd::P64;
           Sp = Sp - 184;
           if (R1 & 7 != 0) goto ucKze; else goto ccKnX;
       ucKze: // global
           call _ccKnW(R1) args: 0, res: 0, upd: 0;
       ccKnX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccKnW() //  [R1]
         { info_tbl: [(ccKnW,
                       label: block_ccKnW_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKnW: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccKza; else goto ccKz9;
       ccKza: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccKz9: // global
           _scHwf::I64 = I64[R1 + 7];
           I64[Hp - 168] = sat_scHyj_info;
           P64[Hp - 152] = P64[Sp + 8];
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = P64[Sp + 48];
           P64[Hp - 104] = P64[Sp + 56];
           P64[Hp - 96] = P64[Sp + 64];
           P64[Hp - 88] = P64[Sp + 72];
           P64[Hp - 80] = P64[Sp + 80];
           P64[Hp - 72] = P64[Sp + 88];
           P64[Hp - 64] = P64[Sp + 96];
           P64[Hp - 56] = P64[Sp + 104];
           P64[Hp - 48] = P64[Sp + 112];
           P64[Hp - 40] = P64[Sp + 120];
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 144];
           P64[Hp - 8] = P64[Sp + 152];
           P64[Hp] = P64[Sp + 160];
           I64[Sp + 160] = block_ccKz3_info;
           R3 = Hp - 168;
           R2 = _scHwf::I64;
           Sp = Sp + 160;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccKz3() //  [R1, R2]
         { info_tbl: [(ccKz3,
                       label: block_ccKz3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKz3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKzd; else goto ccKzc;
       ccKzd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccKzc: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyo_entry() //  [R1]
         { info_tbl: [(ccKzf,
                       label: sat_scHyo_info
                       rep:HeapRep 21 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKzf: // global
           _scHyo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKzg; else goto ccKzh;
       ccKzh: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto ccKzj; else goto ccKzi;
       ccKzj: // global
           HpAlloc = 184;
           goto ccKzg;
       ccKzg: // global
           R1 = _scHyo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKzi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHyo::P64;
           _scHuW::P64 = P64[_scHyo::P64 + 16];
           _scHuX::P64 = P64[_scHyo::P64 + 24];
           _scHv9::P64 = P64[_scHyo::P64 + 32];
           _scHva::P64 = P64[_scHyo::P64 + 40];
           _scHvb::P64 = P64[_scHyo::P64 + 48];
           _scHvc::P64 = P64[_scHyo::P64 + 56];
           _scHvd::P64 = P64[_scHyo::P64 + 64];
           _scHve::P64 = P64[_scHyo::P64 + 72];
           _scHvi::P64 = P64[_scHyo::P64 + 80];
           _scHvn::P64 = P64[_scHyo::P64 + 88];
           _scHvs::P64 = P64[_scHyo::P64 + 96];
           _scHvx::P64 = P64[_scHyo::P64 + 104];
           _scHvC::P64 = P64[_scHyo::P64 + 112];
           _scHvH::P64 = P64[_scHyo::P64 + 120];
           _scHvM::P64 = P64[_scHyo::P64 + 128];
           _scHvR::P64 = P64[_scHyo::P64 + 136];
           _scHvW::P64 = P64[_scHyo::P64 + 144];
           _scHw1::P64 = P64[_scHyo::P64 + 152];
           _scHw6::P64 = P64[_scHyo::P64 + 160];
           _scHwb::P64 = P64[_scHyo::P64 + 168];
           _scHwd::P64 = P64[_scHyo::P64 + 176];
           I64[Hp - 176] = sat_scHyn_info;
           P64[Hp - 160] = _scHuW::P64;
           P64[Hp - 152] = _scHuX::P64;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = _scHwd::P64;
           R3 = Hp - 176;
           R2 = lvl17_rcHpM_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_scHwc_entry() //  [R1, R2]
         { info_tbl: [(ccKzk,
                       label: p_scHwc_info
                       rep:HeapRep 20 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKzk: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto ccKzo; else goto ccKzn;
       ccKzo: // global
           HpAlloc = 184;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKzn: // global
           _scHuW::P64 = P64[R1 + 7];
           _scHuX::P64 = P64[R1 + 15];
           _scHv9::P64 = P64[R1 + 23];
           _scHva::P64 = P64[R1 + 31];
           _scHvb::P64 = P64[R1 + 39];
           _scHvc::P64 = P64[R1 + 47];
           _scHvd::P64 = P64[R1 + 55];
           _scHve::P64 = P64[R1 + 63];
           _scHvi::P64 = P64[R1 + 71];
           _scHvn::P64 = P64[R1 + 79];
           _scHvs::P64 = P64[R1 + 87];
           _scHvx::P64 = P64[R1 + 95];
           _scHvC::P64 = P64[R1 + 103];
           _scHvH::P64 = P64[R1 + 111];
           _scHvM::P64 = P64[R1 + 119];
           _scHvR::P64 = P64[R1 + 127];
           _scHvW::P64 = P64[R1 + 135];
           _scHw1::P64 = P64[R1 + 143];
           _scHw6::P64 = P64[R1 + 151];
           _scHwb::P64 = P64[R1 + 159];
           I64[Hp - 176] = sat_scHyo_info;
           P64[Hp - 160] = _scHuW::P64;
           P64[Hp - 152] = _scHuX::P64;
           P64[Hp - 144] = _scHv9::P64;
           P64[Hp - 136] = _scHva::P64;
           P64[Hp - 128] = _scHvb::P64;
           P64[Hp - 120] = _scHvc::P64;
           P64[Hp - 112] = _scHvd::P64;
           P64[Hp - 104] = _scHve::P64;
           P64[Hp - 96] = _scHvi::P64;
           P64[Hp - 88] = _scHvn::P64;
           P64[Hp - 80] = _scHvs::P64;
           P64[Hp - 72] = _scHvx::P64;
           P64[Hp - 64] = _scHvC::P64;
           P64[Hp - 56] = _scHvH::P64;
           P64[Hp - 48] = _scHvM::P64;
           P64[Hp - 40] = _scHvR::P64;
           P64[Hp - 32] = _scHvW::P64;
           P64[Hp - 24] = _scHw1::P64;
           P64[Hp - 16] = _scHw6::P64;
           P64[Hp - 8] = _scHwb::P64;
           P64[Hp] = R2;
           R3 = Hp - 176;
           R2 = lvl16_rcHpL_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHys_entry() //  [R1]
         { info_tbl: [(ccKzD,
                       label: sat_scHys_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKzD: // global
           _scHys::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccKzE; else goto ccKzF;
       ccKzF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKzH; else goto ccKzG;
       ccKzH: // global
           HpAlloc = 24;
           goto ccKzE;
       ccKzE: // global
           R1 = _scHys::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKzG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scHys::P64;
           _scHwc::P64 = P64[_scHys::P64 + 16];
           _scHyq::P64 = P64[_scHys::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _scHyq::P64;
           R2 = Hp - 14;
           R1 = _scHwc::P64;
           Sp = Sp - 16;
           call p_scHwc_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scHyt_entry() //  [R1, R2]
         { info_tbl: [(ccKzJ,
                       label: sat_scHyt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKzJ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccKzN; else goto ccKzM;
       ccKzN: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKzM: // global
           _scHwc::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_scHys_info;
           P64[Hp - 32] = _scHwc::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stats.$fShowRTSStats_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(ccKzO,
                       label: GHC.Stats.$fShowRTSStats_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKzO: // global
           if ((Sp + -168) < SpLim) (likely: False) goto ccKzP; else goto ccKzQ;
       ccKzP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fShowRTSStats_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccKzQ: // global
           I64[Sp - 16] = block_ccKjy_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucKzZ; else goto ccKjz;
       ucKzZ: // global
           call _ccKjy(R1) args: 0, res: 0, upd: 0;
       ccKjz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccKjy() //  [R1]
         { info_tbl: [(ccKjy,
                       label: block_ccKjy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKjy: // global
           I64[Sp - 152] = block_ccKjD_info;
           _scHuW::P64 = P64[R1 + 7];
           _scHuX::P64 = P64[R1 + 15];
           _scHuY::P64 = P64[R1 + 23];
           _scHuZ::P64 = P64[R1 + 31];
           _scHv0::P64 = P64[R1 + 39];
           _scHv1::P64 = P64[R1 + 47];
           _scHv2::P64 = P64[R1 + 55];
           _scHv3::P64 = P64[R1 + 63];
           _scHv4::P64 = P64[R1 + 71];
           _scHv5::P64 = P64[R1 + 79];
           _scHv6::P64 = P64[R1 + 87];
           _scHv7::P64 = P64[R1 + 95];
           _scHv8::P64 = P64[R1 + 103];
           _scHv9::P64 = P64[R1 + 111];
           _scHva::P64 = P64[R1 + 119];
           _scHvb::P64 = P64[R1 + 127];
           _scHvc::P64 = P64[R1 + 135];
           _scHvd::P64 = P64[R1 + 143];
           _scHve::P64 = P64[R1 + 151];
           _scHvf::P64 = P64[R1 + 159];
           R1 = P64[Sp + 8];
           P64[Sp - 144] = _scHuY::P64;
           P64[Sp - 136] = _scHuZ::P64;
           P64[Sp - 128] = _scHv0::P64;
           P64[Sp - 120] = _scHv1::P64;
           P64[Sp - 112] = _scHv2::P64;
           P64[Sp - 104] = _scHv3::P64;
           P64[Sp - 96] = _scHv4::P64;
           P64[Sp - 88] = _scHv5::P64;
           P64[Sp - 80] = _scHv6::P64;
           P64[Sp - 72] = _scHv7::P64;
           P64[Sp - 64] = _scHv8::P64;
           P64[Sp - 56] = _scHv9::P64;
           P64[Sp - 48] = _scHva::P64;
           P64[Sp - 40] = _scHvb::P64;
           P64[Sp - 32] = _scHvc::P64;
           P64[Sp - 24] = _scHvd::P64;
           P64[Sp - 16] = _scHve::P64;
           P64[Sp - 8] = _scHvf::P64;
           P64[Sp] = _scHuX::P64;
           P64[Sp + 8] = _scHuW::P64;
           Sp = Sp - 152;
           if (R1 & 7 != 0) goto ucKzY; else goto ccKjE;
       ucKzY: // global
           call _ccKjD(R1) args: 0, res: 0, upd: 0;
       ccKjE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccKjD() //  [R1]
         { info_tbl: [(ccKjD,
                       label: block_ccKjD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKjD: // global
           Hp = Hp + 472;
           if (Hp > HpLim) (likely: False) goto ccKzU; else goto ccKzT;
       ccKzU: // global
           HpAlloc = 472;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKzT: // global
           _scHvh::I64 = I64[R1 + 7];
           I64[Hp - 464] = w1_scHvi_info;
           P64[Hp - 448] = P64[Sp + 8];
           I64[Hp - 440] = w2_scHvn_info;
           P64[Hp - 424] = P64[Sp + 16];
           I64[Hp - 416] = w3_scHvs_info;
           P64[Hp - 400] = P64[Sp + 24];
           I64[Hp - 392] = w4_scHvx_info;
           P64[Hp - 376] = P64[Sp + 32];
           I64[Hp - 368] = w5_scHvC_info;
           P64[Hp - 352] = P64[Sp + 40];
           I64[Hp - 344] = w6_scHvH_info;
           P64[Hp - 328] = P64[Sp + 48];
           I64[Hp - 320] = w7_scHvM_info;
           P64[Hp - 304] = P64[Sp + 56];
           I64[Hp - 296] = w8_scHvR_info;
           P64[Hp - 280] = P64[Sp + 64];
           I64[Hp - 272] = w9_scHvW_info;
           P64[Hp - 256] = P64[Sp + 72];
           I64[Hp - 248] = w10_scHw1_info;
           P64[Hp - 232] = P64[Sp + 80];
           I64[Hp - 224] = w11_scHw6_info;
           P64[Hp - 208] = P64[Sp + 88];
           I64[Hp - 200] = f_scHwb_info;
           P64[Hp - 184] = P64[Sp + 144];
           I64[Hp - 176] = p_scHwc_info;
           P64[Hp - 168] = P64[Sp + 160];
           P64[Hp - 160] = P64[Sp + 152];
           P64[Hp - 152] = P64[Sp + 96];
           P64[Hp - 144] = P64[Sp + 104];
           P64[Hp - 136] = P64[Sp + 112];
           P64[Hp - 128] = P64[Sp + 120];
           P64[Hp - 120] = P64[Sp + 128];
           P64[Hp - 112] = P64[Sp + 136];
           P64[Hp - 104] = Hp - 464;
           P64[Hp - 96] = Hp - 440;
           P64[Hp - 88] = Hp - 416;
           P64[Hp - 80] = Hp - 392;
           P64[Hp - 72] = Hp - 368;
           P64[Hp - 64] = Hp - 344;
           P64[Hp - 56] = Hp - 320;
           P64[Hp - 48] = Hp - 296;
           P64[Hp - 40] = Hp - 272;
           P64[Hp - 32] = Hp - 248;
           P64[Hp - 24] = Hp - 224;
           P64[Hp - 16] = Hp - 200;
           _ccKnJ::P64 = Hp - 175;
           if (%MO_S_Lt_W64(_scHvh::I64, 11)) goto ccKzW; else goto ccKzX;
       ccKzW: // global
           Hp = Hp - 16;
           R1 = _ccKnJ::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccKzX: // global
           I64[Hp - 8] = sat_scHyt_info;
           P64[Hp] = _ccKnJ::P64;
           R1 = Hp - 7;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.314198191 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_$cshow_closure" {
     GHC.Stats.$fShowRTSStats_$cshow_closure:
         const GHC.Stats.$fShowRTSStats_$cshow_info;
         const 0;
 },
 GHC.Stats.$fShowRTSStats_$cshow_entry() //  [R2]
         { info_tbl: [(ccKIS,
                       label: GHC.Stats.$fShowRTSStats_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKIS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKIT; else goto ccKIU;
       ccKIT: // global
           R2 = R2;
           R1 = GHC.Stats.$fShowRTSStats_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKIU: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Stats.$fShowRTSStats_$cshowsPrec_entry(R3,
                                                           R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.318312489 UTC

[section ""data" . GHC.Stats.$fShowRTSStats1_closure" {
     GHC.Stats.$fShowRTSStats1_closure:
         const GHC.Stats.$fShowRTSStats1_info;
         const 0;
 },
 GHC.Stats.$fShowRTSStats1_entry() //  [R2]
         { info_tbl: [(ccKJ4,
                       label: GHC.Stats.$fShowRTSStats1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKJ4: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           call GHC.Stats.$fShowRTSStats_$cshowsPrec_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.322003981 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_$cshowList_closure" {
     GHC.Stats.$fShowRTSStats_$cshowList_closure:
         const GHC.Stats.$fShowRTSStats_$cshowList_info;
         const 0;
 },
 GHC.Stats.$fShowRTSStats_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(ccKJf,
                       label: GHC.Stats.$fShowRTSStats_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKJf: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fShowRTSStats1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.326105387 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_closure" {
     GHC.Stats.$fShowRTSStats_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Stats.$fShowRTSStats_$cshowsPrec_closure+2;
         const GHC.Stats.$fShowRTSStats_$cshow_closure+1;
         const GHC.Stats.$fShowRTSStats_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.327925558 UTC

[section ""cstring" . GHC.Stats.$tcGCDetails2_bytes" {
     GHC.Stats.$tcGCDetails2_bytes:
         I8[] [71,67,68,101,116,97,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.33432774 UTC

[section ""data" . lexeme_rcHq6_closure" {
     lexeme_rcHq6_closure:
         const lexeme_rcHq6_info;
         const 0;
         const 0;
         const 0;
 },
 lexeme_rcHq6_entry() //  [R1]
         { info_tbl: [(ccKJu,
                       label: lexeme_rcHq6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKJu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKJv; else goto ccKJw;
       ccKJv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKJw: // global
           (_ccKJr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKJr::I64 == 0) goto ccKJt; else goto ccKJs;
       ccKJt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKJs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKJr::I64;
           R2 = GHC.Stats.$tcGCDetails2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.340839522 UTC

[section ""data" . lexeme1_rcHq7_closure" {
     lexeme1_rcHq7_closure:
         const Text.Read.Lex.Ident_con_info;
         const lexeme_rcHq6_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.343611535 UTC

[section ""cstring" . lexeme2_rcHq8_bytes" {
     lexeme2_rcHq8_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.34673027 UTC

[section ""data" . lexeme3_rcHq9_closure" {
     lexeme3_rcHq9_closure:
         const lexeme3_rcHq9_info;
         const 0;
         const 0;
         const 0;
 },
 lexeme3_rcHq9_entry() //  [R1]
         { info_tbl: [(ccKJM,
                       label: lexeme3_rcHq9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKJM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKJN; else goto ccKJO;
       ccKJN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKJO: // global
           (_ccKJJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKJJ::I64 == 0) goto ccKJL; else goto ccKJK;
       ccKJL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKJK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKJJ::I64;
           R2 = lexeme2_rcHq8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.353823388 UTC

[section ""data" . lexeme4_rcHqa_closure" {
     lexeme4_rcHqa_closure:
         const Text.Read.Lex.Punc_con_info;
         const lexeme3_rcHq9_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.356640105 UTC

[section ""cstring" . ds_rcHqb_bytes" {
     ds_rcHqb_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,103,101,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.359696649 UTC

[section ""data" . ds1_rcHqc_closure" {
     ds1_rcHqc_closure:
         const ds1_rcHqc_info;
         const 0;
         const 0;
         const 0;
 },
 ds1_rcHqc_entry() //  [R1]
         { info_tbl: [(ccKK4,
                       label: ds1_rcHqc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKK4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKK5; else goto ccKK6;
       ccKK5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKK6: // global
           (_ccKK1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKK1::I64 == 0) goto ccKK3; else goto ccKK2;
       ccKK3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKK2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKK1::I64;
           R2 = ds_rcHqb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.366314187 UTC

[section ""data" . lvl37_rcHqd_closure" {
     lvl37_rcHqd_closure:
         const lvl37_rcHqd_info;
         const 0;
 },
 lvl37_rcHqd_entry() //  [R2]
         { info_tbl: [(ccKKi,
                       label: lvl37_rcHqd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKKi: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           call GHC.Read.$fReadWord32_$creadsPrec_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.371532525 UTC

[section ""data" . ds2_rcHqe_closure" {
     ds2_rcHqe_closure:
         const ds2_rcHqe_info;
         const 0;
 },
 ds2_rcHqe_entry() //  [R2, R3]
         { info_tbl: [(ccKKw,
                       label: ds2_rcHqe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKKw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccKKx; else goto ccKKy;
       ccKKx: // global
           R3 = R3;
           R2 = R2;
           R1 = ds2_rcHqe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccKKy: // global
           I64[Sp - 8] = block_ccKKt_info;
           R3 = R3;
           R2 = lvl37_rcHqd_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKKt() //  [R1]
         { info_tbl: [(ccKKt,
                       label: block_ccKKt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKKt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKKB; else goto ccKKA;
       ccKKB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKKA: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.377529174 UTC

[section ""data" . n_rcHqf_closure" {
     n_rcHqf_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.379370073 UTC

[section ""cstring" . lvl38_rcHqg_bytes" {
     lvl38_rcHqg_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.381505341 UTC

[section ""data" . lvl39_rcHqh_closure" {
     lvl39_rcHqh_closure:
         const lvl39_rcHqh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl39_rcHqh_entry() //  [R1]
         { info_tbl: [(ccKKT,
                       label: lvl39_rcHqh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKKT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKKU; else goto ccKKV;
       ccKKU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKKV: // global
           (_ccKKQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKKQ::I64 == 0) goto ccKKS; else goto ccKKR;
       ccKKS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKKR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKKQ::I64;
           R2 = lvl38_rcHqg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.385996766 UTC

[section ""data" . lvl40_rcHqi_closure" {
     lvl40_rcHqi_closure:
         const Text.Read.Lex.Punc_con_info;
         const lvl39_rcHqh_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.387871418 UTC

[section ""cstring" . lvl41_rcHqj_bytes" {
     lvl41_rcHqj_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,116,104,114,101,97,100,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.390429497 UTC

[section ""data" . lvl42_rcHqk_closure" {
     lvl42_rcHqk_closure:
         const lvl42_rcHqk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_rcHqk_entry() //  [R1]
         { info_tbl: [(ccKLb,
                       label: lvl42_rcHqk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKLb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKLc; else goto ccKLd;
       ccKLc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKLd: // global
           (_ccKL8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKL8::I64 == 0) goto ccKLa; else goto ccKL9;
       ccKLa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKL9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKL8::I64;
           R2 = lvl41_rcHqj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.396730928 UTC

[section ""cstring" . lvl43_rcHql_bytes" {
     lvl43_rcHql_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,97,108,108,111,99,97,116,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.399969251 UTC

[section ""data" . lvl44_rcHqm_closure" {
     lvl44_rcHqm_closure:
         const lvl44_rcHqm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl44_rcHqm_entry() //  [R1]
         { info_tbl: [(ccKLs,
                       label: lvl44_rcHqm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKLs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKLt; else goto ccKLu;
       ccKLt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKLu: // global
           (_ccKLp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKLp::I64 == 0) goto ccKLr; else goto ccKLq;
       ccKLr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKLq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKLp::I64;
           R2 = lvl43_rcHql_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.407288818 UTC

[section ""data" . lvl45_rcHqn_closure" {
     lvl45_rcHqn_closure:
         const lvl45_rcHqn_info;
         const 0;
 },
 lvl45_rcHqn_entry() //  [R2]
         { info_tbl: [(ccKLG,
                       label: lvl45_rcHqn_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKLG: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           call GHC.Read.$fReadWord64_$creadsPrec_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.411840277 UTC

[section ""data" . lvl46_rcHqo_closure" {
     lvl46_rcHqo_closure:
         const lvl46_rcHqo_info;
         const 0;
 },
 lvl46_rcHqo_entry() //  [R2, R3]
         { info_tbl: [(ccKLU,
                       label: lvl46_rcHqo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKLU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccKLV; else goto ccKLW;
       ccKLV: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl46_rcHqo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccKLW: // global
           I64[Sp - 8] = block_ccKLR_info;
           R3 = R3;
           R2 = lvl45_rcHqn_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKLR() //  [R1]
         { info_tbl: [(ccKLR,
                       label: block_ccKLR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKLR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKLZ; else goto ccKLY;
       ccKLZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKLY: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.417513074 UTC

[section ""cstring" . lvl47_rcHqp_bytes" {
     lvl47_rcHqp_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,105,118,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.419587824 UTC

[section ""data" . lvl48_rcHqq_closure" {
     lvl48_rcHqq_closure:
         const lvl48_rcHqq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl48_rcHqq_entry() //  [R1]
         { info_tbl: [(ccKMg,
                       label: lvl48_rcHqq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKMg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKMh; else goto ccKMi;
       ccKMh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKMi: // global
           (_ccKMd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKMd::I64 == 0) goto ccKMf; else goto ccKMe;
       ccKMf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKMe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKMd::I64;
           R2 = lvl47_rcHqp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.423663001 UTC

[section ""cstring" . lvl49_rcHqr_bytes" {
     lvl49_rcHqr_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.425621022 UTC

[section ""data" . lvl50_rcHqs_closure" {
     lvl50_rcHqs_closure:
         const lvl50_rcHqs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl50_rcHqs_entry() //  [R1]
         { info_tbl: [(ccKMx,
                       label: lvl50_rcHqs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKMx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKMy; else goto ccKMz;
       ccKMy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKMz: // global
           (_ccKMu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKMu::I64 == 0) goto ccKMw; else goto ccKMv;
       ccKMw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKMv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKMu::I64;
           R2 = lvl49_rcHqr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.430009209 UTC

[section ""cstring" . lvl51_rcHqt_bytes" {
     lvl51_rcHqt_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,109,112,97,99,116,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.432215886 UTC

[section ""data" . lvl52_rcHqu_closure" {
     lvl52_rcHqu_closure:
         const lvl52_rcHqu_info;
         const 0;
         const 0;
         const 0;
 },
 lvl52_rcHqu_entry() //  [R1]
         { info_tbl: [(ccKMO,
                       label: lvl52_rcHqu_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKMO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKMP; else goto ccKMQ;
       ccKMP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKMQ: // global
           (_ccKML::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKML::I64 == 0) goto ccKMN; else goto ccKMM;
       ccKMN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKMM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKML::I64;
           R2 = lvl51_rcHqt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.437217212 UTC

[section ""cstring" . lvl53_rcHqv_bytes" {
     lvl53_rcHqv_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,108,111,112,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.439376276 UTC

[section ""data" . lvl54_rcHqw_closure" {
     lvl54_rcHqw_closure:
         const lvl54_rcHqw_info;
         const 0;
         const 0;
         const 0;
 },
 lvl54_rcHqw_entry() //  [R1]
         { info_tbl: [(ccKN5,
                       label: lvl54_rcHqw_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKN5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKN6; else goto ccKN7;
       ccKN6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKN7: // global
           (_ccKN2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKN2::I64 == 0) goto ccKN4; else goto ccKN3;
       ccKN4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKN3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKN2::I64;
           R2 = lvl53_rcHqv_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.443580281 UTC

[section ""cstring" . lvl55_rcHqx_bytes" {
     lvl55_rcHqx_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.445648836 UTC

[section ""data" . lvl56_rcHqy_closure" {
     lvl56_rcHqy_closure:
         const lvl56_rcHqy_info;
         const 0;
         const 0;
         const 0;
 },
 lvl56_rcHqy_entry() //  [R1]
         { info_tbl: [(ccKNm,
                       label: lvl56_rcHqy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKNm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKNn; else goto ccKNo;
       ccKNn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKNo: // global
           (_ccKNj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKNj::I64 == 0) goto ccKNl; else goto ccKNk;
       ccKNl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKNk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKNj::I64;
           R2 = lvl55_rcHqx_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.450269029 UTC

[section ""cstring" . lvl57_rcHqz_bytes" {
     lvl57_rcHqz_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.452379493 UTC

[section ""data" . lvl58_rcHqA_closure" {
     lvl58_rcHqA_closure:
         const lvl58_rcHqA_info;
         const 0;
         const 0;
         const 0;
 },
 lvl58_rcHqA_entry() //  [R1]
         { info_tbl: [(ccKND,
                       label: lvl58_rcHqA_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKND: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKNE; else goto ccKNF;
       ccKNE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKNF: // global
           (_ccKNA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKNA::I64 == 0) goto ccKNC; else goto ccKNB;
       ccKNC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKNB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKNA::I64;
           R2 = lvl57_rcHqz_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.456730539 UTC

[section ""cstring" . lvl59_rcHqB_bytes" {
     lvl59_rcHqB_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.458902919 UTC

[section ""data" . lvl60_rcHqC_closure" {
     lvl60_rcHqC_closure:
         const lvl60_rcHqC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl60_rcHqC_entry() //  [R1]
         { info_tbl: [(ccKNU,
                       label: lvl60_rcHqC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKNU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKNV; else goto ccKNW;
       ccKNV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKNW: // global
           (_ccKNR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKNR::I64 == 0) goto ccKNT; else goto ccKNS;
       ccKNT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKNS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKNR::I64;
           R2 = lvl59_rcHqB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.463313116 UTC

[section ""cstring" . lvl61_rcHqD_bytes" {
     lvl61_rcHqD_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.465540758 UTC

[section ""data" . lvl62_rcHqE_closure" {
     lvl62_rcHqE_closure:
         const lvl62_rcHqE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl62_rcHqE_entry() //  [R1]
         { info_tbl: [(ccKOb,
                       label: lvl62_rcHqE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKOb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKOc; else goto ccKOd;
       ccKOc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKOd: // global
           (_ccKO8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKO8::I64 == 0) goto ccKOa; else goto ccKO9;
       ccKOa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKO9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKO8::I64;
           R2 = lvl61_rcHqD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.470992983 UTC

[section ""cstring" . lvl63_rcHqF_bytes" {
     lvl63_rcHqF_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,121,110,99,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.473058344 UTC

[section ""data" . lvl64_rcHqG_closure" {
     lvl64_rcHqG_closure:
         const lvl64_rcHqG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl64_rcHqG_entry() //  [R1]
         { info_tbl: [(ccKOs,
                       label: lvl64_rcHqG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKOs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKOt; else goto ccKOu;
       ccKOt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKOu: // global
           (_ccKOp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKOp::I64 == 0) goto ccKOr; else goto ccKOq;
       ccKOr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKOq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKOp::I64;
           R2 = lvl63_rcHqF_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.47736367 UTC

[section ""data" . lvl65_rcHqH_closure" {
     lvl65_rcHqH_closure:
         const lvl65_rcHqH_info;
         const 0;
 },
 lvl65_rcHqH_entry() //  [R2]
         { info_tbl: [(ccKOG,
                       label: lvl65_rcHqH_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKOG: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           call GHC.Int.$fReadInt64_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.481327208 UTC

[section ""data" . lvl66_rcHqI_closure" {
     lvl66_rcHqI_closure:
         const lvl66_rcHqI_info;
         const 0;
 },
 lvl66_rcHqI_entry() //  [R2, R3]
         { info_tbl: [(ccKOU,
                       label: lvl66_rcHqI_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKOU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccKOV; else goto ccKOW;
       ccKOV: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl66_rcHqI_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccKOW: // global
           I64[Sp - 8] = block_ccKOR_info;
           R3 = R3;
           R2 = lvl65_rcHqH_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKOR() //  [R1]
         { info_tbl: [(ccKOR,
                       label: block_ccKOR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKOR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKOZ; else goto ccKOY;
       ccKOZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKOY: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.488263995 UTC

[section ""cstring" . lvl67_rcHqJ_bytes" {
     lvl67_rcHqJ_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.491443568 UTC

[section ""data" . lvl68_rcHqK_closure" {
     lvl68_rcHqK_closure:
         const lvl68_rcHqK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl68_rcHqK_entry() //  [R1]
         { info_tbl: [(ccKPg,
                       label: lvl68_rcHqK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKPg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKPh; else goto ccKPi;
       ccKPh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKPi: // global
           (_ccKPd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKPd::I64 == 0) goto ccKPf; else goto ccKPe;
       ccKPf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKPe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKPd::I64;
           R2 = lvl67_rcHqJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.498173727 UTC

[section ""cstring" . lvl69_rcHqL_bytes" {
     lvl69_rcHqL_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.501550099 UTC

[section ""data" . lvl70_rcHqM_closure" {
     lvl70_rcHqM_closure:
         const lvl70_rcHqM_info;
         const 0;
         const 0;
         const 0;
 },
 lvl70_rcHqM_entry() //  [R1]
         { info_tbl: [(ccKPx,
                       label: lvl70_rcHqM_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKPx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKPy; else goto ccKPz;
       ccKPy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKPz: // global
           (_ccKPu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKPu::I64 == 0) goto ccKPw; else goto ccKPv;
       ccKPw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKPv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKPu::I64;
           R2 = lvl69_rcHqL_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.509488314 UTC

[section ""data" . lvl71_rcHqN_closure" {
     lvl71_rcHqN_closure:
         const lvl71_rcHqN_info;
         const 0;
         const 0;
         const 0;
 },
 lvl71_rcHqN_entry() //  [R1]
         { info_tbl: [(ccKPN,
                       label: lvl71_rcHqN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKPN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKPO; else goto ccKPP;
       ccKPO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccKPP: // global
           (_ccKPK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccKPK::I64 == 0) goto ccKPM; else goto ccKPL;
       ccKPM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccKPL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccKPK::I64;
           R2 = lvl15_rcHpK_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.513599521 UTC

[section ""data" . lvl72_rcHqO_closure" {
     lvl72_rcHqO_closure:
         const Text.Read.Lex.Punc_con_info;
         const lvl71_rcHqN_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.523218835 UTC

[section ""data" . GHC.Stats.$w$creadPrec_closure" {
     GHC.Stats.$w$creadPrec_closure:
         const GHC.Stats.$w$creadPrec_info;
         const 0;
 },
 sat_scHzh_entry() //  [R1, R2]
         { info_tbl: [(ccKSx,
                       label: sat_scHzh_info
                       rep:HeapRep 15 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKSx: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccKSB; else goto ccKSA;
       ccKSB: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKSA: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           _scHz8::P64 = P64[R1 + 95];
           _scHza::P64 = P64[R1 + 103];
           _scHzc::P64 = P64[R1 + 111];
           _scHze::P64 = P64[R1 + 119];
           I64[Hp - 112] = GHC.Stats.GCDetails_con_info;
           P64[Hp - 104] = _scHyO::P64;
           P64[Hp - 96] = _scHyQ::P64;
           P64[Hp - 88] = _scHyS::P64;
           P64[Hp - 80] = _scHyU::P64;
           P64[Hp - 72] = _scHyW::P64;
           P64[Hp - 64] = _scHyY::P64;
           P64[Hp - 56] = _scHz0::P64;
           P64[Hp - 48] = _scHz2::P64;
           P64[Hp - 40] = _scHz4::P64;
           P64[Hp - 32] = _scHz6::P64;
           P64[Hp - 24] = _scHz8::P64;
           P64[Hp - 16] = _scHza::P64;
           P64[Hp - 8] = _scHzc::P64;
           P64[Hp] = _scHze::P64;
           R2 = Hp - 111;
           R1 = _scHyK::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzk_entry() //  [R1, R2]
         { info_tbl: [(ccKSF,
                       label: sat_scHzk_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKSF: // global
           _scHze::P64 = R2;
           _scHzk::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKSG; else goto ccKSH;
       ccKSH: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccKSJ; else goto ccKSI;
       ccKSJ: // global
           HpAlloc = 128;
           goto ccKSG;
       ccKSG: // global
           R2 = _scHze::P64;
           R1 = _scHzk::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKSI: // global
           _scHyK::P64 = P64[_scHzk::P64 + 7];
           _scHyO::P64 = P64[_scHzk::P64 + 15];
           _scHyQ::P64 = P64[_scHzk::P64 + 23];
           _scHyS::P64 = P64[_scHzk::P64 + 31];
           _scHyU::P64 = P64[_scHzk::P64 + 39];
           _scHyW::P64 = P64[_scHzk::P64 + 47];
           _scHyY::P64 = P64[_scHzk::P64 + 55];
           _scHz0::P64 = P64[_scHzk::P64 + 63];
           _scHz2::P64 = P64[_scHzk::P64 + 71];
           _scHz4::P64 = P64[_scHzk::P64 + 79];
           _scHz6::P64 = P64[_scHzk::P64 + 87];
           _scHz8::P64 = P64[_scHzk::P64 + 95];
           _scHza::P64 = P64[_scHzk::P64 + 103];
           _scHzc::P64 = P64[_scHzk::P64 + 111];
           I64[Hp - 120] = sat_scHzh_info;
           P64[Hp - 112] = _scHyK::P64;
           P64[Hp - 104] = _scHyO::P64;
           P64[Hp - 96] = _scHyQ::P64;
           P64[Hp - 88] = _scHyS::P64;
           P64[Hp - 80] = _scHyU::P64;
           P64[Hp - 72] = _scHyW::P64;
           P64[Hp - 64] = _scHyY::P64;
           P64[Hp - 56] = _scHz0::P64;
           P64[Hp - 48] = _scHz2::P64;
           P64[Hp - 40] = _scHz4::P64;
           P64[Hp - 32] = _scHz6::P64;
           P64[Hp - 24] = _scHz8::P64;
           P64[Hp - 16] = _scHza::P64;
           P64[Hp - 8] = _scHzc::P64;
           P64[Hp] = _scHze::P64;
           I64[Sp - 8] = block_ccKSC_info;
           R3 = Hp - 119;
           R2 = lvl72_rcHqO_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKSC() //  [R1]
         { info_tbl: [(ccKSC,
                       label: block_ccKSC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKSC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKSM; else goto ccKSL;
       ccKSM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKSL: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzl_entry() //  [R1, R2]
         { info_tbl: [(ccKSN,
                       label: sat_scHzl_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKSN: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccKSR; else goto ccKSQ;
       ccKSR: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKSQ: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           _scHz8::P64 = P64[R1 + 95];
           _scHza::P64 = P64[R1 + 103];
           _scHzc::P64 = P64[R1 + 111];
           I64[Hp - 112] = sat_scHzk_info;
           P64[Hp - 104] = _scHyK::P64;
           P64[Hp - 96] = _scHyO::P64;
           P64[Hp - 88] = _scHyQ::P64;
           P64[Hp - 80] = _scHyS::P64;
           P64[Hp - 72] = _scHyU::P64;
           P64[Hp - 64] = _scHyW::P64;
           P64[Hp - 56] = _scHyY::P64;
           P64[Hp - 48] = _scHz0::P64;
           P64[Hp - 40] = _scHz2::P64;
           P64[Hp - 32] = _scHz4::P64;
           P64[Hp - 24] = _scHz6::P64;
           P64[Hp - 16] = _scHz8::P64;
           P64[Hp - 8] = _scHza::P64;
           P64[Hp] = _scHzc::P64;
           R5 = Hp - 111;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl70_rcHqM_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzo_entry() //  [R1, R2]
         { info_tbl: [(ccKSV,
                       label: sat_scHzo_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKSV: // global
           _scHzc::P64 = R2;
           _scHzo::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKSW; else goto ccKSX;
       ccKSX: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccKSZ; else goto ccKSY;
       ccKSZ: // global
           HpAlloc = 120;
           goto ccKSW;
       ccKSW: // global
           R2 = _scHzc::P64;
           R1 = _scHzo::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKSY: // global
           _scHyK::P64 = P64[_scHzo::P64 + 7];
           _scHyO::P64 = P64[_scHzo::P64 + 15];
           _scHyQ::P64 = P64[_scHzo::P64 + 23];
           _scHyS::P64 = P64[_scHzo::P64 + 31];
           _scHyU::P64 = P64[_scHzo::P64 + 39];
           _scHyW::P64 = P64[_scHzo::P64 + 47];
           _scHyY::P64 = P64[_scHzo::P64 + 55];
           _scHz0::P64 = P64[_scHzo::P64 + 63];
           _scHz2::P64 = P64[_scHzo::P64 + 71];
           _scHz4::P64 = P64[_scHzo::P64 + 79];
           _scHz6::P64 = P64[_scHzo::P64 + 87];
           _scHz8::P64 = P64[_scHzo::P64 + 95];
           _scHza::P64 = P64[_scHzo::P64 + 103];
           I64[Hp - 112] = sat_scHzl_info;
           P64[Hp - 104] = _scHyK::P64;
           P64[Hp - 96] = _scHyO::P64;
           P64[Hp - 88] = _scHyQ::P64;
           P64[Hp - 80] = _scHyS::P64;
           P64[Hp - 72] = _scHyU::P64;
           P64[Hp - 64] = _scHyW::P64;
           P64[Hp - 56] = _scHyY::P64;
           P64[Hp - 48] = _scHz0::P64;
           P64[Hp - 40] = _scHz2::P64;
           P64[Hp - 32] = _scHz4::P64;
           P64[Hp - 24] = _scHz6::P64;
           P64[Hp - 16] = _scHz8::P64;
           P64[Hp - 8] = _scHza::P64;
           P64[Hp] = _scHzc::P64;
           I64[Sp - 8] = block_ccKSS_info;
           R3 = Hp - 111;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKSS() //  [R1]
         { info_tbl: [(ccKSS,
                       label: block_ccKSS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKSS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKT2; else goto ccKT1;
       ccKT2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKT1: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzp_entry() //  [R1, R2]
         { info_tbl: [(ccKT3,
                       label: sat_scHzp_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKT3: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccKT7; else goto ccKT6;
       ccKT7: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKT6: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           _scHz8::P64 = P64[R1 + 95];
           _scHza::P64 = P64[R1 + 103];
           I64[Hp - 104] = sat_scHzo_info;
           P64[Hp - 96] = _scHyK::P64;
           P64[Hp - 88] = _scHyO::P64;
           P64[Hp - 80] = _scHyQ::P64;
           P64[Hp - 72] = _scHyS::P64;
           P64[Hp - 64] = _scHyU::P64;
           P64[Hp - 56] = _scHyW::P64;
           P64[Hp - 48] = _scHyY::P64;
           P64[Hp - 40] = _scHz0::P64;
           P64[Hp - 32] = _scHz2::P64;
           P64[Hp - 24] = _scHz4::P64;
           P64[Hp - 16] = _scHz6::P64;
           P64[Hp - 8] = _scHz8::P64;
           P64[Hp] = _scHza::P64;
           R5 = Hp - 103;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl68_rcHqK_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzs_entry() //  [R1, R2]
         { info_tbl: [(ccKTb,
                       label: sat_scHzs_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKTb: // global
           _scHza::P64 = R2;
           _scHzs::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKTc; else goto ccKTd;
       ccKTd: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccKTf; else goto ccKTe;
       ccKTf: // global
           HpAlloc = 112;
           goto ccKTc;
       ccKTc: // global
           R2 = _scHza::P64;
           R1 = _scHzs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKTe: // global
           _scHyK::P64 = P64[_scHzs::P64 + 7];
           _scHyO::P64 = P64[_scHzs::P64 + 15];
           _scHyQ::P64 = P64[_scHzs::P64 + 23];
           _scHyS::P64 = P64[_scHzs::P64 + 31];
           _scHyU::P64 = P64[_scHzs::P64 + 39];
           _scHyW::P64 = P64[_scHzs::P64 + 47];
           _scHyY::P64 = P64[_scHzs::P64 + 55];
           _scHz0::P64 = P64[_scHzs::P64 + 63];
           _scHz2::P64 = P64[_scHzs::P64 + 71];
           _scHz4::P64 = P64[_scHzs::P64 + 79];
           _scHz6::P64 = P64[_scHzs::P64 + 87];
           _scHz8::P64 = P64[_scHzs::P64 + 95];
           I64[Hp - 104] = sat_scHzp_info;
           P64[Hp - 96] = _scHyK::P64;
           P64[Hp - 88] = _scHyO::P64;
           P64[Hp - 80] = _scHyQ::P64;
           P64[Hp - 72] = _scHyS::P64;
           P64[Hp - 64] = _scHyU::P64;
           P64[Hp - 56] = _scHyW::P64;
           P64[Hp - 48] = _scHyY::P64;
           P64[Hp - 40] = _scHz0::P64;
           P64[Hp - 32] = _scHz2::P64;
           P64[Hp - 24] = _scHz4::P64;
           P64[Hp - 16] = _scHz6::P64;
           P64[Hp - 8] = _scHz8::P64;
           P64[Hp] = _scHza::P64;
           I64[Sp - 8] = block_ccKT8_info;
           R3 = Hp - 103;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKT8() //  [R1]
         { info_tbl: [(ccKT8,
                       label: block_ccKT8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKT8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKTi; else goto ccKTh;
       ccKTi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKTh: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzt_entry() //  [R1, R2]
         { info_tbl: [(ccKTj,
                       label: sat_scHzt_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKTj: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccKTn; else goto ccKTm;
       ccKTn: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKTm: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           _scHz8::P64 = P64[R1 + 95];
           I64[Hp - 96] = sat_scHzs_info;
           P64[Hp - 88] = _scHyK::P64;
           P64[Hp - 80] = _scHyO::P64;
           P64[Hp - 72] = _scHyQ::P64;
           P64[Hp - 64] = _scHyS::P64;
           P64[Hp - 56] = _scHyU::P64;
           P64[Hp - 48] = _scHyW::P64;
           P64[Hp - 40] = _scHyY::P64;
           P64[Hp - 32] = _scHz0::P64;
           P64[Hp - 24] = _scHz2::P64;
           P64[Hp - 16] = _scHz4::P64;
           P64[Hp - 8] = _scHz6::P64;
           P64[Hp] = _scHz8::P64;
           R5 = Hp - 95;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl64_rcHqG_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzw_entry() //  [R1, R2]
         { info_tbl: [(ccKTr,
                       label: sat_scHzw_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKTr: // global
           _scHz8::P64 = R2;
           _scHzw::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKTs; else goto ccKTt;
       ccKTt: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccKTv; else goto ccKTu;
       ccKTv: // global
           HpAlloc = 104;
           goto ccKTs;
       ccKTs: // global
           R2 = _scHz8::P64;
           R1 = _scHzw::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKTu: // global
           _scHyK::P64 = P64[_scHzw::P64 + 7];
           _scHyO::P64 = P64[_scHzw::P64 + 15];
           _scHyQ::P64 = P64[_scHzw::P64 + 23];
           _scHyS::P64 = P64[_scHzw::P64 + 31];
           _scHyU::P64 = P64[_scHzw::P64 + 39];
           _scHyW::P64 = P64[_scHzw::P64 + 47];
           _scHyY::P64 = P64[_scHzw::P64 + 55];
           _scHz0::P64 = P64[_scHzw::P64 + 63];
           _scHz2::P64 = P64[_scHzw::P64 + 71];
           _scHz4::P64 = P64[_scHzw::P64 + 79];
           _scHz6::P64 = P64[_scHzw::P64 + 87];
           I64[Hp - 96] = sat_scHzt_info;
           P64[Hp - 88] = _scHyK::P64;
           P64[Hp - 80] = _scHyO::P64;
           P64[Hp - 72] = _scHyQ::P64;
           P64[Hp - 64] = _scHyS::P64;
           P64[Hp - 56] = _scHyU::P64;
           P64[Hp - 48] = _scHyW::P64;
           P64[Hp - 40] = _scHyY::P64;
           P64[Hp - 32] = _scHz0::P64;
           P64[Hp - 24] = _scHz2::P64;
           P64[Hp - 16] = _scHz4::P64;
           P64[Hp - 8] = _scHz6::P64;
           P64[Hp] = _scHz8::P64;
           I64[Sp - 8] = block_ccKTo_info;
           R3 = Hp - 95;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKTo() //  [R1]
         { info_tbl: [(ccKTo,
                       label: block_ccKTo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKTo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKTy; else goto ccKTx;
       ccKTy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKTx: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzx_entry() //  [R1, R2]
         { info_tbl: [(ccKTz,
                       label: sat_scHzx_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKTz: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccKTD; else goto ccKTC;
       ccKTD: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKTC: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           _scHz6::P64 = P64[R1 + 87];
           I64[Hp - 88] = sat_scHzw_info;
           P64[Hp - 80] = _scHyK::P64;
           P64[Hp - 72] = _scHyO::P64;
           P64[Hp - 64] = _scHyQ::P64;
           P64[Hp - 56] = _scHyS::P64;
           P64[Hp - 48] = _scHyU::P64;
           P64[Hp - 40] = _scHyW::P64;
           P64[Hp - 32] = _scHyY::P64;
           P64[Hp - 24] = _scHz0::P64;
           P64[Hp - 16] = _scHz2::P64;
           P64[Hp - 8] = _scHz4::P64;
           P64[Hp] = _scHz6::P64;
           R5 = Hp - 87;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl62_rcHqE_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzA_entry() //  [R1, R2]
         { info_tbl: [(ccKTH,
                       label: sat_scHzA_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKTH: // global
           _scHz6::P64 = R2;
           _scHzA::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKTI; else goto ccKTJ;
       ccKTJ: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccKTL; else goto ccKTK;
       ccKTL: // global
           HpAlloc = 96;
           goto ccKTI;
       ccKTI: // global
           R2 = _scHz6::P64;
           R1 = _scHzA::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKTK: // global
           _scHyK::P64 = P64[_scHzA::P64 + 7];
           _scHyO::P64 = P64[_scHzA::P64 + 15];
           _scHyQ::P64 = P64[_scHzA::P64 + 23];
           _scHyS::P64 = P64[_scHzA::P64 + 31];
           _scHyU::P64 = P64[_scHzA::P64 + 39];
           _scHyW::P64 = P64[_scHzA::P64 + 47];
           _scHyY::P64 = P64[_scHzA::P64 + 55];
           _scHz0::P64 = P64[_scHzA::P64 + 63];
           _scHz2::P64 = P64[_scHzA::P64 + 71];
           _scHz4::P64 = P64[_scHzA::P64 + 79];
           I64[Hp - 88] = sat_scHzx_info;
           P64[Hp - 80] = _scHyK::P64;
           P64[Hp - 72] = _scHyO::P64;
           P64[Hp - 64] = _scHyQ::P64;
           P64[Hp - 56] = _scHyS::P64;
           P64[Hp - 48] = _scHyU::P64;
           P64[Hp - 40] = _scHyW::P64;
           P64[Hp - 32] = _scHyY::P64;
           P64[Hp - 24] = _scHz0::P64;
           P64[Hp - 16] = _scHz2::P64;
           P64[Hp - 8] = _scHz4::P64;
           P64[Hp] = _scHz6::P64;
           I64[Sp - 8] = block_ccKTE_info;
           R3 = Hp - 87;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKTE() //  [R1]
         { info_tbl: [(ccKTE,
                       label: block_ccKTE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKTE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKTO; else goto ccKTN;
       ccKTO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKTN: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzB_entry() //  [R1, R2]
         { info_tbl: [(ccKTP,
                       label: sat_scHzB_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKTP: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccKTT; else goto ccKTS;
       ccKTT: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKTS: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           _scHz4::P64 = P64[R1 + 79];
           I64[Hp - 80] = sat_scHzA_info;
           P64[Hp - 72] = _scHyK::P64;
           P64[Hp - 64] = _scHyO::P64;
           P64[Hp - 56] = _scHyQ::P64;
           P64[Hp - 48] = _scHyS::P64;
           P64[Hp - 40] = _scHyU::P64;
           P64[Hp - 32] = _scHyW::P64;
           P64[Hp - 24] = _scHyY::P64;
           P64[Hp - 16] = _scHz0::P64;
           P64[Hp - 8] = _scHz2::P64;
           P64[Hp] = _scHz4::P64;
           R5 = Hp - 79;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl60_rcHqC_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzE_entry() //  [R1, R2]
         { info_tbl: [(ccKTX,
                       label: sat_scHzE_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKTX: // global
           _scHz4::P64 = R2;
           _scHzE::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKTY; else goto ccKTZ;
       ccKTZ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccKU1; else goto ccKU0;
       ccKU1: // global
           HpAlloc = 88;
           goto ccKTY;
       ccKTY: // global
           R2 = _scHz4::P64;
           R1 = _scHzE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKU0: // global
           _scHyK::P64 = P64[_scHzE::P64 + 7];
           _scHyO::P64 = P64[_scHzE::P64 + 15];
           _scHyQ::P64 = P64[_scHzE::P64 + 23];
           _scHyS::P64 = P64[_scHzE::P64 + 31];
           _scHyU::P64 = P64[_scHzE::P64 + 39];
           _scHyW::P64 = P64[_scHzE::P64 + 47];
           _scHyY::P64 = P64[_scHzE::P64 + 55];
           _scHz0::P64 = P64[_scHzE::P64 + 63];
           _scHz2::P64 = P64[_scHzE::P64 + 71];
           I64[Hp - 80] = sat_scHzB_info;
           P64[Hp - 72] = _scHyK::P64;
           P64[Hp - 64] = _scHyO::P64;
           P64[Hp - 56] = _scHyQ::P64;
           P64[Hp - 48] = _scHyS::P64;
           P64[Hp - 40] = _scHyU::P64;
           P64[Hp - 32] = _scHyW::P64;
           P64[Hp - 24] = _scHyY::P64;
           P64[Hp - 16] = _scHz0::P64;
           P64[Hp - 8] = _scHz2::P64;
           P64[Hp] = _scHz4::P64;
           I64[Sp - 8] = block_ccKTU_info;
           R3 = Hp - 79;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKTU() //  [R1]
         { info_tbl: [(ccKTU,
                       label: block_ccKTU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKTU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKU4; else goto ccKU3;
       ccKU4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKU3: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzF_entry() //  [R1, R2]
         { info_tbl: [(ccKU5,
                       label: sat_scHzF_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKU5: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccKU9; else goto ccKU8;
       ccKU9: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKU8: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           _scHz2::P64 = P64[R1 + 71];
           I64[Hp - 72] = sat_scHzE_info;
           P64[Hp - 64] = _scHyK::P64;
           P64[Hp - 56] = _scHyO::P64;
           P64[Hp - 48] = _scHyQ::P64;
           P64[Hp - 40] = _scHyS::P64;
           P64[Hp - 32] = _scHyU::P64;
           P64[Hp - 24] = _scHyW::P64;
           P64[Hp - 16] = _scHyY::P64;
           P64[Hp - 8] = _scHz0::P64;
           P64[Hp] = _scHz2::P64;
           R5 = Hp - 71;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl58_rcHqA_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzI_entry() //  [R1, R2]
         { info_tbl: [(ccKUd,
                       label: sat_scHzI_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKUd: // global
           _scHz2::P64 = R2;
           _scHzI::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKUe; else goto ccKUf;
       ccKUf: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccKUh; else goto ccKUg;
       ccKUh: // global
           HpAlloc = 80;
           goto ccKUe;
       ccKUe: // global
           R2 = _scHz2::P64;
           R1 = _scHzI::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKUg: // global
           _scHyK::P64 = P64[_scHzI::P64 + 7];
           _scHyO::P64 = P64[_scHzI::P64 + 15];
           _scHyQ::P64 = P64[_scHzI::P64 + 23];
           _scHyS::P64 = P64[_scHzI::P64 + 31];
           _scHyU::P64 = P64[_scHzI::P64 + 39];
           _scHyW::P64 = P64[_scHzI::P64 + 47];
           _scHyY::P64 = P64[_scHzI::P64 + 55];
           _scHz0::P64 = P64[_scHzI::P64 + 63];
           I64[Hp - 72] = sat_scHzF_info;
           P64[Hp - 64] = _scHyK::P64;
           P64[Hp - 56] = _scHyO::P64;
           P64[Hp - 48] = _scHyQ::P64;
           P64[Hp - 40] = _scHyS::P64;
           P64[Hp - 32] = _scHyU::P64;
           P64[Hp - 24] = _scHyW::P64;
           P64[Hp - 16] = _scHyY::P64;
           P64[Hp - 8] = _scHz0::P64;
           P64[Hp] = _scHz2::P64;
           I64[Sp - 8] = block_ccKUa_info;
           R3 = Hp - 71;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKUa() //  [R1]
         { info_tbl: [(ccKUa,
                       label: block_ccKUa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKUa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKUk; else goto ccKUj;
       ccKUk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKUj: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzJ_entry() //  [R1, R2]
         { info_tbl: [(ccKUl,
                       label: sat_scHzJ_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKUl: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccKUp; else goto ccKUo;
       ccKUp: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKUo: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           _scHz0::P64 = P64[R1 + 63];
           I64[Hp - 64] = sat_scHzI_info;
           P64[Hp - 56] = _scHyK::P64;
           P64[Hp - 48] = _scHyO::P64;
           P64[Hp - 40] = _scHyQ::P64;
           P64[Hp - 32] = _scHyS::P64;
           P64[Hp - 24] = _scHyU::P64;
           P64[Hp - 16] = _scHyW::P64;
           P64[Hp - 8] = _scHyY::P64;
           P64[Hp] = _scHz0::P64;
           R5 = Hp - 63;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl56_rcHqy_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzM_entry() //  [R1, R2]
         { info_tbl: [(ccKUt,
                       label: sat_scHzM_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKUt: // global
           _scHz0::P64 = R2;
           _scHzM::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKUu; else goto ccKUv;
       ccKUv: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccKUx; else goto ccKUw;
       ccKUx: // global
           HpAlloc = 72;
           goto ccKUu;
       ccKUu: // global
           R2 = _scHz0::P64;
           R1 = _scHzM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKUw: // global
           _scHyK::P64 = P64[_scHzM::P64 + 7];
           _scHyO::P64 = P64[_scHzM::P64 + 15];
           _scHyQ::P64 = P64[_scHzM::P64 + 23];
           _scHyS::P64 = P64[_scHzM::P64 + 31];
           _scHyU::P64 = P64[_scHzM::P64 + 39];
           _scHyW::P64 = P64[_scHzM::P64 + 47];
           _scHyY::P64 = P64[_scHzM::P64 + 55];
           I64[Hp - 64] = sat_scHzJ_info;
           P64[Hp - 56] = _scHyK::P64;
           P64[Hp - 48] = _scHyO::P64;
           P64[Hp - 40] = _scHyQ::P64;
           P64[Hp - 32] = _scHyS::P64;
           P64[Hp - 24] = _scHyU::P64;
           P64[Hp - 16] = _scHyW::P64;
           P64[Hp - 8] = _scHyY::P64;
           P64[Hp] = _scHz0::P64;
           I64[Sp - 8] = block_ccKUq_info;
           R3 = Hp - 63;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKUq() //  [R1]
         { info_tbl: [(ccKUq,
                       label: block_ccKUq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKUq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKUA; else goto ccKUz;
       ccKUA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKUz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzN_entry() //  [R1, R2]
         { info_tbl: [(ccKUB,
                       label: sat_scHzN_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKUB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccKUF; else goto ccKUE;
       ccKUF: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKUE: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           _scHyY::P64 = P64[R1 + 55];
           I64[Hp - 56] = sat_scHzM_info;
           P64[Hp - 48] = _scHyK::P64;
           P64[Hp - 40] = _scHyO::P64;
           P64[Hp - 32] = _scHyQ::P64;
           P64[Hp - 24] = _scHyS::P64;
           P64[Hp - 16] = _scHyU::P64;
           P64[Hp - 8] = _scHyW::P64;
           P64[Hp] = _scHyY::P64;
           R5 = Hp - 55;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl54_rcHqw_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzQ_entry() //  [R1, R2]
         { info_tbl: [(ccKUJ,
                       label: sat_scHzQ_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKUJ: // global
           _scHyY::P64 = R2;
           _scHzQ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKUK; else goto ccKUL;
       ccKUL: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccKUN; else goto ccKUM;
       ccKUN: // global
           HpAlloc = 64;
           goto ccKUK;
       ccKUK: // global
           R2 = _scHyY::P64;
           R1 = _scHzQ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKUM: // global
           _scHyK::P64 = P64[_scHzQ::P64 + 7];
           _scHyO::P64 = P64[_scHzQ::P64 + 15];
           _scHyQ::P64 = P64[_scHzQ::P64 + 23];
           _scHyS::P64 = P64[_scHzQ::P64 + 31];
           _scHyU::P64 = P64[_scHzQ::P64 + 39];
           _scHyW::P64 = P64[_scHzQ::P64 + 47];
           I64[Hp - 56] = sat_scHzN_info;
           P64[Hp - 48] = _scHyK::P64;
           P64[Hp - 40] = _scHyO::P64;
           P64[Hp - 32] = _scHyQ::P64;
           P64[Hp - 24] = _scHyS::P64;
           P64[Hp - 16] = _scHyU::P64;
           P64[Hp - 8] = _scHyW::P64;
           P64[Hp] = _scHyY::P64;
           I64[Sp - 8] = block_ccKUG_info;
           R3 = Hp - 55;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKUG() //  [R1]
         { info_tbl: [(ccKUG,
                       label: block_ccKUG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKUG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKUQ; else goto ccKUP;
       ccKUQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKUP: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzR_entry() //  [R1, R2]
         { info_tbl: [(ccKUR,
                       label: sat_scHzR_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKUR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccKUV; else goto ccKUU;
       ccKUV: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKUU: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           _scHyW::P64 = P64[R1 + 47];
           I64[Hp - 48] = sat_scHzQ_info;
           P64[Hp - 40] = _scHyK::P64;
           P64[Hp - 32] = _scHyO::P64;
           P64[Hp - 24] = _scHyQ::P64;
           P64[Hp - 16] = _scHyS::P64;
           P64[Hp - 8] = _scHyU::P64;
           P64[Hp] = _scHyW::P64;
           R5 = Hp - 47;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl52_rcHqu_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzU_entry() //  [R1, R2]
         { info_tbl: [(ccKUZ,
                       label: sat_scHzU_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKUZ: // global
           _scHyW::P64 = R2;
           _scHzU::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKV0; else goto ccKV1;
       ccKV1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccKV3; else goto ccKV2;
       ccKV3: // global
           HpAlloc = 56;
           goto ccKV0;
       ccKV0: // global
           R2 = _scHyW::P64;
           R1 = _scHzU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKV2: // global
           _scHyK::P64 = P64[_scHzU::P64 + 7];
           _scHyO::P64 = P64[_scHzU::P64 + 15];
           _scHyQ::P64 = P64[_scHzU::P64 + 23];
           _scHyS::P64 = P64[_scHzU::P64 + 31];
           _scHyU::P64 = P64[_scHzU::P64 + 39];
           I64[Hp - 48] = sat_scHzR_info;
           P64[Hp - 40] = _scHyK::P64;
           P64[Hp - 32] = _scHyO::P64;
           P64[Hp - 24] = _scHyQ::P64;
           P64[Hp - 16] = _scHyS::P64;
           P64[Hp - 8] = _scHyU::P64;
           P64[Hp] = _scHyW::P64;
           I64[Sp - 8] = block_ccKUW_info;
           R3 = Hp - 47;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKUW() //  [R1]
         { info_tbl: [(ccKUW,
                       label: block_ccKUW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKUW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKV6; else goto ccKV5;
       ccKV6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKV5: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzV_entry() //  [R1, R2]
         { info_tbl: [(ccKV7,
                       label: sat_scHzV_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKV7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccKVb; else goto ccKVa;
       ccKVb: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKVa: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           _scHyU::P64 = P64[R1 + 39];
           I64[Hp - 40] = sat_scHzU_info;
           P64[Hp - 32] = _scHyK::P64;
           P64[Hp - 24] = _scHyO::P64;
           P64[Hp - 16] = _scHyQ::P64;
           P64[Hp - 8] = _scHyS::P64;
           P64[Hp] = _scHyU::P64;
           R5 = Hp - 39;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl50_rcHqs_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzY_entry() //  [R1, R2]
         { info_tbl: [(ccKVf,
                       label: sat_scHzY_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKVf: // global
           _scHyU::P64 = R2;
           _scHzY::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKVg; else goto ccKVh;
       ccKVh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccKVj; else goto ccKVi;
       ccKVj: // global
           HpAlloc = 48;
           goto ccKVg;
       ccKVg: // global
           R2 = _scHyU::P64;
           R1 = _scHzY::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKVi: // global
           _scHyK::P64 = P64[_scHzY::P64 + 7];
           _scHyO::P64 = P64[_scHzY::P64 + 15];
           _scHyQ::P64 = P64[_scHzY::P64 + 23];
           _scHyS::P64 = P64[_scHzY::P64 + 31];
           I64[Hp - 40] = sat_scHzV_info;
           P64[Hp - 32] = _scHyK::P64;
           P64[Hp - 24] = _scHyO::P64;
           P64[Hp - 16] = _scHyQ::P64;
           P64[Hp - 8] = _scHyS::P64;
           P64[Hp] = _scHyU::P64;
           I64[Sp - 8] = block_ccKVc_info;
           R3 = Hp - 39;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKVc() //  [R1]
         { info_tbl: [(ccKVc,
                       label: block_ccKVc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKVc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKVm; else goto ccKVl;
       ccKVm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKVl: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHzZ_entry() //  [R1, R2]
         { info_tbl: [(ccKVn,
                       label: sat_scHzZ_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKVn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccKVr; else goto ccKVq;
       ccKVr: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKVq: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           _scHyS::P64 = P64[R1 + 31];
           I64[Hp - 32] = sat_scHzY_info;
           P64[Hp - 24] = _scHyK::P64;
           P64[Hp - 16] = _scHyO::P64;
           P64[Hp - 8] = _scHyQ::P64;
           P64[Hp] = _scHyS::P64;
           R5 = Hp - 31;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl48_rcHqq_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHA2_entry() //  [R1, R2]
         { info_tbl: [(ccKVv,
                       label: sat_scHA2_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKVv: // global
           _scHyS::P64 = R2;
           _scHA2::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKVw; else goto ccKVx;
       ccKVx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccKVz; else goto ccKVy;
       ccKVz: // global
           HpAlloc = 40;
           goto ccKVw;
       ccKVw: // global
           R2 = _scHyS::P64;
           R1 = _scHA2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKVy: // global
           _scHyK::P64 = P64[_scHA2::P64 + 7];
           _scHyO::P64 = P64[_scHA2::P64 + 15];
           _scHyQ::P64 = P64[_scHA2::P64 + 23];
           I64[Hp - 32] = sat_scHzZ_info;
           P64[Hp - 24] = _scHyK::P64;
           P64[Hp - 16] = _scHyO::P64;
           P64[Hp - 8] = _scHyQ::P64;
           P64[Hp] = _scHyS::P64;
           I64[Sp - 8] = block_ccKVs_info;
           R3 = Hp - 31;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKVs() //  [R1]
         { info_tbl: [(ccKVs,
                       label: block_ccKVs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKVs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKVC; else goto ccKVB;
       ccKVC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKVB: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHA3_entry() //  [R1, R2]
         { info_tbl: [(ccKVD,
                       label: sat_scHA3_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKVD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccKVH; else goto ccKVG;
       ccKVH: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKVG: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           _scHyQ::P64 = P64[R1 + 23];
           I64[Hp - 24] = sat_scHA2_info;
           P64[Hp - 16] = _scHyK::P64;
           P64[Hp - 8] = _scHyO::P64;
           P64[Hp] = _scHyQ::P64;
           R5 = Hp - 23;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl44_rcHqm_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHA6_entry() //  [R1, R2]
         { info_tbl: [(ccKVL,
                       label: sat_scHA6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKVL: // global
           _scHyQ::P64 = R2;
           _scHA6::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKVM; else goto ccKVN;
       ccKVN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccKVP; else goto ccKVO;
       ccKVP: // global
           HpAlloc = 32;
           goto ccKVM;
       ccKVM: // global
           R2 = _scHyQ::P64;
           R1 = _scHA6::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKVO: // global
           _scHyK::P64 = P64[_scHA6::P64 + 7];
           _scHyO::P64 = P64[_scHA6::P64 + 15];
           I64[Hp - 24] = sat_scHA3_info;
           P64[Hp - 16] = _scHyK::P64;
           P64[Hp - 8] = _scHyO::P64;
           P64[Hp] = _scHyQ::P64;
           I64[Sp - 8] = block_ccKVI_info;
           R3 = Hp - 23;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKVI() //  [R1]
         { info_tbl: [(ccKVI,
                       label: block_ccKVI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKVI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKVS; else goto ccKVR;
       ccKVS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKVR: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHA7_entry() //  [R1, R2]
         { info_tbl: [(ccKVT,
                       label: sat_scHA7_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKVT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKVX; else goto ccKVW;
       ccKVX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKVW: // global
           _scHyK::P64 = P64[R1 + 7];
           _scHyO::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_scHA6_info;
           P64[Hp - 8] = _scHyK::P64;
           P64[Hp] = _scHyO::P64;
           R5 = Hp - 15;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = lvl42_rcHqk_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHAa_entry() //  [R1, R2]
         { info_tbl: [(ccKW1,
                       label: sat_scHAa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKW1: // global
           _scHyO::P64 = R2;
           _scHAa::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKW2; else goto ccKW3;
       ccKW3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccKW5; else goto ccKW4;
       ccKW5: // global
           HpAlloc = 24;
           goto ccKW2;
       ccKW2: // global
           R2 = _scHyO::P64;
           R1 = _scHAa::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKW4: // global
           _scHyK::P64 = P64[_scHAa::P64 + 7];
           I64[Hp - 16] = sat_scHA7_info;
           P64[Hp - 8] = _scHyK::P64;
           P64[Hp] = _scHyO::P64;
           I64[Sp - 8] = block_ccKVY_info;
           R3 = Hp - 15;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKVY() //  [R1]
         { info_tbl: [(ccKVY,
                       label: block_ccKVY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKVY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKW8; else goto ccKW7;
       ccKW8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKW7: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHAb_entry() //  [R1, R2]
         { info_tbl: [(ccKW9,
                       label: sat_scHAb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKW9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKWd; else goto ccKWc;
       ccKWd: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKWc: // global
           _scHyK::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_scHAa_info;
           P64[Hp] = _scHyK::P64;
           R5 = Hp - 7;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = ds1_rcHqc_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHAe_entry() //  [R1, R2]
         { info_tbl: [(ccKWh,
                       label: sat_scHAe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKWh: // global
           _scHyM::P64 = R2;
           _scHAe::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKWi; else goto ccKWj;
       ccKWj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKWl; else goto ccKWk;
       ccKWl: // global
           HpAlloc = 16;
           goto ccKWi;
       ccKWi: // global
           R2 = _scHyM::P64;
           R1 = _scHAe::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccKWk: // global
           _scHyK::P64 = P64[_scHAe::P64 + 7];
           I64[Hp - 8] = sat_scHAb_info;
           P64[Hp] = _scHyK::P64;
           I64[Sp - 8] = block_ccKWe_info;
           R3 = Hp - 7;
           R2 = lexeme4_rcHqa_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKWe() //  [R1]
         { info_tbl: [(ccKWe,
                       label: block_ccKWe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKWe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKWo; else goto ccKWn;
       ccKWo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKWn: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stats.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(ccKWs,
                       label: GHC.Stats.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKWs: // global
           _scHyK::P64 = R3;
           _scHyJ::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccKWt; else goto ccKWu;
       ccKWu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKWw; else goto ccKWv;
       ccKWw: // global
           HpAlloc = 16;
           goto ccKWt;
       ccKWt: // global
           R3 = _scHyK::P64;
           R2 = _scHyJ::I64;
           R1 = GHC.Stats.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccKWv: // global
           if (%MO_S_Gt_W64(_scHyJ::I64, 11)) goto ccKWq; else goto ccKWr;
       ccKWq: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccKWr: // global
           I64[Hp - 8] = sat_scHAe_info;
           P64[Hp] = _scHyK::P64;
           I64[Sp - 8] = block_ccKWx_info;
           R3 = Hp - 7;
           R2 = lexeme1_rcHq7_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccKWx() //  [R1]
         { info_tbl: [(ccKWx,
                       label: block_ccKWx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKWx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccKWC; else goto ccKWB;
       ccKWC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccKWB: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.653230272 UTC

[section ""data" . GHC.Stats.$fReadGCDetails2_closure" {
     GHC.Stats.$fReadGCDetails2_closure:
         const GHC.Stats.$fReadGCDetails2_info;
         const 0;
 },
 GHC.Stats.$fReadGCDetails2_entry() //  [R2, R3]
         { info_tbl: [(ccKZz,
                       label: GHC.Stats.$fReadGCDetails2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKZz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccKZA; else goto ccKZB;
       ccKZA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fReadGCDetails2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccKZB: // global
           I64[Sp - 16] = block_ccKZw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucKZF; else goto ccKZx;
       ucKZF: // global
           call _ccKZw(R1) args: 0, res: 0, upd: 0;
       ccKZx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccKZw() //  [R1]
         { info_tbl: [(ccKZw,
                       label: block_ccKZw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKZw: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Stats.$w$creadPrec_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.660199805 UTC

[section ""data" . GHC.Stats.$fReadGCDetails1_closure" {
     GHC.Stats.$fReadGCDetails1_closure:
         const GHC.Stats.$fReadGCDetails1_info;
         const 0;
 },
 GHC.Stats.$fReadGCDetails1_entry() //  [R2, R3]
         { info_tbl: [(ccKZT,
                       label: GHC.Stats.$fReadGCDetails1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccKZT: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fReadGCDetails2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.665053434 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_$creadsPrec_closure" {
     GHC.Stats.$fReadGCDetails_$creadsPrec_closure:
         const GHC.Stats.$fReadGCDetails_$creadsPrec_info;
         const 0;
 },
 sat_scHAm_entry() //  [R1]
         { info_tbl: [(ccL08,
                       label: sat_scHAm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL08: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL09; else goto ccL0a;
       ccL09: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL0a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Stats.$fReadGCDetails2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stats.$fReadGCDetails_$creadsPrec_entry() //  [R2]
         { info_tbl: [(ccL0b,
                       label: GHC.Stats.$fReadGCDetails_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL0b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccL0f; else goto ccL0e;
       ccL0f: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stats.$fReadGCDetails_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccL0e: // global
           I64[Hp - 16] = sat_scHAm_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.673051101 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_$creadListPrec_closure" {
     GHC.Stats.$fReadGCDetails_$creadListPrec_closure:
         const GHC.Stats.$fReadGCDetails_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadGCDetails_$creadListPrec_entry() //  [R1]
         { info_tbl: [(ccL0u,
                       label: GHC.Stats.$fReadGCDetails_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL0u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL0v; else goto ccL0w;
       ccL0v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL0w: // global
           (_ccL0r::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL0r::I64 == 0) goto ccL0t; else goto ccL0s;
       ccL0t: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL0s: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL0r::I64;
           R2 = GHC.Stats.$fReadGCDetails1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.678143083 UTC

[section ""data" . GHC.Stats.$fReadGCDetails3_closure" {
     GHC.Stats.$fReadGCDetails3_closure:
         const GHC.Stats.$fReadGCDetails3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadGCDetails3_entry() //  [R1]
         { info_tbl: [(ccL0K,
                       label: GHC.Stats.$fReadGCDetails3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL0K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL0L; else goto ccL0M;
       ccL0L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL0M: // global
           (_ccL0H::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL0H::I64 == 0) goto ccL0J; else goto ccL0I;
       ccL0J: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL0I: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL0H::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.Stats.$fReadGCDetails_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.683412412 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_$creadList_closure" {
     GHC.Stats.$fReadGCDetails_$creadList_closure:
         const GHC.Stats.$fReadGCDetails_$creadList_info;
         const 0;
 },
 GHC.Stats.$fReadGCDetails_$creadList_entry() //  [R2]
         { info_tbl: [(ccL0Y,
                       label: GHC.Stats.$fReadGCDetails_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL0Y: // global
           R3 = R2;
           R2 = GHC.Stats.$fReadGCDetails3_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.687234219 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_closure" {
     GHC.Stats.$fReadGCDetails_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Stats.$fReadGCDetails_$creadsPrec_closure+1;
         const GHC.Stats.$fReadGCDetails_$creadList_closure+1;
         const GHC.Stats.$fReadGCDetails1_closure+2;
         const GHC.Stats.$fReadGCDetails_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.689126267 UTC

[section ""cstring" . GHC.Stats.$tcRTSStats2_bytes" {
     GHC.Stats.$tcRTSStats2_bytes:
         I8[] [82,84,83,83,116,97,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.69134236 UTC

[section ""data" . lexeme5_rcHqP_closure" {
     lexeme5_rcHqP_closure:
         const lexeme5_rcHqP_info;
         const 0;
         const 0;
         const 0;
 },
 lexeme5_rcHqP_entry() //  [R1]
         { info_tbl: [(ccL1d,
                       label: lexeme5_rcHqP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL1d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL1e; else goto ccL1f;
       ccL1e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL1f: // global
           (_ccL1a::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL1a::I64 == 0) goto ccL1c; else goto ccL1b;
       ccL1c: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL1b: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL1a::I64;
           R2 = GHC.Stats.$tcRTSStats2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.695578687 UTC

[section ""data" . lexeme6_rcHqQ_closure" {
     lexeme6_rcHqQ_closure:
         const Text.Read.Lex.Ident_con_info;
         const lexeme5_rcHqP_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.697594416 UTC

[section ""cstring" . ds3_rcHqR_bytes" {
     ds3_rcHqR_bytes:
         I8[] [103,99,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.699776023 UTC

[section ""data" . ds4_rcHqS_closure" {
     ds4_rcHqS_closure:
         const ds4_rcHqS_info;
         const 0;
         const 0;
         const 0;
 },
 ds4_rcHqS_entry() //  [R1]
         { info_tbl: [(ccL1v,
                       label: ds4_rcHqS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL1v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL1w; else goto ccL1x;
       ccL1w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL1x: // global
           (_ccL1s::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL1s::I64 == 0) goto ccL1u; else goto ccL1t;
       ccL1u: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL1t: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL1s::I64;
           R2 = ds3_rcHqR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.704756535 UTC

[section ""cstring" . lvl73_rcHqT_bytes" {
     lvl73_rcHqT_bytes:
         I8[] [109,97,106,111,114,95,103,99,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.70683631 UTC

[section ""data" . lvl74_rcHqU_closure" {
     lvl74_rcHqU_closure:
         const lvl74_rcHqU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl74_rcHqU_entry() //  [R1]
         { info_tbl: [(ccL1M,
                       label: lvl74_rcHqU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL1M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL1N; else goto ccL1O;
       ccL1N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL1O: // global
           (_ccL1J::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL1J::I64 == 0) goto ccL1L; else goto ccL1K;
       ccL1L: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL1K: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL1J::I64;
           R2 = lvl73_rcHqT_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.711138405 UTC

[section ""cstring" . lvl75_rcHqV_bytes" {
     lvl75_rcHqV_bytes:
         I8[] [97,108,108,111,99,97,116,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.713120793 UTC

[section ""data" . lvl76_rcHqW_closure" {
     lvl76_rcHqW_closure:
         const lvl76_rcHqW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl76_rcHqW_entry() //  [R1]
         { info_tbl: [(ccL23,
                       label: lvl76_rcHqW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL23: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL24; else goto ccL25;
       ccL24: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL25: // global
           (_ccL20::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL20::I64 == 0) goto ccL22; else goto ccL21;
       ccL22: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL21: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL20::I64;
           R2 = lvl75_rcHqV_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.717225396 UTC

[section ""cstring" . lvl77_rcHqX_bytes" {
     lvl77_rcHqX_bytes:
         I8[] [109,97,120,95,108,105,118,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.719317778 UTC

[section ""data" . lvl78_rcHqY_closure" {
     lvl78_rcHqY_closure:
         const lvl78_rcHqY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl78_rcHqY_entry() //  [R1]
         { info_tbl: [(ccL2k,
                       label: lvl78_rcHqY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL2k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL2l; else goto ccL2m;
       ccL2l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL2m: // global
           (_ccL2h::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL2h::I64 == 0) goto ccL2j; else goto ccL2i;
       ccL2j: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL2i: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL2h::I64;
           R2 = lvl77_rcHqX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.723548698 UTC

[section ""cstring" . lvl79_rcHqZ_bytes" {
     lvl79_rcHqZ_bytes:
         I8[] [109,97,120,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.725800963 UTC

[section ""data" . lvl80_rcHr0_closure" {
     lvl80_rcHr0_closure:
         const lvl80_rcHr0_info;
         const 0;
         const 0;
         const 0;
 },
 lvl80_rcHr0_entry() //  [R1]
         { info_tbl: [(ccL2B,
                       label: lvl80_rcHr0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL2B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL2C; else goto ccL2D;
       ccL2C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL2D: // global
           (_ccL2y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL2y::I64 == 0) goto ccL2A; else goto ccL2z;
       ccL2A: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL2z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL2y::I64;
           R2 = lvl79_rcHqZ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.730770967 UTC

[section ""cstring" . lvl81_rcHr1_bytes" {
     lvl81_rcHr1_bytes:
         I8[] [109,97,120,95,99,111,109,112,97,99,116,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.732785614 UTC

[section ""data" . lvl82_rcHr2_closure" {
     lvl82_rcHr2_closure:
         const lvl82_rcHr2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl82_rcHr2_entry() //  [R1]
         { info_tbl: [(ccL2S,
                       label: lvl82_rcHr2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL2S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL2T; else goto ccL2U;
       ccL2T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL2U: // global
           (_ccL2P::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL2P::I64 == 0) goto ccL2R; else goto ccL2Q;
       ccL2R: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL2Q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL2P::I64;
           R2 = lvl81_rcHr1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.737404071 UTC

[section ""cstring" . lvl83_rcHr3_bytes" {
     lvl83_rcHr3_bytes:
         I8[] [109,97,120,95,115,108,111,112,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.739382651 UTC

[section ""data" . lvl84_rcHr4_closure" {
     lvl84_rcHr4_closure:
         const lvl84_rcHr4_info;
         const 0;
         const 0;
         const 0;
 },
 lvl84_rcHr4_entry() //  [R1]
         { info_tbl: [(ccL39,
                       label: lvl84_rcHr4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL39: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL3a; else goto ccL3b;
       ccL3a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL3b: // global
           (_ccL36::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL36::I64 == 0) goto ccL38; else goto ccL37;
       ccL38: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL37: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL36::I64;
           R2 = lvl83_rcHr3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.743534162 UTC

[section ""cstring" . lvl85_rcHr5_bytes" {
     lvl85_rcHr5_bytes:
         I8[] [109,97,120,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.7457348 UTC

[section ""data" . lvl86_rcHr6_closure" {
     lvl86_rcHr6_closure:
         const lvl86_rcHr6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl86_rcHr6_entry() //  [R1]
         { info_tbl: [(ccL3q,
                       label: lvl86_rcHr6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL3q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL3r; else goto ccL3s;
       ccL3r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL3s: // global
           (_ccL3n::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL3n::I64 == 0) goto ccL3p; else goto ccL3o;
       ccL3p: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL3o: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL3n::I64;
           R2 = lvl85_rcHr5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.74980288 UTC

[section ""cstring" . lvl87_rcHr7_bytes" {
     lvl87_rcHr7_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,108,105,118,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.751728282 UTC

[section ""data" . lvl88_rcHr8_closure" {
     lvl88_rcHr8_closure:
         const lvl88_rcHr8_info;
         const 0;
         const 0;
         const 0;
 },
 lvl88_rcHr8_entry() //  [R1]
         { info_tbl: [(ccL3H,
                       label: lvl88_rcHr8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL3H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL3I; else goto ccL3J;
       ccL3I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL3J: // global
           (_ccL3E::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL3E::I64 == 0) goto ccL3G; else goto ccL3F;
       ccL3G: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL3F: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL3E::I64;
           R2 = lvl87_rcHr7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.755905158 UTC

[section ""cstring" . lvl89_rcHr9_bytes" {
     lvl89_rcHr9_bytes:
         I8[] [99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.758095793 UTC

[section ""data" . lvl90_rcHra_closure" {
     lvl90_rcHra_closure:
         const lvl90_rcHra_info;
         const 0;
         const 0;
         const 0;
 },
 lvl90_rcHra_entry() //  [R1]
         { info_tbl: [(ccL3Y,
                       label: lvl90_rcHra_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL3Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL3Z; else goto ccL40;
       ccL3Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL40: // global
           (_ccL3V::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL3V::I64 == 0) goto ccL3X; else goto ccL3W;
       ccL3X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL3W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL3V::I64;
           R2 = lvl89_rcHr9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.763081595 UTC

[section ""cstring" . lvl91_rcHrb_bytes" {
     lvl91_rcHrb_bytes:
         I8[] [112,97,114,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.765058065 UTC

[section ""data" . lvl92_rcHrc_closure" {
     lvl92_rcHrc_closure:
         const lvl92_rcHrc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl92_rcHrc_entry() //  [R1]
         { info_tbl: [(ccL4f,
                       label: lvl92_rcHrc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL4f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL4g; else goto ccL4h;
       ccL4g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL4h: // global
           (_ccL4c::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL4c::I64 == 0) goto ccL4e; else goto ccL4d;
       ccL4e: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL4d: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL4c::I64;
           R2 = lvl91_rcHrb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.769666488 UTC

[section ""cstring" . lvl93_rcHrd_bytes" {
     lvl93_rcHrd_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.771841164 UTC

[section ""data" . lvl94_rcHre_closure" {
     lvl94_rcHre_closure:
         const lvl94_rcHre_info;
         const 0;
         const 0;
         const 0;
 },
 lvl94_rcHre_entry() //  [R1]
         { info_tbl: [(ccL4w,
                       label: lvl94_rcHre_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL4w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL4x; else goto ccL4y;
       ccL4x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL4y: // global
           (_ccL4t::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL4t::I64 == 0) goto ccL4v; else goto ccL4u;
       ccL4v: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL4u: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL4t::I64;
           R2 = lvl93_rcHrd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.776137582 UTC

[section ""cstring" . lvl95_rcHrf_bytes" {
     lvl95_rcHrf_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.778574119 UTC

[section ""data" . lvl96_rcHrg_closure" {
     lvl96_rcHrg_closure:
         const lvl96_rcHrg_info;
         const 0;
         const 0;
         const 0;
 },
 lvl96_rcHrg_entry() //  [R1]
         { info_tbl: [(ccL4N,
                       label: lvl96_rcHrg_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL4N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL4O; else goto ccL4P;
       ccL4O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL4P: // global
           (_ccL4K::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL4K::I64 == 0) goto ccL4M; else goto ccL4L;
       ccL4M: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL4L: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL4K::I64;
           R2 = lvl95_rcHrf_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.782771583 UTC

[section ""cstring" . lvl97_rcHrh_bytes" {
     lvl97_rcHrh_bytes:
         I8[] [109,117,116,97,116,111,114,95,99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.784926242 UTC

[section ""data" . lvl98_rcHri_closure" {
     lvl98_rcHri_closure:
         const lvl98_rcHri_info;
         const 0;
         const 0;
         const 0;
 },
 lvl98_rcHri_entry() //  [R1]
         { info_tbl: [(ccL54,
                       label: lvl98_rcHri_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL54: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL55; else goto ccL56;
       ccL55: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL56: // global
           (_ccL51::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL51::I64 == 0) goto ccL53; else goto ccL52;
       ccL53: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL52: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL51::I64;
           R2 = lvl97_rcHrh_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.789489816 UTC

[section ""cstring" . lvl99_rcHrj_bytes" {
     lvl99_rcHrj_bytes:
         I8[] [109,117,116,97,116,111,114,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.792249528 UTC

[section ""data" . lvl100_rcHrk_closure" {
     lvl100_rcHrk_closure:
         const lvl100_rcHrk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl100_rcHrk_entry() //  [R1]
         { info_tbl: [(ccL5l,
                       label: lvl100_rcHrk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL5l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL5m; else goto ccL5n;
       ccL5m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL5n: // global
           (_ccL5i::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL5i::I64 == 0) goto ccL5k; else goto ccL5j;
       ccL5k: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL5j: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL5i::I64;
           R2 = lvl99_rcHrj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.796892209 UTC

[section ""cstring" . lvl101_rcHrl_bytes" {
     lvl101_rcHrl_bytes:
         I8[] [103,99,95,99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.798928651 UTC

[section ""data" . lvl102_rcHrm_closure" {
     lvl102_rcHrm_closure:
         const lvl102_rcHrm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl102_rcHrm_entry() //  [R1]
         { info_tbl: [(ccL5C,
                       label: lvl102_rcHrm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL5C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL5D; else goto ccL5E;
       ccL5D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL5E: // global
           (_ccL5z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL5z::I64 == 0) goto ccL5B; else goto ccL5A;
       ccL5B: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL5A: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL5z::I64;
           R2 = lvl101_rcHrl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.803081788 UTC

[section ""cstring" . lvl103_rcHrn_bytes" {
     lvl103_rcHrn_bytes:
         I8[] [103,99,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.805191033 UTC

[section ""data" . lvl104_rcHro_closure" {
     lvl104_rcHro_closure:
         const lvl104_rcHro_info;
         const 0;
         const 0;
         const 0;
 },
 lvl104_rcHro_entry() //  [R1]
         { info_tbl: [(ccL5T,
                       label: lvl104_rcHro_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL5T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL5U; else goto ccL5V;
       ccL5U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL5V: // global
           (_ccL5Q::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL5Q::I64 == 0) goto ccL5S; else goto ccL5R;
       ccL5S: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL5R: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL5Q::I64;
           R2 = lvl103_rcHrn_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.809886768 UTC

[section ""cstring" . lvl105_rcHrp_bytes" {
     lvl105_rcHrp_bytes:
         I8[] [99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.812055665 UTC

[section ""data" . lvl106_rcHrq_closure" {
     lvl106_rcHrq_closure:
         const lvl106_rcHrq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl106_rcHrq_entry() //  [R1]
         { info_tbl: [(ccL6a,
                       label: lvl106_rcHrq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL6a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL6b; else goto ccL6c;
       ccL6b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL6c: // global
           (_ccL67::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL67::I64 == 0) goto ccL69; else goto ccL68;
       ccL69: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL68: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL67::I64;
           R2 = lvl105_rcHrp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.816361551 UTC

[section ""cstring" . lvl107_rcHrr_bytes" {
     lvl107_rcHrr_bytes:
         I8[] [101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.818836046 UTC

[section ""data" . lvl108_rcHrs_closure" {
     lvl108_rcHrs_closure:
         const lvl108_rcHrs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl108_rcHrs_entry() //  [R1]
         { info_tbl: [(ccL6r,
                       label: lvl108_rcHrs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL6r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL6s; else goto ccL6t;
       ccL6s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL6t: // global
           (_ccL6o::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL6o::I64 == 0) goto ccL6q; else goto ccL6p;
       ccL6q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL6p: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL6o::I64;
           R2 = lvl107_rcHrr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.823625755 UTC

[section ""cstring" . lvl109_rcHrt_bytes" {
     lvl109_rcHrt_bytes:
         I8[] [103,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.825866023 UTC

[section ""data" . lvl110_rcHru_closure" {
     lvl110_rcHru_closure:
         const lvl110_rcHru_info;
         const 0;
         const 0;
         const 0;
 },
 lvl110_rcHru_entry() //  [R1]
         { info_tbl: [(ccL6I,
                       label: lvl110_rcHru_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL6I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccL6J; else goto ccL6K;
       ccL6J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccL6K: // global
           (_ccL6F::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccL6F::I64 == 0) goto ccL6H; else goto ccL6G;
       ccL6H: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccL6G: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccL6F::I64;
           R2 = lvl109_rcHrt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.829947989 UTC

[section ""data" . lvl111_rcHrv_closure" {
     lvl111_rcHrv_closure:
         const lvl111_rcHrv_info;
         const 0;
 },
 lvl111_rcHrv_entry() //  [R3]
         { info_tbl: [(ccL6W,
                       label: lvl111_rcHrv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccL6W: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Stats.$fReadGCDetails2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:37.845312303 UTC

[section ""data" . GHC.Stats.$w$creadPrec1_closure" {
     GHC.Stats.$w$creadPrec1_closure:
         const GHC.Stats.$w$creadPrec1_info;
         const 0;
 },
 sat_scHB9_entry() //  [R1, R2]
         { info_tbl: [(ccLaA,
                       label: sat_scHB9_info
                       rep:HeapRep 21 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLaA: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccLaE; else goto ccLaD;
       ccLaE: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLaD: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           _scHB0::P64 = P64[R1 + 143];
           _scHB2::P64 = P64[R1 + 151];
           _scHB4::P64 = P64[R1 + 159];
           _scHB6::P64 = P64[R1 + 167];
           I64[Hp - 160] = GHC.Stats.RTSStats_con_info;
           P64[Hp - 152] = _scHAu::P64;
           P64[Hp - 144] = _scHAw::P64;
           P64[Hp - 136] = _scHAy::P64;
           P64[Hp - 128] = _scHAA::P64;
           P64[Hp - 120] = _scHAC::P64;
           P64[Hp - 112] = _scHAE::P64;
           P64[Hp - 104] = _scHAG::P64;
           P64[Hp - 96] = _scHAI::P64;
           P64[Hp - 88] = _scHAK::P64;
           P64[Hp - 80] = _scHAM::P64;
           P64[Hp - 72] = _scHAO::P64;
           P64[Hp - 64] = _scHAQ::P64;
           P64[Hp - 56] = _scHAS::P64;
           P64[Hp - 48] = _scHAU::P64;
           P64[Hp - 40] = _scHAW::P64;
           P64[Hp - 32] = _scHAY::P64;
           P64[Hp - 24] = _scHB0::P64;
           P64[Hp - 16] = _scHB2::P64;
           P64[Hp - 8] = _scHB4::P64;
           P64[Hp] = _scHB6::P64;
           R2 = Hp - 159;
           R1 = _scHAq::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBc_entry() //  [R1, R2]
         { info_tbl: [(ccLaI,
                       label: sat_scHBc_info
                       rep:HeapRep 20 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLaI: // global
           _scHB6::P64 = R2;
           _scHBc::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLaJ; else goto ccLaK;
       ccLaK: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccLaM; else goto ccLaL;
       ccLaM: // global
           HpAlloc = 176;
           goto ccLaJ;
       ccLaJ: // global
           R2 = _scHB6::P64;
           R1 = _scHBc::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLaL: // global
           _scHAq::P64 = P64[_scHBc::P64 + 7];
           _scHAu::P64 = P64[_scHBc::P64 + 15];
           _scHAw::P64 = P64[_scHBc::P64 + 23];
           _scHAy::P64 = P64[_scHBc::P64 + 31];
           _scHAA::P64 = P64[_scHBc::P64 + 39];
           _scHAC::P64 = P64[_scHBc::P64 + 47];
           _scHAE::P64 = P64[_scHBc::P64 + 55];
           _scHAG::P64 = P64[_scHBc::P64 + 63];
           _scHAI::P64 = P64[_scHBc::P64 + 71];
           _scHAK::P64 = P64[_scHBc::P64 + 79];
           _scHAM::P64 = P64[_scHBc::P64 + 87];
           _scHAO::P64 = P64[_scHBc::P64 + 95];
           _scHAQ::P64 = P64[_scHBc::P64 + 103];
           _scHAS::P64 = P64[_scHBc::P64 + 111];
           _scHAU::P64 = P64[_scHBc::P64 + 119];
           _scHAW::P64 = P64[_scHBc::P64 + 127];
           _scHAY::P64 = P64[_scHBc::P64 + 135];
           _scHB0::P64 = P64[_scHBc::P64 + 143];
           _scHB2::P64 = P64[_scHBc::P64 + 151];
           _scHB4::P64 = P64[_scHBc::P64 + 159];
           I64[Hp - 168] = sat_scHB9_info;
           P64[Hp - 160] = _scHAq::P64;
           P64[Hp - 152] = _scHAu::P64;
           P64[Hp - 144] = _scHAw::P64;
           P64[Hp - 136] = _scHAy::P64;
           P64[Hp - 128] = _scHAA::P64;
           P64[Hp - 120] = _scHAC::P64;
           P64[Hp - 112] = _scHAE::P64;
           P64[Hp - 104] = _scHAG::P64;
           P64[Hp - 96] = _scHAI::P64;
           P64[Hp - 88] = _scHAK::P64;
           P64[Hp - 80] = _scHAM::P64;
           P64[Hp - 72] = _scHAO::P64;
           P64[Hp - 64] = _scHAQ::P64;
           P64[Hp - 56] = _scHAS::P64;
           P64[Hp - 48] = _scHAU::P64;
           P64[Hp - 40] = _scHAW::P64;
           P64[Hp - 32] = _scHAY::P64;
           P64[Hp - 24] = _scHB0::P64;
           P64[Hp - 16] = _scHB2::P64;
           P64[Hp - 8] = _scHB4::P64;
           P64[Hp] = _scHB6::P64;
           I64[Sp - 8] = block_ccLaF_info;
           R3 = Hp - 167;
           R2 = lvl72_rcHqO_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLaF() //  [R1]
         { info_tbl: [(ccLaF,
                       label: block_ccLaF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLaF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLaP; else goto ccLaO;
       ccLaP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLaO: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBd_entry() //  [R1, R2]
         { info_tbl: [(ccLaQ,
                       label: sat_scHBd_info
                       rep:HeapRep 20 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLaQ: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccLaU; else goto ccLaT;
       ccLaU: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLaT: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           _scHB0::P64 = P64[R1 + 143];
           _scHB2::P64 = P64[R1 + 151];
           _scHB4::P64 = P64[R1 + 159];
           I64[Hp - 160] = sat_scHBc_info;
           P64[Hp - 152] = _scHAq::P64;
           P64[Hp - 144] = _scHAu::P64;
           P64[Hp - 136] = _scHAw::P64;
           P64[Hp - 128] = _scHAy::P64;
           P64[Hp - 120] = _scHAA::P64;
           P64[Hp - 112] = _scHAC::P64;
           P64[Hp - 104] = _scHAE::P64;
           P64[Hp - 96] = _scHAG::P64;
           P64[Hp - 88] = _scHAI::P64;
           P64[Hp - 80] = _scHAK::P64;
           P64[Hp - 72] = _scHAM::P64;
           P64[Hp - 64] = _scHAO::P64;
           P64[Hp - 56] = _scHAQ::P64;
           P64[Hp - 48] = _scHAS::P64;
           P64[Hp - 40] = _scHAU::P64;
           P64[Hp - 32] = _scHAW::P64;
           P64[Hp - 24] = _scHAY::P64;
           P64[Hp - 16] = _scHB0::P64;
           P64[Hp - 8] = _scHB2::P64;
           P64[Hp] = _scHB4::P64;
           R5 = Hp - 159;
           R4 = n_rcHqf_closure+1;
           R3 = lvl111_rcHrv_closure+2;
           R2 = lvl110_rcHru_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBg_entry() //  [R1, R2]
         { info_tbl: [(ccLaY,
                       label: sat_scHBg_info
                       rep:HeapRep 19 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLaY: // global
           _scHB4::P64 = R2;
           _scHBg::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLaZ; else goto ccLb0;
       ccLb0: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccLb2; else goto ccLb1;
       ccLb2: // global
           HpAlloc = 168;
           goto ccLaZ;
       ccLaZ: // global
           R2 = _scHB4::P64;
           R1 = _scHBg::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLb1: // global
           _scHAq::P64 = P64[_scHBg::P64 + 7];
           _scHAu::P64 = P64[_scHBg::P64 + 15];
           _scHAw::P64 = P64[_scHBg::P64 + 23];
           _scHAy::P64 = P64[_scHBg::P64 + 31];
           _scHAA::P64 = P64[_scHBg::P64 + 39];
           _scHAC::P64 = P64[_scHBg::P64 + 47];
           _scHAE::P64 = P64[_scHBg::P64 + 55];
           _scHAG::P64 = P64[_scHBg::P64 + 63];
           _scHAI::P64 = P64[_scHBg::P64 + 71];
           _scHAK::P64 = P64[_scHBg::P64 + 79];
           _scHAM::P64 = P64[_scHBg::P64 + 87];
           _scHAO::P64 = P64[_scHBg::P64 + 95];
           _scHAQ::P64 = P64[_scHBg::P64 + 103];
           _scHAS::P64 = P64[_scHBg::P64 + 111];
           _scHAU::P64 = P64[_scHBg::P64 + 119];
           _scHAW::P64 = P64[_scHBg::P64 + 127];
           _scHAY::P64 = P64[_scHBg::P64 + 135];
           _scHB0::P64 = P64[_scHBg::P64 + 143];
           _scHB2::P64 = P64[_scHBg::P64 + 151];
           I64[Hp - 160] = sat_scHBd_info;
           P64[Hp - 152] = _scHAq::P64;
           P64[Hp - 144] = _scHAu::P64;
           P64[Hp - 136] = _scHAw::P64;
           P64[Hp - 128] = _scHAy::P64;
           P64[Hp - 120] = _scHAA::P64;
           P64[Hp - 112] = _scHAC::P64;
           P64[Hp - 104] = _scHAE::P64;
           P64[Hp - 96] = _scHAG::P64;
           P64[Hp - 88] = _scHAI::P64;
           P64[Hp - 80] = _scHAK::P64;
           P64[Hp - 72] = _scHAM::P64;
           P64[Hp - 64] = _scHAO::P64;
           P64[Hp - 56] = _scHAQ::P64;
           P64[Hp - 48] = _scHAS::P64;
           P64[Hp - 40] = _scHAU::P64;
           P64[Hp - 32] = _scHAW::P64;
           P64[Hp - 24] = _scHAY::P64;
           P64[Hp - 16] = _scHB0::P64;
           P64[Hp - 8] = _scHB2::P64;
           P64[Hp] = _scHB4::P64;
           I64[Sp - 8] = block_ccLaV_info;
           R3 = Hp - 159;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLaV() //  [R1]
         { info_tbl: [(ccLaV,
                       label: block_ccLaV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLaV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLb5; else goto ccLb4;
       ccLb5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLb4: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBh_entry() //  [R1, R2]
         { info_tbl: [(ccLb6,
                       label: sat_scHBh_info
                       rep:HeapRep 19 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLb6: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccLba; else goto ccLb9;
       ccLba: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLb9: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           _scHB0::P64 = P64[R1 + 143];
           _scHB2::P64 = P64[R1 + 151];
           I64[Hp - 152] = sat_scHBg_info;
           P64[Hp - 144] = _scHAq::P64;
           P64[Hp - 136] = _scHAu::P64;
           P64[Hp - 128] = _scHAw::P64;
           P64[Hp - 120] = _scHAy::P64;
           P64[Hp - 112] = _scHAA::P64;
           P64[Hp - 104] = _scHAC::P64;
           P64[Hp - 96] = _scHAE::P64;
           P64[Hp - 88] = _scHAG::P64;
           P64[Hp - 80] = _scHAI::P64;
           P64[Hp - 72] = _scHAK::P64;
           P64[Hp - 64] = _scHAM::P64;
           P64[Hp - 56] = _scHAO::P64;
           P64[Hp - 48] = _scHAQ::P64;
           P64[Hp - 40] = _scHAS::P64;
           P64[Hp - 32] = _scHAU::P64;
           P64[Hp - 24] = _scHAW::P64;
           P64[Hp - 16] = _scHAY::P64;
           P64[Hp - 8] = _scHB0::P64;
           P64[Hp] = _scHB2::P64;
           R5 = Hp - 151;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl108_rcHrs_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scHBk_entry() //  [R1, R2]
         { info_tbl: [(ccLbe,
                       label: sat_scHBk_info
                       rep:HeapRep 18 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLbe: // global
           _scHB2::P64 = R2;
           _scHBk::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLbf; else goto ccLbg;
       ccLbg: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccLbi; else goto ccLbh;
       ccLbi: // global
           HpAlloc = 160;
           goto ccLbf;
       ccLbf: // global
           R2 = _scHB2::P64;
           R1 = _scHBk::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLbh: // global
           _scHAq::P64 = P64[_scHBk::P64 + 7];
           _scHAu::P64 = P64[_scHBk::P64 + 15];
           _scHAw::P64 = P64[_scHBk::P64 + 23];
           _scHAy::P64 = P64[_scHBk::P64 + 31];
           _scHAA::P64 = P64[_scHBk::P64 + 39];
           _scHAC::P64 = P64[_scHBk::P64 + 47];
           _scHAE::P64 = P64[_scHBk::P64 + 55];
           _scHAG::P64 = P64[_scHBk::P64 + 63];
           _scHAI::P64 = P64[_scHBk::P64 + 71];
           _scHAK::P64 = P64[_scHBk::P64 + 79];
           _scHAM::P64 = P64[_scHBk::P64 + 87];
           _scHAO::P64 = P64[_scHBk::P64 + 95];
           _scHAQ::P64 = P64[_scHBk::P64 + 103];
           _scHAS::P64 = P64[_scHBk::P64 + 111];
           _scHAU::P64 = P64[_scHBk::P64 + 119];
           _scHAW::P64 = P64[_scHBk::P64 + 127];
           _scHAY::P64 = P64[_scHBk::P64 + 135];
           _scHB0::P64 = P64[_scHBk::P64 + 143];
           I64[Hp - 152] = sat_scHBh_info;
           P64[Hp - 144] = _scHAq::P64;
           P64[Hp - 136] = _scHAu::P64;
           P64[Hp - 128] = _scHAw::P64;
           P64[Hp - 120] = _scHAy::P64;
           P64[Hp - 112] = _scHAA::P64;
           P64[Hp - 104] = _scHAC::P64;
           P64[Hp - 96] = _scHAE::P64;
           P64[Hp - 88] = _scHAG::P64;
           P64[Hp - 80] = _scHAI::P64;
           P64[Hp - 72] = _scHAK::P64;
           P64[Hp - 64] = _scHAM::P64;
           P64[Hp - 56] = _scHAO::P64;
           P64[Hp - 48] = _scHAQ::P64;
           P64[Hp - 40] = _scHAS::P64;
           P64[Hp - 32] = _scHAU::P64;
           P64[Hp - 24] = _scHAW::P64;
           P64[Hp - 16] = _scHAY::P64;
           P64[Hp - 8] = _scHB0::P64;
           P64[Hp] = _scHB2::P64;
           I64[Sp - 8] = block_ccLbb_info;
           R3 = Hp - 151;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLbb() //  [R1]
         { info_tbl: [(ccLbb,
                       label: block_ccLbb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLbb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLbl; else goto ccLbk;
       ccLbl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLbk: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLge_srtd" {
     ucLge_srtd:
         const ScI2G_srt+128;
         const 33;
         const 8053063727;
 },
 sat_scHBl_entry() //  [R1, R2]
         { info_tbl: [(ccLbm,
                       label: sat_scHBl_info
                       rep:HeapRep 18 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLbm: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccLbq; else goto ccLbp;
       ccLbq: // global
           HpAlloc = 152;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLbp: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           _scHB0::P64 = P64[R1 + 143];
           I64[Hp - 144] = sat_scHBk_info;
           P64[Hp - 136] = _scHAq::P64;
           P64[Hp - 128] = _scHAu::P64;
           P64[Hp - 120] = _scHAw::P64;
           P64[Hp - 112] = _scHAy::P64;
           P64[Hp - 104] = _scHAA::P64;
           P64[Hp - 96] = _scHAC::P64;
           P64[Hp - 88] = _scHAE::P64;
           P64[Hp - 80] = _scHAG::P64;
           P64[Hp - 72] = _scHAI::P64;
           P64[Hp - 64] = _scHAK::P64;
           P64[Hp - 56] = _scHAM::P64;
           P64[Hp - 48] = _scHAO::P64;
           P64[Hp - 40] = _scHAQ::P64;
           P64[Hp - 32] = _scHAS::P64;
           P64[Hp - 24] = _scHAU::P64;
           P64[Hp - 16] = _scHAW::P64;
           P64[Hp - 8] = _scHAY::P64;
           P64[Hp] = _scHB0::P64;
           R5 = Hp - 143;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl106_rcHrq_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgf_srtd" {
     ucLgf_srtd:
         const ScI2G_srt+128;
         const 33;
         const 8053063727;
 },
 sat_scHBo_entry() //  [R1, R2]
         { info_tbl: [(ccLbu,
                       label: sat_scHBo_info
                       rep:HeapRep 17 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLbu: // global
           _scHB0::P64 = R2;
           _scHBo::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLbv; else goto ccLbw;
       ccLbw: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccLby; else goto ccLbx;
       ccLby: // global
           HpAlloc = 152;
           goto ccLbv;
       ccLbv: // global
           R2 = _scHB0::P64;
           R1 = _scHBo::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLbx: // global
           _scHAq::P64 = P64[_scHBo::P64 + 7];
           _scHAu::P64 = P64[_scHBo::P64 + 15];
           _scHAw::P64 = P64[_scHBo::P64 + 23];
           _scHAy::P64 = P64[_scHBo::P64 + 31];
           _scHAA::P64 = P64[_scHBo::P64 + 39];
           _scHAC::P64 = P64[_scHBo::P64 + 47];
           _scHAE::P64 = P64[_scHBo::P64 + 55];
           _scHAG::P64 = P64[_scHBo::P64 + 63];
           _scHAI::P64 = P64[_scHBo::P64 + 71];
           _scHAK::P64 = P64[_scHBo::P64 + 79];
           _scHAM::P64 = P64[_scHBo::P64 + 87];
           _scHAO::P64 = P64[_scHBo::P64 + 95];
           _scHAQ::P64 = P64[_scHBo::P64 + 103];
           _scHAS::P64 = P64[_scHBo::P64 + 111];
           _scHAU::P64 = P64[_scHBo::P64 + 119];
           _scHAW::P64 = P64[_scHBo::P64 + 127];
           _scHAY::P64 = P64[_scHBo::P64 + 135];
           I64[Hp - 144] = sat_scHBl_info;
           P64[Hp - 136] = _scHAq::P64;
           P64[Hp - 128] = _scHAu::P64;
           P64[Hp - 120] = _scHAw::P64;
           P64[Hp - 112] = _scHAy::P64;
           P64[Hp - 104] = _scHAA::P64;
           P64[Hp - 96] = _scHAC::P64;
           P64[Hp - 88] = _scHAE::P64;
           P64[Hp - 80] = _scHAG::P64;
           P64[Hp - 72] = _scHAI::P64;
           P64[Hp - 64] = _scHAK::P64;
           P64[Hp - 56] = _scHAM::P64;
           P64[Hp - 48] = _scHAO::P64;
           P64[Hp - 40] = _scHAQ::P64;
           P64[Hp - 32] = _scHAS::P64;
           P64[Hp - 24] = _scHAU::P64;
           P64[Hp - 16] = _scHAW::P64;
           P64[Hp - 8] = _scHAY::P64;
           P64[Hp] = _scHB0::P64;
           I64[Sp - 8] = block_ccLbr_info;
           R3 = Hp - 143;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLbr() //  [R1]
         { info_tbl: [(ccLbr,
                       label: block_ccLbr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLbr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLbB; else goto ccLbA;
       ccLbB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLbA: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgg_srtd" {
     ucLgg_srtd:
         const ScI2G_srt+128;
         const 34;
         const 16642998319;
 },
 sat_scHBp_entry() //  [R1, R2]
         { info_tbl: [(ccLbC,
                       label: sat_scHBp_info
                       rep:HeapRep 17 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLbC: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccLbG; else goto ccLbF;
       ccLbG: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLbF: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           _scHAY::P64 = P64[R1 + 135];
           I64[Hp - 136] = sat_scHBo_info;
           P64[Hp - 128] = _scHAq::P64;
           P64[Hp - 120] = _scHAu::P64;
           P64[Hp - 112] = _scHAw::P64;
           P64[Hp - 104] = _scHAy::P64;
           P64[Hp - 96] = _scHAA::P64;
           P64[Hp - 88] = _scHAC::P64;
           P64[Hp - 80] = _scHAE::P64;
           P64[Hp - 72] = _scHAG::P64;
           P64[Hp - 64] = _scHAI::P64;
           P64[Hp - 56] = _scHAK::P64;
           P64[Hp - 48] = _scHAM::P64;
           P64[Hp - 40] = _scHAO::P64;
           P64[Hp - 32] = _scHAQ::P64;
           P64[Hp - 24] = _scHAS::P64;
           P64[Hp - 16] = _scHAU::P64;
           P64[Hp - 8] = _scHAW::P64;
           P64[Hp] = _scHAY::P64;
           R5 = Hp - 135;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl104_rcHro_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgh_srtd" {
     ucLgh_srtd:
         const ScI2G_srt+128;
         const 34;
         const 16642998319;
 },
 sat_scHBs_entry() //  [R1, R2]
         { info_tbl: [(ccLbK,
                       label: sat_scHBs_info
                       rep:HeapRep 16 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLbK: // global
           _scHAY::P64 = R2;
           _scHBs::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLbL; else goto ccLbM;
       ccLbM: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccLbO; else goto ccLbN;
       ccLbO: // global
           HpAlloc = 144;
           goto ccLbL;
       ccLbL: // global
           R2 = _scHAY::P64;
           R1 = _scHBs::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLbN: // global
           _scHAq::P64 = P64[_scHBs::P64 + 7];
           _scHAu::P64 = P64[_scHBs::P64 + 15];
           _scHAw::P64 = P64[_scHBs::P64 + 23];
           _scHAy::P64 = P64[_scHBs::P64 + 31];
           _scHAA::P64 = P64[_scHBs::P64 + 39];
           _scHAC::P64 = P64[_scHBs::P64 + 47];
           _scHAE::P64 = P64[_scHBs::P64 + 55];
           _scHAG::P64 = P64[_scHBs::P64 + 63];
           _scHAI::P64 = P64[_scHBs::P64 + 71];
           _scHAK::P64 = P64[_scHBs::P64 + 79];
           _scHAM::P64 = P64[_scHBs::P64 + 87];
           _scHAO::P64 = P64[_scHBs::P64 + 95];
           _scHAQ::P64 = P64[_scHBs::P64 + 103];
           _scHAS::P64 = P64[_scHBs::P64 + 111];
           _scHAU::P64 = P64[_scHBs::P64 + 119];
           _scHAW::P64 = P64[_scHBs::P64 + 127];
           I64[Hp - 136] = sat_scHBp_info;
           P64[Hp - 128] = _scHAq::P64;
           P64[Hp - 120] = _scHAu::P64;
           P64[Hp - 112] = _scHAw::P64;
           P64[Hp - 104] = _scHAy::P64;
           P64[Hp - 96] = _scHAA::P64;
           P64[Hp - 88] = _scHAC::P64;
           P64[Hp - 80] = _scHAE::P64;
           P64[Hp - 72] = _scHAG::P64;
           P64[Hp - 64] = _scHAI::P64;
           P64[Hp - 56] = _scHAK::P64;
           P64[Hp - 48] = _scHAM::P64;
           P64[Hp - 40] = _scHAO::P64;
           P64[Hp - 32] = _scHAQ::P64;
           P64[Hp - 24] = _scHAS::P64;
           P64[Hp - 16] = _scHAU::P64;
           P64[Hp - 8] = _scHAW::P64;
           P64[Hp] = _scHAY::P64;
           I64[Sp - 8] = block_ccLbH_info;
           R3 = Hp - 135;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLbH() //  [R1]
         { info_tbl: [(ccLbH,
                       label: block_ccLbH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLbH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLbR; else goto ccLbQ;
       ccLbR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLbQ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgi_srtd" {
     ucLgi_srtd:
         const ScI2G_srt+128;
         const 35;
         const 33822867503;
 },
 sat_scHBt_entry() //  [R1, R2]
         { info_tbl: [(ccLbS,
                       label: sat_scHBt_info
                       rep:HeapRep 16 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLbS: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccLbW; else goto ccLbV;
       ccLbW: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLbV: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           _scHAW::P64 = P64[R1 + 127];
           I64[Hp - 128] = sat_scHBs_info;
           P64[Hp - 120] = _scHAq::P64;
           P64[Hp - 112] = _scHAu::P64;
           P64[Hp - 104] = _scHAw::P64;
           P64[Hp - 96] = _scHAy::P64;
           P64[Hp - 88] = _scHAA::P64;
           P64[Hp - 80] = _scHAC::P64;
           P64[Hp - 72] = _scHAE::P64;
           P64[Hp - 64] = _scHAG::P64;
           P64[Hp - 56] = _scHAI::P64;
           P64[Hp - 48] = _scHAK::P64;
           P64[Hp - 40] = _scHAM::P64;
           P64[Hp - 32] = _scHAO::P64;
           P64[Hp - 24] = _scHAQ::P64;
           P64[Hp - 16] = _scHAS::P64;
           P64[Hp - 8] = _scHAU::P64;
           P64[Hp] = _scHAW::P64;
           R5 = Hp - 127;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl102_rcHrm_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgj_srtd" {
     ucLgj_srtd:
         const ScI2G_srt+128;
         const 35;
         const 33822867503;
 },
 sat_scHBw_entry() //  [R1, R2]
         { info_tbl: [(ccLc0,
                       label: sat_scHBw_info
                       rep:HeapRep 15 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLc0: // global
           _scHAW::P64 = R2;
           _scHBw::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLc1; else goto ccLc2;
       ccLc2: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccLc4; else goto ccLc3;
       ccLc4: // global
           HpAlloc = 136;
           goto ccLc1;
       ccLc1: // global
           R2 = _scHAW::P64;
           R1 = _scHBw::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLc3: // global
           _scHAq::P64 = P64[_scHBw::P64 + 7];
           _scHAu::P64 = P64[_scHBw::P64 + 15];
           _scHAw::P64 = P64[_scHBw::P64 + 23];
           _scHAy::P64 = P64[_scHBw::P64 + 31];
           _scHAA::P64 = P64[_scHBw::P64 + 39];
           _scHAC::P64 = P64[_scHBw::P64 + 47];
           _scHAE::P64 = P64[_scHBw::P64 + 55];
           _scHAG::P64 = P64[_scHBw::P64 + 63];
           _scHAI::P64 = P64[_scHBw::P64 + 71];
           _scHAK::P64 = P64[_scHBw::P64 + 79];
           _scHAM::P64 = P64[_scHBw::P64 + 87];
           _scHAO::P64 = P64[_scHBw::P64 + 95];
           _scHAQ::P64 = P64[_scHBw::P64 + 103];
           _scHAS::P64 = P64[_scHBw::P64 + 111];
           _scHAU::P64 = P64[_scHBw::P64 + 119];
           I64[Hp - 128] = sat_scHBt_info;
           P64[Hp - 120] = _scHAq::P64;
           P64[Hp - 112] = _scHAu::P64;
           P64[Hp - 104] = _scHAw::P64;
           P64[Hp - 96] = _scHAy::P64;
           P64[Hp - 88] = _scHAA::P64;
           P64[Hp - 80] = _scHAC::P64;
           P64[Hp - 72] = _scHAE::P64;
           P64[Hp - 64] = _scHAG::P64;
           P64[Hp - 56] = _scHAI::P64;
           P64[Hp - 48] = _scHAK::P64;
           P64[Hp - 40] = _scHAM::P64;
           P64[Hp - 32] = _scHAO::P64;
           P64[Hp - 24] = _scHAQ::P64;
           P64[Hp - 16] = _scHAS::P64;
           P64[Hp - 8] = _scHAU::P64;
           P64[Hp] = _scHAW::P64;
           I64[Sp - 8] = block_ccLbX_info;
           R3 = Hp - 127;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLbX() //  [R1]
         { info_tbl: [(ccLbX,
                       label: block_ccLbX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLbX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLc7; else goto ccLc6;
       ccLc7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLc6: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgk_srtd" {
     ucLgk_srtd:
         const ScI2G_srt+128;
         const 36;
         const 68182605871;
 },
 sat_scHBx_entry() //  [R1, R2]
         { info_tbl: [(ccLc8,
                       label: sat_scHBx_info
                       rep:HeapRep 15 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLc8: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccLcc; else goto ccLcb;
       ccLcc: // global
           HpAlloc = 128;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLcb: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           _scHAU::P64 = P64[R1 + 119];
           I64[Hp - 120] = sat_scHBw_info;
           P64[Hp - 112] = _scHAq::P64;
           P64[Hp - 104] = _scHAu::P64;
           P64[Hp - 96] = _scHAw::P64;
           P64[Hp - 88] = _scHAy::P64;
           P64[Hp - 80] = _scHAA::P64;
           P64[Hp - 72] = _scHAC::P64;
           P64[Hp - 64] = _scHAE::P64;
           P64[Hp - 56] = _scHAG::P64;
           P64[Hp - 48] = _scHAI::P64;
           P64[Hp - 40] = _scHAK::P64;
           P64[Hp - 32] = _scHAM::P64;
           P64[Hp - 24] = _scHAO::P64;
           P64[Hp - 16] = _scHAQ::P64;
           P64[Hp - 8] = _scHAS::P64;
           P64[Hp] = _scHAU::P64;
           R5 = Hp - 119;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl100_rcHrk_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgl_srtd" {
     ucLgl_srtd:
         const ScI2G_srt+128;
         const 36;
         const 68182605871;
 },
 sat_scHBA_entry() //  [R1, R2]
         { info_tbl: [(ccLcg,
                       label: sat_scHBA_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLcg: // global
           _scHAU::P64 = R2;
           _scHBA::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLch; else goto ccLci;
       ccLci: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccLck; else goto ccLcj;
       ccLck: // global
           HpAlloc = 128;
           goto ccLch;
       ccLch: // global
           R2 = _scHAU::P64;
           R1 = _scHBA::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLcj: // global
           _scHAq::P64 = P64[_scHBA::P64 + 7];
           _scHAu::P64 = P64[_scHBA::P64 + 15];
           _scHAw::P64 = P64[_scHBA::P64 + 23];
           _scHAy::P64 = P64[_scHBA::P64 + 31];
           _scHAA::P64 = P64[_scHBA::P64 + 39];
           _scHAC::P64 = P64[_scHBA::P64 + 47];
           _scHAE::P64 = P64[_scHBA::P64 + 55];
           _scHAG::P64 = P64[_scHBA::P64 + 63];
           _scHAI::P64 = P64[_scHBA::P64 + 71];
           _scHAK::P64 = P64[_scHBA::P64 + 79];
           _scHAM::P64 = P64[_scHBA::P64 + 87];
           _scHAO::P64 = P64[_scHBA::P64 + 95];
           _scHAQ::P64 = P64[_scHBA::P64 + 103];
           _scHAS::P64 = P64[_scHBA::P64 + 111];
           I64[Hp - 120] = sat_scHBx_info;
           P64[Hp - 112] = _scHAq::P64;
           P64[Hp - 104] = _scHAu::P64;
           P64[Hp - 96] = _scHAw::P64;
           P64[Hp - 88] = _scHAy::P64;
           P64[Hp - 80] = _scHAA::P64;
           P64[Hp - 72] = _scHAC::P64;
           P64[Hp - 64] = _scHAE::P64;
           P64[Hp - 56] = _scHAG::P64;
           P64[Hp - 48] = _scHAI::P64;
           P64[Hp - 40] = _scHAK::P64;
           P64[Hp - 32] = _scHAM::P64;
           P64[Hp - 24] = _scHAO::P64;
           P64[Hp - 16] = _scHAQ::P64;
           P64[Hp - 8] = _scHAS::P64;
           P64[Hp] = _scHAU::P64;
           I64[Sp - 8] = block_ccLcd_info;
           R3 = Hp - 119;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLcd() //  [R1]
         { info_tbl: [(ccLcd,
                       label: block_ccLcd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLcd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLcn; else goto ccLcm;
       ccLcn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLcm: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgm_srtd" {
     ucLgm_srtd:
         const ScI2G_srt+128;
         const 37;
         const 136902082607;
 },
 sat_scHBB_entry() //  [R1, R2]
         { info_tbl: [(ccLco,
                       label: sat_scHBB_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLco: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccLcs; else goto ccLcr;
       ccLcs: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLcr: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           _scHAS::P64 = P64[R1 + 111];
           I64[Hp - 112] = sat_scHBA_info;
           P64[Hp - 104] = _scHAq::P64;
           P64[Hp - 96] = _scHAu::P64;
           P64[Hp - 88] = _scHAw::P64;
           P64[Hp - 80] = _scHAy::P64;
           P64[Hp - 72] = _scHAA::P64;
           P64[Hp - 64] = _scHAC::P64;
           P64[Hp - 56] = _scHAE::P64;
           P64[Hp - 48] = _scHAG::P64;
           P64[Hp - 40] = _scHAI::P64;
           P64[Hp - 32] = _scHAK::P64;
           P64[Hp - 24] = _scHAM::P64;
           P64[Hp - 16] = _scHAO::P64;
           P64[Hp - 8] = _scHAQ::P64;
           P64[Hp] = _scHAS::P64;
           R5 = Hp - 111;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl98_rcHri_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgn_srtd" {
     ucLgn_srtd:
         const ScI2G_srt+128;
         const 37;
         const 136902082607;
 },
 sat_scHBE_entry() //  [R1, R2]
         { info_tbl: [(ccLcw,
                       label: sat_scHBE_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLcw: // global
           _scHAS::P64 = R2;
           _scHBE::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLcx; else goto ccLcy;
       ccLcy: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccLcA; else goto ccLcz;
       ccLcA: // global
           HpAlloc = 120;
           goto ccLcx;
       ccLcx: // global
           R2 = _scHAS::P64;
           R1 = _scHBE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLcz: // global
           _scHAq::P64 = P64[_scHBE::P64 + 7];
           _scHAu::P64 = P64[_scHBE::P64 + 15];
           _scHAw::P64 = P64[_scHBE::P64 + 23];
           _scHAy::P64 = P64[_scHBE::P64 + 31];
           _scHAA::P64 = P64[_scHBE::P64 + 39];
           _scHAC::P64 = P64[_scHBE::P64 + 47];
           _scHAE::P64 = P64[_scHBE::P64 + 55];
           _scHAG::P64 = P64[_scHBE::P64 + 63];
           _scHAI::P64 = P64[_scHBE::P64 + 71];
           _scHAK::P64 = P64[_scHBE::P64 + 79];
           _scHAM::P64 = P64[_scHBE::P64 + 87];
           _scHAO::P64 = P64[_scHBE::P64 + 95];
           _scHAQ::P64 = P64[_scHBE::P64 + 103];
           I64[Hp - 112] = sat_scHBB_info;
           P64[Hp - 104] = _scHAq::P64;
           P64[Hp - 96] = _scHAu::P64;
           P64[Hp - 88] = _scHAw::P64;
           P64[Hp - 80] = _scHAy::P64;
           P64[Hp - 72] = _scHAA::P64;
           P64[Hp - 64] = _scHAC::P64;
           P64[Hp - 56] = _scHAE::P64;
           P64[Hp - 48] = _scHAG::P64;
           P64[Hp - 40] = _scHAI::P64;
           P64[Hp - 32] = _scHAK::P64;
           P64[Hp - 24] = _scHAM::P64;
           P64[Hp - 16] = _scHAO::P64;
           P64[Hp - 8] = _scHAQ::P64;
           P64[Hp] = _scHAS::P64;
           I64[Sp - 8] = block_ccLct_info;
           R3 = Hp - 111;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLct() //  [R1]
         { info_tbl: [(ccLct,
                       label: block_ccLct_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLct: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLcD; else goto ccLcC;
       ccLcD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLcC: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgo_srtd" {
     ucLgo_srtd:
         const ScI2G_srt+104;
         const 41;
         const 2194728288633;
 },
 sat_scHBF_entry() //  [R1, R2]
         { info_tbl: [(ccLcE,
                       label: sat_scHBF_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLcE: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccLcI; else goto ccLcH;
       ccLcI: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLcH: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           _scHAQ::P64 = P64[R1 + 103];
           I64[Hp - 104] = sat_scHBE_info;
           P64[Hp - 96] = _scHAq::P64;
           P64[Hp - 88] = _scHAu::P64;
           P64[Hp - 80] = _scHAw::P64;
           P64[Hp - 72] = _scHAy::P64;
           P64[Hp - 64] = _scHAA::P64;
           P64[Hp - 56] = _scHAC::P64;
           P64[Hp - 48] = _scHAE::P64;
           P64[Hp - 40] = _scHAG::P64;
           P64[Hp - 32] = _scHAI::P64;
           P64[Hp - 24] = _scHAK::P64;
           P64[Hp - 16] = _scHAM::P64;
           P64[Hp - 8] = _scHAO::P64;
           P64[Hp] = _scHAQ::P64;
           R5 = Hp - 103;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl96_rcHrg_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgp_srtd" {
     ucLgp_srtd:
         const ScI2G_srt+104;
         const 41;
         const 2194728288633;
 },
 sat_scHBI_entry() //  [R1, R2]
         { info_tbl: [(ccLcM,
                       label: sat_scHBI_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLcM: // global
           _scHAQ::P64 = R2;
           _scHBI::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLcN; else goto ccLcO;
       ccLcO: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccLcQ; else goto ccLcP;
       ccLcQ: // global
           HpAlloc = 112;
           goto ccLcN;
       ccLcN: // global
           R2 = _scHAQ::P64;
           R1 = _scHBI::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLcP: // global
           _scHAq::P64 = P64[_scHBI::P64 + 7];
           _scHAu::P64 = P64[_scHBI::P64 + 15];
           _scHAw::P64 = P64[_scHBI::P64 + 23];
           _scHAy::P64 = P64[_scHBI::P64 + 31];
           _scHAA::P64 = P64[_scHBI::P64 + 39];
           _scHAC::P64 = P64[_scHBI::P64 + 47];
           _scHAE::P64 = P64[_scHBI::P64 + 55];
           _scHAG::P64 = P64[_scHBI::P64 + 63];
           _scHAI::P64 = P64[_scHBI::P64 + 71];
           _scHAK::P64 = P64[_scHBI::P64 + 79];
           _scHAM::P64 = P64[_scHBI::P64 + 87];
           _scHAO::P64 = P64[_scHBI::P64 + 95];
           I64[Hp - 104] = sat_scHBF_info;
           P64[Hp - 96] = _scHAq::P64;
           P64[Hp - 88] = _scHAu::P64;
           P64[Hp - 80] = _scHAw::P64;
           P64[Hp - 72] = _scHAy::P64;
           P64[Hp - 64] = _scHAA::P64;
           P64[Hp - 56] = _scHAC::P64;
           P64[Hp - 48] = _scHAE::P64;
           P64[Hp - 40] = _scHAG::P64;
           P64[Hp - 32] = _scHAI::P64;
           P64[Hp - 24] = _scHAK::P64;
           P64[Hp - 16] = _scHAM::P64;
           P64[Hp - 8] = _scHAO::P64;
           P64[Hp] = _scHAQ::P64;
           I64[Sp - 8] = block_ccLcJ_info;
           R3 = Hp - 103;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLcJ() //  [R1]
         { info_tbl: [(ccLcJ,
                       label: block_ccLcJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLcJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLcT; else goto ccLcS;
       ccLcT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLcS: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgq_srtd" {
     ucLgq_srtd:
         const ScI2G_srt+104;
         const 42;
         const 4393751544185;
 },
 sat_scHBJ_entry() //  [R1, R2]
         { info_tbl: [(ccLcU,
                       label: sat_scHBJ_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLcU: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccLcY; else goto ccLcX;
       ccLcY: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLcX: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           _scHAO::P64 = P64[R1 + 95];
           I64[Hp - 96] = sat_scHBI_info;
           P64[Hp - 88] = _scHAq::P64;
           P64[Hp - 80] = _scHAu::P64;
           P64[Hp - 72] = _scHAw::P64;
           P64[Hp - 64] = _scHAy::P64;
           P64[Hp - 56] = _scHAA::P64;
           P64[Hp - 48] = _scHAC::P64;
           P64[Hp - 40] = _scHAE::P64;
           P64[Hp - 32] = _scHAG::P64;
           P64[Hp - 24] = _scHAI::P64;
           P64[Hp - 16] = _scHAK::P64;
           P64[Hp - 8] = _scHAM::P64;
           P64[Hp] = _scHAO::P64;
           R5 = Hp - 95;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl94_rcHre_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgr_srtd" {
     ucLgr_srtd:
         const ScI2G_srt+104;
         const 42;
         const 4393751544185;
 },
 sat_scHBM_entry() //  [R1, R2]
         { info_tbl: [(ccLd2,
                       label: sat_scHBM_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLd2: // global
           _scHAO::P64 = R2;
           _scHBM::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLd3; else goto ccLd4;
       ccLd4: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccLd6; else goto ccLd5;
       ccLd6: // global
           HpAlloc = 104;
           goto ccLd3;
       ccLd3: // global
           R2 = _scHAO::P64;
           R1 = _scHBM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLd5: // global
           _scHAq::P64 = P64[_scHBM::P64 + 7];
           _scHAu::P64 = P64[_scHBM::P64 + 15];
           _scHAw::P64 = P64[_scHBM::P64 + 23];
           _scHAy::P64 = P64[_scHBM::P64 + 31];
           _scHAA::P64 = P64[_scHBM::P64 + 39];
           _scHAC::P64 = P64[_scHBM::P64 + 47];
           _scHAE::P64 = P64[_scHBM::P64 + 55];
           _scHAG::P64 = P64[_scHBM::P64 + 63];
           _scHAI::P64 = P64[_scHBM::P64 + 71];
           _scHAK::P64 = P64[_scHBM::P64 + 79];
           _scHAM::P64 = P64[_scHBM::P64 + 87];
           I64[Hp - 96] = sat_scHBJ_info;
           P64[Hp - 88] = _scHAq::P64;
           P64[Hp - 80] = _scHAu::P64;
           P64[Hp - 72] = _scHAw::P64;
           P64[Hp - 64] = _scHAy::P64;
           P64[Hp - 56] = _scHAA::P64;
           P64[Hp - 48] = _scHAC::P64;
           P64[Hp - 40] = _scHAE::P64;
           P64[Hp - 32] = _scHAG::P64;
           P64[Hp - 24] = _scHAI::P64;
           P64[Hp - 16] = _scHAK::P64;
           P64[Hp - 8] = _scHAM::P64;
           P64[Hp] = _scHAO::P64;
           I64[Sp - 8] = block_ccLcZ_info;
           R3 = Hp - 95;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLcZ() //  [R1]
         { info_tbl: [(ccLcZ,
                       label: block_ccLcZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLcZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLd9; else goto ccLd8;
       ccLd9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLd8: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgs_srtd" {
     ucLgs_srtd:
         const ScI2G_srt+104;
         const 43;
         const 8791798055289;
 },
 sat_scHBN_entry() //  [R1, R2]
         { info_tbl: [(ccLda,
                       label: sat_scHBN_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLda: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccLde; else goto ccLdd;
       ccLde: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLdd: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           _scHAM::P64 = P64[R1 + 87];
           I64[Hp - 88] = sat_scHBM_info;
           P64[Hp - 80] = _scHAq::P64;
           P64[Hp - 72] = _scHAu::P64;
           P64[Hp - 64] = _scHAw::P64;
           P64[Hp - 56] = _scHAy::P64;
           P64[Hp - 48] = _scHAA::P64;
           P64[Hp - 40] = _scHAC::P64;
           P64[Hp - 32] = _scHAE::P64;
           P64[Hp - 24] = _scHAG::P64;
           P64[Hp - 16] = _scHAI::P64;
           P64[Hp - 8] = _scHAK::P64;
           P64[Hp] = _scHAM::P64;
           R5 = Hp - 87;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl92_rcHrc_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgt_srtd" {
     ucLgt_srtd:
         const ScI2G_srt+104;
         const 43;
         const 8791798055289;
 },
 sat_scHBQ_entry() //  [R1, R2]
         { info_tbl: [(ccLdi,
                       label: sat_scHBQ_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLdi: // global
           _scHAM::P64 = R2;
           _scHBQ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLdj; else goto ccLdk;
       ccLdk: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccLdm; else goto ccLdl;
       ccLdm: // global
           HpAlloc = 96;
           goto ccLdj;
       ccLdj: // global
           R2 = _scHAM::P64;
           R1 = _scHBQ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLdl: // global
           _scHAq::P64 = P64[_scHBQ::P64 + 7];
           _scHAu::P64 = P64[_scHBQ::P64 + 15];
           _scHAw::P64 = P64[_scHBQ::P64 + 23];
           _scHAy::P64 = P64[_scHBQ::P64 + 31];
           _scHAA::P64 = P64[_scHBQ::P64 + 39];
           _scHAC::P64 = P64[_scHBQ::P64 + 47];
           _scHAE::P64 = P64[_scHBQ::P64 + 55];
           _scHAG::P64 = P64[_scHBQ::P64 + 63];
           _scHAI::P64 = P64[_scHBQ::P64 + 71];
           _scHAK::P64 = P64[_scHBQ::P64 + 79];
           I64[Hp - 88] = sat_scHBN_info;
           P64[Hp - 80] = _scHAq::P64;
           P64[Hp - 72] = _scHAu::P64;
           P64[Hp - 64] = _scHAw::P64;
           P64[Hp - 56] = _scHAy::P64;
           P64[Hp - 48] = _scHAA::P64;
           P64[Hp - 40] = _scHAC::P64;
           P64[Hp - 32] = _scHAE::P64;
           P64[Hp - 24] = _scHAG::P64;
           P64[Hp - 16] = _scHAI::P64;
           P64[Hp - 8] = _scHAK::P64;
           P64[Hp] = _scHAM::P64;
           I64[Sp - 8] = block_ccLdf_info;
           R3 = Hp - 87;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLdf() //  [R1]
         { info_tbl: [(ccLdf,
                       label: block_ccLdf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLdf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLdp; else goto ccLdo;
       ccLdp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLdo: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgu_srtd" {
     ucLgu_srtd:
         const ScI2G_srt+104;
         const 44;
         const 17587891077497;
 },
 sat_scHBR_entry() //  [R1, R2]
         { info_tbl: [(ccLdq,
                       label: sat_scHBR_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLdq: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccLdu; else goto ccLdt;
       ccLdu: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLdt: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           _scHAK::P64 = P64[R1 + 79];
           I64[Hp - 80] = sat_scHBQ_info;
           P64[Hp - 72] = _scHAq::P64;
           P64[Hp - 64] = _scHAu::P64;
           P64[Hp - 56] = _scHAw::P64;
           P64[Hp - 48] = _scHAy::P64;
           P64[Hp - 40] = _scHAA::P64;
           P64[Hp - 32] = _scHAC::P64;
           P64[Hp - 24] = _scHAE::P64;
           P64[Hp - 16] = _scHAG::P64;
           P64[Hp - 8] = _scHAI::P64;
           P64[Hp] = _scHAK::P64;
           R5 = Hp - 79;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl90_rcHra_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgv_srtd" {
     ucLgv_srtd:
         const ScI2G_srt+104;
         const 44;
         const 17587891077497;
 },
 sat_scHBU_entry() //  [R1, R2]
         { info_tbl: [(ccLdy,
                       label: sat_scHBU_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLdy: // global
           _scHAK::P64 = R2;
           _scHBU::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLdz; else goto ccLdA;
       ccLdA: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccLdC; else goto ccLdB;
       ccLdC: // global
           HpAlloc = 88;
           goto ccLdz;
       ccLdz: // global
           R2 = _scHAK::P64;
           R1 = _scHBU::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLdB: // global
           _scHAq::P64 = P64[_scHBU::P64 + 7];
           _scHAu::P64 = P64[_scHBU::P64 + 15];
           _scHAw::P64 = P64[_scHBU::P64 + 23];
           _scHAy::P64 = P64[_scHBU::P64 + 31];
           _scHAA::P64 = P64[_scHBU::P64 + 39];
           _scHAC::P64 = P64[_scHBU::P64 + 47];
           _scHAE::P64 = P64[_scHBU::P64 + 55];
           _scHAG::P64 = P64[_scHBU::P64 + 63];
           _scHAI::P64 = P64[_scHBU::P64 + 71];
           I64[Hp - 80] = sat_scHBR_info;
           P64[Hp - 72] = _scHAq::P64;
           P64[Hp - 64] = _scHAu::P64;
           P64[Hp - 56] = _scHAw::P64;
           P64[Hp - 48] = _scHAy::P64;
           P64[Hp - 40] = _scHAA::P64;
           P64[Hp - 32] = _scHAC::P64;
           P64[Hp - 24] = _scHAE::P64;
           P64[Hp - 16] = _scHAG::P64;
           P64[Hp - 8] = _scHAI::P64;
           P64[Hp] = _scHAK::P64;
           I64[Sp - 8] = block_ccLdv_info;
           R3 = Hp - 79;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLdv() //  [R1]
         { info_tbl: [(ccLdv,
                       label: block_ccLdv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLdv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLdF; else goto ccLdE;
       ccLdF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLdE: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgw_srtd" {
     ucLgw_srtd:
         const ScI2G_srt+104;
         const 45;
         const 35180077121913;
 },
 sat_scHBV_entry() //  [R1, R2]
         { info_tbl: [(ccLdG,
                       label: sat_scHBV_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLdG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccLdK; else goto ccLdJ;
       ccLdK: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLdJ: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           _scHAI::P64 = P64[R1 + 71];
           I64[Hp - 72] = sat_scHBU_info;
           P64[Hp - 64] = _scHAq::P64;
           P64[Hp - 56] = _scHAu::P64;
           P64[Hp - 48] = _scHAw::P64;
           P64[Hp - 40] = _scHAy::P64;
           P64[Hp - 32] = _scHAA::P64;
           P64[Hp - 24] = _scHAC::P64;
           P64[Hp - 16] = _scHAE::P64;
           P64[Hp - 8] = _scHAG::P64;
           P64[Hp] = _scHAI::P64;
           R5 = Hp - 71;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl88_rcHr8_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgx_srtd" {
     ucLgx_srtd:
         const ScI2G_srt+104;
         const 45;
         const 35180077121913;
 },
 sat_scHBY_entry() //  [R1, R2]
         { info_tbl: [(ccLdO,
                       label: sat_scHBY_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLdO: // global
           _scHAI::P64 = R2;
           _scHBY::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLdP; else goto ccLdQ;
       ccLdQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccLdS; else goto ccLdR;
       ccLdS: // global
           HpAlloc = 80;
           goto ccLdP;
       ccLdP: // global
           R2 = _scHAI::P64;
           R1 = _scHBY::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLdR: // global
           _scHAq::P64 = P64[_scHBY::P64 + 7];
           _scHAu::P64 = P64[_scHBY::P64 + 15];
           _scHAw::P64 = P64[_scHBY::P64 + 23];
           _scHAy::P64 = P64[_scHBY::P64 + 31];
           _scHAA::P64 = P64[_scHBY::P64 + 39];
           _scHAC::P64 = P64[_scHBY::P64 + 47];
           _scHAE::P64 = P64[_scHBY::P64 + 55];
           _scHAG::P64 = P64[_scHBY::P64 + 63];
           I64[Hp - 72] = sat_scHBV_info;
           P64[Hp - 64] = _scHAq::P64;
           P64[Hp - 56] = _scHAu::P64;
           P64[Hp - 48] = _scHAw::P64;
           P64[Hp - 40] = _scHAy::P64;
           P64[Hp - 32] = _scHAA::P64;
           P64[Hp - 24] = _scHAC::P64;
           P64[Hp - 16] = _scHAE::P64;
           P64[Hp - 8] = _scHAG::P64;
           P64[Hp] = _scHAI::P64;
           I64[Sp - 8] = block_ccLdL_info;
           R3 = Hp - 71;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLdL() //  [R1]
         { info_tbl: [(ccLdL,
                       label: block_ccLdL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLdL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLdV; else goto ccLdU;
       ccLdV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLdU: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgy_srtd" {
     ucLgy_srtd:
         const ScI2G_srt+104;
         const 46;
         const 70364449210745;
 },
 sat_scHBZ_entry() //  [R1, R2]
         { info_tbl: [(ccLdW,
                       label: sat_scHBZ_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLdW: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccLe0; else goto ccLdZ;
       ccLe0: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLdZ: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           _scHAG::P64 = P64[R1 + 63];
           I64[Hp - 64] = sat_scHBY_info;
           P64[Hp - 56] = _scHAq::P64;
           P64[Hp - 48] = _scHAu::P64;
           P64[Hp - 40] = _scHAw::P64;
           P64[Hp - 32] = _scHAy::P64;
           P64[Hp - 24] = _scHAA::P64;
           P64[Hp - 16] = _scHAC::P64;
           P64[Hp - 8] = _scHAE::P64;
           P64[Hp] = _scHAG::P64;
           R5 = Hp - 63;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl86_rcHr6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgz_srtd" {
     ucLgz_srtd:
         const ScI2G_srt+104;
         const 46;
         const 70364449210745;
 },
 sat_scHC2_entry() //  [R1, R2]
         { info_tbl: [(ccLe4,
                       label: sat_scHC2_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLe4: // global
           _scHAG::P64 = R2;
           _scHC2::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLe5; else goto ccLe6;
       ccLe6: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccLe8; else goto ccLe7;
       ccLe8: // global
           HpAlloc = 72;
           goto ccLe5;
       ccLe5: // global
           R2 = _scHAG::P64;
           R1 = _scHC2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLe7: // global
           _scHAq::P64 = P64[_scHC2::P64 + 7];
           _scHAu::P64 = P64[_scHC2::P64 + 15];
           _scHAw::P64 = P64[_scHC2::P64 + 23];
           _scHAy::P64 = P64[_scHC2::P64 + 31];
           _scHAA::P64 = P64[_scHC2::P64 + 39];
           _scHAC::P64 = P64[_scHC2::P64 + 47];
           _scHAE::P64 = P64[_scHC2::P64 + 55];
           I64[Hp - 64] = sat_scHBZ_info;
           P64[Hp - 56] = _scHAq::P64;
           P64[Hp - 48] = _scHAu::P64;
           P64[Hp - 40] = _scHAw::P64;
           P64[Hp - 32] = _scHAy::P64;
           P64[Hp - 24] = _scHAA::P64;
           P64[Hp - 16] = _scHAC::P64;
           P64[Hp - 8] = _scHAE::P64;
           P64[Hp] = _scHAG::P64;
           I64[Sp - 8] = block_ccLe1_info;
           R3 = Hp - 63;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLe1() //  [R1]
         { info_tbl: [(ccLe1,
                       label: block_ccLe1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLe1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLeb; else goto ccLea;
       ccLeb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLea: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgA_srtd" {
     ucLgA_srtd:
         const ScI2G_srt+104;
         const 47;
         const 140733193388409;
 },
 sat_scHC3_entry() //  [R1, R2]
         { info_tbl: [(ccLec,
                       label: sat_scHC3_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLec: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccLeg; else goto ccLef;
       ccLeg: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLef: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           _scHAE::P64 = P64[R1 + 55];
           I64[Hp - 56] = sat_scHC2_info;
           P64[Hp - 48] = _scHAq::P64;
           P64[Hp - 40] = _scHAu::P64;
           P64[Hp - 32] = _scHAw::P64;
           P64[Hp - 24] = _scHAy::P64;
           P64[Hp - 16] = _scHAA::P64;
           P64[Hp - 8] = _scHAC::P64;
           P64[Hp] = _scHAE::P64;
           R5 = Hp - 55;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl84_rcHr4_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgB_srtd" {
     ucLgB_srtd:
         const ScI2G_srt+104;
         const 47;
         const 140733193388409;
 },
 sat_scHC6_entry() //  [R1, R2]
         { info_tbl: [(ccLek,
                       label: sat_scHC6_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLek: // global
           _scHAE::P64 = R2;
           _scHC6::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLel; else goto ccLem;
       ccLem: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccLeo; else goto ccLen;
       ccLeo: // global
           HpAlloc = 64;
           goto ccLel;
       ccLel: // global
           R2 = _scHAE::P64;
           R1 = _scHC6::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLen: // global
           _scHAq::P64 = P64[_scHC6::P64 + 7];
           _scHAu::P64 = P64[_scHC6::P64 + 15];
           _scHAw::P64 = P64[_scHC6::P64 + 23];
           _scHAy::P64 = P64[_scHC6::P64 + 31];
           _scHAA::P64 = P64[_scHC6::P64 + 39];
           _scHAC::P64 = P64[_scHC6::P64 + 47];
           I64[Hp - 56] = sat_scHC3_info;
           P64[Hp - 48] = _scHAq::P64;
           P64[Hp - 40] = _scHAu::P64;
           P64[Hp - 32] = _scHAw::P64;
           P64[Hp - 24] = _scHAy::P64;
           P64[Hp - 16] = _scHAA::P64;
           P64[Hp - 8] = _scHAC::P64;
           P64[Hp] = _scHAE::P64;
           I64[Sp - 8] = block_ccLeh_info;
           R3 = Hp - 55;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLeh() //  [R1]
         { info_tbl: [(ccLeh,
                       label: block_ccLeh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLeh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLer; else goto ccLeq;
       ccLer: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLeq: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgC_srtd" {
     ucLgC_srtd:
         const ScI2G_srt+104;
         const 48;
         const 281470681743737;
 },
 sat_scHC7_entry() //  [R1, R2]
         { info_tbl: [(ccLes,
                       label: sat_scHC7_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLes: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccLew; else goto ccLev;
       ccLew: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLev: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           _scHAC::P64 = P64[R1 + 47];
           I64[Hp - 48] = sat_scHC6_info;
           P64[Hp - 40] = _scHAq::P64;
           P64[Hp - 32] = _scHAu::P64;
           P64[Hp - 24] = _scHAw::P64;
           P64[Hp - 16] = _scHAy::P64;
           P64[Hp - 8] = _scHAA::P64;
           P64[Hp] = _scHAC::P64;
           R5 = Hp - 47;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl82_rcHr2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgD_srtd" {
     ucLgD_srtd:
         const ScI2G_srt+104;
         const 48;
         const 281470681743737;
 },
 sat_scHCa_entry() //  [R1, R2]
         { info_tbl: [(ccLeA,
                       label: sat_scHCa_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLeA: // global
           _scHAC::P64 = R2;
           _scHCa::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLeB; else goto ccLeC;
       ccLeC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccLeE; else goto ccLeD;
       ccLeE: // global
           HpAlloc = 56;
           goto ccLeB;
       ccLeB: // global
           R2 = _scHAC::P64;
           R1 = _scHCa::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLeD: // global
           _scHAq::P64 = P64[_scHCa::P64 + 7];
           _scHAu::P64 = P64[_scHCa::P64 + 15];
           _scHAw::P64 = P64[_scHCa::P64 + 23];
           _scHAy::P64 = P64[_scHCa::P64 + 31];
           _scHAA::P64 = P64[_scHCa::P64 + 39];
           I64[Hp - 48] = sat_scHC7_info;
           P64[Hp - 40] = _scHAq::P64;
           P64[Hp - 32] = _scHAu::P64;
           P64[Hp - 24] = _scHAw::P64;
           P64[Hp - 16] = _scHAy::P64;
           P64[Hp - 8] = _scHAA::P64;
           P64[Hp] = _scHAC::P64;
           I64[Sp - 8] = block_ccLex_info;
           R3 = Hp - 47;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLex() //  [R1]
         { info_tbl: [(ccLex,
                       label: block_ccLex_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLex: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLeH; else goto ccLeG;
       ccLeH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLeG: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgE_srtd" {
     ucLgE_srtd:
         const ScI2G_srt+104;
         const 49;
         const 562945658454393;
 },
 sat_scHCb_entry() //  [R1, R2]
         { info_tbl: [(ccLeI,
                       label: sat_scHCb_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLeI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccLeM; else goto ccLeL;
       ccLeM: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLeL: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           _scHAA::P64 = P64[R1 + 39];
           I64[Hp - 40] = sat_scHCa_info;
           P64[Hp - 32] = _scHAq::P64;
           P64[Hp - 24] = _scHAu::P64;
           P64[Hp - 16] = _scHAw::P64;
           P64[Hp - 8] = _scHAy::P64;
           P64[Hp] = _scHAA::P64;
           R5 = Hp - 39;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl80_rcHr0_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgF_srtd" {
     ucLgF_srtd:
         const ScI2G_srt+104;
         const 49;
         const 562945658454393;
 },
 sat_scHCe_entry() //  [R1, R2]
         { info_tbl: [(ccLeQ,
                       label: sat_scHCe_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLeQ: // global
           _scHAA::P64 = R2;
           _scHCe::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLeR; else goto ccLeS;
       ccLeS: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccLeU; else goto ccLeT;
       ccLeU: // global
           HpAlloc = 48;
           goto ccLeR;
       ccLeR: // global
           R2 = _scHAA::P64;
           R1 = _scHCe::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLeT: // global
           _scHAq::P64 = P64[_scHCe::P64 + 7];
           _scHAu::P64 = P64[_scHCe::P64 + 15];
           _scHAw::P64 = P64[_scHCe::P64 + 23];
           _scHAy::P64 = P64[_scHCe::P64 + 31];
           I64[Hp - 40] = sat_scHCb_info;
           P64[Hp - 32] = _scHAq::P64;
           P64[Hp - 24] = _scHAu::P64;
           P64[Hp - 16] = _scHAw::P64;
           P64[Hp - 8] = _scHAy::P64;
           P64[Hp] = _scHAA::P64;
           I64[Sp - 8] = block_ccLeN_info;
           R3 = Hp - 39;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLeN() //  [R1]
         { info_tbl: [(ccLeN,
                       label: block_ccLeN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLeN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLeX; else goto ccLeW;
       ccLeX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLeW: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgG_srtd" {
     ucLgG_srtd:
         const ScI2G_srt+104;
         const 50;
         const 1125895611875705;
 },
 sat_scHCf_entry() //  [R1, R2]
         { info_tbl: [(ccLeY,
                       label: sat_scHCf_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLeY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccLf2; else goto ccLf1;
       ccLf2: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLf1: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           _scHAy::P64 = P64[R1 + 31];
           I64[Hp - 32] = sat_scHCe_info;
           P64[Hp - 24] = _scHAq::P64;
           P64[Hp - 16] = _scHAu::P64;
           P64[Hp - 8] = _scHAw::P64;
           P64[Hp] = _scHAy::P64;
           R5 = Hp - 31;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl78_rcHqY_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgH_srtd" {
     ucLgH_srtd:
         const ScI2G_srt+104;
         const 50;
         const 1125895611875705;
 },
 sat_scHCi_entry() //  [R1, R2]
         { info_tbl: [(ccLf6,
                       label: sat_scHCi_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLf6: // global
           _scHAy::P64 = R2;
           _scHCi::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLf7; else goto ccLf8;
       ccLf8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccLfa; else goto ccLf9;
       ccLfa: // global
           HpAlloc = 40;
           goto ccLf7;
       ccLf7: // global
           R2 = _scHAy::P64;
           R1 = _scHCi::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLf9: // global
           _scHAq::P64 = P64[_scHCi::P64 + 7];
           _scHAu::P64 = P64[_scHCi::P64 + 15];
           _scHAw::P64 = P64[_scHCi::P64 + 23];
           I64[Hp - 32] = sat_scHCf_info;
           P64[Hp - 24] = _scHAq::P64;
           P64[Hp - 16] = _scHAu::P64;
           P64[Hp - 8] = _scHAw::P64;
           P64[Hp] = _scHAy::P64;
           I64[Sp - 8] = block_ccLf3_info;
           R3 = Hp - 31;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLf3() //  [R1]
         { info_tbl: [(ccLf3,
                       label: block_ccLf3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLf3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLfd; else goto ccLfc;
       ccLfd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLfc: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgI_srtd" {
     ucLgI_srtd:
         const ScI2G_srt+104;
         const 51;
         const 2251795518718329;
 },
 sat_scHCj_entry() //  [R1, R2]
         { info_tbl: [(ccLfe,
                       label: sat_scHCj_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLfe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccLfi; else goto ccLfh;
       ccLfi: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLfh: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           _scHAw::P64 = P64[R1 + 23];
           I64[Hp - 24] = sat_scHCi_info;
           P64[Hp - 16] = _scHAq::P64;
           P64[Hp - 8] = _scHAu::P64;
           P64[Hp] = _scHAw::P64;
           R5 = Hp - 23;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl76_rcHqW_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgJ_srtd" {
     ucLgJ_srtd:
         const ScI2G_srt+104;
         const 51;
         const 2251795518718329;
 },
 sat_scHCm_entry() //  [R1, R2]
         { info_tbl: [(ccLfm,
                       label: sat_scHCm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLfm: // global
           _scHAw::P64 = R2;
           _scHCm::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLfn; else goto ccLfo;
       ccLfo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccLfq; else goto ccLfp;
       ccLfq: // global
           HpAlloc = 32;
           goto ccLfn;
       ccLfn: // global
           R2 = _scHAw::P64;
           R1 = _scHCm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLfp: // global
           _scHAq::P64 = P64[_scHCm::P64 + 7];
           _scHAu::P64 = P64[_scHCm::P64 + 15];
           I64[Hp - 24] = sat_scHCj_info;
           P64[Hp - 16] = _scHAq::P64;
           P64[Hp - 8] = _scHAu::P64;
           P64[Hp] = _scHAw::P64;
           I64[Sp - 8] = block_ccLfj_info;
           R3 = Hp - 23;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLfj() //  [R1]
         { info_tbl: [(ccLfj,
                       label: block_ccLfj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLfj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLft; else goto ccLfs;
       ccLft: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLfs: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgK_srtd" {
     ucLgK_srtd:
         const ScI2G_srt+80;
         const 55;
         const 36028762659228617;
 },
 sat_scHCn_entry() //  [R1, R2]
         { info_tbl: [(ccLfu,
                       label: sat_scHCn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLfu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccLfy; else goto ccLfx;
       ccLfy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLfx: // global
           _scHAq::P64 = P64[R1 + 7];
           _scHAu::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_scHCm_info;
           P64[Hp - 8] = _scHAq::P64;
           P64[Hp] = _scHAu::P64;
           R5 = Hp - 15;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = lvl74_rcHqU_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgL_srtd" {
     ucLgL_srtd:
         const ScI2G_srt+80;
         const 55;
         const 36028762659228617;
 },
 sat_scHCq_entry() //  [R1, R2]
         { info_tbl: [(ccLfC,
                       label: sat_scHCq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLfC: // global
           _scHAu::P64 = R2;
           _scHCq::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLfD; else goto ccLfE;
       ccLfE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccLfG; else goto ccLfF;
       ccLfG: // global
           HpAlloc = 24;
           goto ccLfD;
       ccLfD: // global
           R2 = _scHAu::P64;
           R1 = _scHCq::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLfF: // global
           _scHAq::P64 = P64[_scHCq::P64 + 7];
           I64[Hp - 16] = sat_scHCn_info;
           P64[Hp - 8] = _scHAq::P64;
           P64[Hp] = _scHAu::P64;
           I64[Sp - 8] = block_ccLfz_info;
           R3 = Hp - 15;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLfz() //  [R1]
         { info_tbl: [(ccLfz,
                       label: block_ccLfz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLfz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLfJ; else goto ccLfI;
       ccLfJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLfI: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgM_srtd" {
     ucLgM_srtd:
         const ScI2G_srt+80;
         const 56;
         const 72057559678192585;
 },
 sat_scHCr_entry() //  [R1, R2]
         { info_tbl: [(ccLfK,
                       label: sat_scHCr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLfK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLfO; else goto ccLfN;
       ccLfO: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLfN: // global
           _scHAq::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_scHCq_info;
           P64[Hp] = _scHAq::P64;
           R5 = Hp - 7;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = ds4_rcHqS_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgN_srtd" {
     ucLgN_srtd:
         const ScI2G_srt+80;
         const 56;
         const 72057559711747017;
 },
 sat_scHCu_entry() //  [R1, R2]
         { info_tbl: [(ccLfS,
                       label: sat_scHCu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLfS: // global
           _scHAs::P64 = R2;
           _scHCu::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLfT; else goto ccLfU;
       ccLfU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLfW; else goto ccLfV;
       ccLfW: // global
           HpAlloc = 16;
           goto ccLfT;
       ccLfT: // global
           R2 = _scHAs::P64;
           R1 = _scHCu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLfV: // global
           _scHAq::P64 = P64[_scHCu::P64 + 7];
           I64[Hp - 8] = sat_scHCr_info;
           P64[Hp] = _scHAq::P64;
           I64[Sp - 8] = block_ccLfP_info;
           R3 = Hp - 7;
           R2 = lexeme4_rcHqa_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLfP() //  [R1]
         { info_tbl: [(ccLfP,
                       label: block_ccLfP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLfP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLfZ; else goto ccLfY;
       ccLfZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLfY: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucLgO_srtd" {
     ucLgO_srtd:
         const ScI2G_srt+80;
         const 58;
         const 288230341825530825;
 },
 GHC.Stats.$w$creadPrec1_entry() //  [R2, R3]
         { info_tbl: [(ccLg3,
                       label: GHC.Stats.$w$creadPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLg3: // global
           _scHAq::P64 = R3;
           _scHAp::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccLg4; else goto ccLg5;
       ccLg5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLg7; else goto ccLg6;
       ccLg7: // global
           HpAlloc = 16;
           goto ccLg4;
       ccLg4: // global
           R3 = _scHAq::P64;
           R2 = _scHAp::I64;
           R1 = GHC.Stats.$w$creadPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccLg6: // global
           if (%MO_S_Gt_W64(_scHAp::I64, 11)) goto ccLg1; else goto ccLg2;
       ccLg1: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccLg2: // global
           I64[Hp - 8] = sat_scHCu_info;
           P64[Hp] = _scHAq::P64;
           I64[Sp - 8] = block_ccLg8_info;
           R3 = Hp - 7;
           R2 = lexeme6_rcHqQ_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccLg8() //  [R1]
         { info_tbl: [(ccLg8,
                       label: block_ccLg8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLg8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccLgd; else goto ccLgc;
       ccLgd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccLgc: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.052809279 UTC

[section ""data" . GHC.Stats.$fReadRTSStats2_closure" {
     GHC.Stats.$fReadRTSStats2_closure:
         const GHC.Stats.$fReadRTSStats2_info;
         const 0;
 },
 GHC.Stats.$fReadRTSStats2_entry() //  [R2, R3]
         { info_tbl: [(ccLlq,
                       label: GHC.Stats.$fReadRTSStats2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLlq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccLlr; else goto ccLls;
       ccLlr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fReadRTSStats2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccLls: // global
           I64[Sp - 16] = block_ccLln_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucLlw; else goto ccLlo;
       ucLlw: // global
           call _ccLln(R1) args: 0, res: 0, upd: 0;
       ccLlo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLln() //  [R1]
         { info_tbl: [(ccLln,
                       label: block_ccLln_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLln: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Stats.$w$creadPrec1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.0596244 UTC

[section ""data" . GHC.Stats.$fReadRTSStats1_closure" {
     GHC.Stats.$fReadRTSStats1_closure:
         const GHC.Stats.$fReadRTSStats1_info;
         const 0;
 },
 GHC.Stats.$fReadRTSStats1_entry() //  [R2, R3]
         { info_tbl: [(ccLlK,
                       label: GHC.Stats.$fReadRTSStats1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLlK: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fReadRTSStats2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.063471119 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_$creadsPrec_closure" {
     GHC.Stats.$fReadRTSStats_$creadsPrec_closure:
         const GHC.Stats.$fReadRTSStats_$creadsPrec_info;
         const 0;
 },
 sat_scHCC_entry() //  [R1]
         { info_tbl: [(ccLlZ,
                       label: sat_scHCC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLlZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccLm0; else goto ccLm1;
       ccLm0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccLm1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Stats.$fReadRTSStats2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stats.$fReadRTSStats_$creadsPrec_entry() //  [R2]
         { info_tbl: [(ccLm2,
                       label: GHC.Stats.$fReadRTSStats_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLm2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccLm6; else goto ccLm5;
       ccLm6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stats.$fReadRTSStats_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLm5: // global
           I64[Hp - 16] = sat_scHCC_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.069518184 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_$creadListPrec_closure" {
     GHC.Stats.$fReadRTSStats_$creadListPrec_closure:
         const GHC.Stats.$fReadRTSStats_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadRTSStats_$creadListPrec_entry() //  [R1]
         { info_tbl: [(ccLml,
                       label: GHC.Stats.$fReadRTSStats_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLml: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccLmm; else goto ccLmn;
       ccLmm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccLmn: // global
           (_ccLmi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccLmi::I64 == 0) goto ccLmk; else goto ccLmj;
       ccLmk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccLmj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccLmi::I64;
           R2 = GHC.Stats.$fReadRTSStats1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.074228482 UTC

[section ""data" . GHC.Stats.$fReadRTSStats3_closure" {
     GHC.Stats.$fReadRTSStats3_closure:
         const GHC.Stats.$fReadRTSStats3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadRTSStats3_entry() //  [R1]
         { info_tbl: [(ccLmB,
                       label: GHC.Stats.$fReadRTSStats3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLmB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccLmC; else goto ccLmD;
       ccLmC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccLmD: // global
           (_ccLmy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccLmy::I64 == 0) goto ccLmA; else goto ccLmz;
       ccLmA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccLmz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccLmy::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.Stats.$fReadRTSStats_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.078466241 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_$creadList_closure" {
     GHC.Stats.$fReadRTSStats_$creadList_closure:
         const GHC.Stats.$fReadRTSStats_$creadList_info;
         const 0;
 },
 GHC.Stats.$fReadRTSStats_$creadList_entry() //  [R2]
         { info_tbl: [(ccLmP,
                       label: GHC.Stats.$fReadRTSStats_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLmP: // global
           R3 = R2;
           R2 = GHC.Stats.$fReadRTSStats3_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.081965633 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_closure" {
     GHC.Stats.$fReadRTSStats_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Stats.$fReadRTSStats_$creadsPrec_closure+1;
         const GHC.Stats.$fReadRTSStats_$creadList_closure+1;
         const GHC.Stats.$fReadRTSStats1_closure+2;
         const GHC.Stats.$fReadRTSStats_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.084180156 UTC

[section ""data" . GHC.Stats.gcdetails_elapsed_ns_closure" {
     GHC.Stats.gcdetails_elapsed_ns_closure:
         const GHC.Stats.gcdetails_elapsed_ns_info;
 },
 GHC.Stats.gcdetails_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccLn4,
                       label: GHC.Stats.gcdetails_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLn4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLn5; else goto ccLn6;
       ccLn5: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLn6: // global
           I64[Sp - 8] = block_ccLn1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLna; else goto ccLn2;
       ucLna: // global
           call _ccLn1(R1) args: 0, res: 0, upd: 0;
       ccLn2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLn1() //  [R1]
         { info_tbl: [(ccLn1,
                       label: block_ccLn1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLn1: // global
           R1 = P64[R1 + 111] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.090770138 UTC

[section ""data" . GHC.Stats.gcdetails_cpu_ns_closure" {
     GHC.Stats.gcdetails_cpu_ns_closure:
         const GHC.Stats.gcdetails_cpu_ns_info;
 },
 GHC.Stats.gcdetails_cpu_ns_entry() //  [R2]
         { info_tbl: [(ccLnt,
                       label: GHC.Stats.gcdetails_cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLnt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLnu; else goto ccLnv;
       ccLnu: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLnv: // global
           I64[Sp - 8] = block_ccLnq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLnz; else goto ccLnr;
       ucLnz: // global
           call _ccLnq(R1) args: 0, res: 0, upd: 0;
       ccLnr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLnq() //  [R1]
         { info_tbl: [(ccLnq,
                       label: block_ccLnq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLnq: // global
           R1 = P64[R1 + 103] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.096905838 UTC

[section ""data" . GHC.Stats.gcdetails_sync_elapsed_ns_closure" {
     GHC.Stats.gcdetails_sync_elapsed_ns_closure:
         const GHC.Stats.gcdetails_sync_elapsed_ns_info;
 },
 GHC.Stats.gcdetails_sync_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccLnS,
                       label: GHC.Stats.gcdetails_sync_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLnS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLnT; else goto ccLnU;
       ccLnT: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_sync_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLnU: // global
           I64[Sp - 8] = block_ccLnP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLnY; else goto ccLnQ;
       ucLnY: // global
           call _ccLnP(R1) args: 0, res: 0, upd: 0;
       ccLnQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLnP() //  [R1]
         { info_tbl: [(ccLnP,
                       label: block_ccLnP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLnP: // global
           R1 = P64[R1 + 95] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.102501423 UTC

[section ""data" . GHC.Stats.gcdetails_par_balanced_copied_bytes_closure" {
     GHC.Stats.gcdetails_par_balanced_copied_bytes_closure:
         const GHC.Stats.gcdetails_par_balanced_copied_bytes_info;
 },
 GHC.Stats.gcdetails_par_balanced_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccLoh,
                       label: GHC.Stats.gcdetails_par_balanced_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLoh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLoi; else goto ccLoj;
       ccLoi: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_par_balanced_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLoj: // global
           I64[Sp - 8] = block_ccLoe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLon; else goto ccLof;
       ucLon: // global
           call _ccLoe(R1) args: 0, res: 0, upd: 0;
       ccLof: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLoe() //  [R1]
         { info_tbl: [(ccLoe,
                       label: block_ccLoe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLoe: // global
           R1 = P64[R1 + 87] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.108168213 UTC

[section ""data" . GHC.Stats.gcdetails_par_max_copied_bytes_closure" {
     GHC.Stats.gcdetails_par_max_copied_bytes_closure:
         const GHC.Stats.gcdetails_par_max_copied_bytes_info;
 },
 GHC.Stats.gcdetails_par_max_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccLoG,
                       label: GHC.Stats.gcdetails_par_max_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLoG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLoH; else goto ccLoI;
       ccLoH: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_par_max_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLoI: // global
           I64[Sp - 8] = block_ccLoD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLoM; else goto ccLoE;
       ucLoM: // global
           call _ccLoD(R1) args: 0, res: 0, upd: 0;
       ccLoE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLoD() //  [R1]
         { info_tbl: [(ccLoD,
                       label: block_ccLoD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLoD: // global
           R1 = P64[R1 + 79] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.114205952 UTC

[section ""data" . GHC.Stats.gcdetails_copied_bytes_closure" {
     GHC.Stats.gcdetails_copied_bytes_closure:
         const GHC.Stats.gcdetails_copied_bytes_info;
 },
 GHC.Stats.gcdetails_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccLp5,
                       label: GHC.Stats.gcdetails_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLp5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLp6; else goto ccLp7;
       ccLp6: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLp7: // global
           I64[Sp - 8] = block_ccLp2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLpb; else goto ccLp3;
       ucLpb: // global
           call _ccLp2(R1) args: 0, res: 0, upd: 0;
       ccLp3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLp2() //  [R1]
         { info_tbl: [(ccLp2,
                       label: block_ccLp2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLp2: // global
           R1 = P64[R1 + 71] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.120413687 UTC

[section ""data" . GHC.Stats.gcdetails_mem_in_use_bytes_closure" {
     GHC.Stats.gcdetails_mem_in_use_bytes_closure:
         const GHC.Stats.gcdetails_mem_in_use_bytes_info;
 },
 GHC.Stats.gcdetails_mem_in_use_bytes_entry() //  [R2]
         { info_tbl: [(ccLpu,
                       label: GHC.Stats.gcdetails_mem_in_use_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLpu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLpv; else goto ccLpw;
       ccLpv: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_mem_in_use_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLpw: // global
           I64[Sp - 8] = block_ccLpr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLpA; else goto ccLps;
       ucLpA: // global
           call _ccLpr(R1) args: 0, res: 0, upd: 0;
       ccLps: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLpr() //  [R1]
         { info_tbl: [(ccLpr,
                       label: block_ccLpr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLpr: // global
           R1 = P64[R1 + 63] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.126153335 UTC

[section ""data" . GHC.Stats.gcdetails_slop_bytes_closure" {
     GHC.Stats.gcdetails_slop_bytes_closure:
         const GHC.Stats.gcdetails_slop_bytes_info;
 },
 GHC.Stats.gcdetails_slop_bytes_entry() //  [R2]
         { info_tbl: [(ccLpT,
                       label: GHC.Stats.gcdetails_slop_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLpT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLpU; else goto ccLpV;
       ccLpU: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_slop_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLpV: // global
           I64[Sp - 8] = block_ccLpQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLpZ; else goto ccLpR;
       ucLpZ: // global
           call _ccLpQ(R1) args: 0, res: 0, upd: 0;
       ccLpR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLpQ() //  [R1]
         { info_tbl: [(ccLpQ,
                       label: block_ccLpQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLpQ: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.131595384 UTC

[section ""data" . GHC.Stats.gcdetails_compact_bytes_closure" {
     GHC.Stats.gcdetails_compact_bytes_closure:
         const GHC.Stats.gcdetails_compact_bytes_info;
 },
 GHC.Stats.gcdetails_compact_bytes_entry() //  [R2]
         { info_tbl: [(ccLqi,
                       label: GHC.Stats.gcdetails_compact_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLqi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLqj; else goto ccLqk;
       ccLqj: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_compact_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLqk: // global
           I64[Sp - 8] = block_ccLqf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLqo; else goto ccLqg;
       ucLqo: // global
           call _ccLqf(R1) args: 0, res: 0, upd: 0;
       ccLqg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLqf() //  [R1]
         { info_tbl: [(ccLqf,
                       label: block_ccLqf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLqf: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.137141219 UTC

[section ""data" . GHC.Stats.gcdetails_large_objects_bytes_closure" {
     GHC.Stats.gcdetails_large_objects_bytes_closure:
         const GHC.Stats.gcdetails_large_objects_bytes_info;
 },
 GHC.Stats.gcdetails_large_objects_bytes_entry() //  [R2]
         { info_tbl: [(ccLqH,
                       label: GHC.Stats.gcdetails_large_objects_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLqH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLqI; else goto ccLqJ;
       ccLqI: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_large_objects_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLqJ: // global
           I64[Sp - 8] = block_ccLqE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLqN; else goto ccLqF;
       ucLqN: // global
           call _ccLqE(R1) args: 0, res: 0, upd: 0;
       ccLqF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLqE() //  [R1]
         { info_tbl: [(ccLqE,
                       label: block_ccLqE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLqE: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.142978194 UTC

[section ""data" . GHC.Stats.gcdetails_live_bytes_closure" {
     GHC.Stats.gcdetails_live_bytes_closure:
         const GHC.Stats.gcdetails_live_bytes_info;
 },
 GHC.Stats.gcdetails_live_bytes_entry() //  [R2]
         { info_tbl: [(ccLr6,
                       label: GHC.Stats.gcdetails_live_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLr6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLr7; else goto ccLr8;
       ccLr7: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_live_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLr8: // global
           I64[Sp - 8] = block_ccLr3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLrc; else goto ccLr4;
       ucLrc: // global
           call _ccLr3(R1) args: 0, res: 0, upd: 0;
       ccLr4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLr3() //  [R1]
         { info_tbl: [(ccLr3,
                       label: block_ccLr3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLr3: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.149307424 UTC

[section ""data" . GHC.Stats.gcdetails_allocated_bytes_closure" {
     GHC.Stats.gcdetails_allocated_bytes_closure:
         const GHC.Stats.gcdetails_allocated_bytes_info;
 },
 GHC.Stats.gcdetails_allocated_bytes_entry() //  [R2]
         { info_tbl: [(ccLrv,
                       label: GHC.Stats.gcdetails_allocated_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLrv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLrw; else goto ccLrx;
       ccLrw: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_allocated_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLrx: // global
           I64[Sp - 8] = block_ccLrs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLrB; else goto ccLrt;
       ucLrB: // global
           call _ccLrs(R1) args: 0, res: 0, upd: 0;
       ccLrt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLrs() //  [R1]
         { info_tbl: [(ccLrs,
                       label: block_ccLrs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLrs: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.154967649 UTC

[section ""data" . GHC.Stats.gcdetails_threads_closure" {
     GHC.Stats.gcdetails_threads_closure:
         const GHC.Stats.gcdetails_threads_info;
 },
 GHC.Stats.gcdetails_threads_entry() //  [R2]
         { info_tbl: [(ccLrU,
                       label: GHC.Stats.gcdetails_threads_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLrU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLrV; else goto ccLrW;
       ccLrV: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_threads_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLrW: // global
           I64[Sp - 8] = block_ccLrR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLs0; else goto ccLrS;
       ucLs0: // global
           call _ccLrR(R1) args: 0, res: 0, upd: 0;
       ccLrS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLrR() //  [R1]
         { info_tbl: [(ccLrR,
                       label: block_ccLrR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLrR: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.160352253 UTC

[section ""data" . GHC.Stats.gcdetails_gen_closure" {
     GHC.Stats.gcdetails_gen_closure:
         const GHC.Stats.gcdetails_gen_info;
 },
 GHC.Stats.gcdetails_gen_entry() //  [R2]
         { info_tbl: [(ccLsj,
                       label: GHC.Stats.gcdetails_gen_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLsj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLsk; else goto ccLsl;
       ccLsk: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_gen_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLsl: // global
           I64[Sp - 8] = block_ccLsg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLsp; else goto ccLsh;
       ucLsp: // global
           call _ccLsg(R1) args: 0, res: 0, upd: 0;
       ccLsh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLsg() //  [R1]
         { info_tbl: [(ccLsg,
                       label: block_ccLsg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLsg: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.165831679 UTC

[section ""data" . GHC.Stats.gc_closure" {
     GHC.Stats.gc_closure:
         const GHC.Stats.gc_info;
 },
 GHC.Stats.gc_entry() //  [R2]
         { info_tbl: [(ccLsI,
                       label: GHC.Stats.gc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLsI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLsJ; else goto ccLsK;
       ccLsJ: // global
           R2 = R2;
           R1 = GHC.Stats.gc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLsK: // global
           I64[Sp - 8] = block_ccLsF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLsO; else goto ccLsG;
       ucLsO: // global
           call _ccLsF(R1) args: 0, res: 0, upd: 0;
       ccLsG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLsF() //  [R1]
         { info_tbl: [(ccLsF,
                       label: block_ccLsF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLsF: // global
           R1 = P64[R1 + 159] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.17161849 UTC

[section ""data" . GHC.Stats.elapsed_ns_closure" {
     GHC.Stats.elapsed_ns_closure:
         const GHC.Stats.elapsed_ns_info;
 },
 GHC.Stats.elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccLt7,
                       label: GHC.Stats.elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLt7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLt8; else goto ccLt9;
       ccLt8: // global
           R2 = R2;
           R1 = GHC.Stats.elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLt9: // global
           I64[Sp - 8] = block_ccLt4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLtd; else goto ccLt5;
       ucLtd: // global
           call _ccLt4(R1) args: 0, res: 0, upd: 0;
       ccLt5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLt4() //  [R1]
         { info_tbl: [(ccLt4,
                       label: block_ccLt4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLt4: // global
           R1 = P64[R1 + 151] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.177907514 UTC

[section ""data" . GHC.Stats.cpu_ns_closure" {
     GHC.Stats.cpu_ns_closure:
         const GHC.Stats.cpu_ns_info;
 },
 GHC.Stats.cpu_ns_entry() //  [R2]
         { info_tbl: [(ccLtw,
                       label: GHC.Stats.cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLtw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLtx; else goto ccLty;
       ccLtx: // global
           R2 = R2;
           R1 = GHC.Stats.cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLty: // global
           I64[Sp - 8] = block_ccLtt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLtC; else goto ccLtu;
       ucLtC: // global
           call _ccLtt(R1) args: 0, res: 0, upd: 0;
       ccLtu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLtt() //  [R1]
         { info_tbl: [(ccLtt,
                       label: block_ccLtt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLtt: // global
           R1 = P64[R1 + 143] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.183221532 UTC

[section ""data" . GHC.Stats.gc_elapsed_ns_closure" {
     GHC.Stats.gc_elapsed_ns_closure:
         const GHC.Stats.gc_elapsed_ns_info;
 },
 GHC.Stats.gc_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccLtV,
                       label: GHC.Stats.gc_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLtV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLtW; else goto ccLtX;
       ccLtW: // global
           R2 = R2;
           R1 = GHC.Stats.gc_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLtX: // global
           I64[Sp - 8] = block_ccLtS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLu1; else goto ccLtT;
       ucLu1: // global
           call _ccLtS(R1) args: 0, res: 0, upd: 0;
       ccLtT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLtS() //  [R1]
         { info_tbl: [(ccLtS,
                       label: block_ccLtS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLtS: // global
           R1 = P64[R1 + 135] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.188622359 UTC

[section ""data" . GHC.Stats.gc_cpu_ns_closure" {
     GHC.Stats.gc_cpu_ns_closure:
         const GHC.Stats.gc_cpu_ns_info;
 },
 GHC.Stats.gc_cpu_ns_entry() //  [R2]
         { info_tbl: [(ccLuk,
                       label: GHC.Stats.gc_cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLuk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLul; else goto ccLum;
       ccLul: // global
           R2 = R2;
           R1 = GHC.Stats.gc_cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLum: // global
           I64[Sp - 8] = block_ccLuh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLuq; else goto ccLui;
       ucLuq: // global
           call _ccLuh(R1) args: 0, res: 0, upd: 0;
       ccLui: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLuh() //  [R1]
         { info_tbl: [(ccLuh,
                       label: block_ccLuh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLuh: // global
           R1 = P64[R1 + 127] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.194406992 UTC

[section ""data" . GHC.Stats.mutator_elapsed_ns_closure" {
     GHC.Stats.mutator_elapsed_ns_closure:
         const GHC.Stats.mutator_elapsed_ns_info;
 },
 GHC.Stats.mutator_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccLuJ,
                       label: GHC.Stats.mutator_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLuJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLuK; else goto ccLuL;
       ccLuK: // global
           R2 = R2;
           R1 = GHC.Stats.mutator_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLuL: // global
           I64[Sp - 8] = block_ccLuG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLuP; else goto ccLuH;
       ucLuP: // global
           call _ccLuG(R1) args: 0, res: 0, upd: 0;
       ccLuH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLuG() //  [R1]
         { info_tbl: [(ccLuG,
                       label: block_ccLuG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLuG: // global
           R1 = P64[R1 + 119] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.199898225 UTC

[section ""data" . GHC.Stats.mutator_cpu_ns_closure" {
     GHC.Stats.mutator_cpu_ns_closure:
         const GHC.Stats.mutator_cpu_ns_info;
 },
 GHC.Stats.mutator_cpu_ns_entry() //  [R2]
         { info_tbl: [(ccLv8,
                       label: GHC.Stats.mutator_cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLv8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLv9; else goto ccLva;
       ccLv9: // global
           R2 = R2;
           R1 = GHC.Stats.mutator_cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLva: // global
           I64[Sp - 8] = block_ccLv5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLve; else goto ccLv6;
       ucLve: // global
           call _ccLv5(R1) args: 0, res: 0, upd: 0;
       ccLv6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLv5() //  [R1]
         { info_tbl: [(ccLv5,
                       label: block_ccLv5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLv5: // global
           R1 = P64[R1 + 111] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.206710823 UTC

[section ""data" . GHC.Stats.cumulative_par_balanced_copied_bytes_closure" {
     GHC.Stats.cumulative_par_balanced_copied_bytes_closure:
         const GHC.Stats.cumulative_par_balanced_copied_bytes_info;
 },
 GHC.Stats.cumulative_par_balanced_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccLvx,
                       label: GHC.Stats.cumulative_par_balanced_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLvx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLvy; else goto ccLvz;
       ccLvy: // global
           R2 = R2;
           R1 = GHC.Stats.cumulative_par_balanced_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLvz: // global
           I64[Sp - 8] = block_ccLvu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLvD; else goto ccLvv;
       ucLvD: // global
           call _ccLvu(R1) args: 0, res: 0, upd: 0;
       ccLvv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLvu() //  [R1]
         { info_tbl: [(ccLvu,
                       label: block_ccLvu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLvu: // global
           R1 = P64[R1 + 103] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.212198191 UTC

[section ""data" . GHC.Stats.cumulative_par_max_copied_bytes_closure" {
     GHC.Stats.cumulative_par_max_copied_bytes_closure:
         const GHC.Stats.cumulative_par_max_copied_bytes_info;
 },
 GHC.Stats.cumulative_par_max_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccLvW,
                       label: GHC.Stats.cumulative_par_max_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLvW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLvX; else goto ccLvY;
       ccLvX: // global
           R2 = R2;
           R1 = GHC.Stats.cumulative_par_max_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLvY: // global
           I64[Sp - 8] = block_ccLvT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLw2; else goto ccLvU;
       ucLw2: // global
           call _ccLvT(R1) args: 0, res: 0, upd: 0;
       ccLvU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLvT() //  [R1]
         { info_tbl: [(ccLvT,
                       label: block_ccLvT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLvT: // global
           R1 = P64[R1 + 95] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.218014387 UTC

[section ""data" . GHC.Stats.par_copied_bytes_closure" {
     GHC.Stats.par_copied_bytes_closure:
         const GHC.Stats.par_copied_bytes_info;
 },
 GHC.Stats.par_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccLwl,
                       label: GHC.Stats.par_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLwl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLwm; else goto ccLwn;
       ccLwm: // global
           R2 = R2;
           R1 = GHC.Stats.par_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLwn: // global
           I64[Sp - 8] = block_ccLwi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLwr; else goto ccLwj;
       ucLwr: // global
           call _ccLwi(R1) args: 0, res: 0, upd: 0;
       ccLwj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLwi() //  [R1]
         { info_tbl: [(ccLwi,
                       label: block_ccLwi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLwi: // global
           R1 = P64[R1 + 87] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.223474706 UTC

[section ""data" . GHC.Stats.copied_bytes_closure" {
     GHC.Stats.copied_bytes_closure:
         const GHC.Stats.copied_bytes_info;
 },
 GHC.Stats.copied_bytes_entry() //  [R2]
         { info_tbl: [(ccLwK,
                       label: GHC.Stats.copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLwK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLwL; else goto ccLwM;
       ccLwL: // global
           R2 = R2;
           R1 = GHC.Stats.copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLwM: // global
           I64[Sp - 8] = block_ccLwH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLwQ; else goto ccLwI;
       ucLwQ: // global
           call _ccLwH(R1) args: 0, res: 0, upd: 0;
       ccLwI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLwH() //  [R1]
         { info_tbl: [(ccLwH,
                       label: block_ccLwH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLwH: // global
           R1 = P64[R1 + 79] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.229064155 UTC

[section ""data" . GHC.Stats.cumulative_live_bytes_closure" {
     GHC.Stats.cumulative_live_bytes_closure:
         const GHC.Stats.cumulative_live_bytes_info;
 },
 GHC.Stats.cumulative_live_bytes_entry() //  [R2]
         { info_tbl: [(ccLx9,
                       label: GHC.Stats.cumulative_live_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLx9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLxa; else goto ccLxb;
       ccLxa: // global
           R2 = R2;
           R1 = GHC.Stats.cumulative_live_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLxb: // global
           I64[Sp - 8] = block_ccLx6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLxf; else goto ccLx7;
       ucLxf: // global
           call _ccLx6(R1) args: 0, res: 0, upd: 0;
       ccLx7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLx6() //  [R1]
         { info_tbl: [(ccLx6,
                       label: block_ccLx6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLx6: // global
           R1 = P64[R1 + 71] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.235643441 UTC

[section ""data" . GHC.Stats.max_mem_in_use_bytes_closure" {
     GHC.Stats.max_mem_in_use_bytes_closure:
         const GHC.Stats.max_mem_in_use_bytes_info;
 },
 GHC.Stats.max_mem_in_use_bytes_entry() //  [R2]
         { info_tbl: [(ccLxy,
                       label: GHC.Stats.max_mem_in_use_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLxy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLxz; else goto ccLxA;
       ccLxz: // global
           R2 = R2;
           R1 = GHC.Stats.max_mem_in_use_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLxA: // global
           I64[Sp - 8] = block_ccLxv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLxE; else goto ccLxw;
       ucLxE: // global
           call _ccLxv(R1) args: 0, res: 0, upd: 0;
       ccLxw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLxv() //  [R1]
         { info_tbl: [(ccLxv,
                       label: block_ccLxv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLxv: // global
           R1 = P64[R1 + 63] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.241448252 UTC

[section ""data" . GHC.Stats.max_slop_bytes_closure" {
     GHC.Stats.max_slop_bytes_closure:
         const GHC.Stats.max_slop_bytes_info;
 },
 GHC.Stats.max_slop_bytes_entry() //  [R2]
         { info_tbl: [(ccLxX,
                       label: GHC.Stats.max_slop_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLxX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLxY; else goto ccLxZ;
       ccLxY: // global
           R2 = R2;
           R1 = GHC.Stats.max_slop_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLxZ: // global
           I64[Sp - 8] = block_ccLxU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLy3; else goto ccLxV;
       ucLy3: // global
           call _ccLxU(R1) args: 0, res: 0, upd: 0;
       ccLxV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLxU() //  [R1]
         { info_tbl: [(ccLxU,
                       label: block_ccLxU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLxU: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.246918808 UTC

[section ""data" . GHC.Stats.max_compact_bytes_closure" {
     GHC.Stats.max_compact_bytes_closure:
         const GHC.Stats.max_compact_bytes_info;
 },
 GHC.Stats.max_compact_bytes_entry() //  [R2]
         { info_tbl: [(ccLym,
                       label: GHC.Stats.max_compact_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLym: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLyn; else goto ccLyo;
       ccLyn: // global
           R2 = R2;
           R1 = GHC.Stats.max_compact_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLyo: // global
           I64[Sp - 8] = block_ccLyj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLys; else goto ccLyk;
       ucLys: // global
           call _ccLyj(R1) args: 0, res: 0, upd: 0;
       ccLyk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLyj() //  [R1]
         { info_tbl: [(ccLyj,
                       label: block_ccLyj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLyj: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.252325794 UTC

[section ""data" . GHC.Stats.max_large_objects_bytes_closure" {
     GHC.Stats.max_large_objects_bytes_closure:
         const GHC.Stats.max_large_objects_bytes_info;
 },
 GHC.Stats.max_large_objects_bytes_entry() //  [R2]
         { info_tbl: [(ccLyL,
                       label: GHC.Stats.max_large_objects_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLyL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLyM; else goto ccLyN;
       ccLyM: // global
           R2 = R2;
           R1 = GHC.Stats.max_large_objects_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLyN: // global
           I64[Sp - 8] = block_ccLyI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLyR; else goto ccLyJ;
       ucLyR: // global
           call _ccLyI(R1) args: 0, res: 0, upd: 0;
       ccLyJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLyI() //  [R1]
         { info_tbl: [(ccLyI,
                       label: block_ccLyI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLyI: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.258175899 UTC

[section ""data" . GHC.Stats.max_live_bytes_closure" {
     GHC.Stats.max_live_bytes_closure:
         const GHC.Stats.max_live_bytes_info;
 },
 GHC.Stats.max_live_bytes_entry() //  [R2]
         { info_tbl: [(ccLza,
                       label: GHC.Stats.max_live_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLza: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLzb; else goto ccLzc;
       ccLzb: // global
           R2 = R2;
           R1 = GHC.Stats.max_live_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLzc: // global
           I64[Sp - 8] = block_ccLz7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLzg; else goto ccLz8;
       ucLzg: // global
           call _ccLz7(R1) args: 0, res: 0, upd: 0;
       ccLz8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLz7() //  [R1]
         { info_tbl: [(ccLz7,
                       label: block_ccLz7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLz7: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.264498831 UTC

[section ""data" . GHC.Stats.allocated_bytes_closure" {
     GHC.Stats.allocated_bytes_closure:
         const GHC.Stats.allocated_bytes_info;
 },
 GHC.Stats.allocated_bytes_entry() //  [R2]
         { info_tbl: [(ccLzz,
                       label: GHC.Stats.allocated_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLzz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLzA; else goto ccLzB;
       ccLzA: // global
           R2 = R2;
           R1 = GHC.Stats.allocated_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLzB: // global
           I64[Sp - 8] = block_ccLzw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLzF; else goto ccLzx;
       ucLzF: // global
           call _ccLzw(R1) args: 0, res: 0, upd: 0;
       ccLzx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLzw() //  [R1]
         { info_tbl: [(ccLzw,
                       label: block_ccLzw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLzw: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.270419599 UTC

[section ""data" . GHC.Stats.major_gcs_closure" {
     GHC.Stats.major_gcs_closure:
         const GHC.Stats.major_gcs_info;
 },
 GHC.Stats.major_gcs_entry() //  [R2]
         { info_tbl: [(ccLzY,
                       label: GHC.Stats.major_gcs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLzY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLzZ; else goto ccLA0;
       ccLzZ: // global
           R2 = R2;
           R1 = GHC.Stats.major_gcs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLA0: // global
           I64[Sp - 8] = block_ccLzV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLA4; else goto ccLzW;
       ucLA4: // global
           call _ccLzV(R1) args: 0, res: 0, upd: 0;
       ccLzW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLzV() //  [R1]
         { info_tbl: [(ccLzV,
                       label: block_ccLzV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLzV: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.275962118 UTC

[section ""data" . GHC.Stats.gcs_closure" {
     GHC.Stats.gcs_closure:
         const GHC.Stats.gcs_info;
 },
 GHC.Stats.gcs_entry() //  [R2]
         { info_tbl: [(ccLAn,
                       label: GHC.Stats.gcs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLAn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLAo; else goto ccLAp;
       ccLAo: // global
           R2 = R2;
           R1 = GHC.Stats.gcs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccLAp: // global
           I64[Sp - 8] = block_ccLAk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucLAt; else goto ccLAl;
       ucLAt: // global
           call _ccLAk(R1) args: 0, res: 0, upd: 0;
       ccLAl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLAk() //  [R1]
         { info_tbl: [(ccLAk,
                       label: block_ccLAk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLAk: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.281481519 UTC

[section ""cstring" . GHC.Stats.$trModule4_bytes" {
     GHC.Stats.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.283196128 UTC

[section ""data" . GHC.Stats.$trModule3_closure" {
     GHC.Stats.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.28498743 UTC

[section ""cstring" . GHC.Stats.$trModule2_bytes" {
     GHC.Stats.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.286793987 UTC

[section ""data" . GHC.Stats.$trModule1_closure" {
     GHC.Stats.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.28869435 UTC

[section ""data" . GHC.Stats.$trModule_closure" {
     GHC.Stats.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Stats.$trModule3_closure+1;
         const GHC.Stats.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.290959574 UTC

[section ""data" . $krep_rcHrw_closure" {
     $krep_rcHrw_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt64_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.293455255 UTC

[section ""data" . $krep1_rcHrx_closure" {
     $krep1_rcHrx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.295232242 UTC

[section ""data" . $krep2_rcHry_closure" {
     $krep2_rcHry_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord32_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.296962748 UTC

[section ""data" . GHC.Stats.$tcGCDetails1_closure" {
     GHC.Stats.$tcGCDetails1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tcGCDetails2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.298802805 UTC

[section ""data" . GHC.Stats.$tcGCDetails_closure" {
     GHC.Stats.$tcGCDetails_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tcGCDetails1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1853976479346877039;
         const 12435514499433877542;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.300609827 UTC

[section ""data" . $krep3_rcHrz_closure" {
     $krep3_rcHrz_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Stats.$tcGCDetails_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.302789972 UTC

[section ""data" . $krep4_rcHrA_closure" {
     $krep4_rcHrA_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep3_rcHrz_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.304636086 UTC

[section ""data" . $krep5_rcHrB_closure" {
     $krep5_rcHrB_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep4_rcHrA_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.306660191 UTC

[section ""data" . $krep6_rcHrC_closure" {
     $krep6_rcHrC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep5_rcHrB_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.308458044 UTC

[section ""data" . $krep7_rcHrD_closure" {
     $krep7_rcHrD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep6_rcHrC_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.31030554 UTC

[section ""data" . $krep8_rcHrE_closure" {
     $krep8_rcHrE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep7_rcHrD_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.312094664 UTC

[section ""data" . $krep9_rcHrF_closure" {
     $krep9_rcHrF_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep8_rcHrE_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.314268047 UTC

[section ""data" . $krep10_rcHrG_closure" {
     $krep10_rcHrG_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep9_rcHrF_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.316133526 UTC

[section ""data" . $krep11_rcHrH_closure" {
     $krep11_rcHrH_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep10_rcHrG_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.318697768 UTC

[section ""data" . $krep12_rcHrI_closure" {
     $krep12_rcHrI_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep11_rcHrH_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.320441561 UTC

[section ""data" . $krep13_rcHrJ_closure" {
     $krep13_rcHrJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep12_rcHrI_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.322312705 UTC

[section ""data" . $krep14_rcHrK_closure" {
     $krep14_rcHrK_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep13_rcHrJ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.324064628 UTC

[section ""data" . $krep15_rcHrL_closure" {
     $krep15_rcHrL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep14_rcHrK_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.326091835 UTC

[section ""data" . $krep16_rcHrM_closure" {
     $krep16_rcHrM_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep15_rcHrL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.327840703 UTC

[section ""data" . GHC.Stats.$tc'GCDetails1_closure" {
     GHC.Stats.$tc'GCDetails1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep16_rcHrM_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.329719921 UTC

[section ""cstring" . GHC.Stats.$tc'GCDetails3_bytes" {
     GHC.Stats.$tc'GCDetails3_bytes:
         I8[] [39,71,67,68,101,116,97,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.331477895 UTC

[section ""data" . GHC.Stats.$tc'GCDetails2_closure" {
     GHC.Stats.$tc'GCDetails2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tc'GCDetails3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.333208797 UTC

[section ""data" . GHC.Stats.$tc'GCDetails_closure" {
     GHC.Stats.$tc'GCDetails_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tc'GCDetails2_closure+1;
         const GHC.Stats.$tc'GCDetails1_closure+4;
         const 5964953867232766897;
         const 8889994537819840032;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.335163879 UTC

[section ""data" . GHC.Stats.$tcRTSStats1_closure" {
     GHC.Stats.$tcRTSStats1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tcRTSStats2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.336916699 UTC

[section ""data" . GHC.Stats.$tcRTSStats_closure" {
     GHC.Stats.$tcRTSStats_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tcRTSStats1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1006825398788898151;
         const 9122067856566178937;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.339009294 UTC

[section ""data" . $krep17_rcHrN_closure" {
     $krep17_rcHrN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Stats.$tcRTSStats_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.340859092 UTC

[section ""data" . $krep18_rcHrO_closure" {
     $krep18_rcHrO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rcHrz_closure+1;
         const $krep17_rcHrN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.342833582 UTC

[section ""data" . $krep19_rcHrP_closure" {
     $krep19_rcHrP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep18_rcHrO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.34530215 UTC

[section ""data" . $krep20_rcHrQ_closure" {
     $krep20_rcHrQ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep19_rcHrP_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.34708959 UTC

[section ""data" . $krep21_rcHrR_closure" {
     $krep21_rcHrR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep20_rcHrQ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.348829413 UTC

[section ""data" . $krep22_rcHrS_closure" {
     $krep22_rcHrS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep21_rcHrR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.351001517 UTC

[section ""data" . $krep23_rcHrT_closure" {
     $krep23_rcHrT_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep22_rcHrS_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.352825168 UTC

[section ""data" . $krep24_rcHrU_closure" {
     $krep24_rcHrU_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep23_rcHrT_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.354679473 UTC

[section ""data" . $krep25_rcHrV_closure" {
     $krep25_rcHrV_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep24_rcHrU_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.356584646 UTC

[section ""data" . $krep26_rcHrW_closure" {
     $krep26_rcHrW_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep25_rcHrV_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.358456189 UTC

[section ""data" . $krep27_rcHrX_closure" {
     $krep27_rcHrX_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep26_rcHrW_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.360304193 UTC

[section ""data" . $krep28_rcHrY_closure" {
     $krep28_rcHrY_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep27_rcHrX_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.3622178 UTC

[section ""data" . $krep29_rcHrZ_closure" {
     $krep29_rcHrZ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep28_rcHrY_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.363975127 UTC

[section ""data" . $krep30_rcHs0_closure" {
     $krep30_rcHs0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep29_rcHrZ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.366404933 UTC

[section ""data" . $krep31_rcHs1_closure" {
     $krep31_rcHs1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep30_rcHs0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.3683151 UTC

[section ""data" . $krep32_rcHs2_closure" {
     $krep32_rcHs2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep31_rcHs1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.37027085 UTC

[section ""data" . $krep33_rcHs3_closure" {
     $krep33_rcHs3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep32_rcHs2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.372604417 UTC

[section ""data" . $krep34_rcHs4_closure" {
     $krep34_rcHs4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep33_rcHs3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.374404603 UTC

[section ""data" . $krep35_rcHs5_closure" {
     $krep35_rcHs5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep34_rcHs4_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.376187244 UTC

[section ""data" . $krep36_rcHs6_closure" {
     $krep36_rcHs6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep35_rcHs5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.378362807 UTC

[section ""data" . GHC.Stats.$tc'RTSStats1_closure" {
     GHC.Stats.$tc'RTSStats1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep36_rcHs6_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.380151246 UTC

[section ""cstring" . GHC.Stats.$tc'RTSStats3_bytes" {
     GHC.Stats.$tc'RTSStats3_bytes:
         I8[] [39,82,84,83,83,116,97,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.381987036 UTC

[section ""data" . GHC.Stats.$tc'RTSStats2_closure" {
     GHC.Stats.$tc'RTSStats2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tc'RTSStats3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.383807798 UTC

[section ""data" . GHC.Stats.$tc'RTSStats_closure" {
     GHC.Stats.$tc'RTSStats_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tc'RTSStats2_closure+1;
         const GHC.Stats.$tc'RTSStats1_closure+4;
         const 10718900236833312508;
         const 16334729378492634062;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.386557257 UTC

[section ""data" . getRTSStatsEnabled1_rcHs7_closure" {
     getRTSStatsEnabled1_rcHs7_closure:
         const getRTSStatsEnabled1_rcHs7_info;
 },
 sat_scHNr_entry() //  [R1]
         { info_tbl: [(ccLBM,
                       label: sat_scHNr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLBM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccLBN; else goto ccLBO;
       ccLBN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccLBO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto ccLBL; else goto ccLBK;
       ccLBL: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccLBK: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 getRTSStatsEnabled1_rcHs7_entry() //  []
         { info_tbl: [(ccLBP,
                       label: getRTSStatsEnabled1_rcHs7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLBP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccLBQ; else goto ccLBR;
       ccLBQ: // global
           R1 = getRTSStatsEnabled1_rcHs7_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccLBR: // global
           I64[Sp - 8] = block_ccLBC_info;
           Sp = Sp - 8;
           _ucLBX::P64 = CurrentTSO;
           I64[I64[_ucLBX::P64 + 24] + 16] = Sp;
           _ucLBY::I64 = CurrentNursery;
           P64[_ucLBY::I64 + 8] = Hp + 8;
           I64[_ucLBX::P64 + 104] = I64[_ucLBX::P64 + 104] - ((Hp + 8) - I64[_ucLBY::I64]);
           (_ucLBV::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_scHNp::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] getRTSStatsEnabled();
           (_ucLBW::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ucLBV::I64);
           BaseReg = _ucLBW::I64;
           _ucLBZ::P64 = CurrentTSO;
           _ucLC0::P64 = I64[_ucLBZ::P64 + 24];
           Sp = I64[_ucLC0::P64 + 16];
           SpLim = _ucLC0::P64 + 192;
           HpAlloc = 0;
           _ucLC1::I64 = CurrentNursery;
           _ucLC2::I64 = I64[_ucLC1::I64 + 8];
           Hp = _ucLC2::I64 - 8;
           _ucLC3::I64 = I64[_ucLC1::I64];
           HpLim = _ucLC3::I64 + ((%MO_SS_Conv_W32_W64(I32[_ucLC1::I64 + 48]) << 12) - 1);
           I64[_ucLBZ::P64 + 104] = I64[_ucLBZ::P64 + 104] + (_ucLC2::I64 - _ucLC3::I64);
           R1 = _scHNp::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLBC() //  [R1]
         { info_tbl: [(ccLBC,
                       label: block_ccLBC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLBC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccLBU; else goto ccLBT;
       ccLBU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccLBT: // global
           I64[Hp - 16] = sat_scHNr_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.395988337 UTC

[section ""data" . GHC.Stats.getRTSStatsEnabled_closure" {
     GHC.Stats.getRTSStatsEnabled_closure:
         const GHC.Stats.getRTSStatsEnabled_info;
 },
 GHC.Stats.getRTSStatsEnabled_entry() //  []
         { info_tbl: [(ccLCD,
                       label: GHC.Stats.getRTSStatsEnabled_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLCD: // global
           call getRTSStatsEnabled1_rcHs7_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.399769704 UTC

[section ""cstring" . GHC.Stats.getRTSStats5_bytes" {
     GHC.Stats.getRTSStats5_bytes:
         I8[] [71,72,67,46,83,116,97,116,115,46,103,101,116,82,84,83,83,116,97,116,115,58,32,71,67,32,115,116,97,116,115,32,110,111,116,32,101,110,97,98,108,101,100,46,32,85,115,101,32,96,43,82,84,83,32,45,84,32,45,82,84,83,39,32,116,111,32,101,110,97,98,108,101,32,116,104,101,109,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.401898001 UTC

[section ""data" . GHC.Stats.getRTSStats4_closure" {
     GHC.Stats.getRTSStats4_closure:
         const GHC.Stats.getRTSStats4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.getRTSStats4_entry() //  [R1]
         { info_tbl: [(ccLCR,
                       label: GHC.Stats.getRTSStats4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLCR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccLCS; else goto ccLCT;
       ccLCS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccLCT: // global
           (_ccLCO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccLCO::I64 == 0) goto ccLCQ; else goto ccLCP;
       ccLCQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccLCP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccLCO::I64;
           R2 = GHC.Stats.getRTSStats5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.405946572 UTC

[section ""data" . GHC.Stats.getRTSStats3_closure" {
     GHC.Stats.getRTSStats3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UnsupportedOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Stats.getRTSStats4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.407996929 UTC

[section ""data" . GHC.Stats.getRTSStats2_closure" {
     GHC.Stats.getRTSStats2_closure:
         const GHC.Stats.getRTSStats2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.getRTSStats2_entry() //  [R1]
         { info_tbl: [(ccLD8,
                       label: GHC.Stats.getRTSStats2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLD8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccLD9; else goto ccLDa;
       ccLD9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccLDa: // global
           (_ccLD5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccLD5::I64 == 0) goto ccLD7; else goto ccLD6;
       ccLD7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccLD6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccLD5::I64;
           R2 = GHC.Stats.getRTSStats3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.414628299 UTC

[section ""data" . GHC.Stats.getRTSStats1_closure" {
     GHC.Stats.getRTSStats1_closure:
         const GHC.Stats.getRTSStats1_info;
         const 0;
 },
 GHC.Stats.getRTSStats1_entry() //  []
         { info_tbl: [(ccLDt,
                       label: GHC.Stats.getRTSStats1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLDt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccLDu; else goto ccLDv;
       ccLDu: // global
           R1 = GHC.Stats.getRTSStats1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccLDv: // global
           I64[Sp - 8] = block_ccLDn_info;
           Sp = Sp - 8;
           _ucLFV::P64 = CurrentTSO;
           I64[I64[_ucLFV::P64 + 24] + 16] = Sp;
           _ucLFW::I64 = CurrentNursery;
           P64[_ucLFW::I64 + 8] = Hp + 8;
           I64[_ucLFV::P64 + 104] = I64[_ucLFV::P64 + 104] - ((Hp + 8) - I64[_ucLFW::I64]);
           (_ucLFT::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_scHNw::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] getRTSStatsEnabled();
           (_ucLFU::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ucLFT::I64);
           BaseReg = _ucLFU::I64;
           _ucLFX::P64 = CurrentTSO;
           _ucLFY::P64 = I64[_ucLFX::P64 + 24];
           Sp = I64[_ucLFY::P64 + 16];
           SpLim = _ucLFY::P64 + 192;
           HpAlloc = 0;
           _ucLFZ::I64 = CurrentNursery;
           _ucLG0::I64 = I64[_ucLFZ::I64 + 8];
           Hp = _ucLG0::I64 - 8;
           _ucLG1::I64 = I64[_ucLFZ::I64];
           HpLim = _ucLG1::I64 + ((%MO_SS_Conv_W32_W64(I32[_ucLFZ::I64 + 48]) << 12) - 1);
           I64[_ucLFX::P64 + 104] = I64[_ucLFX::P64 + 104] + (_ucLG0::I64 - _ucLG1::I64);
           R1 = _scHNw::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLDn() //  [R1]
         { info_tbl: [(ccLDn,
                       label: block_ccLDn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLDn: // global
           if (R1 == 0) goto ccLDs; else goto ccLDr;
       ccLDs: // global
           R1 = GHC.Stats.getRTSStats2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ccLDr: // global
           I64[Sp] = block_ccLDy_info;
           R1 = 248;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccLDy() //  [R1]
         { info_tbl: [(ccLDy,
                       label: block_ccLDy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLDy: // global
           I64[Sp - 16] = block_ccLDF_info;
           _scHNE::I64 = R1 + 16;
           I64[Sp - 8] = _scHNE::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           _ucLG5::P64 = CurrentTSO;
           I64[I64[_ucLG5::P64 + 24] + 16] = Sp;
           _ucLG6::I64 = CurrentNursery;
           P64[_ucLG6::I64 + 8] = Hp + 8;
           I64[_ucLG5::P64 + 104] = I64[_ucLG5::P64 + 104] - ((Hp + 8) - I64[_ucLG6::I64]);
           (_ucLG3::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] getRTSStats(_scHNE::I64);
           (_ucLG4::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ucLG3::I64);
           BaseReg = _ucLG4::I64;
           _ucLG7::P64 = CurrentTSO;
           _ucLG8::P64 = I64[_ucLG7::P64 + 24];
           Sp = I64[_ucLG8::P64 + 16];
           SpLim = _ucLG8::P64 + 192;
           HpAlloc = 0;
           _ucLG9::I64 = CurrentNursery;
           _ucLGa::I64 = I64[_ucLG9::I64 + 8];
           Hp = _ucLGa::I64 - 8;
           _ucLGb::I64 = I64[_ucLG9::I64];
           HpLim = _ucLGb::I64 + ((%MO_SS_Conv_W32_W64(I32[_ucLG9::I64 + 48]) << 12) - 1);
           I64[_ucLG7::P64 + 104] = I64[_ucLG7::P64 + 104] + (_ucLGa::I64 - _ucLGb::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _ccLDF() //  []
         { info_tbl: [(ccLDF,
                       label: block_ccLDF_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLDF: // global
           Hp = Hp + 816;
           if (Hp > HpLim) (likely: False) goto ccLFS; else goto ccLFR;
       ccLFS: // global
           HpAlloc = 816;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccLFR: // global
           _scHNE::I64 = I64[Sp + 8];
           _scHNK::I64 = %MO_UU_Conv_W32_W64(I32[_scHNE::I64]);
           _scHNO::I64 = %MO_UU_Conv_W32_W64(I32[_scHNE::I64 + 4]);
           _scHNS::I64 = I64[_scHNE::I64 + 8];
           _scHNW::I64 = I64[_scHNE::I64 + 16];
           _scHO0::I64 = I64[_scHNE::I64 + 24];
           _scHO4::I64 = I64[_scHNE::I64 + 32];
           _scHO8::I64 = I64[_scHNE::I64 + 40];
           _scHOc::I64 = I64[_scHNE::I64 + 48];
           _scHOg::I64 = I64[_scHNE::I64 + 56];
           _scHOk::I64 = I64[_scHNE::I64 + 64];
           _scHOo::I64 = I64[_scHNE::I64 + 72];
           _scHOs::I64 = I64[_scHNE::I64 + 80];
           _scHOw::I64 = I64[_scHNE::I64 + 88];
           _scHOA::I64 = I64[_scHNE::I64 + 96];
           _scHOE::I64 = I64[_scHNE::I64 + 104];
           _scHOI::I64 = I64[_scHNE::I64 + 112];
           _scHOM::I64 = I64[_scHNE::I64 + 120];
           _scHOQ::I64 = I64[_scHNE::I64 + 128];
           _scHOU::I64 = I64[_scHNE::I64 + 136];
           _scHOV::I64 = _scHNE::I64 + 144;
           _scHOY::I64 = %MO_UU_Conv_W32_W64(I32[_scHOV::I64]);
           _scHP2::I64 = %MO_UU_Conv_W32_W64(I32[_scHOV::I64 + 4]);
           _scHP6::I64 = I64[_scHOV::I64 + 8];
           _scHPa::I64 = I64[_scHOV::I64 + 16];
           _scHPe::I64 = I64[_scHOV::I64 + 24];
           _scHPi::I64 = I64[_scHOV::I64 + 32];
           _scHPm::I64 = I64[_scHOV::I64 + 40];
           _scHPq::I64 = I64[_scHOV::I64 + 48];
           _scHPu::I64 = I64[_scHOV::I64 + 56];
           _scHPy::I64 = I64[_scHOV::I64 + 64];
           _scHPC::I64 = I64[_scHOV::I64 + 72];
           _scHPG::I64 = I64[_scHOV::I64 + 80];
           _scHPK::I64 = I64[_scHOV::I64 + 88];
           _scHPO::I64 = I64[_scHOV::I64 + 96];
           call MO_Touch(P64[Sp + 16]);
           I64[Hp - 808] = GHC.Int.I64#_con_info;
           I64[Hp - 800] = _scHPO::I64;
           I64[Hp - 792] = GHC.Int.I64#_con_info;
           I64[Hp - 784] = _scHPK::I64;
           I64[Hp - 776] = GHC.Int.I64#_con_info;
           I64[Hp - 768] = _scHPG::I64;
           I64[Hp - 760] = GHC.Word.W64#_con_info;
           I64[Hp - 752] = _scHPC::I64;
           I64[Hp - 744] = GHC.Word.W64#_con_info;
           I64[Hp - 736] = _scHPy::I64;
           I64[Hp - 728] = GHC.Word.W64#_con_info;
           I64[Hp - 720] = _scHPu::I64;
           I64[Hp - 712] = GHC.Word.W64#_con_info;
           I64[Hp - 704] = _scHPq::I64;
           I64[Hp - 696] = GHC.Word.W64#_con_info;
           I64[Hp - 688] = _scHPm::I64;
           I64[Hp - 680] = GHC.Word.W64#_con_info;
           I64[Hp - 672] = _scHPi::I64;
           I64[Hp - 664] = GHC.Word.W64#_con_info;
           I64[Hp - 656] = _scHPe::I64;
           I64[Hp - 648] = GHC.Word.W64#_con_info;
           I64[Hp - 640] = _scHPa::I64;
           I64[Hp - 632] = GHC.Word.W64#_con_info;
           I64[Hp - 624] = _scHP6::I64;
           I64[Hp - 616] = GHC.Word.W32#_con_info;
           I64[Hp - 608] = _scHP2::I64;
           I64[Hp - 600] = GHC.Word.W32#_con_info;
           I64[Hp - 592] = _scHOY::I64;
           I64[Hp - 584] = GHC.Stats.GCDetails_con_info;
           P64[Hp - 576] = Hp - 599;
           P64[Hp - 568] = Hp - 615;
           P64[Hp - 560] = Hp - 631;
           P64[Hp - 552] = Hp - 647;
           P64[Hp - 544] = Hp - 663;
           P64[Hp - 536] = Hp - 679;
           P64[Hp - 528] = Hp - 695;
           P64[Hp - 520] = Hp - 711;
           P64[Hp - 512] = Hp - 727;
           P64[Hp - 504] = Hp - 743;
           P64[Hp - 496] = Hp - 759;
           P64[Hp - 488] = Hp - 775;
           P64[Hp - 480] = Hp - 791;
           P64[Hp - 472] = Hp - 807;
           I64[Hp - 464] = GHC.Int.I64#_con_info;
           I64[Hp - 456] = _scHOU::I64;
           I64[Hp - 448] = GHC.Int.I64#_con_info;
           I64[Hp - 440] = _scHOQ::I64;
           I64[Hp - 432] = GHC.Int.I64#_con_info;
           I64[Hp - 424] = _scHOM::I64;
           I64[Hp - 416] = GHC.Int.I64#_con_info;
           I64[Hp - 408] = _scHOI::I64;
           I64[Hp - 400] = GHC.Int.I64#_con_info;
           I64[Hp - 392] = _scHOE::I64;
           I64[Hp - 384] = GHC.Int.I64#_con_info;
           I64[Hp - 376] = _scHOA::I64;
           I64[Hp - 368] = GHC.Word.W64#_con_info;
           I64[Hp - 360] = _scHOw::I64;
           I64[Hp - 352] = GHC.Word.W64#_con_info;
           I64[Hp - 344] = _scHOs::I64;
           I64[Hp - 336] = GHC.Word.W64#_con_info;
           I64[Hp - 328] = _scHOo::I64;
           I64[Hp - 320] = GHC.Word.W64#_con_info;
           I64[Hp - 312] = _scHOk::I64;
           I64[Hp - 304] = GHC.Word.W64#_con_info;
           I64[Hp - 296] = _scHOg::I64;
           I64[Hp - 288] = GHC.Word.W64#_con_info;
           I64[Hp - 280] = _scHOc::I64;
           I64[Hp - 272] = GHC.Word.W64#_con_info;
           I64[Hp - 264] = _scHO8::I64;
           I64[Hp - 256] = GHC.Word.W64#_con_info;
           I64[Hp - 248] = _scHO4::I64;
           I64[Hp - 240] = GHC.Word.W64#_con_info;
           I64[Hp - 232] = _scHO0::I64;
           I64[Hp - 224] = GHC.Word.W64#_con_info;
           I64[Hp - 216] = _scHNW::I64;
           I64[Hp - 208] = GHC.Word.W64#_con_info;
           I64[Hp - 200] = _scHNS::I64;
           I64[Hp - 192] = GHC.Word.W32#_con_info;
           I64[Hp - 184] = _scHNO::I64;
           I64[Hp - 176] = GHC.Word.W32#_con_info;
           I64[Hp - 168] = _scHNK::I64;
           I64[Hp - 160] = GHC.Stats.RTSStats_con_info;
           P64[Hp - 152] = Hp - 175;
           P64[Hp - 144] = Hp - 191;
           P64[Hp - 136] = Hp - 207;
           P64[Hp - 128] = Hp - 223;
           P64[Hp - 120] = Hp - 239;
           P64[Hp - 112] = Hp - 255;
           P64[Hp - 104] = Hp - 271;
           P64[Hp - 96] = Hp - 287;
           P64[Hp - 88] = Hp - 303;
           P64[Hp - 80] = Hp - 319;
           P64[Hp - 72] = Hp - 335;
           P64[Hp - 64] = Hp - 351;
           P64[Hp - 56] = Hp - 367;
           P64[Hp - 48] = Hp - 383;
           P64[Hp - 40] = Hp - 399;
           P64[Hp - 32] = Hp - 415;
           P64[Hp - 24] = Hp - 431;
           P64[Hp - 16] = Hp - 447;
           P64[Hp - 8] = Hp - 463;
           P64[Hp] = Hp - 583;
           R1 = Hp - 159;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.432928226 UTC

[section ""data" . GHC.Stats.getRTSStats_closure" {
     GHC.Stats.getRTSStats_closure:
         const GHC.Stats.getRTSStats_info;
         const 0;
 },
 GHC.Stats.getRTSStats_entry() //  []
         { info_tbl: [(ccLHy,
                       label: GHC.Stats.getRTSStats_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLHy: // global
           call GHC.Stats.getRTSStats1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.436794927 UTC

[section ""data" . GHC.Stats.GCDetails_closure" {
     GHC.Stats.GCDetails_closure:
         const GHC.Stats.GCDetails_info;
 },
 GHC.Stats.GCDetails_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLHG: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Stats.GCDetails_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 80, res: 0, upd: 8;
     }
 },
 GHC.Stats.GCDetails_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccLHL,
                       label: GHC.Stats.GCDetails_info
                       rep:HeapRep static {
                             Fun {arity: 14
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLHL: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccLHP; else goto ccLHO;
       ccLHP: // global
           HpAlloc = 120;
           R1 = GHC.Stats.GCDetails_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 120, res: 0, upd: 8;
       ccLHO: // global
           I64[Hp - 112] = GHC.Stats.GCDetails_con_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           P64[Hp - 88] = R4;
           P64[Hp - 80] = R5;
           P64[Hp - 72] = R6;
           P64[Hp - 64] = P64[Sp];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = P64[Sp + 56];
           P64[Hp] = P64[Sp + 64];
           R1 = Hp - 111;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.443226056 UTC

[section ""data" . GHC.Stats.RTSStats_closure" {
     GHC.Stats.RTSStats_closure:
         const GHC.Stats.RTSStats_info;
 },
 GHC.Stats.RTSStats_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLI7: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Stats.RTSStats_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2,
                                         R1) args: 128, res: 0, upd: 8;
     }
 },
 GHC.Stats.RTSStats_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccLIc,
                       label: GHC.Stats.RTSStats_info
                       rep:HeapRep static {
                             Fun {arity: 20
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLIc: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccLIg; else goto ccLIf;
       ccLIg: // global
           HpAlloc = 168;
           R1 = GHC.Stats.RTSStats_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 168, res: 0, upd: 8;
       ccLIf: // global
           I64[Hp - 160] = GHC.Stats.RTSStats_con_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           P64[Hp - 136] = R4;
           P64[Hp - 128] = R5;
           P64[Hp - 120] = R6;
           P64[Hp - 112] = P64[Sp];
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = P64[Sp + 16];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = P64[Sp + 56];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = P64[Sp + 72];
           P64[Hp - 32] = P64[Sp + 80];
           P64[Hp - 24] = P64[Sp + 88];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 159;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.449189594 UTC

[GHC.Stats.GCDetails_con_entry() //  [R1]
         { info_tbl: [(ccLID,
                       label: GHC.Stats.GCDetails_con_info
                       rep:HeapRep 14 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,115,46,71,67,68,101,116,97,105,108,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLID: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.45289992 UTC

[GHC.Stats.RTSStats_con_entry() //  [R1]
         { info_tbl: [(ccLIJ,
                       label: GHC.Stats.RTSStats_con_info
                       rep:HeapRep 20 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,115,46,82,84,83,83,116,97,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccLIJ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:38.457183212 UTC

[section ""relreadonly" . ScI2G_srt" {
     ScI2G_srt:
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Stats.$fShowGCDetails_$cshowsPrec_closure;
         const GHC.Stats.$fShowGCDetails_$cshow_closure;
         const GHC.Stats.$fShowGCDetails1_closure;
         const GHC.Stats.$fShowRTSStats_$cshowsPrec_closure;
         const GHC.Stats.$fShowRTSStats_$cshow_closure;
         const GHC.Stats.$fShowRTSStats1_closure;
         const GHC.Read.$fReadWord32_$creadsPrec_closure;
         const lvl37_rcHqd_closure;
         const ds2_rcHqe_closure;
         const GHC.Read.$fReadWord64_$creadsPrec_closure;
         const lvl45_rcHqn_closure;
         const lvl46_rcHqo_closure;
         const GHC.Int.$fReadInt64_$creadsPrec_closure;
         const lvl65_rcHqH_closure;
         const lvl66_rcHqI_closure;
         const Text.Read.Lex.$wexpect_closure;
         const lvl72_rcHqO_closure;
         const GHC.Read.readField_closure;
         const lvl70_rcHqM_closure;
         const lvl40_rcHqi_closure;
         const lvl68_rcHqK_closure;
         const lvl64_rcHqG_closure;
         const lvl62_rcHqE_closure;
         const lvl60_rcHqC_closure;
         const lvl58_rcHqA_closure;
         const lvl56_rcHqy_closure;
         const lvl54_rcHqw_closure;
         const lvl52_rcHqu_closure;
         const lvl50_rcHqs_closure;
         const lvl48_rcHqq_closure;
         const lvl44_rcHqm_closure;
         const lvl42_rcHqk_closure;
         const ds1_rcHqc_closure;
         const lexeme4_rcHqa_closure;
         const GHC.Stats.$w$creadPrec_closure;
         const lexeme1_rcHq7_closure;
         const GHC.Stats.$fReadGCDetails2_closure;
         const GHC.Read.list3_closure;
         const GHC.Stats.$fReadGCDetails_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.Stats.$fReadGCDetails1_closure;
         const GHC.Stats.$fReadGCDetails_$creadListPrec_closure;
         const GHC.Stats.$fReadGCDetails3_closure;
         const lvl110_rcHru_closure;
         const lvl111_rcHrv_closure;
         const lvl108_rcHrs_closure;
         const lvl106_rcHrq_closure;
         const lvl104_rcHro_closure;
         const lvl102_rcHrm_closure;
         const lvl100_rcHrk_closure;
         const lvl98_rcHri_closure;
         const lvl96_rcHrg_closure;
         const lvl94_rcHre_closure;
         const lvl92_rcHrc_closure;
         const lvl90_rcHra_closure;
         const lvl88_rcHr8_closure;
         const lvl86_rcHr6_closure;
         const lvl84_rcHr4_closure;
         const lvl82_rcHr2_closure;
         const lvl80_rcHr0_closure;
         const lvl78_rcHqY_closure;
         const lvl76_rcHqW_closure;
         const lvl74_rcHqU_closure;
         const ds4_rcHqS_closure;
         const GHC.Stats.$w$creadPrec1_closure;
         const lexeme6_rcHqQ_closure;
         const GHC.Stats.$fReadRTSStats2_closure;
         const GHC.Stats.$fReadRTSStats_$creadsPrec_closure;
         const GHC.Stats.$fReadRTSStats1_closure;
         const GHC.Stats.$fReadRTSStats_$creadListPrec_closure;
         const GHC.Stats.$fReadRTSStats3_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.Stats.getRTSStats3_closure;
         const GHC.Stats.getRTSStats1_closure;
         const GHC.Stats.getRTSStats2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.068272528 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:47.069474405 UTC

[section ""cstring" . lvl_rcHpv_bytes" {
     lvl_rcHpv_bytes:
         I8[] [71,67,68,101,116,97,105,108,115,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.071203178 UTC

[section ""cstring" . lvl1_rcHpw_bytes" {
     lvl1_rcHpw_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,103,101,110,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.072890143 UTC

[section ""cstring" . lvl2_rcHpx_bytes" {
     lvl2_rcHpx_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,116,104,114,101,97,100,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.074676484 UTC

[section ""cstring" . lvl3_rcHpy_bytes" {
     lvl3_rcHpy_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,97,108,108,111,99,97,116,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.076313138 UTC

[section ""cstring" . lvl4_rcHpz_bytes" {
     lvl4_rcHpz_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,105,118,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.078132902 UTC

[section ""cstring" . lvl5_rcHpA_bytes" {
     lvl5_rcHpA_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.07980436 UTC

[section ""cstring" . lvl6_rcHpB_bytes" {
     lvl6_rcHpB_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,109,112,97,99,116,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.081620099 UTC

[section ""cstring" . lvl7_rcHpC_bytes" {
     lvl7_rcHpC_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,108,111,112,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.083355454 UTC

[section ""cstring" . lvl8_rcHpD_bytes" {
     lvl8_rcHpD_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.085039874 UTC

[section ""cstring" . lvl9_rcHpE_bytes" {
     lvl9_rcHpE_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.086853093 UTC

[section ""cstring" . lvl10_rcHpF_bytes" {
     lvl10_rcHpF_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.088613846 UTC

[section ""cstring" . lvl11_rcHpG_bytes" {
     lvl11_rcHpG_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.09033723 UTC

[section ""cstring" . lvl12_rcHpH_bytes" {
     lvl12_rcHpH_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,121,110,99,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.092144618 UTC

[section ""cstring" . lvl13_rcHpI_bytes" {
     lvl13_rcHpI_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.095627673 UTC

[section ""cstring" . lvl14_rcHpJ_bytes" {
     lvl14_rcHpJ_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.09731498 UTC

[section ""cstring" . lvl15_rcHpK_bytes" {
     lvl15_rcHpK_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.112395772 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_$cshowsPrec_closure" {
     GHC.Stats.$fShowGCDetails_$cshowsPrec_closure:
         const GHC.Stats.$fShowGCDetails_$cshowsPrec_info;
         const 0;
 },
 w1_scLJ9_entry() //  [R1]
         { info_tbl: [(ccM7I,
                       label: w1_scLJ9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM7I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccM7J; else goto ccM7K;
       ccM7J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccM7K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccM7F_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucM7W; else goto ccM7G;
       ucM7W: // global
           call _ccM7F(R1) args: 0, res: 0, upd: 0;
       ccM7G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccM7F() //  [R1]
         { info_tbl: [(ccM7F,
                       label: block_ccM7F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM7F: // global
           _scLJb::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLJb::I64, 0)) goto ccM7U; else goto ccM7V;
       ccM7U: // global
           R2 = _scLJb::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccM7V: // global
           R2 = _scLJb::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w2_scLJe_entry() //  [R1]
         { info_tbl: [(ccM84,
                       label: w2_scLJe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM84: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccM85; else goto ccM86;
       ccM85: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccM86: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccM81_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucM8i; else goto ccM82;
       ucM8i: // global
           call _ccM81(R1) args: 0, res: 0, upd: 0;
       ccM82: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccM81() //  [R1]
         { info_tbl: [(ccM81,
                       label: block_ccM81_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM81: // global
           _scLJg::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLJg::I64, 0)) goto ccM8g; else goto ccM8h;
       ccM8g: // global
           R2 = _scLJg::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccM8h: // global
           R2 = _scLJg::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w3_scLJj_entry() //  [R1]
         { info_tbl: [(ccM8q,
                       label: w3_scLJj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM8q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccM8r; else goto ccM8s;
       ccM8r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccM8s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccM8n_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucM8E; else goto ccM8o;
       ucM8E: // global
           call _ccM8n(R1) args: 0, res: 0, upd: 0;
       ccM8o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccM8n() //  [R1]
         { info_tbl: [(ccM8n,
                       label: block_ccM8n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM8n: // global
           _scLJl::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLJl::I64, 0)) goto ccM8C; else goto ccM8D;
       ccM8C: // global
           R2 = _scLJl::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccM8D: // global
           R2 = _scLJl::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w4_scLJo_entry() //  [R1]
         { info_tbl: [(ccM8M,
                       label: w4_scLJo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM8M: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccM8N; else goto ccM8O;
       ccM8N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccM8O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccM8J_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucM90; else goto ccM8K;
       ucM90: // global
           call _ccM8J(R1) args: 0, res: 0, upd: 0;
       ccM8K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccM8J() //  [R1]
         { info_tbl: [(ccM8J,
                       label: block_ccM8J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM8J: // global
           _scLJq::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLJq::I64, 0)) goto ccM8Y; else goto ccM8Z;
       ccM8Y: // global
           R2 = _scLJq::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccM8Z: // global
           R2 = _scLJq::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_scLJt_entry() //  [R1]
         { info_tbl: [(ccM98,
                       label: w5_scLJt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM98: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccM99; else goto ccM9a;
       ccM99: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccM9a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccM95_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucM9m; else goto ccM96;
       ucM9m: // global
           call _ccM95(R1) args: 0, res: 0, upd: 0;
       ccM96: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccM95() //  [R1]
         { info_tbl: [(ccM95,
                       label: block_ccM95_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM95: // global
           _scLJv::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLJv::I64, 0)) goto ccM9k; else goto ccM9l;
       ccM9k: // global
           R2 = _scLJv::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccM9l: // global
           R2 = _scLJv::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_scLJy_entry() //  [R1]
         { info_tbl: [(ccM9u,
                       label: w6_scLJy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM9u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccM9v; else goto ccM9w;
       ccM9v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccM9w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccM9r_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucM9I; else goto ccM9s;
       ucM9I: // global
           call _ccM9r(R1) args: 0, res: 0, upd: 0;
       ccM9s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccM9r() //  [R1]
         { info_tbl: [(ccM9r,
                       label: block_ccM9r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM9r: // global
           _scLJA::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLJA::I64, 0)) goto ccM9G; else goto ccM9H;
       ccM9G: // global
           R2 = _scLJA::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccM9H: // global
           R2 = _scLJA::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_scLJD_entry() //  [R1]
         { info_tbl: [(ccM9Q,
                       label: w7_scLJD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM9Q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccM9R; else goto ccM9S;
       ccM9R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccM9S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccM9N_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMa4; else goto ccM9O;
       ucMa4: // global
           call _ccM9N(R1) args: 0, res: 0, upd: 0;
       ccM9O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccM9N() //  [R1]
         { info_tbl: [(ccM9N,
                       label: block_ccM9N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM9N: // global
           _scLJF::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLJF::I64, 0)) goto ccMa2; else goto ccMa3;
       ccMa2: // global
           R2 = _scLJF::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMa3: // global
           R2 = _scLJF::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w8_scLJI_entry() //  [R1]
         { info_tbl: [(ccMac,
                       label: w8_scLJI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMac: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccMad; else goto ccMae;
       ccMad: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMae: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccMa9_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMaq; else goto ccMaa;
       ucMaq: // global
           call _ccMa9(R1) args: 0, res: 0, upd: 0;
       ccMaa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMa9() //  [R1]
         { info_tbl: [(ccMa9,
                       label: block_ccMa9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMa9: // global
           _scLJK::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLJK::I64, 0)) goto ccMao; else goto ccMap;
       ccMao: // global
           R2 = _scLJK::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMap: // global
           R2 = _scLJK::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w9_scLJN_entry() //  [R1]
         { info_tbl: [(ccMay,
                       label: w9_scLJN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMay: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccMaz; else goto ccMaA;
       ccMaz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMaA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccMav_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMaM; else goto ccMaw;
       ucMaM: // global
           call _ccMav(R1) args: 0, res: 0, upd: 0;
       ccMaw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMav() //  [R1]
         { info_tbl: [(ccMav,
                       label: block_ccMav_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMav: // global
           _scLJP::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLJP::I64, 0)) goto ccMaK; else goto ccMaL;
       ccMaK: // global
           R2 = _scLJP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMaL: // global
           R2 = _scLJP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLK6_entry() //  [R1]
         { info_tbl: [(ccMdZ,
                       label: sat_scLK6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMdZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMe0; else goto ccMe1;
       ccMe0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMe1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = lvl15_rcHpK_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKa_entry() //  [R1]
         { info_tbl: [(ccMe2,
                       label: sat_scLKa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMe2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccMe6; else goto ccMe7;
       ccMe6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMe7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ccMdQ_info;
           _scLJT::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _scLJT::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucMee; else goto ccMdR;
       ucMee: // global
           call _ccMdQ(R1) args: 0, res: 0, upd: 0;
       ccMdR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMdQ() //  [R1]
         { info_tbl: [(ccMdQ,
                       label: block_ccMdQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMdQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMea; else goto ccMe9;
       ccMea: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccMe9: // global
           _scLK5::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_scLK6_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccMe3_info;
           R4 = Hp - 16;
           R3 = _scLK5::I64;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMe3() //  [R1, R2]
         { info_tbl: [(ccMe3,
                       label: block_ccMe3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMe3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMed; else goto ccMec;
       ccMed: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMec: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKb_entry() //  [R1]
         { info_tbl: [(ccMef,
                       label: sat_scLKb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMef: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccMej; else goto ccMei;
       ccMej: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMei: // global
           _scLJ6::P64 = P64[R1 + 16];
           _scLJT::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_scLKa_info;
           P64[Hp - 8] = _scLJ6::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 24;
           R2 = lvl14_rcHpJ_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLKc_entry() //  [R1]
         { info_tbl: [(ccMek,
                       label: sat_scLKc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMek: // global
           _scLKc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMel; else goto ccMem;
       ccMem: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccMeo; else goto ccMen;
       ccMeo: // global
           HpAlloc = 32;
           goto ccMel;
       ccMel: // global
           R1 = _scLKc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMen: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKc::P64;
           _scLJ6::P64 = P64[_scLKc::P64 + 16];
           _scLJT::P64 = P64[_scLKc::P64 + 24];
           I64[Hp - 24] = sat_scLKb_info;
           P64[Hp - 8] = _scLJ6::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKg_entry() //  [R1]
         { info_tbl: [(ccMep,
                       label: sat_scLKg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMep: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccMet; else goto ccMeu;
       ccMet: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMeu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccMdz_info;
           _scLJ6::P64 = P64[R1 + 24];
           _scLJT::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _scLJ6::P64;
           P64[Sp - 24] = _scLJT::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucMeB; else goto ccMdA;
       ucMeB: // global
           call _ccMdz(R1) args: 0, res: 0, upd: 0;
       ccMdA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMdz() //  [R1]
         { info_tbl: [(ccMdz,
                       label: block_ccMdz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMdz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccMex; else goto ccMew;
       ccMex: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccMew: // global
           _scLK3::I64 = I64[R1 + 7];
           I64[Hp - 24] = sat_scLKc_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_ccMeq_info;
           R4 = Hp - 24;
           R3 = _scLK3::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMeq() //  [R1, R2]
         { info_tbl: [(ccMeq,
                       label: block_ccMeq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMeq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMeA; else goto ccMez;
       ccMeA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMez: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKh_entry() //  [R1]
         { info_tbl: [(ccMeC,
                       label: sat_scLKh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMeC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccMeG; else goto ccMeF;
       ccMeG: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMeF: // global
           _scLJ5::P64 = P64[R1 + 16];
           _scLJ6::P64 = P64[R1 + 24];
           _scLJT::P64 = P64[R1 + 32];
           I64[Hp - 32] = sat_scLKg_info;
           P64[Hp - 16] = _scLJ5::P64;
           P64[Hp - 8] = _scLJ6::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 32;
           R2 = lvl13_rcHpI_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLKi_entry() //  [R1]
         { info_tbl: [(ccMeH,
                       label: sat_scLKi_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMeH: // global
           _scLKi::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMeI; else goto ccMeJ;
       ccMeJ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccMeL; else goto ccMeK;
       ccMeL: // global
           HpAlloc = 40;
           goto ccMeI;
       ccMeI: // global
           R1 = _scLKi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMeK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKi::P64;
           _scLJ5::P64 = P64[_scLKi::P64 + 16];
           _scLJ6::P64 = P64[_scLKi::P64 + 24];
           _scLJT::P64 = P64[_scLKi::P64 + 32];
           I64[Hp - 32] = sat_scLKh_info;
           P64[Hp - 16] = _scLJ5::P64;
           P64[Hp - 8] = _scLJ6::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKm_entry() //  [R1]
         { info_tbl: [(ccMeM,
                       label: sat_scLKm_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMeM: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccMeQ; else goto ccMeR;
       ccMeQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMeR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccMdi_info;
           _scLJ5::P64 = P64[R1 + 24];
           _scLJ6::P64 = P64[R1 + 32];
           _scLJT::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _scLJ5::P64;
           P64[Sp - 32] = _scLJ6::P64;
           P64[Sp - 24] = _scLJT::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucMeY; else goto ccMdj;
       ucMeY: // global
           call _ccMdi(R1) args: 0, res: 0, upd: 0;
       ccMdj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMdi() //  [R1]
         { info_tbl: [(ccMdi,
                       label: block_ccMdi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMdi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccMeU; else goto ccMeT;
       ccMeU: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccMeT: // global
           _scLK1::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_scLKi_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_ccMeN_info;
           R4 = Hp - 32;
           R3 = _scLK1::I64;
           R2 = 0;
           Sp = Sp + 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMeN() //  [R1, R2]
         { info_tbl: [(ccMeN,
                       label: block_ccMeN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMeN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMeX; else goto ccMeW;
       ccMeX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMeW: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKn_entry() //  [R1]
         { info_tbl: [(ccMeZ,
                       label: sat_scLKn_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMeZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccMf3; else goto ccMf2;
       ccMf3: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMf2: // global
           _scLJ4::P64 = P64[R1 + 16];
           _scLJ5::P64 = P64[R1 + 24];
           _scLJ6::P64 = P64[R1 + 32];
           _scLJT::P64 = P64[R1 + 40];
           I64[Hp - 40] = sat_scLKm_info;
           P64[Hp - 24] = _scLJ4::P64;
           P64[Hp - 16] = _scLJ5::P64;
           P64[Hp - 8] = _scLJ6::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 40;
           R2 = lvl12_rcHpH_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLKo_entry() //  [R1]
         { info_tbl: [(ccMf4,
                       label: sat_scLKo_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMf4: // global
           _scLKo::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMf5; else goto ccMf6;
       ccMf6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccMf8; else goto ccMf7;
       ccMf8: // global
           HpAlloc = 48;
           goto ccMf5;
       ccMf5: // global
           R1 = _scLKo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMf7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKo::P64;
           _scLJ4::P64 = P64[_scLKo::P64 + 16];
           _scLJ5::P64 = P64[_scLKo::P64 + 24];
           _scLJ6::P64 = P64[_scLKo::P64 + 32];
           _scLJT::P64 = P64[_scLKo::P64 + 40];
           I64[Hp - 40] = sat_scLKn_info;
           P64[Hp - 24] = _scLJ4::P64;
           P64[Hp - 16] = _scLJ5::P64;
           P64[Hp - 8] = _scLJ6::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 40;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKs_entry() //  [R1]
         { info_tbl: [(ccMfc,
                       label: sat_scLKs_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMfc: // global
           _scLKs::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMfd; else goto ccMfe;
       ccMfe: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccMfg; else goto ccMff;
       ccMfg: // global
           HpAlloc = 48;
           goto ccMfd;
       ccMfd: // global
           R1 = _scLKs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMff: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKs::P64;
           _scLJ4::P64 = P64[_scLKs::P64 + 16];
           _scLJ5::P64 = P64[_scLKs::P64 + 24];
           _scLJ6::P64 = P64[_scLKs::P64 + 32];
           _scLJN::P64 = P64[_scLKs::P64 + 40];
           _scLJT::P64 = P64[_scLKs::P64 + 48];
           I64[Hp - 40] = sat_scLKo_info;
           P64[Hp - 24] = _scLJ4::P64;
           P64[Hp - 16] = _scLJ5::P64;
           P64[Hp - 8] = _scLJ6::P64;
           P64[Hp] = _scLJT::P64;
           I64[Sp - 24] = block_ccMf9_info;
           R4 = Hp - 40;
           R3 = _scLJN::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMf9() //  [R1, R2]
         { info_tbl: [(ccMf9,
                       label: block_ccMf9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMf9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMfj; else goto ccMfi;
       ccMfj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMfi: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKt_entry() //  [R1]
         { info_tbl: [(ccMfk,
                       label: sat_scLKt_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMfk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccMfo; else goto ccMfn;
       ccMfo: // global
           HpAlloc = 56;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMfn: // global
           _scLJ4::P64 = P64[R1 + 16];
           _scLJ5::P64 = P64[R1 + 24];
           _scLJ6::P64 = P64[R1 + 32];
           _scLJN::P64 = P64[R1 + 40];
           _scLJT::P64 = P64[R1 + 48];
           I64[Hp - 48] = sat_scLKs_info;
           P64[Hp - 32] = _scLJ4::P64;
           P64[Hp - 24] = _scLJ5::P64;
           P64[Hp - 16] = _scLJ6::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 48;
           R2 = lvl11_rcHpG_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLKu_entry() //  [R1]
         { info_tbl: [(ccMfp,
                       label: sat_scLKu_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMfp: // global
           _scLKu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMfq; else goto ccMfr;
       ccMfr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccMft; else goto ccMfs;
       ccMft: // global
           HpAlloc = 56;
           goto ccMfq;
       ccMfq: // global
           R1 = _scLKu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMfs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKu::P64;
           _scLJ4::P64 = P64[_scLKu::P64 + 16];
           _scLJ5::P64 = P64[_scLKu::P64 + 24];
           _scLJ6::P64 = P64[_scLKu::P64 + 32];
           _scLJN::P64 = P64[_scLKu::P64 + 40];
           _scLJT::P64 = P64[_scLKu::P64 + 48];
           I64[Hp - 48] = sat_scLKt_info;
           P64[Hp - 32] = _scLJ4::P64;
           P64[Hp - 24] = _scLJ5::P64;
           P64[Hp - 16] = _scLJ6::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 48;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKy_entry() //  [R1]
         { info_tbl: [(ccMfx,
                       label: sat_scLKy_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMfx: // global
           _scLKy::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMfy; else goto ccMfz;
       ccMfz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccMfB; else goto ccMfA;
       ccMfB: // global
           HpAlloc = 56;
           goto ccMfy;
       ccMfy: // global
           R1 = _scLKy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMfA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKy::P64;
           _scLJ4::P64 = P64[_scLKy::P64 + 16];
           _scLJ5::P64 = P64[_scLKy::P64 + 24];
           _scLJ6::P64 = P64[_scLKy::P64 + 32];
           _scLJI::P64 = P64[_scLKy::P64 + 40];
           _scLJN::P64 = P64[_scLKy::P64 + 48];
           _scLJT::P64 = P64[_scLKy::P64 + 56];
           I64[Hp - 48] = sat_scLKu_info;
           P64[Hp - 32] = _scLJ4::P64;
           P64[Hp - 24] = _scLJ5::P64;
           P64[Hp - 16] = _scLJ6::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           I64[Sp - 24] = block_ccMfu_info;
           R4 = Hp - 48;
           R3 = _scLJI::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMfu() //  [R1, R2]
         { info_tbl: [(ccMfu,
                       label: block_ccMfu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMfu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMfE; else goto ccMfD;
       ccMfE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMfD: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKz_entry() //  [R1]
         { info_tbl: [(ccMfF,
                       label: sat_scLKz_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMfF: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccMfJ; else goto ccMfI;
       ccMfJ: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMfI: // global
           _scLJ4::P64 = P64[R1 + 16];
           _scLJ5::P64 = P64[R1 + 24];
           _scLJ6::P64 = P64[R1 + 32];
           _scLJI::P64 = P64[R1 + 40];
           _scLJN::P64 = P64[R1 + 48];
           _scLJT::P64 = P64[R1 + 56];
           I64[Hp - 56] = sat_scLKy_info;
           P64[Hp - 40] = _scLJ4::P64;
           P64[Hp - 32] = _scLJ5::P64;
           P64[Hp - 24] = _scLJ6::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 56;
           R2 = lvl10_rcHpF_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLKA_entry() //  [R1]
         { info_tbl: [(ccMfK,
                       label: sat_scLKA_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMfK: // global
           _scLKA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMfL; else goto ccMfM;
       ccMfM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccMfO; else goto ccMfN;
       ccMfO: // global
           HpAlloc = 64;
           goto ccMfL;
       ccMfL: // global
           R1 = _scLKA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMfN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKA::P64;
           _scLJ4::P64 = P64[_scLKA::P64 + 16];
           _scLJ5::P64 = P64[_scLKA::P64 + 24];
           _scLJ6::P64 = P64[_scLKA::P64 + 32];
           _scLJI::P64 = P64[_scLKA::P64 + 40];
           _scLJN::P64 = P64[_scLKA::P64 + 48];
           _scLJT::P64 = P64[_scLKA::P64 + 56];
           I64[Hp - 56] = sat_scLKz_info;
           P64[Hp - 40] = _scLJ4::P64;
           P64[Hp - 32] = _scLJ5::P64;
           P64[Hp - 24] = _scLJ6::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 56;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKE_entry() //  [R1]
         { info_tbl: [(ccMfS,
                       label: sat_scLKE_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMfS: // global
           _scLKE::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMfT; else goto ccMfU;
       ccMfU: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccMfW; else goto ccMfV;
       ccMfW: // global
           HpAlloc = 64;
           goto ccMfT;
       ccMfT: // global
           R1 = _scLKE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMfV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKE::P64;
           _scLJ4::P64 = P64[_scLKE::P64 + 16];
           _scLJ5::P64 = P64[_scLKE::P64 + 24];
           _scLJ6::P64 = P64[_scLKE::P64 + 32];
           _scLJD::P64 = P64[_scLKE::P64 + 40];
           _scLJI::P64 = P64[_scLKE::P64 + 48];
           _scLJN::P64 = P64[_scLKE::P64 + 56];
           _scLJT::P64 = P64[_scLKE::P64 + 64];
           I64[Hp - 56] = sat_scLKA_info;
           P64[Hp - 40] = _scLJ4::P64;
           P64[Hp - 32] = _scLJ5::P64;
           P64[Hp - 24] = _scLJ6::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           I64[Sp - 24] = block_ccMfP_info;
           R4 = Hp - 56;
           R3 = _scLJD::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMfP() //  [R1, R2]
         { info_tbl: [(ccMfP,
                       label: block_ccMfP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMfP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMfZ; else goto ccMfY;
       ccMfZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMfY: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKF_entry() //  [R1]
         { info_tbl: [(ccMg0,
                       label: sat_scLKF_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMg0: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccMg4; else goto ccMg3;
       ccMg4: // global
           HpAlloc = 72;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMg3: // global
           _scLJ4::P64 = P64[R1 + 16];
           _scLJ5::P64 = P64[R1 + 24];
           _scLJ6::P64 = P64[R1 + 32];
           _scLJD::P64 = P64[R1 + 40];
           _scLJI::P64 = P64[R1 + 48];
           _scLJN::P64 = P64[R1 + 56];
           _scLJT::P64 = P64[R1 + 64];
           I64[Hp - 64] = sat_scLKE_info;
           P64[Hp - 48] = _scLJ4::P64;
           P64[Hp - 40] = _scLJ5::P64;
           P64[Hp - 32] = _scLJ6::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 64;
           R2 = lvl9_rcHpE_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLKG_entry() //  [R1]
         { info_tbl: [(ccMg5,
                       label: sat_scLKG_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMg5: // global
           _scLKG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMg6; else goto ccMg7;
       ccMg7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccMg9; else goto ccMg8;
       ccMg9: // global
           HpAlloc = 72;
           goto ccMg6;
       ccMg6: // global
           R1 = _scLKG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMg8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKG::P64;
           _scLJ4::P64 = P64[_scLKG::P64 + 16];
           _scLJ5::P64 = P64[_scLKG::P64 + 24];
           _scLJ6::P64 = P64[_scLKG::P64 + 32];
           _scLJD::P64 = P64[_scLKG::P64 + 40];
           _scLJI::P64 = P64[_scLKG::P64 + 48];
           _scLJN::P64 = P64[_scLKG::P64 + 56];
           _scLJT::P64 = P64[_scLKG::P64 + 64];
           I64[Hp - 64] = sat_scLKF_info;
           P64[Hp - 48] = _scLJ4::P64;
           P64[Hp - 40] = _scLJ5::P64;
           P64[Hp - 32] = _scLJ6::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 64;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKK_entry() //  [R1]
         { info_tbl: [(ccMgd,
                       label: sat_scLKK_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMgd: // global
           _scLKK::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMge; else goto ccMgf;
       ccMgf: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccMgh; else goto ccMgg;
       ccMgh: // global
           HpAlloc = 72;
           goto ccMge;
       ccMge: // global
           R1 = _scLKK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMgg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKK::P64;
           _scLJ4::P64 = P64[_scLKK::P64 + 16];
           _scLJ5::P64 = P64[_scLKK::P64 + 24];
           _scLJ6::P64 = P64[_scLKK::P64 + 32];
           _scLJy::P64 = P64[_scLKK::P64 + 40];
           _scLJD::P64 = P64[_scLKK::P64 + 48];
           _scLJI::P64 = P64[_scLKK::P64 + 56];
           _scLJN::P64 = P64[_scLKK::P64 + 64];
           _scLJT::P64 = P64[_scLKK::P64 + 72];
           I64[Hp - 64] = sat_scLKG_info;
           P64[Hp - 48] = _scLJ4::P64;
           P64[Hp - 40] = _scLJ5::P64;
           P64[Hp - 32] = _scLJ6::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           I64[Sp - 24] = block_ccMga_info;
           R4 = Hp - 64;
           R3 = _scLJy::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMga() //  [R1, R2]
         { info_tbl: [(ccMga,
                       label: block_ccMga_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMga: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMgk; else goto ccMgj;
       ccMgk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMgj: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKL_entry() //  [R1]
         { info_tbl: [(ccMgl,
                       label: sat_scLKL_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMgl: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccMgp; else goto ccMgo;
       ccMgp: // global
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMgo: // global
           _scLJ4::P64 = P64[R1 + 16];
           _scLJ5::P64 = P64[R1 + 24];
           _scLJ6::P64 = P64[R1 + 32];
           _scLJy::P64 = P64[R1 + 40];
           _scLJD::P64 = P64[R1 + 48];
           _scLJI::P64 = P64[R1 + 56];
           _scLJN::P64 = P64[R1 + 64];
           _scLJT::P64 = P64[R1 + 72];
           I64[Hp - 72] = sat_scLKK_info;
           P64[Hp - 56] = _scLJ4::P64;
           P64[Hp - 48] = _scLJ5::P64;
           P64[Hp - 40] = _scLJ6::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 72;
           R2 = lvl8_rcHpD_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLKM_entry() //  [R1]
         { info_tbl: [(ccMgq,
                       label: sat_scLKM_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMgq: // global
           _scLKM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMgr; else goto ccMgs;
       ccMgs: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccMgu; else goto ccMgt;
       ccMgu: // global
           HpAlloc = 80;
           goto ccMgr;
       ccMgr: // global
           R1 = _scLKM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMgt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKM::P64;
           _scLJ4::P64 = P64[_scLKM::P64 + 16];
           _scLJ5::P64 = P64[_scLKM::P64 + 24];
           _scLJ6::P64 = P64[_scLKM::P64 + 32];
           _scLJy::P64 = P64[_scLKM::P64 + 40];
           _scLJD::P64 = P64[_scLKM::P64 + 48];
           _scLJI::P64 = P64[_scLKM::P64 + 56];
           _scLJN::P64 = P64[_scLKM::P64 + 64];
           _scLJT::P64 = P64[_scLKM::P64 + 72];
           I64[Hp - 72] = sat_scLKL_info;
           P64[Hp - 56] = _scLJ4::P64;
           P64[Hp - 48] = _scLJ5::P64;
           P64[Hp - 40] = _scLJ6::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 72;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKQ_entry() //  [R1]
         { info_tbl: [(ccMgy,
                       label: sat_scLKQ_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMgy: // global
           _scLKQ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMgz; else goto ccMgA;
       ccMgA: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccMgC; else goto ccMgB;
       ccMgC: // global
           HpAlloc = 80;
           goto ccMgz;
       ccMgz: // global
           R1 = _scLKQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMgB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKQ::P64;
           _scLJ4::P64 = P64[_scLKQ::P64 + 16];
           _scLJ5::P64 = P64[_scLKQ::P64 + 24];
           _scLJ6::P64 = P64[_scLKQ::P64 + 32];
           _scLJt::P64 = P64[_scLKQ::P64 + 40];
           _scLJy::P64 = P64[_scLKQ::P64 + 48];
           _scLJD::P64 = P64[_scLKQ::P64 + 56];
           _scLJI::P64 = P64[_scLKQ::P64 + 64];
           _scLJN::P64 = P64[_scLKQ::P64 + 72];
           _scLJT::P64 = P64[_scLKQ::P64 + 80];
           I64[Hp - 72] = sat_scLKM_info;
           P64[Hp - 56] = _scLJ4::P64;
           P64[Hp - 48] = _scLJ5::P64;
           P64[Hp - 40] = _scLJ6::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           I64[Sp - 24] = block_ccMgv_info;
           R4 = Hp - 72;
           R3 = _scLJt::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMgv() //  [R1, R2]
         { info_tbl: [(ccMgv,
                       label: block_ccMgv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMgv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMgF; else goto ccMgE;
       ccMgF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMgE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKR_entry() //  [R1]
         { info_tbl: [(ccMgG,
                       label: sat_scLKR_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMgG: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccMgK; else goto ccMgJ;
       ccMgK: // global
           HpAlloc = 88;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMgJ: // global
           _scLJ4::P64 = P64[R1 + 16];
           _scLJ5::P64 = P64[R1 + 24];
           _scLJ6::P64 = P64[R1 + 32];
           _scLJt::P64 = P64[R1 + 40];
           _scLJy::P64 = P64[R1 + 48];
           _scLJD::P64 = P64[R1 + 56];
           _scLJI::P64 = P64[R1 + 64];
           _scLJN::P64 = P64[R1 + 72];
           _scLJT::P64 = P64[R1 + 80];
           I64[Hp - 80] = sat_scLKQ_info;
           P64[Hp - 64] = _scLJ4::P64;
           P64[Hp - 56] = _scLJ5::P64;
           P64[Hp - 48] = _scLJ6::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 80;
           R2 = lvl7_rcHpC_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLKS_entry() //  [R1]
         { info_tbl: [(ccMgL,
                       label: sat_scLKS_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMgL: // global
           _scLKS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMgM; else goto ccMgN;
       ccMgN: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccMgP; else goto ccMgO;
       ccMgP: // global
           HpAlloc = 88;
           goto ccMgM;
       ccMgM: // global
           R1 = _scLKS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMgO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKS::P64;
           _scLJ4::P64 = P64[_scLKS::P64 + 16];
           _scLJ5::P64 = P64[_scLKS::P64 + 24];
           _scLJ6::P64 = P64[_scLKS::P64 + 32];
           _scLJt::P64 = P64[_scLKS::P64 + 40];
           _scLJy::P64 = P64[_scLKS::P64 + 48];
           _scLJD::P64 = P64[_scLKS::P64 + 56];
           _scLJI::P64 = P64[_scLKS::P64 + 64];
           _scLJN::P64 = P64[_scLKS::P64 + 72];
           _scLJT::P64 = P64[_scLKS::P64 + 80];
           I64[Hp - 80] = sat_scLKR_info;
           P64[Hp - 64] = _scLJ4::P64;
           P64[Hp - 56] = _scLJ5::P64;
           P64[Hp - 48] = _scLJ6::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 80;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKW_entry() //  [R1]
         { info_tbl: [(ccMgT,
                       label: sat_scLKW_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMgT: // global
           _scLKW::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMgU; else goto ccMgV;
       ccMgV: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccMgX; else goto ccMgW;
       ccMgX: // global
           HpAlloc = 88;
           goto ccMgU;
       ccMgU: // global
           R1 = _scLKW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMgW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKW::P64;
           _scLJ4::P64 = P64[_scLKW::P64 + 16];
           _scLJ5::P64 = P64[_scLKW::P64 + 24];
           _scLJ6::P64 = P64[_scLKW::P64 + 32];
           _scLJo::P64 = P64[_scLKW::P64 + 40];
           _scLJt::P64 = P64[_scLKW::P64 + 48];
           _scLJy::P64 = P64[_scLKW::P64 + 56];
           _scLJD::P64 = P64[_scLKW::P64 + 64];
           _scLJI::P64 = P64[_scLKW::P64 + 72];
           _scLJN::P64 = P64[_scLKW::P64 + 80];
           _scLJT::P64 = P64[_scLKW::P64 + 88];
           I64[Hp - 80] = sat_scLKS_info;
           P64[Hp - 64] = _scLJ4::P64;
           P64[Hp - 56] = _scLJ5::P64;
           P64[Hp - 48] = _scLJ6::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           I64[Sp - 24] = block_ccMgQ_info;
           R4 = Hp - 80;
           R3 = _scLJo::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMgQ() //  [R1, R2]
         { info_tbl: [(ccMgQ,
                       label: block_ccMgQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMgQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMh0; else goto ccMgZ;
       ccMh0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMgZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLKX_entry() //  [R1]
         { info_tbl: [(ccMh1,
                       label: sat_scLKX_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMh1: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccMh5; else goto ccMh4;
       ccMh5: // global
           HpAlloc = 96;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMh4: // global
           _scLJ4::P64 = P64[R1 + 16];
           _scLJ5::P64 = P64[R1 + 24];
           _scLJ6::P64 = P64[R1 + 32];
           _scLJo::P64 = P64[R1 + 40];
           _scLJt::P64 = P64[R1 + 48];
           _scLJy::P64 = P64[R1 + 56];
           _scLJD::P64 = P64[R1 + 64];
           _scLJI::P64 = P64[R1 + 72];
           _scLJN::P64 = P64[R1 + 80];
           _scLJT::P64 = P64[R1 + 88];
           I64[Hp - 88] = sat_scLKW_info;
           P64[Hp - 72] = _scLJ4::P64;
           P64[Hp - 64] = _scLJ5::P64;
           P64[Hp - 56] = _scLJ6::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 88;
           R2 = lvl6_rcHpB_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLKY_entry() //  [R1]
         { info_tbl: [(ccMh6,
                       label: sat_scLKY_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMh6: // global
           _scLKY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMh7; else goto ccMh8;
       ccMh8: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccMha; else goto ccMh9;
       ccMha: // global
           HpAlloc = 96;
           goto ccMh7;
       ccMh7: // global
           R1 = _scLKY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMh9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLKY::P64;
           _scLJ4::P64 = P64[_scLKY::P64 + 16];
           _scLJ5::P64 = P64[_scLKY::P64 + 24];
           _scLJ6::P64 = P64[_scLKY::P64 + 32];
           _scLJo::P64 = P64[_scLKY::P64 + 40];
           _scLJt::P64 = P64[_scLKY::P64 + 48];
           _scLJy::P64 = P64[_scLKY::P64 + 56];
           _scLJD::P64 = P64[_scLKY::P64 + 64];
           _scLJI::P64 = P64[_scLKY::P64 + 72];
           _scLJN::P64 = P64[_scLKY::P64 + 80];
           _scLJT::P64 = P64[_scLKY::P64 + 88];
           I64[Hp - 88] = sat_scLKX_info;
           P64[Hp - 72] = _scLJ4::P64;
           P64[Hp - 64] = _scLJ5::P64;
           P64[Hp - 56] = _scLJ6::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 88;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLL2_entry() //  [R1]
         { info_tbl: [(ccMhe,
                       label: sat_scLL2_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMhe: // global
           _scLL2::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMhf; else goto ccMhg;
       ccMhg: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccMhi; else goto ccMhh;
       ccMhi: // global
           HpAlloc = 96;
           goto ccMhf;
       ccMhf: // global
           R1 = _scLL2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMhh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLL2::P64;
           _scLJ4::P64 = P64[_scLL2::P64 + 16];
           _scLJ5::P64 = P64[_scLL2::P64 + 24];
           _scLJ6::P64 = P64[_scLL2::P64 + 32];
           _scLJj::P64 = P64[_scLL2::P64 + 40];
           _scLJo::P64 = P64[_scLL2::P64 + 48];
           _scLJt::P64 = P64[_scLL2::P64 + 56];
           _scLJy::P64 = P64[_scLL2::P64 + 64];
           _scLJD::P64 = P64[_scLL2::P64 + 72];
           _scLJI::P64 = P64[_scLL2::P64 + 80];
           _scLJN::P64 = P64[_scLL2::P64 + 88];
           _scLJT::P64 = P64[_scLL2::P64 + 96];
           I64[Hp - 88] = sat_scLKY_info;
           P64[Hp - 72] = _scLJ4::P64;
           P64[Hp - 64] = _scLJ5::P64;
           P64[Hp - 56] = _scLJ6::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           I64[Sp - 24] = block_ccMhb_info;
           R4 = Hp - 88;
           R3 = _scLJj::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMhb() //  [R1, R2]
         { info_tbl: [(ccMhb,
                       label: block_ccMhb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMhb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMhl; else goto ccMhk;
       ccMhl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMhk: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLL3_entry() //  [R1]
         { info_tbl: [(ccMhm,
                       label: sat_scLL3_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMhm: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccMhq; else goto ccMhp;
       ccMhq: // global
           HpAlloc = 104;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMhp: // global
           _scLJ4::P64 = P64[R1 + 16];
           _scLJ5::P64 = P64[R1 + 24];
           _scLJ6::P64 = P64[R1 + 32];
           _scLJj::P64 = P64[R1 + 40];
           _scLJo::P64 = P64[R1 + 48];
           _scLJt::P64 = P64[R1 + 56];
           _scLJy::P64 = P64[R1 + 64];
           _scLJD::P64 = P64[R1 + 72];
           _scLJI::P64 = P64[R1 + 80];
           _scLJN::P64 = P64[R1 + 88];
           _scLJT::P64 = P64[R1 + 96];
           I64[Hp - 96] = sat_scLL2_info;
           P64[Hp - 80] = _scLJ4::P64;
           P64[Hp - 72] = _scLJ5::P64;
           P64[Hp - 64] = _scLJ6::P64;
           P64[Hp - 56] = _scLJj::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 96;
           R2 = lvl5_rcHpA_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLL4_entry() //  [R1]
         { info_tbl: [(ccMhr,
                       label: sat_scLL4_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMhr: // global
           _scLL4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMhs; else goto ccMht;
       ccMht: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccMhv; else goto ccMhu;
       ccMhv: // global
           HpAlloc = 104;
           goto ccMhs;
       ccMhs: // global
           R1 = _scLL4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMhu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLL4::P64;
           _scLJ4::P64 = P64[_scLL4::P64 + 16];
           _scLJ5::P64 = P64[_scLL4::P64 + 24];
           _scLJ6::P64 = P64[_scLL4::P64 + 32];
           _scLJj::P64 = P64[_scLL4::P64 + 40];
           _scLJo::P64 = P64[_scLL4::P64 + 48];
           _scLJt::P64 = P64[_scLL4::P64 + 56];
           _scLJy::P64 = P64[_scLL4::P64 + 64];
           _scLJD::P64 = P64[_scLL4::P64 + 72];
           _scLJI::P64 = P64[_scLL4::P64 + 80];
           _scLJN::P64 = P64[_scLL4::P64 + 88];
           _scLJT::P64 = P64[_scLL4::P64 + 96];
           I64[Hp - 96] = sat_scLL3_info;
           P64[Hp - 80] = _scLJ4::P64;
           P64[Hp - 72] = _scLJ5::P64;
           P64[Hp - 64] = _scLJ6::P64;
           P64[Hp - 56] = _scLJj::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 96;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLL8_entry() //  [R1]
         { info_tbl: [(ccMhz,
                       label: sat_scLL8_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMhz: // global
           _scLL8::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMhA; else goto ccMhB;
       ccMhB: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccMhD; else goto ccMhC;
       ccMhD: // global
           HpAlloc = 104;
           goto ccMhA;
       ccMhA: // global
           R1 = _scLL8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMhC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLL8::P64;
           _scLJ4::P64 = P64[_scLL8::P64 + 16];
           _scLJ5::P64 = P64[_scLL8::P64 + 24];
           _scLJ6::P64 = P64[_scLL8::P64 + 32];
           _scLJe::P64 = P64[_scLL8::P64 + 40];
           _scLJj::P64 = P64[_scLL8::P64 + 48];
           _scLJo::P64 = P64[_scLL8::P64 + 56];
           _scLJt::P64 = P64[_scLL8::P64 + 64];
           _scLJy::P64 = P64[_scLL8::P64 + 72];
           _scLJD::P64 = P64[_scLL8::P64 + 80];
           _scLJI::P64 = P64[_scLL8::P64 + 88];
           _scLJN::P64 = P64[_scLL8::P64 + 96];
           _scLJT::P64 = P64[_scLL8::P64 + 104];
           I64[Hp - 96] = sat_scLL4_info;
           P64[Hp - 80] = _scLJ4::P64;
           P64[Hp - 72] = _scLJ5::P64;
           P64[Hp - 64] = _scLJ6::P64;
           P64[Hp - 56] = _scLJj::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           I64[Sp - 24] = block_ccMhw_info;
           R4 = Hp - 96;
           R3 = _scLJe::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMhw() //  [R1, R2]
         { info_tbl: [(ccMhw,
                       label: block_ccMhw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMhw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMhG; else goto ccMhF;
       ccMhG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMhF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLL9_entry() //  [R1]
         { info_tbl: [(ccMhH,
                       label: sat_scLL9_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMhH: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccMhL; else goto ccMhK;
       ccMhL: // global
           HpAlloc = 112;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMhK: // global
           _scLJ4::P64 = P64[R1 + 16];
           _scLJ5::P64 = P64[R1 + 24];
           _scLJ6::P64 = P64[R1 + 32];
           _scLJe::P64 = P64[R1 + 40];
           _scLJj::P64 = P64[R1 + 48];
           _scLJo::P64 = P64[R1 + 56];
           _scLJt::P64 = P64[R1 + 64];
           _scLJy::P64 = P64[R1 + 72];
           _scLJD::P64 = P64[R1 + 80];
           _scLJI::P64 = P64[R1 + 88];
           _scLJN::P64 = P64[R1 + 96];
           _scLJT::P64 = P64[R1 + 104];
           I64[Hp - 104] = sat_scLL8_info;
           P64[Hp - 88] = _scLJ4::P64;
           P64[Hp - 80] = _scLJ5::P64;
           P64[Hp - 72] = _scLJ6::P64;
           P64[Hp - 64] = _scLJe::P64;
           P64[Hp - 56] = _scLJj::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 104;
           R2 = lvl4_rcHpz_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLLa_entry() //  [R1]
         { info_tbl: [(ccMhM,
                       label: sat_scLLa_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMhM: // global
           _scLLa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMhN; else goto ccMhO;
       ccMhO: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccMhQ; else goto ccMhP;
       ccMhQ: // global
           HpAlloc = 112;
           goto ccMhN;
       ccMhN: // global
           R1 = _scLLa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMhP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLLa::P64;
           _scLJ4::P64 = P64[_scLLa::P64 + 16];
           _scLJ5::P64 = P64[_scLLa::P64 + 24];
           _scLJ6::P64 = P64[_scLLa::P64 + 32];
           _scLJe::P64 = P64[_scLLa::P64 + 40];
           _scLJj::P64 = P64[_scLLa::P64 + 48];
           _scLJo::P64 = P64[_scLLa::P64 + 56];
           _scLJt::P64 = P64[_scLLa::P64 + 64];
           _scLJy::P64 = P64[_scLLa::P64 + 72];
           _scLJD::P64 = P64[_scLLa::P64 + 80];
           _scLJI::P64 = P64[_scLLa::P64 + 88];
           _scLJN::P64 = P64[_scLLa::P64 + 96];
           _scLJT::P64 = P64[_scLLa::P64 + 104];
           I64[Hp - 104] = sat_scLL9_info;
           P64[Hp - 88] = _scLJ4::P64;
           P64[Hp - 80] = _scLJ5::P64;
           P64[Hp - 72] = _scLJ6::P64;
           P64[Hp - 64] = _scLJe::P64;
           P64[Hp - 56] = _scLJj::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 104;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLLe_entry() //  [R1]
         { info_tbl: [(ccMhU,
                       label: sat_scLLe_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMhU: // global
           _scLLe::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMhV; else goto ccMhW;
       ccMhW: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccMhY; else goto ccMhX;
       ccMhY: // global
           HpAlloc = 112;
           goto ccMhV;
       ccMhV: // global
           R1 = _scLLe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMhX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLLe::P64;
           _scLJ4::P64 = P64[_scLLe::P64 + 16];
           _scLJ5::P64 = P64[_scLLe::P64 + 24];
           _scLJ6::P64 = P64[_scLLe::P64 + 32];
           _scLJ9::P64 = P64[_scLLe::P64 + 40];
           _scLJe::P64 = P64[_scLLe::P64 + 48];
           _scLJj::P64 = P64[_scLLe::P64 + 56];
           _scLJo::P64 = P64[_scLLe::P64 + 64];
           _scLJt::P64 = P64[_scLLe::P64 + 72];
           _scLJy::P64 = P64[_scLLe::P64 + 80];
           _scLJD::P64 = P64[_scLLe::P64 + 88];
           _scLJI::P64 = P64[_scLLe::P64 + 96];
           _scLJN::P64 = P64[_scLLe::P64 + 104];
           _scLJT::P64 = P64[_scLLe::P64 + 112];
           I64[Hp - 104] = sat_scLLa_info;
           P64[Hp - 88] = _scLJ4::P64;
           P64[Hp - 80] = _scLJ5::P64;
           P64[Hp - 72] = _scLJ6::P64;
           P64[Hp - 64] = _scLJe::P64;
           P64[Hp - 56] = _scLJj::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           I64[Sp - 24] = block_ccMhR_info;
           R4 = Hp - 104;
           R3 = _scLJ9::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMhR() //  [R1, R2]
         { info_tbl: [(ccMhR,
                       label: block_ccMhR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMhR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMi1; else goto ccMi0;
       ccMi1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMi0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLLf_entry() //  [R1]
         { info_tbl: [(ccMi2,
                       label: sat_scLLf_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMi2: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccMi6; else goto ccMi5;
       ccMi6: // global
           HpAlloc = 120;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMi5: // global
           _scLJ4::P64 = P64[R1 + 16];
           _scLJ5::P64 = P64[R1 + 24];
           _scLJ6::P64 = P64[R1 + 32];
           _scLJ9::P64 = P64[R1 + 40];
           _scLJe::P64 = P64[R1 + 48];
           _scLJj::P64 = P64[R1 + 56];
           _scLJo::P64 = P64[R1 + 64];
           _scLJt::P64 = P64[R1 + 72];
           _scLJy::P64 = P64[R1 + 80];
           _scLJD::P64 = P64[R1 + 88];
           _scLJI::P64 = P64[R1 + 96];
           _scLJN::P64 = P64[R1 + 104];
           _scLJT::P64 = P64[R1 + 112];
           I64[Hp - 112] = sat_scLLe_info;
           P64[Hp - 96] = _scLJ4::P64;
           P64[Hp - 88] = _scLJ5::P64;
           P64[Hp - 80] = _scLJ6::P64;
           P64[Hp - 72] = _scLJ9::P64;
           P64[Hp - 64] = _scLJe::P64;
           P64[Hp - 56] = _scLJj::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 112;
           R2 = lvl3_rcHpy_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLLg_entry() //  [R1]
         { info_tbl: [(ccMi7,
                       label: sat_scLLg_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMi7: // global
           _scLLg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMi8; else goto ccMi9;
       ccMi9: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccMib; else goto ccMia;
       ccMib: // global
           HpAlloc = 120;
           goto ccMi8;
       ccMi8: // global
           R1 = _scLLg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMia: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLLg::P64;
           _scLJ4::P64 = P64[_scLLg::P64 + 16];
           _scLJ5::P64 = P64[_scLLg::P64 + 24];
           _scLJ6::P64 = P64[_scLLg::P64 + 32];
           _scLJ9::P64 = P64[_scLLg::P64 + 40];
           _scLJe::P64 = P64[_scLLg::P64 + 48];
           _scLJj::P64 = P64[_scLLg::P64 + 56];
           _scLJo::P64 = P64[_scLLg::P64 + 64];
           _scLJt::P64 = P64[_scLLg::P64 + 72];
           _scLJy::P64 = P64[_scLLg::P64 + 80];
           _scLJD::P64 = P64[_scLLg::P64 + 88];
           _scLJI::P64 = P64[_scLLg::P64 + 96];
           _scLJN::P64 = P64[_scLLg::P64 + 104];
           _scLJT::P64 = P64[_scLLg::P64 + 112];
           I64[Hp - 112] = sat_scLLf_info;
           P64[Hp - 96] = _scLJ4::P64;
           P64[Hp - 88] = _scLJ5::P64;
           P64[Hp - 80] = _scLJ6::P64;
           P64[Hp - 72] = _scLJ9::P64;
           P64[Hp - 64] = _scLJe::P64;
           P64[Hp - 56] = _scLJj::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 112;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLLk_entry() //  [R1]
         { info_tbl: [(ccMic,
                       label: sat_scLLk_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMic: // global
           if ((Sp + -128) < SpLim) (likely: False) goto ccMij; else goto ccMik;
       ccMij: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMik: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 128] = block_ccMbh_info;
           _scLJ4::P64 = P64[R1 + 24];
           _scLJ5::P64 = P64[R1 + 32];
           _scLJ6::P64 = P64[R1 + 40];
           _scLJ9::P64 = P64[R1 + 48];
           _scLJe::P64 = P64[R1 + 56];
           _scLJj::P64 = P64[R1 + 64];
           _scLJo::P64 = P64[R1 + 72];
           _scLJt::P64 = P64[R1 + 80];
           _scLJy::P64 = P64[R1 + 88];
           _scLJD::P64 = P64[R1 + 96];
           _scLJI::P64 = P64[R1 + 104];
           _scLJN::P64 = P64[R1 + 112];
           _scLJT::P64 = P64[R1 + 120];
           R1 = P64[R1 + 16];
           P64[Sp - 120] = _scLJ4::P64;
           P64[Sp - 112] = _scLJ5::P64;
           P64[Sp - 104] = _scLJ6::P64;
           P64[Sp - 96] = _scLJ9::P64;
           P64[Sp - 88] = _scLJe::P64;
           P64[Sp - 80] = _scLJj::P64;
           P64[Sp - 72] = _scLJo::P64;
           P64[Sp - 64] = _scLJt::P64;
           P64[Sp - 56] = _scLJy::P64;
           P64[Sp - 48] = _scLJD::P64;
           P64[Sp - 40] = _scLJI::P64;
           P64[Sp - 32] = _scLJN::P64;
           P64[Sp - 24] = _scLJT::P64;
           Sp = Sp - 128;
           if (R1 & 7 != 0) goto ucMir; else goto ccMbi;
       ucMir: // global
           call _ccMbh(R1) args: 0, res: 0, upd: 0;
       ccMbi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMbh() //  [R1]
         { info_tbl: [(ccMbh,
                       label: block_ccMbh_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMbh: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccMin; else goto ccMim;
       ccMin: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccMim: // global
           _scLJY::I64 = I64[R1 + 7];
           I64[Hp - 112] = sat_scLLg_info;
           P64[Hp - 96] = P64[Sp + 8];
           P64[Hp - 88] = P64[Sp + 16];
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 32];
           P64[Hp - 64] = P64[Sp + 40];
           P64[Hp - 56] = P64[Sp + 48];
           P64[Hp - 48] = P64[Sp + 56];
           P64[Hp - 40] = P64[Sp + 64];
           P64[Hp - 32] = P64[Sp + 72];
           P64[Hp - 24] = P64[Sp + 80];
           P64[Hp - 16] = P64[Sp + 88];
           P64[Hp - 8] = P64[Sp + 96];
           P64[Hp] = P64[Sp + 104];
           I64[Sp + 104] = block_ccMig_info;
           R3 = Hp - 112;
           R2 = _scLJY::I64;
           Sp = Sp + 104;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMig() //  [R1, R2]
         { info_tbl: [(ccMig,
                       label: block_ccMig_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMig: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMiq; else goto ccMip;
       ccMiq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMip: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLLl_entry() //  [R1]
         { info_tbl: [(ccMis,
                       label: sat_scLLl_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMis: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccMiw; else goto ccMiv;
       ccMiw: // global
           HpAlloc = 128;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMiv: // global
           _scLIU::P64 = P64[R1 + 16];
           _scLJ4::P64 = P64[R1 + 24];
           _scLJ5::P64 = P64[R1 + 32];
           _scLJ6::P64 = P64[R1 + 40];
           _scLJ9::P64 = P64[R1 + 48];
           _scLJe::P64 = P64[R1 + 56];
           _scLJj::P64 = P64[R1 + 64];
           _scLJo::P64 = P64[R1 + 72];
           _scLJt::P64 = P64[R1 + 80];
           _scLJy::P64 = P64[R1 + 88];
           _scLJD::P64 = P64[R1 + 96];
           _scLJI::P64 = P64[R1 + 104];
           _scLJN::P64 = P64[R1 + 112];
           _scLJT::P64 = P64[R1 + 120];
           I64[Hp - 120] = sat_scLLk_info;
           P64[Hp - 104] = _scLIU::P64;
           P64[Hp - 96] = _scLJ4::P64;
           P64[Hp - 88] = _scLJ5::P64;
           P64[Hp - 80] = _scLJ6::P64;
           P64[Hp - 72] = _scLJ9::P64;
           P64[Hp - 64] = _scLJe::P64;
           P64[Hp - 56] = _scLJj::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 120;
           R2 = lvl2_rcHpx_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLLm_entry() //  [R1]
         { info_tbl: [(ccMix,
                       label: sat_scLLm_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMix: // global
           _scLLm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMiy; else goto ccMiz;
       ccMiz: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccMiB; else goto ccMiA;
       ccMiB: // global
           HpAlloc = 128;
           goto ccMiy;
       ccMiy: // global
           R1 = _scLLm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMiA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLLm::P64;
           _scLIU::P64 = P64[_scLLm::P64 + 16];
           _scLJ4::P64 = P64[_scLLm::P64 + 24];
           _scLJ5::P64 = P64[_scLLm::P64 + 32];
           _scLJ6::P64 = P64[_scLLm::P64 + 40];
           _scLJ9::P64 = P64[_scLLm::P64 + 48];
           _scLJe::P64 = P64[_scLLm::P64 + 56];
           _scLJj::P64 = P64[_scLLm::P64 + 64];
           _scLJo::P64 = P64[_scLLm::P64 + 72];
           _scLJt::P64 = P64[_scLLm::P64 + 80];
           _scLJy::P64 = P64[_scLLm::P64 + 88];
           _scLJD::P64 = P64[_scLLm::P64 + 96];
           _scLJI::P64 = P64[_scLLm::P64 + 104];
           _scLJN::P64 = P64[_scLLm::P64 + 112];
           _scLJT::P64 = P64[_scLLm::P64 + 120];
           I64[Hp - 120] = sat_scLLl_info;
           P64[Hp - 104] = _scLIU::P64;
           P64[Hp - 96] = _scLJ4::P64;
           P64[Hp - 88] = _scLJ5::P64;
           P64[Hp - 80] = _scLJ6::P64;
           P64[Hp - 72] = _scLJ9::P64;
           P64[Hp - 64] = _scLJe::P64;
           P64[Hp - 56] = _scLJj::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 120;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLLq_entry() //  [R1]
         { info_tbl: [(ccMiC,
                       label: sat_scLLq_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMiC: // global
           if ((Sp + -136) < SpLim) (likely: False) goto ccMiJ; else goto ccMiK;
       ccMiJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMiK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 136] = block_ccMb0_info;
           _scLIU::P64 = P64[R1 + 24];
           _scLJ4::P64 = P64[R1 + 32];
           _scLJ5::P64 = P64[R1 + 40];
           _scLJ6::P64 = P64[R1 + 48];
           _scLJ9::P64 = P64[R1 + 56];
           _scLJe::P64 = P64[R1 + 64];
           _scLJj::P64 = P64[R1 + 72];
           _scLJo::P64 = P64[R1 + 80];
           _scLJt::P64 = P64[R1 + 88];
           _scLJy::P64 = P64[R1 + 96];
           _scLJD::P64 = P64[R1 + 104];
           _scLJI::P64 = P64[R1 + 112];
           _scLJN::P64 = P64[R1 + 120];
           _scLJT::P64 = P64[R1 + 128];
           R1 = P64[R1 + 16];
           P64[Sp - 128] = _scLIU::P64;
           P64[Sp - 120] = _scLJ4::P64;
           P64[Sp - 112] = _scLJ5::P64;
           P64[Sp - 104] = _scLJ6::P64;
           P64[Sp - 96] = _scLJ9::P64;
           P64[Sp - 88] = _scLJe::P64;
           P64[Sp - 80] = _scLJj::P64;
           P64[Sp - 72] = _scLJo::P64;
           P64[Sp - 64] = _scLJt::P64;
           P64[Sp - 56] = _scLJy::P64;
           P64[Sp - 48] = _scLJD::P64;
           P64[Sp - 40] = _scLJI::P64;
           P64[Sp - 32] = _scLJN::P64;
           P64[Sp - 24] = _scLJT::P64;
           Sp = Sp - 136;
           if (R1 & 7 != 0) goto ucMiR; else goto ccMb1;
       ucMiR: // global
           call _ccMb0(R1) args: 0, res: 0, upd: 0;
       ccMb1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMb0() //  [R1]
         { info_tbl: [(ccMb0,
                       label: block_ccMb0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMb0: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccMiN; else goto ccMiM;
       ccMiN: // global
           HpAlloc = 128;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccMiM: // global
           _scLJV::I64 = I64[R1 + 7];
           I64[Hp - 120] = sat_scLLm_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = P64[Sp + 16];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = P64[Sp + 56];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = P64[Sp + 72];
           P64[Hp - 32] = P64[Sp + 80];
           P64[Hp - 24] = P64[Sp + 88];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           I64[Sp + 112] = block_ccMiG_info;
           R3 = Hp - 120;
           R2 = _scLJV::I64;
           Sp = Sp + 112;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMiG() //  [R1, R2]
         { info_tbl: [(ccMiG,
                       label: block_ccMiG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMiG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMiQ; else goto ccMiP;
       ccMiQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMiP: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLLr_entry() //  [R1]
         { info_tbl: [(ccMiS,
                       label: sat_scLLr_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMiS: // global
           _scLLr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMiT; else goto ccMiU;
       ccMiU: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccMiW; else goto ccMiV;
       ccMiW: // global
           HpAlloc = 136;
           goto ccMiT;
       ccMiT: // global
           R1 = _scLLr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMiV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLLr::P64;
           _scLIT::P64 = P64[_scLLr::P64 + 16];
           _scLIU::P64 = P64[_scLLr::P64 + 24];
           _scLJ4::P64 = P64[_scLLr::P64 + 32];
           _scLJ5::P64 = P64[_scLLr::P64 + 40];
           _scLJ6::P64 = P64[_scLLr::P64 + 48];
           _scLJ9::P64 = P64[_scLLr::P64 + 56];
           _scLJe::P64 = P64[_scLLr::P64 + 64];
           _scLJj::P64 = P64[_scLLr::P64 + 72];
           _scLJo::P64 = P64[_scLLr::P64 + 80];
           _scLJt::P64 = P64[_scLLr::P64 + 88];
           _scLJy::P64 = P64[_scLLr::P64 + 96];
           _scLJD::P64 = P64[_scLLr::P64 + 104];
           _scLJI::P64 = P64[_scLLr::P64 + 112];
           _scLJN::P64 = P64[_scLLr::P64 + 120];
           _scLJT::P64 = P64[_scLLr::P64 + 128];
           I64[Hp - 128] = sat_scLLq_info;
           P64[Hp - 112] = _scLIT::P64;
           P64[Hp - 104] = _scLIU::P64;
           P64[Hp - 96] = _scLJ4::P64;
           P64[Hp - 88] = _scLJ5::P64;
           P64[Hp - 80] = _scLJ6::P64;
           P64[Hp - 72] = _scLJ9::P64;
           P64[Hp - 64] = _scLJe::P64;
           P64[Hp - 56] = _scLJj::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = _scLJT::P64;
           R3 = Hp - 128;
           R2 = lvl1_rcHpw_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_scLJS_entry() //  [R1, R2]
         { info_tbl: [(ccMiX,
                       label: p_scLJS_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMiX: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccMj1; else goto ccMj0;
       ccMj1: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccMj0: // global
           _scLIT::P64 = P64[R1 + 7];
           _scLIU::P64 = P64[R1 + 15];
           _scLJ4::P64 = P64[R1 + 23];
           _scLJ5::P64 = P64[R1 + 31];
           _scLJ6::P64 = P64[R1 + 39];
           _scLJ9::P64 = P64[R1 + 47];
           _scLJe::P64 = P64[R1 + 55];
           _scLJj::P64 = P64[R1 + 63];
           _scLJo::P64 = P64[R1 + 71];
           _scLJt::P64 = P64[R1 + 79];
           _scLJy::P64 = P64[R1 + 87];
           _scLJD::P64 = P64[R1 + 95];
           _scLJI::P64 = P64[R1 + 103];
           _scLJN::P64 = P64[R1 + 111];
           I64[Hp - 128] = sat_scLLr_info;
           P64[Hp - 112] = _scLIT::P64;
           P64[Hp - 104] = _scLIU::P64;
           P64[Hp - 96] = _scLJ4::P64;
           P64[Hp - 88] = _scLJ5::P64;
           P64[Hp - 80] = _scLJ6::P64;
           P64[Hp - 72] = _scLJ9::P64;
           P64[Hp - 64] = _scLJe::P64;
           P64[Hp - 56] = _scLJj::P64;
           P64[Hp - 48] = _scLJo::P64;
           P64[Hp - 40] = _scLJt::P64;
           P64[Hp - 32] = _scLJy::P64;
           P64[Hp - 24] = _scLJD::P64;
           P64[Hp - 16] = _scLJI::P64;
           P64[Hp - 8] = _scLJN::P64;
           P64[Hp] = R2;
           R3 = Hp - 128;
           R2 = lvl_rcHpv_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLLv_entry() //  [R1]
         { info_tbl: [(ccMjg,
                       label: sat_scLLv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMjg: // global
           _scLLv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMjh; else goto ccMji;
       ccMji: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMjk; else goto ccMjj;
       ccMjk: // global
           HpAlloc = 24;
           goto ccMjh;
       ccMjh: // global
           R1 = _scLLv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMjj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLLv::P64;
           _scLJS::P64 = P64[_scLLv::P64 + 16];
           _scLLt::P64 = P64[_scLLv::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _scLLt::P64;
           R2 = Hp - 14;
           R1 = _scLJS::P64;
           Sp = Sp - 16;
           call p_scLJS_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLLw_entry() //  [R1, R2]
         { info_tbl: [(ccMjm,
                       label: sat_scLLw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMjm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccMjq; else goto ccMjp;
       ccMjq: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccMjp: // global
           _scLJS::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_scLLv_info;
           P64[Hp - 32] = _scLJS::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stats.$fShowGCDetails_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(ccMjr,
                       label: GHC.Stats.$fShowGCDetails_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMjr: // global
           if ((Sp + -120) < SpLim) (likely: False) goto ccMjs; else goto ccMjt;
       ccMjs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fShowGCDetails_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccMjt: // global
           I64[Sp - 16] = block_ccM7r_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucMjC; else goto ccM7s;
       ucMjC: // global
           call _ccM7r(R1) args: 0, res: 0, upd: 0;
       ccM7s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccM7r() //  [R1]
         { info_tbl: [(ccM7r,
                       label: block_ccM7r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM7r: // global
           I64[Sp - 104] = block_ccM7w_info;
           _scLIT::P64 = P64[R1 + 7];
           _scLIU::P64 = P64[R1 + 15];
           _scLIV::P64 = P64[R1 + 23];
           _scLIW::P64 = P64[R1 + 31];
           _scLIX::P64 = P64[R1 + 39];
           _scLIY::P64 = P64[R1 + 47];
           _scLIZ::P64 = P64[R1 + 55];
           _scLJ0::P64 = P64[R1 + 63];
           _scLJ1::P64 = P64[R1 + 71];
           _scLJ2::P64 = P64[R1 + 79];
           _scLJ3::P64 = P64[R1 + 87];
           _scLJ4::P64 = P64[R1 + 95];
           _scLJ5::P64 = P64[R1 + 103];
           _scLJ6::P64 = P64[R1 + 111];
           R1 = P64[Sp + 8];
           P64[Sp - 96] = _scLIV::P64;
           P64[Sp - 88] = _scLIW::P64;
           P64[Sp - 80] = _scLIX::P64;
           P64[Sp - 72] = _scLIY::P64;
           P64[Sp - 64] = _scLIZ::P64;
           P64[Sp - 56] = _scLJ0::P64;
           P64[Sp - 48] = _scLJ1::P64;
           P64[Sp - 40] = _scLJ2::P64;
           P64[Sp - 32] = _scLJ3::P64;
           P64[Sp - 24] = _scLJ4::P64;
           P64[Sp - 16] = _scLJ5::P64;
           P64[Sp - 8] = _scLJ6::P64;
           P64[Sp] = _scLIU::P64;
           P64[Sp + 8] = _scLIT::P64;
           Sp = Sp - 104;
           if (R1 & 7 != 0) goto ucMjB; else goto ccM7x;
       ucMjB: // global
           call _ccM7w(R1) args: 0, res: 0, upd: 0;
       ccM7x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccM7w() //  [R1]
         { info_tbl: [(ccM7w,
                       label: block_ccM7w_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccM7w: // global
           Hp = Hp + 352;
           if (Hp > HpLim) (likely: False) goto ccMjx; else goto ccMjw;
       ccMjx: // global
           HpAlloc = 352;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccMjw: // global
           _scLJ8::I64 = I64[R1 + 7];
           I64[Hp - 344] = w1_scLJ9_info;
           P64[Hp - 328] = P64[Sp + 8];
           I64[Hp - 320] = w2_scLJe_info;
           P64[Hp - 304] = P64[Sp + 16];
           I64[Hp - 296] = w3_scLJj_info;
           P64[Hp - 280] = P64[Sp + 24];
           I64[Hp - 272] = w4_scLJo_info;
           P64[Hp - 256] = P64[Sp + 32];
           I64[Hp - 248] = w5_scLJt_info;
           P64[Hp - 232] = P64[Sp + 40];
           I64[Hp - 224] = w6_scLJy_info;
           P64[Hp - 208] = P64[Sp + 48];
           I64[Hp - 200] = w7_scLJD_info;
           P64[Hp - 184] = P64[Sp + 56];
           I64[Hp - 176] = w8_scLJI_info;
           P64[Hp - 160] = P64[Sp + 64];
           I64[Hp - 152] = w9_scLJN_info;
           P64[Hp - 136] = P64[Sp + 72];
           I64[Hp - 128] = p_scLJS_info;
           P64[Hp - 120] = P64[Sp + 112];
           P64[Hp - 112] = P64[Sp + 104];
           P64[Hp - 104] = P64[Sp + 80];
           P64[Hp - 96] = P64[Sp + 88];
           P64[Hp - 88] = P64[Sp + 96];
           P64[Hp - 80] = Hp - 344;
           P64[Hp - 72] = Hp - 320;
           P64[Hp - 64] = Hp - 296;
           P64[Hp - 56] = Hp - 272;
           P64[Hp - 48] = Hp - 248;
           P64[Hp - 40] = Hp - 224;
           P64[Hp - 32] = Hp - 200;
           P64[Hp - 24] = Hp - 176;
           P64[Hp - 16] = Hp - 152;
           _ccMaN::P64 = Hp - 127;
           if (%MO_S_Lt_W64(_scLJ8::I64, 11)) goto ccMjz; else goto ccMjA;
       ccMjz: // global
           Hp = Hp - 16;
           R1 = _ccMaN::P64;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccMjA: // global
           I64[Hp - 8] = sat_scLLw_info;
           P64[Hp] = _ccMaN::P64;
           R1 = Hp - 7;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.314896304 UTC

[section ""data" . GHC.Stats.$fShowGCDetails2_closure" {
     GHC.Stats.$fShowGCDetails2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.316815873 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_$cshow_closure" {
     GHC.Stats.$fShowGCDetails_$cshow_closure:
         const GHC.Stats.$fShowGCDetails_$cshow_info;
         const 0;
 },
 GHC.Stats.$fShowGCDetails_$cshow_entry() //  [R2]
         { info_tbl: [(ccMse,
                       label: GHC.Stats.$fShowGCDetails_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMse: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMsf; else goto ccMsg;
       ccMsf: // global
           R2 = R2;
           R1 = GHC.Stats.$fShowGCDetails_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccMsg: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Stats.$fShowGCDetails_$cshowsPrec_entry(R3,
                                                            R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.321058663 UTC

[section ""data" . GHC.Stats.$fShowGCDetails1_closure" {
     GHC.Stats.$fShowGCDetails1_closure:
         const GHC.Stats.$fShowGCDetails1_info;
         const 0;
 },
 GHC.Stats.$fShowGCDetails1_entry() //  [R2]
         { info_tbl: [(ccMst,
                       label: GHC.Stats.$fShowGCDetails1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMst: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           call GHC.Stats.$fShowGCDetails_$cshowsPrec_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.324508952 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_$cshowList_closure" {
     GHC.Stats.$fShowGCDetails_$cshowList_closure:
         const GHC.Stats.$fShowGCDetails_$cshowList_info;
         const 0;
 },
 GHC.Stats.$fShowGCDetails_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(ccMsE,
                       label: GHC.Stats.$fShowGCDetails_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMsE: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.327883246 UTC

[section ""data" . GHC.Stats.$fShowGCDetails_closure" {
     GHC.Stats.$fShowGCDetails_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Stats.$fShowGCDetails_$cshowsPrec_closure+2;
         const GHC.Stats.$fShowGCDetails_$cshow_closure+1;
         const GHC.Stats.$fShowGCDetails_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.330378283 UTC

[section ""cstring" . lvl16_rcHpL_bytes" {
     lvl16_rcHpL_bytes:
         I8[] [82,84,83,83,116,97,116,115,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.331992418 UTC

[section ""cstring" . lvl17_rcHpM_bytes" {
     lvl17_rcHpM_bytes:
         I8[] [103,99,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.333669102 UTC

[section ""cstring" . lvl18_rcHpN_bytes" {
     lvl18_rcHpN_bytes:
         I8[] [109,97,106,111,114,95,103,99,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.335260647 UTC

[section ""cstring" . lvl19_rcHpO_bytes" {
     lvl19_rcHpO_bytes:
         I8[] [97,108,108,111,99,97,116,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.338027147 UTC

[section ""cstring" . lvl20_rcHpP_bytes" {
     lvl20_rcHpP_bytes:
         I8[] [109,97,120,95,108,105,118,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.339674045 UTC

[section ""cstring" . lvl21_rcHpQ_bytes" {
     lvl21_rcHpQ_bytes:
         I8[] [109,97,120,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.341367616 UTC

[section ""cstring" . lvl22_rcHpR_bytes" {
     lvl22_rcHpR_bytes:
         I8[] [109,97,120,95,99,111,109,112,97,99,116,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.343004474 UTC

[section ""cstring" . lvl23_rcHpS_bytes" {
     lvl23_rcHpS_bytes:
         I8[] [109,97,120,95,115,108,111,112,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.34466493 UTC

[section ""cstring" . lvl24_rcHpT_bytes" {
     lvl24_rcHpT_bytes:
         I8[] [109,97,120,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.346738953 UTC

[section ""cstring" . lvl25_rcHpU_bytes" {
     lvl25_rcHpU_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,108,105,118,101,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.348366135 UTC

[section ""cstring" . lvl26_rcHpV_bytes" {
     lvl26_rcHpV_bytes:
         I8[] [99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.349984447 UTC

[section ""cstring" . lvl27_rcHpW_bytes" {
     lvl27_rcHpW_bytes:
         I8[] [112,97,114,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.351630612 UTC

[section ""cstring" . lvl28_rcHpX_bytes" {
     lvl28_rcHpX_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.353232005 UTC

[section ""cstring" . lvl29_rcHpY_bytes" {
     lvl29_rcHpY_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.354947036 UTC

[section ""cstring" . lvl30_rcHpZ_bytes" {
     lvl30_rcHpZ_bytes:
         I8[] [109,117,116,97,116,111,114,95,99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.356542183 UTC

[section ""cstring" . lvl31_rcHq0_bytes" {
     lvl31_rcHq0_bytes:
         I8[] [109,117,116,97,116,111,114,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.35824642 UTC

[section ""cstring" . lvl32_rcHq1_bytes" {
     lvl32_rcHq1_bytes:
         I8[] [103,99,95,99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.359827612 UTC

[section ""cstring" . lvl33_rcHq2_bytes" {
     lvl33_rcHq2_bytes:
         I8[] [103,99,95,101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.362126892 UTC

[section ""cstring" . lvl34_rcHq3_bytes" {
     lvl34_rcHq3_bytes:
         I8[] [99,112,117,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.36375159 UTC

[section ""cstring" . lvl35_rcHq4_bytes" {
     lvl35_rcHq4_bytes:
         I8[] [101,108,97,112,115,101,100,95,110,115,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.365380062 UTC

[section ""cstring" . lvl36_rcHq5_bytes" {
     lvl36_rcHq5_bytes:
         I8[] [103,99,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.387996703 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_$cshowsPrec_closure" {
     GHC.Stats.$fShowRTSStats_$cshowsPrec_closure:
         const GHC.Stats.$fShowRTSStats_$cshowsPrec_info;
         const 0;
 },
 w1_scLLZ_entry() //  [R1]
         { info_tbl: [(ccMts,
                       label: w1_scLLZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMts: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccMtt; else goto ccMtu;
       ccMtt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMtu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccMtp_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMtG; else goto ccMtq;
       ucMtG: // global
           call _ccMtp(R1) args: 0, res: 0, upd: 0;
       ccMtq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMtp() //  [R1]
         { info_tbl: [(ccMtp,
                       label: block_ccMtp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMtp: // global
           _scLM1::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLM1::I64, 0)) goto ccMtE; else goto ccMtF;
       ccMtE: // global
           R2 = _scLM1::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMtF: // global
           R2 = _scLM1::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w2_scLM4_entry() //  [R1]
         { info_tbl: [(ccMtO,
                       label: w2_scLM4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMtO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccMtP; else goto ccMtQ;
       ccMtP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMtQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccMtL_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMu2; else goto ccMtM;
       ucMu2: // global
           call _ccMtL(R1) args: 0, res: 0, upd: 0;
       ccMtM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMtL() //  [R1]
         { info_tbl: [(ccMtL,
                       label: block_ccMtL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMtL: // global
           _scLM6::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLM6::I64, 0)) goto ccMu0; else goto ccMu1;
       ccMu0: // global
           R2 = _scLM6::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMu1: // global
           R2 = _scLM6::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w3_scLM9_entry() //  [R1]
         { info_tbl: [(ccMua,
                       label: w3_scLM9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMua: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccMub; else goto ccMuc;
       ccMub: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMuc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccMu7_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMuo; else goto ccMu8;
       ucMuo: // global
           call _ccMu7(R1) args: 0, res: 0, upd: 0;
       ccMu8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMu7() //  [R1]
         { info_tbl: [(ccMu7,
                       label: block_ccMu7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMu7: // global
           _scLMb::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLMb::I64, 0)) goto ccMum; else goto ccMun;
       ccMum: // global
           R2 = _scLMb::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMun: // global
           R2 = _scLMb::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w4_scLMe_entry() //  [R1]
         { info_tbl: [(ccMuw,
                       label: w4_scLMe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMuw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccMux; else goto ccMuy;
       ccMux: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMuy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccMut_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMuK; else goto ccMuu;
       ucMuK: // global
           call _ccMut(R1) args: 0, res: 0, upd: 0;
       ccMuu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMut() //  [R1]
         { info_tbl: [(ccMut,
                       label: block_ccMut_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMut: // global
           _scLMg::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLMg::I64, 0)) goto ccMuI; else goto ccMuJ;
       ccMuI: // global
           R2 = _scLMg::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMuJ: // global
           R2 = _scLMg::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w5_scLMj_entry() //  [R1]
         { info_tbl: [(ccMuS,
                       label: w5_scLMj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMuS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccMuT; else goto ccMuU;
       ccMuT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMuU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccMuP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMv6; else goto ccMuQ;
       ucMv6: // global
           call _ccMuP(R1) args: 0, res: 0, upd: 0;
       ccMuQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMuP() //  [R1]
         { info_tbl: [(ccMuP,
                       label: block_ccMuP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMuP: // global
           _scLMl::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLMl::I64, 0)) goto ccMv4; else goto ccMv5;
       ccMv4: // global
           R2 = _scLMl::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMv5: // global
           R2 = _scLMl::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w6_scLMo_entry() //  [R1]
         { info_tbl: [(ccMve,
                       label: w6_scLMo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMve: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccMvf; else goto ccMvg;
       ccMvf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMvg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccMvb_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMvs; else goto ccMvc;
       ucMvs: // global
           call _ccMvb(R1) args: 0, res: 0, upd: 0;
       ccMvc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMvb() //  [R1]
         { info_tbl: [(ccMvb,
                       label: block_ccMvb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMvb: // global
           _scLMq::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLMq::I64, 0)) goto ccMvq; else goto ccMvr;
       ccMvq: // global
           R2 = _scLMq::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMvr: // global
           R2 = _scLMq::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w7_scLMt_entry() //  [R1]
         { info_tbl: [(ccMvA,
                       label: w7_scLMt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMvA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccMvB; else goto ccMvC;
       ccMvB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMvC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccMvx_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMvO; else goto ccMvy;
       ucMvO: // global
           call _ccMvx(R1) args: 0, res: 0, upd: 0;
       ccMvy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMvx() //  [R1]
         { info_tbl: [(ccMvx,
                       label: block_ccMvx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMvx: // global
           _scLMv::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLMv::I64, 0)) goto ccMvM; else goto ccMvN;
       ccMvM: // global
           R2 = _scLMv::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMvN: // global
           R2 = _scLMv::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w8_scLMy_entry() //  [R1]
         { info_tbl: [(ccMvW,
                       label: w8_scLMy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMvW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccMvX; else goto ccMvY;
       ccMvX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMvY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccMvT_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMwa; else goto ccMvU;
       ucMwa: // global
           call _ccMvT(R1) args: 0, res: 0, upd: 0;
       ccMvU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMvT() //  [R1]
         { info_tbl: [(ccMvT,
                       label: block_ccMvT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMvT: // global
           _scLMA::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLMA::I64, 0)) goto ccMw8; else goto ccMw9;
       ccMw8: // global
           R2 = _scLMA::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMw9: // global
           R2 = _scLMA::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w9_scLMD_entry() //  [R1]
         { info_tbl: [(ccMwi,
                       label: w9_scLMD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMwi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccMwj; else goto ccMwk;
       ccMwj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMwk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccMwf_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMww; else goto ccMwg;
       ucMww: // global
           call _ccMwf(R1) args: 0, res: 0, upd: 0;
       ccMwg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMwf() //  [R1]
         { info_tbl: [(ccMwf,
                       label: block_ccMwf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMwf: // global
           _scLMF::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLMF::I64, 0)) goto ccMwu; else goto ccMwv;
       ccMwu: // global
           R2 = _scLMF::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMwv: // global
           R2 = _scLMF::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w10_scLMI_entry() //  [R1]
         { info_tbl: [(ccMwE,
                       label: w10_scLMI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMwE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccMwF; else goto ccMwG;
       ccMwF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMwG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccMwB_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMwS; else goto ccMwC;
       ucMwS: // global
           call _ccMwB(R1) args: 0, res: 0, upd: 0;
       ccMwC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMwB() //  [R1]
         { info_tbl: [(ccMwB,
                       label: block_ccMwB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMwB: // global
           _scLMK::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLMK::I64, 0)) goto ccMwQ; else goto ccMwR;
       ccMwQ: // global
           R2 = _scLMK::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMwR: // global
           R2 = _scLMK::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 w11_scLMN_entry() //  [R1]
         { info_tbl: [(ccMx0,
                       label: w11_scLMN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMx0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccMx1; else goto ccMx2;
       ccMx1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMx2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccMwX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucMxe; else goto ccMwY;
       ucMxe: // global
           call _ccMwX(R1) args: 0, res: 0, upd: 0;
       ccMwY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMwX() //  [R1]
         { info_tbl: [(ccMwX,
                       label: block_ccMwX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMwX: // global
           _scLMP::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_scLMP::I64, 0)) goto ccMxc; else goto ccMxd;
       ccMxc: // global
           R2 = _scLMP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
       ccMxd: // global
           R2 = _scLMP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 f_scLMS_entry() //  [R1]
         { info_tbl: [(ccMxj,
                       label: f_scLMS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMxj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMxk; else goto ccMxl;
       ccMxk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMxl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           Sp = Sp - 16;
           call GHC.Stats.$fShowGCDetails_$cshowsPrec_entry(R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNd_entry() //  [R1]
         { info_tbl: [(ccMBX,
                       label: sat_scLNd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMBX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMBY; else goto ccMBZ;
       ccMBY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMBZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = lvl15_rcHpK_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNe_entry() //  [R1]
         { info_tbl: [(ccMC0,
                       label: sat_scLNe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMC0: // global
           _scLNe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMC1; else goto ccMC2;
       ccMC2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMC4; else goto ccMC3;
       ccMC4: // global
           HpAlloc = 24;
           goto ccMC1;
       ccMC1: // global
           R1 = _scLNe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMC3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLNe::P64;
           _scLMS::P64 = P64[_scLNe::P64 + 16];
           _scLMU::P64 = P64[_scLNe::P64 + 24];
           I64[Hp - 16] = sat_scLNd_info;
           P64[Hp] = _scLMU::P64;
           R2 = Hp - 16;
           R1 = _scLMS::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNf_entry() //  [R1]
         { info_tbl: [(ccMC5,
                       label: sat_scLNf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMC5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccMC9; else goto ccMC8;
       ccMC9: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMC8: // global
           _scLMS::P64 = P64[R1 + 16];
           _scLMU::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_scLNe_info;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 24;
           R2 = lvl36_rcHq5_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLNg_entry() //  [R1]
         { info_tbl: [(ccMCa,
                       label: sat_scLNg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMCa: // global
           _scLNg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMCb; else goto ccMCc;
       ccMCc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccMCe; else goto ccMCd;
       ccMCe: // global
           HpAlloc = 32;
           goto ccMCb;
       ccMCb: // global
           R1 = _scLNg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMCd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLNg::P64;
           _scLMS::P64 = P64[_scLNg::P64 + 16];
           _scLMU::P64 = P64[_scLNg::P64 + 24];
           I64[Hp - 24] = sat_scLNf_info;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 24;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNk_entry() //  [R1]
         { info_tbl: [(ccMCf,
                       label: sat_scLNk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMCf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccMCj; else goto ccMCk;
       ccMCj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMCk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccMBC_info;
           _scLMS::P64 = P64[R1 + 24];
           _scLMU::P64 = P64[R1 + 32];
           R1 = P64[R1 + 16];
           P64[Sp - 32] = _scLMS::P64;
           P64[Sp - 24] = _scLMU::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ucMCr; else goto ccMBD;
       ucMCr: // global
           call _ccMBC(R1) args: 0, res: 0, upd: 0;
       ccMBD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMBC() //  [R1]
         { info_tbl: [(ccMBC,
                       label: block_ccMBC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMBC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccMCn; else goto ccMCm;
       ccMCn: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccMCm: // global
           _scLNc::I64 = I64[R1 + 7];
           I64[Hp - 24] = sat_scLNg_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_ccMCg_info;
           R4 = Hp - 24;
           R3 = _scLNc::I64;
           R2 = 0;
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMCg() //  [R1, R2]
         { info_tbl: [(ccMCg,
                       label: block_ccMCg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMCg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMCq; else goto ccMCp;
       ccMCq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMCp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNl_entry() //  [R1]
         { info_tbl: [(ccMCs,
                       label: sat_scLNl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMCs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccMCw; else goto ccMCv;
       ccMCw: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMCv: // global
           _scLLV::P64 = P64[R1 + 16];
           _scLMS::P64 = P64[R1 + 24];
           _scLMU::P64 = P64[R1 + 32];
           I64[Hp - 32] = sat_scLNk_info;
           P64[Hp - 16] = _scLLV::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 32;
           R2 = lvl35_rcHq4_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLNm_entry() //  [R1]
         { info_tbl: [(ccMCx,
                       label: sat_scLNm_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMCx: // global
           _scLNm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMCy; else goto ccMCz;
       ccMCz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccMCB; else goto ccMCA;
       ccMCB: // global
           HpAlloc = 40;
           goto ccMCy;
       ccMCy: // global
           R1 = _scLNm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMCA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLNm::P64;
           _scLLV::P64 = P64[_scLNm::P64 + 16];
           _scLMS::P64 = P64[_scLNm::P64 + 24];
           _scLMU::P64 = P64[_scLNm::P64 + 32];
           I64[Hp - 32] = sat_scLNl_info;
           P64[Hp - 16] = _scLLV::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 32;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNq_entry() //  [R1]
         { info_tbl: [(ccMCC,
                       label: sat_scLNq_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMCC: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ccMCG; else goto ccMCH;
       ccMCG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMCH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ccMBl_info;
           _scLLV::P64 = P64[R1 + 24];
           _scLMS::P64 = P64[R1 + 32];
           _scLMU::P64 = P64[R1 + 40];
           R1 = P64[R1 + 16];
           P64[Sp - 40] = _scLLV::P64;
           P64[Sp - 32] = _scLMS::P64;
           P64[Sp - 24] = _scLMU::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ucMCO; else goto ccMBm;
       ucMCO: // global
           call _ccMBl(R1) args: 0, res: 0, upd: 0;
       ccMBm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMBl() //  [R1]
         { info_tbl: [(ccMBl,
                       label: block_ccMBl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMBl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccMCK; else goto ccMCJ;
       ccMCK: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccMCJ: // global
           _scLNa::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_scLNm_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = block_ccMCD_info;
           R4 = Hp - 32;
           R3 = _scLNa::I64;
           R2 = 0;
           Sp = Sp + 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMCD() //  [R1, R2]
         { info_tbl: [(ccMCD,
                       label: block_ccMCD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMCD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMCN; else goto ccMCM;
       ccMCN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMCM: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNr_entry() //  [R1]
         { info_tbl: [(ccMCP,
                       label: sat_scLNr_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMCP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccMCT; else goto ccMCS;
       ccMCT: // global
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMCS: // global
           _scLLU::P64 = P64[R1 + 16];
           _scLLV::P64 = P64[R1 + 24];
           _scLMS::P64 = P64[R1 + 32];
           _scLMU::P64 = P64[R1 + 40];
           I64[Hp - 40] = sat_scLNq_info;
           P64[Hp - 24] = _scLLU::P64;
           P64[Hp - 16] = _scLLV::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 40;
           R2 = lvl34_rcHq3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLNs_entry() //  [R1]
         { info_tbl: [(ccMCU,
                       label: sat_scLNs_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMCU: // global
           _scLNs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMCV; else goto ccMCW;
       ccMCW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccMCY; else goto ccMCX;
       ccMCY: // global
           HpAlloc = 48;
           goto ccMCV;
       ccMCV: // global
           R1 = _scLNs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMCX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLNs::P64;
           _scLLU::P64 = P64[_scLNs::P64 + 16];
           _scLLV::P64 = P64[_scLNs::P64 + 24];
           _scLMS::P64 = P64[_scLNs::P64 + 32];
           _scLMU::P64 = P64[_scLNs::P64 + 40];
           I64[Hp - 40] = sat_scLNr_info;
           P64[Hp - 24] = _scLLU::P64;
           P64[Hp - 16] = _scLLV::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 40;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNw_entry() //  [R1]
         { info_tbl: [(ccMCZ,
                       label: sat_scLNw_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMCZ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccMD3; else goto ccMD4;
       ccMD3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMD4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_ccMB4_info;
           _scLLU::P64 = P64[R1 + 24];
           _scLLV::P64 = P64[R1 + 32];
           _scLMS::P64 = P64[R1 + 40];
           _scLMU::P64 = P64[R1 + 48];
           R1 = P64[R1 + 16];
           P64[Sp - 48] = _scLLU::P64;
           P64[Sp - 40] = _scLLV::P64;
           P64[Sp - 32] = _scLMS::P64;
           P64[Sp - 24] = _scLMU::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ucMDb; else goto ccMB5;
       ucMDb: // global
           call _ccMB4(R1) args: 0, res: 0, upd: 0;
       ccMB5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMB4() //  [R1]
         { info_tbl: [(ccMB4,
                       label: block_ccMB4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMB4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccMD7; else goto ccMD6;
       ccMD7: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccMD6: // global
           _scLN8::I64 = I64[R1 + 7];
           I64[Hp - 40] = sat_scLNs_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           I64[Sp + 32] = block_ccMD0_info;
           R4 = Hp - 40;
           R3 = _scLN8::I64;
           R2 = 0;
           Sp = Sp + 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMD0() //  [R1, R2]
         { info_tbl: [(ccMD0,
                       label: block_ccMD0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMD0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMDa; else goto ccMD9;
       ccMDa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMD9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNx_entry() //  [R1]
         { info_tbl: [(ccMDc,
                       label: sat_scLNx_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMDc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccMDg; else goto ccMDf;
       ccMDg: // global
           HpAlloc = 56;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMDf: // global
           _scLLT::P64 = P64[R1 + 16];
           _scLLU::P64 = P64[R1 + 24];
           _scLLV::P64 = P64[R1 + 32];
           _scLMS::P64 = P64[R1 + 40];
           _scLMU::P64 = P64[R1 + 48];
           I64[Hp - 48] = sat_scLNw_info;
           P64[Hp - 32] = _scLLT::P64;
           P64[Hp - 24] = _scLLU::P64;
           P64[Hp - 16] = _scLLV::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 48;
           R2 = lvl33_rcHq2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLNy_entry() //  [R1]
         { info_tbl: [(ccMDh,
                       label: sat_scLNy_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMDh: // global
           _scLNy::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMDi; else goto ccMDj;
       ccMDj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccMDl; else goto ccMDk;
       ccMDl: // global
           HpAlloc = 56;
           goto ccMDi;
       ccMDi: // global
           R1 = _scLNy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMDk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLNy::P64;
           _scLLT::P64 = P64[_scLNy::P64 + 16];
           _scLLU::P64 = P64[_scLNy::P64 + 24];
           _scLLV::P64 = P64[_scLNy::P64 + 32];
           _scLMS::P64 = P64[_scLNy::P64 + 40];
           _scLMU::P64 = P64[_scLNy::P64 + 48];
           I64[Hp - 48] = sat_scLNx_info;
           P64[Hp - 32] = _scLLT::P64;
           P64[Hp - 24] = _scLLU::P64;
           P64[Hp - 16] = _scLLV::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 48;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNC_entry() //  [R1]
         { info_tbl: [(ccMDm,
                       label: sat_scLNC_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMDm: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ccMDq; else goto ccMDr;
       ccMDq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMDr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 64] = block_ccMAN_info;
           _scLLT::P64 = P64[R1 + 24];
           _scLLU::P64 = P64[R1 + 32];
           _scLLV::P64 = P64[R1 + 40];
           _scLMS::P64 = P64[R1 + 48];
           _scLMU::P64 = P64[R1 + 56];
           R1 = P64[R1 + 16];
           P64[Sp - 56] = _scLLT::P64;
           P64[Sp - 48] = _scLLU::P64;
           P64[Sp - 40] = _scLLV::P64;
           P64[Sp - 32] = _scLMS::P64;
           P64[Sp - 24] = _scLMU::P64;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ucMDy; else goto ccMAO;
       ucMDy: // global
           call _ccMAN(R1) args: 0, res: 0, upd: 0;
       ccMAO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMAN() //  [R1]
         { info_tbl: [(ccMAN,
                       label: block_ccMAN_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMAN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccMDu; else goto ccMDt;
       ccMDu: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccMDt: // global
           _scLN6::I64 = I64[R1 + 7];
           I64[Hp - 48] = sat_scLNy_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 40] = block_ccMDn_info;
           R4 = Hp - 48;
           R3 = _scLN6::I64;
           R2 = 0;
           Sp = Sp + 40;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMDn() //  [R1, R2]
         { info_tbl: [(ccMDn,
                       label: block_ccMDn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMDn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMDx; else goto ccMDw;
       ccMDx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMDw: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLND_entry() //  [R1]
         { info_tbl: [(ccMDz,
                       label: sat_scLND_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMDz: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccMDD; else goto ccMDC;
       ccMDD: // global
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMDC: // global
           _scLLS::P64 = P64[R1 + 16];
           _scLLT::P64 = P64[R1 + 24];
           _scLLU::P64 = P64[R1 + 32];
           _scLLV::P64 = P64[R1 + 40];
           _scLMS::P64 = P64[R1 + 48];
           _scLMU::P64 = P64[R1 + 56];
           I64[Hp - 56] = sat_scLNC_info;
           P64[Hp - 40] = _scLLS::P64;
           P64[Hp - 32] = _scLLT::P64;
           P64[Hp - 24] = _scLLU::P64;
           P64[Hp - 16] = _scLLV::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 56;
           R2 = lvl32_rcHq1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLNE_entry() //  [R1]
         { info_tbl: [(ccMDE,
                       label: sat_scLNE_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMDE: // global
           _scLNE::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMDF; else goto ccMDG;
       ccMDG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccMDI; else goto ccMDH;
       ccMDI: // global
           HpAlloc = 64;
           goto ccMDF;
       ccMDF: // global
           R1 = _scLNE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMDH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLNE::P64;
           _scLLS::P64 = P64[_scLNE::P64 + 16];
           _scLLT::P64 = P64[_scLNE::P64 + 24];
           _scLLU::P64 = P64[_scLNE::P64 + 32];
           _scLLV::P64 = P64[_scLNE::P64 + 40];
           _scLMS::P64 = P64[_scLNE::P64 + 48];
           _scLMU::P64 = P64[_scLNE::P64 + 56];
           I64[Hp - 56] = sat_scLND_info;
           P64[Hp - 40] = _scLLS::P64;
           P64[Hp - 32] = _scLLT::P64;
           P64[Hp - 24] = _scLLU::P64;
           P64[Hp - 16] = _scLLV::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 56;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNI_entry() //  [R1]
         { info_tbl: [(ccMDJ,
                       label: sat_scLNI_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMDJ: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ccMDN; else goto ccMDO;
       ccMDN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMDO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 72] = block_ccMAw_info;
           _scLLS::P64 = P64[R1 + 24];
           _scLLT::P64 = P64[R1 + 32];
           _scLLU::P64 = P64[R1 + 40];
           _scLLV::P64 = P64[R1 + 48];
           _scLMS::P64 = P64[R1 + 56];
           _scLMU::P64 = P64[R1 + 64];
           R1 = P64[R1 + 16];
           P64[Sp - 64] = _scLLS::P64;
           P64[Sp - 56] = _scLLT::P64;
           P64[Sp - 48] = _scLLU::P64;
           P64[Sp - 40] = _scLLV::P64;
           P64[Sp - 32] = _scLMS::P64;
           P64[Sp - 24] = _scLMU::P64;
           Sp = Sp - 72;
           if (R1 & 7 != 0) goto ucMDV; else goto ccMAx;
       ucMDV: // global
           call _ccMAw(R1) args: 0, res: 0, upd: 0;
       ccMAx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMAw() //  [R1]
         { info_tbl: [(ccMAw,
                       label: block_ccMAw_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMAw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccMDR; else goto ccMDQ;
       ccMDR: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccMDQ: // global
           _scLN4::I64 = I64[R1 + 7];
           I64[Hp - 56] = sat_scLNE_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 48];
           I64[Sp + 48] = block_ccMDK_info;
           R4 = Hp - 56;
           R3 = _scLN4::I64;
           R2 = 0;
           Sp = Sp + 48;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMDK() //  [R1, R2]
         { info_tbl: [(ccMDK,
                       label: block_ccMDK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMDK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMDU; else goto ccMDT;
       ccMDU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMDT: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNJ_entry() //  [R1]
         { info_tbl: [(ccMDW,
                       label: sat_scLNJ_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMDW: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccME0; else goto ccMDZ;
       ccME0: // global
           HpAlloc = 72;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMDZ: // global
           _scLLR::P64 = P64[R1 + 16];
           _scLLS::P64 = P64[R1 + 24];
           _scLLT::P64 = P64[R1 + 32];
           _scLLU::P64 = P64[R1 + 40];
           _scLLV::P64 = P64[R1 + 48];
           _scLMS::P64 = P64[R1 + 56];
           _scLMU::P64 = P64[R1 + 64];
           I64[Hp - 64] = sat_scLNI_info;
           P64[Hp - 48] = _scLLR::P64;
           P64[Hp - 40] = _scLLS::P64;
           P64[Hp - 32] = _scLLT::P64;
           P64[Hp - 24] = _scLLU::P64;
           P64[Hp - 16] = _scLLV::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 64;
           R2 = lvl31_rcHq0_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLNK_entry() //  [R1]
         { info_tbl: [(ccME1,
                       label: sat_scLNK_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccME1: // global
           _scLNK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccME2; else goto ccME3;
       ccME3: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccME5; else goto ccME4;
       ccME5: // global
           HpAlloc = 72;
           goto ccME2;
       ccME2: // global
           R1 = _scLNK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccME4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLNK::P64;
           _scLLR::P64 = P64[_scLNK::P64 + 16];
           _scLLS::P64 = P64[_scLNK::P64 + 24];
           _scLLT::P64 = P64[_scLNK::P64 + 32];
           _scLLU::P64 = P64[_scLNK::P64 + 40];
           _scLLV::P64 = P64[_scLNK::P64 + 48];
           _scLMS::P64 = P64[_scLNK::P64 + 56];
           _scLMU::P64 = P64[_scLNK::P64 + 64];
           I64[Hp - 64] = sat_scLNJ_info;
           P64[Hp - 48] = _scLLR::P64;
           P64[Hp - 40] = _scLLS::P64;
           P64[Hp - 32] = _scLLT::P64;
           P64[Hp - 24] = _scLLU::P64;
           P64[Hp - 16] = _scLLV::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 64;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNO_entry() //  [R1]
         { info_tbl: [(ccME6,
                       label: sat_scLNO_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccME6: // global
           if ((Sp + -80) < SpLim) (likely: False) goto ccMEa; else goto ccMEb;
       ccMEa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMEb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 80] = block_ccMAf_info;
           _scLLR::P64 = P64[R1 + 24];
           _scLLS::P64 = P64[R1 + 32];
           _scLLT::P64 = P64[R1 + 40];
           _scLLU::P64 = P64[R1 + 48];
           _scLLV::P64 = P64[R1 + 56];
           _scLMS::P64 = P64[R1 + 64];
           _scLMU::P64 = P64[R1 + 72];
           R1 = P64[R1 + 16];
           P64[Sp - 72] = _scLLR::P64;
           P64[Sp - 64] = _scLLS::P64;
           P64[Sp - 56] = _scLLT::P64;
           P64[Sp - 48] = _scLLU::P64;
           P64[Sp - 40] = _scLLV::P64;
           P64[Sp - 32] = _scLMS::P64;
           P64[Sp - 24] = _scLMU::P64;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto ucMEi; else goto ccMAg;
       ucMEi: // global
           call _ccMAf(R1) args: 0, res: 0, upd: 0;
       ccMAg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMAf() //  [R1]
         { info_tbl: [(ccMAf,
                       label: block_ccMAf_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMAf: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccMEe; else goto ccMEd;
       ccMEe: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccMEd: // global
           _scLN2::I64 = I64[R1 + 7];
           I64[Hp - 64] = sat_scLNK_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 56];
           I64[Sp + 56] = block_ccME7_info;
           R4 = Hp - 64;
           R3 = _scLN2::I64;
           R2 = 0;
           Sp = Sp + 56;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccME7() //  [R1, R2]
         { info_tbl: [(ccME7,
                       label: block_ccME7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccME7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMEh; else goto ccMEg;
       ccMEh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMEg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNP_entry() //  [R1]
         { info_tbl: [(ccMEj,
                       label: sat_scLNP_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMEj: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccMEn; else goto ccMEm;
       ccMEn: // global
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMEm: // global
           _scLLQ::P64 = P64[R1 + 16];
           _scLLR::P64 = P64[R1 + 24];
           _scLLS::P64 = P64[R1 + 32];
           _scLLT::P64 = P64[R1 + 40];
           _scLLU::P64 = P64[R1 + 48];
           _scLLV::P64 = P64[R1 + 56];
           _scLMS::P64 = P64[R1 + 64];
           _scLMU::P64 = P64[R1 + 72];
           I64[Hp - 72] = sat_scLNO_info;
           P64[Hp - 56] = _scLLQ::P64;
           P64[Hp - 48] = _scLLR::P64;
           P64[Hp - 40] = _scLLS::P64;
           P64[Hp - 32] = _scLLT::P64;
           P64[Hp - 24] = _scLLU::P64;
           P64[Hp - 16] = _scLLV::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 72;
           R2 = lvl30_rcHpZ_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLNQ_entry() //  [R1]
         { info_tbl: [(ccMEo,
                       label: sat_scLNQ_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMEo: // global
           _scLNQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMEp; else goto ccMEq;
       ccMEq: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccMEs; else goto ccMEr;
       ccMEs: // global
           HpAlloc = 80;
           goto ccMEp;
       ccMEp: // global
           R1 = _scLNQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMEr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLNQ::P64;
           _scLLQ::P64 = P64[_scLNQ::P64 + 16];
           _scLLR::P64 = P64[_scLNQ::P64 + 24];
           _scLLS::P64 = P64[_scLNQ::P64 + 32];
           _scLLT::P64 = P64[_scLNQ::P64 + 40];
           _scLLU::P64 = P64[_scLNQ::P64 + 48];
           _scLLV::P64 = P64[_scLNQ::P64 + 56];
           _scLMS::P64 = P64[_scLNQ::P64 + 64];
           _scLMU::P64 = P64[_scLNQ::P64 + 72];
           I64[Hp - 72] = sat_scLNP_info;
           P64[Hp - 56] = _scLLQ::P64;
           P64[Hp - 48] = _scLLR::P64;
           P64[Hp - 40] = _scLLS::P64;
           P64[Hp - 32] = _scLLT::P64;
           P64[Hp - 24] = _scLLU::P64;
           P64[Hp - 16] = _scLLV::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 72;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNU_entry() //  [R1]
         { info_tbl: [(ccMEw,
                       label: sat_scLNU_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMEw: // global
           _scLNU::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMEx; else goto ccMEy;
       ccMEy: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccMEA; else goto ccMEz;
       ccMEA: // global
           HpAlloc = 80;
           goto ccMEx;
       ccMEx: // global
           R1 = _scLNU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMEz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLNU::P64;
           _scLLQ::P64 = P64[_scLNU::P64 + 16];
           _scLLR::P64 = P64[_scLNU::P64 + 24];
           _scLLS::P64 = P64[_scLNU::P64 + 32];
           _scLLT::P64 = P64[_scLNU::P64 + 40];
           _scLLU::P64 = P64[_scLNU::P64 + 48];
           _scLLV::P64 = P64[_scLNU::P64 + 56];
           _scLMN::P64 = P64[_scLNU::P64 + 64];
           _scLMS::P64 = P64[_scLNU::P64 + 72];
           _scLMU::P64 = P64[_scLNU::P64 + 80];
           I64[Hp - 72] = sat_scLNQ_info;
           P64[Hp - 56] = _scLLQ::P64;
           P64[Hp - 48] = _scLLR::P64;
           P64[Hp - 40] = _scLLS::P64;
           P64[Hp - 32] = _scLLT::P64;
           P64[Hp - 24] = _scLLU::P64;
           P64[Hp - 16] = _scLLV::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           I64[Sp - 24] = block_ccMEt_info;
           R4 = Hp - 72;
           R3 = _scLMN::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMEt() //  [R1, R2]
         { info_tbl: [(ccMEt,
                       label: block_ccMEt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMEt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMED; else goto ccMEC;
       ccMED: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMEC: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLNV_entry() //  [R1]
         { info_tbl: [(ccMEE,
                       label: sat_scLNV_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMEE: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccMEI; else goto ccMEH;
       ccMEI: // global
           HpAlloc = 88;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMEH: // global
           _scLLQ::P64 = P64[R1 + 16];
           _scLLR::P64 = P64[R1 + 24];
           _scLLS::P64 = P64[R1 + 32];
           _scLLT::P64 = P64[R1 + 40];
           _scLLU::P64 = P64[R1 + 48];
           _scLLV::P64 = P64[R1 + 56];
           _scLMN::P64 = P64[R1 + 64];
           _scLMS::P64 = P64[R1 + 72];
           _scLMU::P64 = P64[R1 + 80];
           I64[Hp - 80] = sat_scLNU_info;
           P64[Hp - 64] = _scLLQ::P64;
           P64[Hp - 56] = _scLLR::P64;
           P64[Hp - 48] = _scLLS::P64;
           P64[Hp - 40] = _scLLT::P64;
           P64[Hp - 32] = _scLLU::P64;
           P64[Hp - 24] = _scLLV::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 80;
           R2 = lvl29_rcHpY_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLNW_entry() //  [R1]
         { info_tbl: [(ccMEJ,
                       label: sat_scLNW_info
                       rep:HeapRep 9 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMEJ: // global
           _scLNW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMEK; else goto ccMEL;
       ccMEL: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccMEN; else goto ccMEM;
       ccMEN: // global
           HpAlloc = 88;
           goto ccMEK;
       ccMEK: // global
           R1 = _scLNW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMEM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLNW::P64;
           _scLLQ::P64 = P64[_scLNW::P64 + 16];
           _scLLR::P64 = P64[_scLNW::P64 + 24];
           _scLLS::P64 = P64[_scLNW::P64 + 32];
           _scLLT::P64 = P64[_scLNW::P64 + 40];
           _scLLU::P64 = P64[_scLNW::P64 + 48];
           _scLLV::P64 = P64[_scLNW::P64 + 56];
           _scLMN::P64 = P64[_scLNW::P64 + 64];
           _scLMS::P64 = P64[_scLNW::P64 + 72];
           _scLMU::P64 = P64[_scLNW::P64 + 80];
           I64[Hp - 80] = sat_scLNV_info;
           P64[Hp - 64] = _scLLQ::P64;
           P64[Hp - 56] = _scLLR::P64;
           P64[Hp - 48] = _scLLS::P64;
           P64[Hp - 40] = _scLLT::P64;
           P64[Hp - 32] = _scLLU::P64;
           P64[Hp - 24] = _scLLV::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 80;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLO0_entry() //  [R1]
         { info_tbl: [(ccMER,
                       label: sat_scLO0_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMER: // global
           _scLO0::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMES; else goto ccMET;
       ccMET: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccMEV; else goto ccMEU;
       ccMEV: // global
           HpAlloc = 88;
           goto ccMES;
       ccMES: // global
           R1 = _scLO0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMEU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLO0::P64;
           _scLLQ::P64 = P64[_scLO0::P64 + 16];
           _scLLR::P64 = P64[_scLO0::P64 + 24];
           _scLLS::P64 = P64[_scLO0::P64 + 32];
           _scLLT::P64 = P64[_scLO0::P64 + 40];
           _scLLU::P64 = P64[_scLO0::P64 + 48];
           _scLLV::P64 = P64[_scLO0::P64 + 56];
           _scLMI::P64 = P64[_scLO0::P64 + 64];
           _scLMN::P64 = P64[_scLO0::P64 + 72];
           _scLMS::P64 = P64[_scLO0::P64 + 80];
           _scLMU::P64 = P64[_scLO0::P64 + 88];
           I64[Hp - 80] = sat_scLNW_info;
           P64[Hp - 64] = _scLLQ::P64;
           P64[Hp - 56] = _scLLR::P64;
           P64[Hp - 48] = _scLLS::P64;
           P64[Hp - 40] = _scLLT::P64;
           P64[Hp - 32] = _scLLU::P64;
           P64[Hp - 24] = _scLLV::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           I64[Sp - 24] = block_ccMEO_info;
           R4 = Hp - 80;
           R3 = _scLMI::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMEO() //  [R1, R2]
         { info_tbl: [(ccMEO,
                       label: block_ccMEO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMEO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMEY; else goto ccMEX;
       ccMEY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMEX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLO1_entry() //  [R1]
         { info_tbl: [(ccMEZ,
                       label: sat_scLO1_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMEZ: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccMF3; else goto ccMF2;
       ccMF3: // global
           HpAlloc = 96;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMF2: // global
           _scLLQ::P64 = P64[R1 + 16];
           _scLLR::P64 = P64[R1 + 24];
           _scLLS::P64 = P64[R1 + 32];
           _scLLT::P64 = P64[R1 + 40];
           _scLLU::P64 = P64[R1 + 48];
           _scLLV::P64 = P64[R1 + 56];
           _scLMI::P64 = P64[R1 + 64];
           _scLMN::P64 = P64[R1 + 72];
           _scLMS::P64 = P64[R1 + 80];
           _scLMU::P64 = P64[R1 + 88];
           I64[Hp - 88] = sat_scLO0_info;
           P64[Hp - 72] = _scLLQ::P64;
           P64[Hp - 64] = _scLLR::P64;
           P64[Hp - 56] = _scLLS::P64;
           P64[Hp - 48] = _scLLT::P64;
           P64[Hp - 40] = _scLLU::P64;
           P64[Hp - 32] = _scLLV::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 88;
           R2 = lvl28_rcHpX_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLO2_entry() //  [R1]
         { info_tbl: [(ccMF4,
                       label: sat_scLO2_info
                       rep:HeapRep 10 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMF4: // global
           _scLO2::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMF5; else goto ccMF6;
       ccMF6: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccMF8; else goto ccMF7;
       ccMF8: // global
           HpAlloc = 96;
           goto ccMF5;
       ccMF5: // global
           R1 = _scLO2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMF7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLO2::P64;
           _scLLQ::P64 = P64[_scLO2::P64 + 16];
           _scLLR::P64 = P64[_scLO2::P64 + 24];
           _scLLS::P64 = P64[_scLO2::P64 + 32];
           _scLLT::P64 = P64[_scLO2::P64 + 40];
           _scLLU::P64 = P64[_scLO2::P64 + 48];
           _scLLV::P64 = P64[_scLO2::P64 + 56];
           _scLMI::P64 = P64[_scLO2::P64 + 64];
           _scLMN::P64 = P64[_scLO2::P64 + 72];
           _scLMS::P64 = P64[_scLO2::P64 + 80];
           _scLMU::P64 = P64[_scLO2::P64 + 88];
           I64[Hp - 88] = sat_scLO1_info;
           P64[Hp - 72] = _scLLQ::P64;
           P64[Hp - 64] = _scLLR::P64;
           P64[Hp - 56] = _scLLS::P64;
           P64[Hp - 48] = _scLLT::P64;
           P64[Hp - 40] = _scLLU::P64;
           P64[Hp - 32] = _scLLV::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 88;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLO6_entry() //  [R1]
         { info_tbl: [(ccMFc,
                       label: sat_scLO6_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMFc: // global
           _scLO6::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMFd; else goto ccMFe;
       ccMFe: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccMFg; else goto ccMFf;
       ccMFg: // global
           HpAlloc = 96;
           goto ccMFd;
       ccMFd: // global
           R1 = _scLO6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMFf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLO6::P64;
           _scLLQ::P64 = P64[_scLO6::P64 + 16];
           _scLLR::P64 = P64[_scLO6::P64 + 24];
           _scLLS::P64 = P64[_scLO6::P64 + 32];
           _scLLT::P64 = P64[_scLO6::P64 + 40];
           _scLLU::P64 = P64[_scLO6::P64 + 48];
           _scLLV::P64 = P64[_scLO6::P64 + 56];
           _scLMD::P64 = P64[_scLO6::P64 + 64];
           _scLMI::P64 = P64[_scLO6::P64 + 72];
           _scLMN::P64 = P64[_scLO6::P64 + 80];
           _scLMS::P64 = P64[_scLO6::P64 + 88];
           _scLMU::P64 = P64[_scLO6::P64 + 96];
           I64[Hp - 88] = sat_scLO2_info;
           P64[Hp - 72] = _scLLQ::P64;
           P64[Hp - 64] = _scLLR::P64;
           P64[Hp - 56] = _scLLS::P64;
           P64[Hp - 48] = _scLLT::P64;
           P64[Hp - 40] = _scLLU::P64;
           P64[Hp - 32] = _scLLV::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           I64[Sp - 24] = block_ccMF9_info;
           R4 = Hp - 88;
           R3 = _scLMD::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMF9() //  [R1, R2]
         { info_tbl: [(ccMF9,
                       label: block_ccMF9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMF9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMFj; else goto ccMFi;
       ccMFj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMFi: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLO7_entry() //  [R1]
         { info_tbl: [(ccMFk,
                       label: sat_scLO7_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMFk: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccMFo; else goto ccMFn;
       ccMFo: // global
           HpAlloc = 104;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMFn: // global
           _scLLQ::P64 = P64[R1 + 16];
           _scLLR::P64 = P64[R1 + 24];
           _scLLS::P64 = P64[R1 + 32];
           _scLLT::P64 = P64[R1 + 40];
           _scLLU::P64 = P64[R1 + 48];
           _scLLV::P64 = P64[R1 + 56];
           _scLMD::P64 = P64[R1 + 64];
           _scLMI::P64 = P64[R1 + 72];
           _scLMN::P64 = P64[R1 + 80];
           _scLMS::P64 = P64[R1 + 88];
           _scLMU::P64 = P64[R1 + 96];
           I64[Hp - 96] = sat_scLO6_info;
           P64[Hp - 80] = _scLLQ::P64;
           P64[Hp - 72] = _scLLR::P64;
           P64[Hp - 64] = _scLLS::P64;
           P64[Hp - 56] = _scLLT::P64;
           P64[Hp - 48] = _scLLU::P64;
           P64[Hp - 40] = _scLLV::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 96;
           R2 = lvl27_rcHpW_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLO8_entry() //  [R1]
         { info_tbl: [(ccMFp,
                       label: sat_scLO8_info
                       rep:HeapRep 11 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMFp: // global
           _scLO8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMFq; else goto ccMFr;
       ccMFr: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccMFt; else goto ccMFs;
       ccMFt: // global
           HpAlloc = 104;
           goto ccMFq;
       ccMFq: // global
           R1 = _scLO8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMFs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLO8::P64;
           _scLLQ::P64 = P64[_scLO8::P64 + 16];
           _scLLR::P64 = P64[_scLO8::P64 + 24];
           _scLLS::P64 = P64[_scLO8::P64 + 32];
           _scLLT::P64 = P64[_scLO8::P64 + 40];
           _scLLU::P64 = P64[_scLO8::P64 + 48];
           _scLLV::P64 = P64[_scLO8::P64 + 56];
           _scLMD::P64 = P64[_scLO8::P64 + 64];
           _scLMI::P64 = P64[_scLO8::P64 + 72];
           _scLMN::P64 = P64[_scLO8::P64 + 80];
           _scLMS::P64 = P64[_scLO8::P64 + 88];
           _scLMU::P64 = P64[_scLO8::P64 + 96];
           I64[Hp - 96] = sat_scLO7_info;
           P64[Hp - 80] = _scLLQ::P64;
           P64[Hp - 72] = _scLLR::P64;
           P64[Hp - 64] = _scLLS::P64;
           P64[Hp - 56] = _scLLT::P64;
           P64[Hp - 48] = _scLLU::P64;
           P64[Hp - 40] = _scLLV::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 96;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOc_entry() //  [R1]
         { info_tbl: [(ccMFx,
                       label: sat_scLOc_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMFx: // global
           _scLOc::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMFy; else goto ccMFz;
       ccMFz: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccMFB; else goto ccMFA;
       ccMFB: // global
           HpAlloc = 104;
           goto ccMFy;
       ccMFy: // global
           R1 = _scLOc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMFA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOc::P64;
           _scLLQ::P64 = P64[_scLOc::P64 + 16];
           _scLLR::P64 = P64[_scLOc::P64 + 24];
           _scLLS::P64 = P64[_scLOc::P64 + 32];
           _scLLT::P64 = P64[_scLOc::P64 + 40];
           _scLLU::P64 = P64[_scLOc::P64 + 48];
           _scLLV::P64 = P64[_scLOc::P64 + 56];
           _scLMy::P64 = P64[_scLOc::P64 + 64];
           _scLMD::P64 = P64[_scLOc::P64 + 72];
           _scLMI::P64 = P64[_scLOc::P64 + 80];
           _scLMN::P64 = P64[_scLOc::P64 + 88];
           _scLMS::P64 = P64[_scLOc::P64 + 96];
           _scLMU::P64 = P64[_scLOc::P64 + 104];
           I64[Hp - 96] = sat_scLO8_info;
           P64[Hp - 80] = _scLLQ::P64;
           P64[Hp - 72] = _scLLR::P64;
           P64[Hp - 64] = _scLLS::P64;
           P64[Hp - 56] = _scLLT::P64;
           P64[Hp - 48] = _scLLU::P64;
           P64[Hp - 40] = _scLLV::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           I64[Sp - 24] = block_ccMFu_info;
           R4 = Hp - 96;
           R3 = _scLMy::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMFu() //  [R1, R2]
         { info_tbl: [(ccMFu,
                       label: block_ccMFu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMFu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMFE; else goto ccMFD;
       ccMFE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMFD: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOd_entry() //  [R1]
         { info_tbl: [(ccMFF,
                       label: sat_scLOd_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMFF: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccMFJ; else goto ccMFI;
       ccMFJ: // global
           HpAlloc = 112;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMFI: // global
           _scLLQ::P64 = P64[R1 + 16];
           _scLLR::P64 = P64[R1 + 24];
           _scLLS::P64 = P64[R1 + 32];
           _scLLT::P64 = P64[R1 + 40];
           _scLLU::P64 = P64[R1 + 48];
           _scLLV::P64 = P64[R1 + 56];
           _scLMy::P64 = P64[R1 + 64];
           _scLMD::P64 = P64[R1 + 72];
           _scLMI::P64 = P64[R1 + 80];
           _scLMN::P64 = P64[R1 + 88];
           _scLMS::P64 = P64[R1 + 96];
           _scLMU::P64 = P64[R1 + 104];
           I64[Hp - 104] = sat_scLOc_info;
           P64[Hp - 88] = _scLLQ::P64;
           P64[Hp - 80] = _scLLR::P64;
           P64[Hp - 72] = _scLLS::P64;
           P64[Hp - 64] = _scLLT::P64;
           P64[Hp - 56] = _scLLU::P64;
           P64[Hp - 48] = _scLLV::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 104;
           R2 = lvl26_rcHpV_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLOe_entry() //  [R1]
         { info_tbl: [(ccMFK,
                       label: sat_scLOe_info
                       rep:HeapRep 12 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMFK: // global
           _scLOe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMFL; else goto ccMFM;
       ccMFM: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccMFO; else goto ccMFN;
       ccMFO: // global
           HpAlloc = 112;
           goto ccMFL;
       ccMFL: // global
           R1 = _scLOe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMFN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOe::P64;
           _scLLQ::P64 = P64[_scLOe::P64 + 16];
           _scLLR::P64 = P64[_scLOe::P64 + 24];
           _scLLS::P64 = P64[_scLOe::P64 + 32];
           _scLLT::P64 = P64[_scLOe::P64 + 40];
           _scLLU::P64 = P64[_scLOe::P64 + 48];
           _scLLV::P64 = P64[_scLOe::P64 + 56];
           _scLMy::P64 = P64[_scLOe::P64 + 64];
           _scLMD::P64 = P64[_scLOe::P64 + 72];
           _scLMI::P64 = P64[_scLOe::P64 + 80];
           _scLMN::P64 = P64[_scLOe::P64 + 88];
           _scLMS::P64 = P64[_scLOe::P64 + 96];
           _scLMU::P64 = P64[_scLOe::P64 + 104];
           I64[Hp - 104] = sat_scLOd_info;
           P64[Hp - 88] = _scLLQ::P64;
           P64[Hp - 80] = _scLLR::P64;
           P64[Hp - 72] = _scLLS::P64;
           P64[Hp - 64] = _scLLT::P64;
           P64[Hp - 56] = _scLLU::P64;
           P64[Hp - 48] = _scLLV::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 104;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOi_entry() //  [R1]
         { info_tbl: [(ccMFS,
                       label: sat_scLOi_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMFS: // global
           _scLOi::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMFT; else goto ccMFU;
       ccMFU: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccMFW; else goto ccMFV;
       ccMFW: // global
           HpAlloc = 112;
           goto ccMFT;
       ccMFT: // global
           R1 = _scLOi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMFV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOi::P64;
           _scLLQ::P64 = P64[_scLOi::P64 + 16];
           _scLLR::P64 = P64[_scLOi::P64 + 24];
           _scLLS::P64 = P64[_scLOi::P64 + 32];
           _scLLT::P64 = P64[_scLOi::P64 + 40];
           _scLLU::P64 = P64[_scLOi::P64 + 48];
           _scLLV::P64 = P64[_scLOi::P64 + 56];
           _scLMt::P64 = P64[_scLOi::P64 + 64];
           _scLMy::P64 = P64[_scLOi::P64 + 72];
           _scLMD::P64 = P64[_scLOi::P64 + 80];
           _scLMI::P64 = P64[_scLOi::P64 + 88];
           _scLMN::P64 = P64[_scLOi::P64 + 96];
           _scLMS::P64 = P64[_scLOi::P64 + 104];
           _scLMU::P64 = P64[_scLOi::P64 + 112];
           I64[Hp - 104] = sat_scLOe_info;
           P64[Hp - 88] = _scLLQ::P64;
           P64[Hp - 80] = _scLLR::P64;
           P64[Hp - 72] = _scLLS::P64;
           P64[Hp - 64] = _scLLT::P64;
           P64[Hp - 56] = _scLLU::P64;
           P64[Hp - 48] = _scLLV::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           I64[Sp - 24] = block_ccMFP_info;
           R4 = Hp - 104;
           R3 = _scLMt::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMFP() //  [R1, R2]
         { info_tbl: [(ccMFP,
                       label: block_ccMFP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMFP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMFZ; else goto ccMFY;
       ccMFZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMFY: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOj_entry() //  [R1]
         { info_tbl: [(ccMG0,
                       label: sat_scLOj_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMG0: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccMG4; else goto ccMG3;
       ccMG4: // global
           HpAlloc = 120;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMG3: // global
           _scLLQ::P64 = P64[R1 + 16];
           _scLLR::P64 = P64[R1 + 24];
           _scLLS::P64 = P64[R1 + 32];
           _scLLT::P64 = P64[R1 + 40];
           _scLLU::P64 = P64[R1 + 48];
           _scLLV::P64 = P64[R1 + 56];
           _scLMt::P64 = P64[R1 + 64];
           _scLMy::P64 = P64[R1 + 72];
           _scLMD::P64 = P64[R1 + 80];
           _scLMI::P64 = P64[R1 + 88];
           _scLMN::P64 = P64[R1 + 96];
           _scLMS::P64 = P64[R1 + 104];
           _scLMU::P64 = P64[R1 + 112];
           I64[Hp - 112] = sat_scLOi_info;
           P64[Hp - 96] = _scLLQ::P64;
           P64[Hp - 88] = _scLLR::P64;
           P64[Hp - 80] = _scLLS::P64;
           P64[Hp - 72] = _scLLT::P64;
           P64[Hp - 64] = _scLLU::P64;
           P64[Hp - 56] = _scLLV::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 112;
           R2 = lvl25_rcHpU_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLOk_entry() //  [R1]
         { info_tbl: [(ccMG5,
                       label: sat_scLOk_info
                       rep:HeapRep 13 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMG5: // global
           _scLOk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMG6; else goto ccMG7;
       ccMG7: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccMG9; else goto ccMG8;
       ccMG9: // global
           HpAlloc = 120;
           goto ccMG6;
       ccMG6: // global
           R1 = _scLOk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMG8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOk::P64;
           _scLLQ::P64 = P64[_scLOk::P64 + 16];
           _scLLR::P64 = P64[_scLOk::P64 + 24];
           _scLLS::P64 = P64[_scLOk::P64 + 32];
           _scLLT::P64 = P64[_scLOk::P64 + 40];
           _scLLU::P64 = P64[_scLOk::P64 + 48];
           _scLLV::P64 = P64[_scLOk::P64 + 56];
           _scLMt::P64 = P64[_scLOk::P64 + 64];
           _scLMy::P64 = P64[_scLOk::P64 + 72];
           _scLMD::P64 = P64[_scLOk::P64 + 80];
           _scLMI::P64 = P64[_scLOk::P64 + 88];
           _scLMN::P64 = P64[_scLOk::P64 + 96];
           _scLMS::P64 = P64[_scLOk::P64 + 104];
           _scLMU::P64 = P64[_scLOk::P64 + 112];
           I64[Hp - 112] = sat_scLOj_info;
           P64[Hp - 96] = _scLLQ::P64;
           P64[Hp - 88] = _scLLR::P64;
           P64[Hp - 80] = _scLLS::P64;
           P64[Hp - 72] = _scLLT::P64;
           P64[Hp - 64] = _scLLU::P64;
           P64[Hp - 56] = _scLLV::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 112;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOo_entry() //  [R1]
         { info_tbl: [(ccMGd,
                       label: sat_scLOo_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMGd: // global
           _scLOo::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMGe; else goto ccMGf;
       ccMGf: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccMGh; else goto ccMGg;
       ccMGh: // global
           HpAlloc = 120;
           goto ccMGe;
       ccMGe: // global
           R1 = _scLOo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMGg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOo::P64;
           _scLLQ::P64 = P64[_scLOo::P64 + 16];
           _scLLR::P64 = P64[_scLOo::P64 + 24];
           _scLLS::P64 = P64[_scLOo::P64 + 32];
           _scLLT::P64 = P64[_scLOo::P64 + 40];
           _scLLU::P64 = P64[_scLOo::P64 + 48];
           _scLLV::P64 = P64[_scLOo::P64 + 56];
           _scLMo::P64 = P64[_scLOo::P64 + 64];
           _scLMt::P64 = P64[_scLOo::P64 + 72];
           _scLMy::P64 = P64[_scLOo::P64 + 80];
           _scLMD::P64 = P64[_scLOo::P64 + 88];
           _scLMI::P64 = P64[_scLOo::P64 + 96];
           _scLMN::P64 = P64[_scLOo::P64 + 104];
           _scLMS::P64 = P64[_scLOo::P64 + 112];
           _scLMU::P64 = P64[_scLOo::P64 + 120];
           I64[Hp - 112] = sat_scLOk_info;
           P64[Hp - 96] = _scLLQ::P64;
           P64[Hp - 88] = _scLLR::P64;
           P64[Hp - 80] = _scLLS::P64;
           P64[Hp - 72] = _scLLT::P64;
           P64[Hp - 64] = _scLLU::P64;
           P64[Hp - 56] = _scLLV::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           I64[Sp - 24] = block_ccMGa_info;
           R4 = Hp - 112;
           R3 = _scLMo::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMGa() //  [R1, R2]
         { info_tbl: [(ccMGa,
                       label: block_ccMGa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMGa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMGk; else goto ccMGj;
       ccMGk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMGj: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOp_entry() //  [R1]
         { info_tbl: [(ccMGl,
                       label: sat_scLOp_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMGl: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccMGp; else goto ccMGo;
       ccMGp: // global
           HpAlloc = 128;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMGo: // global
           _scLLQ::P64 = P64[R1 + 16];
           _scLLR::P64 = P64[R1 + 24];
           _scLLS::P64 = P64[R1 + 32];
           _scLLT::P64 = P64[R1 + 40];
           _scLLU::P64 = P64[R1 + 48];
           _scLLV::P64 = P64[R1 + 56];
           _scLMo::P64 = P64[R1 + 64];
           _scLMt::P64 = P64[R1 + 72];
           _scLMy::P64 = P64[R1 + 80];
           _scLMD::P64 = P64[R1 + 88];
           _scLMI::P64 = P64[R1 + 96];
           _scLMN::P64 = P64[R1 + 104];
           _scLMS::P64 = P64[R1 + 112];
           _scLMU::P64 = P64[R1 + 120];
           I64[Hp - 120] = sat_scLOo_info;
           P64[Hp - 104] = _scLLQ::P64;
           P64[Hp - 96] = _scLLR::P64;
           P64[Hp - 88] = _scLLS::P64;
           P64[Hp - 80] = _scLLT::P64;
           P64[Hp - 72] = _scLLU::P64;
           P64[Hp - 64] = _scLLV::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 120;
           R2 = lvl24_rcHpT_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLOq_entry() //  [R1]
         { info_tbl: [(ccMGq,
                       label: sat_scLOq_info
                       rep:HeapRep 14 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMGq: // global
           _scLOq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMGr; else goto ccMGs;
       ccMGs: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccMGu; else goto ccMGt;
       ccMGu: // global
           HpAlloc = 128;
           goto ccMGr;
       ccMGr: // global
           R1 = _scLOq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMGt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOq::P64;
           _scLLQ::P64 = P64[_scLOq::P64 + 16];
           _scLLR::P64 = P64[_scLOq::P64 + 24];
           _scLLS::P64 = P64[_scLOq::P64 + 32];
           _scLLT::P64 = P64[_scLOq::P64 + 40];
           _scLLU::P64 = P64[_scLOq::P64 + 48];
           _scLLV::P64 = P64[_scLOq::P64 + 56];
           _scLMo::P64 = P64[_scLOq::P64 + 64];
           _scLMt::P64 = P64[_scLOq::P64 + 72];
           _scLMy::P64 = P64[_scLOq::P64 + 80];
           _scLMD::P64 = P64[_scLOq::P64 + 88];
           _scLMI::P64 = P64[_scLOq::P64 + 96];
           _scLMN::P64 = P64[_scLOq::P64 + 104];
           _scLMS::P64 = P64[_scLOq::P64 + 112];
           _scLMU::P64 = P64[_scLOq::P64 + 120];
           I64[Hp - 120] = sat_scLOp_info;
           P64[Hp - 104] = _scLLQ::P64;
           P64[Hp - 96] = _scLLR::P64;
           P64[Hp - 88] = _scLLS::P64;
           P64[Hp - 80] = _scLLT::P64;
           P64[Hp - 72] = _scLLU::P64;
           P64[Hp - 64] = _scLLV::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 120;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOu_entry() //  [R1]
         { info_tbl: [(ccMGy,
                       label: sat_scLOu_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMGy: // global
           _scLOu::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMGz; else goto ccMGA;
       ccMGA: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccMGC; else goto ccMGB;
       ccMGC: // global
           HpAlloc = 128;
           goto ccMGz;
       ccMGz: // global
           R1 = _scLOu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMGB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOu::P64;
           _scLLQ::P64 = P64[_scLOu::P64 + 16];
           _scLLR::P64 = P64[_scLOu::P64 + 24];
           _scLLS::P64 = P64[_scLOu::P64 + 32];
           _scLLT::P64 = P64[_scLOu::P64 + 40];
           _scLLU::P64 = P64[_scLOu::P64 + 48];
           _scLLV::P64 = P64[_scLOu::P64 + 56];
           _scLMj::P64 = P64[_scLOu::P64 + 64];
           _scLMo::P64 = P64[_scLOu::P64 + 72];
           _scLMt::P64 = P64[_scLOu::P64 + 80];
           _scLMy::P64 = P64[_scLOu::P64 + 88];
           _scLMD::P64 = P64[_scLOu::P64 + 96];
           _scLMI::P64 = P64[_scLOu::P64 + 104];
           _scLMN::P64 = P64[_scLOu::P64 + 112];
           _scLMS::P64 = P64[_scLOu::P64 + 120];
           _scLMU::P64 = P64[_scLOu::P64 + 128];
           I64[Hp - 120] = sat_scLOq_info;
           P64[Hp - 104] = _scLLQ::P64;
           P64[Hp - 96] = _scLLR::P64;
           P64[Hp - 88] = _scLLS::P64;
           P64[Hp - 80] = _scLLT::P64;
           P64[Hp - 72] = _scLLU::P64;
           P64[Hp - 64] = _scLLV::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           I64[Sp - 24] = block_ccMGv_info;
           R4 = Hp - 120;
           R3 = _scLMj::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMGv() //  [R1, R2]
         { info_tbl: [(ccMGv,
                       label: block_ccMGv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMGv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMGF; else goto ccMGE;
       ccMGF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMGE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOv_entry() //  [R1]
         { info_tbl: [(ccMGG,
                       label: sat_scLOv_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMGG: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccMGK; else goto ccMGJ;
       ccMGK: // global
           HpAlloc = 136;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMGJ: // global
           _scLLQ::P64 = P64[R1 + 16];
           _scLLR::P64 = P64[R1 + 24];
           _scLLS::P64 = P64[R1 + 32];
           _scLLT::P64 = P64[R1 + 40];
           _scLLU::P64 = P64[R1 + 48];
           _scLLV::P64 = P64[R1 + 56];
           _scLMj::P64 = P64[R1 + 64];
           _scLMo::P64 = P64[R1 + 72];
           _scLMt::P64 = P64[R1 + 80];
           _scLMy::P64 = P64[R1 + 88];
           _scLMD::P64 = P64[R1 + 96];
           _scLMI::P64 = P64[R1 + 104];
           _scLMN::P64 = P64[R1 + 112];
           _scLMS::P64 = P64[R1 + 120];
           _scLMU::P64 = P64[R1 + 128];
           I64[Hp - 128] = sat_scLOu_info;
           P64[Hp - 112] = _scLLQ::P64;
           P64[Hp - 104] = _scLLR::P64;
           P64[Hp - 96] = _scLLS::P64;
           P64[Hp - 88] = _scLLT::P64;
           P64[Hp - 80] = _scLLU::P64;
           P64[Hp - 72] = _scLLV::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 128;
           R2 = lvl23_rcHpS_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLOw_entry() //  [R1]
         { info_tbl: [(ccMGL,
                       label: sat_scLOw_info
                       rep:HeapRep 15 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMGL: // global
           _scLOw::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMGM; else goto ccMGN;
       ccMGN: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccMGP; else goto ccMGO;
       ccMGP: // global
           HpAlloc = 136;
           goto ccMGM;
       ccMGM: // global
           R1 = _scLOw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMGO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOw::P64;
           _scLLQ::P64 = P64[_scLOw::P64 + 16];
           _scLLR::P64 = P64[_scLOw::P64 + 24];
           _scLLS::P64 = P64[_scLOw::P64 + 32];
           _scLLT::P64 = P64[_scLOw::P64 + 40];
           _scLLU::P64 = P64[_scLOw::P64 + 48];
           _scLLV::P64 = P64[_scLOw::P64 + 56];
           _scLMj::P64 = P64[_scLOw::P64 + 64];
           _scLMo::P64 = P64[_scLOw::P64 + 72];
           _scLMt::P64 = P64[_scLOw::P64 + 80];
           _scLMy::P64 = P64[_scLOw::P64 + 88];
           _scLMD::P64 = P64[_scLOw::P64 + 96];
           _scLMI::P64 = P64[_scLOw::P64 + 104];
           _scLMN::P64 = P64[_scLOw::P64 + 112];
           _scLMS::P64 = P64[_scLOw::P64 + 120];
           _scLMU::P64 = P64[_scLOw::P64 + 128];
           I64[Hp - 128] = sat_scLOv_info;
           P64[Hp - 112] = _scLLQ::P64;
           P64[Hp - 104] = _scLLR::P64;
           P64[Hp - 96] = _scLLS::P64;
           P64[Hp - 88] = _scLLT::P64;
           P64[Hp - 80] = _scLLU::P64;
           P64[Hp - 72] = _scLLV::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 128;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOA_entry() //  [R1]
         { info_tbl: [(ccMGT,
                       label: sat_scLOA_info
                       rep:HeapRep 16 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMGT: // global
           _scLOA::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMGU; else goto ccMGV;
       ccMGV: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccMGX; else goto ccMGW;
       ccMGX: // global
           HpAlloc = 136;
           goto ccMGU;
       ccMGU: // global
           R1 = _scLOA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMGW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOA::P64;
           _scLLQ::P64 = P64[_scLOA::P64 + 16];
           _scLLR::P64 = P64[_scLOA::P64 + 24];
           _scLLS::P64 = P64[_scLOA::P64 + 32];
           _scLLT::P64 = P64[_scLOA::P64 + 40];
           _scLLU::P64 = P64[_scLOA::P64 + 48];
           _scLLV::P64 = P64[_scLOA::P64 + 56];
           _scLMe::P64 = P64[_scLOA::P64 + 64];
           _scLMj::P64 = P64[_scLOA::P64 + 72];
           _scLMo::P64 = P64[_scLOA::P64 + 80];
           _scLMt::P64 = P64[_scLOA::P64 + 88];
           _scLMy::P64 = P64[_scLOA::P64 + 96];
           _scLMD::P64 = P64[_scLOA::P64 + 104];
           _scLMI::P64 = P64[_scLOA::P64 + 112];
           _scLMN::P64 = P64[_scLOA::P64 + 120];
           _scLMS::P64 = P64[_scLOA::P64 + 128];
           _scLMU::P64 = P64[_scLOA::P64 + 136];
           I64[Hp - 128] = sat_scLOw_info;
           P64[Hp - 112] = _scLLQ::P64;
           P64[Hp - 104] = _scLLR::P64;
           P64[Hp - 96] = _scLLS::P64;
           P64[Hp - 88] = _scLLT::P64;
           P64[Hp - 80] = _scLLU::P64;
           P64[Hp - 72] = _scLLV::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           I64[Sp - 24] = block_ccMGQ_info;
           R4 = Hp - 128;
           R3 = _scLMe::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMGQ() //  [R1, R2]
         { info_tbl: [(ccMGQ,
                       label: block_ccMGQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMGQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMH0; else goto ccMGZ;
       ccMH0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMGZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOB_entry() //  [R1]
         { info_tbl: [(ccMH1,
                       label: sat_scLOB_info
                       rep:HeapRep 16 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMH1: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccMH5; else goto ccMH4;
       ccMH5: // global
           HpAlloc = 144;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMH4: // global
           _scLLQ::P64 = P64[R1 + 16];
           _scLLR::P64 = P64[R1 + 24];
           _scLLS::P64 = P64[R1 + 32];
           _scLLT::P64 = P64[R1 + 40];
           _scLLU::P64 = P64[R1 + 48];
           _scLLV::P64 = P64[R1 + 56];
           _scLMe::P64 = P64[R1 + 64];
           _scLMj::P64 = P64[R1 + 72];
           _scLMo::P64 = P64[R1 + 80];
           _scLMt::P64 = P64[R1 + 88];
           _scLMy::P64 = P64[R1 + 96];
           _scLMD::P64 = P64[R1 + 104];
           _scLMI::P64 = P64[R1 + 112];
           _scLMN::P64 = P64[R1 + 120];
           _scLMS::P64 = P64[R1 + 128];
           _scLMU::P64 = P64[R1 + 136];
           I64[Hp - 136] = sat_scLOA_info;
           P64[Hp - 120] = _scLLQ::P64;
           P64[Hp - 112] = _scLLR::P64;
           P64[Hp - 104] = _scLLS::P64;
           P64[Hp - 96] = _scLLT::P64;
           P64[Hp - 88] = _scLLU::P64;
           P64[Hp - 80] = _scLLV::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 136;
           R2 = lvl22_rcHpR_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLOC_entry() //  [R1]
         { info_tbl: [(ccMH6,
                       label: sat_scLOC_info
                       rep:HeapRep 16 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMH6: // global
           _scLOC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMH7; else goto ccMH8;
       ccMH8: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccMHa; else goto ccMH9;
       ccMHa: // global
           HpAlloc = 144;
           goto ccMH7;
       ccMH7: // global
           R1 = _scLOC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMH9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOC::P64;
           _scLLQ::P64 = P64[_scLOC::P64 + 16];
           _scLLR::P64 = P64[_scLOC::P64 + 24];
           _scLLS::P64 = P64[_scLOC::P64 + 32];
           _scLLT::P64 = P64[_scLOC::P64 + 40];
           _scLLU::P64 = P64[_scLOC::P64 + 48];
           _scLLV::P64 = P64[_scLOC::P64 + 56];
           _scLMe::P64 = P64[_scLOC::P64 + 64];
           _scLMj::P64 = P64[_scLOC::P64 + 72];
           _scLMo::P64 = P64[_scLOC::P64 + 80];
           _scLMt::P64 = P64[_scLOC::P64 + 88];
           _scLMy::P64 = P64[_scLOC::P64 + 96];
           _scLMD::P64 = P64[_scLOC::P64 + 104];
           _scLMI::P64 = P64[_scLOC::P64 + 112];
           _scLMN::P64 = P64[_scLOC::P64 + 120];
           _scLMS::P64 = P64[_scLOC::P64 + 128];
           _scLMU::P64 = P64[_scLOC::P64 + 136];
           I64[Hp - 136] = sat_scLOB_info;
           P64[Hp - 120] = _scLLQ::P64;
           P64[Hp - 112] = _scLLR::P64;
           P64[Hp - 104] = _scLLS::P64;
           P64[Hp - 96] = _scLLT::P64;
           P64[Hp - 88] = _scLLU::P64;
           P64[Hp - 80] = _scLLV::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 136;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOG_entry() //  [R1]
         { info_tbl: [(ccMHe,
                       label: sat_scLOG_info
                       rep:HeapRep 17 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMHe: // global
           _scLOG::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMHf; else goto ccMHg;
       ccMHg: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccMHi; else goto ccMHh;
       ccMHi: // global
           HpAlloc = 144;
           goto ccMHf;
       ccMHf: // global
           R1 = _scLOG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMHh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOG::P64;
           _scLLQ::P64 = P64[_scLOG::P64 + 16];
           _scLLR::P64 = P64[_scLOG::P64 + 24];
           _scLLS::P64 = P64[_scLOG::P64 + 32];
           _scLLT::P64 = P64[_scLOG::P64 + 40];
           _scLLU::P64 = P64[_scLOG::P64 + 48];
           _scLLV::P64 = P64[_scLOG::P64 + 56];
           _scLM9::P64 = P64[_scLOG::P64 + 64];
           _scLMe::P64 = P64[_scLOG::P64 + 72];
           _scLMj::P64 = P64[_scLOG::P64 + 80];
           _scLMo::P64 = P64[_scLOG::P64 + 88];
           _scLMt::P64 = P64[_scLOG::P64 + 96];
           _scLMy::P64 = P64[_scLOG::P64 + 104];
           _scLMD::P64 = P64[_scLOG::P64 + 112];
           _scLMI::P64 = P64[_scLOG::P64 + 120];
           _scLMN::P64 = P64[_scLOG::P64 + 128];
           _scLMS::P64 = P64[_scLOG::P64 + 136];
           _scLMU::P64 = P64[_scLOG::P64 + 144];
           I64[Hp - 136] = sat_scLOC_info;
           P64[Hp - 120] = _scLLQ::P64;
           P64[Hp - 112] = _scLLR::P64;
           P64[Hp - 104] = _scLLS::P64;
           P64[Hp - 96] = _scLLT::P64;
           P64[Hp - 88] = _scLLU::P64;
           P64[Hp - 80] = _scLLV::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           I64[Sp - 24] = block_ccMHb_info;
           R4 = Hp - 136;
           R3 = _scLM9::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMHb() //  [R1, R2]
         { info_tbl: [(ccMHb,
                       label: block_ccMHb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMHb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMHl; else goto ccMHk;
       ccMHl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMHk: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOH_entry() //  [R1]
         { info_tbl: [(ccMHm,
                       label: sat_scLOH_info
                       rep:HeapRep 17 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMHm: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccMHq; else goto ccMHp;
       ccMHq: // global
           HpAlloc = 152;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMHp: // global
           _scLLQ::P64 = P64[R1 + 16];
           _scLLR::P64 = P64[R1 + 24];
           _scLLS::P64 = P64[R1 + 32];
           _scLLT::P64 = P64[R1 + 40];
           _scLLU::P64 = P64[R1 + 48];
           _scLLV::P64 = P64[R1 + 56];
           _scLM9::P64 = P64[R1 + 64];
           _scLMe::P64 = P64[R1 + 72];
           _scLMj::P64 = P64[R1 + 80];
           _scLMo::P64 = P64[R1 + 88];
           _scLMt::P64 = P64[R1 + 96];
           _scLMy::P64 = P64[R1 + 104];
           _scLMD::P64 = P64[R1 + 112];
           _scLMI::P64 = P64[R1 + 120];
           _scLMN::P64 = P64[R1 + 128];
           _scLMS::P64 = P64[R1 + 136];
           _scLMU::P64 = P64[R1 + 144];
           I64[Hp - 144] = sat_scLOG_info;
           P64[Hp - 128] = _scLLQ::P64;
           P64[Hp - 120] = _scLLR::P64;
           P64[Hp - 112] = _scLLS::P64;
           P64[Hp - 104] = _scLLT::P64;
           P64[Hp - 96] = _scLLU::P64;
           P64[Hp - 88] = _scLLV::P64;
           P64[Hp - 80] = _scLM9::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 144;
           R2 = lvl21_rcHpQ_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLOI_entry() //  [R1]
         { info_tbl: [(ccMHr,
                       label: sat_scLOI_info
                       rep:HeapRep 17 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMHr: // global
           _scLOI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMHs; else goto ccMHt;
       ccMHt: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccMHv; else goto ccMHu;
       ccMHv: // global
           HpAlloc = 152;
           goto ccMHs;
       ccMHs: // global
           R1 = _scLOI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMHu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOI::P64;
           _scLLQ::P64 = P64[_scLOI::P64 + 16];
           _scLLR::P64 = P64[_scLOI::P64 + 24];
           _scLLS::P64 = P64[_scLOI::P64 + 32];
           _scLLT::P64 = P64[_scLOI::P64 + 40];
           _scLLU::P64 = P64[_scLOI::P64 + 48];
           _scLLV::P64 = P64[_scLOI::P64 + 56];
           _scLM9::P64 = P64[_scLOI::P64 + 64];
           _scLMe::P64 = P64[_scLOI::P64 + 72];
           _scLMj::P64 = P64[_scLOI::P64 + 80];
           _scLMo::P64 = P64[_scLOI::P64 + 88];
           _scLMt::P64 = P64[_scLOI::P64 + 96];
           _scLMy::P64 = P64[_scLOI::P64 + 104];
           _scLMD::P64 = P64[_scLOI::P64 + 112];
           _scLMI::P64 = P64[_scLOI::P64 + 120];
           _scLMN::P64 = P64[_scLOI::P64 + 128];
           _scLMS::P64 = P64[_scLOI::P64 + 136];
           _scLMU::P64 = P64[_scLOI::P64 + 144];
           I64[Hp - 144] = sat_scLOH_info;
           P64[Hp - 128] = _scLLQ::P64;
           P64[Hp - 120] = _scLLR::P64;
           P64[Hp - 112] = _scLLS::P64;
           P64[Hp - 104] = _scLLT::P64;
           P64[Hp - 96] = _scLLU::P64;
           P64[Hp - 88] = _scLLV::P64;
           P64[Hp - 80] = _scLM9::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 144;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOM_entry() //  [R1]
         { info_tbl: [(ccMHz,
                       label: sat_scLOM_info
                       rep:HeapRep 18 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMHz: // global
           _scLOM::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMHA; else goto ccMHB;
       ccMHB: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccMHD; else goto ccMHC;
       ccMHD: // global
           HpAlloc = 152;
           goto ccMHA;
       ccMHA: // global
           R1 = _scLOM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMHC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOM::P64;
           _scLLQ::P64 = P64[_scLOM::P64 + 16];
           _scLLR::P64 = P64[_scLOM::P64 + 24];
           _scLLS::P64 = P64[_scLOM::P64 + 32];
           _scLLT::P64 = P64[_scLOM::P64 + 40];
           _scLLU::P64 = P64[_scLOM::P64 + 48];
           _scLLV::P64 = P64[_scLOM::P64 + 56];
           _scLM4::P64 = P64[_scLOM::P64 + 64];
           _scLM9::P64 = P64[_scLOM::P64 + 72];
           _scLMe::P64 = P64[_scLOM::P64 + 80];
           _scLMj::P64 = P64[_scLOM::P64 + 88];
           _scLMo::P64 = P64[_scLOM::P64 + 96];
           _scLMt::P64 = P64[_scLOM::P64 + 104];
           _scLMy::P64 = P64[_scLOM::P64 + 112];
           _scLMD::P64 = P64[_scLOM::P64 + 120];
           _scLMI::P64 = P64[_scLOM::P64 + 128];
           _scLMN::P64 = P64[_scLOM::P64 + 136];
           _scLMS::P64 = P64[_scLOM::P64 + 144];
           _scLMU::P64 = P64[_scLOM::P64 + 152];
           I64[Hp - 144] = sat_scLOI_info;
           P64[Hp - 128] = _scLLQ::P64;
           P64[Hp - 120] = _scLLR::P64;
           P64[Hp - 112] = _scLLS::P64;
           P64[Hp - 104] = _scLLT::P64;
           P64[Hp - 96] = _scLLU::P64;
           P64[Hp - 88] = _scLLV::P64;
           P64[Hp - 80] = _scLM9::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           I64[Sp - 24] = block_ccMHw_info;
           R4 = Hp - 144;
           R3 = _scLM4::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMHw() //  [R1, R2]
         { info_tbl: [(ccMHw,
                       label: block_ccMHw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMHw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMHG; else goto ccMHF;
       ccMHG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMHF: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLON_entry() //  [R1]
         { info_tbl: [(ccMHH,
                       label: sat_scLON_info
                       rep:HeapRep 18 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMHH: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccMHL; else goto ccMHK;
       ccMHL: // global
           HpAlloc = 160;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMHK: // global
           _scLLQ::P64 = P64[R1 + 16];
           _scLLR::P64 = P64[R1 + 24];
           _scLLS::P64 = P64[R1 + 32];
           _scLLT::P64 = P64[R1 + 40];
           _scLLU::P64 = P64[R1 + 48];
           _scLLV::P64 = P64[R1 + 56];
           _scLM4::P64 = P64[R1 + 64];
           _scLM9::P64 = P64[R1 + 72];
           _scLMe::P64 = P64[R1 + 80];
           _scLMj::P64 = P64[R1 + 88];
           _scLMo::P64 = P64[R1 + 96];
           _scLMt::P64 = P64[R1 + 104];
           _scLMy::P64 = P64[R1 + 112];
           _scLMD::P64 = P64[R1 + 120];
           _scLMI::P64 = P64[R1 + 128];
           _scLMN::P64 = P64[R1 + 136];
           _scLMS::P64 = P64[R1 + 144];
           _scLMU::P64 = P64[R1 + 152];
           I64[Hp - 152] = sat_scLOM_info;
           P64[Hp - 136] = _scLLQ::P64;
           P64[Hp - 128] = _scLLR::P64;
           P64[Hp - 120] = _scLLS::P64;
           P64[Hp - 112] = _scLLT::P64;
           P64[Hp - 104] = _scLLU::P64;
           P64[Hp - 96] = _scLLV::P64;
           P64[Hp - 88] = _scLM4::P64;
           P64[Hp - 80] = _scLM9::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 152;
           R2 = lvl20_rcHpP_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLOO_entry() //  [R1]
         { info_tbl: [(ccMHM,
                       label: sat_scLOO_info
                       rep:HeapRep 18 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMHM: // global
           _scLOO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMHN; else goto ccMHO;
       ccMHO: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccMHQ; else goto ccMHP;
       ccMHQ: // global
           HpAlloc = 160;
           goto ccMHN;
       ccMHN: // global
           R1 = _scLOO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMHP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOO::P64;
           _scLLQ::P64 = P64[_scLOO::P64 + 16];
           _scLLR::P64 = P64[_scLOO::P64 + 24];
           _scLLS::P64 = P64[_scLOO::P64 + 32];
           _scLLT::P64 = P64[_scLOO::P64 + 40];
           _scLLU::P64 = P64[_scLOO::P64 + 48];
           _scLLV::P64 = P64[_scLOO::P64 + 56];
           _scLM4::P64 = P64[_scLOO::P64 + 64];
           _scLM9::P64 = P64[_scLOO::P64 + 72];
           _scLMe::P64 = P64[_scLOO::P64 + 80];
           _scLMj::P64 = P64[_scLOO::P64 + 88];
           _scLMo::P64 = P64[_scLOO::P64 + 96];
           _scLMt::P64 = P64[_scLOO::P64 + 104];
           _scLMy::P64 = P64[_scLOO::P64 + 112];
           _scLMD::P64 = P64[_scLOO::P64 + 120];
           _scLMI::P64 = P64[_scLOO::P64 + 128];
           _scLMN::P64 = P64[_scLOO::P64 + 136];
           _scLMS::P64 = P64[_scLOO::P64 + 144];
           _scLMU::P64 = P64[_scLOO::P64 + 152];
           I64[Hp - 152] = sat_scLON_info;
           P64[Hp - 136] = _scLLQ::P64;
           P64[Hp - 128] = _scLLR::P64;
           P64[Hp - 120] = _scLLS::P64;
           P64[Hp - 112] = _scLLT::P64;
           P64[Hp - 104] = _scLLU::P64;
           P64[Hp - 96] = _scLLV::P64;
           P64[Hp - 88] = _scLM4::P64;
           P64[Hp - 80] = _scLM9::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 152;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOS_entry() //  [R1]
         { info_tbl: [(ccMHU,
                       label: sat_scLOS_info
                       rep:HeapRep 19 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMHU: // global
           _scLOS::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ccMHV; else goto ccMHW;
       ccMHW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccMHY; else goto ccMHX;
       ccMHY: // global
           HpAlloc = 160;
           goto ccMHV;
       ccMHV: // global
           R1 = _scLOS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMHX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOS::P64;
           _scLLQ::P64 = P64[_scLOS::P64 + 16];
           _scLLR::P64 = P64[_scLOS::P64 + 24];
           _scLLS::P64 = P64[_scLOS::P64 + 32];
           _scLLT::P64 = P64[_scLOS::P64 + 40];
           _scLLU::P64 = P64[_scLOS::P64 + 48];
           _scLLV::P64 = P64[_scLOS::P64 + 56];
           _scLLZ::P64 = P64[_scLOS::P64 + 64];
           _scLM4::P64 = P64[_scLOS::P64 + 72];
           _scLM9::P64 = P64[_scLOS::P64 + 80];
           _scLMe::P64 = P64[_scLOS::P64 + 88];
           _scLMj::P64 = P64[_scLOS::P64 + 96];
           _scLMo::P64 = P64[_scLOS::P64 + 104];
           _scLMt::P64 = P64[_scLOS::P64 + 112];
           _scLMy::P64 = P64[_scLOS::P64 + 120];
           _scLMD::P64 = P64[_scLOS::P64 + 128];
           _scLMI::P64 = P64[_scLOS::P64 + 136];
           _scLMN::P64 = P64[_scLOS::P64 + 144];
           _scLMS::P64 = P64[_scLOS::P64 + 152];
           _scLMU::P64 = P64[_scLOS::P64 + 160];
           I64[Hp - 152] = sat_scLOO_info;
           P64[Hp - 136] = _scLLQ::P64;
           P64[Hp - 128] = _scLLR::P64;
           P64[Hp - 120] = _scLLS::P64;
           P64[Hp - 112] = _scLLT::P64;
           P64[Hp - 104] = _scLLU::P64;
           P64[Hp - 96] = _scLLV::P64;
           P64[Hp - 88] = _scLM4::P64;
           P64[Hp - 80] = _scLM9::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           I64[Sp - 24] = block_ccMHR_info;
           R4 = Hp - 152;
           R3 = _scLLZ::P64;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMHR() //  [R1, R2]
         { info_tbl: [(ccMHR,
                       label: block_ccMHR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMHR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMI1; else goto ccMI0;
       ccMI1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMI0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOT_entry() //  [R1]
         { info_tbl: [(ccMI2,
                       label: sat_scLOT_info
                       rep:HeapRep 19 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMI2: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccMI6; else goto ccMI5;
       ccMI6: // global
           HpAlloc = 168;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMI5: // global
           _scLLQ::P64 = P64[R1 + 16];
           _scLLR::P64 = P64[R1 + 24];
           _scLLS::P64 = P64[R1 + 32];
           _scLLT::P64 = P64[R1 + 40];
           _scLLU::P64 = P64[R1 + 48];
           _scLLV::P64 = P64[R1 + 56];
           _scLLZ::P64 = P64[R1 + 64];
           _scLM4::P64 = P64[R1 + 72];
           _scLM9::P64 = P64[R1 + 80];
           _scLMe::P64 = P64[R1 + 88];
           _scLMj::P64 = P64[R1 + 96];
           _scLMo::P64 = P64[R1 + 104];
           _scLMt::P64 = P64[R1 + 112];
           _scLMy::P64 = P64[R1 + 120];
           _scLMD::P64 = P64[R1 + 128];
           _scLMI::P64 = P64[R1 + 136];
           _scLMN::P64 = P64[R1 + 144];
           _scLMS::P64 = P64[R1 + 152];
           _scLMU::P64 = P64[R1 + 160];
           I64[Hp - 160] = sat_scLOS_info;
           P64[Hp - 144] = _scLLQ::P64;
           P64[Hp - 136] = _scLLR::P64;
           P64[Hp - 128] = _scLLS::P64;
           P64[Hp - 120] = _scLLT::P64;
           P64[Hp - 112] = _scLLU::P64;
           P64[Hp - 104] = _scLLV::P64;
           P64[Hp - 96] = _scLLZ::P64;
           P64[Hp - 88] = _scLM4::P64;
           P64[Hp - 80] = _scLM9::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 160;
           R2 = lvl19_rcHpO_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLOU_entry() //  [R1]
         { info_tbl: [(ccMI7,
                       label: sat_scLOU_info
                       rep:HeapRep 19 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMI7: // global
           _scLOU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMI8; else goto ccMI9;
       ccMI9: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccMIb; else goto ccMIa;
       ccMIb: // global
           HpAlloc = 168;
           goto ccMI8;
       ccMI8: // global
           R1 = _scLOU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMIa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLOU::P64;
           _scLLQ::P64 = P64[_scLOU::P64 + 16];
           _scLLR::P64 = P64[_scLOU::P64 + 24];
           _scLLS::P64 = P64[_scLOU::P64 + 32];
           _scLLT::P64 = P64[_scLOU::P64 + 40];
           _scLLU::P64 = P64[_scLOU::P64 + 48];
           _scLLV::P64 = P64[_scLOU::P64 + 56];
           _scLLZ::P64 = P64[_scLOU::P64 + 64];
           _scLM4::P64 = P64[_scLOU::P64 + 72];
           _scLM9::P64 = P64[_scLOU::P64 + 80];
           _scLMe::P64 = P64[_scLOU::P64 + 88];
           _scLMj::P64 = P64[_scLOU::P64 + 96];
           _scLMo::P64 = P64[_scLOU::P64 + 104];
           _scLMt::P64 = P64[_scLOU::P64 + 112];
           _scLMy::P64 = P64[_scLOU::P64 + 120];
           _scLMD::P64 = P64[_scLOU::P64 + 128];
           _scLMI::P64 = P64[_scLOU::P64 + 136];
           _scLMN::P64 = P64[_scLOU::P64 + 144];
           _scLMS::P64 = P64[_scLOU::P64 + 152];
           _scLMU::P64 = P64[_scLOU::P64 + 160];
           I64[Hp - 160] = sat_scLOT_info;
           P64[Hp - 144] = _scLLQ::P64;
           P64[Hp - 136] = _scLLR::P64;
           P64[Hp - 128] = _scLLS::P64;
           P64[Hp - 120] = _scLLT::P64;
           P64[Hp - 112] = _scLLU::P64;
           P64[Hp - 104] = _scLLV::P64;
           P64[Hp - 96] = _scLLZ::P64;
           P64[Hp - 88] = _scLM4::P64;
           P64[Hp - 80] = _scLM9::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 160;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOY_entry() //  [R1]
         { info_tbl: [(ccMIc,
                       label: sat_scLOY_info
                       rep:HeapRep 20 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMIc: // global
           if ((Sp + -176) < SpLim) (likely: False) goto ccMIj; else goto ccMIk;
       ccMIj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMIk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 176] = block_ccMxQ_info;
           _scLLQ::P64 = P64[R1 + 24];
           _scLLR::P64 = P64[R1 + 32];
           _scLLS::P64 = P64[R1 + 40];
           _scLLT::P64 = P64[R1 + 48];
           _scLLU::P64 = P64[R1 + 56];
           _scLLV::P64 = P64[R1 + 64];
           _scLLZ::P64 = P64[R1 + 72];
           _scLM4::P64 = P64[R1 + 80];
           _scLM9::P64 = P64[R1 + 88];
           _scLMe::P64 = P64[R1 + 96];
           _scLMj::P64 = P64[R1 + 104];
           _scLMo::P64 = P64[R1 + 112];
           _scLMt::P64 = P64[R1 + 120];
           _scLMy::P64 = P64[R1 + 128];
           _scLMD::P64 = P64[R1 + 136];
           _scLMI::P64 = P64[R1 + 144];
           _scLMN::P64 = P64[R1 + 152];
           _scLMS::P64 = P64[R1 + 160];
           _scLMU::P64 = P64[R1 + 168];
           R1 = P64[R1 + 16];
           P64[Sp - 168] = _scLLQ::P64;
           P64[Sp - 160] = _scLLR::P64;
           P64[Sp - 152] = _scLLS::P64;
           P64[Sp - 144] = _scLLT::P64;
           P64[Sp - 136] = _scLLU::P64;
           P64[Sp - 128] = _scLLV::P64;
           P64[Sp - 120] = _scLLZ::P64;
           P64[Sp - 112] = _scLM4::P64;
           P64[Sp - 104] = _scLM9::P64;
           P64[Sp - 96] = _scLMe::P64;
           P64[Sp - 88] = _scLMj::P64;
           P64[Sp - 80] = _scLMo::P64;
           P64[Sp - 72] = _scLMt::P64;
           P64[Sp - 64] = _scLMy::P64;
           P64[Sp - 56] = _scLMD::P64;
           P64[Sp - 48] = _scLMI::P64;
           P64[Sp - 40] = _scLMN::P64;
           P64[Sp - 32] = _scLMS::P64;
           P64[Sp - 24] = _scLMU::P64;
           Sp = Sp - 176;
           if (R1 & 7 != 0) goto ucMIr; else goto ccMxR;
       ucMIr: // global
           call _ccMxQ(R1) args: 0, res: 0, upd: 0;
       ccMxR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMxQ() //  [R1]
         { info_tbl: [(ccMxQ,
                       label: block_ccMxQ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMxQ: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccMIn; else goto ccMIm;
       ccMIn: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccMIm: // global
           _scLMZ::I64 = I64[R1 + 7];
           I64[Hp - 160] = sat_scLOU_info;
           P64[Hp - 144] = P64[Sp + 8];
           P64[Hp - 136] = P64[Sp + 16];
           P64[Hp - 128] = P64[Sp + 24];
           P64[Hp - 120] = P64[Sp + 32];
           P64[Hp - 112] = P64[Sp + 40];
           P64[Hp - 104] = P64[Sp + 48];
           P64[Hp - 96] = P64[Sp + 56];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = P64[Sp + 72];
           P64[Hp - 72] = P64[Sp + 80];
           P64[Hp - 64] = P64[Sp + 88];
           P64[Hp - 56] = P64[Sp + 96];
           P64[Hp - 48] = P64[Sp + 104];
           P64[Hp - 40] = P64[Sp + 112];
           P64[Hp - 32] = P64[Sp + 120];
           P64[Hp - 24] = P64[Sp + 128];
           P64[Hp - 16] = P64[Sp + 136];
           P64[Hp - 8] = P64[Sp + 144];
           P64[Hp] = P64[Sp + 152];
           I64[Sp + 152] = block_ccMIg_info;
           R3 = Hp - 160;
           R2 = _scLMZ::I64;
           Sp = Sp + 152;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMIg() //  [R1, R2]
         { info_tbl: [(ccMIg,
                       label: block_ccMIg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMIg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMIq; else goto ccMIp;
       ccMIq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMIp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLOZ_entry() //  [R1]
         { info_tbl: [(ccMIs,
                       label: sat_scLOZ_info
                       rep:HeapRep 20 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMIs: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccMIw; else goto ccMIv;
       ccMIw: // global
           HpAlloc = 176;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMIv: // global
           _scLLE::P64 = P64[R1 + 16];
           _scLLQ::P64 = P64[R1 + 24];
           _scLLR::P64 = P64[R1 + 32];
           _scLLS::P64 = P64[R1 + 40];
           _scLLT::P64 = P64[R1 + 48];
           _scLLU::P64 = P64[R1 + 56];
           _scLLV::P64 = P64[R1 + 64];
           _scLLZ::P64 = P64[R1 + 72];
           _scLM4::P64 = P64[R1 + 80];
           _scLM9::P64 = P64[R1 + 88];
           _scLMe::P64 = P64[R1 + 96];
           _scLMj::P64 = P64[R1 + 104];
           _scLMo::P64 = P64[R1 + 112];
           _scLMt::P64 = P64[R1 + 120];
           _scLMy::P64 = P64[R1 + 128];
           _scLMD::P64 = P64[R1 + 136];
           _scLMI::P64 = P64[R1 + 144];
           _scLMN::P64 = P64[R1 + 152];
           _scLMS::P64 = P64[R1 + 160];
           _scLMU::P64 = P64[R1 + 168];
           I64[Hp - 168] = sat_scLOY_info;
           P64[Hp - 152] = _scLLE::P64;
           P64[Hp - 144] = _scLLQ::P64;
           P64[Hp - 136] = _scLLR::P64;
           P64[Hp - 128] = _scLLS::P64;
           P64[Hp - 120] = _scLLT::P64;
           P64[Hp - 112] = _scLLU::P64;
           P64[Hp - 104] = _scLLV::P64;
           P64[Hp - 96] = _scLLZ::P64;
           P64[Hp - 88] = _scLM4::P64;
           P64[Hp - 80] = _scLM9::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 168;
           R2 = lvl18_rcHpN_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLP0_entry() //  [R1]
         { info_tbl: [(ccMIx,
                       label: sat_scLP0_info
                       rep:HeapRep 20 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMIx: // global
           _scLP0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMIy; else goto ccMIz;
       ccMIz: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccMIB; else goto ccMIA;
       ccMIB: // global
           HpAlloc = 176;
           goto ccMIy;
       ccMIy: // global
           R1 = _scLP0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMIA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLP0::P64;
           _scLLE::P64 = P64[_scLP0::P64 + 16];
           _scLLQ::P64 = P64[_scLP0::P64 + 24];
           _scLLR::P64 = P64[_scLP0::P64 + 32];
           _scLLS::P64 = P64[_scLP0::P64 + 40];
           _scLLT::P64 = P64[_scLP0::P64 + 48];
           _scLLU::P64 = P64[_scLP0::P64 + 56];
           _scLLV::P64 = P64[_scLP0::P64 + 64];
           _scLLZ::P64 = P64[_scLP0::P64 + 72];
           _scLM4::P64 = P64[_scLP0::P64 + 80];
           _scLM9::P64 = P64[_scLP0::P64 + 88];
           _scLMe::P64 = P64[_scLP0::P64 + 96];
           _scLMj::P64 = P64[_scLP0::P64 + 104];
           _scLMo::P64 = P64[_scLP0::P64 + 112];
           _scLMt::P64 = P64[_scLP0::P64 + 120];
           _scLMy::P64 = P64[_scLP0::P64 + 128];
           _scLMD::P64 = P64[_scLP0::P64 + 136];
           _scLMI::P64 = P64[_scLP0::P64 + 144];
           _scLMN::P64 = P64[_scLP0::P64 + 152];
           _scLMS::P64 = P64[_scLP0::P64 + 160];
           _scLMU::P64 = P64[_scLP0::P64 + 168];
           I64[Hp - 168] = sat_scLOZ_info;
           P64[Hp - 152] = _scLLE::P64;
           P64[Hp - 144] = _scLLQ::P64;
           P64[Hp - 136] = _scLLR::P64;
           P64[Hp - 128] = _scLLS::P64;
           P64[Hp - 120] = _scLLT::P64;
           P64[Hp - 112] = _scLLU::P64;
           P64[Hp - 104] = _scLLV::P64;
           P64[Hp - 96] = _scLLZ::P64;
           P64[Hp - 88] = _scLM4::P64;
           P64[Hp - 80] = _scLM9::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 168;
           R2 = GHC.Show.showCommaSpace1_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLP4_entry() //  [R1]
         { info_tbl: [(ccMIC,
                       label: sat_scLP4_info
                       rep:HeapRep 21 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMIC: // global
           if ((Sp + -184) < SpLim) (likely: False) goto ccMIJ; else goto ccMIK;
       ccMIJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMIK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 184] = block_ccMxz_info;
           _scLLE::P64 = P64[R1 + 24];
           _scLLQ::P64 = P64[R1 + 32];
           _scLLR::P64 = P64[R1 + 40];
           _scLLS::P64 = P64[R1 + 48];
           _scLLT::P64 = P64[R1 + 56];
           _scLLU::P64 = P64[R1 + 64];
           _scLLV::P64 = P64[R1 + 72];
           _scLLZ::P64 = P64[R1 + 80];
           _scLM4::P64 = P64[R1 + 88];
           _scLM9::P64 = P64[R1 + 96];
           _scLMe::P64 = P64[R1 + 104];
           _scLMj::P64 = P64[R1 + 112];
           _scLMo::P64 = P64[R1 + 120];
           _scLMt::P64 = P64[R1 + 128];
           _scLMy::P64 = P64[R1 + 136];
           _scLMD::P64 = P64[R1 + 144];
           _scLMI::P64 = P64[R1 + 152];
           _scLMN::P64 = P64[R1 + 160];
           _scLMS::P64 = P64[R1 + 168];
           _scLMU::P64 = P64[R1 + 176];
           R1 = P64[R1 + 16];
           P64[Sp - 176] = _scLLE::P64;
           P64[Sp - 168] = _scLLQ::P64;
           P64[Sp - 160] = _scLLR::P64;
           P64[Sp - 152] = _scLLS::P64;
           P64[Sp - 144] = _scLLT::P64;
           P64[Sp - 136] = _scLLU::P64;
           P64[Sp - 128] = _scLLV::P64;
           P64[Sp - 120] = _scLLZ::P64;
           P64[Sp - 112] = _scLM4::P64;
           P64[Sp - 104] = _scLM9::P64;
           P64[Sp - 96] = _scLMe::P64;
           P64[Sp - 88] = _scLMj::P64;
           P64[Sp - 80] = _scLMo::P64;
           P64[Sp - 72] = _scLMt::P64;
           P64[Sp - 64] = _scLMy::P64;
           P64[Sp - 56] = _scLMD::P64;
           P64[Sp - 48] = _scLMI::P64;
           P64[Sp - 40] = _scLMN::P64;
           P64[Sp - 32] = _scLMS::P64;
           P64[Sp - 24] = _scLMU::P64;
           Sp = Sp - 184;
           if (R1 & 7 != 0) goto ucMIR; else goto ccMxA;
       ucMIR: // global
           call _ccMxz(R1) args: 0, res: 0, upd: 0;
       ccMxA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _ccMxz() //  [R1]
         { info_tbl: [(ccMxz,
                       label: block_ccMxz_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMxz: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccMIN; else goto ccMIM;
       ccMIN: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ccMIM: // global
           _scLMW::I64 = I64[R1 + 7];
           I64[Hp - 168] = sat_scLP0_info;
           P64[Hp - 152] = P64[Sp + 8];
           P64[Hp - 144] = P64[Sp + 16];
           P64[Hp - 136] = P64[Sp + 24];
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 40];
           P64[Hp - 112] = P64[Sp + 48];
           P64[Hp - 104] = P64[Sp + 56];
           P64[Hp - 96] = P64[Sp + 64];
           P64[Hp - 88] = P64[Sp + 72];
           P64[Hp - 80] = P64[Sp + 80];
           P64[Hp - 72] = P64[Sp + 88];
           P64[Hp - 64] = P64[Sp + 96];
           P64[Hp - 56] = P64[Sp + 104];
           P64[Hp - 48] = P64[Sp + 112];
           P64[Hp - 40] = P64[Sp + 120];
           P64[Hp - 32] = P64[Sp + 128];
           P64[Hp - 24] = P64[Sp + 136];
           P64[Hp - 16] = P64[Sp + 144];
           P64[Hp - 8] = P64[Sp + 152];
           P64[Hp] = P64[Sp + 160];
           I64[Sp + 160] = block_ccMIG_info;
           R3 = Hp - 168;
           R2 = _scLMW::I64;
           Sp = Sp + 160;
           call GHC.Show.$witos_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccMIG() //  [R1, R2]
         { info_tbl: [(ccMIG,
                       label: block_ccMIG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMIG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMIQ; else goto ccMIP;
       ccMIQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccMIP: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLP5_entry() //  [R1]
         { info_tbl: [(ccMIS,
                       label: sat_scLP5_info
                       rep:HeapRep 21 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMIS: // global
           _scLP5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMIT; else goto ccMIU;
       ccMIU: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto ccMIW; else goto ccMIV;
       ccMIW: // global
           HpAlloc = 184;
           goto ccMIT;
       ccMIT: // global
           R1 = _scLP5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMIV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLP5::P64;
           _scLLD::P64 = P64[_scLP5::P64 + 16];
           _scLLE::P64 = P64[_scLP5::P64 + 24];
           _scLLQ::P64 = P64[_scLP5::P64 + 32];
           _scLLR::P64 = P64[_scLP5::P64 + 40];
           _scLLS::P64 = P64[_scLP5::P64 + 48];
           _scLLT::P64 = P64[_scLP5::P64 + 56];
           _scLLU::P64 = P64[_scLP5::P64 + 64];
           _scLLV::P64 = P64[_scLP5::P64 + 72];
           _scLLZ::P64 = P64[_scLP5::P64 + 80];
           _scLM4::P64 = P64[_scLP5::P64 + 88];
           _scLM9::P64 = P64[_scLP5::P64 + 96];
           _scLMe::P64 = P64[_scLP5::P64 + 104];
           _scLMj::P64 = P64[_scLP5::P64 + 112];
           _scLMo::P64 = P64[_scLP5::P64 + 120];
           _scLMt::P64 = P64[_scLP5::P64 + 128];
           _scLMy::P64 = P64[_scLP5::P64 + 136];
           _scLMD::P64 = P64[_scLP5::P64 + 144];
           _scLMI::P64 = P64[_scLP5::P64 + 152];
           _scLMN::P64 = P64[_scLP5::P64 + 160];
           _scLMS::P64 = P64[_scLP5::P64 + 168];
           _scLMU::P64 = P64[_scLP5::P64 + 176];
           I64[Hp - 176] = sat_scLP4_info;
           P64[Hp - 160] = _scLLD::P64;
           P64[Hp - 152] = _scLLE::P64;
           P64[Hp - 144] = _scLLQ::P64;
           P64[Hp - 136] = _scLLR::P64;
           P64[Hp - 128] = _scLLS::P64;
           P64[Hp - 120] = _scLLT::P64;
           P64[Hp - 112] = _scLLU::P64;
           P64[Hp - 104] = _scLLV::P64;
           P64[Hp - 96] = _scLLZ::P64;
           P64[Hp - 88] = _scLM4::P64;
           P64[Hp - 80] = _scLM9::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = _scLMU::P64;
           R3 = Hp - 176;
           R2 = lvl17_rcHpM_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 p_scLMT_entry() //  [R1, R2]
         { info_tbl: [(ccMIX,
                       label: p_scLMT_info
                       rep:HeapRep 20 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMIX: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto ccMJ1; else goto ccMJ0;
       ccMJ1: // global
           HpAlloc = 184;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccMJ0: // global
           _scLLD::P64 = P64[R1 + 7];
           _scLLE::P64 = P64[R1 + 15];
           _scLLQ::P64 = P64[R1 + 23];
           _scLLR::P64 = P64[R1 + 31];
           _scLLS::P64 = P64[R1 + 39];
           _scLLT::P64 = P64[R1 + 47];
           _scLLU::P64 = P64[R1 + 55];
           _scLLV::P64 = P64[R1 + 63];
           _scLLZ::P64 = P64[R1 + 71];
           _scLM4::P64 = P64[R1 + 79];
           _scLM9::P64 = P64[R1 + 87];
           _scLMe::P64 = P64[R1 + 95];
           _scLMj::P64 = P64[R1 + 103];
           _scLMo::P64 = P64[R1 + 111];
           _scLMt::P64 = P64[R1 + 119];
           _scLMy::P64 = P64[R1 + 127];
           _scLMD::P64 = P64[R1 + 135];
           _scLMI::P64 = P64[R1 + 143];
           _scLMN::P64 = P64[R1 + 151];
           _scLMS::P64 = P64[R1 + 159];
           I64[Hp - 176] = sat_scLP5_info;
           P64[Hp - 160] = _scLLD::P64;
           P64[Hp - 152] = _scLLE::P64;
           P64[Hp - 144] = _scLLQ::P64;
           P64[Hp - 136] = _scLLR::P64;
           P64[Hp - 128] = _scLLS::P64;
           P64[Hp - 120] = _scLLT::P64;
           P64[Hp - 112] = _scLLU::P64;
           P64[Hp - 104] = _scLLV::P64;
           P64[Hp - 96] = _scLLZ::P64;
           P64[Hp - 88] = _scLM4::P64;
           P64[Hp - 80] = _scLM9::P64;
           P64[Hp - 72] = _scLMe::P64;
           P64[Hp - 64] = _scLMj::P64;
           P64[Hp - 56] = _scLMo::P64;
           P64[Hp - 48] = _scLMt::P64;
           P64[Hp - 40] = _scLMy::P64;
           P64[Hp - 32] = _scLMD::P64;
           P64[Hp - 24] = _scLMI::P64;
           P64[Hp - 16] = _scLMN::P64;
           P64[Hp - 8] = _scLMS::P64;
           P64[Hp] = R2;
           R3 = Hp - 176;
           R2 = lvl16_rcHpL_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLP9_entry() //  [R1]
         { info_tbl: [(ccMJg,
                       label: sat_scLP9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMJg: // global
           _scLP9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccMJh; else goto ccMJi;
       ccMJi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccMJk; else goto ccMJj;
       ccMJk: // global
           HpAlloc = 24;
           goto ccMJh;
       ccMJh: // global
           R1 = _scLP9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMJj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scLP9::P64;
           _scLMT::P64 = P64[_scLP9::P64 + 16];
           _scLP7::P64 = P64[_scLP9::P64 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _scLP7::P64;
           R2 = Hp - 14;
           R1 = _scLMT::P64;
           Sp = Sp - 16;
           call p_scLMT_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scLPa_entry() //  [R1, R2]
         { info_tbl: [(ccMJm,
                       label: sat_scLPa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMJm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccMJq; else goto ccMJp;
       ccMJq: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccMJp: // global
           _scLMT::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_scLP9_info;
           P64[Hp - 32] = _scLMT::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stats.$fShowRTSStats_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(ccMJr,
                       label: GHC.Stats.$fShowRTSStats_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMJr: // global
           if ((Sp + -168) < SpLim) (likely: False) goto ccMJs; else goto ccMJt;
       ccMJs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fShowRTSStats_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccMJt: // global
           I64[Sp - 16] = block_ccMtb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucMJC; else goto ccMtc;
       ucMJC: // global
           call _ccMtb(R1) args: 0, res: 0, upd: 0;
       ccMtc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccMtb() //  [R1]
         { info_tbl: [(ccMtb,
                       label: block_ccMtb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMtb: // global
           I64[Sp - 152] = block_ccMtg_info;
           _scLLD::P64 = P64[R1 + 7];
           _scLLE::P64 = P64[R1 + 15];
           _scLLF::P64 = P64[R1 + 23];
           _scLLG::P64 = P64[R1 + 31];
           _scLLH::P64 = P64[R1 + 39];
           _scLLI::P64 = P64[R1 + 47];
           _scLLJ::P64 = P64[R1 + 55];
           _scLLK::P64 = P64[R1 + 63];
           _scLLL::P64 = P64[R1 + 71];
           _scLLM::P64 = P64[R1 + 79];
           _scLLN::P64 = P64[R1 + 87];
           _scLLO::P64 = P64[R1 + 95];
           _scLLP::P64 = P64[R1 + 103];
           _scLLQ::P64 = P64[R1 + 111];
           _scLLR::P64 = P64[R1 + 119];
           _scLLS::P64 = P64[R1 + 127];
           _scLLT::P64 = P64[R1 + 135];
           _scLLU::P64 = P64[R1 + 143];
           _scLLV::P64 = P64[R1 + 151];
           _scLLW::P64 = P64[R1 + 159];
           R1 = P64[Sp + 8];
           P64[Sp - 144] = _scLLF::P64;
           P64[Sp - 136] = _scLLG::P64;
           P64[Sp - 128] = _scLLH::P64;
           P64[Sp - 120] = _scLLI::P64;
           P64[Sp - 112] = _scLLJ::P64;
           P64[Sp - 104] = _scLLK::P64;
           P64[Sp - 96] = _scLLL::P64;
           P64[Sp - 88] = _scLLM::P64;
           P64[Sp - 80] = _scLLN::P64;
           P64[Sp - 72] = _scLLO::P64;
           P64[Sp - 64] = _scLLP::P64;
           P64[Sp - 56] = _scLLQ::P64;
           P64[Sp - 48] = _scLLR::P64;
           P64[Sp - 40] = _scLLS::P64;
           P64[Sp - 32] = _scLLT::P64;
           P64[Sp - 24] = _scLLU::P64;
           P64[Sp - 16] = _scLLV::P64;
           P64[Sp - 8] = _scLLW::P64;
           P64[Sp] = _scLLE::P64;
           P64[Sp + 8] = _scLLD::P64;
           Sp = Sp - 152;
           if (R1 & 7 != 0) goto ucMJB; else goto ccMth;
       ucMJB: // global
           call _ccMtg(R1) args: 0, res: 0, upd: 0;
       ccMth: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccMtg() //  [R1]
         { info_tbl: [(ccMtg,
                       label: block_ccMtg_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False, False, False, False, False, False, False,
                                     False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMtg: // global
           Hp = Hp + 472;
           if (Hp > HpLim) (likely: False) goto ccMJx; else goto ccMJw;
       ccMJx: // global
           HpAlloc = 472;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccMJw: // global
           _scLLY::I64 = I64[R1 + 7];
           I64[Hp - 464] = w1_scLLZ_info;
           P64[Hp - 448] = P64[Sp + 8];
           I64[Hp - 440] = w2_scLM4_info;
           P64[Hp - 424] = P64[Sp + 16];
           I64[Hp - 416] = w3_scLM9_info;
           P64[Hp - 400] = P64[Sp + 24];
           I64[Hp - 392] = w4_scLMe_info;
           P64[Hp - 376] = P64[Sp + 32];
           I64[Hp - 368] = w5_scLMj_info;
           P64[Hp - 352] = P64[Sp + 40];
           I64[Hp - 344] = w6_scLMo_info;
           P64[Hp - 328] = P64[Sp + 48];
           I64[Hp - 320] = w7_scLMt_info;
           P64[Hp - 304] = P64[Sp + 56];
           I64[Hp - 296] = w8_scLMy_info;
           P64[Hp - 280] = P64[Sp + 64];
           I64[Hp - 272] = w9_scLMD_info;
           P64[Hp - 256] = P64[Sp + 72];
           I64[Hp - 248] = w10_scLMI_info;
           P64[Hp - 232] = P64[Sp + 80];
           I64[Hp - 224] = w11_scLMN_info;
           P64[Hp - 208] = P64[Sp + 88];
           I64[Hp - 200] = f_scLMS_info;
           P64[Hp - 184] = P64[Sp + 144];
           I64[Hp - 176] = p_scLMT_info;
           P64[Hp - 168] = P64[Sp + 160];
           P64[Hp - 160] = P64[Sp + 152];
           P64[Hp - 152] = P64[Sp + 96];
           P64[Hp - 144] = P64[Sp + 104];
           P64[Hp - 136] = P64[Sp + 112];
           P64[Hp - 128] = P64[Sp + 120];
           P64[Hp - 120] = P64[Sp + 128];
           P64[Hp - 112] = P64[Sp + 136];
           P64[Hp - 104] = Hp - 464;
           P64[Hp - 96] = Hp - 440;
           P64[Hp - 88] = Hp - 416;
           P64[Hp - 80] = Hp - 392;
           P64[Hp - 72] = Hp - 368;
           P64[Hp - 64] = Hp - 344;
           P64[Hp - 56] = Hp - 320;
           P64[Hp - 48] = Hp - 296;
           P64[Hp - 40] = Hp - 272;
           P64[Hp - 32] = Hp - 248;
           P64[Hp - 24] = Hp - 224;
           P64[Hp - 16] = Hp - 200;
           _ccMxm::P64 = Hp - 175;
           if (%MO_S_Lt_W64(_scLLY::I64, 11)) goto ccMJz; else goto ccMJA;
       ccMJz: // global
           Hp = Hp - 16;
           R1 = _ccMxm::P64;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccMJA: // global
           I64[Hp - 8] = sat_scLPa_info;
           P64[Hp] = _ccMxm::P64;
           R1 = Hp - 7;
           Sp = Sp + 168;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.682213688 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_$cshow_closure" {
     GHC.Stats.$fShowRTSStats_$cshow_closure:
         const GHC.Stats.$fShowRTSStats_$cshow_info;
         const 0;
 },
 GHC.Stats.$fShowRTSStats_$cshow_entry() //  [R2]
         { info_tbl: [(ccMVB,
                       label: GHC.Stats.$fShowRTSStats_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMVB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMVC; else goto ccMVD;
       ccMVC: // global
           R2 = R2;
           R1 = GHC.Stats.$fShowRTSStats_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccMVD: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Stats.$fShowRTSStats_$cshowsPrec_entry(R3,
                                                           R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.686208627 UTC

[section ""data" . GHC.Stats.$fShowRTSStats1_closure" {
     GHC.Stats.$fShowRTSStats1_closure:
         const GHC.Stats.$fShowRTSStats1_info;
         const 0;
 },
 GHC.Stats.$fShowRTSStats1_entry() //  [R2]
         { info_tbl: [(ccMVQ,
                       label: GHC.Stats.$fShowRTSStats1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMVQ: // global
           R3 = R2;
           R2 = GHC.Stats.$fShowGCDetails2_closure+1;
           call GHC.Stats.$fShowRTSStats_$cshowsPrec_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.689969771 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_$cshowList_closure" {
     GHC.Stats.$fShowRTSStats_$cshowList_closure:
         const GHC.Stats.$fShowRTSStats_$cshowList_info;
         const 0;
 },
 GHC.Stats.$fShowRTSStats_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(ccMW1,
                       label: GHC.Stats.$fShowRTSStats_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMW1: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fShowRTSStats1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.693188225 UTC

[section ""data" . GHC.Stats.$fShowRTSStats_closure" {
     GHC.Stats.$fShowRTSStats_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Stats.$fShowRTSStats_$cshowsPrec_closure+2;
         const GHC.Stats.$fShowRTSStats_$cshow_closure+1;
         const GHC.Stats.$fShowRTSStats_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.694962073 UTC

[section ""cstring" . GHC.Stats.$tcGCDetails2_bytes" {
     GHC.Stats.$tcGCDetails2_bytes:
         I8[] [71,67,68,101,116,97,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.696845756 UTC

[section ""data" . lexeme_rcHq6_closure" {
     lexeme_rcHq6_closure:
         const lexeme_rcHq6_info;
         const 0;
         const 0;
         const 0;
 },
 lexeme_rcHq6_entry() //  [R1]
         { info_tbl: [(ccMWg,
                       label: lexeme_rcHq6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMWg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMWh; else goto ccMWi;
       ccMWh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMWi: // global
           (_ccMWd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccMWd::I64 == 0) goto ccMWf; else goto ccMWe;
       ccMWf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccMWe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccMWd::I64;
           R2 = GHC.Stats.$tcGCDetails2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.701367483 UTC

[section ""data" . lexeme1_rcHq7_closure" {
     lexeme1_rcHq7_closure:
         const Text.Read.Lex.Ident_con_info;
         const lexeme_rcHq6_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.703142779 UTC

[section ""cstring" . lexeme2_rcHq8_bytes" {
     lexeme2_rcHq8_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.704968857 UTC

[section ""data" . lexeme3_rcHq9_closure" {
     lexeme3_rcHq9_closure:
         const lexeme3_rcHq9_info;
         const 0;
         const 0;
         const 0;
 },
 lexeme3_rcHq9_entry() //  [R1]
         { info_tbl: [(ccMWz,
                       label: lexeme3_rcHq9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMWz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMWA; else goto ccMWB;
       ccMWA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMWB: // global
           (_ccMWw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccMWw::I64 == 0) goto ccMWy; else goto ccMWx;
       ccMWy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccMWx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccMWw::I64;
           R2 = lexeme2_rcHq8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.708860153 UTC

[section ""data" . lexeme4_rcHqa_closure" {
     lexeme4_rcHqa_closure:
         const Text.Read.Lex.Punc_con_info;
         const lexeme3_rcHq9_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.710562133 UTC

[section ""cstring" . ds_rcHqb_bytes" {
     ds_rcHqb_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,103,101,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.71235988 UTC

[section ""data" . ds1_rcHqc_closure" {
     ds1_rcHqc_closure:
         const ds1_rcHqc_info;
         const 0;
         const 0;
         const 0;
 },
 ds1_rcHqc_entry() //  [R1]
         { info_tbl: [(ccMWS,
                       label: ds1_rcHqc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMWS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMWT; else goto ccMWU;
       ccMWT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMWU: // global
           (_ccMWP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccMWP::I64 == 0) goto ccMWR; else goto ccMWQ;
       ccMWR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccMWQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccMWP::I64;
           R2 = ds_rcHqb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.716842012 UTC

[section ""data" . lvl37_rcHqd_closure" {
     lvl37_rcHqd_closure:
         const lvl37_rcHqd_info;
         const 0;
 },
 lvl37_rcHqd_entry() //  [R2]
         { info_tbl: [(ccMX7,
                       label: lvl37_rcHqd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMX7: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           call GHC.Read.$fReadWord32_$creadsPrec_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.720568091 UTC

[section ""data" . ds2_rcHqe_closure" {
     ds2_rcHqe_closure:
         const ds2_rcHqe_info;
         const 0;
 },
 ds2_rcHqe_entry() //  [R2, R3]
         { info_tbl: [(ccMXl,
                       label: ds2_rcHqe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMXl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccMXm; else goto ccMXn;
       ccMXm: // global
           R3 = R3;
           R2 = R2;
           R1 = ds2_rcHqe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccMXn: // global
           I64[Sp - 8] = block_ccMXi_info;
           R3 = R3;
           R2 = lvl37_rcHqd_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccMXi() //  [R1]
         { info_tbl: [(ccMXi,
                       label: block_ccMXi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMXi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccMXq; else goto ccMXp;
       ccMXq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccMXp: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.726968089 UTC

[section ""data" . n_rcHqf_closure" {
     n_rcHqf_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.728588967 UTC

[section ""cstring" . lvl38_rcHqg_bytes" {
     lvl38_rcHqg_bytes:
         I8[] [44]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.73103456 UTC

[section ""data" . lvl39_rcHqh_closure" {
     lvl39_rcHqh_closure:
         const lvl39_rcHqh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl39_rcHqh_entry() //  [R1]
         { info_tbl: [(ccMXK,
                       label: lvl39_rcHqh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMXK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMXL; else goto ccMXM;
       ccMXL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMXM: // global
           (_ccMXH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccMXH::I64 == 0) goto ccMXJ; else goto ccMXI;
       ccMXJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccMXI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccMXH::I64;
           R2 = lvl38_rcHqg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.734905091 UTC

[section ""data" . lvl40_rcHqi_closure" {
     lvl40_rcHqi_closure:
         const Text.Read.Lex.Punc_con_info;
         const lvl39_rcHqh_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.736660176 UTC

[section ""cstring" . lvl41_rcHqj_bytes" {
     lvl41_rcHqj_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,116,104,114,101,97,100,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.738971609 UTC

[section ""data" . lvl42_rcHqk_closure" {
     lvl42_rcHqk_closure:
         const lvl42_rcHqk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl42_rcHqk_entry() //  [R1]
         { info_tbl: [(ccMY3,
                       label: lvl42_rcHqk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMY3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMY4; else goto ccMY5;
       ccMY4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMY5: // global
           (_ccMY0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccMY0::I64 == 0) goto ccMY2; else goto ccMY1;
       ccMY2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccMY1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccMY0::I64;
           R2 = lvl41_rcHqj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.743141907 UTC

[section ""cstring" . lvl43_rcHql_bytes" {
     lvl43_rcHql_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,97,108,108,111,99,97,116,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.74494766 UTC

[section ""data" . lvl44_rcHqm_closure" {
     lvl44_rcHqm_closure:
         const lvl44_rcHqm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl44_rcHqm_entry() //  [R1]
         { info_tbl: [(ccMYl,
                       label: lvl44_rcHqm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMYl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMYm; else goto ccMYn;
       ccMYm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMYn: // global
           (_ccMYi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccMYi::I64 == 0) goto ccMYk; else goto ccMYj;
       ccMYk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccMYj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccMYi::I64;
           R2 = lvl43_rcHql_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.748980113 UTC

[section ""data" . lvl45_rcHqn_closure" {
     lvl45_rcHqn_closure:
         const lvl45_rcHqn_info;
         const 0;
 },
 lvl45_rcHqn_entry() //  [R2]
         { info_tbl: [(ccMYA,
                       label: lvl45_rcHqn_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMYA: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           call GHC.Read.$fReadWord64_$creadsPrec_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.752549878 UTC

[section ""data" . lvl46_rcHqo_closure" {
     lvl46_rcHqo_closure:
         const lvl46_rcHqo_info;
         const 0;
 },
 lvl46_rcHqo_entry() //  [R2, R3]
         { info_tbl: [(ccMYO,
                       label: lvl46_rcHqo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMYO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccMYP; else goto ccMYQ;
       ccMYP: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl46_rcHqo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccMYQ: // global
           I64[Sp - 8] = block_ccMYL_info;
           R3 = R3;
           R2 = lvl45_rcHqn_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccMYL() //  [R1]
         { info_tbl: [(ccMYL,
                       label: block_ccMYL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMYL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccMYT; else goto ccMYS;
       ccMYT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccMYS: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.758023053 UTC

[section ""cstring" . lvl47_rcHqp_bytes" {
     lvl47_rcHqp_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,105,118,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.759838924 UTC

[section ""data" . lvl48_rcHqq_closure" {
     lvl48_rcHqq_closure:
         const lvl48_rcHqq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl48_rcHqq_entry() //  [R1]
         { info_tbl: [(ccMZc,
                       label: lvl48_rcHqq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMZc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMZd; else goto ccMZe;
       ccMZd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMZe: // global
           (_ccMZ9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccMZ9::I64 == 0) goto ccMZb; else goto ccMZa;
       ccMZb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccMZa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccMZ9::I64;
           R2 = lvl47_rcHqp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.764342566 UTC

[section ""cstring" . lvl49_rcHqr_bytes" {
     lvl49_rcHqr_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.766561335 UTC

[section ""data" . lvl50_rcHqs_closure" {
     lvl50_rcHqs_closure:
         const lvl50_rcHqs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl50_rcHqs_entry() //  [R1]
         { info_tbl: [(ccMZu,
                       label: lvl50_rcHqs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMZu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMZv; else goto ccMZw;
       ccMZv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMZw: // global
           (_ccMZr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccMZr::I64 == 0) goto ccMZt; else goto ccMZs;
       ccMZt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccMZs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccMZr::I64;
           R2 = lvl49_rcHqr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.770385706 UTC

[section ""cstring" . lvl51_rcHqt_bytes" {
     lvl51_rcHqt_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,109,112,97,99,116,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.772208994 UTC

[section ""data" . lvl52_rcHqu_closure" {
     lvl52_rcHqu_closure:
         const lvl52_rcHqu_info;
         const 0;
         const 0;
         const 0;
 },
 lvl52_rcHqu_entry() //  [R1]
         { info_tbl: [(ccMZM,
                       label: lvl52_rcHqu_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccMZM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccMZN; else goto ccMZO;
       ccMZN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccMZO: // global
           (_ccMZJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccMZJ::I64 == 0) goto ccMZL; else goto ccMZK;
       ccMZL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccMZK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccMZJ::I64;
           R2 = lvl51_rcHqt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.775999819 UTC

[section ""cstring" . lvl53_rcHqv_bytes" {
     lvl53_rcHqv_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,108,111,112,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.778674372 UTC

[section ""data" . lvl54_rcHqw_closure" {
     lvl54_rcHqw_closure:
         const lvl54_rcHqw_info;
         const 0;
         const 0;
         const 0;
 },
 lvl54_rcHqw_entry() //  [R1]
         { info_tbl: [(ccN04,
                       label: lvl54_rcHqw_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN04: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccN05; else goto ccN06;
       ccN05: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccN06: // global
           (_ccN01::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccN01::I64 == 0) goto ccN03; else goto ccN02;
       ccN03: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccN02: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccN01::I64;
           R2 = lvl53_rcHqv_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.782559206 UTC

[section ""cstring" . lvl55_rcHqx_bytes" {
     lvl55_rcHqx_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.784380767 UTC

[section ""data" . lvl56_rcHqy_closure" {
     lvl56_rcHqy_closure:
         const lvl56_rcHqy_info;
         const 0;
         const 0;
         const 0;
 },
 lvl56_rcHqy_entry() //  [R1]
         { info_tbl: [(ccN0m,
                       label: lvl56_rcHqy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN0m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccN0n; else goto ccN0o;
       ccN0n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccN0o: // global
           (_ccN0j::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccN0j::I64 == 0) goto ccN0l; else goto ccN0k;
       ccN0l: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccN0k: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccN0j::I64;
           R2 = lvl55_rcHqx_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.788197468 UTC

[section ""cstring" . lvl57_rcHqz_bytes" {
     lvl57_rcHqz_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.7901142 UTC

[section ""data" . lvl58_rcHqA_closure" {
     lvl58_rcHqA_closure:
         const lvl58_rcHqA_info;
         const 0;
         const 0;
         const 0;
 },
 lvl58_rcHqA_entry() //  [R1]
         { info_tbl: [(ccN0E,
                       label: lvl58_rcHqA_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN0E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccN0F; else goto ccN0G;
       ccN0F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccN0G: // global
           (_ccN0B::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccN0B::I64 == 0) goto ccN0D; else goto ccN0C;
       ccN0D: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccN0C: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccN0B::I64;
           R2 = lvl57_rcHqz_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.794323089 UTC

[section ""cstring" . lvl59_rcHqB_bytes" {
     lvl59_rcHqB_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.796676977 UTC

[section ""data" . lvl60_rcHqC_closure" {
     lvl60_rcHqC_closure:
         const lvl60_rcHqC_info;
         const 0;
         const 0;
         const 0;
 },
 lvl60_rcHqC_entry() //  [R1]
         { info_tbl: [(ccN0W,
                       label: lvl60_rcHqC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN0W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccN0X; else goto ccN0Y;
       ccN0X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccN0Y: // global
           (_ccN0T::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccN0T::I64 == 0) goto ccN0V; else goto ccN0U;
       ccN0V: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccN0U: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccN0T::I64;
           R2 = lvl59_rcHqB_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.800458643 UTC

[section ""cstring" . lvl61_rcHqD_bytes" {
     lvl61_rcHqD_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.8022994 UTC

[section ""data" . lvl62_rcHqE_closure" {
     lvl62_rcHqE_closure:
         const lvl62_rcHqE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl62_rcHqE_entry() //  [R1]
         { info_tbl: [(ccN1e,
                       label: lvl62_rcHqE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN1e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccN1f; else goto ccN1g;
       ccN1f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccN1g: // global
           (_ccN1b::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccN1b::I64 == 0) goto ccN1d; else goto ccN1c;
       ccN1d: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccN1c: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccN1b::I64;
           R2 = lvl61_rcHqD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.806012704 UTC

[section ""cstring" . lvl63_rcHqF_bytes" {
     lvl63_rcHqF_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,115,121,110,99,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.807733608 UTC

[section ""data" . lvl64_rcHqG_closure" {
     lvl64_rcHqG_closure:
         const lvl64_rcHqG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl64_rcHqG_entry() //  [R1]
         { info_tbl: [(ccN1w,
                       label: lvl64_rcHqG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN1w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccN1x; else goto ccN1y;
       ccN1x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccN1y: // global
           (_ccN1t::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccN1t::I64 == 0) goto ccN1v; else goto ccN1u;
       ccN1v: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccN1u: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccN1t::I64;
           R2 = lvl63_rcHqF_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.812065659 UTC

[section ""data" . lvl65_rcHqH_closure" {
     lvl65_rcHqH_closure:
         const lvl65_rcHqH_info;
         const 0;
 },
 lvl65_rcHqH_entry() //  [R2]
         { info_tbl: [(ccN1L,
                       label: lvl65_rcHqH_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN1L: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           call GHC.Int.$fReadInt64_$creadsPrec_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.815597533 UTC

[section ""data" . lvl66_rcHqI_closure" {
     lvl66_rcHqI_closure:
         const lvl66_rcHqI_info;
         const 0;
 },
 lvl66_rcHqI_entry() //  [R2, R3]
         { info_tbl: [(ccN1Z,
                       label: lvl66_rcHqI_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN1Z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccN20; else goto ccN21;
       ccN20: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl66_rcHqI_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccN21: // global
           I64[Sp - 8] = block_ccN1W_info;
           R3 = R3;
           R2 = lvl65_rcHqH_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN1W() //  [R1]
         { info_tbl: [(ccN1W,
                       label: block_ccN1W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN1W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN24; else goto ccN23;
       ccN24: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN23: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.821043862 UTC

[section ""cstring" . lvl67_rcHqJ_bytes" {
     lvl67_rcHqJ_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.824836357 UTC

[section ""data" . lvl68_rcHqK_closure" {
     lvl68_rcHqK_closure:
         const lvl68_rcHqK_info;
         const 0;
         const 0;
         const 0;
 },
 lvl68_rcHqK_entry() //  [R1]
         { info_tbl: [(ccN2n,
                       label: lvl68_rcHqK_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN2n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccN2o; else goto ccN2p;
       ccN2o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccN2p: // global
           (_ccN2k::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccN2k::I64 == 0) goto ccN2m; else goto ccN2l;
       ccN2m: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccN2l: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccN2k::I64;
           R2 = lvl67_rcHqJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.829863306 UTC

[section ""cstring" . lvl69_rcHqL_bytes" {
     lvl69_rcHqL_bytes:
         I8[] [103,99,100,101,116,97,105,108,115,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.831681809 UTC

[section ""data" . lvl70_rcHqM_closure" {
     lvl70_rcHqM_closure:
         const lvl70_rcHqM_info;
         const 0;
         const 0;
         const 0;
 },
 lvl70_rcHqM_entry() //  [R1]
         { info_tbl: [(ccN2F,
                       label: lvl70_rcHqM_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN2F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccN2G; else goto ccN2H;
       ccN2G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccN2H: // global
           (_ccN2C::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccN2C::I64 == 0) goto ccN2E; else goto ccN2D;
       ccN2E: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccN2D: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccN2C::I64;
           R2 = lvl69_rcHqL_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.836537197 UTC

[section ""data" . lvl71_rcHqN_closure" {
     lvl71_rcHqN_closure:
         const lvl71_rcHqN_info;
         const 0;
         const 0;
         const 0;
 },
 lvl71_rcHqN_entry() //  [R1]
         { info_tbl: [(ccN2W,
                       label: lvl71_rcHqN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN2W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccN2X; else goto ccN2Y;
       ccN2X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccN2Y: // global
           (_ccN2T::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccN2T::I64 == 0) goto ccN2V; else goto ccN2U;
       ccN2V: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccN2U: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccN2T::I64;
           R2 = lvl15_rcHpK_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.840549116 UTC

[section ""data" . lvl72_rcHqO_closure" {
     lvl72_rcHqO_closure:
         const Text.Read.Lex.Punc_con_info;
         const lvl71_rcHqN_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.850265931 UTC

[section ""data" . GHC.Stats.$w$creadPrec_closure" {
     GHC.Stats.$w$creadPrec_closure:
         const GHC.Stats.$w$creadPrec_info;
         const 0;
 },
 sat_scLPY_entry() //  [R1, R2]
         { info_tbl: [(ccN5H,
                       label: sat_scLPY_info
                       rep:HeapRep 15 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN5H: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccN5L; else goto ccN5K;
       ccN5L: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN5K: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           _scLPx::P64 = P64[R1 + 23];
           _scLPz::P64 = P64[R1 + 31];
           _scLPB::P64 = P64[R1 + 39];
           _scLPD::P64 = P64[R1 + 47];
           _scLPF::P64 = P64[R1 + 55];
           _scLPH::P64 = P64[R1 + 63];
           _scLPJ::P64 = P64[R1 + 71];
           _scLPL::P64 = P64[R1 + 79];
           _scLPN::P64 = P64[R1 + 87];
           _scLPP::P64 = P64[R1 + 95];
           _scLPR::P64 = P64[R1 + 103];
           _scLPT::P64 = P64[R1 + 111];
           _scLPV::P64 = P64[R1 + 119];
           I64[Hp - 112] = GHC.Stats.GCDetails_con_info;
           P64[Hp - 104] = _scLPv::P64;
           P64[Hp - 96] = _scLPx::P64;
           P64[Hp - 88] = _scLPz::P64;
           P64[Hp - 80] = _scLPB::P64;
           P64[Hp - 72] = _scLPD::P64;
           P64[Hp - 64] = _scLPF::P64;
           P64[Hp - 56] = _scLPH::P64;
           P64[Hp - 48] = _scLPJ::P64;
           P64[Hp - 40] = _scLPL::P64;
           P64[Hp - 32] = _scLPN::P64;
           P64[Hp - 24] = _scLPP::P64;
           P64[Hp - 16] = _scLPR::P64;
           P64[Hp - 8] = _scLPT::P64;
           P64[Hp] = _scLPV::P64;
           R2 = Hp - 111;
           R1 = _scLPr::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQ1_entry() //  [R1, R2]
         { info_tbl: [(ccN5P,
                       label: sat_scLQ1_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN5P: // global
           _scLPV::P64 = R2;
           _scLQ1::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN5Q; else goto ccN5R;
       ccN5R: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccN5T; else goto ccN5S;
       ccN5T: // global
           HpAlloc = 128;
           goto ccN5Q;
       ccN5Q: // global
           R2 = _scLPV::P64;
           R1 = _scLQ1::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN5S: // global
           _scLPr::P64 = P64[_scLQ1::P64 + 7];
           _scLPv::P64 = P64[_scLQ1::P64 + 15];
           _scLPx::P64 = P64[_scLQ1::P64 + 23];
           _scLPz::P64 = P64[_scLQ1::P64 + 31];
           _scLPB::P64 = P64[_scLQ1::P64 + 39];
           _scLPD::P64 = P64[_scLQ1::P64 + 47];
           _scLPF::P64 = P64[_scLQ1::P64 + 55];
           _scLPH::P64 = P64[_scLQ1::P64 + 63];
           _scLPJ::P64 = P64[_scLQ1::P64 + 71];
           _scLPL::P64 = P64[_scLQ1::P64 + 79];
           _scLPN::P64 = P64[_scLQ1::P64 + 87];
           _scLPP::P64 = P64[_scLQ1::P64 + 95];
           _scLPR::P64 = P64[_scLQ1::P64 + 103];
           _scLPT::P64 = P64[_scLQ1::P64 + 111];
           I64[Hp - 120] = sat_scLPY_info;
           P64[Hp - 112] = _scLPr::P64;
           P64[Hp - 104] = _scLPv::P64;
           P64[Hp - 96] = _scLPx::P64;
           P64[Hp - 88] = _scLPz::P64;
           P64[Hp - 80] = _scLPB::P64;
           P64[Hp - 72] = _scLPD::P64;
           P64[Hp - 64] = _scLPF::P64;
           P64[Hp - 56] = _scLPH::P64;
           P64[Hp - 48] = _scLPJ::P64;
           P64[Hp - 40] = _scLPL::P64;
           P64[Hp - 32] = _scLPN::P64;
           P64[Hp - 24] = _scLPP::P64;
           P64[Hp - 16] = _scLPR::P64;
           P64[Hp - 8] = _scLPT::P64;
           P64[Hp] = _scLPV::P64;
           I64[Sp - 8] = block_ccN5M_info;
           R3 = Hp - 119;
           R2 = lvl72_rcHqO_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN5M() //  [R1]
         { info_tbl: [(ccN5M,
                       label: block_ccN5M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN5M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN5W; else goto ccN5V;
       ccN5W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN5V: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQ2_entry() //  [R1, R2]
         { info_tbl: [(ccN5X,
                       label: sat_scLQ2_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN5X: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccN61; else goto ccN60;
       ccN61: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN60: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           _scLPx::P64 = P64[R1 + 23];
           _scLPz::P64 = P64[R1 + 31];
           _scLPB::P64 = P64[R1 + 39];
           _scLPD::P64 = P64[R1 + 47];
           _scLPF::P64 = P64[R1 + 55];
           _scLPH::P64 = P64[R1 + 63];
           _scLPJ::P64 = P64[R1 + 71];
           _scLPL::P64 = P64[R1 + 79];
           _scLPN::P64 = P64[R1 + 87];
           _scLPP::P64 = P64[R1 + 95];
           _scLPR::P64 = P64[R1 + 103];
           _scLPT::P64 = P64[R1 + 111];
           I64[Hp - 112] = sat_scLQ1_info;
           P64[Hp - 104] = _scLPr::P64;
           P64[Hp - 96] = _scLPv::P64;
           P64[Hp - 88] = _scLPx::P64;
           P64[Hp - 80] = _scLPz::P64;
           P64[Hp - 72] = _scLPB::P64;
           P64[Hp - 64] = _scLPD::P64;
           P64[Hp - 56] = _scLPF::P64;
           P64[Hp - 48] = _scLPH::P64;
           P64[Hp - 40] = _scLPJ::P64;
           P64[Hp - 32] = _scLPL::P64;
           P64[Hp - 24] = _scLPN::P64;
           P64[Hp - 16] = _scLPP::P64;
           P64[Hp - 8] = _scLPR::P64;
           P64[Hp] = _scLPT::P64;
           R5 = Hp - 111;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl70_rcHqM_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQ5_entry() //  [R1, R2]
         { info_tbl: [(ccN65,
                       label: sat_scLQ5_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN65: // global
           _scLPT::P64 = R2;
           _scLQ5::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN66; else goto ccN67;
       ccN67: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccN69; else goto ccN68;
       ccN69: // global
           HpAlloc = 120;
           goto ccN66;
       ccN66: // global
           R2 = _scLPT::P64;
           R1 = _scLQ5::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN68: // global
           _scLPr::P64 = P64[_scLQ5::P64 + 7];
           _scLPv::P64 = P64[_scLQ5::P64 + 15];
           _scLPx::P64 = P64[_scLQ5::P64 + 23];
           _scLPz::P64 = P64[_scLQ5::P64 + 31];
           _scLPB::P64 = P64[_scLQ5::P64 + 39];
           _scLPD::P64 = P64[_scLQ5::P64 + 47];
           _scLPF::P64 = P64[_scLQ5::P64 + 55];
           _scLPH::P64 = P64[_scLQ5::P64 + 63];
           _scLPJ::P64 = P64[_scLQ5::P64 + 71];
           _scLPL::P64 = P64[_scLQ5::P64 + 79];
           _scLPN::P64 = P64[_scLQ5::P64 + 87];
           _scLPP::P64 = P64[_scLQ5::P64 + 95];
           _scLPR::P64 = P64[_scLQ5::P64 + 103];
           I64[Hp - 112] = sat_scLQ2_info;
           P64[Hp - 104] = _scLPr::P64;
           P64[Hp - 96] = _scLPv::P64;
           P64[Hp - 88] = _scLPx::P64;
           P64[Hp - 80] = _scLPz::P64;
           P64[Hp - 72] = _scLPB::P64;
           P64[Hp - 64] = _scLPD::P64;
           P64[Hp - 56] = _scLPF::P64;
           P64[Hp - 48] = _scLPH::P64;
           P64[Hp - 40] = _scLPJ::P64;
           P64[Hp - 32] = _scLPL::P64;
           P64[Hp - 24] = _scLPN::P64;
           P64[Hp - 16] = _scLPP::P64;
           P64[Hp - 8] = _scLPR::P64;
           P64[Hp] = _scLPT::P64;
           I64[Sp - 8] = block_ccN62_info;
           R3 = Hp - 111;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN62() //  [R1]
         { info_tbl: [(ccN62,
                       label: block_ccN62_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN62: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN6c; else goto ccN6b;
       ccN6c: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN6b: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQ6_entry() //  [R1, R2]
         { info_tbl: [(ccN6d,
                       label: sat_scLQ6_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN6d: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccN6h; else goto ccN6g;
       ccN6h: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN6g: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           _scLPx::P64 = P64[R1 + 23];
           _scLPz::P64 = P64[R1 + 31];
           _scLPB::P64 = P64[R1 + 39];
           _scLPD::P64 = P64[R1 + 47];
           _scLPF::P64 = P64[R1 + 55];
           _scLPH::P64 = P64[R1 + 63];
           _scLPJ::P64 = P64[R1 + 71];
           _scLPL::P64 = P64[R1 + 79];
           _scLPN::P64 = P64[R1 + 87];
           _scLPP::P64 = P64[R1 + 95];
           _scLPR::P64 = P64[R1 + 103];
           I64[Hp - 104] = sat_scLQ5_info;
           P64[Hp - 96] = _scLPr::P64;
           P64[Hp - 88] = _scLPv::P64;
           P64[Hp - 80] = _scLPx::P64;
           P64[Hp - 72] = _scLPz::P64;
           P64[Hp - 64] = _scLPB::P64;
           P64[Hp - 56] = _scLPD::P64;
           P64[Hp - 48] = _scLPF::P64;
           P64[Hp - 40] = _scLPH::P64;
           P64[Hp - 32] = _scLPJ::P64;
           P64[Hp - 24] = _scLPL::P64;
           P64[Hp - 16] = _scLPN::P64;
           P64[Hp - 8] = _scLPP::P64;
           P64[Hp] = _scLPR::P64;
           R5 = Hp - 103;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl68_rcHqK_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQ9_entry() //  [R1, R2]
         { info_tbl: [(ccN6l,
                       label: sat_scLQ9_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN6l: // global
           _scLPR::P64 = R2;
           _scLQ9::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN6m; else goto ccN6n;
       ccN6n: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccN6p; else goto ccN6o;
       ccN6p: // global
           HpAlloc = 112;
           goto ccN6m;
       ccN6m: // global
           R2 = _scLPR::P64;
           R1 = _scLQ9::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN6o: // global
           _scLPr::P64 = P64[_scLQ9::P64 + 7];
           _scLPv::P64 = P64[_scLQ9::P64 + 15];
           _scLPx::P64 = P64[_scLQ9::P64 + 23];
           _scLPz::P64 = P64[_scLQ9::P64 + 31];
           _scLPB::P64 = P64[_scLQ9::P64 + 39];
           _scLPD::P64 = P64[_scLQ9::P64 + 47];
           _scLPF::P64 = P64[_scLQ9::P64 + 55];
           _scLPH::P64 = P64[_scLQ9::P64 + 63];
           _scLPJ::P64 = P64[_scLQ9::P64 + 71];
           _scLPL::P64 = P64[_scLQ9::P64 + 79];
           _scLPN::P64 = P64[_scLQ9::P64 + 87];
           _scLPP::P64 = P64[_scLQ9::P64 + 95];
           I64[Hp - 104] = sat_scLQ6_info;
           P64[Hp - 96] = _scLPr::P64;
           P64[Hp - 88] = _scLPv::P64;
           P64[Hp - 80] = _scLPx::P64;
           P64[Hp - 72] = _scLPz::P64;
           P64[Hp - 64] = _scLPB::P64;
           P64[Hp - 56] = _scLPD::P64;
           P64[Hp - 48] = _scLPF::P64;
           P64[Hp - 40] = _scLPH::P64;
           P64[Hp - 32] = _scLPJ::P64;
           P64[Hp - 24] = _scLPL::P64;
           P64[Hp - 16] = _scLPN::P64;
           P64[Hp - 8] = _scLPP::P64;
           P64[Hp] = _scLPR::P64;
           I64[Sp - 8] = block_ccN6i_info;
           R3 = Hp - 103;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN6i() //  [R1]
         { info_tbl: [(ccN6i,
                       label: block_ccN6i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN6i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN6s; else goto ccN6r;
       ccN6s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN6r: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQa_entry() //  [R1, R2]
         { info_tbl: [(ccN6t,
                       label: sat_scLQa_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN6t: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccN6x; else goto ccN6w;
       ccN6x: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN6w: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           _scLPx::P64 = P64[R1 + 23];
           _scLPz::P64 = P64[R1 + 31];
           _scLPB::P64 = P64[R1 + 39];
           _scLPD::P64 = P64[R1 + 47];
           _scLPF::P64 = P64[R1 + 55];
           _scLPH::P64 = P64[R1 + 63];
           _scLPJ::P64 = P64[R1 + 71];
           _scLPL::P64 = P64[R1 + 79];
           _scLPN::P64 = P64[R1 + 87];
           _scLPP::P64 = P64[R1 + 95];
           I64[Hp - 96] = sat_scLQ9_info;
           P64[Hp - 88] = _scLPr::P64;
           P64[Hp - 80] = _scLPv::P64;
           P64[Hp - 72] = _scLPx::P64;
           P64[Hp - 64] = _scLPz::P64;
           P64[Hp - 56] = _scLPB::P64;
           P64[Hp - 48] = _scLPD::P64;
           P64[Hp - 40] = _scLPF::P64;
           P64[Hp - 32] = _scLPH::P64;
           P64[Hp - 24] = _scLPJ::P64;
           P64[Hp - 16] = _scLPL::P64;
           P64[Hp - 8] = _scLPN::P64;
           P64[Hp] = _scLPP::P64;
           R5 = Hp - 95;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl64_rcHqG_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQd_entry() //  [R1, R2]
         { info_tbl: [(ccN6B,
                       label: sat_scLQd_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN6B: // global
           _scLPP::P64 = R2;
           _scLQd::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN6C; else goto ccN6D;
       ccN6D: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccN6F; else goto ccN6E;
       ccN6F: // global
           HpAlloc = 104;
           goto ccN6C;
       ccN6C: // global
           R2 = _scLPP::P64;
           R1 = _scLQd::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN6E: // global
           _scLPr::P64 = P64[_scLQd::P64 + 7];
           _scLPv::P64 = P64[_scLQd::P64 + 15];
           _scLPx::P64 = P64[_scLQd::P64 + 23];
           _scLPz::P64 = P64[_scLQd::P64 + 31];
           _scLPB::P64 = P64[_scLQd::P64 + 39];
           _scLPD::P64 = P64[_scLQd::P64 + 47];
           _scLPF::P64 = P64[_scLQd::P64 + 55];
           _scLPH::P64 = P64[_scLQd::P64 + 63];
           _scLPJ::P64 = P64[_scLQd::P64 + 71];
           _scLPL::P64 = P64[_scLQd::P64 + 79];
           _scLPN::P64 = P64[_scLQd::P64 + 87];
           I64[Hp - 96] = sat_scLQa_info;
           P64[Hp - 88] = _scLPr::P64;
           P64[Hp - 80] = _scLPv::P64;
           P64[Hp - 72] = _scLPx::P64;
           P64[Hp - 64] = _scLPz::P64;
           P64[Hp - 56] = _scLPB::P64;
           P64[Hp - 48] = _scLPD::P64;
           P64[Hp - 40] = _scLPF::P64;
           P64[Hp - 32] = _scLPH::P64;
           P64[Hp - 24] = _scLPJ::P64;
           P64[Hp - 16] = _scLPL::P64;
           P64[Hp - 8] = _scLPN::P64;
           P64[Hp] = _scLPP::P64;
           I64[Sp - 8] = block_ccN6y_info;
           R3 = Hp - 95;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN6y() //  [R1]
         { info_tbl: [(ccN6y,
                       label: block_ccN6y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN6y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN6I; else goto ccN6H;
       ccN6I: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN6H: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQe_entry() //  [R1, R2]
         { info_tbl: [(ccN6J,
                       label: sat_scLQe_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN6J: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccN6N; else goto ccN6M;
       ccN6N: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN6M: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           _scLPx::P64 = P64[R1 + 23];
           _scLPz::P64 = P64[R1 + 31];
           _scLPB::P64 = P64[R1 + 39];
           _scLPD::P64 = P64[R1 + 47];
           _scLPF::P64 = P64[R1 + 55];
           _scLPH::P64 = P64[R1 + 63];
           _scLPJ::P64 = P64[R1 + 71];
           _scLPL::P64 = P64[R1 + 79];
           _scLPN::P64 = P64[R1 + 87];
           I64[Hp - 88] = sat_scLQd_info;
           P64[Hp - 80] = _scLPr::P64;
           P64[Hp - 72] = _scLPv::P64;
           P64[Hp - 64] = _scLPx::P64;
           P64[Hp - 56] = _scLPz::P64;
           P64[Hp - 48] = _scLPB::P64;
           P64[Hp - 40] = _scLPD::P64;
           P64[Hp - 32] = _scLPF::P64;
           P64[Hp - 24] = _scLPH::P64;
           P64[Hp - 16] = _scLPJ::P64;
           P64[Hp - 8] = _scLPL::P64;
           P64[Hp] = _scLPN::P64;
           R5 = Hp - 87;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl62_rcHqE_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQh_entry() //  [R1, R2]
         { info_tbl: [(ccN6R,
                       label: sat_scLQh_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN6R: // global
           _scLPN::P64 = R2;
           _scLQh::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN6S; else goto ccN6T;
       ccN6T: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccN6V; else goto ccN6U;
       ccN6V: // global
           HpAlloc = 96;
           goto ccN6S;
       ccN6S: // global
           R2 = _scLPN::P64;
           R1 = _scLQh::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN6U: // global
           _scLPr::P64 = P64[_scLQh::P64 + 7];
           _scLPv::P64 = P64[_scLQh::P64 + 15];
           _scLPx::P64 = P64[_scLQh::P64 + 23];
           _scLPz::P64 = P64[_scLQh::P64 + 31];
           _scLPB::P64 = P64[_scLQh::P64 + 39];
           _scLPD::P64 = P64[_scLQh::P64 + 47];
           _scLPF::P64 = P64[_scLQh::P64 + 55];
           _scLPH::P64 = P64[_scLQh::P64 + 63];
           _scLPJ::P64 = P64[_scLQh::P64 + 71];
           _scLPL::P64 = P64[_scLQh::P64 + 79];
           I64[Hp - 88] = sat_scLQe_info;
           P64[Hp - 80] = _scLPr::P64;
           P64[Hp - 72] = _scLPv::P64;
           P64[Hp - 64] = _scLPx::P64;
           P64[Hp - 56] = _scLPz::P64;
           P64[Hp - 48] = _scLPB::P64;
           P64[Hp - 40] = _scLPD::P64;
           P64[Hp - 32] = _scLPF::P64;
           P64[Hp - 24] = _scLPH::P64;
           P64[Hp - 16] = _scLPJ::P64;
           P64[Hp - 8] = _scLPL::P64;
           P64[Hp] = _scLPN::P64;
           I64[Sp - 8] = block_ccN6O_info;
           R3 = Hp - 87;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN6O() //  [R1]
         { info_tbl: [(ccN6O,
                       label: block_ccN6O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN6O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN6Y; else goto ccN6X;
       ccN6Y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN6X: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQi_entry() //  [R1, R2]
         { info_tbl: [(ccN6Z,
                       label: sat_scLQi_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN6Z: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccN73; else goto ccN72;
       ccN73: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN72: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           _scLPx::P64 = P64[R1 + 23];
           _scLPz::P64 = P64[R1 + 31];
           _scLPB::P64 = P64[R1 + 39];
           _scLPD::P64 = P64[R1 + 47];
           _scLPF::P64 = P64[R1 + 55];
           _scLPH::P64 = P64[R1 + 63];
           _scLPJ::P64 = P64[R1 + 71];
           _scLPL::P64 = P64[R1 + 79];
           I64[Hp - 80] = sat_scLQh_info;
           P64[Hp - 72] = _scLPr::P64;
           P64[Hp - 64] = _scLPv::P64;
           P64[Hp - 56] = _scLPx::P64;
           P64[Hp - 48] = _scLPz::P64;
           P64[Hp - 40] = _scLPB::P64;
           P64[Hp - 32] = _scLPD::P64;
           P64[Hp - 24] = _scLPF::P64;
           P64[Hp - 16] = _scLPH::P64;
           P64[Hp - 8] = _scLPJ::P64;
           P64[Hp] = _scLPL::P64;
           R5 = Hp - 79;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl60_rcHqC_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQl_entry() //  [R1, R2]
         { info_tbl: [(ccN77,
                       label: sat_scLQl_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN77: // global
           _scLPL::P64 = R2;
           _scLQl::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN78; else goto ccN79;
       ccN79: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccN7b; else goto ccN7a;
       ccN7b: // global
           HpAlloc = 88;
           goto ccN78;
       ccN78: // global
           R2 = _scLPL::P64;
           R1 = _scLQl::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN7a: // global
           _scLPr::P64 = P64[_scLQl::P64 + 7];
           _scLPv::P64 = P64[_scLQl::P64 + 15];
           _scLPx::P64 = P64[_scLQl::P64 + 23];
           _scLPz::P64 = P64[_scLQl::P64 + 31];
           _scLPB::P64 = P64[_scLQl::P64 + 39];
           _scLPD::P64 = P64[_scLQl::P64 + 47];
           _scLPF::P64 = P64[_scLQl::P64 + 55];
           _scLPH::P64 = P64[_scLQl::P64 + 63];
           _scLPJ::P64 = P64[_scLQl::P64 + 71];
           I64[Hp - 80] = sat_scLQi_info;
           P64[Hp - 72] = _scLPr::P64;
           P64[Hp - 64] = _scLPv::P64;
           P64[Hp - 56] = _scLPx::P64;
           P64[Hp - 48] = _scLPz::P64;
           P64[Hp - 40] = _scLPB::P64;
           P64[Hp - 32] = _scLPD::P64;
           P64[Hp - 24] = _scLPF::P64;
           P64[Hp - 16] = _scLPH::P64;
           P64[Hp - 8] = _scLPJ::P64;
           P64[Hp] = _scLPL::P64;
           I64[Sp - 8] = block_ccN74_info;
           R3 = Hp - 79;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN74() //  [R1]
         { info_tbl: [(ccN74,
                       label: block_ccN74_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN74: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN7e; else goto ccN7d;
       ccN7e: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN7d: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQm_entry() //  [R1, R2]
         { info_tbl: [(ccN7f,
                       label: sat_scLQm_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN7f: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccN7j; else goto ccN7i;
       ccN7j: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN7i: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           _scLPx::P64 = P64[R1 + 23];
           _scLPz::P64 = P64[R1 + 31];
           _scLPB::P64 = P64[R1 + 39];
           _scLPD::P64 = P64[R1 + 47];
           _scLPF::P64 = P64[R1 + 55];
           _scLPH::P64 = P64[R1 + 63];
           _scLPJ::P64 = P64[R1 + 71];
           I64[Hp - 72] = sat_scLQl_info;
           P64[Hp - 64] = _scLPr::P64;
           P64[Hp - 56] = _scLPv::P64;
           P64[Hp - 48] = _scLPx::P64;
           P64[Hp - 40] = _scLPz::P64;
           P64[Hp - 32] = _scLPB::P64;
           P64[Hp - 24] = _scLPD::P64;
           P64[Hp - 16] = _scLPF::P64;
           P64[Hp - 8] = _scLPH::P64;
           P64[Hp] = _scLPJ::P64;
           R5 = Hp - 71;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl58_rcHqA_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQp_entry() //  [R1, R2]
         { info_tbl: [(ccN7n,
                       label: sat_scLQp_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN7n: // global
           _scLPJ::P64 = R2;
           _scLQp::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN7o; else goto ccN7p;
       ccN7p: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccN7r; else goto ccN7q;
       ccN7r: // global
           HpAlloc = 80;
           goto ccN7o;
       ccN7o: // global
           R2 = _scLPJ::P64;
           R1 = _scLQp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN7q: // global
           _scLPr::P64 = P64[_scLQp::P64 + 7];
           _scLPv::P64 = P64[_scLQp::P64 + 15];
           _scLPx::P64 = P64[_scLQp::P64 + 23];
           _scLPz::P64 = P64[_scLQp::P64 + 31];
           _scLPB::P64 = P64[_scLQp::P64 + 39];
           _scLPD::P64 = P64[_scLQp::P64 + 47];
           _scLPF::P64 = P64[_scLQp::P64 + 55];
           _scLPH::P64 = P64[_scLQp::P64 + 63];
           I64[Hp - 72] = sat_scLQm_info;
           P64[Hp - 64] = _scLPr::P64;
           P64[Hp - 56] = _scLPv::P64;
           P64[Hp - 48] = _scLPx::P64;
           P64[Hp - 40] = _scLPz::P64;
           P64[Hp - 32] = _scLPB::P64;
           P64[Hp - 24] = _scLPD::P64;
           P64[Hp - 16] = _scLPF::P64;
           P64[Hp - 8] = _scLPH::P64;
           P64[Hp] = _scLPJ::P64;
           I64[Sp - 8] = block_ccN7k_info;
           R3 = Hp - 71;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN7k() //  [R1]
         { info_tbl: [(ccN7k,
                       label: block_ccN7k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN7k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN7u; else goto ccN7t;
       ccN7u: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN7t: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQq_entry() //  [R1, R2]
         { info_tbl: [(ccN7v,
                       label: sat_scLQq_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN7v: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccN7z; else goto ccN7y;
       ccN7z: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN7y: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           _scLPx::P64 = P64[R1 + 23];
           _scLPz::P64 = P64[R1 + 31];
           _scLPB::P64 = P64[R1 + 39];
           _scLPD::P64 = P64[R1 + 47];
           _scLPF::P64 = P64[R1 + 55];
           _scLPH::P64 = P64[R1 + 63];
           I64[Hp - 64] = sat_scLQp_info;
           P64[Hp - 56] = _scLPr::P64;
           P64[Hp - 48] = _scLPv::P64;
           P64[Hp - 40] = _scLPx::P64;
           P64[Hp - 32] = _scLPz::P64;
           P64[Hp - 24] = _scLPB::P64;
           P64[Hp - 16] = _scLPD::P64;
           P64[Hp - 8] = _scLPF::P64;
           P64[Hp] = _scLPH::P64;
           R5 = Hp - 63;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl56_rcHqy_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQt_entry() //  [R1, R2]
         { info_tbl: [(ccN7D,
                       label: sat_scLQt_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN7D: // global
           _scLPH::P64 = R2;
           _scLQt::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN7E; else goto ccN7F;
       ccN7F: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccN7H; else goto ccN7G;
       ccN7H: // global
           HpAlloc = 72;
           goto ccN7E;
       ccN7E: // global
           R2 = _scLPH::P64;
           R1 = _scLQt::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN7G: // global
           _scLPr::P64 = P64[_scLQt::P64 + 7];
           _scLPv::P64 = P64[_scLQt::P64 + 15];
           _scLPx::P64 = P64[_scLQt::P64 + 23];
           _scLPz::P64 = P64[_scLQt::P64 + 31];
           _scLPB::P64 = P64[_scLQt::P64 + 39];
           _scLPD::P64 = P64[_scLQt::P64 + 47];
           _scLPF::P64 = P64[_scLQt::P64 + 55];
           I64[Hp - 64] = sat_scLQq_info;
           P64[Hp - 56] = _scLPr::P64;
           P64[Hp - 48] = _scLPv::P64;
           P64[Hp - 40] = _scLPx::P64;
           P64[Hp - 32] = _scLPz::P64;
           P64[Hp - 24] = _scLPB::P64;
           P64[Hp - 16] = _scLPD::P64;
           P64[Hp - 8] = _scLPF::P64;
           P64[Hp] = _scLPH::P64;
           I64[Sp - 8] = block_ccN7A_info;
           R3 = Hp - 63;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN7A() //  [R1]
         { info_tbl: [(ccN7A,
                       label: block_ccN7A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN7A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN7K; else goto ccN7J;
       ccN7K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN7J: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQu_entry() //  [R1, R2]
         { info_tbl: [(ccN7L,
                       label: sat_scLQu_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN7L: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccN7P; else goto ccN7O;
       ccN7P: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN7O: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           _scLPx::P64 = P64[R1 + 23];
           _scLPz::P64 = P64[R1 + 31];
           _scLPB::P64 = P64[R1 + 39];
           _scLPD::P64 = P64[R1 + 47];
           _scLPF::P64 = P64[R1 + 55];
           I64[Hp - 56] = sat_scLQt_info;
           P64[Hp - 48] = _scLPr::P64;
           P64[Hp - 40] = _scLPv::P64;
           P64[Hp - 32] = _scLPx::P64;
           P64[Hp - 24] = _scLPz::P64;
           P64[Hp - 16] = _scLPB::P64;
           P64[Hp - 8] = _scLPD::P64;
           P64[Hp] = _scLPF::P64;
           R5 = Hp - 55;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl54_rcHqw_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQx_entry() //  [R1, R2]
         { info_tbl: [(ccN7T,
                       label: sat_scLQx_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN7T: // global
           _scLPF::P64 = R2;
           _scLQx::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN7U; else goto ccN7V;
       ccN7V: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccN7X; else goto ccN7W;
       ccN7X: // global
           HpAlloc = 64;
           goto ccN7U;
       ccN7U: // global
           R2 = _scLPF::P64;
           R1 = _scLQx::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN7W: // global
           _scLPr::P64 = P64[_scLQx::P64 + 7];
           _scLPv::P64 = P64[_scLQx::P64 + 15];
           _scLPx::P64 = P64[_scLQx::P64 + 23];
           _scLPz::P64 = P64[_scLQx::P64 + 31];
           _scLPB::P64 = P64[_scLQx::P64 + 39];
           _scLPD::P64 = P64[_scLQx::P64 + 47];
           I64[Hp - 56] = sat_scLQu_info;
           P64[Hp - 48] = _scLPr::P64;
           P64[Hp - 40] = _scLPv::P64;
           P64[Hp - 32] = _scLPx::P64;
           P64[Hp - 24] = _scLPz::P64;
           P64[Hp - 16] = _scLPB::P64;
           P64[Hp - 8] = _scLPD::P64;
           P64[Hp] = _scLPF::P64;
           I64[Sp - 8] = block_ccN7Q_info;
           R3 = Hp - 55;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN7Q() //  [R1]
         { info_tbl: [(ccN7Q,
                       label: block_ccN7Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN7Q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN80; else goto ccN7Z;
       ccN80: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN7Z: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQy_entry() //  [R1, R2]
         { info_tbl: [(ccN81,
                       label: sat_scLQy_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN81: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccN85; else goto ccN84;
       ccN85: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN84: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           _scLPx::P64 = P64[R1 + 23];
           _scLPz::P64 = P64[R1 + 31];
           _scLPB::P64 = P64[R1 + 39];
           _scLPD::P64 = P64[R1 + 47];
           I64[Hp - 48] = sat_scLQx_info;
           P64[Hp - 40] = _scLPr::P64;
           P64[Hp - 32] = _scLPv::P64;
           P64[Hp - 24] = _scLPx::P64;
           P64[Hp - 16] = _scLPz::P64;
           P64[Hp - 8] = _scLPB::P64;
           P64[Hp] = _scLPD::P64;
           R5 = Hp - 47;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl52_rcHqu_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQB_entry() //  [R1, R2]
         { info_tbl: [(ccN89,
                       label: sat_scLQB_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN89: // global
           _scLPD::P64 = R2;
           _scLQB::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN8a; else goto ccN8b;
       ccN8b: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccN8d; else goto ccN8c;
       ccN8d: // global
           HpAlloc = 56;
           goto ccN8a;
       ccN8a: // global
           R2 = _scLPD::P64;
           R1 = _scLQB::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN8c: // global
           _scLPr::P64 = P64[_scLQB::P64 + 7];
           _scLPv::P64 = P64[_scLQB::P64 + 15];
           _scLPx::P64 = P64[_scLQB::P64 + 23];
           _scLPz::P64 = P64[_scLQB::P64 + 31];
           _scLPB::P64 = P64[_scLQB::P64 + 39];
           I64[Hp - 48] = sat_scLQy_info;
           P64[Hp - 40] = _scLPr::P64;
           P64[Hp - 32] = _scLPv::P64;
           P64[Hp - 24] = _scLPx::P64;
           P64[Hp - 16] = _scLPz::P64;
           P64[Hp - 8] = _scLPB::P64;
           P64[Hp] = _scLPD::P64;
           I64[Sp - 8] = block_ccN86_info;
           R3 = Hp - 47;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN86() //  [R1]
         { info_tbl: [(ccN86,
                       label: block_ccN86_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN86: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN8g; else goto ccN8f;
       ccN8g: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN8f: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQC_entry() //  [R1, R2]
         { info_tbl: [(ccN8h,
                       label: sat_scLQC_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN8h: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccN8l; else goto ccN8k;
       ccN8l: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN8k: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           _scLPx::P64 = P64[R1 + 23];
           _scLPz::P64 = P64[R1 + 31];
           _scLPB::P64 = P64[R1 + 39];
           I64[Hp - 40] = sat_scLQB_info;
           P64[Hp - 32] = _scLPr::P64;
           P64[Hp - 24] = _scLPv::P64;
           P64[Hp - 16] = _scLPx::P64;
           P64[Hp - 8] = _scLPz::P64;
           P64[Hp] = _scLPB::P64;
           R5 = Hp - 39;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl50_rcHqs_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQF_entry() //  [R1, R2]
         { info_tbl: [(ccN8p,
                       label: sat_scLQF_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN8p: // global
           _scLPB::P64 = R2;
           _scLQF::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN8q; else goto ccN8r;
       ccN8r: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccN8t; else goto ccN8s;
       ccN8t: // global
           HpAlloc = 48;
           goto ccN8q;
       ccN8q: // global
           R2 = _scLPB::P64;
           R1 = _scLQF::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN8s: // global
           _scLPr::P64 = P64[_scLQF::P64 + 7];
           _scLPv::P64 = P64[_scLQF::P64 + 15];
           _scLPx::P64 = P64[_scLQF::P64 + 23];
           _scLPz::P64 = P64[_scLQF::P64 + 31];
           I64[Hp - 40] = sat_scLQC_info;
           P64[Hp - 32] = _scLPr::P64;
           P64[Hp - 24] = _scLPv::P64;
           P64[Hp - 16] = _scLPx::P64;
           P64[Hp - 8] = _scLPz::P64;
           P64[Hp] = _scLPB::P64;
           I64[Sp - 8] = block_ccN8m_info;
           R3 = Hp - 39;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN8m() //  [R1]
         { info_tbl: [(ccN8m,
                       label: block_ccN8m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN8m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN8w; else goto ccN8v;
       ccN8w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN8v: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQG_entry() //  [R1, R2]
         { info_tbl: [(ccN8x,
                       label: sat_scLQG_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN8x: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccN8B; else goto ccN8A;
       ccN8B: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN8A: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           _scLPx::P64 = P64[R1 + 23];
           _scLPz::P64 = P64[R1 + 31];
           I64[Hp - 32] = sat_scLQF_info;
           P64[Hp - 24] = _scLPr::P64;
           P64[Hp - 16] = _scLPv::P64;
           P64[Hp - 8] = _scLPx::P64;
           P64[Hp] = _scLPz::P64;
           R5 = Hp - 31;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl48_rcHqq_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQJ_entry() //  [R1, R2]
         { info_tbl: [(ccN8F,
                       label: sat_scLQJ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN8F: // global
           _scLPz::P64 = R2;
           _scLQJ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN8G; else goto ccN8H;
       ccN8H: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccN8J; else goto ccN8I;
       ccN8J: // global
           HpAlloc = 40;
           goto ccN8G;
       ccN8G: // global
           R2 = _scLPz::P64;
           R1 = _scLQJ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN8I: // global
           _scLPr::P64 = P64[_scLQJ::P64 + 7];
           _scLPv::P64 = P64[_scLQJ::P64 + 15];
           _scLPx::P64 = P64[_scLQJ::P64 + 23];
           I64[Hp - 32] = sat_scLQG_info;
           P64[Hp - 24] = _scLPr::P64;
           P64[Hp - 16] = _scLPv::P64;
           P64[Hp - 8] = _scLPx::P64;
           P64[Hp] = _scLPz::P64;
           I64[Sp - 8] = block_ccN8C_info;
           R3 = Hp - 31;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN8C() //  [R1]
         { info_tbl: [(ccN8C,
                       label: block_ccN8C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN8C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN8M; else goto ccN8L;
       ccN8M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN8L: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQK_entry() //  [R1, R2]
         { info_tbl: [(ccN8N,
                       label: sat_scLQK_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN8N: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccN8R; else goto ccN8Q;
       ccN8R: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN8Q: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           _scLPx::P64 = P64[R1 + 23];
           I64[Hp - 24] = sat_scLQJ_info;
           P64[Hp - 16] = _scLPr::P64;
           P64[Hp - 8] = _scLPv::P64;
           P64[Hp] = _scLPx::P64;
           R5 = Hp - 23;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl44_rcHqm_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQN_entry() //  [R1, R2]
         { info_tbl: [(ccN8V,
                       label: sat_scLQN_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN8V: // global
           _scLPx::P64 = R2;
           _scLQN::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN8W; else goto ccN8X;
       ccN8X: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccN8Z; else goto ccN8Y;
       ccN8Z: // global
           HpAlloc = 32;
           goto ccN8W;
       ccN8W: // global
           R2 = _scLPx::P64;
           R1 = _scLQN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN8Y: // global
           _scLPr::P64 = P64[_scLQN::P64 + 7];
           _scLPv::P64 = P64[_scLQN::P64 + 15];
           I64[Hp - 24] = sat_scLQK_info;
           P64[Hp - 16] = _scLPr::P64;
           P64[Hp - 8] = _scLPv::P64;
           P64[Hp] = _scLPx::P64;
           I64[Sp - 8] = block_ccN8S_info;
           R3 = Hp - 23;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN8S() //  [R1]
         { info_tbl: [(ccN8S,
                       label: block_ccN8S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN8S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN92; else goto ccN91;
       ccN92: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN91: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQO_entry() //  [R1, R2]
         { info_tbl: [(ccN93,
                       label: sat_scLQO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN93: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccN97; else goto ccN96;
       ccN97: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN96: // global
           _scLPr::P64 = P64[R1 + 7];
           _scLPv::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_scLQN_info;
           P64[Hp - 8] = _scLPr::P64;
           P64[Hp] = _scLPv::P64;
           R5 = Hp - 15;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = lvl42_rcHqk_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQR_entry() //  [R1, R2]
         { info_tbl: [(ccN9b,
                       label: sat_scLQR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN9b: // global
           _scLPv::P64 = R2;
           _scLQR::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN9c; else goto ccN9d;
       ccN9d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccN9f; else goto ccN9e;
       ccN9f: // global
           HpAlloc = 24;
           goto ccN9c;
       ccN9c: // global
           R2 = _scLPv::P64;
           R1 = _scLQR::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN9e: // global
           _scLPr::P64 = P64[_scLQR::P64 + 7];
           I64[Hp - 16] = sat_scLQO_info;
           P64[Hp - 8] = _scLPr::P64;
           P64[Hp] = _scLPv::P64;
           I64[Sp - 8] = block_ccN98_info;
           R3 = Hp - 15;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN98() //  [R1]
         { info_tbl: [(ccN98,
                       label: block_ccN98_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN98: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN9i; else goto ccN9h;
       ccN9i: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN9h: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQS_entry() //  [R1, R2]
         { info_tbl: [(ccN9j,
                       label: sat_scLQS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN9j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN9n; else goto ccN9m;
       ccN9n: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN9m: // global
           _scLPr::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_scLQR_info;
           P64[Hp] = _scLPr::P64;
           R5 = Hp - 7;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = ds1_rcHqc_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLQV_entry() //  [R1, R2]
         { info_tbl: [(ccN9r,
                       label: sat_scLQV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN9r: // global
           _scLPt::P64 = R2;
           _scLQV::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN9s; else goto ccN9t;
       ccN9t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN9v; else goto ccN9u;
       ccN9v: // global
           HpAlloc = 16;
           goto ccN9s;
       ccN9s: // global
           R2 = _scLPt::P64;
           R1 = _scLQV::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccN9u: // global
           _scLPr::P64 = P64[_scLQV::P64 + 7];
           I64[Hp - 8] = sat_scLQS_info;
           P64[Hp] = _scLPr::P64;
           I64[Sp - 8] = block_ccN9o_info;
           R3 = Hp - 7;
           R2 = lexeme4_rcHqa_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN9o() //  [R1]
         { info_tbl: [(ccN9o,
                       label: block_ccN9o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN9o: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN9y; else goto ccN9x;
       ccN9y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN9x: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Stats.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(ccN9C,
                       label: GHC.Stats.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN9C: // global
           _scLPr::P64 = R3;
           _scLPq::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccN9D; else goto ccN9E;
       ccN9E: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN9G; else goto ccN9F;
       ccN9G: // global
           HpAlloc = 16;
           goto ccN9D;
       ccN9D: // global
           R3 = _scLPr::P64;
           R2 = _scLPq::I64;
           R1 = GHC.Stats.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccN9F: // global
           if (%MO_S_Gt_W64(_scLPq::I64, 11)) goto ccN9A; else goto ccN9B;
       ccN9A: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccN9B: // global
           I64[Hp - 8] = sat_scLQV_info;
           P64[Hp] = _scLPr::P64;
           I64[Sp - 8] = block_ccN9H_info;
           R3 = Hp - 7;
           R2 = lexeme1_rcHq7_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccN9H() //  [R1]
         { info_tbl: [(ccN9H,
                       label: block_ccN9H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccN9H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccN9M; else goto ccN9L;
       ccN9M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccN9L: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.966359754 UTC

[section ""data" . GHC.Stats.$fReadGCDetails2_closure" {
     GHC.Stats.$fReadGCDetails2_closure:
         const GHC.Stats.$fReadGCDetails2_info;
         const 0;
 },
 GHC.Stats.$fReadGCDetails2_entry() //  [R2, R3]
         { info_tbl: [(ccNdL,
                       label: GHC.Stats.$fReadGCDetails2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNdL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNdM; else goto ccNdN;
       ccNdM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fReadGCDetails2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccNdN: // global
           I64[Sp - 16] = block_ccNdI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucNdR; else goto ccNdJ;
       ucNdR: // global
           call _ccNdI(R1) args: 0, res: 0, upd: 0;
       ccNdJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNdI() //  [R1]
         { info_tbl: [(ccNdI,
                       label: block_ccNdI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNdI: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Stats.$w$creadPrec_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.971829239 UTC

[section ""data" . GHC.Stats.$fReadGCDetails1_closure" {
     GHC.Stats.$fReadGCDetails1_closure:
         const GHC.Stats.$fReadGCDetails1_info;
         const 0;
 },
 GHC.Stats.$fReadGCDetails1_entry() //  [R2, R3]
         { info_tbl: [(ccNe6,
                       label: GHC.Stats.$fReadGCDetails1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNe6: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fReadGCDetails2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.975456959 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_$creadsPrec_closure" {
     GHC.Stats.$fReadGCDetails_$creadsPrec_closure:
         const GHC.Stats.$fReadGCDetails_$creadsPrec_info;
         const 0;
 },
 sat_scLR3_entry() //  [R1]
         { info_tbl: [(ccNel,
                       label: sat_scLR3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNel: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNem; else goto ccNen;
       ccNem: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNen: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Stats.$fReadGCDetails2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stats.$fReadGCDetails_$creadsPrec_entry() //  [R2]
         { info_tbl: [(ccNeo,
                       label: GHC.Stats.$fReadGCDetails_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNeo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccNes; else goto ccNer;
       ccNes: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stats.$fReadGCDetails_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNer: // global
           I64[Hp - 16] = sat_scLR3_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.982406224 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_$creadListPrec_closure" {
     GHC.Stats.$fReadGCDetails_$creadListPrec_closure:
         const GHC.Stats.$fReadGCDetails_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadGCDetails_$creadListPrec_entry() //  [R1]
         { info_tbl: [(ccNeL,
                       label: GHC.Stats.$fReadGCDetails_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNeL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNeM; else goto ccNeN;
       ccNeM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNeN: // global
           (_ccNeI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNeI::I64 == 0) goto ccNeK; else goto ccNeJ;
       ccNeK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNeJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNeI::I64;
           R2 = GHC.Stats.$fReadGCDetails1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.986407395 UTC

[section ""data" . GHC.Stats.$fReadGCDetails3_closure" {
     GHC.Stats.$fReadGCDetails3_closure:
         const GHC.Stats.$fReadGCDetails3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadGCDetails3_entry() //  [R1]
         { info_tbl: [(ccNf2,
                       label: GHC.Stats.$fReadGCDetails3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNf2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNf3; else goto ccNf4;
       ccNf3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNf4: // global
           (_ccNeZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNeZ::I64 == 0) goto ccNf1; else goto ccNf0;
       ccNf1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNf0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNeZ::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.Stats.$fReadGCDetails_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.990613082 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_$creadList_closure" {
     GHC.Stats.$fReadGCDetails_$creadList_closure:
         const GHC.Stats.$fReadGCDetails_$creadList_info;
         const 0;
 },
 GHC.Stats.$fReadGCDetails_$creadList_entry() //  [R2]
         { info_tbl: [(ccNfi,
                       label: GHC.Stats.$fReadGCDetails_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNfi: // global
           R3 = R2;
           R2 = GHC.Stats.$fReadGCDetails3_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.99374488 UTC

[section ""data" . GHC.Stats.$fReadGCDetails_closure" {
     GHC.Stats.$fReadGCDetails_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Stats.$fReadGCDetails_$creadsPrec_closure+1;
         const GHC.Stats.$fReadGCDetails_$creadList_closure+1;
         const GHC.Stats.$fReadGCDetails1_closure+2;
         const GHC.Stats.$fReadGCDetails_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.995452981 UTC

[section ""cstring" . GHC.Stats.$tcRTSStats2_bytes" {
     GHC.Stats.$tcRTSStats2_bytes:
         I8[] [82,84,83,83,116,97,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:47.997146481 UTC

[section ""data" . lexeme5_rcHqP_closure" {
     lexeme5_rcHqP_closure:
         const lexeme5_rcHqP_info;
         const 0;
         const 0;
         const 0;
 },
 lexeme5_rcHqP_entry() //  [R1]
         { info_tbl: [(ccNfx,
                       label: lexeme5_rcHqP_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNfx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNfy; else goto ccNfz;
       ccNfy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNfz: // global
           (_ccNfu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNfu::I64 == 0) goto ccNfw; else goto ccNfv;
       ccNfw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNfv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNfu::I64;
           R2 = GHC.Stats.$tcRTSStats2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.000765353 UTC

[section ""data" . lexeme6_rcHqQ_closure" {
     lexeme6_rcHqQ_closure:
         const Text.Read.Lex.Ident_con_info;
         const lexeme5_rcHqP_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.002701674 UTC

[section ""cstring" . ds3_rcHqR_bytes" {
     ds3_rcHqR_bytes:
         I8[] [103,99,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.004334023 UTC

[section ""data" . ds4_rcHqS_closure" {
     ds4_rcHqS_closure:
         const ds4_rcHqS_info;
         const 0;
         const 0;
         const 0;
 },
 ds4_rcHqS_entry() //  [R1]
         { info_tbl: [(ccNfQ,
                       label: ds4_rcHqS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNfQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNfR; else goto ccNfS;
       ccNfR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNfS: // global
           (_ccNfN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNfN::I64 == 0) goto ccNfP; else goto ccNfO;
       ccNfP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNfO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNfN::I64;
           R2 = ds3_rcHqR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.008199149 UTC

[section ""cstring" . lvl73_rcHqT_bytes" {
     lvl73_rcHqT_bytes:
         I8[] [109,97,106,111,114,95,103,99,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.010536279 UTC

[section ""data" . lvl74_rcHqU_closure" {
     lvl74_rcHqU_closure:
         const lvl74_rcHqU_info;
         const 0;
         const 0;
         const 0;
 },
 lvl74_rcHqU_entry() //  [R1]
         { info_tbl: [(ccNg8,
                       label: lvl74_rcHqU_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNg8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNg9; else goto ccNga;
       ccNg9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNga: // global
           (_ccNg5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNg5::I64 == 0) goto ccNg7; else goto ccNg6;
       ccNg7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNg6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNg5::I64;
           R2 = lvl73_rcHqT_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.014250144 UTC

[section ""cstring" . lvl75_rcHqV_bytes" {
     lvl75_rcHqV_bytes:
         I8[] [97,108,108,111,99,97,116,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.016000224 UTC

[section ""data" . lvl76_rcHqW_closure" {
     lvl76_rcHqW_closure:
         const lvl76_rcHqW_info;
         const 0;
         const 0;
         const 0;
 },
 lvl76_rcHqW_entry() //  [R1]
         { info_tbl: [(ccNgq,
                       label: lvl76_rcHqW_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNgq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNgr; else goto ccNgs;
       ccNgr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNgs: // global
           (_ccNgn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNgn::I64 == 0) goto ccNgp; else goto ccNgo;
       ccNgp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNgo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNgn::I64;
           R2 = lvl75_rcHqV_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.019951266 UTC

[section ""cstring" . lvl77_rcHqX_bytes" {
     lvl77_rcHqX_bytes:
         I8[] [109,97,120,95,108,105,118,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.021781932 UTC

[section ""data" . lvl78_rcHqY_closure" {
     lvl78_rcHqY_closure:
         const lvl78_rcHqY_info;
         const 0;
         const 0;
         const 0;
 },
 lvl78_rcHqY_entry() //  [R1]
         { info_tbl: [(ccNgI,
                       label: lvl78_rcHqY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNgI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNgJ; else goto ccNgK;
       ccNgJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNgK: // global
           (_ccNgF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNgF::I64 == 0) goto ccNgH; else goto ccNgG;
       ccNgH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNgG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNgF::I64;
           R2 = lvl77_rcHqX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.025445841 UTC

[section ""cstring" . lvl79_rcHqZ_bytes" {
     lvl79_rcHqZ_bytes:
         I8[] [109,97,120,95,108,97,114,103,101,95,111,98,106,101,99,116,115,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.027187758 UTC

[section ""data" . lvl80_rcHr0_closure" {
     lvl80_rcHr0_closure:
         const lvl80_rcHr0_info;
         const 0;
         const 0;
         const 0;
 },
 lvl80_rcHr0_entry() //  [R1]
         { info_tbl: [(ccNh0,
                       label: lvl80_rcHr0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNh0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNh1; else goto ccNh2;
       ccNh1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNh2: // global
           (_ccNgX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNgX::I64 == 0) goto ccNgZ; else goto ccNgY;
       ccNgZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNgY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNgX::I64;
           R2 = lvl79_rcHqZ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.030929004 UTC

[section ""cstring" . lvl81_rcHr1_bytes" {
     lvl81_rcHr1_bytes:
         I8[] [109,97,120,95,99,111,109,112,97,99,116,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.032616606 UTC

[section ""data" . lvl82_rcHr2_closure" {
     lvl82_rcHr2_closure:
         const lvl82_rcHr2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl82_rcHr2_entry() //  [R1]
         { info_tbl: [(ccNhi,
                       label: lvl82_rcHr2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNhi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNhj; else goto ccNhk;
       ccNhj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNhk: // global
           (_ccNhf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNhf::I64 == 0) goto ccNhh; else goto ccNhg;
       ccNhh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNhg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNhf::I64;
           R2 = lvl81_rcHr1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.03639029 UTC

[section ""cstring" . lvl83_rcHr3_bytes" {
     lvl83_rcHr3_bytes:
         I8[] [109,97,120,95,115,108,111,112,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.038185339 UTC

[section ""data" . lvl84_rcHr4_closure" {
     lvl84_rcHr4_closure:
         const lvl84_rcHr4_info;
         const 0;
         const 0;
         const 0;
 },
 lvl84_rcHr4_entry() //  [R1]
         { info_tbl: [(ccNhA,
                       label: lvl84_rcHr4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNhA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNhB; else goto ccNhC;
       ccNhB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNhC: // global
           (_ccNhx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNhx::I64 == 0) goto ccNhz; else goto ccNhy;
       ccNhz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNhy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNhx::I64;
           R2 = lvl83_rcHr3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.042512122 UTC

[section ""cstring" . lvl85_rcHr5_bytes" {
     lvl85_rcHr5_bytes:
         I8[] [109,97,120,95,109,101,109,95,105,110,95,117,115,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.04427631 UTC

[section ""data" . lvl86_rcHr6_closure" {
     lvl86_rcHr6_closure:
         const lvl86_rcHr6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl86_rcHr6_entry() //  [R1]
         { info_tbl: [(ccNhS,
                       label: lvl86_rcHr6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNhS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNhT; else goto ccNhU;
       ccNhT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNhU: // global
           (_ccNhP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNhP::I64 == 0) goto ccNhR; else goto ccNhQ;
       ccNhR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNhQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNhP::I64;
           R2 = lvl85_rcHr5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.04848729 UTC

[section ""cstring" . lvl87_rcHr7_bytes" {
     lvl87_rcHr7_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,108,105,118,101,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.050303628 UTC

[section ""data" . lvl88_rcHr8_closure" {
     lvl88_rcHr8_closure:
         const lvl88_rcHr8_info;
         const 0;
         const 0;
         const 0;
 },
 lvl88_rcHr8_entry() //  [R1]
         { info_tbl: [(ccNia,
                       label: lvl88_rcHr8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNia: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNib; else goto ccNic;
       ccNib: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNic: // global
           (_ccNi7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNi7::I64 == 0) goto ccNi9; else goto ccNi8;
       ccNi9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNi8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNi7::I64;
           R2 = lvl87_rcHr7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.054138093 UTC

[section ""cstring" . lvl89_rcHr9_bytes" {
     lvl89_rcHr9_bytes:
         I8[] [99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.055912686 UTC

[section ""data" . lvl90_rcHra_closure" {
     lvl90_rcHra_closure:
         const lvl90_rcHra_info;
         const 0;
         const 0;
         const 0;
 },
 lvl90_rcHra_entry() //  [R1]
         { info_tbl: [(ccNis,
                       label: lvl90_rcHra_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNis: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNit; else goto ccNiu;
       ccNit: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNiu: // global
           (_ccNip::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNip::I64 == 0) goto ccNir; else goto ccNiq;
       ccNir: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNiq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNip::I64;
           R2 = lvl89_rcHr9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.059860312 UTC

[section ""cstring" . lvl91_rcHrb_bytes" {
     lvl91_rcHrb_bytes:
         I8[] [112,97,114,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.061718836 UTC

[section ""data" . lvl92_rcHrc_closure" {
     lvl92_rcHrc_closure:
         const lvl92_rcHrc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl92_rcHrc_entry() //  [R1]
         { info_tbl: [(ccNiK,
                       label: lvl92_rcHrc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNiK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNiL; else goto ccNiM;
       ccNiL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNiM: // global
           (_ccNiH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNiH::I64 == 0) goto ccNiJ; else goto ccNiI;
       ccNiJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNiI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNiH::I64;
           R2 = lvl91_rcHrb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.065434685 UTC

[section ""cstring" . lvl93_rcHrd_bytes" {
     lvl93_rcHrd_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,109,97,120,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.06724835 UTC

[section ""data" . lvl94_rcHre_closure" {
     lvl94_rcHre_closure:
         const lvl94_rcHre_info;
         const 0;
         const 0;
         const 0;
 },
 lvl94_rcHre_entry() //  [R1]
         { info_tbl: [(ccNj2,
                       label: lvl94_rcHre_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNj2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNj3; else goto ccNj4;
       ccNj3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNj4: // global
           (_ccNiZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNiZ::I64 == 0) goto ccNj1; else goto ccNj0;
       ccNj1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNj0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNiZ::I64;
           R2 = lvl93_rcHrd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.072110751 UTC

[section ""cstring" . lvl95_rcHrf_bytes" {
     lvl95_rcHrf_bytes:
         I8[] [99,117,109,117,108,97,116,105,118,101,95,112,97,114,95,98,97,108,97,110,99,101,100,95,99,111,112,105,101,100,95,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.073988949 UTC

[section ""data" . lvl96_rcHrg_closure" {
     lvl96_rcHrg_closure:
         const lvl96_rcHrg_info;
         const 0;
         const 0;
         const 0;
 },
 lvl96_rcHrg_entry() //  [R1]
         { info_tbl: [(ccNjk,
                       label: lvl96_rcHrg_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNjk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNjl; else goto ccNjm;
       ccNjl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNjm: // global
           (_ccNjh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNjh::I64 == 0) goto ccNjj; else goto ccNji;
       ccNjj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNji: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNjh::I64;
           R2 = lvl95_rcHrf_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.077712168 UTC

[section ""cstring" . lvl97_rcHrh_bytes" {
     lvl97_rcHrh_bytes:
         I8[] [109,117,116,97,116,111,114,95,99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.079559442 UTC

[section ""data" . lvl98_rcHri_closure" {
     lvl98_rcHri_closure:
         const lvl98_rcHri_info;
         const 0;
         const 0;
         const 0;
 },
 lvl98_rcHri_entry() //  [R1]
         { info_tbl: [(ccNjC,
                       label: lvl98_rcHri_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNjC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNjD; else goto ccNjE;
       ccNjD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNjE: // global
           (_ccNjz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNjz::I64 == 0) goto ccNjB; else goto ccNjA;
       ccNjB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNjA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNjz::I64;
           R2 = lvl97_rcHrh_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.083359524 UTC

[section ""cstring" . lvl99_rcHrj_bytes" {
     lvl99_rcHrj_bytes:
         I8[] [109,117,116,97,116,111,114,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.085128583 UTC

[section ""data" . lvl100_rcHrk_closure" {
     lvl100_rcHrk_closure:
         const lvl100_rcHrk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl100_rcHrk_entry() //  [R1]
         { info_tbl: [(ccNjU,
                       label: lvl100_rcHrk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNjU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNjV; else goto ccNjW;
       ccNjV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNjW: // global
           (_ccNjR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNjR::I64 == 0) goto ccNjT; else goto ccNjS;
       ccNjT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNjS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNjR::I64;
           R2 = lvl99_rcHrj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.088843018 UTC

[section ""cstring" . lvl101_rcHrl_bytes" {
     lvl101_rcHrl_bytes:
         I8[] [103,99,95,99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.090647279 UTC

[section ""data" . lvl102_rcHrm_closure" {
     lvl102_rcHrm_closure:
         const lvl102_rcHrm_info;
         const 0;
         const 0;
         const 0;
 },
 lvl102_rcHrm_entry() //  [R1]
         { info_tbl: [(ccNkc,
                       label: lvl102_rcHrm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNkc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNkd; else goto ccNke;
       ccNkd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNke: // global
           (_ccNk9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNk9::I64 == 0) goto ccNkb; else goto ccNka;
       ccNkb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNka: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNk9::I64;
           R2 = lvl101_rcHrl_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.094800814 UTC

[section ""cstring" . lvl103_rcHrn_bytes" {
     lvl103_rcHrn_bytes:
         I8[] [103,99,95,101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.096564262 UTC

[section ""data" . lvl104_rcHro_closure" {
     lvl104_rcHro_closure:
         const lvl104_rcHro_info;
         const 0;
         const 0;
         const 0;
 },
 lvl104_rcHro_entry() //  [R1]
         { info_tbl: [(ccNku,
                       label: lvl104_rcHro_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNku: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNkv; else goto ccNkw;
       ccNkv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNkw: // global
           (_ccNkr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNkr::I64 == 0) goto ccNkt; else goto ccNks;
       ccNkt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNks: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNkr::I64;
           R2 = lvl103_rcHrn_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.100334398 UTC

[section ""cstring" . lvl105_rcHrp_bytes" {
     lvl105_rcHrp_bytes:
         I8[] [99,112,117,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.102720502 UTC

[section ""data" . lvl106_rcHrq_closure" {
     lvl106_rcHrq_closure:
         const lvl106_rcHrq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl106_rcHrq_entry() //  [R1]
         { info_tbl: [(ccNkM,
                       label: lvl106_rcHrq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNkM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNkN; else goto ccNkO;
       ccNkN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNkO: // global
           (_ccNkJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNkJ::I64 == 0) goto ccNkL; else goto ccNkK;
       ccNkL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNkK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNkJ::I64;
           R2 = lvl105_rcHrp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.106533234 UTC

[section ""cstring" . lvl107_rcHrr_bytes" {
     lvl107_rcHrr_bytes:
         I8[] [101,108,97,112,115,101,100,95,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.108265547 UTC

[section ""data" . lvl108_rcHrs_closure" {
     lvl108_rcHrs_closure:
         const lvl108_rcHrs_info;
         const 0;
         const 0;
         const 0;
 },
 lvl108_rcHrs_entry() //  [R1]
         { info_tbl: [(ccNl4,
                       label: lvl108_rcHrs_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNl4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNl5; else goto ccNl6;
       ccNl5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNl6: // global
           (_ccNl1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNl1::I64 == 0) goto ccNl3; else goto ccNl2;
       ccNl3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNl2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNl1::I64;
           R2 = lvl107_rcHrr_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.112352309 UTC

[section ""cstring" . lvl109_rcHrt_bytes" {
     lvl109_rcHrt_bytes:
         I8[] [103,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.114228025 UTC

[section ""data" . lvl110_rcHru_closure" {
     lvl110_rcHru_closure:
         const lvl110_rcHru_info;
         const 0;
         const 0;
         const 0;
 },
 lvl110_rcHru_entry() //  [R1]
         { info_tbl: [(ccNlm,
                       label: lvl110_rcHru_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNlm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNln; else goto ccNlo;
       ccNln: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNlo: // global
           (_ccNlj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNlj::I64 == 0) goto ccNll; else goto ccNlk;
       ccNll: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNlk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNlj::I64;
           R2 = lvl109_rcHrt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.118152965 UTC

[section ""data" . lvl111_rcHrv_closure" {
     lvl111_rcHrv_closure:
         const lvl111_rcHrv_info;
         const 0;
 },
 lvl111_rcHrv_entry() //  [R3]
         { info_tbl: [(ccNlB,
                       label: lvl111_rcHrv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNlB: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Stats.$fReadGCDetails2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.13286668 UTC

[section ""data" . GHC.Stats.$w$creadPrec1_closure" {
     GHC.Stats.$w$creadPrec1_closure:
         const GHC.Stats.$w$creadPrec1_info;
         const 0;
 },
 sat_scLRQ_entry() //  [R1, R2]
         { info_tbl: [(ccNpf,
                       label: sat_scLRQ_info
                       rep:HeapRep 21 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNpf: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccNpj; else goto ccNpi;
       ccNpj: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNpi: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           _scLRp::P64 = P64[R1 + 71];
           _scLRr::P64 = P64[R1 + 79];
           _scLRt::P64 = P64[R1 + 87];
           _scLRv::P64 = P64[R1 + 95];
           _scLRx::P64 = P64[R1 + 103];
           _scLRz::P64 = P64[R1 + 111];
           _scLRB::P64 = P64[R1 + 119];
           _scLRD::P64 = P64[R1 + 127];
           _scLRF::P64 = P64[R1 + 135];
           _scLRH::P64 = P64[R1 + 143];
           _scLRJ::P64 = P64[R1 + 151];
           _scLRL::P64 = P64[R1 + 159];
           _scLRN::P64 = P64[R1 + 167];
           I64[Hp - 160] = GHC.Stats.RTSStats_con_info;
           P64[Hp - 152] = _scLRb::P64;
           P64[Hp - 144] = _scLRd::P64;
           P64[Hp - 136] = _scLRf::P64;
           P64[Hp - 128] = _scLRh::P64;
           P64[Hp - 120] = _scLRj::P64;
           P64[Hp - 112] = _scLRl::P64;
           P64[Hp - 104] = _scLRn::P64;
           P64[Hp - 96] = _scLRp::P64;
           P64[Hp - 88] = _scLRr::P64;
           P64[Hp - 80] = _scLRt::P64;
           P64[Hp - 72] = _scLRv::P64;
           P64[Hp - 64] = _scLRx::P64;
           P64[Hp - 56] = _scLRz::P64;
           P64[Hp - 48] = _scLRB::P64;
           P64[Hp - 40] = _scLRD::P64;
           P64[Hp - 32] = _scLRF::P64;
           P64[Hp - 24] = _scLRH::P64;
           P64[Hp - 16] = _scLRJ::P64;
           P64[Hp - 8] = _scLRL::P64;
           P64[Hp] = _scLRN::P64;
           R2 = Hp - 159;
           R1 = _scLR7::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLRT_entry() //  [R1, R2]
         { info_tbl: [(ccNpn,
                       label: sat_scLRT_info
                       rep:HeapRep 20 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNpn: // global
           _scLRN::P64 = R2;
           _scLRT::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNpo; else goto ccNpp;
       ccNpp: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ccNpr; else goto ccNpq;
       ccNpr: // global
           HpAlloc = 176;
           goto ccNpo;
       ccNpo: // global
           R2 = _scLRN::P64;
           R1 = _scLRT::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNpq: // global
           _scLR7::P64 = P64[_scLRT::P64 + 7];
           _scLRb::P64 = P64[_scLRT::P64 + 15];
           _scLRd::P64 = P64[_scLRT::P64 + 23];
           _scLRf::P64 = P64[_scLRT::P64 + 31];
           _scLRh::P64 = P64[_scLRT::P64 + 39];
           _scLRj::P64 = P64[_scLRT::P64 + 47];
           _scLRl::P64 = P64[_scLRT::P64 + 55];
           _scLRn::P64 = P64[_scLRT::P64 + 63];
           _scLRp::P64 = P64[_scLRT::P64 + 71];
           _scLRr::P64 = P64[_scLRT::P64 + 79];
           _scLRt::P64 = P64[_scLRT::P64 + 87];
           _scLRv::P64 = P64[_scLRT::P64 + 95];
           _scLRx::P64 = P64[_scLRT::P64 + 103];
           _scLRz::P64 = P64[_scLRT::P64 + 111];
           _scLRB::P64 = P64[_scLRT::P64 + 119];
           _scLRD::P64 = P64[_scLRT::P64 + 127];
           _scLRF::P64 = P64[_scLRT::P64 + 135];
           _scLRH::P64 = P64[_scLRT::P64 + 143];
           _scLRJ::P64 = P64[_scLRT::P64 + 151];
           _scLRL::P64 = P64[_scLRT::P64 + 159];
           I64[Hp - 168] = sat_scLRQ_info;
           P64[Hp - 160] = _scLR7::P64;
           P64[Hp - 152] = _scLRb::P64;
           P64[Hp - 144] = _scLRd::P64;
           P64[Hp - 136] = _scLRf::P64;
           P64[Hp - 128] = _scLRh::P64;
           P64[Hp - 120] = _scLRj::P64;
           P64[Hp - 112] = _scLRl::P64;
           P64[Hp - 104] = _scLRn::P64;
           P64[Hp - 96] = _scLRp::P64;
           P64[Hp - 88] = _scLRr::P64;
           P64[Hp - 80] = _scLRt::P64;
           P64[Hp - 72] = _scLRv::P64;
           P64[Hp - 64] = _scLRx::P64;
           P64[Hp - 56] = _scLRz::P64;
           P64[Hp - 48] = _scLRB::P64;
           P64[Hp - 40] = _scLRD::P64;
           P64[Hp - 32] = _scLRF::P64;
           P64[Hp - 24] = _scLRH::P64;
           P64[Hp - 16] = _scLRJ::P64;
           P64[Hp - 8] = _scLRL::P64;
           P64[Hp] = _scLRN::P64;
           I64[Sp - 8] = block_ccNpk_info;
           R3 = Hp - 167;
           R2 = lvl72_rcHqO_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNpk() //  [R1]
         { info_tbl: [(ccNpk,
                       label: block_ccNpk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNpk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNpu; else goto ccNpt;
       ccNpu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNpt: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLRU_entry() //  [R1, R2]
         { info_tbl: [(ccNpv,
                       label: sat_scLRU_info
                       rep:HeapRep 20 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNpv: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccNpz; else goto ccNpy;
       ccNpz: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNpy: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           _scLRp::P64 = P64[R1 + 71];
           _scLRr::P64 = P64[R1 + 79];
           _scLRt::P64 = P64[R1 + 87];
           _scLRv::P64 = P64[R1 + 95];
           _scLRx::P64 = P64[R1 + 103];
           _scLRz::P64 = P64[R1 + 111];
           _scLRB::P64 = P64[R1 + 119];
           _scLRD::P64 = P64[R1 + 127];
           _scLRF::P64 = P64[R1 + 135];
           _scLRH::P64 = P64[R1 + 143];
           _scLRJ::P64 = P64[R1 + 151];
           _scLRL::P64 = P64[R1 + 159];
           I64[Hp - 160] = sat_scLRT_info;
           P64[Hp - 152] = _scLR7::P64;
           P64[Hp - 144] = _scLRb::P64;
           P64[Hp - 136] = _scLRd::P64;
           P64[Hp - 128] = _scLRf::P64;
           P64[Hp - 120] = _scLRh::P64;
           P64[Hp - 112] = _scLRj::P64;
           P64[Hp - 104] = _scLRl::P64;
           P64[Hp - 96] = _scLRn::P64;
           P64[Hp - 88] = _scLRp::P64;
           P64[Hp - 80] = _scLRr::P64;
           P64[Hp - 72] = _scLRt::P64;
           P64[Hp - 64] = _scLRv::P64;
           P64[Hp - 56] = _scLRx::P64;
           P64[Hp - 48] = _scLRz::P64;
           P64[Hp - 40] = _scLRB::P64;
           P64[Hp - 32] = _scLRD::P64;
           P64[Hp - 24] = _scLRF::P64;
           P64[Hp - 16] = _scLRH::P64;
           P64[Hp - 8] = _scLRJ::P64;
           P64[Hp] = _scLRL::P64;
           R5 = Hp - 159;
           R4 = n_rcHqf_closure+1;
           R3 = lvl111_rcHrv_closure+2;
           R2 = lvl110_rcHru_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLRX_entry() //  [R1, R2]
         { info_tbl: [(ccNpD,
                       label: sat_scLRX_info
                       rep:HeapRep 19 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNpD: // global
           _scLRL::P64 = R2;
           _scLRX::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNpE; else goto ccNpF;
       ccNpF: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccNpH; else goto ccNpG;
       ccNpH: // global
           HpAlloc = 168;
           goto ccNpE;
       ccNpE: // global
           R2 = _scLRL::P64;
           R1 = _scLRX::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNpG: // global
           _scLR7::P64 = P64[_scLRX::P64 + 7];
           _scLRb::P64 = P64[_scLRX::P64 + 15];
           _scLRd::P64 = P64[_scLRX::P64 + 23];
           _scLRf::P64 = P64[_scLRX::P64 + 31];
           _scLRh::P64 = P64[_scLRX::P64 + 39];
           _scLRj::P64 = P64[_scLRX::P64 + 47];
           _scLRl::P64 = P64[_scLRX::P64 + 55];
           _scLRn::P64 = P64[_scLRX::P64 + 63];
           _scLRp::P64 = P64[_scLRX::P64 + 71];
           _scLRr::P64 = P64[_scLRX::P64 + 79];
           _scLRt::P64 = P64[_scLRX::P64 + 87];
           _scLRv::P64 = P64[_scLRX::P64 + 95];
           _scLRx::P64 = P64[_scLRX::P64 + 103];
           _scLRz::P64 = P64[_scLRX::P64 + 111];
           _scLRB::P64 = P64[_scLRX::P64 + 119];
           _scLRD::P64 = P64[_scLRX::P64 + 127];
           _scLRF::P64 = P64[_scLRX::P64 + 135];
           _scLRH::P64 = P64[_scLRX::P64 + 143];
           _scLRJ::P64 = P64[_scLRX::P64 + 151];
           I64[Hp - 160] = sat_scLRU_info;
           P64[Hp - 152] = _scLR7::P64;
           P64[Hp - 144] = _scLRb::P64;
           P64[Hp - 136] = _scLRd::P64;
           P64[Hp - 128] = _scLRf::P64;
           P64[Hp - 120] = _scLRh::P64;
           P64[Hp - 112] = _scLRj::P64;
           P64[Hp - 104] = _scLRl::P64;
           P64[Hp - 96] = _scLRn::P64;
           P64[Hp - 88] = _scLRp::P64;
           P64[Hp - 80] = _scLRr::P64;
           P64[Hp - 72] = _scLRt::P64;
           P64[Hp - 64] = _scLRv::P64;
           P64[Hp - 56] = _scLRx::P64;
           P64[Hp - 48] = _scLRz::P64;
           P64[Hp - 40] = _scLRB::P64;
           P64[Hp - 32] = _scLRD::P64;
           P64[Hp - 24] = _scLRF::P64;
           P64[Hp - 16] = _scLRH::P64;
           P64[Hp - 8] = _scLRJ::P64;
           P64[Hp] = _scLRL::P64;
           I64[Sp - 8] = block_ccNpA_info;
           R3 = Hp - 159;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNpA() //  [R1]
         { info_tbl: [(ccNpA,
                       label: block_ccNpA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNpA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNpK; else goto ccNpJ;
       ccNpK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNpJ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLRY_entry() //  [R1, R2]
         { info_tbl: [(ccNpL,
                       label: sat_scLRY_info
                       rep:HeapRep 19 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNpL: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccNpP; else goto ccNpO;
       ccNpP: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNpO: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           _scLRp::P64 = P64[R1 + 71];
           _scLRr::P64 = P64[R1 + 79];
           _scLRt::P64 = P64[R1 + 87];
           _scLRv::P64 = P64[R1 + 95];
           _scLRx::P64 = P64[R1 + 103];
           _scLRz::P64 = P64[R1 + 111];
           _scLRB::P64 = P64[R1 + 119];
           _scLRD::P64 = P64[R1 + 127];
           _scLRF::P64 = P64[R1 + 135];
           _scLRH::P64 = P64[R1 + 143];
           _scLRJ::P64 = P64[R1 + 151];
           I64[Hp - 152] = sat_scLRX_info;
           P64[Hp - 144] = _scLR7::P64;
           P64[Hp - 136] = _scLRb::P64;
           P64[Hp - 128] = _scLRd::P64;
           P64[Hp - 120] = _scLRf::P64;
           P64[Hp - 112] = _scLRh::P64;
           P64[Hp - 104] = _scLRj::P64;
           P64[Hp - 96] = _scLRl::P64;
           P64[Hp - 88] = _scLRn::P64;
           P64[Hp - 80] = _scLRp::P64;
           P64[Hp - 72] = _scLRr::P64;
           P64[Hp - 64] = _scLRt::P64;
           P64[Hp - 56] = _scLRv::P64;
           P64[Hp - 48] = _scLRx::P64;
           P64[Hp - 40] = _scLRz::P64;
           P64[Hp - 32] = _scLRB::P64;
           P64[Hp - 24] = _scLRD::P64;
           P64[Hp - 16] = _scLRF::P64;
           P64[Hp - 8] = _scLRH::P64;
           P64[Hp] = _scLRJ::P64;
           R5 = Hp - 151;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl108_rcHrs_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scLS1_entry() //  [R1, R2]
         { info_tbl: [(ccNpT,
                       label: sat_scLS1_info
                       rep:HeapRep 18 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNpT: // global
           _scLRJ::P64 = R2;
           _scLS1::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNpU; else goto ccNpV;
       ccNpV: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ccNpX; else goto ccNpW;
       ccNpX: // global
           HpAlloc = 160;
           goto ccNpU;
       ccNpU: // global
           R2 = _scLRJ::P64;
           R1 = _scLS1::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNpW: // global
           _scLR7::P64 = P64[_scLS1::P64 + 7];
           _scLRb::P64 = P64[_scLS1::P64 + 15];
           _scLRd::P64 = P64[_scLS1::P64 + 23];
           _scLRf::P64 = P64[_scLS1::P64 + 31];
           _scLRh::P64 = P64[_scLS1::P64 + 39];
           _scLRj::P64 = P64[_scLS1::P64 + 47];
           _scLRl::P64 = P64[_scLS1::P64 + 55];
           _scLRn::P64 = P64[_scLS1::P64 + 63];
           _scLRp::P64 = P64[_scLS1::P64 + 71];
           _scLRr::P64 = P64[_scLS1::P64 + 79];
           _scLRt::P64 = P64[_scLS1::P64 + 87];
           _scLRv::P64 = P64[_scLS1::P64 + 95];
           _scLRx::P64 = P64[_scLS1::P64 + 103];
           _scLRz::P64 = P64[_scLS1::P64 + 111];
           _scLRB::P64 = P64[_scLS1::P64 + 119];
           _scLRD::P64 = P64[_scLS1::P64 + 127];
           _scLRF::P64 = P64[_scLS1::P64 + 135];
           _scLRH::P64 = P64[_scLS1::P64 + 143];
           I64[Hp - 152] = sat_scLRY_info;
           P64[Hp - 144] = _scLR7::P64;
           P64[Hp - 136] = _scLRb::P64;
           P64[Hp - 128] = _scLRd::P64;
           P64[Hp - 120] = _scLRf::P64;
           P64[Hp - 112] = _scLRh::P64;
           P64[Hp - 104] = _scLRj::P64;
           P64[Hp - 96] = _scLRl::P64;
           P64[Hp - 88] = _scLRn::P64;
           P64[Hp - 80] = _scLRp::P64;
           P64[Hp - 72] = _scLRr::P64;
           P64[Hp - 64] = _scLRt::P64;
           P64[Hp - 56] = _scLRv::P64;
           P64[Hp - 48] = _scLRx::P64;
           P64[Hp - 40] = _scLRz::P64;
           P64[Hp - 32] = _scLRB::P64;
           P64[Hp - 24] = _scLRD::P64;
           P64[Hp - 16] = _scLRF::P64;
           P64[Hp - 8] = _scLRH::P64;
           P64[Hp] = _scLRJ::P64;
           I64[Sp - 8] = block_ccNpQ_info;
           R3 = Hp - 151;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNpQ() //  [R1]
         { info_tbl: [(ccNpQ,
                       label: block_ccNpQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNpQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNq0; else goto ccNpZ;
       ccNq0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNpZ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNuT_srtd" {
     ucNuT_srtd:
         const ScMjD_srt+128;
         const 33;
         const 8053063727;
 },
 sat_scLS2_entry() //  [R1, R2]
         { info_tbl: [(ccNq1,
                       label: sat_scLS2_info
                       rep:HeapRep 18 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNq1: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccNq5; else goto ccNq4;
       ccNq5: // global
           HpAlloc = 152;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNq4: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           _scLRp::P64 = P64[R1 + 71];
           _scLRr::P64 = P64[R1 + 79];
           _scLRt::P64 = P64[R1 + 87];
           _scLRv::P64 = P64[R1 + 95];
           _scLRx::P64 = P64[R1 + 103];
           _scLRz::P64 = P64[R1 + 111];
           _scLRB::P64 = P64[R1 + 119];
           _scLRD::P64 = P64[R1 + 127];
           _scLRF::P64 = P64[R1 + 135];
           _scLRH::P64 = P64[R1 + 143];
           I64[Hp - 144] = sat_scLS1_info;
           P64[Hp - 136] = _scLR7::P64;
           P64[Hp - 128] = _scLRb::P64;
           P64[Hp - 120] = _scLRd::P64;
           P64[Hp - 112] = _scLRf::P64;
           P64[Hp - 104] = _scLRh::P64;
           P64[Hp - 96] = _scLRj::P64;
           P64[Hp - 88] = _scLRl::P64;
           P64[Hp - 80] = _scLRn::P64;
           P64[Hp - 72] = _scLRp::P64;
           P64[Hp - 64] = _scLRr::P64;
           P64[Hp - 56] = _scLRt::P64;
           P64[Hp - 48] = _scLRv::P64;
           P64[Hp - 40] = _scLRx::P64;
           P64[Hp - 32] = _scLRz::P64;
           P64[Hp - 24] = _scLRB::P64;
           P64[Hp - 16] = _scLRD::P64;
           P64[Hp - 8] = _scLRF::P64;
           P64[Hp] = _scLRH::P64;
           R5 = Hp - 143;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl106_rcHrq_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNuU_srtd" {
     ucNuU_srtd:
         const ScMjD_srt+128;
         const 33;
         const 8053063727;
 },
 sat_scLS5_entry() //  [R1, R2]
         { info_tbl: [(ccNq9,
                       label: sat_scLS5_info
                       rep:HeapRep 17 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNq9: // global
           _scLRH::P64 = R2;
           _scLS5::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNqa; else goto ccNqb;
       ccNqb: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ccNqd; else goto ccNqc;
       ccNqd: // global
           HpAlloc = 152;
           goto ccNqa;
       ccNqa: // global
           R2 = _scLRH::P64;
           R1 = _scLS5::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNqc: // global
           _scLR7::P64 = P64[_scLS5::P64 + 7];
           _scLRb::P64 = P64[_scLS5::P64 + 15];
           _scLRd::P64 = P64[_scLS5::P64 + 23];
           _scLRf::P64 = P64[_scLS5::P64 + 31];
           _scLRh::P64 = P64[_scLS5::P64 + 39];
           _scLRj::P64 = P64[_scLS5::P64 + 47];
           _scLRl::P64 = P64[_scLS5::P64 + 55];
           _scLRn::P64 = P64[_scLS5::P64 + 63];
           _scLRp::P64 = P64[_scLS5::P64 + 71];
           _scLRr::P64 = P64[_scLS5::P64 + 79];
           _scLRt::P64 = P64[_scLS5::P64 + 87];
           _scLRv::P64 = P64[_scLS5::P64 + 95];
           _scLRx::P64 = P64[_scLS5::P64 + 103];
           _scLRz::P64 = P64[_scLS5::P64 + 111];
           _scLRB::P64 = P64[_scLS5::P64 + 119];
           _scLRD::P64 = P64[_scLS5::P64 + 127];
           _scLRF::P64 = P64[_scLS5::P64 + 135];
           I64[Hp - 144] = sat_scLS2_info;
           P64[Hp - 136] = _scLR7::P64;
           P64[Hp - 128] = _scLRb::P64;
           P64[Hp - 120] = _scLRd::P64;
           P64[Hp - 112] = _scLRf::P64;
           P64[Hp - 104] = _scLRh::P64;
           P64[Hp - 96] = _scLRj::P64;
           P64[Hp - 88] = _scLRl::P64;
           P64[Hp - 80] = _scLRn::P64;
           P64[Hp - 72] = _scLRp::P64;
           P64[Hp - 64] = _scLRr::P64;
           P64[Hp - 56] = _scLRt::P64;
           P64[Hp - 48] = _scLRv::P64;
           P64[Hp - 40] = _scLRx::P64;
           P64[Hp - 32] = _scLRz::P64;
           P64[Hp - 24] = _scLRB::P64;
           P64[Hp - 16] = _scLRD::P64;
           P64[Hp - 8] = _scLRF::P64;
           P64[Hp] = _scLRH::P64;
           I64[Sp - 8] = block_ccNq6_info;
           R3 = Hp - 143;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNq6() //  [R1]
         { info_tbl: [(ccNq6,
                       label: block_ccNq6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNq6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNqg; else goto ccNqf;
       ccNqg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNqf: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNuV_srtd" {
     ucNuV_srtd:
         const ScMjD_srt+128;
         const 34;
         const 16642998319;
 },
 sat_scLS6_entry() //  [R1, R2]
         { info_tbl: [(ccNqh,
                       label: sat_scLS6_info
                       rep:HeapRep 17 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNqh: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccNql; else goto ccNqk;
       ccNql: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNqk: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           _scLRp::P64 = P64[R1 + 71];
           _scLRr::P64 = P64[R1 + 79];
           _scLRt::P64 = P64[R1 + 87];
           _scLRv::P64 = P64[R1 + 95];
           _scLRx::P64 = P64[R1 + 103];
           _scLRz::P64 = P64[R1 + 111];
           _scLRB::P64 = P64[R1 + 119];
           _scLRD::P64 = P64[R1 + 127];
           _scLRF::P64 = P64[R1 + 135];
           I64[Hp - 136] = sat_scLS5_info;
           P64[Hp - 128] = _scLR7::P64;
           P64[Hp - 120] = _scLRb::P64;
           P64[Hp - 112] = _scLRd::P64;
           P64[Hp - 104] = _scLRf::P64;
           P64[Hp - 96] = _scLRh::P64;
           P64[Hp - 88] = _scLRj::P64;
           P64[Hp - 80] = _scLRl::P64;
           P64[Hp - 72] = _scLRn::P64;
           P64[Hp - 64] = _scLRp::P64;
           P64[Hp - 56] = _scLRr::P64;
           P64[Hp - 48] = _scLRt::P64;
           P64[Hp - 40] = _scLRv::P64;
           P64[Hp - 32] = _scLRx::P64;
           P64[Hp - 24] = _scLRz::P64;
           P64[Hp - 16] = _scLRB::P64;
           P64[Hp - 8] = _scLRD::P64;
           P64[Hp] = _scLRF::P64;
           R5 = Hp - 135;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl104_rcHro_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNuW_srtd" {
     ucNuW_srtd:
         const ScMjD_srt+128;
         const 34;
         const 16642998319;
 },
 sat_scLS9_entry() //  [R1, R2]
         { info_tbl: [(ccNqp,
                       label: sat_scLS9_info
                       rep:HeapRep 16 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNqp: // global
           _scLRF::P64 = R2;
           _scLS9::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNqq; else goto ccNqr;
       ccNqr: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto ccNqt; else goto ccNqs;
       ccNqt: // global
           HpAlloc = 144;
           goto ccNqq;
       ccNqq: // global
           R2 = _scLRF::P64;
           R1 = _scLS9::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNqs: // global
           _scLR7::P64 = P64[_scLS9::P64 + 7];
           _scLRb::P64 = P64[_scLS9::P64 + 15];
           _scLRd::P64 = P64[_scLS9::P64 + 23];
           _scLRf::P64 = P64[_scLS9::P64 + 31];
           _scLRh::P64 = P64[_scLS9::P64 + 39];
           _scLRj::P64 = P64[_scLS9::P64 + 47];
           _scLRl::P64 = P64[_scLS9::P64 + 55];
           _scLRn::P64 = P64[_scLS9::P64 + 63];
           _scLRp::P64 = P64[_scLS9::P64 + 71];
           _scLRr::P64 = P64[_scLS9::P64 + 79];
           _scLRt::P64 = P64[_scLS9::P64 + 87];
           _scLRv::P64 = P64[_scLS9::P64 + 95];
           _scLRx::P64 = P64[_scLS9::P64 + 103];
           _scLRz::P64 = P64[_scLS9::P64 + 111];
           _scLRB::P64 = P64[_scLS9::P64 + 119];
           _scLRD::P64 = P64[_scLS9::P64 + 127];
           I64[Hp - 136] = sat_scLS6_info;
           P64[Hp - 128] = _scLR7::P64;
           P64[Hp - 120] = _scLRb::P64;
           P64[Hp - 112] = _scLRd::P64;
           P64[Hp - 104] = _scLRf::P64;
           P64[Hp - 96] = _scLRh::P64;
           P64[Hp - 88] = _scLRj::P64;
           P64[Hp - 80] = _scLRl::P64;
           P64[Hp - 72] = _scLRn::P64;
           P64[Hp - 64] = _scLRp::P64;
           P64[Hp - 56] = _scLRr::P64;
           P64[Hp - 48] = _scLRt::P64;
           P64[Hp - 40] = _scLRv::P64;
           P64[Hp - 32] = _scLRx::P64;
           P64[Hp - 24] = _scLRz::P64;
           P64[Hp - 16] = _scLRB::P64;
           P64[Hp - 8] = _scLRD::P64;
           P64[Hp] = _scLRF::P64;
           I64[Sp - 8] = block_ccNqm_info;
           R3 = Hp - 135;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNqm() //  [R1]
         { info_tbl: [(ccNqm,
                       label: block_ccNqm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNqm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNqw; else goto ccNqv;
       ccNqw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNqv: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNuX_srtd" {
     ucNuX_srtd:
         const ScMjD_srt+128;
         const 35;
         const 33822867503;
 },
 sat_scLSa_entry() //  [R1, R2]
         { info_tbl: [(ccNqx,
                       label: sat_scLSa_info
                       rep:HeapRep 16 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNqx: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccNqB; else goto ccNqA;
       ccNqB: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNqA: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           _scLRp::P64 = P64[R1 + 71];
           _scLRr::P64 = P64[R1 + 79];
           _scLRt::P64 = P64[R1 + 87];
           _scLRv::P64 = P64[R1 + 95];
           _scLRx::P64 = P64[R1 + 103];
           _scLRz::P64 = P64[R1 + 111];
           _scLRB::P64 = P64[R1 + 119];
           _scLRD::P64 = P64[R1 + 127];
           I64[Hp - 128] = sat_scLS9_info;
           P64[Hp - 120] = _scLR7::P64;
           P64[Hp - 112] = _scLRb::P64;
           P64[Hp - 104] = _scLRd::P64;
           P64[Hp - 96] = _scLRf::P64;
           P64[Hp - 88] = _scLRh::P64;
           P64[Hp - 80] = _scLRj::P64;
           P64[Hp - 72] = _scLRl::P64;
           P64[Hp - 64] = _scLRn::P64;
           P64[Hp - 56] = _scLRp::P64;
           P64[Hp - 48] = _scLRr::P64;
           P64[Hp - 40] = _scLRt::P64;
           P64[Hp - 32] = _scLRv::P64;
           P64[Hp - 24] = _scLRx::P64;
           P64[Hp - 16] = _scLRz::P64;
           P64[Hp - 8] = _scLRB::P64;
           P64[Hp] = _scLRD::P64;
           R5 = Hp - 127;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl102_rcHrm_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNuY_srtd" {
     ucNuY_srtd:
         const ScMjD_srt+128;
         const 35;
         const 33822867503;
 },
 sat_scLSd_entry() //  [R1, R2]
         { info_tbl: [(ccNqF,
                       label: sat_scLSd_info
                       rep:HeapRep 15 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNqF: // global
           _scLRD::P64 = R2;
           _scLSd::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNqG; else goto ccNqH;
       ccNqH: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ccNqJ; else goto ccNqI;
       ccNqJ: // global
           HpAlloc = 136;
           goto ccNqG;
       ccNqG: // global
           R2 = _scLRD::P64;
           R1 = _scLSd::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNqI: // global
           _scLR7::P64 = P64[_scLSd::P64 + 7];
           _scLRb::P64 = P64[_scLSd::P64 + 15];
           _scLRd::P64 = P64[_scLSd::P64 + 23];
           _scLRf::P64 = P64[_scLSd::P64 + 31];
           _scLRh::P64 = P64[_scLSd::P64 + 39];
           _scLRj::P64 = P64[_scLSd::P64 + 47];
           _scLRl::P64 = P64[_scLSd::P64 + 55];
           _scLRn::P64 = P64[_scLSd::P64 + 63];
           _scLRp::P64 = P64[_scLSd::P64 + 71];
           _scLRr::P64 = P64[_scLSd::P64 + 79];
           _scLRt::P64 = P64[_scLSd::P64 + 87];
           _scLRv::P64 = P64[_scLSd::P64 + 95];
           _scLRx::P64 = P64[_scLSd::P64 + 103];
           _scLRz::P64 = P64[_scLSd::P64 + 111];
           _scLRB::P64 = P64[_scLSd::P64 + 119];
           I64[Hp - 128] = sat_scLSa_info;
           P64[Hp - 120] = _scLR7::P64;
           P64[Hp - 112] = _scLRb::P64;
           P64[Hp - 104] = _scLRd::P64;
           P64[Hp - 96] = _scLRf::P64;
           P64[Hp - 88] = _scLRh::P64;
           P64[Hp - 80] = _scLRj::P64;
           P64[Hp - 72] = _scLRl::P64;
           P64[Hp - 64] = _scLRn::P64;
           P64[Hp - 56] = _scLRp::P64;
           P64[Hp - 48] = _scLRr::P64;
           P64[Hp - 40] = _scLRt::P64;
           P64[Hp - 32] = _scLRv::P64;
           P64[Hp - 24] = _scLRx::P64;
           P64[Hp - 16] = _scLRz::P64;
           P64[Hp - 8] = _scLRB::P64;
           P64[Hp] = _scLRD::P64;
           I64[Sp - 8] = block_ccNqC_info;
           R3 = Hp - 127;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNqC() //  [R1]
         { info_tbl: [(ccNqC,
                       label: block_ccNqC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNqC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNqM; else goto ccNqL;
       ccNqM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNqL: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNuZ_srtd" {
     ucNuZ_srtd:
         const ScMjD_srt+128;
         const 36;
         const 68182605871;
 },
 sat_scLSe_entry() //  [R1, R2]
         { info_tbl: [(ccNqN,
                       label: sat_scLSe_info
                       rep:HeapRep 15 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNqN: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccNqR; else goto ccNqQ;
       ccNqR: // global
           HpAlloc = 128;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNqQ: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           _scLRp::P64 = P64[R1 + 71];
           _scLRr::P64 = P64[R1 + 79];
           _scLRt::P64 = P64[R1 + 87];
           _scLRv::P64 = P64[R1 + 95];
           _scLRx::P64 = P64[R1 + 103];
           _scLRz::P64 = P64[R1 + 111];
           _scLRB::P64 = P64[R1 + 119];
           I64[Hp - 120] = sat_scLSd_info;
           P64[Hp - 112] = _scLR7::P64;
           P64[Hp - 104] = _scLRb::P64;
           P64[Hp - 96] = _scLRd::P64;
           P64[Hp - 88] = _scLRf::P64;
           P64[Hp - 80] = _scLRh::P64;
           P64[Hp - 72] = _scLRj::P64;
           P64[Hp - 64] = _scLRl::P64;
           P64[Hp - 56] = _scLRn::P64;
           P64[Hp - 48] = _scLRp::P64;
           P64[Hp - 40] = _scLRr::P64;
           P64[Hp - 32] = _scLRt::P64;
           P64[Hp - 24] = _scLRv::P64;
           P64[Hp - 16] = _scLRx::P64;
           P64[Hp - 8] = _scLRz::P64;
           P64[Hp] = _scLRB::P64;
           R5 = Hp - 119;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl100_rcHrk_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNv0_srtd" {
     ucNv0_srtd:
         const ScMjD_srt+128;
         const 36;
         const 68182605871;
 },
 sat_scLSh_entry() //  [R1, R2]
         { info_tbl: [(ccNqV,
                       label: sat_scLSh_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNqV: // global
           _scLRB::P64 = R2;
           _scLSh::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNqW; else goto ccNqX;
       ccNqX: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ccNqZ; else goto ccNqY;
       ccNqZ: // global
           HpAlloc = 128;
           goto ccNqW;
       ccNqW: // global
           R2 = _scLRB::P64;
           R1 = _scLSh::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNqY: // global
           _scLR7::P64 = P64[_scLSh::P64 + 7];
           _scLRb::P64 = P64[_scLSh::P64 + 15];
           _scLRd::P64 = P64[_scLSh::P64 + 23];
           _scLRf::P64 = P64[_scLSh::P64 + 31];
           _scLRh::P64 = P64[_scLSh::P64 + 39];
           _scLRj::P64 = P64[_scLSh::P64 + 47];
           _scLRl::P64 = P64[_scLSh::P64 + 55];
           _scLRn::P64 = P64[_scLSh::P64 + 63];
           _scLRp::P64 = P64[_scLSh::P64 + 71];
           _scLRr::P64 = P64[_scLSh::P64 + 79];
           _scLRt::P64 = P64[_scLSh::P64 + 87];
           _scLRv::P64 = P64[_scLSh::P64 + 95];
           _scLRx::P64 = P64[_scLSh::P64 + 103];
           _scLRz::P64 = P64[_scLSh::P64 + 111];
           I64[Hp - 120] = sat_scLSe_info;
           P64[Hp - 112] = _scLR7::P64;
           P64[Hp - 104] = _scLRb::P64;
           P64[Hp - 96] = _scLRd::P64;
           P64[Hp - 88] = _scLRf::P64;
           P64[Hp - 80] = _scLRh::P64;
           P64[Hp - 72] = _scLRj::P64;
           P64[Hp - 64] = _scLRl::P64;
           P64[Hp - 56] = _scLRn::P64;
           P64[Hp - 48] = _scLRp::P64;
           P64[Hp - 40] = _scLRr::P64;
           P64[Hp - 32] = _scLRt::P64;
           P64[Hp - 24] = _scLRv::P64;
           P64[Hp - 16] = _scLRx::P64;
           P64[Hp - 8] = _scLRz::P64;
           P64[Hp] = _scLRB::P64;
           I64[Sp - 8] = block_ccNqS_info;
           R3 = Hp - 119;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNqS() //  [R1]
         { info_tbl: [(ccNqS,
                       label: block_ccNqS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNqS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNr2; else goto ccNr1;
       ccNr2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNr1: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNv1_srtd" {
     ucNv1_srtd:
         const ScMjD_srt+128;
         const 37;
         const 136902082607;
 },
 sat_scLSi_entry() //  [R1, R2]
         { info_tbl: [(ccNr3,
                       label: sat_scLSi_info
                       rep:HeapRep 14 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNr3: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccNr7; else goto ccNr6;
       ccNr7: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNr6: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           _scLRp::P64 = P64[R1 + 71];
           _scLRr::P64 = P64[R1 + 79];
           _scLRt::P64 = P64[R1 + 87];
           _scLRv::P64 = P64[R1 + 95];
           _scLRx::P64 = P64[R1 + 103];
           _scLRz::P64 = P64[R1 + 111];
           I64[Hp - 112] = sat_scLSh_info;
           P64[Hp - 104] = _scLR7::P64;
           P64[Hp - 96] = _scLRb::P64;
           P64[Hp - 88] = _scLRd::P64;
           P64[Hp - 80] = _scLRf::P64;
           P64[Hp - 72] = _scLRh::P64;
           P64[Hp - 64] = _scLRj::P64;
           P64[Hp - 56] = _scLRl::P64;
           P64[Hp - 48] = _scLRn::P64;
           P64[Hp - 40] = _scLRp::P64;
           P64[Hp - 32] = _scLRr::P64;
           P64[Hp - 24] = _scLRt::P64;
           P64[Hp - 16] = _scLRv::P64;
           P64[Hp - 8] = _scLRx::P64;
           P64[Hp] = _scLRz::P64;
           R5 = Hp - 111;
           R4 = n_rcHqf_closure+1;
           R3 = lvl66_rcHqI_closure+2;
           R2 = lvl98_rcHri_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNv2_srtd" {
     ucNv2_srtd:
         const ScMjD_srt+128;
         const 37;
         const 136902082607;
 },
 sat_scLSl_entry() //  [R1, R2]
         { info_tbl: [(ccNrb,
                       label: sat_scLSl_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNrb: // global
           _scLRz::P64 = R2;
           _scLSl::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNrc; else goto ccNrd;
       ccNrd: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccNrf; else goto ccNre;
       ccNrf: // global
           HpAlloc = 120;
           goto ccNrc;
       ccNrc: // global
           R2 = _scLRz::P64;
           R1 = _scLSl::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNre: // global
           _scLR7::P64 = P64[_scLSl::P64 + 7];
           _scLRb::P64 = P64[_scLSl::P64 + 15];
           _scLRd::P64 = P64[_scLSl::P64 + 23];
           _scLRf::P64 = P64[_scLSl::P64 + 31];
           _scLRh::P64 = P64[_scLSl::P64 + 39];
           _scLRj::P64 = P64[_scLSl::P64 + 47];
           _scLRl::P64 = P64[_scLSl::P64 + 55];
           _scLRn::P64 = P64[_scLSl::P64 + 63];
           _scLRp::P64 = P64[_scLSl::P64 + 71];
           _scLRr::P64 = P64[_scLSl::P64 + 79];
           _scLRt::P64 = P64[_scLSl::P64 + 87];
           _scLRv::P64 = P64[_scLSl::P64 + 95];
           _scLRx::P64 = P64[_scLSl::P64 + 103];
           I64[Hp - 112] = sat_scLSi_info;
           P64[Hp - 104] = _scLR7::P64;
           P64[Hp - 96] = _scLRb::P64;
           P64[Hp - 88] = _scLRd::P64;
           P64[Hp - 80] = _scLRf::P64;
           P64[Hp - 72] = _scLRh::P64;
           P64[Hp - 64] = _scLRj::P64;
           P64[Hp - 56] = _scLRl::P64;
           P64[Hp - 48] = _scLRn::P64;
           P64[Hp - 40] = _scLRp::P64;
           P64[Hp - 32] = _scLRr::P64;
           P64[Hp - 24] = _scLRt::P64;
           P64[Hp - 16] = _scLRv::P64;
           P64[Hp - 8] = _scLRx::P64;
           P64[Hp] = _scLRz::P64;
           I64[Sp - 8] = block_ccNr8_info;
           R3 = Hp - 111;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNr8() //  [R1]
         { info_tbl: [(ccNr8,
                       label: block_ccNr8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNr8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNri; else goto ccNrh;
       ccNri: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNrh: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNv3_srtd" {
     ucNv3_srtd:
         const ScMjD_srt+104;
         const 41;
         const 2194728288633;
 },
 sat_scLSm_entry() //  [R1, R2]
         { info_tbl: [(ccNrj,
                       label: sat_scLSm_info
                       rep:HeapRep 13 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNrj: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccNrn; else goto ccNrm;
       ccNrn: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNrm: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           _scLRp::P64 = P64[R1 + 71];
           _scLRr::P64 = P64[R1 + 79];
           _scLRt::P64 = P64[R1 + 87];
           _scLRv::P64 = P64[R1 + 95];
           _scLRx::P64 = P64[R1 + 103];
           I64[Hp - 104] = sat_scLSl_info;
           P64[Hp - 96] = _scLR7::P64;
           P64[Hp - 88] = _scLRb::P64;
           P64[Hp - 80] = _scLRd::P64;
           P64[Hp - 72] = _scLRf::P64;
           P64[Hp - 64] = _scLRh::P64;
           P64[Hp - 56] = _scLRj::P64;
           P64[Hp - 48] = _scLRl::P64;
           P64[Hp - 40] = _scLRn::P64;
           P64[Hp - 32] = _scLRp::P64;
           P64[Hp - 24] = _scLRr::P64;
           P64[Hp - 16] = _scLRt::P64;
           P64[Hp - 8] = _scLRv::P64;
           P64[Hp] = _scLRx::P64;
           R5 = Hp - 103;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl96_rcHrg_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNv4_srtd" {
     ucNv4_srtd:
         const ScMjD_srt+104;
         const 41;
         const 2194728288633;
 },
 sat_scLSp_entry() //  [R1, R2]
         { info_tbl: [(ccNrr,
                       label: sat_scLSp_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNrr: // global
           _scLRx::P64 = R2;
           _scLSp::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNrs; else goto ccNrt;
       ccNrt: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ccNrv; else goto ccNru;
       ccNrv: // global
           HpAlloc = 112;
           goto ccNrs;
       ccNrs: // global
           R2 = _scLRx::P64;
           R1 = _scLSp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNru: // global
           _scLR7::P64 = P64[_scLSp::P64 + 7];
           _scLRb::P64 = P64[_scLSp::P64 + 15];
           _scLRd::P64 = P64[_scLSp::P64 + 23];
           _scLRf::P64 = P64[_scLSp::P64 + 31];
           _scLRh::P64 = P64[_scLSp::P64 + 39];
           _scLRj::P64 = P64[_scLSp::P64 + 47];
           _scLRl::P64 = P64[_scLSp::P64 + 55];
           _scLRn::P64 = P64[_scLSp::P64 + 63];
           _scLRp::P64 = P64[_scLSp::P64 + 71];
           _scLRr::P64 = P64[_scLSp::P64 + 79];
           _scLRt::P64 = P64[_scLSp::P64 + 87];
           _scLRv::P64 = P64[_scLSp::P64 + 95];
           I64[Hp - 104] = sat_scLSm_info;
           P64[Hp - 96] = _scLR7::P64;
           P64[Hp - 88] = _scLRb::P64;
           P64[Hp - 80] = _scLRd::P64;
           P64[Hp - 72] = _scLRf::P64;
           P64[Hp - 64] = _scLRh::P64;
           P64[Hp - 56] = _scLRj::P64;
           P64[Hp - 48] = _scLRl::P64;
           P64[Hp - 40] = _scLRn::P64;
           P64[Hp - 32] = _scLRp::P64;
           P64[Hp - 24] = _scLRr::P64;
           P64[Hp - 16] = _scLRt::P64;
           P64[Hp - 8] = _scLRv::P64;
           P64[Hp] = _scLRx::P64;
           I64[Sp - 8] = block_ccNro_info;
           R3 = Hp - 103;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNro() //  [R1]
         { info_tbl: [(ccNro,
                       label: block_ccNro_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNro: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNry; else goto ccNrx;
       ccNry: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNrx: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNv5_srtd" {
     ucNv5_srtd:
         const ScMjD_srt+104;
         const 42;
         const 4393751544185;
 },
 sat_scLSq_entry() //  [R1, R2]
         { info_tbl: [(ccNrz,
                       label: sat_scLSq_info
                       rep:HeapRep 12 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNrz: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccNrD; else goto ccNrC;
       ccNrD: // global
           HpAlloc = 104;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNrC: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           _scLRp::P64 = P64[R1 + 71];
           _scLRr::P64 = P64[R1 + 79];
           _scLRt::P64 = P64[R1 + 87];
           _scLRv::P64 = P64[R1 + 95];
           I64[Hp - 96] = sat_scLSp_info;
           P64[Hp - 88] = _scLR7::P64;
           P64[Hp - 80] = _scLRb::P64;
           P64[Hp - 72] = _scLRd::P64;
           P64[Hp - 64] = _scLRf::P64;
           P64[Hp - 56] = _scLRh::P64;
           P64[Hp - 48] = _scLRj::P64;
           P64[Hp - 40] = _scLRl::P64;
           P64[Hp - 32] = _scLRn::P64;
           P64[Hp - 24] = _scLRp::P64;
           P64[Hp - 16] = _scLRr::P64;
           P64[Hp - 8] = _scLRt::P64;
           P64[Hp] = _scLRv::P64;
           R5 = Hp - 95;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl94_rcHre_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNv6_srtd" {
     ucNv6_srtd:
         const ScMjD_srt+104;
         const 42;
         const 4393751544185;
 },
 sat_scLSt_entry() //  [R1, R2]
         { info_tbl: [(ccNrH,
                       label: sat_scLSt_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNrH: // global
           _scLRv::P64 = R2;
           _scLSt::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNrI; else goto ccNrJ;
       ccNrJ: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ccNrL; else goto ccNrK;
       ccNrL: // global
           HpAlloc = 104;
           goto ccNrI;
       ccNrI: // global
           R2 = _scLRv::P64;
           R1 = _scLSt::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNrK: // global
           _scLR7::P64 = P64[_scLSt::P64 + 7];
           _scLRb::P64 = P64[_scLSt::P64 + 15];
           _scLRd::P64 = P64[_scLSt::P64 + 23];
           _scLRf::P64 = P64[_scLSt::P64 + 31];
           _scLRh::P64 = P64[_scLSt::P64 + 39];
           _scLRj::P64 = P64[_scLSt::P64 + 47];
           _scLRl::P64 = P64[_scLSt::P64 + 55];
           _scLRn::P64 = P64[_scLSt::P64 + 63];
           _scLRp::P64 = P64[_scLSt::P64 + 71];
           _scLRr::P64 = P64[_scLSt::P64 + 79];
           _scLRt::P64 = P64[_scLSt::P64 + 87];
           I64[Hp - 96] = sat_scLSq_info;
           P64[Hp - 88] = _scLR7::P64;
           P64[Hp - 80] = _scLRb::P64;
           P64[Hp - 72] = _scLRd::P64;
           P64[Hp - 64] = _scLRf::P64;
           P64[Hp - 56] = _scLRh::P64;
           P64[Hp - 48] = _scLRj::P64;
           P64[Hp - 40] = _scLRl::P64;
           P64[Hp - 32] = _scLRn::P64;
           P64[Hp - 24] = _scLRp::P64;
           P64[Hp - 16] = _scLRr::P64;
           P64[Hp - 8] = _scLRt::P64;
           P64[Hp] = _scLRv::P64;
           I64[Sp - 8] = block_ccNrE_info;
           R3 = Hp - 95;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNrE() //  [R1]
         { info_tbl: [(ccNrE,
                       label: block_ccNrE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNrE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNrO; else goto ccNrN;
       ccNrO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNrN: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNv7_srtd" {
     ucNv7_srtd:
         const ScMjD_srt+104;
         const 43;
         const 8791798055289;
 },
 sat_scLSu_entry() //  [R1, R2]
         { info_tbl: [(ccNrP,
                       label: sat_scLSu_info
                       rep:HeapRep 11 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNrP: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccNrT; else goto ccNrS;
       ccNrT: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNrS: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           _scLRp::P64 = P64[R1 + 71];
           _scLRr::P64 = P64[R1 + 79];
           _scLRt::P64 = P64[R1 + 87];
           I64[Hp - 88] = sat_scLSt_info;
           P64[Hp - 80] = _scLR7::P64;
           P64[Hp - 72] = _scLRb::P64;
           P64[Hp - 64] = _scLRd::P64;
           P64[Hp - 56] = _scLRf::P64;
           P64[Hp - 48] = _scLRh::P64;
           P64[Hp - 40] = _scLRj::P64;
           P64[Hp - 32] = _scLRl::P64;
           P64[Hp - 24] = _scLRn::P64;
           P64[Hp - 16] = _scLRp::P64;
           P64[Hp - 8] = _scLRr::P64;
           P64[Hp] = _scLRt::P64;
           R5 = Hp - 87;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl92_rcHrc_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNv8_srtd" {
     ucNv8_srtd:
         const ScMjD_srt+104;
         const 43;
         const 8791798055289;
 },
 sat_scLSx_entry() //  [R1, R2]
         { info_tbl: [(ccNrX,
                       label: sat_scLSx_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNrX: // global
           _scLRt::P64 = R2;
           _scLSx::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNrY; else goto ccNrZ;
       ccNrZ: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ccNs1; else goto ccNs0;
       ccNs1: // global
           HpAlloc = 96;
           goto ccNrY;
       ccNrY: // global
           R2 = _scLRt::P64;
           R1 = _scLSx::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNs0: // global
           _scLR7::P64 = P64[_scLSx::P64 + 7];
           _scLRb::P64 = P64[_scLSx::P64 + 15];
           _scLRd::P64 = P64[_scLSx::P64 + 23];
           _scLRf::P64 = P64[_scLSx::P64 + 31];
           _scLRh::P64 = P64[_scLSx::P64 + 39];
           _scLRj::P64 = P64[_scLSx::P64 + 47];
           _scLRl::P64 = P64[_scLSx::P64 + 55];
           _scLRn::P64 = P64[_scLSx::P64 + 63];
           _scLRp::P64 = P64[_scLSx::P64 + 71];
           _scLRr::P64 = P64[_scLSx::P64 + 79];
           I64[Hp - 88] = sat_scLSu_info;
           P64[Hp - 80] = _scLR7::P64;
           P64[Hp - 72] = _scLRb::P64;
           P64[Hp - 64] = _scLRd::P64;
           P64[Hp - 56] = _scLRf::P64;
           P64[Hp - 48] = _scLRh::P64;
           P64[Hp - 40] = _scLRj::P64;
           P64[Hp - 32] = _scLRl::P64;
           P64[Hp - 24] = _scLRn::P64;
           P64[Hp - 16] = _scLRp::P64;
           P64[Hp - 8] = _scLRr::P64;
           P64[Hp] = _scLRt::P64;
           I64[Sp - 8] = block_ccNrU_info;
           R3 = Hp - 87;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNrU() //  [R1]
         { info_tbl: [(ccNrU,
                       label: block_ccNrU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNrU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNs4; else goto ccNs3;
       ccNs4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNs3: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNv9_srtd" {
     ucNv9_srtd:
         const ScMjD_srt+104;
         const 44;
         const 17587891077497;
 },
 sat_scLSy_entry() //  [R1, R2]
         { info_tbl: [(ccNs5,
                       label: sat_scLSy_info
                       rep:HeapRep 10 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNs5: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccNs9; else goto ccNs8;
       ccNs9: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNs8: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           _scLRp::P64 = P64[R1 + 71];
           _scLRr::P64 = P64[R1 + 79];
           I64[Hp - 80] = sat_scLSx_info;
           P64[Hp - 72] = _scLR7::P64;
           P64[Hp - 64] = _scLRb::P64;
           P64[Hp - 56] = _scLRd::P64;
           P64[Hp - 48] = _scLRf::P64;
           P64[Hp - 40] = _scLRh::P64;
           P64[Hp - 32] = _scLRj::P64;
           P64[Hp - 24] = _scLRl::P64;
           P64[Hp - 16] = _scLRn::P64;
           P64[Hp - 8] = _scLRp::P64;
           P64[Hp] = _scLRr::P64;
           R5 = Hp - 79;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl90_rcHra_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNva_srtd" {
     ucNva_srtd:
         const ScMjD_srt+104;
         const 44;
         const 17587891077497;
 },
 sat_scLSB_entry() //  [R1, R2]
         { info_tbl: [(ccNsd,
                       label: sat_scLSB_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNsd: // global
           _scLRr::P64 = R2;
           _scLSB::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNse; else goto ccNsf;
       ccNsf: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccNsh; else goto ccNsg;
       ccNsh: // global
           HpAlloc = 88;
           goto ccNse;
       ccNse: // global
           R2 = _scLRr::P64;
           R1 = _scLSB::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNsg: // global
           _scLR7::P64 = P64[_scLSB::P64 + 7];
           _scLRb::P64 = P64[_scLSB::P64 + 15];
           _scLRd::P64 = P64[_scLSB::P64 + 23];
           _scLRf::P64 = P64[_scLSB::P64 + 31];
           _scLRh::P64 = P64[_scLSB::P64 + 39];
           _scLRj::P64 = P64[_scLSB::P64 + 47];
           _scLRl::P64 = P64[_scLSB::P64 + 55];
           _scLRn::P64 = P64[_scLSB::P64 + 63];
           _scLRp::P64 = P64[_scLSB::P64 + 71];
           I64[Hp - 80] = sat_scLSy_info;
           P64[Hp - 72] = _scLR7::P64;
           P64[Hp - 64] = _scLRb::P64;
           P64[Hp - 56] = _scLRd::P64;
           P64[Hp - 48] = _scLRf::P64;
           P64[Hp - 40] = _scLRh::P64;
           P64[Hp - 32] = _scLRj::P64;
           P64[Hp - 24] = _scLRl::P64;
           P64[Hp - 16] = _scLRn::P64;
           P64[Hp - 8] = _scLRp::P64;
           P64[Hp] = _scLRr::P64;
           I64[Sp - 8] = block_ccNsa_info;
           R3 = Hp - 79;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNsa() //  [R1]
         { info_tbl: [(ccNsa,
                       label: block_ccNsa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNsa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNsk; else goto ccNsj;
       ccNsk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNsj: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvb_srtd" {
     ucNvb_srtd:
         const ScMjD_srt+104;
         const 45;
         const 35180077121913;
 },
 sat_scLSC_entry() //  [R1, R2]
         { info_tbl: [(ccNsl,
                       label: sat_scLSC_info
                       rep:HeapRep 9 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNsl: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccNsp; else goto ccNso;
       ccNsp: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNso: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           _scLRp::P64 = P64[R1 + 71];
           I64[Hp - 72] = sat_scLSB_info;
           P64[Hp - 64] = _scLR7::P64;
           P64[Hp - 56] = _scLRb::P64;
           P64[Hp - 48] = _scLRd::P64;
           P64[Hp - 40] = _scLRf::P64;
           P64[Hp - 32] = _scLRh::P64;
           P64[Hp - 24] = _scLRj::P64;
           P64[Hp - 16] = _scLRl::P64;
           P64[Hp - 8] = _scLRn::P64;
           P64[Hp] = _scLRp::P64;
           R5 = Hp - 71;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl88_rcHr8_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvc_srtd" {
     ucNvc_srtd:
         const ScMjD_srt+104;
         const 45;
         const 35180077121913;
 },
 sat_scLSF_entry() //  [R1, R2]
         { info_tbl: [(ccNst,
                       label: sat_scLSF_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNst: // global
           _scLRp::P64 = R2;
           _scLSF::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNsu; else goto ccNsv;
       ccNsv: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ccNsx; else goto ccNsw;
       ccNsx: // global
           HpAlloc = 80;
           goto ccNsu;
       ccNsu: // global
           R2 = _scLRp::P64;
           R1 = _scLSF::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNsw: // global
           _scLR7::P64 = P64[_scLSF::P64 + 7];
           _scLRb::P64 = P64[_scLSF::P64 + 15];
           _scLRd::P64 = P64[_scLSF::P64 + 23];
           _scLRf::P64 = P64[_scLSF::P64 + 31];
           _scLRh::P64 = P64[_scLSF::P64 + 39];
           _scLRj::P64 = P64[_scLSF::P64 + 47];
           _scLRl::P64 = P64[_scLSF::P64 + 55];
           _scLRn::P64 = P64[_scLSF::P64 + 63];
           I64[Hp - 72] = sat_scLSC_info;
           P64[Hp - 64] = _scLR7::P64;
           P64[Hp - 56] = _scLRb::P64;
           P64[Hp - 48] = _scLRd::P64;
           P64[Hp - 40] = _scLRf::P64;
           P64[Hp - 32] = _scLRh::P64;
           P64[Hp - 24] = _scLRj::P64;
           P64[Hp - 16] = _scLRl::P64;
           P64[Hp - 8] = _scLRn::P64;
           P64[Hp] = _scLRp::P64;
           I64[Sp - 8] = block_ccNsq_info;
           R3 = Hp - 71;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNsq() //  [R1]
         { info_tbl: [(ccNsq,
                       label: block_ccNsq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNsq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNsA; else goto ccNsz;
       ccNsA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNsz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvd_srtd" {
     ucNvd_srtd:
         const ScMjD_srt+104;
         const 46;
         const 70364449210745;
 },
 sat_scLSG_entry() //  [R1, R2]
         { info_tbl: [(ccNsB,
                       label: sat_scLSG_info
                       rep:HeapRep 8 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNsB: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccNsF; else goto ccNsE;
       ccNsF: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNsE: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           _scLRn::P64 = P64[R1 + 63];
           I64[Hp - 64] = sat_scLSF_info;
           P64[Hp - 56] = _scLR7::P64;
           P64[Hp - 48] = _scLRb::P64;
           P64[Hp - 40] = _scLRd::P64;
           P64[Hp - 32] = _scLRf::P64;
           P64[Hp - 24] = _scLRh::P64;
           P64[Hp - 16] = _scLRj::P64;
           P64[Hp - 8] = _scLRl::P64;
           P64[Hp] = _scLRn::P64;
           R5 = Hp - 63;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl86_rcHr6_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNve_srtd" {
     ucNve_srtd:
         const ScMjD_srt+104;
         const 46;
         const 70364449210745;
 },
 sat_scLSJ_entry() //  [R1, R2]
         { info_tbl: [(ccNsJ,
                       label: sat_scLSJ_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNsJ: // global
           _scLRn::P64 = R2;
           _scLSJ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNsK; else goto ccNsL;
       ccNsL: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccNsN; else goto ccNsM;
       ccNsN: // global
           HpAlloc = 72;
           goto ccNsK;
       ccNsK: // global
           R2 = _scLRn::P64;
           R1 = _scLSJ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNsM: // global
           _scLR7::P64 = P64[_scLSJ::P64 + 7];
           _scLRb::P64 = P64[_scLSJ::P64 + 15];
           _scLRd::P64 = P64[_scLSJ::P64 + 23];
           _scLRf::P64 = P64[_scLSJ::P64 + 31];
           _scLRh::P64 = P64[_scLSJ::P64 + 39];
           _scLRj::P64 = P64[_scLSJ::P64 + 47];
           _scLRl::P64 = P64[_scLSJ::P64 + 55];
           I64[Hp - 64] = sat_scLSG_info;
           P64[Hp - 56] = _scLR7::P64;
           P64[Hp - 48] = _scLRb::P64;
           P64[Hp - 40] = _scLRd::P64;
           P64[Hp - 32] = _scLRf::P64;
           P64[Hp - 24] = _scLRh::P64;
           P64[Hp - 16] = _scLRj::P64;
           P64[Hp - 8] = _scLRl::P64;
           P64[Hp] = _scLRn::P64;
           I64[Sp - 8] = block_ccNsG_info;
           R3 = Hp - 63;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNsG() //  [R1]
         { info_tbl: [(ccNsG,
                       label: block_ccNsG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNsG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNsQ; else goto ccNsP;
       ccNsQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNsP: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvf_srtd" {
     ucNvf_srtd:
         const ScMjD_srt+104;
         const 47;
         const 140733193388409;
 },
 sat_scLSK_entry() //  [R1, R2]
         { info_tbl: [(ccNsR,
                       label: sat_scLSK_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNsR: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccNsV; else goto ccNsU;
       ccNsV: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNsU: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           _scLRl::P64 = P64[R1 + 55];
           I64[Hp - 56] = sat_scLSJ_info;
           P64[Hp - 48] = _scLR7::P64;
           P64[Hp - 40] = _scLRb::P64;
           P64[Hp - 32] = _scLRd::P64;
           P64[Hp - 24] = _scLRf::P64;
           P64[Hp - 16] = _scLRh::P64;
           P64[Hp - 8] = _scLRj::P64;
           P64[Hp] = _scLRl::P64;
           R5 = Hp - 55;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl84_rcHr4_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvg_srtd" {
     ucNvg_srtd:
         const ScMjD_srt+104;
         const 47;
         const 140733193388409;
 },
 sat_scLSN_entry() //  [R1, R2]
         { info_tbl: [(ccNsZ,
                       label: sat_scLSN_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNsZ: // global
           _scLRl::P64 = R2;
           _scLSN::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNt0; else goto ccNt1;
       ccNt1: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ccNt3; else goto ccNt2;
       ccNt3: // global
           HpAlloc = 64;
           goto ccNt0;
       ccNt0: // global
           R2 = _scLRl::P64;
           R1 = _scLSN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNt2: // global
           _scLR7::P64 = P64[_scLSN::P64 + 7];
           _scLRb::P64 = P64[_scLSN::P64 + 15];
           _scLRd::P64 = P64[_scLSN::P64 + 23];
           _scLRf::P64 = P64[_scLSN::P64 + 31];
           _scLRh::P64 = P64[_scLSN::P64 + 39];
           _scLRj::P64 = P64[_scLSN::P64 + 47];
           I64[Hp - 56] = sat_scLSK_info;
           P64[Hp - 48] = _scLR7::P64;
           P64[Hp - 40] = _scLRb::P64;
           P64[Hp - 32] = _scLRd::P64;
           P64[Hp - 24] = _scLRf::P64;
           P64[Hp - 16] = _scLRh::P64;
           P64[Hp - 8] = _scLRj::P64;
           P64[Hp] = _scLRl::P64;
           I64[Sp - 8] = block_ccNsW_info;
           R3 = Hp - 55;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNsW() //  [R1]
         { info_tbl: [(ccNsW,
                       label: block_ccNsW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNsW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNt6; else goto ccNt5;
       ccNt6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNt5: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvh_srtd" {
     ucNvh_srtd:
         const ScMjD_srt+104;
         const 48;
         const 281470681743737;
 },
 sat_scLSO_entry() //  [R1, R2]
         { info_tbl: [(ccNt7,
                       label: sat_scLSO_info
                       rep:HeapRep 6 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNt7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccNtb; else goto ccNta;
       ccNtb: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNta: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           _scLRj::P64 = P64[R1 + 47];
           I64[Hp - 48] = sat_scLSN_info;
           P64[Hp - 40] = _scLR7::P64;
           P64[Hp - 32] = _scLRb::P64;
           P64[Hp - 24] = _scLRd::P64;
           P64[Hp - 16] = _scLRf::P64;
           P64[Hp - 8] = _scLRh::P64;
           P64[Hp] = _scLRj::P64;
           R5 = Hp - 47;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl82_rcHr2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvi_srtd" {
     ucNvi_srtd:
         const ScMjD_srt+104;
         const 48;
         const 281470681743737;
 },
 sat_scLSR_entry() //  [R1, R2]
         { info_tbl: [(ccNtf,
                       label: sat_scLSR_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNtf: // global
           _scLRj::P64 = R2;
           _scLSR::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNtg; else goto ccNth;
       ccNth: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccNtj; else goto ccNti;
       ccNtj: // global
           HpAlloc = 56;
           goto ccNtg;
       ccNtg: // global
           R2 = _scLRj::P64;
           R1 = _scLSR::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNti: // global
           _scLR7::P64 = P64[_scLSR::P64 + 7];
           _scLRb::P64 = P64[_scLSR::P64 + 15];
           _scLRd::P64 = P64[_scLSR::P64 + 23];
           _scLRf::P64 = P64[_scLSR::P64 + 31];
           _scLRh::P64 = P64[_scLSR::P64 + 39];
           I64[Hp - 48] = sat_scLSO_info;
           P64[Hp - 40] = _scLR7::P64;
           P64[Hp - 32] = _scLRb::P64;
           P64[Hp - 24] = _scLRd::P64;
           P64[Hp - 16] = _scLRf::P64;
           P64[Hp - 8] = _scLRh::P64;
           P64[Hp] = _scLRj::P64;
           I64[Sp - 8] = block_ccNtc_info;
           R3 = Hp - 47;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNtc() //  [R1]
         { info_tbl: [(ccNtc,
                       label: block_ccNtc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNtc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNtm; else goto ccNtl;
       ccNtm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNtl: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvj_srtd" {
     ucNvj_srtd:
         const ScMjD_srt+104;
         const 49;
         const 562945658454393;
 },
 sat_scLSS_entry() //  [R1, R2]
         { info_tbl: [(ccNtn,
                       label: sat_scLSS_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNtn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccNtr; else goto ccNtq;
       ccNtr: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNtq: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           _scLRh::P64 = P64[R1 + 39];
           I64[Hp - 40] = sat_scLSR_info;
           P64[Hp - 32] = _scLR7::P64;
           P64[Hp - 24] = _scLRb::P64;
           P64[Hp - 16] = _scLRd::P64;
           P64[Hp - 8] = _scLRf::P64;
           P64[Hp] = _scLRh::P64;
           R5 = Hp - 39;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl80_rcHr0_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvk_srtd" {
     ucNvk_srtd:
         const ScMjD_srt+104;
         const 49;
         const 562945658454393;
 },
 sat_scLSV_entry() //  [R1, R2]
         { info_tbl: [(ccNtv,
                       label: sat_scLSV_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNtv: // global
           _scLRh::P64 = R2;
           _scLSV::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNtw; else goto ccNtx;
       ccNtx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ccNtz; else goto ccNty;
       ccNtz: // global
           HpAlloc = 48;
           goto ccNtw;
       ccNtw: // global
           R2 = _scLRh::P64;
           R1 = _scLSV::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNty: // global
           _scLR7::P64 = P64[_scLSV::P64 + 7];
           _scLRb::P64 = P64[_scLSV::P64 + 15];
           _scLRd::P64 = P64[_scLSV::P64 + 23];
           _scLRf::P64 = P64[_scLSV::P64 + 31];
           I64[Hp - 40] = sat_scLSS_info;
           P64[Hp - 32] = _scLR7::P64;
           P64[Hp - 24] = _scLRb::P64;
           P64[Hp - 16] = _scLRd::P64;
           P64[Hp - 8] = _scLRf::P64;
           P64[Hp] = _scLRh::P64;
           I64[Sp - 8] = block_ccNts_info;
           R3 = Hp - 39;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNts() //  [R1]
         { info_tbl: [(ccNts,
                       label: block_ccNts_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNts: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNtC; else goto ccNtB;
       ccNtC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNtB: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvl_srtd" {
     ucNvl_srtd:
         const ScMjD_srt+104;
         const 50;
         const 1125895611875705;
 },
 sat_scLSW_entry() //  [R1, R2]
         { info_tbl: [(ccNtD,
                       label: sat_scLSW_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNtD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccNtH; else goto ccNtG;
       ccNtH: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNtG: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           _scLRf::P64 = P64[R1 + 31];
           I64[Hp - 32] = sat_scLSV_info;
           P64[Hp - 24] = _scLR7::P64;
           P64[Hp - 16] = _scLRb::P64;
           P64[Hp - 8] = _scLRd::P64;
           P64[Hp] = _scLRf::P64;
           R5 = Hp - 31;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl78_rcHqY_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvm_srtd" {
     ucNvm_srtd:
         const ScMjD_srt+104;
         const 50;
         const 1125895611875705;
 },
 sat_scLSZ_entry() //  [R1, R2]
         { info_tbl: [(ccNtL,
                       label: sat_scLSZ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNtL: // global
           _scLRf::P64 = R2;
           _scLSZ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNtM; else goto ccNtN;
       ccNtN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccNtP; else goto ccNtO;
       ccNtP: // global
           HpAlloc = 40;
           goto ccNtM;
       ccNtM: // global
           R2 = _scLRf::P64;
           R1 = _scLSZ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNtO: // global
           _scLR7::P64 = P64[_scLSZ::P64 + 7];
           _scLRb::P64 = P64[_scLSZ::P64 + 15];
           _scLRd::P64 = P64[_scLSZ::P64 + 23];
           I64[Hp - 32] = sat_scLSW_info;
           P64[Hp - 24] = _scLR7::P64;
           P64[Hp - 16] = _scLRb::P64;
           P64[Hp - 8] = _scLRd::P64;
           P64[Hp] = _scLRf::P64;
           I64[Sp - 8] = block_ccNtI_info;
           R3 = Hp - 31;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNtI() //  [R1]
         { info_tbl: [(ccNtI,
                       label: block_ccNtI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNtI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNtS; else goto ccNtR;
       ccNtS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNtR: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvn_srtd" {
     ucNvn_srtd:
         const ScMjD_srt+104;
         const 51;
         const 2251795518718329;
 },
 sat_scLT0_entry() //  [R1, R2]
         { info_tbl: [(ccNtT,
                       label: sat_scLT0_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNtT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccNtX; else goto ccNtW;
       ccNtX: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNtW: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           _scLRd::P64 = P64[R1 + 23];
           I64[Hp - 24] = sat_scLSZ_info;
           P64[Hp - 16] = _scLR7::P64;
           P64[Hp - 8] = _scLRb::P64;
           P64[Hp] = _scLRd::P64;
           R5 = Hp - 23;
           R4 = n_rcHqf_closure+1;
           R3 = lvl46_rcHqo_closure+2;
           R2 = lvl76_rcHqW_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvo_srtd" {
     ucNvo_srtd:
         const ScMjD_srt+104;
         const 51;
         const 2251795518718329;
 },
 sat_scLT3_entry() //  [R1, R2]
         { info_tbl: [(ccNu1,
                       label: sat_scLT3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNu1: // global
           _scLRd::P64 = R2;
           _scLT3::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNu2; else goto ccNu3;
       ccNu3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccNu5; else goto ccNu4;
       ccNu5: // global
           HpAlloc = 32;
           goto ccNu2;
       ccNu2: // global
           R2 = _scLRd::P64;
           R1 = _scLT3::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNu4: // global
           _scLR7::P64 = P64[_scLT3::P64 + 7];
           _scLRb::P64 = P64[_scLT3::P64 + 15];
           I64[Hp - 24] = sat_scLT0_info;
           P64[Hp - 16] = _scLR7::P64;
           P64[Hp - 8] = _scLRb::P64;
           P64[Hp] = _scLRd::P64;
           I64[Sp - 8] = block_ccNtY_info;
           R3 = Hp - 23;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNtY() //  [R1]
         { info_tbl: [(ccNtY,
                       label: block_ccNtY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNtY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNu8; else goto ccNu7;
       ccNu8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNu7: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvp_srtd" {
     ucNvp_srtd:
         const ScMjD_srt+80;
         const 55;
         const 36028762659228617;
 },
 sat_scLT4_entry() //  [R1, R2]
         { info_tbl: [(ccNu9,
                       label: sat_scLT4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNu9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccNud; else goto ccNuc;
       ccNud: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNuc: // global
           _scLR7::P64 = P64[R1 + 7];
           _scLRb::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_scLT3_info;
           P64[Hp - 8] = _scLR7::P64;
           P64[Hp] = _scLRb::P64;
           R5 = Hp - 15;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = lvl74_rcHqU_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvq_srtd" {
     ucNvq_srtd:
         const ScMjD_srt+80;
         const 55;
         const 36028762659228617;
 },
 sat_scLT7_entry() //  [R1, R2]
         { info_tbl: [(ccNuh,
                       label: sat_scLT7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNuh: // global
           _scLRb::P64 = R2;
           _scLT7::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNui; else goto ccNuj;
       ccNuj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccNul; else goto ccNuk;
       ccNul: // global
           HpAlloc = 24;
           goto ccNui;
       ccNui: // global
           R2 = _scLRb::P64;
           R1 = _scLT7::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNuk: // global
           _scLR7::P64 = P64[_scLT7::P64 + 7];
           I64[Hp - 16] = sat_scLT4_info;
           P64[Hp - 8] = _scLR7::P64;
           P64[Hp] = _scLRb::P64;
           I64[Sp - 8] = block_ccNue_info;
           R3 = Hp - 15;
           R2 = lvl40_rcHqi_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNue() //  [R1]
         { info_tbl: [(ccNue,
                       label: block_ccNue_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNue: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNuo; else goto ccNun;
       ccNuo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNun: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvr_srtd" {
     ucNvr_srtd:
         const ScMjD_srt+80;
         const 56;
         const 72057559678192585;
 },
 sat_scLT8_entry() //  [R1, R2]
         { info_tbl: [(ccNup,
                       label: sat_scLT8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNup: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNut; else goto ccNus;
       ccNut: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNus: // global
           _scLR7::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_scLT7_info;
           P64[Hp] = _scLR7::P64;
           R5 = Hp - 7;
           R4 = n_rcHqf_closure+1;
           R3 = ds2_rcHqe_closure+2;
           R2 = ds4_rcHqS_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvs_srtd" {
     ucNvs_srtd:
         const ScMjD_srt+80;
         const 56;
         const 72057559711747017;
 },
 sat_scLTb_entry() //  [R1, R2]
         { info_tbl: [(ccNux,
                       label: sat_scLTb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNux: // global
           _scLR9::P64 = R2;
           _scLTb::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNuy; else goto ccNuz;
       ccNuz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNuB; else goto ccNuA;
       ccNuB: // global
           HpAlloc = 16;
           goto ccNuy;
       ccNuy: // global
           R2 = _scLR9::P64;
           R1 = _scLTb::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNuA: // global
           _scLR7::P64 = P64[_scLTb::P64 + 7];
           I64[Hp - 8] = sat_scLT8_info;
           P64[Hp] = _scLR7::P64;
           I64[Sp - 8] = block_ccNuu_info;
           R3 = Hp - 7;
           R2 = lexeme4_rcHqa_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNuu() //  [R1]
         { info_tbl: [(ccNuu,
                       label: block_ccNuu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNuu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNuE; else goto ccNuD;
       ccNuE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNuD: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ucNvt_srtd" {
     ucNvt_srtd:
         const ScMjD_srt+80;
         const 58;
         const 288230341825530825;
 },
 GHC.Stats.$w$creadPrec1_entry() //  [R2, R3]
         { info_tbl: [(ccNuI,
                       label: GHC.Stats.$w$creadPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNuI: // global
           _scLR7::P64 = R3;
           _scLR6::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccNuJ; else goto ccNuK;
       ccNuK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNuM; else goto ccNuL;
       ccNuM: // global
           HpAlloc = 16;
           goto ccNuJ;
       ccNuJ: // global
           R3 = _scLR7::P64;
           R2 = _scLR6::I64;
           R1 = GHC.Stats.$w$creadPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccNuL: // global
           if (%MO_S_Gt_W64(_scLR6::I64, 11)) goto ccNuG; else goto ccNuH;
       ccNuG: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccNuH: // global
           I64[Hp - 8] = sat_scLTb_info;
           P64[Hp] = _scLR7::P64;
           I64[Sp - 8] = block_ccNuN_info;
           R3 = Hp - 7;
           R2 = lexeme6_rcHqQ_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccNuN() //  [R1]
         { info_tbl: [(ccNuN,
                       label: block_ccNuN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNuN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccNuS; else goto ccNuR;
       ccNuS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccNuR: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.326110045 UTC

[section ""data" . GHC.Stats.$fReadRTSStats2_closure" {
     GHC.Stats.$fReadRTSStats2_closure:
         const GHC.Stats.$fReadRTSStats2_info;
         const 0;
 },
 GHC.Stats.$fReadRTSStats2_entry() //  [R2, R3]
         { info_tbl: [(ccNBv,
                       label: GHC.Stats.$fReadRTSStats2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNBv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNBw; else goto ccNBx;
       ccNBw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Stats.$fReadRTSStats2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccNBx: // global
           I64[Sp - 16] = block_ccNBs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucNBB; else goto ccNBt;
       ucNBB: // global
           call _ccNBs(R1) args: 0, res: 0, upd: 0;
       ccNBt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNBs() //  [R1]
         { info_tbl: [(ccNBs,
                       label: block_ccNBs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNBs: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Stats.$w$creadPrec1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.33144141 UTC

[section ""data" . GHC.Stats.$fReadRTSStats1_closure" {
     GHC.Stats.$fReadRTSStats1_closure:
         const GHC.Stats.$fReadRTSStats1_info;
         const 0;
 },
 GHC.Stats.$fReadRTSStats1_entry() //  [R2, R3]
         { info_tbl: [(ccNBQ,
                       label: GHC.Stats.$fReadRTSStats1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNBQ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Stats.$fReadRTSStats2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.334914137 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_$creadsPrec_closure" {
     GHC.Stats.$fReadRTSStats_$creadsPrec_closure:
         const GHC.Stats.$fReadRTSStats_$creadsPrec_info;
         const 0;
 },
 sat_scLTj_entry() //  [R1]
         { info_tbl: [(ccNC5,
                       label: sat_scLTj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNC5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNC6; else goto ccNC7;
       ccNC6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNC7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Stats.$fReadRTSStats2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Stats.$fReadRTSStats_$creadsPrec_entry() //  [R2]
         { info_tbl: [(ccNC8,
                       label: GHC.Stats.$fReadRTSStats_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNC8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccNCc; else goto ccNCb;
       ccNCc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Stats.$fReadRTSStats_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNCb: // global
           I64[Hp - 16] = sat_scLTj_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.341336899 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_$creadListPrec_closure" {
     GHC.Stats.$fReadRTSStats_$creadListPrec_closure:
         const GHC.Stats.$fReadRTSStats_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadRTSStats_$creadListPrec_entry() //  [R1]
         { info_tbl: [(ccNCv,
                       label: GHC.Stats.$fReadRTSStats_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNCv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNCw; else goto ccNCx;
       ccNCw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNCx: // global
           (_ccNCs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNCs::I64 == 0) goto ccNCu; else goto ccNCt;
       ccNCu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNCt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNCs::I64;
           R2 = GHC.Stats.$fReadRTSStats1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.345438005 UTC

[section ""data" . GHC.Stats.$fReadRTSStats3_closure" {
     GHC.Stats.$fReadRTSStats3_closure:
         const GHC.Stats.$fReadRTSStats3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.$fReadRTSStats3_entry() //  [R1]
         { info_tbl: [(ccNCM,
                       label: GHC.Stats.$fReadRTSStats3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNCM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNCN; else goto ccNCO;
       ccNCN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNCO: // global
           (_ccNCJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNCJ::I64 == 0) goto ccNCL; else goto ccNCK;
       ccNCL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNCK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNCJ::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.Stats.$fReadRTSStats_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.349928341 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_$creadList_closure" {
     GHC.Stats.$fReadRTSStats_$creadList_closure:
         const GHC.Stats.$fReadRTSStats_$creadList_info;
         const 0;
 },
 GHC.Stats.$fReadRTSStats_$creadList_entry() //  [R2]
         { info_tbl: [(ccND2,
                       label: GHC.Stats.$fReadRTSStats_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccND2: // global
           R3 = R2;
           R2 = GHC.Stats.$fReadRTSStats3_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.353268244 UTC

[section ""data" . GHC.Stats.$fReadRTSStats_closure" {
     GHC.Stats.$fReadRTSStats_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Stats.$fReadRTSStats_$creadsPrec_closure+1;
         const GHC.Stats.$fReadRTSStats_$creadList_closure+1;
         const GHC.Stats.$fReadRTSStats1_closure+2;
         const GHC.Stats.$fReadRTSStats_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.355353712 UTC

[section ""data" . GHC.Stats.gcdetails_elapsed_ns_closure" {
     GHC.Stats.gcdetails_elapsed_ns_closure:
         const GHC.Stats.gcdetails_elapsed_ns_info;
 },
 GHC.Stats.gcdetails_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccNDh,
                       label: GHC.Stats.gcdetails_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNDh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNDi; else goto ccNDj;
       ccNDi: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNDj: // global
           I64[Sp - 8] = block_ccNDe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNDn; else goto ccNDf;
       ucNDn: // global
           call _ccNDe(R1) args: 0, res: 0, upd: 0;
       ccNDf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNDe() //  [R1]
         { info_tbl: [(ccNDe,
                       label: block_ccNDe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNDe: // global
           R1 = P64[R1 + 111] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.360808816 UTC

[section ""data" . GHC.Stats.gcdetails_cpu_ns_closure" {
     GHC.Stats.gcdetails_cpu_ns_closure:
         const GHC.Stats.gcdetails_cpu_ns_info;
 },
 GHC.Stats.gcdetails_cpu_ns_entry() //  [R2]
         { info_tbl: [(ccNDH,
                       label: GHC.Stats.gcdetails_cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNDH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNDI; else goto ccNDJ;
       ccNDI: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNDJ: // global
           I64[Sp - 8] = block_ccNDE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNDN; else goto ccNDF;
       ucNDN: // global
           call _ccNDE(R1) args: 0, res: 0, upd: 0;
       ccNDF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNDE() //  [R1]
         { info_tbl: [(ccNDE,
                       label: block_ccNDE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNDE: // global
           R1 = P64[R1 + 103] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.366114184 UTC

[section ""data" . GHC.Stats.gcdetails_sync_elapsed_ns_closure" {
     GHC.Stats.gcdetails_sync_elapsed_ns_closure:
         const GHC.Stats.gcdetails_sync_elapsed_ns_info;
 },
 GHC.Stats.gcdetails_sync_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccNE7,
                       label: GHC.Stats.gcdetails_sync_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNE7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNE8; else goto ccNE9;
       ccNE8: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_sync_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNE9: // global
           I64[Sp - 8] = block_ccNE4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNEd; else goto ccNE5;
       ucNEd: // global
           call _ccNE4(R1) args: 0, res: 0, upd: 0;
       ccNE5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNE4() //  [R1]
         { info_tbl: [(ccNE4,
                       label: block_ccNE4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNE4: // global
           R1 = P64[R1 + 95] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.372420717 UTC

[section ""data" . GHC.Stats.gcdetails_par_balanced_copied_bytes_closure" {
     GHC.Stats.gcdetails_par_balanced_copied_bytes_closure:
         const GHC.Stats.gcdetails_par_balanced_copied_bytes_info;
 },
 GHC.Stats.gcdetails_par_balanced_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccNEx,
                       label: GHC.Stats.gcdetails_par_balanced_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNEx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNEy; else goto ccNEz;
       ccNEy: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_par_balanced_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNEz: // global
           I64[Sp - 8] = block_ccNEu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNED; else goto ccNEv;
       ucNED: // global
           call _ccNEu(R1) args: 0, res: 0, upd: 0;
       ccNEv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNEu() //  [R1]
         { info_tbl: [(ccNEu,
                       label: block_ccNEu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNEu: // global
           R1 = P64[R1 + 87] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.37778794 UTC

[section ""data" . GHC.Stats.gcdetails_par_max_copied_bytes_closure" {
     GHC.Stats.gcdetails_par_max_copied_bytes_closure:
         const GHC.Stats.gcdetails_par_max_copied_bytes_info;
 },
 GHC.Stats.gcdetails_par_max_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccNEX,
                       label: GHC.Stats.gcdetails_par_max_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNEX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNEY; else goto ccNEZ;
       ccNEY: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_par_max_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNEZ: // global
           I64[Sp - 8] = block_ccNEU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNF3; else goto ccNEV;
       ucNF3: // global
           call _ccNEU(R1) args: 0, res: 0, upd: 0;
       ccNEV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNEU() //  [R1]
         { info_tbl: [(ccNEU,
                       label: block_ccNEU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNEU: // global
           R1 = P64[R1 + 79] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.383144621 UTC

[section ""data" . GHC.Stats.gcdetails_copied_bytes_closure" {
     GHC.Stats.gcdetails_copied_bytes_closure:
         const GHC.Stats.gcdetails_copied_bytes_info;
 },
 GHC.Stats.gcdetails_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccNFn,
                       label: GHC.Stats.gcdetails_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNFn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNFo; else goto ccNFp;
       ccNFo: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNFp: // global
           I64[Sp - 8] = block_ccNFk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNFt; else goto ccNFl;
       ucNFt: // global
           call _ccNFk(R1) args: 0, res: 0, upd: 0;
       ccNFl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNFk() //  [R1]
         { info_tbl: [(ccNFk,
                       label: block_ccNFk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNFk: // global
           R1 = P64[R1 + 71] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.388544995 UTC

[section ""data" . GHC.Stats.gcdetails_mem_in_use_bytes_closure" {
     GHC.Stats.gcdetails_mem_in_use_bytes_closure:
         const GHC.Stats.gcdetails_mem_in_use_bytes_info;
 },
 GHC.Stats.gcdetails_mem_in_use_bytes_entry() //  [R2]
         { info_tbl: [(ccNFN,
                       label: GHC.Stats.gcdetails_mem_in_use_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNFN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNFO; else goto ccNFP;
       ccNFO: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_mem_in_use_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNFP: // global
           I64[Sp - 8] = block_ccNFK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNFT; else goto ccNFL;
       ucNFT: // global
           call _ccNFK(R1) args: 0, res: 0, upd: 0;
       ccNFL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNFK() //  [R1]
         { info_tbl: [(ccNFK,
                       label: block_ccNFK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNFK: // global
           R1 = P64[R1 + 63] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.39420406 UTC

[section ""data" . GHC.Stats.gcdetails_slop_bytes_closure" {
     GHC.Stats.gcdetails_slop_bytes_closure:
         const GHC.Stats.gcdetails_slop_bytes_info;
 },
 GHC.Stats.gcdetails_slop_bytes_entry() //  [R2]
         { info_tbl: [(ccNGd,
                       label: GHC.Stats.gcdetails_slop_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNGd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNGe; else goto ccNGf;
       ccNGe: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_slop_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNGf: // global
           I64[Sp - 8] = block_ccNGa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNGj; else goto ccNGb;
       ucNGj: // global
           call _ccNGa(R1) args: 0, res: 0, upd: 0;
       ccNGb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNGa() //  [R1]
         { info_tbl: [(ccNGa,
                       label: block_ccNGa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNGa: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.39947983 UTC

[section ""data" . GHC.Stats.gcdetails_compact_bytes_closure" {
     GHC.Stats.gcdetails_compact_bytes_closure:
         const GHC.Stats.gcdetails_compact_bytes_info;
 },
 GHC.Stats.gcdetails_compact_bytes_entry() //  [R2]
         { info_tbl: [(ccNGD,
                       label: GHC.Stats.gcdetails_compact_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNGD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNGE; else goto ccNGF;
       ccNGE: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_compact_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNGF: // global
           I64[Sp - 8] = block_ccNGA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNGJ; else goto ccNGB;
       ucNGJ: // global
           call _ccNGA(R1) args: 0, res: 0, upd: 0;
       ccNGB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNGA() //  [R1]
         { info_tbl: [(ccNGA,
                       label: block_ccNGA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNGA: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.404742349 UTC

[section ""data" . GHC.Stats.gcdetails_large_objects_bytes_closure" {
     GHC.Stats.gcdetails_large_objects_bytes_closure:
         const GHC.Stats.gcdetails_large_objects_bytes_info;
 },
 GHC.Stats.gcdetails_large_objects_bytes_entry() //  [R2]
         { info_tbl: [(ccNH3,
                       label: GHC.Stats.gcdetails_large_objects_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNH3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNH4; else goto ccNH5;
       ccNH4: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_large_objects_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNH5: // global
           I64[Sp - 8] = block_ccNH0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNH9; else goto ccNH1;
       ucNH9: // global
           call _ccNH0(R1) args: 0, res: 0, upd: 0;
       ccNH1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNH0() //  [R1]
         { info_tbl: [(ccNH0,
                       label: block_ccNH0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNH0: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.410837568 UTC

[section ""data" . GHC.Stats.gcdetails_live_bytes_closure" {
     GHC.Stats.gcdetails_live_bytes_closure:
         const GHC.Stats.gcdetails_live_bytes_info;
 },
 GHC.Stats.gcdetails_live_bytes_entry() //  [R2]
         { info_tbl: [(ccNHt,
                       label: GHC.Stats.gcdetails_live_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNHt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNHu; else goto ccNHv;
       ccNHu: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_live_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNHv: // global
           I64[Sp - 8] = block_ccNHq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNHz; else goto ccNHr;
       ucNHz: // global
           call _ccNHq(R1) args: 0, res: 0, upd: 0;
       ccNHr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNHq() //  [R1]
         { info_tbl: [(ccNHq,
                       label: block_ccNHq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNHq: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.416627674 UTC

[section ""data" . GHC.Stats.gcdetails_allocated_bytes_closure" {
     GHC.Stats.gcdetails_allocated_bytes_closure:
         const GHC.Stats.gcdetails_allocated_bytes_info;
 },
 GHC.Stats.gcdetails_allocated_bytes_entry() //  [R2]
         { info_tbl: [(ccNHT,
                       label: GHC.Stats.gcdetails_allocated_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNHT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNHU; else goto ccNHV;
       ccNHU: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_allocated_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNHV: // global
           I64[Sp - 8] = block_ccNHQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNHZ; else goto ccNHR;
       ucNHZ: // global
           call _ccNHQ(R1) args: 0, res: 0, upd: 0;
       ccNHR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNHQ() //  [R1]
         { info_tbl: [(ccNHQ,
                       label: block_ccNHQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNHQ: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.423863545 UTC

[section ""data" . GHC.Stats.gcdetails_threads_closure" {
     GHC.Stats.gcdetails_threads_closure:
         const GHC.Stats.gcdetails_threads_info;
 },
 GHC.Stats.gcdetails_threads_entry() //  [R2]
         { info_tbl: [(ccNIj,
                       label: GHC.Stats.gcdetails_threads_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNIj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNIk; else goto ccNIl;
       ccNIk: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_threads_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNIl: // global
           I64[Sp - 8] = block_ccNIg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNIp; else goto ccNIh;
       ucNIp: // global
           call _ccNIg(R1) args: 0, res: 0, upd: 0;
       ccNIh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNIg() //  [R1]
         { info_tbl: [(ccNIg,
                       label: block_ccNIg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNIg: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.429533991 UTC

[section ""data" . GHC.Stats.gcdetails_gen_closure" {
     GHC.Stats.gcdetails_gen_closure:
         const GHC.Stats.gcdetails_gen_info;
 },
 GHC.Stats.gcdetails_gen_entry() //  [R2]
         { info_tbl: [(ccNIJ,
                       label: GHC.Stats.gcdetails_gen_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNIJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNIK; else goto ccNIL;
       ccNIK: // global
           R2 = R2;
           R1 = GHC.Stats.gcdetails_gen_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNIL: // global
           I64[Sp - 8] = block_ccNIG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNIP; else goto ccNIH;
       ucNIP: // global
           call _ccNIG(R1) args: 0, res: 0, upd: 0;
       ccNIH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNIG() //  [R1]
         { info_tbl: [(ccNIG,
                       label: block_ccNIG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNIG: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.435520442 UTC

[section ""data" . GHC.Stats.gc_closure" {
     GHC.Stats.gc_closure:
         const GHC.Stats.gc_info;
 },
 GHC.Stats.gc_entry() //  [R2]
         { info_tbl: [(ccNJ9,
                       label: GHC.Stats.gc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNJ9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNJa; else goto ccNJb;
       ccNJa: // global
           R2 = R2;
           R1 = GHC.Stats.gc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNJb: // global
           I64[Sp - 8] = block_ccNJ6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNJf; else goto ccNJ7;
       ucNJf: // global
           call _ccNJ6(R1) args: 0, res: 0, upd: 0;
       ccNJ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNJ6() //  [R1]
         { info_tbl: [(ccNJ6,
                       label: block_ccNJ6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNJ6: // global
           R1 = P64[R1 + 159] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.44078 UTC

[section ""data" . GHC.Stats.elapsed_ns_closure" {
     GHC.Stats.elapsed_ns_closure:
         const GHC.Stats.elapsed_ns_info;
 },
 GHC.Stats.elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccNJz,
                       label: GHC.Stats.elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNJz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNJA; else goto ccNJB;
       ccNJA: // global
           R2 = R2;
           R1 = GHC.Stats.elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNJB: // global
           I64[Sp - 8] = block_ccNJw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNJF; else goto ccNJx;
       ucNJF: // global
           call _ccNJw(R1) args: 0, res: 0, upd: 0;
       ccNJx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNJw() //  [R1]
         { info_tbl: [(ccNJw,
                       label: block_ccNJw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNJw: // global
           R1 = P64[R1 + 151] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.450579672 UTC

[section ""data" . GHC.Stats.cpu_ns_closure" {
     GHC.Stats.cpu_ns_closure:
         const GHC.Stats.cpu_ns_info;
 },
 GHC.Stats.cpu_ns_entry() //  [R2]
         { info_tbl: [(ccNJZ,
                       label: GHC.Stats.cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNJZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNK0; else goto ccNK1;
       ccNK0: // global
           R2 = R2;
           R1 = GHC.Stats.cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNK1: // global
           I64[Sp - 8] = block_ccNJW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNK5; else goto ccNJX;
       ucNK5: // global
           call _ccNJW(R1) args: 0, res: 0, upd: 0;
       ccNJX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNJW() //  [R1]
         { info_tbl: [(ccNJW,
                       label: block_ccNJW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNJW: // global
           R1 = P64[R1 + 143] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.457014224 UTC

[section ""data" . GHC.Stats.gc_elapsed_ns_closure" {
     GHC.Stats.gc_elapsed_ns_closure:
         const GHC.Stats.gc_elapsed_ns_info;
 },
 GHC.Stats.gc_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccNKp,
                       label: GHC.Stats.gc_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNKp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNKq; else goto ccNKr;
       ccNKq: // global
           R2 = R2;
           R1 = GHC.Stats.gc_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNKr: // global
           I64[Sp - 8] = block_ccNKm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNKv; else goto ccNKn;
       ucNKv: // global
           call _ccNKm(R1) args: 0, res: 0, upd: 0;
       ccNKn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNKm() //  [R1]
         { info_tbl: [(ccNKm,
                       label: block_ccNKm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNKm: // global
           R1 = P64[R1 + 135] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.462283628 UTC

[section ""data" . GHC.Stats.gc_cpu_ns_closure" {
     GHC.Stats.gc_cpu_ns_closure:
         const GHC.Stats.gc_cpu_ns_info;
 },
 GHC.Stats.gc_cpu_ns_entry() //  [R2]
         { info_tbl: [(ccNKP,
                       label: GHC.Stats.gc_cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNKP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNKQ; else goto ccNKR;
       ccNKQ: // global
           R2 = R2;
           R1 = GHC.Stats.gc_cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNKR: // global
           I64[Sp - 8] = block_ccNKM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNKV; else goto ccNKN;
       ucNKV: // global
           call _ccNKM(R1) args: 0, res: 0, upd: 0;
       ccNKN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNKM() //  [R1]
         { info_tbl: [(ccNKM,
                       label: block_ccNKM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNKM: // global
           R1 = P64[R1 + 127] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.467935483 UTC

[section ""data" . GHC.Stats.mutator_elapsed_ns_closure" {
     GHC.Stats.mutator_elapsed_ns_closure:
         const GHC.Stats.mutator_elapsed_ns_info;
 },
 GHC.Stats.mutator_elapsed_ns_entry() //  [R2]
         { info_tbl: [(ccNLf,
                       label: GHC.Stats.mutator_elapsed_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNLf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNLg; else goto ccNLh;
       ccNLg: // global
           R2 = R2;
           R1 = GHC.Stats.mutator_elapsed_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNLh: // global
           I64[Sp - 8] = block_ccNLc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNLl; else goto ccNLd;
       ucNLl: // global
           call _ccNLc(R1) args: 0, res: 0, upd: 0;
       ccNLd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNLc() //  [R1]
         { info_tbl: [(ccNLc,
                       label: block_ccNLc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNLc: // global
           R1 = P64[R1 + 119] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.474076023 UTC

[section ""data" . GHC.Stats.mutator_cpu_ns_closure" {
     GHC.Stats.mutator_cpu_ns_closure:
         const GHC.Stats.mutator_cpu_ns_info;
 },
 GHC.Stats.mutator_cpu_ns_entry() //  [R2]
         { info_tbl: [(ccNLF,
                       label: GHC.Stats.mutator_cpu_ns_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNLF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNLG; else goto ccNLH;
       ccNLG: // global
           R2 = R2;
           R1 = GHC.Stats.mutator_cpu_ns_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNLH: // global
           I64[Sp - 8] = block_ccNLC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNLL; else goto ccNLD;
       ucNLL: // global
           call _ccNLC(R1) args: 0, res: 0, upd: 0;
       ccNLD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNLC() //  [R1]
         { info_tbl: [(ccNLC,
                       label: block_ccNLC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNLC: // global
           R1 = P64[R1 + 111] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.479978542 UTC

[section ""data" . GHC.Stats.cumulative_par_balanced_copied_bytes_closure" {
     GHC.Stats.cumulative_par_balanced_copied_bytes_closure:
         const GHC.Stats.cumulative_par_balanced_copied_bytes_info;
 },
 GHC.Stats.cumulative_par_balanced_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccNM5,
                       label: GHC.Stats.cumulative_par_balanced_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNM5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNM6; else goto ccNM7;
       ccNM6: // global
           R2 = R2;
           R1 = GHC.Stats.cumulative_par_balanced_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNM7: // global
           I64[Sp - 8] = block_ccNM2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNMb; else goto ccNM3;
       ucNMb: // global
           call _ccNM2(R1) args: 0, res: 0, upd: 0;
       ccNM3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNM2() //  [R1]
         { info_tbl: [(ccNM2,
                       label: block_ccNM2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNM2: // global
           R1 = P64[R1 + 103] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.486747678 UTC

[section ""data" . GHC.Stats.cumulative_par_max_copied_bytes_closure" {
     GHC.Stats.cumulative_par_max_copied_bytes_closure:
         const GHC.Stats.cumulative_par_max_copied_bytes_info;
 },
 GHC.Stats.cumulative_par_max_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccNMv,
                       label: GHC.Stats.cumulative_par_max_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNMv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNMw; else goto ccNMx;
       ccNMw: // global
           R2 = R2;
           R1 = GHC.Stats.cumulative_par_max_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNMx: // global
           I64[Sp - 8] = block_ccNMs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNMB; else goto ccNMt;
       ucNMB: // global
           call _ccNMs(R1) args: 0, res: 0, upd: 0;
       ccNMt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNMs() //  [R1]
         { info_tbl: [(ccNMs,
                       label: block_ccNMs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNMs: // global
           R1 = P64[R1 + 95] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.492024511 UTC

[section ""data" . GHC.Stats.par_copied_bytes_closure" {
     GHC.Stats.par_copied_bytes_closure:
         const GHC.Stats.par_copied_bytes_info;
 },
 GHC.Stats.par_copied_bytes_entry() //  [R2]
         { info_tbl: [(ccNMV,
                       label: GHC.Stats.par_copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNMV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNMW; else goto ccNMX;
       ccNMW: // global
           R2 = R2;
           R1 = GHC.Stats.par_copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNMX: // global
           I64[Sp - 8] = block_ccNMS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNN1; else goto ccNMT;
       ucNN1: // global
           call _ccNMS(R1) args: 0, res: 0, upd: 0;
       ccNMT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNMS() //  [R1]
         { info_tbl: [(ccNMS,
                       label: block_ccNMS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNMS: // global
           R1 = P64[R1 + 87] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.497543265 UTC

[section ""data" . GHC.Stats.copied_bytes_closure" {
     GHC.Stats.copied_bytes_closure:
         const GHC.Stats.copied_bytes_info;
 },
 GHC.Stats.copied_bytes_entry() //  [R2]
         { info_tbl: [(ccNNl,
                       label: GHC.Stats.copied_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNNl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNNm; else goto ccNNn;
       ccNNm: // global
           R2 = R2;
           R1 = GHC.Stats.copied_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNNn: // global
           I64[Sp - 8] = block_ccNNi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNNr; else goto ccNNj;
       ucNNr: // global
           call _ccNNi(R1) args: 0, res: 0, upd: 0;
       ccNNj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNNi() //  [R1]
         { info_tbl: [(ccNNi,
                       label: block_ccNNi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNNi: // global
           R1 = P64[R1 + 79] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.502679019 UTC

[section ""data" . GHC.Stats.cumulative_live_bytes_closure" {
     GHC.Stats.cumulative_live_bytes_closure:
         const GHC.Stats.cumulative_live_bytes_info;
 },
 GHC.Stats.cumulative_live_bytes_entry() //  [R2]
         { info_tbl: [(ccNNL,
                       label: GHC.Stats.cumulative_live_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNNL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNNM; else goto ccNNN;
       ccNNM: // global
           R2 = R2;
           R1 = GHC.Stats.cumulative_live_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNNN: // global
           I64[Sp - 8] = block_ccNNI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNNR; else goto ccNNJ;
       ucNNR: // global
           call _ccNNI(R1) args: 0, res: 0, upd: 0;
       ccNNJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNNI() //  [R1]
         { info_tbl: [(ccNNI,
                       label: block_ccNNI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNNI: // global
           R1 = P64[R1 + 71] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.507972526 UTC

[section ""data" . GHC.Stats.max_mem_in_use_bytes_closure" {
     GHC.Stats.max_mem_in_use_bytes_closure:
         const GHC.Stats.max_mem_in_use_bytes_info;
 },
 GHC.Stats.max_mem_in_use_bytes_entry() //  [R2]
         { info_tbl: [(ccNOb,
                       label: GHC.Stats.max_mem_in_use_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNOb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNOc; else goto ccNOd;
       ccNOc: // global
           R2 = R2;
           R1 = GHC.Stats.max_mem_in_use_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNOd: // global
           I64[Sp - 8] = block_ccNO8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNOh; else goto ccNO9;
       ucNOh: // global
           call _ccNO8(R1) args: 0, res: 0, upd: 0;
       ccNO9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNO8() //  [R1]
         { info_tbl: [(ccNO8,
                       label: block_ccNO8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNO8: // global
           R1 = P64[R1 + 63] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.513547075 UTC

[section ""data" . GHC.Stats.max_slop_bytes_closure" {
     GHC.Stats.max_slop_bytes_closure:
         const GHC.Stats.max_slop_bytes_info;
 },
 GHC.Stats.max_slop_bytes_entry() //  [R2]
         { info_tbl: [(ccNOB,
                       label: GHC.Stats.max_slop_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNOB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNOC; else goto ccNOD;
       ccNOC: // global
           R2 = R2;
           R1 = GHC.Stats.max_slop_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNOD: // global
           I64[Sp - 8] = block_ccNOy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNOH; else goto ccNOz;
       ucNOH: // global
           call _ccNOy(R1) args: 0, res: 0, upd: 0;
       ccNOz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNOy() //  [R1]
         { info_tbl: [(ccNOy,
                       label: block_ccNOy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNOy: // global
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.51934265 UTC

[section ""data" . GHC.Stats.max_compact_bytes_closure" {
     GHC.Stats.max_compact_bytes_closure:
         const GHC.Stats.max_compact_bytes_info;
 },
 GHC.Stats.max_compact_bytes_entry() //  [R2]
         { info_tbl: [(ccNP1,
                       label: GHC.Stats.max_compact_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNP1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNP2; else goto ccNP3;
       ccNP2: // global
           R2 = R2;
           R1 = GHC.Stats.max_compact_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNP3: // global
           I64[Sp - 8] = block_ccNOY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNP7; else goto ccNOZ;
       ucNP7: // global
           call _ccNOY(R1) args: 0, res: 0, upd: 0;
       ccNOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNOY() //  [R1]
         { info_tbl: [(ccNOY,
                       label: block_ccNOY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNOY: // global
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.524561205 UTC

[section ""data" . GHC.Stats.max_large_objects_bytes_closure" {
     GHC.Stats.max_large_objects_bytes_closure:
         const GHC.Stats.max_large_objects_bytes_info;
 },
 GHC.Stats.max_large_objects_bytes_entry() //  [R2]
         { info_tbl: [(ccNPr,
                       label: GHC.Stats.max_large_objects_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNPr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNPs; else goto ccNPt;
       ccNPs: // global
           R2 = R2;
           R1 = GHC.Stats.max_large_objects_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNPt: // global
           I64[Sp - 8] = block_ccNPo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNPx; else goto ccNPp;
       ucNPx: // global
           call _ccNPo(R1) args: 0, res: 0, upd: 0;
       ccNPp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNPo() //  [R1]
         { info_tbl: [(ccNPo,
                       label: block_ccNPo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNPo: // global
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.530361265 UTC

[section ""data" . GHC.Stats.max_live_bytes_closure" {
     GHC.Stats.max_live_bytes_closure:
         const GHC.Stats.max_live_bytes_info;
 },
 GHC.Stats.max_live_bytes_entry() //  [R2]
         { info_tbl: [(ccNPR,
                       label: GHC.Stats.max_live_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNPR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNPS; else goto ccNPT;
       ccNPS: // global
           R2 = R2;
           R1 = GHC.Stats.max_live_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNPT: // global
           I64[Sp - 8] = block_ccNPO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNPX; else goto ccNPP;
       ucNPX: // global
           call _ccNPO(R1) args: 0, res: 0, upd: 0;
       ccNPP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNPO() //  [R1]
         { info_tbl: [(ccNPO,
                       label: block_ccNPO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNPO: // global
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.535806639 UTC

[section ""data" . GHC.Stats.allocated_bytes_closure" {
     GHC.Stats.allocated_bytes_closure:
         const GHC.Stats.allocated_bytes_info;
 },
 GHC.Stats.allocated_bytes_entry() //  [R2]
         { info_tbl: [(ccNQh,
                       label: GHC.Stats.allocated_bytes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNQh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNQi; else goto ccNQj;
       ccNQi: // global
           R2 = R2;
           R1 = GHC.Stats.allocated_bytes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNQj: // global
           I64[Sp - 8] = block_ccNQe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNQn; else goto ccNQf;
       ucNQn: // global
           call _ccNQe(R1) args: 0, res: 0, upd: 0;
       ccNQf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNQe() //  [R1]
         { info_tbl: [(ccNQe,
                       label: block_ccNQe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNQe: // global
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.541139771 UTC

[section ""data" . GHC.Stats.major_gcs_closure" {
     GHC.Stats.major_gcs_closure:
         const GHC.Stats.major_gcs_info;
 },
 GHC.Stats.major_gcs_entry() //  [R2]
         { info_tbl: [(ccNQH,
                       label: GHC.Stats.major_gcs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNQH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNQI; else goto ccNQJ;
       ccNQI: // global
           R2 = R2;
           R1 = GHC.Stats.major_gcs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNQJ: // global
           I64[Sp - 8] = block_ccNQE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNQN; else goto ccNQF;
       ucNQN: // global
           call _ccNQE(R1) args: 0, res: 0, upd: 0;
       ccNQF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNQE() //  [R1]
         { info_tbl: [(ccNQE,
                       label: block_ccNQE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNQE: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.546560793 UTC

[section ""data" . GHC.Stats.gcs_closure" {
     GHC.Stats.gcs_closure:
         const GHC.Stats.gcs_info;
 },
 GHC.Stats.gcs_entry() //  [R2]
         { info_tbl: [(ccNR7,
                       label: GHC.Stats.gcs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNR7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNR8; else goto ccNR9;
       ccNR8: // global
           R2 = R2;
           R1 = GHC.Stats.gcs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccNR9: // global
           I64[Sp - 8] = block_ccNR4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucNRd; else goto ccNR5;
       ucNRd: // global
           call _ccNR4(R1) args: 0, res: 0, upd: 0;
       ccNR5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNR4() //  [R1]
         { info_tbl: [(ccNR4,
                       label: block_ccNR4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNR4: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.552380841 UTC

[section ""cstring" . GHC.Stats.$trModule4_bytes" {
     GHC.Stats.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.554043864 UTC

[section ""data" . GHC.Stats.$trModule3_closure" {
     GHC.Stats.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.555723652 UTC

[section ""cstring" . GHC.Stats.$trModule2_bytes" {
     GHC.Stats.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,97,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.557375462 UTC

[section ""data" . GHC.Stats.$trModule1_closure" {
     GHC.Stats.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.559001872 UTC

[section ""data" . GHC.Stats.$trModule_closure" {
     GHC.Stats.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Stats.$trModule3_closure+1;
         const GHC.Stats.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.560706796 UTC

[section ""data" . $krep_rcHrw_closure" {
     $krep_rcHrw_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Int.$tcInt64_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.562560817 UTC

[section ""data" . $krep1_rcHrx_closure" {
     $krep1_rcHrx_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord64_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.564261273 UTC

[section ""data" . $krep2_rcHry_closure" {
     $krep2_rcHry_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Word.$tcWord32_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.56603703 UTC

[section ""data" . GHC.Stats.$tcGCDetails1_closure" {
     GHC.Stats.$tcGCDetails1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tcGCDetails2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.567731508 UTC

[section ""data" . GHC.Stats.$tcGCDetails_closure" {
     GHC.Stats.$tcGCDetails_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tcGCDetails1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1853976479346877039;
         const 12435514499433877542;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.569914825 UTC

[section ""data" . $krep3_rcHrz_closure" {
     $krep3_rcHrz_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Stats.$tcGCDetails_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.571639191 UTC

[section ""data" . $krep4_rcHrA_closure" {
     $krep4_rcHrA_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep3_rcHrz_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.573393054 UTC

[section ""data" . $krep5_rcHrB_closure" {
     $krep5_rcHrB_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep4_rcHrA_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.57554439 UTC

[section ""data" . $krep6_rcHrC_closure" {
     $krep6_rcHrC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep5_rcHrB_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.577382064 UTC

[section ""data" . $krep7_rcHrD_closure" {
     $krep7_rcHrD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep6_rcHrC_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.579025102 UTC

[section ""data" . $krep8_rcHrE_closure" {
     $krep8_rcHrE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep7_rcHrD_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.580771945 UTC

[section ""data" . $krep9_rcHrF_closure" {
     $krep9_rcHrF_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep8_rcHrE_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.582959058 UTC

[section ""data" . $krep10_rcHrG_closure" {
     $krep10_rcHrG_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep9_rcHrF_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.584614271 UTC

[section ""data" . $krep11_rcHrH_closure" {
     $krep11_rcHrH_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep10_rcHrG_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.58642925 UTC

[section ""data" . $krep12_rcHrI_closure" {
     $krep12_rcHrI_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep11_rcHrH_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.588091673 UTC

[section ""data" . $krep13_rcHrJ_closure" {
     $krep13_rcHrJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep12_rcHrI_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.589822819 UTC

[section ""data" . $krep14_rcHrK_closure" {
     $krep14_rcHrK_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep13_rcHrJ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.59159855 UTC

[section ""data" . $krep15_rcHrL_closure" {
     $krep15_rcHrL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep14_rcHrK_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.59390451 UTC

[section ""data" . $krep16_rcHrM_closure" {
     $krep16_rcHrM_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep15_rcHrL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.595593129 UTC

[section ""data" . GHC.Stats.$tc'GCDetails1_closure" {
     GHC.Stats.$tc'GCDetails1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep16_rcHrM_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.597362395 UTC

[section ""cstring" . GHC.Stats.$tc'GCDetails3_bytes" {
     GHC.Stats.$tc'GCDetails3_bytes:
         I8[] [39,71,67,68,101,116,97,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.599043211 UTC

[section ""data" . GHC.Stats.$tc'GCDetails2_closure" {
     GHC.Stats.$tc'GCDetails2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tc'GCDetails3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.600716504 UTC

[section ""data" . GHC.Stats.$tc'GCDetails_closure" {
     GHC.Stats.$tc'GCDetails_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tc'GCDetails2_closure+1;
         const GHC.Stats.$tc'GCDetails1_closure+4;
         const 5964953867232766897;
         const 8889994537819840032;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.603135314 UTC

[section ""data" . GHC.Stats.$tcRTSStats1_closure" {
     GHC.Stats.$tcRTSStats1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tcRTSStats2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.604852973 UTC

[section ""data" . GHC.Stats.$tcRTSStats_closure" {
     GHC.Stats.$tcRTSStats_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tcRTSStats1_closure+1;
         const GHC.Types.krep$*_closure;
         const 1006825398788898151;
         const 9122067856566178937;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.607028153 UTC

[section ""data" . $krep17_rcHrN_closure" {
     $krep17_rcHrN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Stats.$tcRTSStats_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.608745728 UTC

[section ""data" . $krep18_rcHrO_closure" {
     $krep18_rcHrO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rcHrz_closure+1;
         const $krep17_rcHrN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.610570209 UTC

[section ""data" . $krep19_rcHrP_closure" {
     $krep19_rcHrP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep18_rcHrO_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.612311413 UTC

[section ""data" . $krep20_rcHrQ_closure" {
     $krep20_rcHrQ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep19_rcHrP_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.614150092 UTC

[section ""data" . $krep21_rcHrR_closure" {
     $krep21_rcHrR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep20_rcHrQ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.615853428 UTC

[section ""data" . $krep22_rcHrS_closure" {
     $krep22_rcHrS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep21_rcHrR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.617882901 UTC

[section ""data" . $krep23_rcHrT_closure" {
     $krep23_rcHrT_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep22_rcHrS_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.619578139 UTC

[section ""data" . $krep24_rcHrU_closure" {
     $krep24_rcHrU_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rcHrw_closure+1;
         const $krep23_rcHrT_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.621371994 UTC

[section ""data" . $krep25_rcHrV_closure" {
     $krep25_rcHrV_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep24_rcHrU_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.623133747 UTC

[section ""data" . $krep26_rcHrW_closure" {
     $krep26_rcHrW_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep25_rcHrV_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.624920963 UTC

[section ""data" . $krep27_rcHrX_closure" {
     $krep27_rcHrX_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep26_rcHrW_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.627202222 UTC

[section ""data" . $krep28_rcHrY_closure" {
     $krep28_rcHrY_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep27_rcHrX_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.629583192 UTC

[section ""data" . $krep29_rcHrZ_closure" {
     $krep29_rcHrZ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep28_rcHrY_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.631352231 UTC

[section ""data" . $krep30_rcHs0_closure" {
     $krep30_rcHs0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep29_rcHrZ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.633115983 UTC

[section ""data" . $krep31_rcHs1_closure" {
     $krep31_rcHs1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep30_rcHs0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.634944144 UTC

[section ""data" . $krep32_rcHs2_closure" {
     $krep32_rcHs2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep31_rcHs1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.63670797 UTC

[section ""data" . $krep33_rcHs3_closure" {
     $krep33_rcHs3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep32_rcHs2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.638710126 UTC

[section ""data" . $krep34_rcHs4_closure" {
     $krep34_rcHs4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep33_rcHs3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.640425134 UTC

[section ""data" . $krep35_rcHs5_closure" {
     $krep35_rcHs5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rcHrx_closure+1;
         const $krep34_rcHs4_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.642210846 UTC

[section ""data" . $krep36_rcHs6_closure" {
     $krep36_rcHs6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep35_rcHs5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.643939926 UTC

[section ""data" . GHC.Stats.$tc'RTSStats1_closure" {
     GHC.Stats.$tc'RTSStats1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rcHry_closure+1;
         const $krep36_rcHs6_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.645679973 UTC

[section ""cstring" . GHC.Stats.$tc'RTSStats3_bytes" {
     GHC.Stats.$tc'RTSStats3_bytes:
         I8[] [39,82,84,83,83,116,97,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.647416561 UTC

[section ""data" . GHC.Stats.$tc'RTSStats2_closure" {
     GHC.Stats.$tc'RTSStats2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Stats.$tc'RTSStats3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.649111149 UTC

[section ""data" . GHC.Stats.$tc'RTSStats_closure" {
     GHC.Stats.$tc'RTSStats_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Stats.$trModule_closure+1;
         const GHC.Stats.$tc'RTSStats2_closure+1;
         const GHC.Stats.$tc'RTSStats1_closure+4;
         const 10718900236833312508;
         const 16334729378492634062;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.652051512 UTC

[section ""data" . getRTSStatsEnabled1_rcHs7_closure" {
     getRTSStatsEnabled1_rcHs7_closure:
         const getRTSStatsEnabled1_rcHs7_info;
 },
 sat_scM48_entry() //  [R1]
         { info_tbl: [(ccNSx,
                       label: sat_scM48_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNSx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNSy; else goto ccNSz;
       ccNSy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNSz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto ccNSw; else goto ccNSv;
       ccNSw: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       ccNSv: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 getRTSStatsEnabled1_rcHs7_entry() //  []
         { info_tbl: [(ccNSA,
                       label: getRTSStatsEnabled1_rcHs7_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNSA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccNSB; else goto ccNSC;
       ccNSB: // global
           R1 = getRTSStatsEnabled1_rcHs7_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccNSC: // global
           I64[Sp - 8] = block_ccNSn_info;
           Sp = Sp - 8;
           _ucNSI::P64 = CurrentTSO;
           I64[I64[_ucNSI::P64 + 24] + 16] = Sp;
           _ucNSJ::I64 = CurrentNursery;
           P64[_ucNSJ::I64 + 8] = Hp + 8;
           I64[_ucNSI::P64 + 104] = I64[_ucNSI::P64 + 104] - ((Hp + 8) - I64[_ucNSJ::I64]);
           (_ucNSG::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_scM46::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] getRTSStatsEnabled();
           (_ucNSH::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ucNSG::I64);
           BaseReg = _ucNSH::I64;
           _ucNSK::P64 = CurrentTSO;
           _ucNSL::P64 = I64[_ucNSK::P64 + 24];
           Sp = I64[_ucNSL::P64 + 16];
           SpLim = _ucNSL::P64 + 192;
           HpAlloc = 0;
           _ucNSM::I64 = CurrentNursery;
           _ucNSN::I64 = I64[_ucNSM::I64 + 8];
           Hp = _ucNSN::I64 - 8;
           _ucNSO::I64 = I64[_ucNSM::I64];
           HpLim = _ucNSO::I64 + ((%MO_SS_Conv_W32_W64(I32[_ucNSM::I64 + 48]) << 12) - 1);
           I64[_ucNSK::P64 + 104] = I64[_ucNSK::P64 + 104] + (_ucNSN::I64 - _ucNSO::I64);
           R1 = _scM46::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNSn() //  [R1]
         { info_tbl: [(ccNSn,
                       label: block_ccNSn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNSn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccNSF; else goto ccNSE;
       ccNSF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccNSE: // global
           I64[Hp - 16] = sat_scM48_info;
           I64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.661680787 UTC

[section ""data" . GHC.Stats.getRTSStatsEnabled_closure" {
     GHC.Stats.getRTSStatsEnabled_closure:
         const GHC.Stats.getRTSStatsEnabled_info;
 },
 GHC.Stats.getRTSStatsEnabled_entry() //  []
         { info_tbl: [(ccNTt,
                       label: GHC.Stats.getRTSStatsEnabled_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNTt: // global
           call getRTSStatsEnabled1_rcHs7_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.664846694 UTC

[section ""cstring" . GHC.Stats.getRTSStats5_bytes" {
     GHC.Stats.getRTSStats5_bytes:
         I8[] [71,72,67,46,83,116,97,116,115,46,103,101,116,82,84,83,83,116,97,116,115,58,32,71,67,32,115,116,97,116,115,32,110,111,116,32,101,110,97,98,108,101,100,46,32,85,115,101,32,96,43,82,84,83,32,45,84,32,45,82,84,83,39,32,116,111,32,101,110,97,98,108,101,32,116,104,101,109,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.666797386 UTC

[section ""data" . GHC.Stats.getRTSStats4_closure" {
     GHC.Stats.getRTSStats4_closure:
         const GHC.Stats.getRTSStats4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.getRTSStats4_entry() //  [R1]
         { info_tbl: [(ccNTH,
                       label: GHC.Stats.getRTSStats4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNTH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNTI; else goto ccNTJ;
       ccNTI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNTJ: // global
           (_ccNTE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNTE::I64 == 0) goto ccNTG; else goto ccNTF;
       ccNTG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNTF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNTE::I64;
           R2 = GHC.Stats.getRTSStats5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.670766027 UTC

[section ""data" . GHC.Stats.getRTSStats3_closure" {
     GHC.Stats.getRTSStats3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UnsupportedOperation_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Stats.getRTSStats4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.672881596 UTC

[section ""data" . GHC.Stats.getRTSStats2_closure" {
     GHC.Stats.getRTSStats2_closure:
         const GHC.Stats.getRTSStats2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Stats.getRTSStats2_entry() //  [R1]
         { info_tbl: [(ccNTZ,
                       label: GHC.Stats.getRTSStats2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNTZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccNU0; else goto ccNU1;
       ccNU0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccNU1: // global
           (_ccNTW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccNTW::I64 == 0) goto ccNTY; else goto ccNTX;
       ccNTY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccNTX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccNTW::I64;
           R2 = GHC.Stats.getRTSStats3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.679418009 UTC

[section ""data" . GHC.Stats.getRTSStats1_closure" {
     GHC.Stats.getRTSStats1_closure:
         const GHC.Stats.getRTSStats1_info;
         const 0;
 },
 GHC.Stats.getRTSStats1_entry() //  []
         { info_tbl: [(ccNUl,
                       label: GHC.Stats.getRTSStats1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNUl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccNUm; else goto ccNUn;
       ccNUm: // global
           R1 = GHC.Stats.getRTSStats1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccNUn: // global
           I64[Sp - 8] = block_ccNUf_info;
           Sp = Sp - 8;
           _ucNWN::P64 = CurrentTSO;
           I64[I64[_ucNWN::P64 + 24] + 16] = Sp;
           _ucNWO::I64 = CurrentNursery;
           P64[_ucNWO::I64 + 8] = Hp + 8;
           I64[_ucNWN::P64 + 104] = I64[_ucNWN::P64 + 104] - ((Hp + 8) - I64[_ucNWO::I64]);
           (_ucNWL::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           (_scM4d::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] getRTSStatsEnabled();
           (_ucNWM::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ucNWL::I64);
           BaseReg = _ucNWM::I64;
           _ucNWP::P64 = CurrentTSO;
           _ucNWQ::P64 = I64[_ucNWP::P64 + 24];
           Sp = I64[_ucNWQ::P64 + 16];
           SpLim = _ucNWQ::P64 + 192;
           HpAlloc = 0;
           _ucNWR::I64 = CurrentNursery;
           _ucNWS::I64 = I64[_ucNWR::I64 + 8];
           Hp = _ucNWS::I64 - 8;
           _ucNWT::I64 = I64[_ucNWR::I64];
           HpLim = _ucNWT::I64 + ((%MO_SS_Conv_W32_W64(I32[_ucNWR::I64 + 48]) << 12) - 1);
           I64[_ucNWP::P64 + 104] = I64[_ucNWP::P64 + 104] + (_ucNWS::I64 - _ucNWT::I64);
           R1 = _scM4d::I64;
           call (I64[I64[Sp]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNUf() //  [R1]
         { info_tbl: [(ccNUf,
                       label: block_ccNUf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNUf: // global
           if (R1 == 0) goto ccNUk; else goto ccNUj;
       ccNUk: // global
           R1 = GHC.Stats.getRTSStats2_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       ccNUj: // global
           I64[Sp] = block_ccNUq_info;
           R1 = 248;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccNUq() //  [R1]
         { info_tbl: [(ccNUq,
                       label: block_ccNUq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNUq: // global
           I64[Sp - 16] = block_ccNUx_info;
           _scM4l::I64 = R1 + 16;
           I64[Sp - 8] = _scM4l::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           _ucNWX::P64 = CurrentTSO;
           I64[I64[_ucNWX::P64 + 24] + 16] = Sp;
           _ucNWY::I64 = CurrentNursery;
           P64[_ucNWY::I64 + 8] = Hp + 8;
           I64[_ucNWX::P64 + 104] = I64[_ucNWX::P64 + 104] - ((Hp + 8) - I64[_ucNWY::I64]);
           (_ucNWV::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [PtrHint]  result hints:  [] getRTSStats(_scM4l::I64);
           (_ucNWW::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ucNWV::I64);
           BaseReg = _ucNWW::I64;
           _ucNWZ::P64 = CurrentTSO;
           _ucNX0::P64 = I64[_ucNWZ::P64 + 24];
           Sp = I64[_ucNX0::P64 + 16];
           SpLim = _ucNX0::P64 + 192;
           HpAlloc = 0;
           _ucNX1::I64 = CurrentNursery;
           _ucNX2::I64 = I64[_ucNX1::I64 + 8];
           Hp = _ucNX2::I64 - 8;
           _ucNX3::I64 = I64[_ucNX1::I64];
           HpLim = _ucNX3::I64 + ((%MO_SS_Conv_W32_W64(I32[_ucNX1::I64 + 48]) << 12) - 1);
           I64[_ucNWZ::P64 + 104] = I64[_ucNWZ::P64 + 104] + (_ucNX2::I64 - _ucNX3::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _ccNUx() //  []
         { info_tbl: [(ccNUx,
                       label: block_ccNUx_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNUx: // global
           Hp = Hp + 816;
           if (Hp > HpLim) (likely: False) goto ccNWK; else goto ccNWJ;
       ccNWK: // global
           HpAlloc = 816;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccNWJ: // global
           _scM4l::I64 = I64[Sp + 8];
           _scM4r::I64 = %MO_UU_Conv_W32_W64(I32[_scM4l::I64]);
           _scM4v::I64 = %MO_UU_Conv_W32_W64(I32[_scM4l::I64 + 4]);
           _scM4z::I64 = I64[_scM4l::I64 + 8];
           _scM4D::I64 = I64[_scM4l::I64 + 16];
           _scM4H::I64 = I64[_scM4l::I64 + 24];
           _scM4L::I64 = I64[_scM4l::I64 + 32];
           _scM4P::I64 = I64[_scM4l::I64 + 40];
           _scM4T::I64 = I64[_scM4l::I64 + 48];
           _scM4X::I64 = I64[_scM4l::I64 + 56];
           _scM51::I64 = I64[_scM4l::I64 + 64];
           _scM55::I64 = I64[_scM4l::I64 + 72];
           _scM59::I64 = I64[_scM4l::I64 + 80];
           _scM5d::I64 = I64[_scM4l::I64 + 88];
           _scM5h::I64 = I64[_scM4l::I64 + 96];
           _scM5l::I64 = I64[_scM4l::I64 + 104];
           _scM5p::I64 = I64[_scM4l::I64 + 112];
           _scM5t::I64 = I64[_scM4l::I64 + 120];
           _scM5x::I64 = I64[_scM4l::I64 + 128];
           _scM5B::I64 = I64[_scM4l::I64 + 136];
           _scM5C::I64 = _scM4l::I64 + 144;
           _scM5F::I64 = %MO_UU_Conv_W32_W64(I32[_scM5C::I64]);
           _scM5J::I64 = %MO_UU_Conv_W32_W64(I32[_scM5C::I64 + 4]);
           _scM5N::I64 = I64[_scM5C::I64 + 8];
           _scM5R::I64 = I64[_scM5C::I64 + 16];
           _scM5V::I64 = I64[_scM5C::I64 + 24];
           _scM5Z::I64 = I64[_scM5C::I64 + 32];
           _scM63::I64 = I64[_scM5C::I64 + 40];
           _scM67::I64 = I64[_scM5C::I64 + 48];
           _scM6b::I64 = I64[_scM5C::I64 + 56];
           _scM6f::I64 = I64[_scM5C::I64 + 64];
           _scM6j::I64 = I64[_scM5C::I64 + 72];
           _scM6n::I64 = I64[_scM5C::I64 + 80];
           _scM6r::I64 = I64[_scM5C::I64 + 88];
           _scM6v::I64 = I64[_scM5C::I64 + 96];
           call MO_Touch(P64[Sp + 16]);
           I64[Hp - 808] = GHC.Int.I64#_con_info;
           I64[Hp - 800] = _scM6v::I64;
           I64[Hp - 792] = GHC.Int.I64#_con_info;
           I64[Hp - 784] = _scM6r::I64;
           I64[Hp - 776] = GHC.Int.I64#_con_info;
           I64[Hp - 768] = _scM6n::I64;
           I64[Hp - 760] = GHC.Word.W64#_con_info;
           I64[Hp - 752] = _scM6j::I64;
           I64[Hp - 744] = GHC.Word.W64#_con_info;
           I64[Hp - 736] = _scM6f::I64;
           I64[Hp - 728] = GHC.Word.W64#_con_info;
           I64[Hp - 720] = _scM6b::I64;
           I64[Hp - 712] = GHC.Word.W64#_con_info;
           I64[Hp - 704] = _scM67::I64;
           I64[Hp - 696] = GHC.Word.W64#_con_info;
           I64[Hp - 688] = _scM63::I64;
           I64[Hp - 680] = GHC.Word.W64#_con_info;
           I64[Hp - 672] = _scM5Z::I64;
           I64[Hp - 664] = GHC.Word.W64#_con_info;
           I64[Hp - 656] = _scM5V::I64;
           I64[Hp - 648] = GHC.Word.W64#_con_info;
           I64[Hp - 640] = _scM5R::I64;
           I64[Hp - 632] = GHC.Word.W64#_con_info;
           I64[Hp - 624] = _scM5N::I64;
           I64[Hp - 616] = GHC.Word.W32#_con_info;
           I64[Hp - 608] = _scM5J::I64;
           I64[Hp - 600] = GHC.Word.W32#_con_info;
           I64[Hp - 592] = _scM5F::I64;
           I64[Hp - 584] = GHC.Stats.GCDetails_con_info;
           P64[Hp - 576] = Hp - 599;
           P64[Hp - 568] = Hp - 615;
           P64[Hp - 560] = Hp - 631;
           P64[Hp - 552] = Hp - 647;
           P64[Hp - 544] = Hp - 663;
           P64[Hp - 536] = Hp - 679;
           P64[Hp - 528] = Hp - 695;
           P64[Hp - 520] = Hp - 711;
           P64[Hp - 512] = Hp - 727;
           P64[Hp - 504] = Hp - 743;
           P64[Hp - 496] = Hp - 759;
           P64[Hp - 488] = Hp - 775;
           P64[Hp - 480] = Hp - 791;
           P64[Hp - 472] = Hp - 807;
           I64[Hp - 464] = GHC.Int.I64#_con_info;
           I64[Hp - 456] = _scM5B::I64;
           I64[Hp - 448] = GHC.Int.I64#_con_info;
           I64[Hp - 440] = _scM5x::I64;
           I64[Hp - 432] = GHC.Int.I64#_con_info;
           I64[Hp - 424] = _scM5t::I64;
           I64[Hp - 416] = GHC.Int.I64#_con_info;
           I64[Hp - 408] = _scM5p::I64;
           I64[Hp - 400] = GHC.Int.I64#_con_info;
           I64[Hp - 392] = _scM5l::I64;
           I64[Hp - 384] = GHC.Int.I64#_con_info;
           I64[Hp - 376] = _scM5h::I64;
           I64[Hp - 368] = GHC.Word.W64#_con_info;
           I64[Hp - 360] = _scM5d::I64;
           I64[Hp - 352] = GHC.Word.W64#_con_info;
           I64[Hp - 344] = _scM59::I64;
           I64[Hp - 336] = GHC.Word.W64#_con_info;
           I64[Hp - 328] = _scM55::I64;
           I64[Hp - 320] = GHC.Word.W64#_con_info;
           I64[Hp - 312] = _scM51::I64;
           I64[Hp - 304] = GHC.Word.W64#_con_info;
           I64[Hp - 296] = _scM4X::I64;
           I64[Hp - 288] = GHC.Word.W64#_con_info;
           I64[Hp - 280] = _scM4T::I64;
           I64[Hp - 272] = GHC.Word.W64#_con_info;
           I64[Hp - 264] = _scM4P::I64;
           I64[Hp - 256] = GHC.Word.W64#_con_info;
           I64[Hp - 248] = _scM4L::I64;
           I64[Hp - 240] = GHC.Word.W64#_con_info;
           I64[Hp - 232] = _scM4H::I64;
           I64[Hp - 224] = GHC.Word.W64#_con_info;
           I64[Hp - 216] = _scM4D::I64;
           I64[Hp - 208] = GHC.Word.W64#_con_info;
           I64[Hp - 200] = _scM4z::I64;
           I64[Hp - 192] = GHC.Word.W32#_con_info;
           I64[Hp - 184] = _scM4v::I64;
           I64[Hp - 176] = GHC.Word.W32#_con_info;
           I64[Hp - 168] = _scM4r::I64;
           I64[Hp - 160] = GHC.Stats.RTSStats_con_info;
           P64[Hp - 152] = Hp - 175;
           P64[Hp - 144] = Hp - 191;
           P64[Hp - 136] = Hp - 207;
           P64[Hp - 128] = Hp - 223;
           P64[Hp - 120] = Hp - 239;
           P64[Hp - 112] = Hp - 255;
           P64[Hp - 104] = Hp - 271;
           P64[Hp - 96] = Hp - 287;
           P64[Hp - 88] = Hp - 303;
           P64[Hp - 80] = Hp - 319;
           P64[Hp - 72] = Hp - 335;
           P64[Hp - 64] = Hp - 351;
           P64[Hp - 56] = Hp - 367;
           P64[Hp - 48] = Hp - 383;
           P64[Hp - 40] = Hp - 399;
           P64[Hp - 32] = Hp - 415;
           P64[Hp - 24] = Hp - 431;
           P64[Hp - 16] = Hp - 447;
           P64[Hp - 8] = Hp - 463;
           P64[Hp] = Hp - 583;
           R1 = Hp - 159;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.697599004 UTC

[section ""data" . GHC.Stats.getRTSStats_closure" {
     GHC.Stats.getRTSStats_closure:
         const GHC.Stats.getRTSStats_info;
         const 0;
 },
 GHC.Stats.getRTSStats_entry() //  []
         { info_tbl: [(ccNZ2,
                       label: GHC.Stats.getRTSStats_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNZ2: // global
           call GHC.Stats.getRTSStats1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.701659672 UTC

[section ""data" . GHC.Stats.GCDetails_closure" {
     GHC.Stats.GCDetails_closure:
         const GHC.Stats.GCDetails_info;
 },
 GHC.Stats.GCDetails_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNZa: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Stats.GCDetails_entry(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2,
                                          R1) args: 80, res: 0, upd: 8;
     }
 },
 GHC.Stats.GCDetails_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccNZf,
                       label: GHC.Stats.GCDetails_info
                       rep:HeapRep static {
                             Fun {arity: 14
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNZf: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ccNZj; else goto ccNZi;
       ccNZj: // global
           HpAlloc = 120;
           R1 = GHC.Stats.GCDetails_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 120, res: 0, upd: 8;
       ccNZi: // global
           I64[Hp - 112] = GHC.Stats.GCDetails_con_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           P64[Hp - 88] = R4;
           P64[Hp - 80] = R5;
           P64[Hp - 72] = R6;
           P64[Hp - 64] = P64[Sp];
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = P64[Sp + 56];
           P64[Hp] = P64[Sp + 64];
           R1 = Hp - 111;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.709102106 UTC

[section ""data" . GHC.Stats.RTSStats_closure" {
     GHC.Stats.RTSStats_closure:
         const GHC.Stats.RTSStats_info;
 },
 GHC.Stats.RTSStats_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNZC: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Stats.RTSStats_entry(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2,
                                         R1) args: 128, res: 0, upd: 8;
     }
 },
 GHC.Stats.RTSStats_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(ccNZH,
                       label: GHC.Stats.RTSStats_info
                       rep:HeapRep static {
                             Fun {arity: 20
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccNZH: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto ccNZL; else goto ccNZK;
       ccNZL: // global
           HpAlloc = 168;
           R1 = GHC.Stats.RTSStats_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 168, res: 0, upd: 8;
       ccNZK: // global
           I64[Hp - 160] = GHC.Stats.RTSStats_con_info;
           P64[Hp - 152] = R2;
           P64[Hp - 144] = R3;
           P64[Hp - 136] = R4;
           P64[Hp - 128] = R5;
           P64[Hp - 120] = R6;
           P64[Hp - 112] = P64[Sp];
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = P64[Sp + 16];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 40];
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = P64[Sp + 56];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = P64[Sp + 72];
           P64[Hp - 32] = P64[Sp + 80];
           P64[Hp - 24] = P64[Sp + 88];
           P64[Hp - 16] = P64[Sp + 96];
           P64[Hp - 8] = P64[Sp + 104];
           P64[Hp] = P64[Sp + 112];
           R1 = Hp - 159;
           Sp = Sp + 120;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.715117727 UTC

[GHC.Stats.GCDetails_con_entry() //  [R1]
         { info_tbl: [(ccO09,
                       label: GHC.Stats.GCDetails_con_info
                       rep:HeapRep 14 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,115,46,71,67,68,101,116,97,105,108,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccO09: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.718384635 UTC

[GHC.Stats.RTSStats_con_entry() //  [R1]
         { info_tbl: [(ccO0g,
                       label: GHC.Stats.RTSStats_con_info
                       rep:HeapRep 20 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,83,116,97,116,115,46,82,84,83,83,116,97,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccO0g: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:48.721559695 UTC

[section ""relreadonly" . ScMjD_srt" {
     ScMjD_srt:
         const GHC.Show.showCommaSpace1_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Stats.$fShowGCDetails_$cshowsPrec_closure;
         const GHC.Stats.$fShowGCDetails_$cshow_closure;
         const GHC.Stats.$fShowGCDetails1_closure;
         const GHC.Stats.$fShowRTSStats_$cshowsPrec_closure;
         const GHC.Stats.$fShowRTSStats_$cshow_closure;
         const GHC.Stats.$fShowRTSStats1_closure;
         const GHC.Read.$fReadWord32_$creadsPrec_closure;
         const lvl37_rcHqd_closure;
         const ds2_rcHqe_closure;
         const GHC.Read.$fReadWord64_$creadsPrec_closure;
         const lvl45_rcHqn_closure;
         const lvl46_rcHqo_closure;
         const GHC.Int.$fReadInt64_$creadsPrec_closure;
         const lvl65_rcHqH_closure;
         const lvl66_rcHqI_closure;
         const Text.Read.Lex.$wexpect_closure;
         const lvl72_rcHqO_closure;
         const GHC.Read.readField_closure;
         const lvl70_rcHqM_closure;
         const lvl40_rcHqi_closure;
         const lvl68_rcHqK_closure;
         const lvl64_rcHqG_closure;
         const lvl62_rcHqE_closure;
         const lvl60_rcHqC_closure;
         const lvl58_rcHqA_closure;
         const lvl56_rcHqy_closure;
         const lvl54_rcHqw_closure;
         const lvl52_rcHqu_closure;
         const lvl50_rcHqs_closure;
         const lvl48_rcHqq_closure;
         const lvl44_rcHqm_closure;
         const lvl42_rcHqk_closure;
         const ds1_rcHqc_closure;
         const lexeme4_rcHqa_closure;
         const GHC.Stats.$w$creadPrec_closure;
         const lexeme1_rcHq7_closure;
         const GHC.Stats.$fReadGCDetails2_closure;
         const GHC.Read.list3_closure;
         const GHC.Stats.$fReadGCDetails_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.Stats.$fReadGCDetails1_closure;
         const GHC.Stats.$fReadGCDetails_$creadListPrec_closure;
         const GHC.Stats.$fReadGCDetails3_closure;
         const lvl110_rcHru_closure;
         const lvl111_rcHrv_closure;
         const lvl108_rcHrs_closure;
         const lvl106_rcHrq_closure;
         const lvl104_rcHro_closure;
         const lvl102_rcHrm_closure;
         const lvl100_rcHrk_closure;
         const lvl98_rcHri_closure;
         const lvl96_rcHrg_closure;
         const lvl94_rcHre_closure;
         const lvl92_rcHrc_closure;
         const lvl90_rcHra_closure;
         const lvl88_rcHr8_closure;
         const lvl86_rcHr6_closure;
         const lvl84_rcHr4_closure;
         const lvl82_rcHr2_closure;
         const lvl80_rcHr0_closure;
         const lvl78_rcHqY_closure;
         const lvl76_rcHqW_closure;
         const lvl74_rcHqU_closure;
         const ds4_rcHqS_closure;
         const GHC.Stats.$w$creadPrec1_closure;
         const lexeme6_rcHqQ_closure;
         const GHC.Stats.$fReadRTSStats2_closure;
         const GHC.Stats.$fReadRTSStats_$creadsPrec_closure;
         const GHC.Stats.$fReadRTSStats1_closure;
         const GHC.Stats.$fReadRTSStats_$creadListPrec_closure;
         const GHC.Stats.$fReadRTSStats3_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const GHC.Stats.getRTSStats3_closure;
         const GHC.Stats.getRTSStats1_closure;
         const GHC.Stats.getRTSStats2_closure;
 }]

