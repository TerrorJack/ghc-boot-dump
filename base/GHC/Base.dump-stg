
==================== Pre unarise: ====================
2018-03-16 15:54:42.247039157 UTC

GHC.Base.$p1Monad
  :: forall (m :: * -> *). GHC.Base.Monad m => GHC.Base.Applicative m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>] =
    [] \r [v_s7PN]
        case v_s7PN of {
          GHC.Base.C:Monad v_s7PP [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s7PP;
        };

GHC.Base.>>=
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. m a -> (a -> m b) -> m b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>] =
    [] \r [v_s7PU]
        case v_s7PU of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           v_s7PX [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s7PX;
        };

GHC.Base.>>
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. m a -> m b -> m b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>] =
    [] \r [v_s7Q1]
        case v_s7Q1 of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s7Q5 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s7Q5;
        };

GHC.Base.return
  :: forall (m :: * -> *). GHC.Base.Monad m => forall a. a -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>] =
    [] \r [v_s7Q8]
        case v_s7Q8 of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s7Qd [Occ=Once]
                           _ [Occ=Dead] ->
              v_s7Qd;
        };

GHC.Base.fail
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a. GHC.Base.String -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>] =
    [] \r [v_s7Qf]
        case v_s7Qf of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s7Ql [Occ=Once] ->
              v_s7Ql;
        };

GHC.Base.fmap
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     forall a b. (a -> b) -> f a -> f b
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_s7Qm]
        case v_s7Qm of {
          GHC.Base.C:Functor v_s7Qo [Occ=Once] _ [Occ=Dead] -> v_s7Qo;
        };

GHC.Base.<$
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     forall a b. a -> f b -> f a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_s7Qq]
        case v_s7Qq of {
          GHC.Base.C:Functor _ [Occ=Dead] v_s7Qt [Occ=Once] -> v_s7Qt;
        };

GHC.Base.$p1Applicative
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Base.Functor f
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>] =
    [] \r [v_s7Qu]
        case v_s7Qu of {
          GHC.Base.C:Applicative v_s7Qw [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7Qw;
        };

GHC.Base.pure
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a. a -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>] =
    [] \r [v_s7QC]
        case v_s7QC of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 v_s7QF [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7QF;
        };

GHC.Base.<*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f (a -> b) -> f a -> f b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>] =
    [] \r [v_s7QK]
        case v_s7QK of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7QO [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7QO;
        };

GHC.Base.liftA2
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b c. (a -> b -> c) -> f a -> f b -> f c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>] =
    [] \r [v_s7QS]
        case v_s7QS of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7QX [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7QX;
        };

GHC.Base.*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>] =
    [] \r [v_s7R0]
        case v_s7R0 of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7R6 [Occ=Once]
                                 _ [Occ=Dead] ->
              v_s7R6;
        };

GHC.Base.<*
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>] =
    [] \r [v_s7R8]
        case v_s7R8 of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7Rf [Occ=Once] ->
              v_s7Rf;
        };

GHC.Base.<> :: forall a. GHC.Base.Semigroup a => a -> a -> a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_s7Rg]
        case v_s7Rg of {
          GHC.Base.C:Semigroup v_s7Ri [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
              v_s7Ri;
        };

GHC.Base.sconcat
  :: forall a. GHC.Base.Semigroup a => GHC.Base.NonEmpty a -> a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_s7Rl]
        case v_s7Rl of {
          GHC.Base.C:Semigroup _ [Occ=Dead] v_s7Ro [Occ=Once] _ [Occ=Dead] ->
              v_s7Ro;
        };

GHC.Base.stimes
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b. GHC.Real.Integral b => b -> a -> a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_s7Rq]
        case v_s7Rq of {
          GHC.Base.C:Semigroup _ [Occ=Dead] _ [Occ=Dead] v_s7Ru [Occ=Once] ->
              v_s7Ru;
        };

GHC.Base.$p1Monoid
  :: forall a. GHC.Base.Monoid a => GHC.Base.Semigroup a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_s7Rv]
        case v_s7Rv of {
          GHC.Base.C:Monoid v_s7Rx [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
              v_s7Rx;
        };

GHC.Base.mempty :: forall a. GHC.Base.Monoid a => a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_s7RB]
        case v_s7RB of {
          GHC.Base.C:Monoid _ [Occ=Dead]
                            v_s7RE [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
              v_s7RE;
        };

GHC.Base.mappend :: forall a. GHC.Base.Monoid a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_s7RH]
        case v_s7RH of {
          GHC.Base.C:Monoid _ [Occ=Dead]
                            _ [Occ=Dead]
                            v_s7RL [Occ=Once]
                            _ [Occ=Dead] ->
              v_s7RL;
        };

GHC.Base.mconcat :: forall a. GHC.Base.Monoid a => [a] -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_s7RN]
        case v_s7RN of {
          GHC.Base.C:Monoid _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            v_s7RS [Occ=Once] ->
              v_s7RS;
        };

GHC.Base.$p1MonadPlus
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Base.Alternative m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_s7RT]
        case v_s7RT of {
          GHC.Base.C:MonadPlus v_s7RV [Occ=Once]
                               _ [Occ=Dead]
                               _ [Occ=Dead]
                               _ [Occ=Dead] ->
              v_s7RV;
        };

GHC.Base.$p2MonadPlus
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => GHC.Base.Monad m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_s7RZ]
        case v_s7RZ of {
          GHC.Base.C:MonadPlus _ [Occ=Dead]
                               v_s7S2 [Occ=Once]
                               _ [Occ=Dead]
                               _ [Occ=Dead] ->
              v_s7S2;
        };

GHC.Base.mzero
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => forall a. m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_s7S5]
        case v_s7S5 of {
          GHC.Base.C:MonadPlus _ [Occ=Dead]
                               _ [Occ=Dead]
                               v_s7S9 [Occ=Once]
                               _ [Occ=Dead] ->
              v_s7S9;
        };

GHC.Base.mplus
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a. m a -> m a -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_s7Sb]
        case v_s7Sb of {
          GHC.Base.C:MonadPlus _ [Occ=Dead]
                               _ [Occ=Dead]
                               _ [Occ=Dead]
                               v_s7Sg [Occ=Once] ->
              v_s7Sg;
        };

GHC.Base.$p1Alternative
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     GHC.Base.Applicative f
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>] =
    [] \r [v_s7Sh]
        case v_s7Sh of {
          GHC.Base.C:Alternative v_s7Sj [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7Sj;
        };

GHC.Base.empty
  :: forall (f :: * -> *). GHC.Base.Alternative f => forall a. f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>] =
    [] \r [v_s7So]
        case v_s7So of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 v_s7Sr [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7Sr;
        };

GHC.Base.<|>
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f a -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>] =
    [] \r [v_s7Sv]
        case v_s7Sv of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7Sz [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7Sz;
        };

GHC.Base.some
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>] =
    [] \r [v_s7SC]
        case v_s7SC of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7SH [Occ=Once]
                                 _ [Occ=Dead] ->
              v_s7SH;
        };

GHC.Base.many
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>] =
    [] \r [v_s7SJ]
        case v_s7SJ of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7SP [Occ=Once] ->
              v_s7SP;
        };

GHC.Base.eqString [Occ=LoopBreaker]
  :: GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s7SQ ds1_s7SR]
        case ds_s7SQ of {
          [] ->
              case ds1_s7SR of {
                [] -> GHC.Types.True [];
                : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
              };
          : c1_s7SW [Occ=Once!] cs1_s7SX [Occ=Once] ->
              case ds1_s7SR of {
                [] -> GHC.Types.False [];
                : c2_s7SZ [Occ=Once!] cs2_s7T0 [Occ=Once] ->
                    case c1_s7SW of {
                      GHC.Types.C# x_s7T2 [Occ=Once] ->
                          case c2_s7SZ of {
                            GHC.Types.C# y_s7T4 [Occ=Once] ->
                                case eqChar# [x_s7T2 y_s7T4] of {
                                  __DEFAULT -> GHC.Types.False [];
                                  1# -> GHC.Base.eqString cs1_s7SX cs2_s7T0;
                                };
                          };
                    };
              };
        };

GHC.Base.when2
  :: GHC.Types.Bool
     -> GHC.Types.IO ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [p_s7T6 s_s7T7 eta_s7T8]
        case p_s7T6 of {
          GHC.Types.False -> (#,#) [eta_s7T8 GHC.Tuple.()];
          GHC.Types.True -> s_s7T7 eta_s7T8;
        };

GHC.Base.when_$swhen1 [InlPrag=INLINABLE]
  :: GHC.Types.Bool -> GHC.Types.IO () -> GHC.Types.IO ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] GHC.Base.when2 eta_B3 eta_B2 eta_B1;

GHC.Base.$fFunctorIO2
  :: forall a b.
     (a -> b)
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_s7Ta x_s7Tb s_s7Tc]
        case x_s7Tb s_s7Tc of {
          (#,#) ipv_s7Te [Occ=Once] ipv1_s7Tf [Occ=Once] ->
              let {
                sat_s7Tg [Occ=Once] :: b_a4qK
                [LclId] =
                    [f_s7Ta ipv1_s7Tf] \u [] f_s7Ta ipv1_s7Tf;
              } in  (#,#) [ipv_s7Te sat_s7Tg];
        };

GHC.Base.$fFunctorIO1
  :: forall a b.
     a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S(SL)),1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [x_s7Th eta_s7Ti eta1_s7Tj]
        case eta_s7Ti eta1_s7Tj of {
          (#,#) ipv_s7Tl [Occ=Once] _ [Occ=Dead] -> (#,#) [ipv_s7Tl x_s7Th];
        };

GHC.Base.$fFunctorIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.Types.IO
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctorIO2
                                       GHC.Base.$fFunctorIO1];

GHC.Base.$fAlternativeMaybe1 :: forall a. GHC.Base.Maybe [a]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [GHC.Types.[]];

GHC.Base.$fAlternativeMaybe_$cmany
  :: forall a. GHC.Base.Maybe a -> GHC.Base.Maybe [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s7Tn]
        let {
          many_v_s7To [Occ=LoopBreaker] :: GHC.Base.Maybe [a_a4IZ]
          [LclId] =
              [v_s7Tn many_v_s7To] \u []
                  case v_s7Tn of {
                    GHC.Base.Nothing -> GHC.Base.$fAlternativeMaybe1;
                    GHC.Base.Just x_s7Tq [Occ=Once] ->
                        case many_v_s7To of {
                          GHC.Base.Nothing -> GHC.Base.$fAlternativeMaybe1;
                          GHC.Base.Just y_s7Ts [Occ=Once] ->
                              let {
                                sat_s7Tt [Occ=Once] :: [a_a4IZ]
                                [LclId] =
                                    CCCS :! [x_s7Tq y_s7Ts];
                              } in  GHC.Base.Just [sat_s7Tt];
                        };
                  };
        } in  many_v_s7To;

GHC.Base.$fAlternativeMaybe_$csome
  :: forall a. GHC.Base.Maybe a -> GHC.Base.Maybe [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s7Tu]
        let {
          some_v_s7Tv [Occ=LoopBreaker] :: GHC.Base.Maybe [a_a4IR]
          [LclId] =
              [v_s7Tu some_v_s7Tv] \u []
                  case v_s7Tu of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_s7Tx [Occ=Once*] ->
                        case some_v_s7Tv of {
                          GHC.Base.Nothing ->
                              let {
                                sat_s7Tz [Occ=Once] :: [a_a4IR]
                                [LclId] =
                                    CCCS :! [x_s7Tx GHC.Types.[]];
                              } in  GHC.Base.Just [sat_s7Tz];
                          GHC.Base.Just ipv_s7TA [Occ=Once] ->
                              let {
                                sat_s7TB [Occ=Once] :: [a_a4IR]
                                [LclId] =
                                    CCCS :! [x_s7Tx ipv_s7TA];
                              } in  GHC.Base.Just [sat_s7TB];
                        };
                  };
        } in  some_v_s7Tv;

GHC.Base.ap_$sap [InlPrag=INLINABLE]
  :: forall a b.
     GHC.Base.Maybe (a -> b) -> GHC.Base.Maybe a -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_s7TC m2_s7TD]
        case m1_s7TC of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s7TF [Occ=Once!] ->
              case m2_s7TD of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_s7TH [Occ=Once] ->
                    let {
                      sat_s7TI [Occ=Once] :: b_a447
                      [LclId] =
                          [x_s7TF x1_s7TH] \u [] x_s7TF x1_s7TH;
                    } in  GHC.Base.Just [sat_s7TI];
              };
        };

GHC.Base.liftM5_$sliftM5 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe a4
     -> GHC.Base.Maybe a5
     -> GHC.Base.Maybe r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><S,1*U><L,1*U><L,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s7TJ m1_s7TK m2_s7TL m3_s7TM m4_s7TN m5_s7TO]
        case m1_s7TK of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s7TQ [Occ=Once] ->
              case m2_s7TL of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_s7TS [Occ=Once] ->
                    case m3_s7TM of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just x2_s7TU [Occ=Once] ->
                          case m4_s7TN of {
                            GHC.Base.Nothing -> GHC.Base.Nothing [];
                            GHC.Base.Just x3_s7TW [Occ=Once] ->
                                case m5_s7TO of {
                                  GHC.Base.Nothing -> GHC.Base.Nothing [];
                                  GHC.Base.Just x4_s7TY [Occ=Once] ->
                                      let {
                                        sat_s7TZ [Occ=Once] :: r_a46A
                                        [LclId] =
                                            [f_s7TJ x_s7TQ x1_s7TS x2_s7TU x3_s7TW x4_s7TY] \u []
                                                f_s7TJ x_s7TQ x1_s7TS x2_s7TU x3_s7TW x4_s7TY;
                                      } in  GHC.Base.Just [sat_s7TZ];
                                };
                          };
                    };
              };
        };

GHC.Base.liftM4_$sliftM4 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe a4
     -> GHC.Base.Maybe r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><S,1*U><L,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s7U0 m1_s7U1 m2_s7U2 m3_s7U3 m4_s7U4]
        case m1_s7U1 of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s7U6 [Occ=Once] ->
              case m2_s7U2 of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_s7U8 [Occ=Once] ->
                    case m3_s7U3 of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just x2_s7Ua [Occ=Once] ->
                          case m4_s7U4 of {
                            GHC.Base.Nothing -> GHC.Base.Nothing [];
                            GHC.Base.Just x3_s7Uc [Occ=Once] ->
                                let {
                                  sat_s7Ud [Occ=Once] :: r_a48L
                                  [LclId] =
                                      [f_s7U0 x_s7U6 x1_s7U8 x2_s7Ua x3_s7Uc] \u []
                                          f_s7U0 x_s7U6 x1_s7U8 x2_s7Ua x3_s7Uc;
                                } in  GHC.Base.Just [sat_s7Ud];
                          };
                    };
              };
        };

GHC.Base.liftM3_$sliftM3 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s7Ue m1_s7Uf m2_s7Ug m3_s7Uh]
        case m1_s7Uf of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s7Uj [Occ=Once] ->
              case m2_s7Ug of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_s7Ul [Occ=Once] ->
                    case m3_s7Uh of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just x2_s7Un [Occ=Once] ->
                          let {
                            sat_s7Uo [Occ=Once] :: r_a4az
                            [LclId] =
                                [f_s7Ue x_s7Uj x1_s7Ul x2_s7Un] \u []
                                    f_s7Ue x_s7Uj x1_s7Ul x2_s7Un;
                          } in  GHC.Base.Just [sat_s7Uo];
                    };
              };
        };

GHC.Base.liftM2_$sliftM2 [InlPrag=INLINABLE]
  :: forall a1 a2 r.
     (a1 -> a2 -> r)
     -> GHC.Base.Maybe a1 -> GHC.Base.Maybe a2 -> GHC.Base.Maybe r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s7Up m1_s7Uq m2_s7Ur]
        case m1_s7Uq of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s7Ut [Occ=Once] ->
              case m2_s7Ur of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_s7Uv [Occ=Once] ->
                    let {
                      sat_s7Uw [Occ=Once] :: r_a4c0
                      [LclId] =
                          [f_s7Up x_s7Ut x1_s7Uv] \u [] f_s7Up x_s7Ut x1_s7Uv;
                    } in  GHC.Base.Just [sat_s7Uw];
              };
        };

GHC.Base.liftM_$sliftM [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Base.Maybe a1 -> GHC.Base.Maybe r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s7Ux m1_s7Uy]
        case m1_s7Uy of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s7UA [Occ=Once] ->
              let {
                sat_s7UB [Occ=Once] :: r_a4d4
                [LclId] =
                    [f_s7Ux x_s7UA] \u [] f_s7Ux x_s7UA;
              } in  GHC.Base.Just [sat_s7UB];
        };

GHC.Base.when1 :: GHC.Base.Maybe ()
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [GHC.Tuple.()];

GHC.Base.when_$swhen [InlPrag=INLINABLE]
  :: GHC.Types.Bool -> GHC.Base.Maybe () -> GHC.Base.Maybe ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [p_s7UC s_s7UD]
        case p_s7UC of {
          GHC.Types.False -> GHC.Base.when1;
          GHC.Types.True -> s_s7UD;
        };

GHC.Base.when [InlPrag=INLINABLE]
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Types.Bool -> f () -> f ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U),A,A,A,A)><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s7UF p_s7UG s_s7UH]
        case p_s7UG of {
          GHC.Types.False -> GHC.Base.pure $dApplicative_s7UF GHC.Tuple.();
          GHC.Types.True -> s_s7UH;
        };

GHC.Base.$fApplicativeMaybe_$c<*
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s7UJ ds1_s7UK]
        case ds_s7UJ of wild_s7UL {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] ->
              case ds1_s7UK of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just _ [Occ=Dead] -> wild_s7UL;
              };
        };

GHC.Base.$tc'O3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'O"#;

GHC.Base.$tc'O2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'O3];

GHC.Base.$tcOpaque2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Opaque"#;

GHC.Base.$tcOpaque1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcOpaque2];

GHC.Base.$tcMonadPlus2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "MonadPlus"#;

GHC.Base.$tcMonadPlus1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMonadPlus2];

GHC.Base.$tcMonad2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Monad"#;

GHC.Base.$tcMonad1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMonad2];

GHC.Base.$tc'C:Monoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Monoid"#;

GHC.Base.$tc'C:Monoid2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'C:Monoid3];

GHC.Base.$tcMonoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Monoid"#;

GHC.Base.$tcMonoid2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMonoid3];

GHC.Base.$tcSemigroup2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Semigroup"#;

GHC.Base.$tcSemigroup1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcSemigroup2];

GHC.Base.$tc':|3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "':|"#;

GHC.Base.$tc':|2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc':|3];

GHC.Base.$tcNonEmpty2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty"#;

GHC.Base.$tcNonEmpty1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcNonEmpty2];

GHC.Base.$tcAlternative3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Alternative"#;

GHC.Base.$tcAlternative2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcAlternative3];

GHC.Base.$tcApplicative2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Applicative"#;

GHC.Base.$tcApplicative1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcApplicative2];

GHC.Base.$tcFunctor2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Functor"#;

GHC.Base.$tcFunctor1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcFunctor2];

GHC.Base.$tc'Just3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Just"#;

GHC.Base.$tc'Just2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'Just3];

GHC.Base.$tc'Nothing3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Nothing"#;

GHC.Base.$tc'Nothing2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'Nothing3];

GHC.Base.$tcMaybe2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Maybe"#;

GHC.Base.$tcMaybe1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMaybe2];

$krep_r7Pr :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_r7Ps :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep_r7Pr];

$krep2_r7Pt :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep1_r7Ps];

$krep3_r7Pu :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r7Pr GHC.Types.[]];

$krep4_r7Pv :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep3_r7Pu];

$krep5_r7Pw :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r7Pv $krep_r7Pr];

$krep6_r7Px :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.Base.$tcMonoid1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$* $krep6_r7Px];

GHC.Base.$tcAlternative1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep6_r7Px];

GHC.Base.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Base"#;

GHC.Base.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$trModule2];

GHC.Base.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Base.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$trModule4];

GHC.Base.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Base.$trModule3
                                     GHC.Base.$trModule1];

GHC.Base.$tcMaybe :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [625655543500963593##
                                    6391758309165051762##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMaybe1
                                    0#
                                    GHC.Types.krep$*Arr*];

GHC.Base.$tc'Nothing1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep3_r7Pu];

GHC.Base.$tc'Just1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr
                                         GHC.Base.$tc'Nothing1];

GHC.Base.$tc'Nothing :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14633289528184412192##
                                    12773126156421542470##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'Nothing2
                                    1#
                                    GHC.Base.$tc'Nothing1];

GHC.Base.$tc'Just :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5794512144280699493##
                                    9434423460978218117##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'Just2
                                    1#
                                    GHC.Base.$tc'Just1];

GHC.Base.$tcFunctor :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [211182333006544237##
                                    5556320544348084514##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcFunctor1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcApplicative :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12705055220831243597##
                                    2963353171490466073##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcApplicative1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcAlternative :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1073491102990665358##
                                    14320772755704808948##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcAlternative2
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcNonEmpty :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13207016872645468285##
                                    3455542966739695982##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcNonEmpty1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep7_r7Py :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcNonEmpty
                                              $krep3_r7Pu];

$krep8_r7Pz :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r7Pv $krep7_r7Py];

GHC.Base.$tc':|1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep8_r7Pz];

GHC.Base.$tc':| :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9440832435183810765##
                                    3053237465234607583##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc':|2
                                    1#
                                    GHC.Base.$tc':|1];

GHC.Base.$tcSemigroup :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16195352186364298277##
                                    3285685594139281062##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcSemigroup1
                                    0#
                                    GHC.Base.$tcMonoid1];

$krep9_r7PA :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcSemigroup
                                              $krep3_r7Pu];

GHC.Base.$tcMonoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13838560045895743776##
                                    1291018260833769143##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMonoid2
                                    0#
                                    GHC.Base.$tcMonoid1];

$krep10_r7PB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMonoid
                                              $krep3_r7Pu];

$krep11_r7PC :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r7Pw $krep10_r7PB];

$krep12_r7PD :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r7Pt $krep11_r7PC];

$krep13_r7PE :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep12_r7PD];

GHC.Base.$tc'C:Monoid1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep9_r7PA $krep13_r7PE];

GHC.Base.$tc'C:Monoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16099296089107510343##
                                    5895832073319104984##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'C:Monoid2
                                    1#
                                    GHC.Base.$tc'C:Monoid1];

GHC.Base.$tcMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3168880480603756299##
                                    8398240611646296094##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMonad1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcMonadPlus :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14115673251620372550##
                                    14155357326069389390##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMonadPlus1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcOpaque :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9339725405829241186##
                                    15550233501624900571##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcOpaque1
                                    0#
                                    GHC.Types.krep$*];

$krep14_r7PF :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcOpaque
                                              GHC.Types.[]];

GHC.Base.$tc'O1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep14_r7PF];

GHC.Base.$tc'O :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12551274612394834805##
                                    13000664474148134329##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'O2
                                    1#
                                    GHC.Base.$tc'O1];

GHC.Base.quotRemInt
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s7UP ds1_s7UQ]
        case ds_s7UP of {
          GHC.Types.I# x_s7US [Occ=Once] ->
              case ds1_s7UQ of {
                GHC.Types.I# y_s7UU [Occ=Once] ->
                    case quotRemInt# [x_s7US y_s7UU] of {
                      (#,#) ipv_s7UW [Occ=Once] ipv1_s7UX [Occ=Once] ->
                          let {
                            sat_s7UZ [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [ipv1_s7UX]; } in
                          let {
                            sat_s7UY [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [ipv_s7UW];
                          } in  (,) [sat_s7UY sat_s7UZ];
                    };
              };
        };

GHC.Base.modInt :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s7V0 ds1_s7V1]
        case ds_s7V0 of {
          GHC.Types.I# x_s7V3 [Occ=Once] ->
              case ds1_s7V1 of {
                GHC.Types.I# y_s7V5 [Occ=Once] ->
                    case GHC.Classes.modInt# x_s7V3 y_s7V5 of wild2_s7V6 {
                      __DEFAULT -> GHC.Types.I# [wild2_s7V6];
                    };
              };
        };

GHC.Base.divInt :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s7V7 ds1_s7V8]
        case ds_s7V7 of {
          GHC.Types.I# x_s7Va [Occ=Once] ->
              case ds1_s7V8 of {
                GHC.Types.I# y_s7Vc [Occ=Once] ->
                    case GHC.Classes.divInt# x_s7Va y_s7Vc of wild2_s7Vd {
                      __DEFAULT -> GHC.Types.I# [wild2_s7Vd];
                    };
              };
        };

GHC.Base.remInt [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s7Ve ds1_s7Vf]
        case ds_s7Ve of {
          GHC.Types.I# x_s7Vh [Occ=Once] ->
              case ds1_s7Vf of {
                GHC.Types.I# y_s7Vj [Occ=Once] ->
                    case remInt# [x_s7Vh y_s7Vj] of wild2_s7Vk {
                      __DEFAULT -> GHC.Types.I# [wild2_s7Vk];
                    };
              };
        };

GHC.Base.quotInt [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s7Vl ds1_s7Vm]
        case ds_s7Vl of {
          GHC.Types.I# x_s7Vo [Occ=Once] ->
              case ds1_s7Vm of {
                GHC.Types.I# y_s7Vq [Occ=Once] ->
                    case quotInt# [x_s7Vo y_s7Vq] of wild2_s7Vr {
                      __DEFAULT -> GHC.Types.I# [wild2_s7Vr];
                    };
              };
        };

GHC.Base.getTag [InlPrag=INLINE (sat-args=1)]
  :: forall a. a -> GHC.Prim.Int#
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [eta_B1]
        case eta_B1 of sat_s7Vs { __DEFAULT -> dataToTag# [sat_s7Vs]; };

GHC.Base.$fMonadIO1
  :: forall a b.
     GHC.Types.IO a
     -> (a -> GHC.Types.IO b)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_s7Vt k_s7Vu s_s7Vv]
        case ds_s7Vt s_s7Vv of {
          (#,#) ipv_s7Vx [Occ=Once] ipv1_s7Vy [Occ=Once] ->
              k_s7Vu ipv1_s7Vy ipv_s7Vx;
        };

GHC.Base.bindIO
  :: forall a b.
     GHC.Types.IO a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Base.$fMonadIO1 eta_B3 eta_B2 eta_B1;

GHC.Base.$fApplicativeIO2
  :: forall a b.
     GHC.Types.IO a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_s7Vz k_s7VA s_s7VB]
        case ds_s7Vz s_s7VB of {
          (#,#) ipv_s7VD [Occ=Once] _ [Occ=Dead] -> k_s7VA ipv_s7VD;
        };

GHC.Base.thenIO
  :: forall a b. GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Base.$fApplicativeIO2 eta_B3 eta_B2 eta_B1;

GHC.Base.unIO1 :: forall a. GHC.Types.IO a -> GHC.Types.IO a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s7VF] ds_s7VF;

GHC.Base.unIO
  :: forall a.
     GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.unIO1 eta_B1;

GHC.Base.$fApplicativeIO4
  :: forall a.
     a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [x_s7VG s_s7VH] (#,#) [s_s7VH x_s7VG];

GHC.Base.returnIO :: forall a. a -> GHC.Types.IO a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.$fApplicativeIO4 eta_B2 eta_B1;

GHC.Base.$fApplicativeIO3
  :: forall b a.
     GHC.Types.IO (a -> b)
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_s7VI m2_s7VJ s_s7VK]
        case m1_s7VI s_s7VK of {
          (#,#) ipv_s7VM [Occ=Once] ipv1_s7VN [Occ=Once!] ->
              case m2_s7VJ ipv_s7VM of {
                (#,#) ipv2_s7VP [Occ=Once] ipv3_s7VQ [Occ=Once] ->
                    let {
                      sat_s7VR [Occ=Once] :: b_a4Jk
                      [LclId] =
                          [ipv1_s7VN ipv3_s7VQ] \u [] ipv1_s7VN ipv3_s7VQ;
                    } in  (#,#) [ipv2_s7VP sat_s7VR];
              };
        };

GHC.Base.liftA_$sliftA1 [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Types.IO a1 -> GHC.Types.IO r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Base.$fFunctorIO2 eta_B3 eta_B2 eta_B1;

GHC.Base.ap1
  :: forall a b.
     GHC.Types.IO (a -> b)
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_s7VS m2_s7VT s_s7VU]
        case m1_s7VS s_s7VU of {
          (#,#) ipv_s7VW [Occ=Once] ipv1_s7VX [Occ=Once!] ->
              case m2_s7VT ipv_s7VW of {
                (#,#) ipv2_s7VZ [Occ=Once] ipv3_s7W0 [Occ=Once] ->
                    let {
                      sat_s7W1 [Occ=Once] :: b_a43H
                      [LclId] =
                          [ipv1_s7VX ipv3_s7W0] \u [] ipv1_s7VX ipv3_s7W0;
                    } in  (#,#) [ipv2_s7VZ sat_s7W1];
              };
        };

GHC.Base.ap_$sap1 [InlPrag=INLINABLE]
  :: forall a b.
     GHC.Types.IO (a -> b) -> GHC.Types.IO a -> GHC.Types.IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] GHC.Base.ap1 eta_B3 eta_B2 eta_B1;

GHC.Base.ap [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     m (a -> b) -> m a -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s7W2 m1_s7W3 m2_s7W4]
        let {
          sat_s7W9 [Occ=Once] :: (a_a437 -> b_a438) -> m_a436 b_a438
          [LclId] =
              [$dMonad_s7W2 m2_s7W4] \r [x1_s7W5]
                  let {
                    sat_s7W8 [Occ=Once] :: a_a437 -> m_a436 b_a438
                    [LclId] =
                        [$dMonad_s7W2 x1_s7W5] \r [x2_s7W6]
                            let {
                              sat_s7W7 [Occ=Once] :: b_a438
                              [LclId] =
                                  [x1_s7W5 x2_s7W6] \u [] x1_s7W5 x2_s7W6;
                            } in  GHC.Base.return $dMonad_s7W2 sat_s7W7;
                  } in  GHC.Base.>>= $dMonad_s7W2 m2_s7W4 sat_s7W8;
        } in  GHC.Base.>>= $dMonad_s7W2 m1_s7W3 sat_s7W9;

GHC.Base.liftM1
  :: forall a1 a2 r.
     (a1 -> a2 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_s7Wa m1_s7Wb m2_s7Wc s_s7Wd]
        case m1_s7Wb s_s7Wd of {
          (#,#) ipv_s7Wf [Occ=Once] ipv1_s7Wg [Occ=Once] ->
              case m2_s7Wc ipv_s7Wf of {
                (#,#) ipv2_s7Wi [Occ=Once] ipv3_s7Wj [Occ=Once] ->
                    let {
                      sat_s7Wk [Occ=Once] :: r_a4br
                      [LclId] =
                          [f_s7Wa ipv1_s7Wg ipv3_s7Wj] \u [] f_s7Wa ipv1_s7Wg ipv3_s7Wj;
                    } in  (#,#) [ipv2_s7Wi sat_s7Wk];
              };
        };

GHC.Base.liftM2_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 r.
     (a1 -> a2 -> r)
     -> GHC.Types.IO a1 -> GHC.Types.IO a2 -> GHC.Types.IO r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.liftM1 eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.liftM2 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s7Wl f_s7Wm m1_s7Wn m2_s7Wo]
        let {
          sat_s7Wt [Occ=Once] :: a1_a4aI -> m_a4aH r_a4aK
          [LclId] =
              [$dMonad_s7Wl f_s7Wm m2_s7Wo] \r [x1_s7Wp]
                  let {
                    sat_s7Ws [Occ=Once] :: a2_a4aJ -> m_a4aH r_a4aK
                    [LclId] =
                        [$dMonad_s7Wl f_s7Wm x1_s7Wp] \r [x2_s7Wq]
                            let {
                              sat_s7Wr [Occ=Once] :: r_a4aK
                              [LclId] =
                                  [f_s7Wm x1_s7Wp x2_s7Wq] \u [] f_s7Wm x1_s7Wp x2_s7Wq;
                            } in  GHC.Base.return $dMonad_s7Wl sat_s7Wr;
                  } in  GHC.Base.>>= $dMonad_s7Wl m2_s7Wo sat_s7Ws;
        } in  GHC.Base.>>= $dMonad_s7Wl m1_s7Wn sat_s7Wt;

$cliftA2_r7PG
  :: forall c b a.
     (a -> b -> c)
     -> GHC.Types.IO a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, c #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    sat-only [] \r [f_s7Wu m1_s7Wv m2_s7Ww s_s7Wx]
        case m1_s7Wv s_s7Wx of {
          (#,#) ipv_s7Wz [Occ=Once] ipv1_s7WA [Occ=Once] ->
              case m2_s7Ww ipv_s7Wz of {
                (#,#) ipv2_s7WC [Occ=Once] ipv3_s7WD [Occ=Once] ->
                    let {
                      sat_s7WE [Occ=Once] :: c_a4Jw
                      [LclId] =
                          [f_s7Wu ipv1_s7WA ipv3_s7WD] \u [] f_s7Wu ipv1_s7WA ipv3_s7WD;
                    } in  (#,#) [ipv2_s7WC sat_s7WE];
              };
        };

GHC.Base.$fApplicativeIO_$cliftA2 [InlPrag=INLINE (sat-args=0)]
  :: forall a b c.
     (a -> b -> c) -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        $cliftA2_r7PG eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.liftA1
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_s7WF a_s7WG b_s7WH c_s7WI eta_s7WJ]
        case a_s7WG eta_s7WJ of {
          (#,#) ipv_s7WL [Occ=Once] ipv1_s7WM [Occ=Once] ->
              case b_s7WH ipv_s7WL of {
                (#,#) ipv2_s7WO [Occ=Once] ipv3_s7WP [Occ=Once] ->
                    case c_s7WI ipv2_s7WO of {
                      (#,#) ipv4_s7WR [Occ=Once] ipv5_s7WS [Occ=Once] ->
                          let {
                            sat_s7WT [Occ=Once] :: r_a4g0
                            [LclId] =
                                [f_s7WF ipv1_s7WM ipv3_s7WP ipv5_s7WS] \u []
                                    f_s7WF ipv1_s7WM ipv3_s7WP ipv5_s7WS;
                          } in  (#,#) [ipv4_s7WR sat_s7WT];
                    };
              };
        };

GHC.Base.liftA3_$sliftA1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.liftA1 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.$fSemigroupIO2
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Types.IO a
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s7WU eta_s7WV eta1_s7WW eta2_s7WX]
        case eta_s7WV eta2_s7WX of {
          (#,#) ipv_s7WZ [Occ=Once] ipv1_s7X0 [Occ=Once] ->
              case eta1_s7WW ipv_s7WZ of {
                (#,#) ipv2_s7X2 [Occ=Once] ipv3_s7X3 [Occ=Once] ->
                    let {
                      sat_s7X4 [Occ=Once] :: a_a4Al
                      [LclId] =
                          [$dSemigroup_s7WU ipv1_s7X0 ipv3_s7X3] \u []
                              GHC.Base.<> $dSemigroup_s7WU ipv1_s7X0 ipv3_s7X3;
                    } in  (#,#) [ipv2_s7X2 sat_s7X4];
              };
        };

GHC.Base.$w$csconcat4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Types.IO a
     -> [GHC.Types.IO a]
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><C(S),1*C1(U(U,U))><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s7X5 ww_s7X6 ww1_s7X7 w1_s7X8]
        let {
          go_s7X9 [Occ=LoopBreaker]
            :: GHC.Types.IO a_s6Fu
               -> [GHC.Types.IO a_s6Fu]
               -> GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, a_s6Fu #)
          [LclId,
           Arity=3,
           Str=<C(S),1*C1(U(U,U))><S,1*U><S,U>,
           Unf=OtherCon []] =
              sat-only [w_s7X5 go_s7X9] \r [b_s7Xa ds_s7Xb eta_s7Xc]
                  case ds_s7Xb of {
                    [] -> b_s7Xa eta_s7Xc;
                    : c_s7Xe [Occ=Once] cs_s7Xf [Occ=Once] ->
                        case b_s7Xa eta_s7Xc of {
                          (#,#) ipv_s7Xh [Occ=Once] ipv1_s7Xi [Occ=Once] ->
                              case go_s7X9 c_s7Xe cs_s7Xf ipv_s7Xh of {
                                (#,#) ipv2_s7Xk [Occ=Once] ipv3_s7Xl [Occ=Once] ->
                                    let {
                                      sat_s7Xm [Occ=Once] :: a_s6Fu
                                      [LclId] =
                                          [w_s7X5 ipv1_s7Xi ipv3_s7Xl] \u []
                                              GHC.Base.<> w_s7X5 ipv1_s7Xi ipv3_s7Xl;
                                    } in  (#,#) [ipv2_s7Xk sat_s7Xm];
                              };
                        };
                  };
        } in  go_s7X9 ww_s7X6 ww1_s7X7 w1_s7X8;

GHC.Base.$fSemigroupIO1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (GHC.Types.IO a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(C(S)S),1*U(1*C1(U(U,U)),1*U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s7Xn w1_s7Xo w2_s7Xp]
        case w1_s7Xo of {
          GHC.Base.:| ww1_s7Xr [Occ=Once] ww2_s7Xs [Occ=Once] ->
              GHC.Base.$w$csconcat4 w_s7Xn ww1_s7Xr ww2_s7Xs w2_s7Xp;
        };

GHC.Base.$fSemigroupIO [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (GHC.Types.IO a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,A)>m] =
    [] \r [$dSemigroup_s7Xt]
        let {
          sat_s7Xw [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> GHC.Types.IO a_X4J3 -> GHC.Types.IO a_X4J3
          [LclId] =
              [$dSemigroup_s7Xt] \r [eta_B1]
                  GHC.Base.$fSemigroupIO_$cstimes $dSemigroup_s7Xt eta_B1; } in
        let {
          sat_s7Xv [Occ=Once]
            :: GHC.Base.NonEmpty (GHC.Types.IO a_X4J3) -> GHC.Types.IO a_X4J3
          [LclId] =
              [$dSemigroup_s7Xt] \r [eta_B2 eta_B1]
                  GHC.Base.$fSemigroupIO1 $dSemigroup_s7Xt eta_B2 eta_B1; } in
        let {
          sat_s7Xu [Occ=Once]
            :: GHC.Types.IO a_X4J3
               -> GHC.Types.IO a_X4J3 -> GHC.Types.IO a_X4J3
          [LclId] =
              [$dSemigroup_s7Xt] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroupIO2 $dSemigroup_s7Xt eta_B3 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s7Xu sat_s7Xv sat_s7Xw];
GHC.Base.$fSemigroupIO_$cstimes [Occ=LoopBreaker]
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b.
     GHC.Real.Integral b =>
     b -> GHC.Types.IO a -> GHC.Types.IO a
[GblId, Arity=2, Str=<L,U(C(C1(U)),A,A)><L,U>, Unf=OtherCon []] =
    [] \r [$dSemigroup_s7Xx $dIntegral_s7Xy]
        let {
          sat_s7Xz [Occ=Once] :: GHC.Base.Semigroup (GHC.Types.IO a_X4J4)
          [LclId] =
              [$dSemigroup_s7Xx] \u [] GHC.Base.$fSemigroupIO $dSemigroup_s7Xx;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_s7Xy sat_s7Xz;

GHC.Base.$fMonoidIO_$cp1Monoid
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (GHC.Types.IO a)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(C(C1(U)),A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s7XA]
        let {
          sat_s7XB [Occ=Once, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_X4I6
          [LclId] =
              [$dMonoid_s7XA] \u [] GHC.Base.$p1Monoid $dMonoid_s7XA;
        } in  GHC.Base.$fSemigroupIO sat_s7XB;

$cmappend_r7PH
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Types.IO a
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dMonoid_s7XC eta_s7XD eta1_s7XE eta2_s7XF]
        case eta_s7XD eta2_s7XF of {
          (#,#) ipv_s7XH [Occ=Once] ipv1_s7XI [Occ=Once] ->
              case eta1_s7XE ipv_s7XH of {
                (#,#) ipv2_s7XK [Occ=Once] ipv3_s7XL [Occ=Once] ->
                    let {
                      sat_s7XN [Occ=Once] :: a_X4I8
                      [LclId] =
                          [$dMonoid_s7XC ipv1_s7XI ipv3_s7XL] \u []
                              case GHC.Base.$p1Monoid $dMonoid_s7XC of sat_s7XM {
                                __DEFAULT -> GHC.Base.<> sat_s7XM ipv1_s7XI ipv3_s7XL;
                              };
                    } in  (#,#) [ipv2_s7XK sat_s7XN];
              };
        };

GHC.Base.$fMonoidIO_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Types.IO a -> GHC.Types.IO a -> GHC.Types.IO a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        $cmappend_r7PH eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.$fAlternativeIO1
  :: forall a.
     GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [s_s7XO] (#,#) [s_s7XO GHC.Types.[]];

GHC.Base.$fAlternativeIO2
  :: forall a.
     GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a] #)
[GblId, Arity=2, Str=<C(S(SL)),C(U(U,U))><S,U>, Unf=OtherCon []] =
    [] \r [v_s7XP eta_s7XQ]
        let {
          some_v_s7XR [Occ=LoopBreaker]
            :: GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a_a4HN] #)
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              [v_s7XP some_v_s7XR] \r [s_s7XS]
                  case v_s7XP s_s7XS of {
                    (#,#) ipv_s7XU [Occ=Once] ipv1_s7XV [Occ=Once] ->
                        case
                            GHC.IO.mplusIO some_v_s7XR GHC.Base.$fAlternativeIO1 ipv_s7XU
                        of
                        { (#,#) ipv2_s7XX [Occ=Once] ipv3_s7XY [Occ=Once] ->
                              let {
                                sat_s7XZ [Occ=Once] :: [a_a4HN]
                                [LclId] =
                                    CCCS :! [ipv1_s7XV ipv3_s7XY];
                              } in  (#,#) [ipv2_s7XX sat_s7XZ];
                        };
                  };
        } in  some_v_s7XR eta_s7XQ;

GHC.Base.$fAlternativeIO_$cmany
  :: forall a. GHC.Types.IO a -> GHC.Types.IO [a]
[GblId, Arity=1, Str=<L,C(U(U,U))>, Unf=OtherCon []] =
    [] \r [v_s7Y0]
        let {
          many_v_s7Y1 [Occ=LoopBreaker] :: GHC.Types.IO [a_a4HV]
          [LclId] =
              [v_s7Y0 many_v_s7Y1] \u []
                  let {
                    sat_s7Ya [Occ=Once] :: GHC.Types.IO [a_a4HV]
                    [LclId] =
                        [v_s7Y0 many_v_s7Y1] \r [s_s7Y2]
                            case v_s7Y0 s_s7Y2 of {
                              (#,#) ipv_s7Y4 [Occ=Once] ipv1_s7Y5 [Occ=Once] ->
                                  case many_v_s7Y1 ipv_s7Y4 of {
                                    (#,#) ipv2_s7Y7 [Occ=Once] ipv3_s7Y8 [Occ=Once] ->
                                        let {
                                          sat_s7Y9 [Occ=Once] :: [a_a4HV]
                                          [LclId] =
                                              CCCS :! [ipv1_s7Y5 ipv3_s7Y8];
                                        } in  (#,#) [ipv2_s7Y7 sat_s7Y9];
                                  };
                            };
                  } in  GHC.IO.mplusIO sat_s7Ya GHC.Base.$fAlternativeIO1;
        } in  many_v_s7Y1;

GHC.Base.liftM9
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Types.IO a5
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_s7Yb m1_s7Yc m2_s7Yd m3_s7Ye m4_s7Yf m5_s7Yg s_s7Yh]
        case m1_s7Yc s_s7Yh of {
          (#,#) ipv_s7Yj [Occ=Once] ipv1_s7Yk [Occ=Once] ->
              case m2_s7Yd ipv_s7Yj of {
                (#,#) ipv2_s7Ym [Occ=Once] ipv3_s7Yn [Occ=Once] ->
                    case m3_s7Ye ipv2_s7Ym of {
                      (#,#) ipv4_s7Yp [Occ=Once] ipv5_s7Yq [Occ=Once] ->
                          case m4_s7Yf ipv4_s7Yp of {
                            (#,#) ipv6_s7Ys [Occ=Once] ipv7_s7Yt [Occ=Once] ->
                                case m5_s7Yg ipv6_s7Ys of {
                                  (#,#) ipv8_s7Yv [Occ=Once] ipv9_s7Yw [Occ=Once] ->
                                      let {
                                        sat_s7Yx [Occ=Once] :: r_a45A
                                        [LclId] =
                                            [f_s7Yb
                                             ipv1_s7Yk
                                             ipv3_s7Yn
                                             ipv5_s7Yq
                                             ipv7_s7Yt
                                             ipv9_s7Yw] \u []
                                                f_s7Yb
                                                    ipv1_s7Yk
                                                    ipv3_s7Yn
                                                    ipv5_s7Yq
                                                    ipv7_s7Yt
                                                    ipv9_s7Yw;
                                      } in  (#,#) [ipv8_s7Yv sat_s7Yx];
                                };
                          };
                    };
              };
        };

GHC.Base.liftM5_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Types.IO a5
     -> GHC.Types.IO r
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.liftM9 eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.liftM5 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 a4 a5 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s7Yy f_s7Yz m1_s7YA m2_s7YB m3_s7YC m4_s7YD m5_s7YE]
        let {
          sat_s7YP [Occ=Once] :: a1_a44e -> m_a44d r_a44j
          [LclId] =
              [$dMonad_s7Yy f_s7Yz m2_s7YB m3_s7YC m4_s7YD m5_s7YE] \r [x1_s7YF]
                  let {
                    sat_s7YO [Occ=Once] :: a2_a44f -> m_a44d r_a44j
                    [LclId] =
                        [$dMonad_s7Yy f_s7Yz m3_s7YC m4_s7YD m5_s7YE x1_s7YF] \r [x2_s7YG]
                            let {
                              sat_s7YN [Occ=Once] :: a3_a44g -> m_a44d r_a44j
                              [LclId] =
                                  [$dMonad_s7Yy f_s7Yz m4_s7YD m5_s7YE x1_s7YF x2_s7YG] \r [x3_s7YH]
                                      let {
                                        sat_s7YM [Occ=Once] :: a4_a44h -> m_a44d r_a44j
                                        [LclId] =
                                            [$dMonad_s7Yy
                                             f_s7Yz
                                             m5_s7YE
                                             x1_s7YF
                                             x2_s7YG
                                             x3_s7YH] \r [x4_s7YI]
                                                let {
                                                  sat_s7YL [Occ=Once] :: a5_a44i -> m_a44d r_a44j
                                                  [LclId] =
                                                      [$dMonad_s7Yy
                                                       f_s7Yz
                                                       x1_s7YF
                                                       x2_s7YG
                                                       x3_s7YH
                                                       x4_s7YI] \r [x5_s7YJ]
                                                          let {
                                                            sat_s7YK [Occ=Once] :: r_a44j
                                                            [LclId] =
                                                                [f_s7Yz
                                                                 x1_s7YF
                                                                 x2_s7YG
                                                                 x3_s7YH
                                                                 x4_s7YI
                                                                 x5_s7YJ] \u []
                                                                    f_s7Yz
                                                                        x1_s7YF
                                                                        x2_s7YG
                                                                        x3_s7YH
                                                                        x4_s7YI
                                                                        x5_s7YJ;
                                                          } in 
                                                            GHC.Base.return $dMonad_s7Yy sat_s7YK;
                                                } in  GHC.Base.>>= $dMonad_s7Yy m5_s7YE sat_s7YL;
                                      } in  GHC.Base.>>= $dMonad_s7Yy m4_s7YD sat_s7YM;
                            } in  GHC.Base.>>= $dMonad_s7Yy m3_s7YC sat_s7YN;
                  } in  GHC.Base.>>= $dMonad_s7Yy m2_s7YB sat_s7YO;
        } in  GHC.Base.>>= $dMonad_s7Yy m1_s7YA sat_s7YP;

GHC.Base.liftM8
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_s7YQ m1_s7YR m2_s7YS m3_s7YT m4_s7YU s_s7YV]
        case m1_s7YR s_s7YV of {
          (#,#) ipv_s7YX [Occ=Once] ipv1_s7YY [Occ=Once] ->
              case m2_s7YS ipv_s7YX of {
                (#,#) ipv2_s7Z0 [Occ=Once] ipv3_s7Z1 [Occ=Once] ->
                    case m3_s7YT ipv2_s7Z0 of {
                      (#,#) ipv4_s7Z3 [Occ=Once] ipv5_s7Z4 [Occ=Once] ->
                          case m4_s7YU ipv4_s7Z3 of {
                            (#,#) ipv6_s7Z6 [Occ=Once] ipv7_s7Z7 [Occ=Once] ->
                                let {
                                  sat_s7Z8 [Occ=Once] :: r_a47U
                                  [LclId] =
                                      [f_s7YQ ipv1_s7YY ipv3_s7Z1 ipv5_s7Z4 ipv7_s7Z7] \u []
                                          f_s7YQ ipv1_s7YY ipv3_s7Z1 ipv5_s7Z4 ipv7_s7Z7;
                                } in  (#,#) [ipv6_s7Z6 sat_s7Z8];
                          };
                    };
              };
        };

GHC.Base.liftM4_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Types.IO r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.liftM8 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.liftM4 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 a4 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(C1(U))))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s7Z9 f_s7Za m1_s7Zb m2_s7Zc m3_s7Zd m4_s7Ze]
        let {
          sat_s7Zn [Occ=Once] :: a1_a46L -> m_a46K r_a46P
          [LclId] =
              [$dMonad_s7Z9 f_s7Za m2_s7Zc m3_s7Zd m4_s7Ze] \r [x1_s7Zf]
                  let {
                    sat_s7Zm [Occ=Once] :: a2_a46M -> m_a46K r_a46P
                    [LclId] =
                        [$dMonad_s7Z9 f_s7Za m3_s7Zd m4_s7Ze x1_s7Zf] \r [x2_s7Zg]
                            let {
                              sat_s7Zl [Occ=Once] :: a3_a46N -> m_a46K r_a46P
                              [LclId] =
                                  [$dMonad_s7Z9 f_s7Za m4_s7Ze x1_s7Zf x2_s7Zg] \r [x3_s7Zh]
                                      let {
                                        sat_s7Zk [Occ=Once] :: a4_a46O -> m_a46K r_a46P
                                        [LclId] =
                                            [$dMonad_s7Z9
                                             f_s7Za
                                             x1_s7Zf
                                             x2_s7Zg
                                             x3_s7Zh] \r [x4_s7Zi]
                                                let {
                                                  sat_s7Zj [Occ=Once] :: r_a46P
                                                  [LclId] =
                                                      [f_s7Za x1_s7Zf x2_s7Zg x3_s7Zh x4_s7Zi] \u []
                                                          f_s7Za x1_s7Zf x2_s7Zg x3_s7Zh x4_s7Zi;
                                                } in  GHC.Base.return $dMonad_s7Z9 sat_s7Zj;
                                      } in  GHC.Base.>>= $dMonad_s7Z9 m4_s7Ze sat_s7Zk;
                            } in  GHC.Base.>>= $dMonad_s7Z9 m3_s7Zd sat_s7Zl;
                  } in  GHC.Base.>>= $dMonad_s7Z9 m2_s7Zc sat_s7Zm;
        } in  GHC.Base.>>= $dMonad_s7Z9 m1_s7Zb sat_s7Zn;

GHC.Base.liftM3_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.liftA1 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.liftM3 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(U)))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s7Zo f_s7Zp m1_s7Zq m2_s7Zr m3_s7Zs]
        let {
          sat_s7Zz [Occ=Once] :: a1_a48V -> m_a48U r_a48Y
          [LclId] =
              [$dMonad_s7Zo f_s7Zp m2_s7Zr m3_s7Zs] \r [x1_s7Zt]
                  let {
                    sat_s7Zy [Occ=Once] :: a2_a48W -> m_a48U r_a48Y
                    [LclId] =
                        [$dMonad_s7Zo f_s7Zp m3_s7Zs x1_s7Zt] \r [x2_s7Zu]
                            let {
                              sat_s7Zx [Occ=Once] :: a3_a48X -> m_a48U r_a48Y
                              [LclId] =
                                  [$dMonad_s7Zo f_s7Zp x1_s7Zt x2_s7Zu] \r [x3_s7Zv]
                                      let {
                                        sat_s7Zw [Occ=Once] :: r_a48Y
                                        [LclId] =
                                            [f_s7Zp x1_s7Zt x2_s7Zu x3_s7Zv] \u []
                                                f_s7Zp x1_s7Zt x2_s7Zu x3_s7Zv;
                                      } in  GHC.Base.return $dMonad_s7Zo sat_s7Zw;
                            } in  GHC.Base.>>= $dMonad_s7Zo m3_s7Zs sat_s7Zx;
                  } in  GHC.Base.>>= $dMonad_s7Zo m2_s7Zr sat_s7Zy;
        } in  GHC.Base.>>= $dMonad_s7Zo m1_s7Zq sat_s7Zz;

GHC.Base.liftM_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Types.IO a1 -> GHC.Types.IO r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Base.$fFunctorIO2 eta_B3 eta_B2 eta_B1;

GHC.Base.liftM [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 r.
     GHC.Base.Monad m =>
     (a1 -> r) -> m a1 -> m r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s7ZA f_s7ZB m1_s7ZC]
        let {
          sat_s7ZF [Occ=Once] :: a1_a4c8 -> m_a4c7 r_a4c9
          [LclId] =
              [$dMonad_s7ZA f_s7ZB] \r [x1_s7ZD]
                  let {
                    sat_s7ZE [Occ=Once] :: r_a4c9
                    [LclId] =
                        [f_s7ZB x1_s7ZD] \u [] f_s7ZB x1_s7ZD;
                  } in  GHC.Base.return $dMonad_s7ZA sat_s7ZE;
        } in  GHC.Base.>>= $dMonad_s7ZA m1_s7ZC sat_s7ZF;

GHC.Base.$! :: forall a (b :: TYPE r). (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s7ZG x_s7ZH]
        case x_s7ZH of vx_s7ZI { __DEFAULT -> f_s7ZG vx_s7ZI; };

GHC.Base.$ [InlPrag=INLINE (sat-args=2)]
  :: forall a (b :: TYPE r). (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s7ZJ x_s7ZK] f_s7ZJ x_s7ZK;

GHC.Base.flip :: forall a b c. (a -> b -> c) -> b -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s7ZL x_s7ZM y_s7ZN] f_s7ZL y_s7ZN x_s7ZM;

GHC.Base.$fMonad(->)_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall r a b. (r -> a) -> (r -> b) -> r -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_s7ZO eta1_s7ZP r1_s7ZQ] eta1_s7ZP r1_s7ZQ;

GHC.Base.$fApplicative(->)_$c<*
  :: forall a1 a2 b. (a1 -> a2) -> (a1 -> b) -> a1 -> a2
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s7ZR g_s7ZS x_s7ZT] f_s7ZR x_s7ZT;

GHC.Base.$fMonad(,)_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,A)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s7ZU eta_s7ZV eta1_s7ZW]
        case eta_s7ZV of {
          (,) u_s7ZY [Occ=Once] _ [Occ=Dead] ->
              case eta1_s7ZW of {
                (,) v_s801 [Occ=Once] b1_s802 [Occ=Once] ->
                    let {
                      sat_s804 [Occ=Once] :: a_a4ul
                      [LclId] =
                          [$dMonoid_s7ZU u_s7ZY v_s801] \u []
                              case GHC.Base.$p1Monoid $dMonoid_s7ZU of sat_s803 {
                                __DEFAULT -> GHC.Base.<> sat_s803 u_s7ZY v_s801;
                              };
                    } in  (,) [sat_s804 b1_s802];
              };
        };

GHC.Base.$fApplicative(,)_$c<*
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a, b) -> (a, a1)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><S,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s805 eta_s806 eta1_s807]
        case eta_s806 of {
          (,) u_s809 [Occ=Once] x_s80a [Occ=Once] ->
              case eta1_s807 of {
                (,) v_s80c [Occ=Once] _ [Occ=Dead] ->
                    let {
                      sat_s80f [Occ=Once] :: a_a4vv
                      [LclId] =
                          [$dMonoid_s805 u_s809 v_s80c] \u []
                              case GHC.Base.$p1Monoid $dMonoid_s805 of sat_s80e {
                                __DEFAULT -> GHC.Base.<> sat_s80e u_s809 v_s80c;
                              };
                    } in  (,) [sat_s80f x_s80a];
              };
        };

GHC.Base.$fFunctor(,)_$c<$
  :: forall a1 a2 b. a2 -> (a1, b) -> (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [x_s80g ds_s80h]
        case ds_s80h of {
          (,) x1_s80j [Occ=Once] _ [Occ=Dead] -> (,) [x1_s80j x_s80g];
        };

GHC.Base.$fFunctorMaybe_$c<$
  :: forall a b. a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_s80l ds_s80m]
        case ds_s80m of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Base.Just [x_s80l];
        };

GHC.Base.$dm<$
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     forall a b. a -> f b -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s80p eta_s80q]
        let {
          sat_s80s [Occ=Once] :: b_a4il -> a_a4ik
          [LclId] =
              [eta_s80q] \r [ds_s80r] eta_s80q;
        } in  GHC.Base.fmap $dFunctor_s80p sat_s80s;

GHC.Base.$fMonoid(->)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall b a. GHC.Base.Monoid b => (a -> b) -> (a -> b) -> a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s80t eta_s80u eta1_s80v eta2_s80w]
        let {
          sat_s80z [Occ=Once] :: b_a4zA
          [LclId] =
              [eta1_s80v eta2_s80w] \u [] eta1_s80v eta2_s80w; } in
        let {
          sat_s80y [Occ=Once] :: b_a4zA
          [LclId] =
              [eta_s80u eta2_s80w] \u [] eta_s80u eta2_s80w;
        } in 
          case GHC.Base.$p1Monoid $dMonoid_s80t of sat_s80x {
            __DEFAULT -> GHC.Base.<> sat_s80x sat_s80y sat_s80z;
          };

GHC.Base.$fMonoid(,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     (a, b) -> (a, b) -> (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s80A $dMonoid1_s80B eta_s80C eta1_s80D]
        case eta_s80C of {
          (,) a1_s80F [Occ=Once] b1_s80G [Occ=Once] ->
              case eta1_s80D of {
                (,) a'_s80I [Occ=Once] b'_s80J [Occ=Once] ->
                    let {
                      sat_s80N [Occ=Once] :: b_a4yQ
                      [LclId] =
                          [$dMonoid1_s80B b1_s80G b'_s80J] \u []
                              case GHC.Base.$p1Monoid $dMonoid1_s80B of sat_s80M {
                                __DEFAULT -> GHC.Base.<> sat_s80M b1_s80G b'_s80J;
                              }; } in
                    let {
                      sat_s80L [Occ=Once] :: a_a4yP
                      [LclId] =
                          [$dMonoid_s80A a1_s80F a'_s80I] \u []
                              case GHC.Base.$p1Monoid $dMonoid_s80A of sat_s80K {
                                __DEFAULT -> GHC.Base.<> sat_s80K a1_s80F a'_s80I;
                              };
                    } in  (,) [sat_s80L sat_s80N];
              };
        };

GHC.Base.$fSemigroupOrdering_go [Occ=LoopBreaker]
  :: GHC.Types.Ordering -> [GHC.Types.Ordering] -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s80O ds_s80P]
        case ds_s80P of {
          [] -> b_s80O;
          : c_s80R [Occ=Once] cs_s80S [Occ=Once] ->
              case b_s80O of {
                GHC.Types.LT -> GHC.Types.LT [];
                GHC.Types.EQ -> GHC.Base.$fSemigroupOrdering_go c_s80R cs_s80S;
                GHC.Types.GT -> GHC.Types.GT [];
              };
        };

GHC.Base.$fSemigroupOrdering_$csconcat
  :: GHC.Base.NonEmpty GHC.Types.Ordering -> GHC.Types.Ordering
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s80U]
        case ds_s80U of {
          GHC.Base.:| a_s80W [Occ=Once] as_s80X [Occ=Once] ->
              GHC.Base.$fSemigroupOrdering_go a_s80W as_s80X;
        };

GHC.Base.. [InlPrag=INLINE (sat-args=2)]
  :: forall b c a. (b -> c) -> (a -> b) -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s80Y g_s80Z x_s810]
        let {
          sat_s811 [Occ=Once] :: b_a41v
          [LclId] =
              [g_s80Z x_s810] \u [] g_s80Z x_s810;
        } in  f_s80Y sat_s811;

GHC.Base.mapFB [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall elt lst a.
     (elt -> lst -> lst) -> (a -> elt) -> a -> lst -> lst
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c_s812 f_s813 x_s814 ys_s815]
        let {
          sat_s816 [Occ=Once] :: elt_a42v
          [LclId] =
              [f_s813 x_s814] \u [] f_s813 x_s814;
        } in  c_s812 sat_s816 ys_s815;

GHC.Base.$fFunctor(->)_$c<$
  :: forall r a b. a -> (r -> b) -> r -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s817 eta_s818 eta1_s819] x_s817;

GHC.Base.$fFunctor(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall r. GHC.Base.Functor ((->) r)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base..
                                       GHC.Base.$fFunctor(->)_$c<$];

GHC.Base.const :: forall a b. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s81a ds_s81b] x_s81a;

GHC.Base.asTypeOf :: forall a. a -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.const eta_B2 eta_B1;

GHC.Base.$dm<*
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s81c]
        GHC.Base.liftA2 $dApplicative_s81c GHC.Base.const;

GHC.Base.$fApplicativeIO1
  :: forall a b.
     GHC.Types.IO a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_s81d m2_s81e s_s81f]
        case m1_s81d s_s81f of {
          (#,#) ipv_s81h [Occ=Once] ipv1_s81i [Occ=Once] ->
              case m2_s81e ipv_s81h of {
                (#,#) ipv2_s81k [Occ=Once] _ [Occ=Dead] ->
                    (#,#) [ipv2_s81k ipv1_s81i];
              };
        };

GHC.Base.$fApplicativeIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctorIO
                                           GHC.Base.$fApplicativeIO4
                                           GHC.Base.$fApplicativeIO3
                                           GHC.Base.$fApplicativeIO_$cliftA2
                                           GHC.Base.$fApplicativeIO2
                                           GHC.Base.$fApplicativeIO1];

GHC.Base.breakpointCond :: forall a. GHC.Types.Bool -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s81m r_s81n] r_s81n;

GHC.Base.breakpoint :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [r_s81o] r_s81o;

GHC.Base.assert :: forall a. GHC.Types.Bool -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.breakpointCond eta_B2 eta_B1;

GHC.Base.id :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.breakpoint eta_B1;

GHC.Base.join
  :: forall (m :: * -> *) a. GHC.Base.Monad m => m (m a) -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s81p x_s81q]
        GHC.Base.>>= $dMonad_s81p x_s81q GHC.Base.breakpoint;

GHC.Base.$dm<*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f (a -> b) -> f a -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s81r]
        GHC.Base.liftA2 $dApplicative_s81r GHC.Base.breakpoint;

GHC.Base.$dm*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(1*U(A,1*C1(C1(U))),A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s81s eta_s81t eta1_s81u]
        let {
          sat_s81w [Occ=Once] :: f_a37E (b_a4j2 -> b_a4j2)
          [LclId] =
              [$dApplicative_s81s eta_s81t] \u []
                  case GHC.Base.$p1Applicative $dApplicative_s81s of sat_s81v {
                    __DEFAULT -> GHC.Base.<$ sat_s81v GHC.Base.breakpoint eta_s81t;
                  };
        } in  GHC.Base.<*> $dApplicative_s81s sat_s81w eta1_s81u;

GHC.Base.$fApplicative(->)_$c*>
  :: forall a1 a2 b. (a1 -> a2) -> (a1 -> b) -> a1 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [a2_s81x a3_s81y x_s81z] a3_s81y x_s81z;

GHC.Base.maxInt :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [9223372036854775807#];

GHC.Base.minInt :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [-9223372036854775808#];

GHC.Base.ord :: GHC.Types.Char -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s81A]
        case ds_s81A of {
          GHC.Types.C# c#_s81C [Occ=Once] ->
              case ord# [c#_s81C] of sat_s81D {
                __DEFAULT -> GHC.Types.I# [sat_s81D];
              };
        };

GHC.Base.unsafeChr :: GHC.Types.Int -> GHC.Types.Char
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s81E]
        case ds_s81E of {
          GHC.Types.I# i#_s81G [Occ=Once] ->
              case chr# [i#_s81G] of sat_s81H {
                __DEFAULT -> GHC.Types.C# [sat_s81H];
              };
        };

GHC.Base.otherwise :: GHC.Types.Bool
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.True! [];

GHC.Base.until
  :: forall a. (a -> GHC.Types.Bool) -> (a -> a) -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [p_s81I f_s81J eta_s81K]
        let-no-escape {
          go_s81L [Occ=LoopBreakerT[1]] :: a_a41W -> a_a41W
          [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [p_s81I f_s81J go_s81L] \r [x_s81M]
                  case p_s81I x_s81M of {
                    GHC.Types.False ->
                        let {
                          sat_s81O [Occ=Once] :: a_a41W
                          [LclId] =
                              [f_s81J x_s81M] \u [] f_s81J x_s81M;
                        } in  go_s81L sat_s81O;
                    GHC.Types.True -> x_s81M;
                  };
        } in  go_s81L eta_s81K;

GHC.Base.divModInt#
  :: GHC.Prim.Int#
     -> GHC.Prim.Int# -> (# GHC.Prim.Int#, GHC.Prim.Int# #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [x#_s81P y#_s81Q]
        case ># [x#_s81P 0#] of {
          __DEFAULT ->
              case <# [x#_s81P 0#] of {
                __DEFAULT -> quotRemInt# [x#_s81P y#_s81Q];
                1# ->
                    case ># [y#_s81Q 0#] of {
                      __DEFAULT -> quotRemInt# [x#_s81P y#_s81Q];
                      1# ->
                          case +# [x#_s81P 1#] of sat_s81U {
                            __DEFAULT ->
                                case quotRemInt# [sat_s81U y#_s81Q] of {
                                  (#,#) ipv_s81W [Occ=Once] ipv1_s81X [Occ=Once] ->
                                      case +# [ipv1_s81X y#_s81Q] of sat_s81Z {
                                        __DEFAULT ->
                                            case -# [sat_s81Z 1#] of sat_s820 {
                                              __DEFAULT ->
                                                  case -# [ipv_s81W 1#] of sat_s81Y {
                                                    __DEFAULT -> (#,#) [sat_s81Y sat_s820];
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
          1# ->
              case <# [y#_s81Q 0#] of {
                __DEFAULT ->
                    case <# [x#_s81P 0#] of {
                      __DEFAULT -> quotRemInt# [x#_s81P y#_s81Q];
                      1# ->
                          case ># [y#_s81Q 0#] of {
                            __DEFAULT -> quotRemInt# [x#_s81P y#_s81Q];
                            1# ->
                                case +# [x#_s81P 1#] of sat_s824 {
                                  __DEFAULT ->
                                      case quotRemInt# [sat_s824 y#_s81Q] of {
                                        (#,#) ipv_s826 [Occ=Once] ipv1_s827 [Occ=Once] ->
                                            case +# [ipv1_s827 y#_s81Q] of sat_s829 {
                                              __DEFAULT ->
                                                  case -# [sat_s829 1#] of sat_s82a {
                                                    __DEFAULT ->
                                                        case -# [ipv_s826 1#] of sat_s828 {
                                                          __DEFAULT -> (#,#) [sat_s828 sat_s82a];
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
                1# ->
                    case -# [x#_s81P 1#] of sat_s82b {
                      __DEFAULT ->
                          case quotRemInt# [sat_s82b y#_s81Q] of {
                            (#,#) ipv_s82d [Occ=Once] ipv1_s82e [Occ=Once] ->
                                case +# [ipv1_s82e y#_s81Q] of sat_s82g {
                                  __DEFAULT ->
                                      case +# [sat_s82g 1#] of sat_s82h {
                                        __DEFAULT ->
                                            case -# [ipv_s82d 1#] of sat_s82f {
                                              __DEFAULT -> (#,#) [sat_s82f sat_s82h];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Base.divModInt [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s82i w1_s82j]
        case w_s82i of {
          GHC.Types.I# ww1_s82l ->
              case w1_s82j of {
                GHC.Types.I# ww3_s82n ->
                    case ># [ww1_s82l 0#] of {
                      __DEFAULT ->
                          case <# [ww1_s82l 0#] of {
                            __DEFAULT ->
                                case quotRemInt# [ww1_s82l ww3_s82n] of {
                                  (#,#) ipv_s82r [Occ=Once] ipv1_s82s [Occ=Once] ->
                                      let {
                                        sat_s82u [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv1_s82s]; } in
                                      let {
                                        sat_s82t [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv_s82r];
                                      } in  (,) [sat_s82t sat_s82u];
                                };
                            1# ->
                                case ># [ww3_s82n 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww1_s82l ww3_s82n] of {
                                        (#,#) ipv_s82x [Occ=Once] ipv1_s82y [Occ=Once] ->
                                            let {
                                              sat_s82A [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s82y]; } in
                                            let {
                                              sat_s82z [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_s82x];
                                            } in  (,) [sat_s82z sat_s82A];
                                      };
                                  1# ->
                                      case +# [ww1_s82l 1#] of sat_s82B {
                                        __DEFAULT ->
                                            case quotRemInt# [sat_s82B ww3_s82n] of {
                                              (#,#) ipv_s82D [Occ=Once] ipv1_s82E [Occ=Once] ->
                                                  case +# [ipv1_s82E ww3_s82n] of sat_s82H {
                                                    __DEFAULT ->
                                                        case -# [sat_s82H 1#] of sat_s82I {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_s82J [Occ=Once] :: GHC.Types.Int
                                                                [LclId] =
                                                                    CCCS GHC.Types.I#! [sat_s82I];
                                                              } in 
                                                                case -# [ipv_s82D 1#] of sat_s82F {
                                                                  __DEFAULT ->
                                                                      let {
                                                                        sat_s82G [Occ=Once]
                                                                          :: GHC.Types.Int
                                                                        [LclId] =
                                                                            CCCS GHC.Types.I#! [sat_s82F];
                                                                      } in  (,) [sat_s82G sat_s82J];
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                      1# ->
                          case <# [ww3_s82n 0#] of {
                            __DEFAULT ->
                                case <# [ww1_s82l 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww1_s82l ww3_s82n] of {
                                        (#,#) ipv_s82N [Occ=Once] ipv1_s82O [Occ=Once] ->
                                            let {
                                              sat_s82Q [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s82O]; } in
                                            let {
                                              sat_s82P [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_s82N];
                                            } in  (,) [sat_s82P sat_s82Q];
                                      };
                                  1# ->
                                      case ># [ww3_s82n 0#] of {
                                        __DEFAULT ->
                                            case quotRemInt# [ww1_s82l ww3_s82n] of {
                                              (#,#) ipv_s82T [Occ=Once] ipv1_s82U [Occ=Once] ->
                                                  let {
                                                    sat_s82W [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv1_s82U]; } in
                                                  let {
                                                    sat_s82V [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv_s82T];
                                                  } in  (,) [sat_s82V sat_s82W];
                                            };
                                        1# ->
                                            case +# [ww1_s82l 1#] of sat_s82X {
                                              __DEFAULT ->
                                                  case quotRemInt# [sat_s82X ww3_s82n] of {
                                                    (#,#) ipv_s82Z [Occ=Once]
                                                          ipv1_s830 [Occ=Once] ->
                                                        case +# [ipv1_s830 ww3_s82n] of sat_s833 {
                                                          __DEFAULT ->
                                                              case -# [sat_s833 1#] of sat_s834 {
                                                                __DEFAULT ->
                                                                    let {
                                                                      sat_s835 [Occ=Once]
                                                                        :: GHC.Types.Int
                                                                      [LclId] =
                                                                          CCCS GHC.Types.I#! [sat_s834];
                                                                    } in 
                                                                      case
                                                                          -# [ipv_s82Z 1#]
                                                                      of
                                                                      sat_s831
                                                                      { __DEFAULT ->
                                                                            let {
                                                                              sat_s832 [Occ=Once]
                                                                                :: GHC.Types.Int
                                                                              [LclId] =
                                                                                  CCCS GHC.Types.I#! [sat_s831];
                                                                            } in 
                                                                              (,) [sat_s832
                                                                                   sat_s835];
                                                                      };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            1# ->
                                case -# [ww1_s82l 1#] of sat_s836 {
                                  __DEFAULT ->
                                      case quotRemInt# [sat_s836 ww3_s82n] of {
                                        (#,#) ipv_s838 [Occ=Once] ipv1_s839 [Occ=Once] ->
                                            case +# [ipv1_s839 ww3_s82n] of sat_s83c {
                                              __DEFAULT ->
                                                  case +# [sat_s83c 1#] of sat_s83d {
                                                    __DEFAULT ->
                                                        let {
                                                          sat_s83e [Occ=Once] :: GHC.Types.Int
                                                          [LclId] =
                                                              CCCS GHC.Types.I#! [sat_s83d];
                                                        } in 
                                                          case -# [ipv_s838 1#] of sat_s83a {
                                                            __DEFAULT ->
                                                                let {
                                                                  sat_s83b [Occ=Once]
                                                                    :: GHC.Types.Int
                                                                  [LclId] =
                                                                      CCCS GHC.Types.I#! [sat_s83a];
                                                                } in  (,) [sat_s83b sat_s83e];
                                                          };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Base.shiftL#
  :: GHC.Prim.Word# -> GHC.Prim.Int# -> GHC.Prim.Word#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_s83f b_s83g]
        case >=# [b_s83g 64#] of {
          __DEFAULT -> uncheckedShiftL# [a_s83f b_s83g];
          1# -> 0##;
        };

GHC.Base.shiftRL#
  :: GHC.Prim.Word# -> GHC.Prim.Int# -> GHC.Prim.Word#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_s83i b_s83j]
        case >=# [b_s83j 64#] of {
          __DEFAULT -> uncheckedShiftRL# [a_s83i b_s83j];
          1# -> 0##;
        };

GHC.Base.iShiftL#
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_s83l b_s83m]
        case >=# [b_s83m 64#] of {
          __DEFAULT -> uncheckedIShiftL# [a_s83l b_s83m];
          1# -> 0#;
        };

GHC.Base.iShiftRA#
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [a_s83o b_s83p]
        case >=# [b_s83p 64#] of {
          __DEFAULT -> uncheckedIShiftRA# [a_s83o b_s83p];
          1# ->
              case <# [a_s83o 0#] of {
                __DEFAULT -> 0#;
                1# -> -1#;
              };
        };

GHC.Base.iShiftRL#
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_s83s b_s83t]
        case >=# [b_s83t 64#] of {
          __DEFAULT -> uncheckedIShiftRL# [a_s83s b_s83t];
          1# -> 0#;
        };

GHC.Base.build [InlPrag=INLINE[1] (sat-args=1)]
  :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [g_s83v] g_s83v GHC.Types.: GHC.Types.[];

GHC.Base.$fApplicative[]_$cpure [InlPrag=INLINE (sat-args=1)]
  :: forall a. a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [x_s83w] : [x_s83w GHC.Types.[]];

GHC.Base.augment [InlPrag=INLINE[1] (sat-args=2)]
  :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [g_s83x xs_s83y] g_s83x GHC.Types.: xs_s83y;

GHC.Base.++ [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. [a] -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s83z ys_s83A]
        case ds_s83z of {
          [] -> ys_s83A;
          : x_s83C [Occ=Once] xs_s83D [Occ=Once] ->
              let {
                sat_s83E [Occ=Once] :: [a_a42r]
                [LclId] =
                    [ys_s83A xs_s83D] \u [] GHC.Base.++ xs_s83D ys_s83A;
              } in  : [x_s83C sat_s83E];
        };
GHC.Base.foldr [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_s83F z_s83G eta_s83H]
        let {
          go_s83I [Occ=LoopBreaker] :: [a_a42N] -> b_a42O
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [k_s83F z_s83G go_s83I] \r [ds_s83J]
                  case ds_s83J of {
                    [] -> z_s83G;
                    : y_s83L [Occ=Once] ys_s83M [Occ=Once] ->
                        let {
                          sat_s83N [Occ=Once] :: b_a42O
                          [LclId] =
                              [go_s83I ys_s83M] \u [] go_s83I ys_s83M;
                        } in  k_s83F y_s83L sat_s83N;
                  };
        } in  go_s83I eta_s83H;
GHC.Base.map [InlPrag=NOINLINE[0], Occ=LoopBreaker]
  :: forall a b. (a -> b) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s83O ds1_s83P]
        case ds1_s83P of {
          [] -> [] [];
          : x_s83R [Occ=Once] xs_s83S [Occ=Once] ->
              let {
                sat_s83U [Occ=Once] :: [b_a42A]
                [LclId] =
                    [ds_s83O xs_s83S] \u [] GHC.Base.map ds_s83O xs_s83S; } in
              let {
                sat_s83T [Occ=Once] :: b_a42A
                [LclId] =
                    [ds_s83O x_s83R] \u [] ds_s83O x_s83R;
              } in  : [sat_s83T sat_s83U];
        };

GHC.Base.$fSemigroupNonEmpty_$c<>
  :: forall a.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,1*U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s83V ds1_s83W]
        case ds_s83V of {
          GHC.Base.:| a1_s83Y [Occ=Once] as_s83Z [Occ=Once] ->
              let {
                sat_s849 [Occ=Once] :: [a_a4Fm]
                [LclId] =
                    [ds1_s83W as_s83Z] \u []
                        let {
                          sat_s847 [Occ=Once] :: [a_a4Fm]
                          [LclId] =
                              [ds1_s83W] \u []
                                  case ds1_s83W of {
                                    GHC.Base.:| _ [Occ=Dead] bs_s846 [Occ=Once] -> bs_s846;
                                  }; } in
                        let {
                          sat_s843 [Occ=Once] :: a_a4Fm
                          [LclId] =
                              [ds1_s83W] \u []
                                  case ds1_s83W of {
                                    GHC.Base.:| b_s841 [Occ=Once] _ [Occ=Dead] -> b_s841;
                                  }; } in
                        let {
                          sat_s848 [Occ=Once] :: [a_a4Fm]
                          [LclId] =
                              CCCS :! [sat_s843 sat_s847];
                        } in  GHC.Base.++ as_s83Z sat_s848;
              } in  GHC.Base.:| [a1_s83Y sat_s849];
        };

GHC.Base.$wpoly_go [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. a -> [a] -> [GHC.Base.NonEmpty a] -> (# a, [a] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_s84a ww1_s84b w_s84c]
        case w_s84c of {
          [] -> (#,#) [ww_s84a ww1_s84b];
          : c_s84e [Occ=Once!] cs_s84f [Occ=Once] ->
              let {
                sat_s84w [Occ=Once] :: [a_s6GZ]
                [LclId] =
                    [ww1_s84b c_s84e cs_s84f] \u []
                        let {
                          ds_s84g [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty a_s6GZ
                          [LclId] =
                              [c_s84e cs_s84f] \u []
                                  case c_s84e of {
                                    GHC.Base.:| ww3_s84i [Occ=Once] ww4_s84j [Occ=Once] ->
                                        case GHC.Base.$wpoly_go ww3_s84i ww4_s84j cs_s84f of {
                                          (#,#) ww6_s84l [Occ=Once] ww7_s84m [Occ=Once] ->
                                              GHC.Base.:| [ww6_s84l ww7_s84m];
                                        };
                                  }; } in
                        let {
                          sat_s84u [Occ=Once] :: [a_s6GZ]
                          [LclId] =
                              [ds_s84g] \u []
                                  case ds_s84g of {
                                    GHC.Base.:| _ [Occ=Dead] bs_s84t [Occ=Once] -> bs_s84t;
                                  }; } in
                        let {
                          sat_s84q [Occ=Once] :: a_s6GZ
                          [LclId] =
                              [ds_s84g] \u []
                                  case ds_s84g of {
                                    GHC.Base.:| b_s84o [Occ=Once] _ [Occ=Dead] -> b_s84o;
                                  }; } in
                        let {
                          sat_s84v [Occ=Once] :: [a_s6GZ]
                          [LclId] =
                              CCCS :! [sat_s84q sat_s84u];
                        } in  GHC.Base.++ ww1_s84b sat_s84v;
              } in  (#,#) [ww_s84a sat_s84w];
        };

GHC.Base.$fSemigroupNonEmpty1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.NonEmpty a -> [GHC.Base.NonEmpty a] -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_s84x w1_s84y]
        case w_s84x of {
          GHC.Base.:| ww1_s84A [Occ=Once] ww2_s84B [Occ=Once] ->
              case GHC.Base.$wpoly_go ww1_s84A ww2_s84B w1_s84y of {
                (#,#) ww4_s84D [Occ=Once] ww5_s84E [Occ=Once] ->
                    GHC.Base.:| [ww4_s84D ww5_s84E];
              };
        };

GHC.Base.$fSemigroupNonEmpty_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (GHC.Base.NonEmpty a) -> GHC.Base.NonEmpty a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U(U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s84F]
        case ds_s84F of {
          GHC.Base.:| a1_s84H [Occ=Once] as_s84I [Occ=Once] ->
              GHC.Base.$fSemigroupNonEmpty1 a1_s84H as_s84I;
        };

GHC.Base.$fSemigroupNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (GHC.Base.NonEmpty a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.$fSemigroupNonEmpty_$c<>
                                         GHC.Base.$fSemigroupNonEmpty_$csconcat
                                         GHC.Base.$fSemigroupNonEmpty_$cstimes];
GHC.Base.$fSemigroupNonEmpty_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_s84J]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_s84J GHC.Base.$fSemigroupNonEmpty;

GHC.Base.$fSemigroup[]1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s84K ds_s84L]
        case ds_s84L of {
          [] -> b_s84K;
          : c_s84N [Occ=Once] cs_s84O [Occ=Once] ->
              let {
                sat_s84P [Occ=Once, Dmd=<L,1*U>] :: [a_a4FL]
                [LclId] =
                    [c_s84N cs_s84O] \s [] GHC.Base.$fSemigroup[]1 c_s84N cs_s84O;
              } in  GHC.Base.++ b_s84K sat_s84P;
        };

GHC.Base.$fSemigroup[]_$csconcat
  :: forall a. GHC.Base.NonEmpty [a] -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s84Q]
        case ds_s84Q of {
          GHC.Base.:| a1_s84S [Occ=Once] as_s84T [Occ=Once] ->
              GHC.Base.$fSemigroup[]1 a1_s84S as_s84T;
        };

GHC.Base.mapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> [a] -> m [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s84U eta_s84V eta1_s84W]
        let {
          z_s84X [Occ=OnceL] :: m_a4da [b_a4dc]
          [LclId] =
              [$dMonad_s84U] \u []
                  GHC.Base.return $dMonad_s84U GHC.Types.[]; } in
        let {
          go_s84Y [Occ=LoopBreaker] :: [a_a4db] -> m_a4da [b_a4dc]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonad_s84U eta_s84V z_s84X go_s84Y] \r [ds_s84Z]
                  case ds_s84Z of {
                    [] -> z_s84X;
                    : y_s851 [Occ=Once] ys_s852 [Occ=Once] ->
                        let {
                          r_s853 [Occ=OnceL] :: m_a4da [b_a4dc]
                          [LclId] =
                              [go_s84Y ys_s852] \u [] go_s84Y ys_s852; } in
                        let {
                          sat_s859 [Occ=Once] :: b_a4dc -> m_a4da [b_a4dc]
                          [LclId] =
                              [$dMonad_s84U r_s853] \r [x_s855]
                                  let {
                                    sat_s858 [Occ=Once] :: [b_a4dc] -> m_a4da [b_a4dc]
                                    [LclId] =
                                        [$dMonad_s84U x_s855] \r [xs_s856]
                                            let {
                                              sat_s857 [Occ=Once] :: [b_a4dc]
                                              [LclId] =
                                                  CCCS :! [x_s855 xs_s856];
                                            } in  GHC.Base.return $dMonad_s84U sat_s857;
                                  } in  GHC.Base.>>= $dMonad_s84U r_s853 sat_s858; } in
                        let {
                          sat_s854 [Occ=Once] :: m_a4da b_a4dc
                          [LclId] =
                              [eta_s84V y_s851] \u [] eta_s84V y_s851;
                        } in  GHC.Base.>>= $dMonad_s84U sat_s854 sat_s859;
                  };
        } in  go_s84Y eta1_s84W;

GHC.Base.sequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. GHC.Base.Monad m => [m a] -> m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s85a eta_B1]
        GHC.Base.mapM $dMonad_s85a GHC.Base.breakpoint eta_B1;

GHC.Base.$dmmconcat :: forall a. GHC.Base.Monoid a => [a] -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s85b eta_s85c]
        let {
          z_s85d [Occ=OnceL] :: a_a37Y
          [LclId] =
              [$dMonoid_s85b] \u [] GHC.Base.mempty $dMonoid_s85b; } in
        let {
          go_s85e [Occ=LoopBreaker] :: [a_a37Y] -> a_a37Y
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_s85b z_s85d go_s85e] \r [ds_s85f]
                  case ds_s85f of {
                    [] -> z_s85d;
                    : y_s85h [Occ=Once] ys_s85i [Occ=Once] ->
                        let {
                          sat_s85j [Occ=Once] :: a_a37Y
                          [LclId] =
                              [go_s85e ys_s85i] \u [] go_s85e ys_s85i;
                        } in  GHC.Base.mappend $dMonoid_s85b y_s85h sat_s85j;
                  };
        } in  go_s85e eta_s85c;

GHC.Base.$fMonoid(->)_$cmconcat
  :: forall b a. GHC.Base.Monoid b => [a -> b] -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s85k eta_s85l eta1_s85m]
        let {
          lvl3_s85n [Occ=OnceL] :: b_a4zA
          [LclId] =
              [$dMonoid_s85k] \u [] GHC.Base.mempty $dMonoid_s85k; } in
        let {
          $dSemigroup_s85o [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_a4zA
          [LclId] =
              [$dMonoid_s85k] \u [] GHC.Base.$p1Monoid $dMonoid_s85k; } in
        let {
          go_s85p [Occ=LoopBreaker] :: [a_a4zB -> b_a4zA] -> a_a4zB -> b_a4zA
          [LclId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
              sat-only [lvl3_s85n $dSemigroup_s85o go_s85p] \r [ds_s85q
                                                                eta2_s85r]
                  case ds_s85q of {
                    [] -> lvl3_s85n;
                    : y_s85t [Occ=Once!] ys_s85u [Occ=Once] ->
                        let {
                          sat_s85w [Occ=Once] :: b_a4zA
                          [LclId] =
                              [go_s85p eta2_s85r ys_s85u] \u [] go_s85p ys_s85u eta2_s85r; } in
                        let {
                          sat_s85v [Occ=Once] :: b_a4zA
                          [LclId] =
                              [eta2_s85r y_s85t] \u [] y_s85t eta2_s85r;
                        } in  GHC.Base.<> $dSemigroup_s85o sat_s85v sat_s85w;
                  };
        } in  go_s85p eta_s85l eta1_s85m;

GHC.Base.$fMonoidIO1
  :: forall a.
     GHC.Base.Monoid a =>
     [GHC.Types.IO a]
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s85x eta_s85y eta1_s85z]
        let {
          $dSemigroup_s85A [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_X4I9
          [LclId] =
              [$dMonoid_s85x] \u [] GHC.Base.$p1Monoid $dMonoid_s85x; } in
        let {
          lvl3_s85B [Occ=OnceL] :: a_X4I9
          [LclId] =
              [$dMonoid_s85x] \u [] GHC.Base.mempty $dMonoid_s85x; } in
        let {
          go_s85C [Occ=LoopBreaker]
            :: [GHC.Types.IO a_X4I9]
               -> GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, a_X4I9 #)
          [LclId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_s85A lvl3_s85B go_s85C] \r [ds_s85D
                                                                eta2_s85E]
                  case ds_s85D of {
                    [] -> (#,#) [eta2_s85E lvl3_s85B];
                    : y_s85G [Occ=Once] ys_s85H [Occ=Once] ->
                        case y_s85G eta2_s85E of {
                          (#,#) ipv_s85J [Occ=Once] ipv1_s85K [Occ=Once] ->
                              case go_s85C ys_s85H ipv_s85J of {
                                (#,#) ipv2_s85M [Occ=Once] ipv3_s85N [Occ=Once] ->
                                    let {
                                      sat_s85O [Occ=Once] :: a_X4I9
                                      [LclId] =
                                          [$dSemigroup_s85A ipv1_s85K ipv3_s85N] \u []
                                              GHC.Base.<> $dSemigroup_s85A ipv1_s85K ipv3_s85N;
                                    } in  (#,#) [ipv2_s85M sat_s85O];
                              };
                        };
                  };
        } in  go_s85C eta_s85y eta1_s85z;

GHC.Base.$fMonoidIO [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid a => GHC.Base.Monoid (GHC.Types.IO a)
[GblId[DFunId], Arity=1, Str=<L,U(U(C(C1(U)),A,A),U,A,A)>m] =
    [] \r [$dMonoid_s85P]
        let {
          sat_s85V [Occ=Once] :: [GHC.Types.IO a_X4I7] -> GHC.Types.IO a_X4I7
          [LclId] =
              [$dMonoid_s85P] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidIO1 $dMonoid_s85P eta_B2 eta_B1; } in
        let {
          sat_s85U [Occ=Once]
            :: GHC.Types.IO a_X4I7
               -> GHC.Types.IO a_X4I7 -> GHC.Types.IO a_X4I7
          [LclId] =
              [$dMonoid_s85P] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoidIO_$cmappend
                      $dMonoid_s85P eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s85T [Occ=Once] :: GHC.Types.IO a_X4I7
          [LclId] =
              [$dMonoid_s85P] \r [s_s85R]
                  let {
                    sat_s85S [Occ=Once] :: a_X4I7
                    [LclId] =
                        [$dMonoid_s85P] \u [] GHC.Base.mempty $dMonoid_s85P;
                  } in  (#,#) [s_s85R sat_s85S]; } in
        let {
          sat_s85Q [Occ=Once] :: GHC.Base.Semigroup (GHC.Types.IO a_X4I7)
          [LclId] =
              [$dMonoid_s85P] \u [] GHC.Base.$fMonoidIO_$cp1Monoid $dMonoid_s85P;
        } in  GHC.Base.C:Monoid [sat_s85Q sat_s85T sat_s85U sat_s85V];

GHC.Base.$fFunctor[]_$c<$ :: forall a b. a -> [b] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_s85W eta_s85X]
        let {
          sat_s85Z [Occ=Once] :: b_a4Mt -> a_a4Ms
          [LclId] =
              [x_s85W] \r [ds_s85Y] x_s85W;
        } in  GHC.Base.map sat_s85Z eta_s85X;

GHC.Base.$fFunctorNonEmpty_$c<$
  :: forall a b. a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,1*U(A,1*U)>m,
 Unf=OtherCon []] =
    [] \r [b1_s860 ds_s861]
        let {
          sat_s867 [Occ=Once] :: [a_a4Hj]
          [LclId] =
              [b1_s860 ds_s861] \u []
                  case ds_s861 of {
                    GHC.Base.:| _ [Occ=Dead] as_s864 [Occ=Once] ->
                        let {
                          sat_s866 [Occ=Once] :: b_a4Hk -> a_a4Hj
                          [LclId] =
                              [b1_s860] \r [ds2_s865] b1_s860;
                        } in  GHC.Base.map sat_s866 as_s864;
                  };
        } in  GHC.Base.:| [b1_s860 sat_s867];

GHC.Base.$fFunctor[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.map
                                       GHC.Base.$fFunctor[]_$c<$];

GHC.Base.$fMonad[]_$c>>= [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a] -> (a -> [b]) -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [xs_s868 f_s869]
        let {
          go_s86a [Occ=LoopBreaker] :: [a_a4rg] -> [b_a4rh]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_s869 go_s86a] \r [ds_s86b]
                  case ds_s86b of {
                    [] -> [] [];
                    : y_s86d [Occ=Once] ys_s86e [Occ=Once] ->
                        let {
                          sat_s86g [Occ=Once, Dmd=<L,1*U>] :: [b_a4rh]
                          [LclId] =
                              [go_s86a ys_s86e] \s [] go_s86a ys_s86e;
                        } in 
                          case f_s869 y_s86d of sat_s86f {
                            __DEFAULT -> GHC.Base.++ sat_s86f sat_s86g;
                          };
                  };
        } in  go_s86a xs_s868;

GHC.Base.=<<_$s=<< :: forall a b. (a -> [b]) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s86h x_s86i] GHC.Base.$fMonad[]_$c>>= x_s86i f_s86h;

GHC.Base.=<<
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> m a -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s86j f_s86k x_s86l]
        GHC.Base.>>= $dMonad_s86j x_s86l f_s86k;

poly_go_r7PI :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds_s86m]
        case ds_s86m of {
          [] -> [] [];
          : y_s86o [Occ=Once] ys_s86p [Occ=Once] ->
              let {
                sat_s86q [Occ=Once, Dmd=<L,1*U>] :: [a_a4zZ]
                [LclId] =
                    [ys_s86p] \s [] poly_go_r7PI ys_s86p;
              } in  GHC.Base.++ y_s86o sat_s86q;
        };

GHC.Base.$fMonoid[]_$cmconcat [InlPrag=INLINE (sat-args=1)]
  :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [xss_s86r] poly_go_r7PI xss_s86r;

GHC.Base.$fApplicative[]_$c<*> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a -> b] -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [fs_s86s xs_s86t]
        let {
          go_s86u [Occ=LoopBreaker] :: [a_a4Ka -> b_a4Kb] -> [b_a4Kb]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [xs_s86t go_s86u] \r [ds_s86v]
                  case ds_s86v of {
                    [] -> [] [];
                    : y_s86x [Occ=OnceL!] ys_s86y [Occ=Once] ->
                        let {
                          z_s86z [Occ=OnceL] :: [b_a4Kb]
                          [LclId] =
                              [go_s86u ys_s86y] \u [] go_s86u ys_s86y; } in
                        let {
                          go1_s86A [Occ=LoopBreaker] :: [a_a4Ka] -> [b_a4Kb]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [y_s86x z_s86z go1_s86A] \r [ds1_s86B]
                                  case ds1_s86B of {
                                    [] -> z_s86z;
                                    : y1_s86D [Occ=Once] ys1_s86E [Occ=Once] ->
                                        let {
                                          sat_s86G [Occ=Once] :: [b_a4Kb]
                                          [LclId] =
                                              [go1_s86A ys1_s86E] \u [] go1_s86A ys1_s86E; } in
                                        let {
                                          sat_s86F [Occ=Once] :: b_a4Kb
                                          [LclId] =
                                              [y_s86x y1_s86D] \u [] y_s86x y1_s86D;
                                        } in  : [sat_s86F sat_s86G];
                                  };
                        } in  go1_s86A xs_s86t;
                  };
        } in  go_s86u fs_s86s;

GHC.Base.$fApplicative[]_$cliftA2 [InlPrag=INLINE (sat-args=3)]
  :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s86H xs_s86I ys_s86J]
        let {
          go_s86K [Occ=LoopBreaker] :: [a_a4Ki] -> [c_a4Kk]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_s86H ys_s86J go_s86K] \r [ds_s86L]
                  case ds_s86L of {
                    [] -> [] [];
                    : y_s86N [Occ=OnceL] ys1_s86O [Occ=Once] ->
                        let {
                          z_s86P [Occ=OnceL] :: [c_a4Kk]
                          [LclId] =
                              [go_s86K ys1_s86O] \u [] go_s86K ys1_s86O; } in
                        let {
                          go1_s86Q [Occ=LoopBreaker] :: [b_a4Kj] -> [c_a4Kk]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [f_s86H y_s86N z_s86P go1_s86Q] \r [ds1_s86R]
                                  case ds1_s86R of {
                                    [] -> z_s86P;
                                    : y1_s86T [Occ=Once] ys2_s86U [Occ=Once] ->
                                        let {
                                          sat_s86W [Occ=Once] :: [c_a4Kk]
                                          [LclId] =
                                              [go1_s86Q ys2_s86U] \u [] go1_s86Q ys2_s86U; } in
                                        let {
                                          sat_s86V [Occ=Once] :: c_a4Kk
                                          [LclId] =
                                              [f_s86H y_s86N y1_s86T] \u [] f_s86H y_s86N y1_s86T;
                                        } in  : [sat_s86V sat_s86W];
                                  };
                        } in  go1_s86Q ys_s86J;
                  };
        } in  go_s86K xs_s86I;

GHC.Base.$fApplicative[]_$c<* :: forall a b. [a] -> [b] -> [a]
[GblId, Arity=2, Caf=NoCafRefs, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fApplicative[]_$cliftA2 GHC.Base.const eta_B2 eta_B1;

GHC.Base.$fApplicative[]_$c*> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a] -> [b] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [xs_s86X ys_s86Y]
        let {
          go_s86Z [Occ=LoopBreaker] :: [a_a4Kr] -> [b_a4Ks]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [ys_s86Y go_s86Z] \r [ds_s870]
                  case ds_s870 of {
                    [] -> [] [];
                    : _ [Occ=Dead] ys1_s873 [Occ=Once] ->
                        let {
                          sat_s874 [Occ=Once, Dmd=<L,1*U>] :: [b_a4Ks]
                          [LclId] =
                              [go_s86Z ys1_s873] \s [] go_s86Z ys1_s873;
                        } in  GHC.Base.++ ys_s86Y sat_s874;
                  };
        } in  go_s86Z xs_s86X;

GHC.Base.$fApplicative[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctor[]
                                           GHC.Base.$fApplicative[]_$cpure
                                           GHC.Base.$fApplicative[]_$c<*>
                                           GHC.Base.$fApplicative[]_$cliftA2
                                           GHC.Base.$fApplicative[]_$c*>
                                           GHC.Base.$fApplicative[]_$c<*];

GHC.Base.$fFunctorNonEmpty_$cfmap
  :: forall a b.
     (a -> b) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_s875 ds_s876]
        let {
          sat_s87f [Occ=Once] :: [b_a4H8]
          [LclId] =
              [f_s875 ds_s876] \u []
                  case ds_s876 of {
                    GHC.Base.:| _ [Occ=Dead] as_s87e [Occ=Once] ->
                        GHC.Base.map f_s875 as_s87e;
                  }; } in
        let {
          sat_s87b [Occ=Once] :: b_a4H8
          [LclId] =
              [f_s875 ds_s876] \u []
                  let {
                    sat_s87a [Occ=Once] :: a_a4H7
                    [LclId] =
                        [ds_s876] \u []
                            case ds_s876 of {
                              GHC.Base.:| a1_s878 [Occ=Once] _ [Occ=Dead] -> a1_s878;
                            };
                  } in  f_s875 sat_s87a;
        } in  GHC.Base.:| [sat_s87b sat_s87f];

GHC.Base.$fFunctorNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctorNonEmpty_$cfmap
                                       GHC.Base.$fFunctorNonEmpty_$c<$];

GHC.Base.$fAlternative[]1 :: forall a. [[a]]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Types.[] GHC.Types.[]];

GHC.Base.$fAlternative[]_$csome :: forall a. [a] -> [[a]]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s87g]
        let {
          some_v_s87h [Occ=LoopBreaker] :: [[a_a4Ik]]
          [LclId] =
              [v_s87g some_v_s87h] \u []
                  let {
                    ys_s87i [Occ=OnceL] :: [[a_a4Ik]]
                    [LclId] =
                        [some_v_s87h] \u []
                            GHC.Base.++ some_v_s87h GHC.Base.$fAlternative[]1; } in
                  let {
                    go_s87j [Occ=LoopBreaker] :: [a_a4Ik] -> [[a_a4Ik]]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                        sat-only [ys_s87i go_s87j] \r [ds_s87k]
                            case ds_s87k of {
                              [] -> [] [];
                              : y_s87m [Occ=OnceL] ys1_s87n [Occ=Once] ->
                                  let {
                                    z_s87o [Occ=OnceL] :: [[a_a4Ik]]
                                    [LclId] =
                                        [go_s87j ys1_s87n] \u [] go_s87j ys1_s87n; } in
                                  let {
                                    go1_s87p [Occ=LoopBreaker] :: [[a_a4Ik]] -> [[a_a4Ik]]
                                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                        sat-only [y_s87m z_s87o go1_s87p] \r [ds1_s87q]
                                            case ds1_s87q of {
                                              [] -> z_s87o;
                                              : y1_s87s [Occ=Once] ys2_s87t [Occ=Once] ->
                                                  let {
                                                    sat_s87v [Occ=Once] :: [[a_a4Ik]]
                                                    [LclId] =
                                                        [go1_s87p ys2_s87t] \u []
                                                            go1_s87p ys2_s87t; } in
                                                  let {
                                                    sat_s87u [Occ=Once] :: [a_a4Ik]
                                                    [LclId] =
                                                        CCCS :! [y_s87m y1_s87s];
                                                  } in  : [sat_s87u sat_s87v];
                                            };
                                  } in  go1_s87p ys_s87i;
                            };
                  } in  go_s87j v_s87g;
        } in  some_v_s87h;

GHC.Base.$fAlternative[]_$cmany :: forall a. [a] -> [[a]]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s87w]
        let {
          many_v_s87x [Occ=LoopBreaker] :: [[a_a4Is]]
          [LclId] =
              [v_s87w many_v_s87x] \u []
                  let {
                    go_s87y [Occ=LoopBreaker] :: [a_a4Is] -> [[a_a4Is]]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                        sat-only [many_v_s87x go_s87y] \r [ds_s87z]
                            case ds_s87z of {
                              [] -> [] [];
                              : y_s87B [Occ=OnceL] ys_s87C [Occ=Once] ->
                                  let {
                                    z_s87D [Occ=OnceL] :: [[a_a4Is]]
                                    [LclId] =
                                        [go_s87y ys_s87C] \u [] go_s87y ys_s87C; } in
                                  let {
                                    go1_s87E [Occ=LoopBreaker] :: [[a_a4Is]] -> [[a_a4Is]]
                                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                        sat-only [y_s87B z_s87D go1_s87E] \r [ds1_s87F]
                                            case ds1_s87F of {
                                              [] -> z_s87D;
                                              : y1_s87H [Occ=Once] ys1_s87I [Occ=Once] ->
                                                  let {
                                                    sat_s87K [Occ=Once] :: [[a_a4Is]]
                                                    [LclId] =
                                                        [go1_s87E ys1_s87I] \u []
                                                            go1_s87E ys1_s87I; } in
                                                  let {
                                                    sat_s87J [Occ=Once] :: [a_a4Is]
                                                    [LclId] =
                                                        CCCS :! [y_s87B y1_s87H];
                                                  } in  : [sat_s87J sat_s87K];
                                            };
                                  } in  go1_s87E many_v_s87x;
                            };
                  } in 
                    case go_s87y v_s87w of sat_s87L {
                      __DEFAULT -> GHC.Base.++ sat_s87L GHC.Base.$fAlternative[]1;
                    };
        } in  many_v_s87x;

GHC.Base.$fAlternative[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [GHC.Base.$fApplicative[]
                                           GHC.Types.[]
                                           GHC.Base.++
                                           GHC.Base.$fAlternative[]_$csome
                                           GHC.Base.$fAlternative[]_$cmany];

GHC.Base.$w$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> (a -> GHC.Base.NonEmpty b) -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,C(U(1*U,1*U))>,
 Unf=OtherCon []] =
    [] \r [w_s87M w1_s87N]
        let {
          ds_s87O [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty b_s6HN
          [LclId] =
              [w_s87M w1_s87N] \u []
                  let {
                    sat_s87S [Occ=Once] :: a_s6HM
                    [LclId] =
                        [w_s87M] \u []
                            case w_s87M of {
                              GHC.Base.:| a1_s87Q [Occ=Once] _ [Occ=Dead] -> a1_s87Q;
                            };
                  } in  w1_s87N sat_s87S; } in
        let {
          sat_s88k [Occ=Once] :: [b_s6HN]
          [LclId] =
              [w_s87M w1_s87N ds_s87O] \u []
                  case ds_s87O of {
                    GHC.Base.:| _ [Occ=Dead] bs_s87Z [Occ=Once] ->
                        let {
                          sat_s88j [Occ=Once, Dmd=<L,1*U>] :: [b_s6HN]
                          [LclId] =
                              [w_s87M w1_s87N] \s []
                                  case w_s87M of {
                                    GHC.Base.:| _ [Occ=Dead] as_s882 [Occ=Once] ->
                                        let {
                                          go_s883 [Occ=LoopBreaker] :: [a_s6HM] -> [b_s6HN]
                                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                              sat-only [w1_s87N go_s883] \r [ds1_s884]
                                                  case ds1_s884 of {
                                                    [] -> [] [];
                                                    : y_s886 [Occ=Once] ys_s887 [Occ=Once] ->
                                                        let {
                                                          ds2_s888 [Dmd=<L,U(1*U,1*U)>]
                                                            :: GHC.Base.NonEmpty b_s6HN
                                                          [LclId] =
                                                              [w1_s87N y_s886] \u []
                                                                  w1_s87N y_s886; } in
                                                        let {
                                                          sat_s88i [Occ=Once, Dmd=<L,1*U>]
                                                            :: [b_s6HN]
                                                          [LclId] =
                                                              [go_s883 ys_s887] \s []
                                                                  go_s883 ys_s887; } in
                                                        let {
                                                          sat_s88g [Occ=Once] :: [b_s6HN]
                                                          [LclId] =
                                                              [ds2_s888] \u []
                                                                  case ds2_s888 of {
                                                                    GHC.Base.:| _ [Occ=Dead]
                                                                                cs_s88f [Occ=Once] ->
                                                                        cs_s88f;
                                                                  }; } in
                                                        let {
                                                          sat_s88c [Occ=Once] :: b_s6HN
                                                          [LclId] =
                                                              [ds2_s888] \u []
                                                                  case ds2_s888 of {
                                                                    GHC.Base.:| c_s88a [Occ=Once]
                                                                                _ [Occ=Dead] ->
                                                                        c_s88a;
                                                                  }; } in
                                                        let {
                                                          sat_s88h [Occ=Once] :: [b_s6HN]
                                                          [LclId] =
                                                              CCCS :! [sat_s88c sat_s88g];
                                                        } in  GHC.Base.++ sat_s88h sat_s88i;
                                                  };
                                        } in  go_s883 as_s882;
                                  };
                        } in  GHC.Base.++ bs_s87Z sat_s88j;
                  }; } in
        let {
          sat_s87W [Occ=Once] :: b_s6HN
          [LclId] =
              [ds_s87O] \u []
                  case ds_s87O of {
                    GHC.Base.:| b1_s87U [Occ=Once] _ [Occ=Dead] -> b1_s87U;
                  };
        } in  (#,#) [sat_s87W sat_s88k];

GHC.Base.$fMonadNonEmpty_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a
     -> (a -> GHC.Base.NonEmpty b) -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,C(U(1*U,1*U))>m,
 Unf=OtherCon []] =
    [] \r [w_s88l w1_s88m]
        case GHC.Base.$w$c>>= w_s88l w1_s88m of {
          (#,#) ww1_s88o [Occ=Once] ww2_s88p [Occ=Once] ->
              GHC.Base.:| [ww1_s88o ww2_s88p];
        };

GHC.Base.$fMonadNonEmpty_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s88q eta1_s88r]
        let {
          sat_s88t [Occ=Once] :: a_a4sH -> GHC.Base.NonEmpty b_a4sI
          [LclId] =
              [eta1_s88r] \r [ds_s88s] eta1_s88r;
        } in 
          case GHC.Base.$w$c>>= eta_s88q sat_s88t of {
            (#,#) ww1_s88v [Occ=Once] ww2_s88w [Occ=Once] ->
                GHC.Base.:| [ww1_s88v ww2_s88w];
          };

GHC.Base.<**>1 :: forall a b. a -> (a -> b) -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [a1_s88x f_s88y] f_s88y a1_s88x;

GHC.Base.<**>
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     f a -> f (a -> b) -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s88z]
        GHC.Base.liftA2 $dApplicative_s88z GHC.Base.<**>1;

GHC.Base.$dmliftA2
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b c. (a -> b -> c) -> f a -> f b -> f c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLL),U(1*U(1*C1(C1(U)),A),A,1*C1(U),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s88A eta_s88B eta1_s88C]
        let {
          sat_s88E [Occ=Once] :: f_a37E (b_a4iN -> c_a4iO)
          [LclId] =
              [$dApplicative_s88A eta_s88B eta1_s88C] \u []
                  case GHC.Base.$p1Applicative $dApplicative_s88A of sat_s88D {
                    __DEFAULT -> GHC.Base.fmap sat_s88D eta_s88B eta1_s88C;
                  };
        } in  GHC.Base.<*> $dApplicative_s88A sat_s88E;

GHC.Base.$dmsome
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s88F eta_s88G]
        let {
          some_v_s88H [Occ=LoopBreaker] :: f_a37j [a_a4ju]
          [LclId] =
              [$dAlternative_s88F eta_s88G some_v_s88H] \u []
                  case
                      GHC.Base.$p1Alternative $dAlternative_s88F
                  of
                  $dApplicative_s88I [Dmd=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                  { __DEFAULT ->
                        let {
                          sat_s88K [Occ=Once] :: f_a37j [a_a4ju]
                          [LclId] =
                              [$dAlternative_s88F some_v_s88H $dApplicative_s88I] \u []
                                  let {
                                    sat_s88J [Occ=Once] :: f_a37j [a_a4ju]
                                    [LclId] =
                                        [$dApplicative_s88I] \u []
                                            GHC.Base.pure $dApplicative_s88I GHC.Types.[];
                                  } in  GHC.Base.<|> $dAlternative_s88F some_v_s88H sat_s88J;
                        } in 
                          GHC.Base.liftA2 $dApplicative_s88I GHC.Types.: eta_s88G sat_s88K;
                  };
        } in  some_v_s88H;

GHC.Base.$dmmany
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s88L eta_s88M]
        let {
          many_v_s88N [Occ=LoopBreaker] :: f_a37j [a_a4jX]
          [LclId] =
              [$dAlternative_s88L eta_s88M many_v_s88N] \u []
                  let {
                    $dApplicative_s88O [Dmd=<L,U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                      :: GHC.Base.Applicative f_a37j
                    [LclId] =
                        [$dAlternative_s88L] \u []
                            GHC.Base.$p1Alternative $dAlternative_s88L; } in
                  let {
                    sat_s88Q [Occ=Once] :: f_a37j [a_a4jX]
                    [LclId] =
                        [$dApplicative_s88O] \u []
                            GHC.Base.pure $dApplicative_s88O GHC.Types.[]; } in
                  let {
                    sat_s88P [Occ=Once] :: f_a37j [a_a4jX]
                    [LclId] =
                        [eta_s88M many_v_s88N $dApplicative_s88O] \u []
                            GHC.Base.liftA2
                                $dApplicative_s88O GHC.Types.: eta_s88M many_v_s88N;
                  } in  GHC.Base.<|> $dAlternative_s88L sat_s88P sat_s88Q;
        } in  many_v_s88N;

GHC.Base.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Base.Semigroup b =>
     (a -> b) -> [a -> b] -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s88R ww_s88S ww1_s88T]
        let {
          go_s88U [Occ=LoopBreaker]
            :: (a_s6HX -> b_s6HW) -> [a_s6HX -> b_s6HW] -> a_s6HX -> b_s6HW
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s88R go_s88U] \r [b1_s88V ds_s88W]
                  case ds_s88W of {
                    [] -> b1_s88V;
                    : c_s88Y [Occ=Once] cs_s88Z [Occ=Once] ->
                        let {
                          g_s890 [Occ=OnceL!, Dmd=<L,C(U)>] :: a_s6HX -> b_s6HW
                          [LclId] =
                              [go_s88U c_s88Y cs_s88Z] \u [] go_s88U c_s88Y cs_s88Z; } in
                        let {
                          sat_s894 [Occ=OnceT[0]] :: a_s6HX -> b_s6HW
                          [LclId] =
                              [w_s88R b1_s88V g_s890] \r [x_s891]
                                  let {
                                    sat_s893 [Occ=Once] :: b_s6HW
                                    [LclId] =
                                        [g_s890 x_s891] \u [] g_s890 x_s891; } in
                                  let {
                                    sat_s892 [Occ=Once] :: b_s6HW
                                    [LclId] =
                                        [b1_s88V x_s891] \u [] b1_s88V x_s891;
                                  } in  GHC.Base.<> w_s88R sat_s892 sat_s893;
                        } in  sat_s894;
                  };
        } in  go_s88U ww_s88S ww1_s88T;

GHC.Base.$fSemigroup(->)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Base.Semigroup b =>
     GHC.Base.NonEmpty (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s895 w1_s896]
        case w1_s896 of {
          GHC.Base.:| ww1_s898 [Occ=Once] ww2_s899 [Occ=Once] ->
              GHC.Base.$w$csconcat3 w_s895 ww1_s898 ww2_s899;
        };

GHC.Base.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     a -> b -> [(a, b)] -> (# a, b #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s89a w1_s89b ww_s89c ww1_s89d ww2_s89e]
        let {
          $wgo_s89f [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: a_s6Ih -> b_s6Ii -> [(a_s6Ih, b_s6Ii)] -> (# a_s6Ih, b_s6Ii #)
          [LclId, Arity=3, Str=<L,U><L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s89a w1_s89b $wgo_s89f] \r [ww3_s89g ww4_s89h w2_s89i]
                  case w2_s89i of {
                    [] -> (#,#) [ww3_s89g ww4_s89h];
                    : c_s89k [Occ=Once!] cs_s89l [Occ=Once] ->
                        case c_s89k of {
                          (,) ww6_s89n [Occ=Once] ww7_s89o [Occ=Once] ->
                              case $wgo_s89f ww6_s89n ww7_s89o cs_s89l of {
                                (#,#) ww9_s89q [Occ=Once] ww10_s89r [Occ=Once] ->
                                    let {
                                      sat_s89t [Occ=Once] :: b_s6Ii
                                      [LclId] =
                                          [w1_s89b ww4_s89h ww10_s89r] \u []
                                              GHC.Base.<> w1_s89b ww4_s89h ww10_s89r; } in
                                    let {
                                      sat_s89s [Occ=Once] :: a_s6Ih
                                      [LclId] =
                                          [w_s89a ww3_s89g ww9_s89q] \u []
                                              GHC.Base.<> w_s89a ww3_s89g ww9_s89q;
                                    } in  (#,#) [sat_s89s sat_s89t];
                              };
                        };
                  };
        } in  $wgo_s89f ww_s89c ww1_s89d ww2_s89e;

GHC.Base.$fSemigroup(,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     GHC.Base.NonEmpty (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s89u w1_s89v w2_s89w]
        case w2_s89w of {
          GHC.Base.:| ww1_s89y [Occ=Once!] ww2_s89z [Occ=Once] ->
              case ww1_s89y of {
                (,) ww4_s89B [Occ=Once] ww5_s89C [Occ=Once] ->
                    case
                        GHC.Base.$w$csconcat w_s89u w1_s89v ww4_s89B ww5_s89C ww2_s89z
                    of
                    { (#,#) ww7_s89E [Occ=Once] ww8_s89F [Occ=Once] ->
                          (,) [ww7_s89E ww8_s89F];
                    };
              };
        };

GHC.Base.$dmsconcat
  :: forall a. GHC.Base.Semigroup a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s89G ds_s89H]
        case ds_s89H of {
          GHC.Base.:| a1_s89J [Occ=Once] as_s89K [Occ=Once] ->
              let {
                go_s89L [Occ=LoopBreaker] :: a_a37Z -> [a_a37Z] -> a_a37Z
                [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
                    sat-only [$dSemigroup_s89G go_s89L] \r [b_s89M ds1_s89N]
                        case ds1_s89N of {
                          [] -> b_s89M;
                          : c_s89P [Occ=Once] cs_s89Q [Occ=Once] ->
                              let {
                                sat_s89R [Occ=Once] :: a_a37Z
                                [LclId] =
                                    [go_s89L c_s89P cs_s89Q] \u [] go_s89L c_s89P cs_s89Q;
                              } in  GHC.Base.<> $dSemigroup_s89G b_s89M sat_s89R;
                        };
              } in  go_s89L a1_s89J as_s89K;
        };

GHC.Base.$dmstimes
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b. GHC.Real.Integral b => b -> a -> a
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
    [] \r [$dSemigroup_s89S $dIntegral_s89T]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_s89T $dSemigroup_s89S;

GHC.Base.$dmmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Base.Monoid a => a -> a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(SLL)LLL),1*U(1*U(1*U,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s89U]
        case GHC.Base.$p1Monoid $dMonoid_s89U of sat_s89V {
          __DEFAULT -> GHC.Base.<> sat_s89V;
        };

GHC.Base.$dm>> [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. m a -> m b -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s89W m1_s89X k_s89Y]
        let {
          sat_s8a0 [Occ=Once] :: a_a4lv -> m_a37u b_a4lw
          [LclId] =
              [k_s89Y] \r [ds_s89Z] k_s89Y;
        } in  GHC.Base.>>= $dMonad_s89W m1_s89X sat_s8a0;

GHC.Base.$dmreturn
  :: forall (m :: * -> *). GHC.Base.Monad m => forall a. a -> m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LSLLLL)LLLL),1*U(1*U(A,1*U,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s8a1]
        case GHC.Base.$p1Monad $dMonad_s8a1 of sat_s8a2 {
          __DEFAULT -> GHC.Base.pure sat_s8a2;
        };

GHC.Base.$dmfail
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a. GHC.Base.String -> m a
[GblId, Arity=2, Str=<B,A><B,U>x, Unf=OtherCon []] =
    [] \r [$dMonad_s8a3 s_s8a4] GHC.Err.errorWithoutStackTrace s_s8a4;

GHC.Base.$dmmzero
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => forall a. m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LSLLL)LLL),1*U(1*U(A,1*U,A,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_s8a5]
        case GHC.Base.$p1MonadPlus $dMonadPlus_s8a5 of sat_s8a6 {
          __DEFAULT -> GHC.Base.empty sat_s8a6;
        };

GHC.Base.$dmmplus
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a. m a -> m a -> m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LLSLL)LLL),1*U(1*U(A,A,1*U,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_s8a7]
        case GHC.Base.$p1MonadPlus $dMonadPlus_s8a7 of sat_s8a8 {
          __DEFAULT -> GHC.Base.<|> sat_s8a8;
        };

GHC.Base.$fEqMaybe_$c==
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s8a9 ds_s8aa ds1_s8ab]
        case ds_s8aa of {
          GHC.Base.Nothing ->
              case ds1_s8ab of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just a1_s8af [Occ=Once] ->
              case ds1_s8ab of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just b1_s8ah [Occ=Once] ->
                    GHC.Classes.== $dEq_s8a9 a1_s8af b1_s8ah;
              };
        };

GHC.Base.$fEqMaybe_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s8ai eta_s8aj eta1_s8ak]
        case eta_s8aj of {
          GHC.Base.Nothing ->
              case eta1_s8ak of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.True [];
              };
          GHC.Base.Just a1_s8ao [Occ=Once] ->
              case eta1_s8ak of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just b1_s8aq [Occ=Once] ->
                    case GHC.Classes.== $dEq_s8ai a1_s8ao b1_s8aq of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

GHC.Base.$fEqMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Base.Maybe a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s8as]
        let {
          sat_s8au [Occ=Once]
            :: GHC.Base.Maybe a_a4m9 -> GHC.Base.Maybe a_a4m9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s8as] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_s8as eta_B2 eta_B1; } in
        let {
          sat_s8at [Occ=Once]
            :: GHC.Base.Maybe a_a4m9 -> GHC.Base.Maybe a_a4m9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s8as] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_s8as eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s8at sat_s8au];

GHC.Base.$fOrdMaybe_$cp1Ord
  :: forall a. GHC.Classes.Ord a => GHC.Classes.Eq (GHC.Base.Maybe a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8av]
        let {
          sat_s8aw [Occ=Once, Dmd=<L,U(C(C1(U)),A)>] :: GHC.Classes.Eq a_a4mo
          [LclId] =
              [$dOrd_s8av] \u [] GHC.Classes.$p1Ord $dOrd_s8av;
        } in  GHC.Base.$fEqMaybe sat_s8aw;

GHC.Base.$fOrdMaybe_$ccompare
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8ax a1_s8ay b_s8az]
        case a1_s8ay of {
          GHC.Base.Nothing ->
              case b_s8az of {
                GHC.Base.Nothing -> GHC.Types.EQ [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.LT [];
              };
          GHC.Base.Just a2_s8aD [Occ=Once] ->
              case b_s8az of {
                GHC.Base.Nothing -> GHC.Types.GT [];
                GHC.Base.Just b1_s8aF [Occ=Once] ->
                    GHC.Classes.compare $dOrd_s8ax a2_s8aD b1_s8aF;
              };
        };

GHC.Base.$fOrdMaybe_$c<
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8aG a1_s8aH b_s8aI]
        case a1_s8aH of {
          GHC.Base.Nothing ->
              case b_s8aI of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.True [];
              };
          GHC.Base.Just a2_s8aM [Occ=Once] ->
              case b_s8aI of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just b1_s8aO [Occ=Once] ->
                    GHC.Classes.< $dOrd_s8aG a2_s8aM b1_s8aO;
              };
        };

GHC.Base.$fOrdMaybe_$c<=
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8aP a1_s8aQ b_s8aR]
        case b_s8aR of {
          GHC.Base.Nothing ->
              case a1_s8aQ of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just a2_s8aV [Occ=Once] ->
              case a1_s8aQ of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just b1_s8aX [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s8aP a2_s8aV b1_s8aX of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

GHC.Base.$fOrdMaybe_$cmax
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8aZ x_s8b0 y_s8b1]
        case y_s8b1 of wild_s8b2 {
          GHC.Base.Nothing -> x_s8b0;
          GHC.Base.Just a1_s8b3 [Occ=Once] ->
              case x_s8b0 of wild1_s8b4 {
                GHC.Base.Nothing -> wild_s8b2;
                GHC.Base.Just b1_s8b5 [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s8aZ a1_s8b3 b1_s8b5 of {
                      GHC.Types.False -> wild_s8b2;
                      GHC.Types.True -> wild1_s8b4;
                    };
              };
        };

GHC.Base.$fOrdMaybe_$cmin
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8b7 x_s8b8 y_s8b9]
        case y_s8b9 of wild_s8ba {
          GHC.Base.Nothing ->
              case x_s8b8 of { __DEFAULT -> GHC.Base.Nothing []; };
          GHC.Base.Just a1_s8bc [Occ=Once] ->
              case x_s8b8 of wild1_s8bd {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just b1_s8be [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s8b7 a1_s8bc b1_s8be of {
                      GHC.Types.False -> wild1_s8bd;
                      GHC.Types.True -> wild_s8ba;
                    };
              };
        };

GHC.Base.$fOrdMaybe_$c>=
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8bg a1_s8bh b_s8bi]
        case a1_s8bh of {
          GHC.Base.Nothing ->
              case b_s8bi of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just a2_s8bm [Occ=Once] ->
              case b_s8bi of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just b1_s8bo [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s8bg a2_s8bm b1_s8bo of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

GHC.Base.$fOrdMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (GHC.Base.Maybe a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s8bq]
        let {
          sat_s8bA [Occ=Once]
            :: GHC.Base.Maybe a_a4mo
               -> GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo
          [LclId] =
              [$dOrd_s8bq] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_s8bq eta_B2 eta_B1; } in
        let {
          sat_s8bz [Occ=Once]
            :: GHC.Base.Maybe a_a4mo
               -> GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo
          [LclId] =
              [$dOrd_s8bq] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_s8bq eta_B2 eta_B1; } in
        let {
          sat_s8by [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8bq] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_s8bq eta_B2 eta_B1; } in
        let {
          sat_s8bx [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8bq] \r [a1_s8bv b_s8bw]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s8bq b_s8bw a1_s8bv; } in
        let {
          sat_s8bu [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8bq] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_s8bq eta_B2 eta_B1; } in
        let {
          sat_s8bt [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8bq] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s8bq eta_B2 eta_B1; } in
        let {
          sat_s8bs [Occ=Once]
            :: GHC.Base.Maybe a_a4mo
               -> GHC.Base.Maybe a_a4mo -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s8bq] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_s8bq eta_B2 eta_B1; } in
        let {
          sat_s8br [Occ=Once] :: GHC.Classes.Eq (GHC.Base.Maybe a_a4mo)
          [LclId] =
              [$dOrd_s8bq] \u [] GHC.Base.$fOrdMaybe_$cp1Ord $dOrd_s8bq;
        } in 
          GHC.Classes.C:Ord [sat_s8br
                             sat_s8bs
                             sat_s8bt
                             sat_s8bu
                             sat_s8bx
                             sat_s8by
                             sat_s8bz
                             sat_s8bA];

GHC.Base.$fEqNonEmpty_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_s8bB eta_s8bC eta1_s8bD]
        case eta_s8bC of {
          GHC.Base.:| a1_s8bF [Occ=Once] a2_s8bG [Occ=Once] ->
              case eta1_s8bD of {
                GHC.Base.:| b1_s8bI [Occ=Once] b2_s8bJ [Occ=Once] ->
                    case GHC.Classes.== $dEq_s8bB a1_s8bF b1_s8bI of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True ->
                          case GHC.Classes.$fEq[]_$c== $dEq_s8bB a2_s8bG b2_s8bJ of {
                            GHC.Types.False -> GHC.Types.True [];
                            GHC.Types.True -> GHC.Types.False [];
                          };
                    };
              };
        };

GHC.Base.$w$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8bM ww_s8bN ww1_s8bO ww2_s8bP ww3_s8bQ]
        case GHC.Classes.== w_s8bM ww_s8bN ww2_s8bP of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True -> GHC.Classes.$fEq[]_$c== w_s8bM ww1_s8bO ww3_s8bQ;
        };

GHC.Base.$fEqNonEmpty_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s8bS w1_s8bT w2_s8bU]
        case w1_s8bT of {
          GHC.Base.:| ww1_s8bW [Occ=Once] ww2_s8bX [Occ=Once] ->
              case w2_s8bU of {
                GHC.Base.:| ww4_s8bZ [Occ=Once] ww5_s8c0 [Occ=Once] ->
                    GHC.Base.$w$c== w_s8bS ww1_s8bW ww2_s8bX ww4_s8bZ ww5_s8c0;
              };
        };

GHC.Base.$fEqNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (GHC.Base.NonEmpty a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s8c1]
        let {
          sat_s8c3 [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nu
               -> GHC.Base.NonEmpty a_a4nu -> GHC.Types.Bool
          [LclId] =
              [$dEq_s8c1] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqNonEmpty_$c/= $dEq_s8c1 eta_B2 eta_B1; } in
        let {
          sat_s8c2 [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nu
               -> GHC.Base.NonEmpty a_a4nu -> GHC.Types.Bool
          [LclId] =
              [$dEq_s8c1] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqNonEmpty_$c== $dEq_s8c1 eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s8c2 sat_s8c3];

GHC.Base.$fOrdNonEmpty_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (GHC.Base.NonEmpty a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8c4]
        let {
          sat_s8c5 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>] :: GHC.Classes.Eq a_a4nL
          [LclId] =
              [$dOrd_s8c4] \u [] GHC.Classes.$p1Ord $dOrd_s8c4;
        } in  GHC.Base.$fEqNonEmpty sat_s8c5;

GHC.Base.$w$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8c6 ww_s8c7 ww1_s8c8 ww2_s8c9 ww3_s8ca]
        case GHC.Classes.compare w_s8c6 ww_s8c7 ww2_s8c9 of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ ->
              GHC.Classes.$fOrd[]_$ccompare w_s8c6 ww1_s8c8 ww3_s8ca;
          GHC.Types.GT -> GHC.Types.GT [];
        };

GHC.Base.$fOrdNonEmpty_$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s8cc w1_s8cd w2_s8ce]
        case w1_s8cd of {
          GHC.Base.:| ww1_s8cg [Occ=Once] ww2_s8ch [Occ=Once] ->
              case w2_s8ce of {
                GHC.Base.:| ww4_s8cj [Occ=Once] ww5_s8ck [Occ=Once] ->
                    GHC.Base.$w$ccompare w_s8cc ww1_s8cg ww2_s8ch ww4_s8cj ww5_s8ck;
              };
        };

GHC.Base.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8cl ww_s8cm ww1_s8cn ww2_s8co ww3_s8cp]
        case GHC.Classes.compare w_s8cl ww_s8cm ww2_s8co of {
          GHC.Types.LT -> GHC.Types.True [];
          GHC.Types.EQ -> GHC.Classes.$fOrd[]_$c< w_s8cl ww1_s8cn ww3_s8cp;
          GHC.Types.GT -> GHC.Types.False [];
        };

GHC.Base.$fOrdNonEmpty_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s8cr w1_s8cs w2_s8ct]
        case w1_s8cs of {
          GHC.Base.:| ww1_s8cv [Occ=Once] ww2_s8cw [Occ=Once] ->
              case w2_s8ct of {
                GHC.Base.:| ww4_s8cy [Occ=Once] ww5_s8cz [Occ=Once] ->
                    GHC.Base.$w$c< w_s8cr ww1_s8cv ww2_s8cw ww4_s8cy ww5_s8cz;
              };
        };

GHC.Base.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8cA ww_s8cB ww1_s8cC ww2_s8cD ww3_s8cE]
        case GHC.Classes.compare w_s8cA ww2_s8cD ww_s8cB of {
          GHC.Types.LT -> GHC.Types.False [];
          GHC.Types.EQ ->
              case GHC.Classes.$fOrd[]_$ccompare w_s8cA ww3_s8cE ww1_s8cC of {
                __DEFAULT -> GHC.Types.True [];
                GHC.Types.LT -> GHC.Types.False [];
              };
          GHC.Types.GT -> GHC.Types.True [];
        };

GHC.Base.$fOrdNonEmpty_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s8cH w1_s8cI w2_s8cJ]
        case w1_s8cI of {
          GHC.Base.:| ww1_s8cL [Occ=Once] ww2_s8cM [Occ=Once] ->
              case w2_s8cJ of {
                GHC.Base.:| ww4_s8cO [Occ=Once] ww5_s8cP [Occ=Once] ->
                    GHC.Base.$w$c<= w_s8cH ww1_s8cL ww2_s8cM ww4_s8cO ww5_s8cP;
              };
        };

GHC.Base.$fOrdNonEmpty_$cmax [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8cQ w1_s8cR w2_s8cS]
        case w1_s8cR of ww_s8cT {
          GHC.Base.:| ww1_s8cU [Occ=Once] ww2_s8cV [Occ=Once] ->
              case w2_s8cS of ww3_s8cW {
                GHC.Base.:| ww4_s8cX [Occ=Once] ww5_s8cY [Occ=Once] ->
                    case GHC.Classes.compare w_s8cQ ww4_s8cX ww1_s8cU of {
                      GHC.Types.LT -> ww_s8cT;
                      GHC.Types.EQ ->
                          case GHC.Classes.$fOrd[]_$ccompare w_s8cQ ww5_s8cY ww2_s8cV of {
                            __DEFAULT -> ww3_s8cW;
                            GHC.Types.LT -> ww_s8cT;
                          };
                      GHC.Types.GT -> ww3_s8cW;
                    };
              };
        };

GHC.Base.$fOrdNonEmpty_$cmin [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8d1 w1_s8d2 w2_s8d3]
        case w1_s8d2 of ww_s8d4 {
          GHC.Base.:| ww1_s8d5 [Occ=Once] ww2_s8d6 [Occ=Once] ->
              case w2_s8d3 of ww3_s8d7 {
                GHC.Base.:| ww4_s8d8 [Occ=Once] ww5_s8d9 [Occ=Once] ->
                    case GHC.Classes.compare w_s8d1 ww4_s8d8 ww1_s8d5 of {
                      GHC.Types.LT -> ww3_s8d7;
                      GHC.Types.EQ ->
                          case GHC.Classes.$fOrd[]_$ccompare w_s8d1 ww5_s8d9 ww2_s8d6 of {
                            __DEFAULT -> ww_s8d4;
                            GHC.Types.LT -> ww3_s8d7;
                          };
                      GHC.Types.GT -> ww_s8d4;
                    };
              };
        };

GHC.Base.$w$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8dc ww_s8dd ww1_s8de ww2_s8df ww3_s8dg]
        case GHC.Classes.compare w_s8dc ww_s8dd ww2_s8df of {
          GHC.Types.LT -> GHC.Types.False [];
          GHC.Types.EQ ->
              case GHC.Classes.$fOrd[]_$ccompare w_s8dc ww1_s8de ww3_s8dg of {
                __DEFAULT -> GHC.Types.True [];
                GHC.Types.LT -> GHC.Types.False [];
              };
          GHC.Types.GT -> GHC.Types.True [];
        };

GHC.Base.$fOrdNonEmpty_$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s8dj w1_s8dk w2_s8dl]
        case w1_s8dk of {
          GHC.Base.:| ww1_s8dn [Occ=Once] ww2_s8do [Occ=Once] ->
              case w2_s8dl of {
                GHC.Base.:| ww4_s8dq [Occ=Once] ww5_s8dr [Occ=Once] ->
                    GHC.Base.$w$c>= w_s8dj ww1_s8dn ww2_s8do ww4_s8dq ww5_s8dr;
              };
        };

GHC.Base.$fOrdNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (GHC.Base.NonEmpty a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_s8ds]
        let {
          sat_s8dC [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Base.NonEmpty a_a4nL
          [LclId] =
              [$dOrd_s8ds] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$cmin $dOrd_s8ds eta_B2 eta_B1; } in
        let {
          sat_s8dB [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Base.NonEmpty a_a4nL
          [LclId] =
              [$dOrd_s8ds] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$cmax $dOrd_s8ds eta_B2 eta_B1; } in
        let {
          sat_s8dA [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8ds] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$c>= $dOrd_s8ds eta_B2 eta_B1; } in
        let {
          sat_s8dz [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8ds] \r [a1_s8dx b_s8dy]
                  GHC.Base.$fOrdNonEmpty_$c< $dOrd_s8ds b_s8dy a1_s8dx; } in
        let {
          sat_s8dw [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8ds] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$c<= $dOrd_s8ds eta_B2 eta_B1; } in
        let {
          sat_s8dv [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8ds] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$c< $dOrd_s8ds eta_B2 eta_B1; } in
        let {
          sat_s8du [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s8ds] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$ccompare $dOrd_s8ds eta_B2 eta_B1; } in
        let {
          sat_s8dt [Occ=Once] :: GHC.Classes.Eq (GHC.Base.NonEmpty a_a4nL)
          [LclId] =
              [$dOrd_s8ds] \u [] GHC.Base.$fOrdNonEmpty_$cp1Ord $dOrd_s8ds;
        } in 
          GHC.Classes.C:Ord [sat_s8dt
                             sat_s8du
                             sat_s8dv
                             sat_s8dw
                             sat_s8dz
                             sat_s8dA
                             sat_s8dB
                             sat_s8dC];

GHC.Base.$fMonadIO_$cfail
  :: forall a. GHC.Base.String -> GHC.Types.IO a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [s_s8dD] GHC.IO.failIO s_s8dD;

GHC.Base.$fMonadIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicativeIO
                                     GHC.Base.$fMonadIO1
                                     GHC.Base.$fApplicativeIO2
                                     GHC.Base.$fApplicativeIO4
                                     GHC.Base.$fMonadIO_$cfail];

GHC.Base.$fMonad[]_$cfail [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Base.String -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s8dE] [] [];

GHC.Base.$fMonad[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicative[]
                                     GHC.Base.$fMonad[]_$c>>=
                                     GHC.Base.$fApplicative[]_$c*>
                                     GHC.Base.$fApplicative[]_$cpure
                                     GHC.Base.$fMonad[]_$cfail];

GHC.Base.$fMonadPlus[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [GHC.Base.$fAlternative[]
                                         GHC.Base.$fMonad[]
                                         GHC.Types.[]
                                         GHC.Base.++];

GHC.Base.$fMonadMaybe_$c>>=
  :: forall a b.
     GHC.Base.Maybe a -> (a -> GHC.Base.Maybe b) -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s8dF k_s8dG]
        case ds_s8dF of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s8dI [Occ=Once] -> k_s8dG x_s8dI;
        };

GHC.Base.$fMonadMaybe_$cfail
  :: forall a. GHC.Base.String -> GHC.Base.Maybe a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s8dJ] GHC.Base.Nothing [];

GHC.Base.$fMonad(->)_$c>>=
  :: forall r a b. (r -> a) -> (a -> r -> b) -> r -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s8dK k_s8dL r1_s8dM]
        let {
          sat_s8dN [Occ=Once] :: a_a4tQ
          [LclId] =
              [f_s8dK r1_s8dM] \u [] f_s8dK r1_s8dM;
        } in  k_s8dL sat_s8dN r1_s8dM;

GHC.Base.$fMonad(,)_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a1 -> (a, b)) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><C(S),1*C1(U(U,U))>m,
 Unf=OtherCon []] =
    [] \r [w_s8dO w1_s8dP w2_s8dQ]
        case w1_s8dP of {
          (,) ww1_s8dS [Occ=Once] ww2_s8dT [Occ=Once] ->
              case w2_s8dQ ww2_s8dT of {
                (,) v_s8dV [Occ=Once] b1_s8dW [Occ=Once] ->
                    let {
                      sat_s8dY [Occ=Once] :: a_s6KB
                      [LclId] =
                          [w_s8dO ww1_s8dS v_s8dV] \u []
                              case GHC.Base.$p1Monoid w_s8dO of sat_s8dX {
                                __DEFAULT -> GHC.Base.<> sat_s8dX ww1_s8dS v_s8dV;
                              };
                    } in  (,) [sat_s8dY b1_s8dW];
              };
        };

GHC.Base.$fApplicative(,)_$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1 -> b) -> (a, a1) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,1*C1(U))><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8dZ w1_s8e0 w2_s8e1]
        case w1_s8e0 of {
          (,) ww1_s8e3 [Occ=Once] ww2_s8e4 [Occ=Once!] ->
              case w2_s8e1 of {
                (,) ww4_s8e6 [Occ=Once] ww5_s8e7 [Occ=Once] ->
                    let {
                      sat_s8ea [Occ=Once] :: b_s6KT
                      [LclId] =
                          [ww2_s8e4 ww5_s8e7] \u [] ww2_s8e4 ww5_s8e7; } in
                    let {
                      sat_s8e9 [Occ=Once] :: a_s6KQ
                      [LclId] =
                          [w_s8dZ ww1_s8e3 ww4_s8e6] \u []
                              case GHC.Base.$p1Monoid w_s8dZ of sat_s8e8 {
                                __DEFAULT -> GHC.Base.<> sat_s8e8 ww1_s8e3 ww4_s8e6;
                              };
                    } in  (,) [sat_s8e9 sat_s8ea];
              };
        };

GHC.Base.$fApplicative(,)_$c*>
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,A)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8eb a2_s8ec a3_s8ed]
        case a2_s8ec of {
          (,) x_s8ef [Occ=Once] _ [Occ=Dead] ->
              case a3_s8ed of {
                (,) v_s8ei [Occ=Once] x1_s8ej [Occ=Once] ->
                    let {
                      sat_s8el [Occ=Once] :: a_a4vv
                      [LclId] =
                          [$dMonoid_s8eb x_s8ef v_s8ei] \u []
                              case GHC.Base.$p1Monoid $dMonoid_s8eb of sat_s8ek {
                                __DEFAULT -> GHC.Base.<> sat_s8ek x_s8ef v_s8ei;
                              };
                    } in  (,) [sat_s8el x1_s8ej];
              };
        };

GHC.Base.$fApplicative(,)_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b c. (a1 -> b -> c) -> (a, a1) -> (a, b) -> (a, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8em w1_s8en w2_s8eo w3_s8ep]
        case w2_s8eo of {
          (,) ww1_s8er [Occ=Once] ww2_s8es [Occ=Once] ->
              case w3_s8ep of {
                (,) ww4_s8eu [Occ=Once] ww5_s8ev [Occ=Once] ->
                    let {
                      sat_s8ey [Occ=Once] :: c_s6Le
                      [LclId] =
                          [w1_s8en ww2_s8es ww5_s8ev] \u [] w1_s8en ww2_s8es ww5_s8ev; } in
                    let {
                      sat_s8ex [Occ=Once] :: a_s6La
                      [LclId] =
                          [w_s8em ww1_s8er ww4_s8eu] \u []
                              case GHC.Base.$p1Monoid w_s8em of sat_s8ew {
                                __DEFAULT -> GHC.Base.<> sat_s8ew ww1_s8er ww4_s8eu;
                              };
                    } in  (,) [sat_s8ex sat_s8ey];
              };
        };

GHC.Base.$fMonoid(,,,,)_$cmempty
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8ez
           $dMonoid1_s8eA
           $dMonoid2_s8eB
           $dMonoid3_s8eC
           $dMonoid4_s8eD]
        let {
          sat_s8eI [Occ=Once] :: e_a4x9
          [LclId] =
              [$dMonoid4_s8eD] \u [] GHC.Base.mempty $dMonoid4_s8eD; } in
        let {
          sat_s8eH [Occ=Once] :: d_a4x8
          [LclId] =
              [$dMonoid3_s8eC] \u [] GHC.Base.mempty $dMonoid3_s8eC; } in
        let {
          sat_s8eG [Occ=Once] :: c_a4x7
          [LclId] =
              [$dMonoid2_s8eB] \u [] GHC.Base.mempty $dMonoid2_s8eB; } in
        let {
          sat_s8eF [Occ=Once] :: b_a4x6
          [LclId] =
              [$dMonoid1_s8eA] \u [] GHC.Base.mempty $dMonoid1_s8eA; } in
        let {
          sat_s8eE [Occ=Once] :: a_a4x5
          [LclId] =
              [$dMonoid_s8ez] \u [] GHC.Base.mempty $dMonoid_s8ez;
        } in  (,,,,) [sat_s8eE sat_s8eF sat_s8eG sat_s8eH sat_s8eI];

GHC.Base.$fMonoid(,,,)_$cmempty
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8eJ $dMonoid1_s8eK $dMonoid2_s8eL $dMonoid3_s8eM]
        let {
          sat_s8eQ [Occ=Once] :: d_a4xM
          [LclId] =
              [$dMonoid3_s8eM] \u [] GHC.Base.mempty $dMonoid3_s8eM; } in
        let {
          sat_s8eP [Occ=Once] :: c_a4xL
          [LclId] =
              [$dMonoid2_s8eL] \u [] GHC.Base.mempty $dMonoid2_s8eL; } in
        let {
          sat_s8eO [Occ=Once] :: b_a4xK
          [LclId] =
              [$dMonoid1_s8eK] \u [] GHC.Base.mempty $dMonoid1_s8eK; } in
        let {
          sat_s8eN [Occ=Once] :: a_a4xJ
          [LclId] =
              [$dMonoid_s8eJ] \u [] GHC.Base.mempty $dMonoid_s8eJ;
        } in  (,,,) [sat_s8eN sat_s8eO sat_s8eP sat_s8eQ];

GHC.Base.$fMonoid(,,)_$cmempty
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     (a, b, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8eR $dMonoid1_s8eS $dMonoid2_s8eT]
        let {
          sat_s8eW [Occ=Once] :: c_a4yl
          [LclId] =
              [$dMonoid2_s8eT] \u [] GHC.Base.mempty $dMonoid2_s8eT; } in
        let {
          sat_s8eV [Occ=Once] :: b_a4yk
          [LclId] =
              [$dMonoid1_s8eS] \u [] GHC.Base.mempty $dMonoid1_s8eS; } in
        let {
          sat_s8eU [Occ=Once] :: a_a4yj
          [LclId] =
              [$dMonoid_s8eR] \u [] GHC.Base.mempty $dMonoid_s8eR;
        } in  (,,) [sat_s8eU sat_s8eV sat_s8eW];

GHC.Base.$fMonoid(,)_$cmempty
  :: forall a b. (GHC.Base.Monoid a, GHC.Base.Monoid b) => (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8eX $dMonoid1_s8eY]
        let {
          sat_s8f0 [Occ=Once] :: b_a4yQ
          [LclId] =
              [$dMonoid1_s8eY] \u [] GHC.Base.mempty $dMonoid1_s8eY; } in
        let {
          sat_s8eZ [Occ=Once] :: a_a4yP
          [LclId] =
              [$dMonoid_s8eX] \u [] GHC.Base.mempty $dMonoid_s8eX;
        } in  (,) [sat_s8eZ sat_s8f0];

GHC.Base.$fMonoid(,)_$cmconcat
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     [(a, b)] -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8f1 $dMonoid1_s8f2 eta_s8f3]
        let {
          $dSemigroup_s8f4 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_a4yP
          [LclId] =
              [$dMonoid_s8f1] \u [] GHC.Base.$p1Monoid $dMonoid_s8f1; } in
        let {
          $dSemigroup1_s8f5 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_a4yQ
          [LclId] =
              [$dMonoid1_s8f2] \u [] GHC.Base.$p1Monoid $dMonoid1_s8f2; } in
        let {
          z_s8f6 [Occ=OnceL] :: a_a4yP
          [LclId] =
              [$dMonoid_s8f1] \u [] GHC.Base.mempty $dMonoid_s8f1; } in
        let {
          z1_s8f7 [Occ=OnceL] :: b_a4yQ
          [LclId] =
              [$dMonoid1_s8f2] \u [] GHC.Base.mempty $dMonoid1_s8f2; } in
        let {
          z2_s8f8 [Occ=OnceL, Dmd=<S,U(U,U)>] :: (a_a4yP, b_a4yQ)
          [LclId, Unf=OtherCon []] =
              CCCS (,)! [z_s8f6 z1_s8f7]; } in
        let {
          go_s8f9 [Occ=LoopBreaker] :: [(a_a4yP, b_a4yQ)] -> (a_a4yP, b_a4yQ)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_s8f4
                        $dSemigroup1_s8f5
                        z2_s8f8
                        go_s8f9] \r [ds_s8fa]
                  case ds_s8fa of {
                    [] -> z2_s8f8;
                    : y_s8fc [Occ=Once!] ys_s8fd [Occ=Once] ->
                        case y_s8fc of {
                          (,) a1_s8ff [Occ=Once] b1_s8fg [Occ=Once] ->
                              case go_s8f9 ys_s8fd of {
                                (,) a'_s8fi [Occ=Once] b'_s8fj [Occ=Once] ->
                                    let {
                                      sat_s8fl [Occ=Once] :: b_a4yQ
                                      [LclId] =
                                          [$dSemigroup1_s8f5 b1_s8fg b'_s8fj] \u []
                                              GHC.Base.<> $dSemigroup1_s8f5 b1_s8fg b'_s8fj; } in
                                    let {
                                      sat_s8fk [Occ=Once] :: a_a4yP
                                      [LclId] =
                                          [$dSemigroup_s8f4 a1_s8ff a'_s8fi] \u []
                                              GHC.Base.<> $dSemigroup_s8f4 a1_s8ff a'_s8fi;
                                    } in  (,) [sat_s8fk sat_s8fl];
                              };
                        };
                  };
        } in  go_s8f9 eta_s8f3;

GHC.Base.$fMonoid()_$cmconcat :: [()] -> ()
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s8fm] () [];

GHC.Base.$fMonoidMaybe_$c<>
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8fn ds_s8fo b_s8fp]
        case ds_s8fo of wild_s8fq {
          GHC.Base.Nothing -> b_s8fp;
          GHC.Base.Just ipv_s8fr [Occ=Once] ->
              case b_s8fp of {
                GHC.Base.Nothing -> wild_s8fq;
                GHC.Base.Just ipv1_s8ft [Occ=Once] ->
                    let {
                      sat_s8fu [Occ=Once] :: a_a4AP
                      [LclId] =
                          [$dSemigroup_s8fn ipv_s8fr ipv1_s8ft] \u []
                              GHC.Base.<> $dSemigroup_s8fn ipv_s8fr ipv1_s8ft;
                    } in  GHC.Base.Just [sat_s8fu];
              };
        };

GHC.Base.$w$csconcat5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Maybe a -> [GHC.Base.Maybe a] -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8fv ww_s8fw ww1_s8fx]
        let {
          go_s8fy [Occ=LoopBreaker]
            :: GHC.Base.Maybe a_s6LE
               -> [GHC.Base.Maybe a_s6LE] -> GHC.Base.Maybe a_s6LE
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s8fv go_s8fy] \r [b_s8fz ds_s8fA]
                  case ds_s8fA of {
                    [] -> b_s8fz;
                    : c_s8fC [Occ=Once*] cs_s8fD [Occ=Once*] ->
                        case b_s8fz of wild1_s8fE {
                          GHC.Base.Nothing -> go_s8fy c_s8fC cs_s8fD;
                          GHC.Base.Just ipv_s8fF [Occ=Once] ->
                              case go_s8fy c_s8fC cs_s8fD of {
                                GHC.Base.Nothing -> wild1_s8fE;
                                GHC.Base.Just ipv1_s8fH [Occ=Once] ->
                                    let {
                                      sat_s8fI [Occ=Once] :: a_s6LE
                                      [LclId] =
                                          [w_s8fv ipv_s8fF ipv1_s8fH] \u []
                                              GHC.Base.<> w_s8fv ipv_s8fF ipv1_s8fH;
                                    } in  GHC.Base.Just [sat_s8fI];
                              };
                        };
                  };
        } in  go_s8fy ww_s8fw ww1_s8fx;

GHC.Base.$fSemigroupMaybe_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (GHC.Base.Maybe a) -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s8fJ w1_s8fK]
        case w1_s8fK of {
          GHC.Base.:| ww1_s8fM [Occ=Once] ww2_s8fN [Occ=Once] ->
              GHC.Base.$w$csconcat5 w_s8fJ ww1_s8fM ww2_s8fN;
        };

GHC.Base.$fSemigroupMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (GHC.Base.Maybe a)
[GblId[DFunId], Arity=1, Str=<L,U(U,U,U)>m] =
    [] \r [$dSemigroup_s8fO]
        let {
          sat_s8fS [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> GHC.Base.Maybe a_a4AP -> GHC.Base.Maybe a_a4AP
          [LclId] =
              [$dSemigroup_s8fO] \r [$dIntegral_s8fR]
                  Data.Semigroup.Internal.stimesMaybe
                      $dIntegral_s8fR $dSemigroup_s8fO; } in
        let {
          sat_s8fQ [Occ=Once]
            :: GHC.Base.NonEmpty (GHC.Base.Maybe a_a4AP)
               -> GHC.Base.Maybe a_a4AP
          [LclId] =
              [$dSemigroup_s8fO] \r [eta_B1]
                  GHC.Base.$fSemigroupMaybe_$csconcat $dSemigroup_s8fO eta_B1; } in
        let {
          sat_s8fP [Occ=Once]
            :: GHC.Base.Maybe a_a4AP
               -> GHC.Base.Maybe a_a4AP -> GHC.Base.Maybe a_a4AP
          [LclId] =
              [$dSemigroup_s8fO] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_s8fO eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s8fP sat_s8fQ sat_s8fS];

GHC.Base.$fMonoidMaybe_$cmconcat
  :: forall a.
     GHC.Base.Semigroup a =>
     [GHC.Base.Maybe a] -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8fT eta_s8fU]
        let {
          go_s8fV [Occ=LoopBreaker]
            :: [GHC.Base.Maybe a_a4wo] -> GHC.Base.Maybe a_a4wo
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_s8fT go_s8fV] \r [ds_s8fW]
                  case ds_s8fW of {
                    [] -> GHC.Base.Nothing [];
                    : y_s8fY [Occ=Once!] ys_s8fZ [Occ=Once*] ->
                        case y_s8fY of wild1_s8g0 {
                          GHC.Base.Nothing -> go_s8fV ys_s8fZ;
                          GHC.Base.Just ipv_s8g1 [Occ=Once] ->
                              case go_s8fV ys_s8fZ of {
                                GHC.Base.Nothing -> wild1_s8g0;
                                GHC.Base.Just ipv1_s8g3 [Occ=Once] ->
                                    let {
                                      sat_s8g4 [Occ=Once] :: a_a4wo
                                      [LclId] =
                                          [$dSemigroup_s8fT ipv_s8g1 ipv1_s8g3] \u []
                                              GHC.Base.<> $dSemigroup_s8fT ipv_s8g1 ipv1_s8g3;
                                    } in  GHC.Base.Just [sat_s8g4];
                              };
                        };
                  };
        } in  go_s8fV eta_s8fU;

GHC.Base.$fMonoidMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Monoid (GHC.Base.Maybe a)
[GblId[DFunId], Arity=1, Str=<L,U(U,U,U)>m] =
    [] \r [$dSemigroup_s8g5]
        let {
          sat_s8g8 [Occ=Once]
            :: [GHC.Base.Maybe a_a4wo] -> GHC.Base.Maybe a_a4wo
          [LclId] =
              [$dSemigroup_s8g5] \r [eta_B1]
                  GHC.Base.$fMonoidMaybe_$cmconcat $dSemigroup_s8g5 eta_B1; } in
        let {
          sat_s8g7 [Occ=Once]
            :: GHC.Base.Maybe a_a4wo
               -> GHC.Base.Maybe a_a4wo -> GHC.Base.Maybe a_a4wo
          [LclId] =
              [$dSemigroup_s8g5] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_s8g5 eta_B2 eta_B1; } in
        let {
          sat_s8g6 [Occ=Once] :: GHC.Base.Semigroup (GHC.Base.Maybe a_a4wo)
          [LclId] =
              [$dSemigroup_s8g5] \u []
                  GHC.Base.$fSemigroupMaybe $dSemigroup_s8g5;
        } in 
          GHC.Base.C:Monoid [sat_s8g6 GHC.Base.Nothing sat_s8g7 sat_s8g8];

GHC.Base.$fMonoidOrdering_$c<>
  :: GHC.Types.Ordering -> GHC.Types.Ordering -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s8g9 ds1_s8ga]
        case ds_s8g9 of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ -> ds1_s8ga;
          GHC.Types.GT -> GHC.Types.GT [];
        };

GHC.Base.$fMonoidOrdering_go [Occ=LoopBreaker]
  :: [GHC.Types.Ordering] -> GHC.Types.Ordering
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s8gc]
        case ds_s8gc of {
          [] -> GHC.Types.EQ [];
          : y_s8ge [Occ=Once!] ys_s8gf [Occ=Once] ->
              case y_s8ge of {
                GHC.Types.LT -> GHC.Types.LT [];
                GHC.Types.EQ -> GHC.Base.$fMonoidOrdering_go ys_s8gf;
                GHC.Types.GT -> GHC.Types.GT [];
              };
        };

GHC.Base.$fSemigroupOrdering [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup GHC.Types.Ordering
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.$fMonoidOrdering_$c<>
                                         GHC.Base.$fSemigroupOrdering_$csconcat
                                         GHC.Base.$fSemigroupOrdering_$cstimes];
GHC.Base.$fMonoidOrdering [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid GHC.Types.Ordering
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [GHC.Base.$fSemigroupOrdering
                                      GHC.Types.EQ
                                      GHC.Base.$fMonoidOrdering_$c<>
                                      GHC.Base.$fMonoidOrdering_go];
GHC.Base.$fSemigroupOrdering_$cstimes [Occ=LoopBreaker]
  :: forall b.
     GHC.Real.Integral b =>
     b -> GHC.Types.Ordering -> GHC.Types.Ordering
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_s8gh]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s8gh GHC.Base.$fMonoidOrdering;

GHC.Base.$fMonoid(,,,,)_$c<>
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U,U,U)><S,1*U(U,U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8gi
           $dSemigroup1_s8gj
           $dSemigroup2_s8gk
           $dSemigroup3_s8gl
           $dSemigroup4_s8gm
           ds_s8gn
           ds1_s8go]
        case ds_s8gn of {
          (,,,,) a1_s8gq [Occ=Once]
                 b1_s8gr [Occ=Once]
                 c1_s8gs [Occ=Once]
                 d1_s8gt [Occ=Once]
                 e1_s8gu [Occ=Once] ->
              case ds1_s8go of {
                (,,,,) a'_s8gw [Occ=Once]
                       b'_s8gx [Occ=Once]
                       c'_s8gy [Occ=Once]
                       d'_s8gz [Occ=Once]
                       e'_s8gA [Occ=Once] ->
                    let {
                      sat_s8gF [Occ=Once] :: e_a4BK
                      [LclId] =
                          [$dSemigroup4_s8gm e1_s8gu e'_s8gA] \u []
                              GHC.Base.<> $dSemigroup4_s8gm e1_s8gu e'_s8gA; } in
                    let {
                      sat_s8gE [Occ=Once] :: d_a4BJ
                      [LclId] =
                          [$dSemigroup3_s8gl d1_s8gt d'_s8gz] \u []
                              GHC.Base.<> $dSemigroup3_s8gl d1_s8gt d'_s8gz; } in
                    let {
                      sat_s8gD [Occ=Once] :: c_a4BI
                      [LclId] =
                          [$dSemigroup2_s8gk c1_s8gs c'_s8gy] \u []
                              GHC.Base.<> $dSemigroup2_s8gk c1_s8gs c'_s8gy; } in
                    let {
                      sat_s8gC [Occ=Once] :: b_a4BH
                      [LclId] =
                          [$dSemigroup1_s8gj b1_s8gr b'_s8gx] \u []
                              GHC.Base.<> $dSemigroup1_s8gj b1_s8gr b'_s8gx; } in
                    let {
                      sat_s8gB [Occ=Once] :: a_a4BG
                      [LclId] =
                          [$dSemigroup_s8gi a1_s8gq a'_s8gw] \u []
                              GHC.Base.<> $dSemigroup_s8gi a1_s8gq a'_s8gw;
                    } in  (,,,,) [sat_s8gB sat_s8gC sat_s8gD sat_s8gE sat_s8gF];
              };
        };

GHC.Base.$fMonoid(,,,,)_$csconcat
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     GHC.Base.NonEmpty (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U,U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8gG
           $dSemigroup1_s8gH
           $dSemigroup2_s8gI
           $dSemigroup3_s8gJ
           $dSemigroup4_s8gK
           ds_s8gL]
        case ds_s8gL of {
          GHC.Base.:| a1_s8gN [Occ=Once!] as_s8gO [Occ=Once] ->
              case a1_s8gN of {
                (,,,,) ww1_s8gQ [Occ=Once]
                       ww2_s8gR [Occ=Once]
                       ww3_s8gS [Occ=Once]
                       ww4_s8gT [Occ=Once]
                       ww5_s8gU [Occ=Once] ->
                    let {
                      $wgo_s8gV [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                        :: a_a4BG
                           -> b_a4BH
                           -> c_a4BI
                           -> d_a4BJ
                           -> e_a4BK
                           -> [(a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)]
                           -> (# a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK #)
                      [LclId,
                       Arity=6,
                       Str=<L,U><L,U><L,U><L,U><L,U><S,1*U>,
                       Unf=OtherCon []] =
                          sat-only [$dSemigroup_s8gG
                                    $dSemigroup1_s8gH
                                    $dSemigroup2_s8gI
                                    $dSemigroup3_s8gJ
                                    $dSemigroup4_s8gK
                                    $wgo_s8gV] \r [ww6_s8gW
                                                   ww7_s8gX
                                                   ww8_s8gY
                                                   ww9_s8gZ
                                                   ww10_s8h0
                                                   w_s8h1]
                              case w_s8h1 of {
                                [] -> (#,,,,#) [ww6_s8gW ww7_s8gX ww8_s8gY ww9_s8gZ ww10_s8h0];
                                : c1_s8h3 [Occ=Once!] cs_s8h4 [Occ=Once] ->
                                    case c1_s8h3 of {
                                      (,,,,) ww12_s8h6 [Occ=Once]
                                             ww13_s8h7 [Occ=Once]
                                             ww14_s8h8 [Occ=Once]
                                             ww15_s8h9 [Occ=Once]
                                             ww16_s8ha [Occ=Once] ->
                                          case
                                              $wgo_s8gV
                                                  ww12_s8h6
                                                  ww13_s8h7
                                                  ww14_s8h8
                                                  ww15_s8h9
                                                  ww16_s8ha
                                                  cs_s8h4
                                          of
                                          { (#,,,,#) ww18_s8hc [Occ=Once]
                                                     ww19_s8hd [Occ=Once]
                                                     ww20_s8he [Occ=Once]
                                                     ww21_s8hf [Occ=Once]
                                                     ww22_s8hg [Occ=Once] ->
                                                let {
                                                  sat_s8hl [Occ=Once] :: e_a4BK
                                                  [LclId] =
                                                      [$dSemigroup4_s8gK ww10_s8h0 ww22_s8hg] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup4_s8gK
                                                              ww10_s8h0
                                                              ww22_s8hg; } in
                                                let {
                                                  sat_s8hk [Occ=Once] :: d_a4BJ
                                                  [LclId] =
                                                      [$dSemigroup3_s8gJ ww9_s8gZ ww21_s8hf] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup3_s8gJ
                                                              ww9_s8gZ
                                                              ww21_s8hf; } in
                                                let {
                                                  sat_s8hj [Occ=Once] :: c_a4BI
                                                  [LclId] =
                                                      [$dSemigroup2_s8gI ww8_s8gY ww20_s8he] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup2_s8gI
                                                              ww8_s8gY
                                                              ww20_s8he; } in
                                                let {
                                                  sat_s8hi [Occ=Once] :: b_a4BH
                                                  [LclId] =
                                                      [$dSemigroup1_s8gH ww7_s8gX ww19_s8hd] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup1_s8gH
                                                              ww7_s8gX
                                                              ww19_s8hd; } in
                                                let {
                                                  sat_s8hh [Occ=Once] :: a_a4BG
                                                  [LclId] =
                                                      [$dSemigroup_s8gG ww6_s8gW ww18_s8hc] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup_s8gG ww6_s8gW ww18_s8hc;
                                                } in 
                                                  (#,,,,#) [sat_s8hh
                                                            sat_s8hi
                                                            sat_s8hj
                                                            sat_s8hk
                                                            sat_s8hl];
                                          };
                                    };
                              };
                    } in 
                      case
                          $wgo_s8gV ww1_s8gQ ww2_s8gR ww3_s8gS ww4_s8gT ww5_s8gU as_s8gO
                      of
                      { (#,,,,#) ww7_s8hn [Occ=Once]
                                 ww8_s8ho [Occ=Once]
                                 ww9_s8hp [Occ=Once]
                                 ww10_s8hq [Occ=Once]
                                 ww11_s8hr [Occ=Once] ->
                            (,,,,) [ww7_s8hn ww8_s8ho ww9_s8hp ww10_s8hq ww11_s8hr];
                      };
              };
        };

GHC.Base.$fMonoid(,,,,)_$cstimes
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     forall b1.
     GHC.Real.Integral b1 =>
     b1 -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8hs
           $dSemigroup1_s8ht
           $dSemigroup2_s8hu
           $dSemigroup3_s8hv
           $dSemigroup4_s8hw
           $dIntegral_s8hx
           n_s8hy
           ds_s8hz]
        case ds_s8hz of {
          (,,,,) a1_s8hB [Occ=Once]
                 b2_s8hC [Occ=Once]
                 c1_s8hD [Occ=Once]
                 d1_s8hE [Occ=Once]
                 e1_s8hF [Occ=Once] ->
              let {
                sat_s8hK [Occ=Once] :: e_a4BK
                [LclId] =
                    [$dSemigroup4_s8hw $dIntegral_s8hx n_s8hy e1_s8hF] \u []
                        GHC.Base.stimes
                            $dSemigroup4_s8hw $dIntegral_s8hx n_s8hy e1_s8hF; } in
              let {
                sat_s8hJ [Occ=Once] :: d_a4BJ
                [LclId] =
                    [$dSemigroup3_s8hv $dIntegral_s8hx n_s8hy d1_s8hE] \u []
                        GHC.Base.stimes
                            $dSemigroup3_s8hv $dIntegral_s8hx n_s8hy d1_s8hE; } in
              let {
                sat_s8hI [Occ=Once] :: c_a4BI
                [LclId] =
                    [$dSemigroup2_s8hu $dIntegral_s8hx n_s8hy c1_s8hD] \u []
                        GHC.Base.stimes
                            $dSemigroup2_s8hu $dIntegral_s8hx n_s8hy c1_s8hD; } in
              let {
                sat_s8hH [Occ=Once] :: b_a4BH
                [LclId] =
                    [$dSemigroup1_s8ht $dIntegral_s8hx n_s8hy b2_s8hC] \u []
                        GHC.Base.stimes
                            $dSemigroup1_s8ht $dIntegral_s8hx n_s8hy b2_s8hC; } in
              let {
                sat_s8hG [Occ=Once] :: a_a4BG
                [LclId] =
                    [$dSemigroup_s8hs $dIntegral_s8hx n_s8hy a1_s8hB] \u []
                        GHC.Base.stimes $dSemigroup_s8hs $dIntegral_s8hx n_s8hy a1_s8hB;
              } in  (,,,,) [sat_s8hG sat_s8hH sat_s8hI sat_s8hJ sat_s8hK];
        };

GHC.Base.$fSemigroup(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     GHC.Base.Semigroup (a, b, c, d, e)
[GblId[DFunId],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s8hL
           $dSemigroup1_s8hM
           $dSemigroup2_s8hN
           $dSemigroup3_s8hO
           $dSemigroup4_s8hP]
        let {
          sat_s8hS [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
          [LclId] =
              [$dSemigroup_s8hL
               $dSemigroup1_s8hM
               $dSemigroup2_s8hN
               $dSemigroup3_s8hO
               $dSemigroup4_s8hP] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$cstimes
                      $dSemigroup_s8hL
                      $dSemigroup1_s8hM
                      $dSemigroup2_s8hN
                      $dSemigroup3_s8hO
                      $dSemigroup4_s8hP
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_s8hR [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
          [LclId] =
              [$dSemigroup_s8hL
               $dSemigroup1_s8hM
               $dSemigroup2_s8hN
               $dSemigroup3_s8hO
               $dSemigroup4_s8hP] \r [eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$csconcat
                      $dSemigroup_s8hL
                      $dSemigroup1_s8hM
                      $dSemigroup2_s8hN
                      $dSemigroup3_s8hO
                      $dSemigroup4_s8hP
                      eta_B1; } in
        let {
          sat_s8hQ [Occ=Once]
            :: (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
          [LclId] =
              [$dSemigroup_s8hL
               $dSemigroup1_s8hM
               $dSemigroup2_s8hN
               $dSemigroup3_s8hO
               $dSemigroup4_s8hP] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$c<>
                      $dSemigroup_s8hL
                      $dSemigroup1_s8hM
                      $dSemigroup2_s8hN
                      $dSemigroup3_s8hO
                      $dSemigroup4_s8hP
                      eta_B2
                      eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s8hQ sat_s8hR sat_s8hS];

GHC.Base.$w$cp1Monoid1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     (# (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e),
        GHC.Base.NonEmpty (a, b, c, d, e) -> (a, b, c, d, e),
        forall b1.
        GHC.Real.Integral b1 =>
        b1 -> (a, b, c, d, e) -> (a, b, c, d, e) #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [w_s8hT w1_s8hU w2_s8hV w3_s8hW w4_s8hX]
        let {
          sat_s8ie [Occ=OnceL] :: GHC.Base.Semigroup e_s6Nx
          [LclId] =
              [w4_s8hX] \u [] GHC.Base.$p1Monoid w4_s8hX; } in
        let {
          sat_s8id [Occ=OnceL] :: GHC.Base.Semigroup d_s6Nw
          [LclId] =
              [w3_s8hW] \u [] GHC.Base.$p1Monoid w3_s8hW; } in
        let {
          sat_s8ic [Occ=OnceL] :: GHC.Base.Semigroup c_s6Nv
          [LclId] =
              [w2_s8hV] \u [] GHC.Base.$p1Monoid w2_s8hV; } in
        let {
          sat_s8ib [Occ=OnceL] :: GHC.Base.Semigroup b_s6Nu
          [LclId] =
              [w1_s8hU] \u [] GHC.Base.$p1Monoid w1_s8hU; } in
        let {
          sat_s8ia [Occ=OnceL] :: GHC.Base.Semigroup a_s6Nt
          [LclId] =
              [w_s8hT] \u [] GHC.Base.$p1Monoid w_s8hT; } in
        let {
          sat_s8if [Occ=Once]
            :: forall b1.
               GHC.Real.Integral b1 =>
               b1
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
          [LclId] =
              [sat_s8ia sat_s8ib sat_s8ic sat_s8id sat_s8ie] \r [eta_B3
                                                                 eta_B2
                                                                 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$cstimes
                      sat_s8ia
                      sat_s8ib
                      sat_s8ic
                      sat_s8id
                      sat_s8ie
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_s8i8 [Occ=OnceL] :: GHC.Base.Semigroup e_s6Nx
          [LclId] =
              [w4_s8hX] \u [] GHC.Base.$p1Monoid w4_s8hX; } in
        let {
          sat_s8i7 [Occ=OnceL] :: GHC.Base.Semigroup d_s6Nw
          [LclId] =
              [w3_s8hW] \u [] GHC.Base.$p1Monoid w3_s8hW; } in
        let {
          sat_s8i6 [Occ=OnceL] :: GHC.Base.Semigroup c_s6Nv
          [LclId] =
              [w2_s8hV] \u [] GHC.Base.$p1Monoid w2_s8hV; } in
        let {
          sat_s8i5 [Occ=OnceL] :: GHC.Base.Semigroup b_s6Nu
          [LclId] =
              [w1_s8hU] \u [] GHC.Base.$p1Monoid w1_s8hU; } in
        let {
          sat_s8i4 [Occ=OnceL] :: GHC.Base.Semigroup a_s6Nt
          [LclId] =
              [w_s8hT] \u [] GHC.Base.$p1Monoid w_s8hT; } in
        let {
          sat_s8i9 [Occ=Once]
            :: GHC.Base.NonEmpty (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
          [LclId] =
              [sat_s8i4 sat_s8i5 sat_s8i6 sat_s8i7 sat_s8i8] \r [eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$csconcat
                      sat_s8i4 sat_s8i5 sat_s8i6 sat_s8i7 sat_s8i8 eta_B1; } in
        let {
          sat_s8i2 [Occ=OnceL] :: GHC.Base.Semigroup e_s6Nx
          [LclId] =
              [w4_s8hX] \u [] GHC.Base.$p1Monoid w4_s8hX; } in
        let {
          sat_s8i1 [Occ=OnceL] :: GHC.Base.Semigroup d_s6Nw
          [LclId] =
              [w3_s8hW] \u [] GHC.Base.$p1Monoid w3_s8hW; } in
        let {
          sat_s8i0 [Occ=OnceL] :: GHC.Base.Semigroup c_s6Nv
          [LclId] =
              [w2_s8hV] \u [] GHC.Base.$p1Monoid w2_s8hV; } in
        let {
          sat_s8hZ [Occ=OnceL] :: GHC.Base.Semigroup b_s6Nu
          [LclId] =
              [w1_s8hU] \u [] GHC.Base.$p1Monoid w1_s8hU; } in
        let {
          sat_s8hY [Occ=OnceL] :: GHC.Base.Semigroup a_s6Nt
          [LclId] =
              [w_s8hT] \u [] GHC.Base.$p1Monoid w_s8hT; } in
        let {
          sat_s8i3 [Occ=Once]
            :: (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
          [LclId] =
              [sat_s8hY sat_s8hZ sat_s8i0 sat_s8i1 sat_s8i2] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$c<>
                      sat_s8hY sat_s8hZ sat_s8i0 sat_s8i1 sat_s8i2 eta_B2 eta_B1;
        } in  (#,,#) [sat_s8i3 sat_s8i9 sat_s8if];

GHC.Base.$fMonoid(,,,,)_$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     GHC.Base.Semigroup (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [w_s8ig w1_s8ih w2_s8ii w3_s8ij w4_s8ik]
        case
            GHC.Base.$w$cp1Monoid1 w_s8ig w1_s8ih w2_s8ii w3_s8ij w4_s8ik
        of
        { (#,,#) ww1_s8im [Occ=Once]
                 ww2_s8in [Occ=Once]
                 ww3_s8io [Occ=Once] ->
              GHC.Base.C:Semigroup [ww1_s8im ww2_s8in ww3_s8io];
        };

GHC.Base.$fMonoid(,,,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8ip
           $dMonoid1_s8iq
           $dMonoid2_s8ir
           $dMonoid3_s8is
           $dMonoid4_s8it]
        case
            GHC.Base.$w$cp1Monoid1
                $dMonoid_s8ip
                $dMonoid1_s8iq
                $dMonoid2_s8ir
                $dMonoid3_s8is
                $dMonoid4_s8it
        of
        { (#,,#) ww1_s8iv [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> ww1_s8iv;
        };

GHC.Base.$fMonoid(,,,,)_$cmconcat
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     [(a, b, c, d, e)] -> (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8iy
           $dMonoid1_s8iz
           $dMonoid2_s8iA
           $dMonoid3_s8iB
           $dMonoid4_s8iC]
        let {
          k_s8iD [Occ=OnceL, Dmd=<L,1*U(1*C(C1(U(U,U,U,U,U))),A,A)>]
            :: GHC.Base.Semigroup (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_s8iy
               $dMonoid1_s8iz
               $dMonoid2_s8iA
               $dMonoid3_s8iB
               $dMonoid4_s8iC] \s []
                  case
                      GHC.Base.$w$cp1Monoid1
                          $dMonoid_s8iy
                          $dMonoid1_s8iz
                          $dMonoid2_s8iA
                          $dMonoid3_s8iB
                          $dMonoid4_s8iC
                  of
                  { (#,,#) ww1_s8iF [Occ=Once]
                           ww2_s8iG [Occ=Once]
                           ww3_s8iH [Occ=Once] ->
                        GHC.Base.C:Semigroup [ww1_s8iF ww2_s8iG ww3_s8iH];
                  }; } in
        let {
          k1_s8iI [Occ=OnceL!, Dmd=<L,C(C1(U(U,U,U,U,U)))>]
            :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [k_s8iD] \u [] GHC.Base.<> k_s8iD; } in
        let {
          z_s8iJ [Occ=OnceL] :: a_a4x5
          [LclId] =
              [$dMonoid_s8iy] \u [] GHC.Base.mempty $dMonoid_s8iy; } in
        let {
          z1_s8iK [Occ=OnceL] :: b_a4x6
          [LclId] =
              [$dMonoid1_s8iz] \u [] GHC.Base.mempty $dMonoid1_s8iz; } in
        let {
          z2_s8iL [Occ=OnceL] :: c_a4x7
          [LclId] =
              [$dMonoid2_s8iA] \u [] GHC.Base.mempty $dMonoid2_s8iA; } in
        let {
          z3_s8iM [Occ=OnceL] :: d_a4x8
          [LclId] =
              [$dMonoid3_s8iB] \u [] GHC.Base.mempty $dMonoid3_s8iB; } in
        let {
          z4_s8iN [Occ=OnceL] :: e_a4x9
          [LclId] =
              [$dMonoid4_s8iC] \u [] GHC.Base.mempty $dMonoid4_s8iC; } in
        let {
          z5_s8iO [Occ=OnceL, Dmd=<L,U(U,U,U,U,U)>]
            :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId, Unf=OtherCon []] =
              CCCS (,,,,)! [z_s8iJ z1_s8iK z2_s8iL z3_s8iM z4_s8iN]; } in
        let {
          go_s8iP [Occ=LoopBreaker]
            :: [(a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)]
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [k1_s8iI z5_s8iO go_s8iP] \r [ds_s8iQ]
                  case ds_s8iQ of {
                    [] -> z5_s8iO;
                    : y_s8iS [Occ=Once] ys_s8iT [Occ=Once] ->
                        let {
                          sat_s8iU [Occ=Once] :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
                          [LclId] =
                              [go_s8iP ys_s8iT] \u [] go_s8iP ys_s8iT;
                        } in  k1_s8iI y_s8iS sat_s8iU;
                  };
        } in  go_s8iP;

GHC.Base.$fMonoid(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     GHC.Base.Monoid (a, b, c, d, e)
[GblId[DFunId],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s8iV
           $dMonoid1_s8iW
           $dMonoid2_s8iX
           $dMonoid3_s8iY
           $dMonoid4_s8iZ]
        let {
          sat_s8j3 [Occ=Once]
            :: [(a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)]
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_s8iV
               $dMonoid1_s8iW
               $dMonoid2_s8iX
               $dMonoid3_s8iY
               $dMonoid4_s8iZ] \u []
                  GHC.Base.$fMonoid(,,,,)_$cmconcat
                      $dMonoid_s8iV
                      $dMonoid1_s8iW
                      $dMonoid2_s8iX
                      $dMonoid3_s8iY
                      $dMonoid4_s8iZ; } in
        let {
          sat_s8j2 [Occ=Once]
            :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_s8iV
               $dMonoid1_s8iW
               $dMonoid2_s8iX
               $dMonoid3_s8iY
               $dMonoid4_s8iZ] \u []
                  GHC.Base.$fMonoid(,,,,)_$cmappend
                      $dMonoid_s8iV
                      $dMonoid1_s8iW
                      $dMonoid2_s8iX
                      $dMonoid3_s8iY
                      $dMonoid4_s8iZ; } in
        let {
          sat_s8j1 [Occ=Once] :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_s8iV
               $dMonoid1_s8iW
               $dMonoid2_s8iX
               $dMonoid3_s8iY
               $dMonoid4_s8iZ] \u []
                  GHC.Base.$fMonoid(,,,,)_$cmempty
                      $dMonoid_s8iV
                      $dMonoid1_s8iW
                      $dMonoid2_s8iX
                      $dMonoid3_s8iY
                      $dMonoid4_s8iZ; } in
        let {
          sat_s8j0 [Occ=Once]
            :: GHC.Base.Semigroup (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_s8iV
               $dMonoid1_s8iW
               $dMonoid2_s8iX
               $dMonoid3_s8iY
               $dMonoid4_s8iZ] \u []
                  GHC.Base.$fMonoid(,,,,)_$cp1Monoid
                      $dMonoid_s8iV
                      $dMonoid1_s8iW
                      $dMonoid2_s8iX
                      $dMonoid3_s8iY
                      $dMonoid4_s8iZ;
        } in  GHC.Base.C:Monoid [sat_s8j0 sat_s8j1 sat_s8j2 sat_s8j3];

GHC.Base.$fMonoid(,,,)_$c<>
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U,U)><S,1*U(U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8j4
           $dSemigroup1_s8j5
           $dSemigroup2_s8j6
           $dSemigroup3_s8j7
           ds_s8j8
           ds1_s8j9]
        case ds_s8j8 of {
          (,,,) a1_s8jb [Occ=Once]
                b1_s8jc [Occ=Once]
                c1_s8jd [Occ=Once]
                d1_s8je [Occ=Once] ->
              case ds1_s8j9 of {
                (,,,) a'_s8jg [Occ=Once]
                      b'_s8jh [Occ=Once]
                      c'_s8ji [Occ=Once]
                      d'_s8jj [Occ=Once] ->
                    let {
                      sat_s8jn [Occ=Once] :: d_a4CF
                      [LclId] =
                          [$dSemigroup3_s8j7 d1_s8je d'_s8jj] \u []
                              GHC.Base.<> $dSemigroup3_s8j7 d1_s8je d'_s8jj; } in
                    let {
                      sat_s8jm [Occ=Once] :: c_a4CE
                      [LclId] =
                          [$dSemigroup2_s8j6 c1_s8jd c'_s8ji] \u []
                              GHC.Base.<> $dSemigroup2_s8j6 c1_s8jd c'_s8ji; } in
                    let {
                      sat_s8jl [Occ=Once] :: b_a4CD
                      [LclId] =
                          [$dSemigroup1_s8j5 b1_s8jc b'_s8jh] \u []
                              GHC.Base.<> $dSemigroup1_s8j5 b1_s8jc b'_s8jh; } in
                    let {
                      sat_s8jk [Occ=Once] :: a_a4CC
                      [LclId] =
                          [$dSemigroup_s8j4 a1_s8jb a'_s8jg] \u []
                              GHC.Base.<> $dSemigroup_s8j4 a1_s8jb a'_s8jg;
                    } in  (,,,) [sat_s8jk sat_s8jl sat_s8jm sat_s8jn];
              };
        };

GHC.Base.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     a -> b -> c -> d -> [(a, b, c, d)] -> (# a, b, c, d #)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8jo
           w1_s8jp
           w2_s8jq
           w3_s8jr
           ww_s8js
           ww1_s8jt
           ww2_s8ju
           ww3_s8jv
           ww4_s8jw]
        let {
          $wgo_s8jx [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: a_s6Ow
               -> b_s6Ox
               -> c_s6Oy
               -> d_s6Oz
               -> [(a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz)]
               -> (# a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz #)
          [LclId,
           Arity=5,
           Str=<L,U><L,U><L,U><L,U><S,1*U>,
           Unf=OtherCon []] =
              sat-only [w_s8jo w1_s8jp w2_s8jq w3_s8jr $wgo_s8jx] \r [ww5_s8jy
                                                                      ww6_s8jz
                                                                      ww7_s8jA
                                                                      ww8_s8jB
                                                                      w4_s8jC]
                  case w4_s8jC of {
                    [] -> (#,,,#) [ww5_s8jy ww6_s8jz ww7_s8jA ww8_s8jB];
                    : c1_s8jE [Occ=Once!] cs_s8jF [Occ=Once] ->
                        case c1_s8jE of {
                          (,,,) ww10_s8jH [Occ=Once]
                                ww11_s8jI [Occ=Once]
                                ww12_s8jJ [Occ=Once]
                                ww13_s8jK [Occ=Once] ->
                              case $wgo_s8jx ww10_s8jH ww11_s8jI ww12_s8jJ ww13_s8jK cs_s8jF of {
                                (#,,,#) ww15_s8jM [Occ=Once]
                                        ww16_s8jN [Occ=Once]
                                        ww17_s8jO [Occ=Once]
                                        ww18_s8jP [Occ=Once] ->
                                    let {
                                      sat_s8jT [Occ=Once] :: d_s6Oz
                                      [LclId] =
                                          [w3_s8jr ww8_s8jB ww18_s8jP] \u []
                                              GHC.Base.<> w3_s8jr ww8_s8jB ww18_s8jP; } in
                                    let {
                                      sat_s8jS [Occ=Once] :: c_s6Oy
                                      [LclId] =
                                          [w2_s8jq ww7_s8jA ww17_s8jO] \u []
                                              GHC.Base.<> w2_s8jq ww7_s8jA ww17_s8jO; } in
                                    let {
                                      sat_s8jR [Occ=Once] :: b_s6Ox
                                      [LclId] =
                                          [w1_s8jp ww6_s8jz ww16_s8jN] \u []
                                              GHC.Base.<> w1_s8jp ww6_s8jz ww16_s8jN; } in
                                    let {
                                      sat_s8jQ [Occ=Once] :: a_s6Ow
                                      [LclId] =
                                          [w_s8jo ww5_s8jy ww15_s8jM] \u []
                                              GHC.Base.<> w_s8jo ww5_s8jy ww15_s8jM;
                                    } in  (#,,,#) [sat_s8jQ sat_s8jR sat_s8jS sat_s8jT];
                              };
                        };
                  };
        } in  $wgo_s8jx ww_s8js ww1_s8jt ww2_s8ju ww3_s8jv ww4_s8jw;

GHC.Base.$fSemigroup(,,,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     GHC.Base.NonEmpty (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8jU w1_s8jV w2_s8jW w3_s8jX w4_s8jY]
        case w4_s8jY of {
          GHC.Base.:| ww1_s8k0 [Occ=Once!] ww2_s8k1 [Occ=Once] ->
              case ww1_s8k0 of {
                (,,,) ww4_s8k3 [Occ=Once]
                      ww5_s8k4 [Occ=Once]
                      ww6_s8k5 [Occ=Once]
                      ww7_s8k6 [Occ=Once] ->
                    case
                        GHC.Base.$w$csconcat2
                            w_s8jU
                            w1_s8jV
                            w2_s8jW
                            w3_s8jX
                            ww4_s8k3
                            ww5_s8k4
                            ww6_s8k5
                            ww7_s8k6
                            ww2_s8k1
                    of
                    { (#,,,#) ww9_s8k8 [Occ=Once]
                              ww10_s8k9 [Occ=Once]
                              ww11_s8ka [Occ=Once]
                              ww12_s8kb [Occ=Once] ->
                          (,,,) [ww9_s8k8 ww10_s8k9 ww11_s8ka ww12_s8kb];
                    };
              };
        };

GHC.Base.$fSemigroup(,,,)_$cstimes [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     forall b1.
     GHC.Real.Integral b1 =>
     b1 -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8kc w1_s8kd w2_s8ke w3_s8kf w4_s8kg w5_s8kh w6_s8ki]
        case w6_s8ki of {
          (,,,) ww1_s8kk [Occ=Once]
                ww2_s8kl [Occ=Once]
                ww3_s8km [Occ=Once]
                ww4_s8kn [Occ=Once] ->
              let {
                sat_s8kr [Occ=Once] :: d_s6OY
                [LclId] =
                    [w3_s8kf w4_s8kg w5_s8kh ww4_s8kn] \u []
                        GHC.Base.stimes w3_s8kf w4_s8kg w5_s8kh ww4_s8kn; } in
              let {
                sat_s8kq [Occ=Once] :: c_s6OX
                [LclId] =
                    [w2_s8ke w4_s8kg w5_s8kh ww3_s8km] \u []
                        GHC.Base.stimes w2_s8ke w4_s8kg w5_s8kh ww3_s8km; } in
              let {
                sat_s8kp [Occ=Once] :: b_s6OW
                [LclId] =
                    [w1_s8kd w4_s8kg w5_s8kh ww2_s8kl] \u []
                        GHC.Base.stimes w1_s8kd w4_s8kg w5_s8kh ww2_s8kl; } in
              let {
                sat_s8ko [Occ=Once] :: a_s6OV
                [LclId] =
                    [w_s8kc w4_s8kg w5_s8kh ww1_s8kk] \u []
                        GHC.Base.stimes w_s8kc w4_s8kg w5_s8kh ww1_s8kk;
              } in  (,,,) [sat_s8ko sat_s8kp sat_s8kq sat_s8kr];
        };

GHC.Base.$fSemigroup(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     GHC.Base.Semigroup (a, b, c, d)
[GblId[DFunId],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s8ks
           $dSemigroup1_s8kt
           $dSemigroup2_s8ku
           $dSemigroup3_s8kv]
        let {
          sat_s8ky [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
          [LclId] =
              [$dSemigroup_s8ks
               $dSemigroup1_s8kt
               $dSemigroup2_s8ku
               $dSemigroup3_s8kv] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(,,,)_$cstimes
                      $dSemigroup_s8ks
                      $dSemigroup1_s8kt
                      $dSemigroup2_s8ku
                      $dSemigroup3_s8kv
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_s8kx [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
          [LclId] =
              [$dSemigroup_s8ks
               $dSemigroup1_s8kt
               $dSemigroup2_s8ku
               $dSemigroup3_s8kv] \r [eta_B1]
                  GHC.Base.$fSemigroup(,,,)_$csconcat
                      $dSemigroup_s8ks
                      $dSemigroup1_s8kt
                      $dSemigroup2_s8ku
                      $dSemigroup3_s8kv
                      eta_B1; } in
        let {
          sat_s8kw [Occ=Once]
            :: (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
          [LclId] =
              [$dSemigroup_s8ks
               $dSemigroup1_s8kt
               $dSemigroup2_s8ku
               $dSemigroup3_s8kv] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,)_$c<>
                      $dSemigroup_s8ks
                      $dSemigroup1_s8kt
                      $dSemigroup2_s8ku
                      $dSemigroup3_s8kv
                      eta_B2
                      eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s8kw sat_s8kx sat_s8ky];

GHC.Base.$w$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     (# (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d),
        GHC.Base.NonEmpty (a, b, c, d) -> (a, b, c, d),
        forall b1.
        GHC.Real.Integral b1 =>
        b1 -> (a, b, c, d) -> (a, b, c, d) #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [w_s8kz w1_s8kA w2_s8kB w3_s8kC]
        let {
          w4_s8l1 [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup d_s6Pl
          [LclId] =
              [w3_s8kC] \u [] GHC.Base.$p1Monoid w3_s8kC; } in
        let {
          w5_s8l2 [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup c_s6Pk
          [LclId] =
              [w2_s8kB] \u [] GHC.Base.$p1Monoid w2_s8kB; } in
        let {
          w6_s8l3 [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_s6Pj
          [LclId] =
              [w1_s8kA] \u [] GHC.Base.$p1Monoid w1_s8kA; } in
        let {
          w7_s8l4 [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_s6Pi
          [LclId] =
              [w_s8kz] \u [] GHC.Base.$p1Monoid w_s8kz; } in
        let {
          sat_s8lh [Occ=Once]
            :: forall b1.
               GHC.Real.Integral b1 =>
               b1
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
          [LclId] =
              [w4_s8l1 w5_s8l2 w6_s8l3 w7_s8l4] \r [w8_s8l5 w9_s8l6 w10_s8l7]
                  case w10_s8l7 of {
                    (,,,) ww1_s8l9 [Occ=Once]
                          ww2_s8la [Occ=Once]
                          ww3_s8lb [Occ=Once]
                          ww4_s8lc [Occ=Once] ->
                        let {
                          sat_s8lg [Occ=Once] :: d_s6Pl
                          [LclId] =
                              [w4_s8l1 w8_s8l5 w9_s8l6 ww4_s8lc] \u []
                                  GHC.Base.stimes w4_s8l1 w8_s8l5 w9_s8l6 ww4_s8lc; } in
                        let {
                          sat_s8lf [Occ=Once] :: c_s6Pk
                          [LclId] =
                              [w5_s8l2 w8_s8l5 w9_s8l6 ww3_s8lb] \u []
                                  GHC.Base.stimes w5_s8l2 w8_s8l5 w9_s8l6 ww3_s8lb; } in
                        let {
                          sat_s8le [Occ=Once] :: b_s6Pj
                          [LclId] =
                              [w6_s8l3 w8_s8l5 w9_s8l6 ww2_s8la] \u []
                                  GHC.Base.stimes w6_s8l3 w8_s8l5 w9_s8l6 ww2_s8la; } in
                        let {
                          sat_s8ld [Occ=Once] :: a_s6Pi
                          [LclId] =
                              [w7_s8l4 w8_s8l5 w9_s8l6 ww1_s8l9] \u []
                                  GHC.Base.stimes w7_s8l4 w8_s8l5 w9_s8l6 ww1_s8l9;
                        } in  (,,,) [sat_s8ld sat_s8le sat_s8lf sat_s8lg];
                  }; } in
        let {
          w4_s8kI [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup d_s6Pl
          [LclId] =
              [w3_s8kC] \u [] GHC.Base.$p1Monoid w3_s8kC; } in
        let {
          w5_s8kJ [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup c_s6Pk
          [LclId] =
              [w2_s8kB] \u [] GHC.Base.$p1Monoid w2_s8kB; } in
        let {
          w6_s8kK [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_s6Pj
          [LclId] =
              [w1_s8kA] \u [] GHC.Base.$p1Monoid w1_s8kA; } in
        let {
          w7_s8kL [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_s6Pi
          [LclId] =
              [w_s8kz] \u [] GHC.Base.$p1Monoid w_s8kz; } in
        let {
          sat_s8l0 [Occ=Once]
            :: GHC.Base.NonEmpty (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
          [LclId] =
              [w4_s8kI w5_s8kJ w6_s8kK w7_s8kL] \r [w8_s8kM]
                  case w8_s8kM of {
                    GHC.Base.:| ww1_s8kO [Occ=Once!] ww2_s8kP [Occ=Once] ->
                        case ww1_s8kO of {
                          (,,,) ww4_s8kR [Occ=Once]
                                ww5_s8kS [Occ=Once]
                                ww6_s8kT [Occ=Once]
                                ww7_s8kU [Occ=Once] ->
                              case
                                  GHC.Base.$w$csconcat2
                                      w7_s8kL
                                      w6_s8kK
                                      w5_s8kJ
                                      w4_s8kI
                                      ww4_s8kR
                                      ww5_s8kS
                                      ww6_s8kT
                                      ww7_s8kU
                                      ww2_s8kP
                              of
                              { (#,,,#) ww9_s8kW [Occ=Once]
                                        ww10_s8kX [Occ=Once]
                                        ww11_s8kY [Occ=Once]
                                        ww12_s8kZ [Occ=Once] ->
                                    (,,,) [ww9_s8kW ww10_s8kX ww11_s8kY ww12_s8kZ];
                              };
                        };
                  }; } in
        let {
          sat_s8kG [Occ=OnceL] :: GHC.Base.Semigroup d_s6Pl
          [LclId] =
              [w3_s8kC] \u [] GHC.Base.$p1Monoid w3_s8kC; } in
        let {
          sat_s8kF [Occ=OnceL] :: GHC.Base.Semigroup c_s6Pk
          [LclId] =
              [w2_s8kB] \u [] GHC.Base.$p1Monoid w2_s8kB; } in
        let {
          sat_s8kE [Occ=OnceL] :: GHC.Base.Semigroup b_s6Pj
          [LclId] =
              [w1_s8kA] \u [] GHC.Base.$p1Monoid w1_s8kA; } in
        let {
          sat_s8kD [Occ=OnceL] :: GHC.Base.Semigroup a_s6Pi
          [LclId] =
              [w_s8kz] \u [] GHC.Base.$p1Monoid w_s8kz; } in
        let {
          sat_s8kH [Occ=Once]
            :: (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
          [LclId] =
              [sat_s8kD sat_s8kE sat_s8kF sat_s8kG] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,)_$c<>
                      sat_s8kD sat_s8kE sat_s8kF sat_s8kG eta_B2 eta_B1;
        } in  (#,,#) [sat_s8kH sat_s8l0 sat_s8lh];

GHC.Base.$fMonoid(,,,)_$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     GHC.Base.Semigroup (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [w_s8li w1_s8lj w2_s8lk w3_s8ll]
        case GHC.Base.$w$cp1Monoid w_s8li w1_s8lj w2_s8lk w3_s8ll of {
          (#,,#) ww1_s8ln [Occ=Once]
                 ww2_s8lo [Occ=Once]
                 ww3_s8lp [Occ=Once] ->
              GHC.Base.C:Semigroup [ww1_s8ln ww2_s8lo ww3_s8lp];
        };

GHC.Base.$fMonoid(,,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8lq $dMonoid1_s8lr $dMonoid2_s8ls $dMonoid3_s8lt]
        case
            GHC.Base.$w$cp1Monoid
                $dMonoid_s8lq $dMonoid1_s8lr $dMonoid2_s8ls $dMonoid3_s8lt
        of
        { (#,,#) ww1_s8lv [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> ww1_s8lv;
        };

GHC.Base.$fMonoid(,,,)_$cmconcat
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     [(a, b, c, d)] -> (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8ly $dMonoid1_s8lz $dMonoid2_s8lA $dMonoid3_s8lB]
        let {
          k_s8lC [Occ=OnceL, Dmd=<L,1*U(1*C(C1(U(U,U,U,U))),A,A)>]
            :: GHC.Base.Semigroup (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_s8ly $dMonoid1_s8lz $dMonoid2_s8lA $dMonoid3_s8lB] \s []
                  case
                      GHC.Base.$w$cp1Monoid
                          $dMonoid_s8ly $dMonoid1_s8lz $dMonoid2_s8lA $dMonoid3_s8lB
                  of
                  { (#,,#) ww1_s8lE [Occ=Once]
                           ww2_s8lF [Occ=Once]
                           ww3_s8lG [Occ=Once] ->
                        GHC.Base.C:Semigroup [ww1_s8lE ww2_s8lF ww3_s8lG];
                  }; } in
        let {
          k1_s8lH [Occ=OnceL!, Dmd=<L,C(C1(U(U,U,U,U)))>]
            :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [k_s8lC] \u [] GHC.Base.<> k_s8lC; } in
        let {
          z_s8lI [Occ=OnceL] :: a_a4xJ
          [LclId] =
              [$dMonoid_s8ly] \u [] GHC.Base.mempty $dMonoid_s8ly; } in
        let {
          z1_s8lJ [Occ=OnceL] :: b_a4xK
          [LclId] =
              [$dMonoid1_s8lz] \u [] GHC.Base.mempty $dMonoid1_s8lz; } in
        let {
          z2_s8lK [Occ=OnceL] :: c_a4xL
          [LclId] =
              [$dMonoid2_s8lA] \u [] GHC.Base.mempty $dMonoid2_s8lA; } in
        let {
          z3_s8lL [Occ=OnceL] :: d_a4xM
          [LclId] =
              [$dMonoid3_s8lB] \u [] GHC.Base.mempty $dMonoid3_s8lB; } in
        let {
          z4_s8lM [Occ=OnceL, Dmd=<L,U(U,U,U,U)>]
            :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId, Unf=OtherCon []] =
              CCCS (,,,)! [z_s8lI z1_s8lJ z2_s8lK z3_s8lL]; } in
        let {
          go_s8lN [Occ=LoopBreaker]
            :: [(a_a4xJ, b_a4xK, c_a4xL, d_a4xM)]
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [k1_s8lH z4_s8lM go_s8lN] \r [ds_s8lO]
                  case ds_s8lO of {
                    [] -> z4_s8lM;
                    : y_s8lQ [Occ=Once] ys_s8lR [Occ=Once] ->
                        let {
                          sat_s8lS [Occ=Once] :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
                          [LclId] =
                              [go_s8lN ys_s8lR] \u [] go_s8lN ys_s8lR;
                        } in  k1_s8lH y_s8lQ sat_s8lS;
                  };
        } in  go_s8lN;

GHC.Base.$fMonoid(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     GHC.Base.Monoid (a, b, c, d)
[GblId[DFunId],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW]
        let {
          sat_s8m0 [Occ=Once]
            :: [(a_a4xJ, b_a4xK, c_a4xL, d_a4xM)]
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW] \u []
                  GHC.Base.$fMonoid(,,,)_$cmconcat
                      $dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW; } in
        let {
          sat_s8lZ [Occ=Once]
            :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW] \u []
                  GHC.Base.$fMonoid(,,,)_$cmappend
                      $dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW; } in
        let {
          sat_s8lY [Occ=Once] :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW] \u []
                  GHC.Base.$fMonoid(,,,)_$cmempty
                      $dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW; } in
        let {
          sat_s8lX [Occ=Once]
            :: GHC.Base.Semigroup (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW] \u []
                  GHC.Base.$fMonoid(,,,)_$cp1Monoid
                      $dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW;
        } in  GHC.Base.C:Monoid [sat_s8lX sat_s8lY sat_s8lZ sat_s8m0];

GHC.Base.$fMonoid(,,)_$c<> [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     (a, b, c) -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U)><S,1*U(U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8m1 w1_s8m2 w2_s8m3 w3_s8m4 w4_s8m5]
        case w3_s8m4 of {
          (,,) ww1_s8m7 [Occ=Once] ww2_s8m8 [Occ=Once] ww3_s8m9 [Occ=Once] ->
              case w4_s8m5 of {
                (,,) ww5_s8mb [Occ=Once] ww6_s8mc [Occ=Once] ww7_s8md [Occ=Once] ->
                    let {
                      sat_s8mg [Occ=Once] :: c_s6PF
                      [LclId] =
                          [w2_s8m3 ww3_s8m9 ww7_s8md] \u []
                              GHC.Base.<> w2_s8m3 ww3_s8m9 ww7_s8md; } in
                    let {
                      sat_s8mf [Occ=Once] :: b_s6PE
                      [LclId] =
                          [w1_s8m2 ww2_s8m8 ww6_s8mc] \u []
                              GHC.Base.<> w1_s8m2 ww2_s8m8 ww6_s8mc; } in
                    let {
                      sat_s8me [Occ=Once] :: a_s6PD
                      [LclId] =
                          [w_s8m1 ww1_s8m7 ww5_s8mb] \u []
                              GHC.Base.<> w_s8m1 ww1_s8m7 ww5_s8mb;
                    } in  (,,) [sat_s8me sat_s8mf sat_s8mg];
              };
        };

GHC.Base.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     a -> b -> c -> [(a, b, c)] -> (# a, b, c #)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8mh w1_s8mi w2_s8mj ww_s8mk ww1_s8ml ww2_s8mm ww3_s8mn]
        let {
          $wgo_s8mo [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: a_s6Qd
               -> b_s6Qe
               -> c_s6Qf
               -> [(a_s6Qd, b_s6Qe, c_s6Qf)]
               -> (# a_s6Qd, b_s6Qe, c_s6Qf #)
          [LclId, Arity=4, Str=<L,U><L,U><L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s8mh w1_s8mi w2_s8mj $wgo_s8mo] \r [ww4_s8mp
                                                              ww5_s8mq
                                                              ww6_s8mr
                                                              w3_s8ms]
                  case w3_s8ms of {
                    [] -> (#,,#) [ww4_s8mp ww5_s8mq ww6_s8mr];
                    : c1_s8mu [Occ=Once!] cs_s8mv [Occ=Once] ->
                        case c1_s8mu of {
                          (,,) ww8_s8mx [Occ=Once]
                               ww9_s8my [Occ=Once]
                               ww10_s8mz [Occ=Once] ->
                              case $wgo_s8mo ww8_s8mx ww9_s8my ww10_s8mz cs_s8mv of {
                                (#,,#) ww12_s8mB [Occ=Once]
                                       ww13_s8mC [Occ=Once]
                                       ww14_s8mD [Occ=Once] ->
                                    let {
                                      sat_s8mG [Occ=Once] :: c_s6Qf
                                      [LclId] =
                                          [w2_s8mj ww6_s8mr ww14_s8mD] \u []
                                              GHC.Base.<> w2_s8mj ww6_s8mr ww14_s8mD; } in
                                    let {
                                      sat_s8mF [Occ=Once] :: b_s6Qe
                                      [LclId] =
                                          [w1_s8mi ww5_s8mq ww13_s8mC] \u []
                                              GHC.Base.<> w1_s8mi ww5_s8mq ww13_s8mC; } in
                                    let {
                                      sat_s8mE [Occ=Once] :: a_s6Qd
                                      [LclId] =
                                          [w_s8mh ww4_s8mp ww12_s8mB] \u []
                                              GHC.Base.<> w_s8mh ww4_s8mp ww12_s8mB;
                                    } in  (#,,#) [sat_s8mE sat_s8mF sat_s8mG];
                              };
                        };
                  };
        } in  $wgo_s8mo ww_s8mk ww1_s8ml ww2_s8mm ww3_s8mn;

GHC.Base.$fSemigroup(,,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     GHC.Base.NonEmpty (a, b, c) -> (a, b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8mH w1_s8mI w2_s8mJ w3_s8mK]
        case w3_s8mK of {
          GHC.Base.:| ww1_s8mM [Occ=Once!] ww2_s8mN [Occ=Once] ->
              case ww1_s8mM of {
                (,,) ww4_s8mP [Occ=Once] ww5_s8mQ [Occ=Once] ww6_s8mR [Occ=Once] ->
                    case
                        GHC.Base.$w$csconcat1
                            w_s8mH w1_s8mI w2_s8mJ ww4_s8mP ww5_s8mQ ww6_s8mR ww2_s8mN
                    of
                    { (#,,#) ww8_s8mT [Occ=Once]
                             ww9_s8mU [Occ=Once]
                             ww10_s8mV [Occ=Once] ->
                          (,,) [ww8_s8mT ww9_s8mU ww10_s8mV];
                    };
              };
        };

GHC.Base.$fMonoid(,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     (a, b, c) -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U,U)><S,1*U(U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8mW
           $dMonoid1_s8mX
           $dMonoid2_s8mY
           eta_s8mZ
           eta1_s8n0]
        case eta_s8mZ of {
          (,,) a1_s8n2 [Occ=Once] b1_s8n3 [Occ=Once] c1_s8n4 [Occ=Once] ->
              case eta1_s8n0 of {
                (,,) a'_s8n6 [Occ=Once] b'_s8n7 [Occ=Once] c'_s8n8 [Occ=Once] ->
                    let {
                      sat_s8ne [Occ=Once] :: c_a4yl
                      [LclId] =
                          [$dMonoid2_s8mY c1_s8n4 c'_s8n8] \u []
                              case GHC.Base.$p1Monoid $dMonoid2_s8mY of sat_s8nd {
                                __DEFAULT -> GHC.Base.<> sat_s8nd c1_s8n4 c'_s8n8;
                              }; } in
                    let {
                      sat_s8nc [Occ=Once] :: b_a4yk
                      [LclId] =
                          [$dMonoid1_s8mX b1_s8n3 b'_s8n7] \u []
                              case GHC.Base.$p1Monoid $dMonoid1_s8mX of sat_s8nb {
                                __DEFAULT -> GHC.Base.<> sat_s8nb b1_s8n3 b'_s8n7;
                              }; } in
                    let {
                      sat_s8na [Occ=Once] :: a_a4yj
                      [LclId] =
                          [$dMonoid_s8mW a1_s8n2 a'_s8n6] \u []
                              case GHC.Base.$p1Monoid $dMonoid_s8mW of sat_s8n9 {
                                __DEFAULT -> GHC.Base.<> sat_s8n9 a1_s8n2 a'_s8n6;
                              };
                    } in  (,,) [sat_s8na sat_s8nc sat_s8ne];
              };
        };

GHC.Base.$fMonoid(,,)_$cmconcat
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     [(a, b, c)] -> (a, b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8nf $dMonoid1_s8ng $dMonoid2_s8nh eta_s8ni]
        let {
          $dSemigroup_s8nj [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_a4yj
          [LclId] =
              [$dMonoid_s8nf] \u [] GHC.Base.$p1Monoid $dMonoid_s8nf; } in
        let {
          $dSemigroup1_s8nk [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_a4yk
          [LclId] =
              [$dMonoid1_s8ng] \u [] GHC.Base.$p1Monoid $dMonoid1_s8ng; } in
        let {
          $dSemigroup2_s8nl [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup c_a4yl
          [LclId] =
              [$dMonoid2_s8nh] \u [] GHC.Base.$p1Monoid $dMonoid2_s8nh; } in
        let {
          z_s8nm [Occ=OnceL] :: a_a4yj
          [LclId] =
              [$dMonoid_s8nf] \u [] GHC.Base.mempty $dMonoid_s8nf; } in
        let {
          z1_s8nn [Occ=OnceL] :: b_a4yk
          [LclId] =
              [$dMonoid1_s8ng] \u [] GHC.Base.mempty $dMonoid1_s8ng; } in
        let {
          z2_s8no [Occ=OnceL] :: c_a4yl
          [LclId] =
              [$dMonoid2_s8nh] \u [] GHC.Base.mempty $dMonoid2_s8nh; } in
        let {
          z3_s8np [Occ=OnceL, Dmd=<S,U(U,U,U)>] :: (a_a4yj, b_a4yk, c_a4yl)
          [LclId, Unf=OtherCon []] =
              CCCS (,,)! [z_s8nm z1_s8nn z2_s8no]; } in
        let {
          go_s8nq [Occ=LoopBreaker]
            :: [(a_a4yj, b_a4yk, c_a4yl)] -> (a_a4yj, b_a4yk, c_a4yl)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_s8nj
                        $dSemigroup1_s8nk
                        $dSemigroup2_s8nl
                        z3_s8np
                        go_s8nq] \r [ds_s8nr]
                  case ds_s8nr of {
                    [] -> z3_s8np;
                    : y_s8nt [Occ=Once!] ys_s8nu [Occ=Once] ->
                        case y_s8nt of {
                          (,,) a1_s8nw [Occ=Once] b1_s8nx [Occ=Once] c1_s8ny [Occ=Once] ->
                              case go_s8nq ys_s8nu of {
                                (,,) a'_s8nA [Occ=Once] b'_s8nB [Occ=Once] c'_s8nC [Occ=Once] ->
                                    let {
                                      sat_s8nF [Occ=Once] :: c_a4yl
                                      [LclId] =
                                          [$dSemigroup2_s8nl c1_s8ny c'_s8nC] \u []
                                              GHC.Base.<> $dSemigroup2_s8nl c1_s8ny c'_s8nC; } in
                                    let {
                                      sat_s8nE [Occ=Once] :: b_a4yk
                                      [LclId] =
                                          [$dSemigroup1_s8nk b1_s8nx b'_s8nB] \u []
                                              GHC.Base.<> $dSemigroup1_s8nk b1_s8nx b'_s8nB; } in
                                    let {
                                      sat_s8nD [Occ=Once] :: a_a4yj
                                      [LclId] =
                                          [$dSemigroup_s8nj a1_s8nw a'_s8nA] \u []
                                              GHC.Base.<> $dSemigroup_s8nj a1_s8nw a'_s8nA;
                                    } in  (,,) [sat_s8nD sat_s8nE sat_s8nF];
                              };
                        };
                  };
        } in  go_s8nq eta_s8ni;

GHC.Base.$fSemigroup(,,)_$cstimes [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     forall b1. GHC.Real.Integral b1 => b1 -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8nG w1_s8nH w2_s8nI w3_s8nJ w4_s8nK w5_s8nL]
        case w5_s8nL of {
          (,,) ww1_s8nN [Occ=Once] ww2_s8nO [Occ=Once] ww3_s8nP [Occ=Once] ->
              let {
                sat_s8nS [Occ=Once] :: c_s6QJ
                [LclId] =
                    [w2_s8nI w3_s8nJ w4_s8nK ww3_s8nP] \u []
                        GHC.Base.stimes w2_s8nI w3_s8nJ w4_s8nK ww3_s8nP; } in
              let {
                sat_s8nR [Occ=Once] :: b_s6QI
                [LclId] =
                    [w1_s8nH w3_s8nJ w4_s8nK ww2_s8nO] \u []
                        GHC.Base.stimes w1_s8nH w3_s8nJ w4_s8nK ww2_s8nO; } in
              let {
                sat_s8nQ [Occ=Once] :: a_s6QH
                [LclId] =
                    [w_s8nG w3_s8nJ w4_s8nK ww1_s8nN] \u []
                        GHC.Base.stimes w_s8nG w3_s8nJ w4_s8nK ww1_s8nN;
              } in  (,,) [sat_s8nQ sat_s8nR sat_s8nS];
        };

GHC.Base.$fSemigroup(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     GHC.Base.Semigroup (a, b, c)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s8nT $dSemigroup1_s8nU $dSemigroup2_s8nV]
        let {
          sat_s8nY [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> (a_a4Dq, b_a4Dr, c_a4Ds) -> (a_a4Dq, b_a4Dr, c_a4Ds)
          [LclId] =
              [$dSemigroup_s8nT $dSemigroup1_s8nU $dSemigroup2_s8nV] \r [eta_B3
                                                                         eta_B2
                                                                         eta_B1]
                  GHC.Base.$fSemigroup(,,)_$cstimes
                      $dSemigroup_s8nT
                      $dSemigroup1_s8nU
                      $dSemigroup2_s8nV
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_s8nX [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4Dq, b_a4Dr, c_a4Ds)
               -> (a_a4Dq, b_a4Dr, c_a4Ds)
          [LclId] =
              [$dSemigroup_s8nT $dSemigroup1_s8nU $dSemigroup2_s8nV] \r [eta_B1]
                  GHC.Base.$fSemigroup(,,)_$csconcat
                      $dSemigroup_s8nT $dSemigroup1_s8nU $dSemigroup2_s8nV eta_B1; } in
        let {
          sat_s8nW [Occ=Once]
            :: (a_a4Dq, b_a4Dr, c_a4Ds)
               -> (a_a4Dq, b_a4Dr, c_a4Ds) -> (a_a4Dq, b_a4Dr, c_a4Ds)
          [LclId] =
              [$dSemigroup_s8nT $dSemigroup1_s8nU $dSemigroup2_s8nV] \r [eta_B2
                                                                         eta_B1]
                  GHC.Base.$fMonoid(,,)_$c<>
                      $dSemigroup_s8nT $dSemigroup1_s8nU $dSemigroup2_s8nV eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s8nW sat_s8nX sat_s8nY];

GHC.Base.$fMonoid(,,)_$cp1Monoid
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     GHC.Base.Semigroup (a, b, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8nZ $dMonoid1_s8o0 $dMonoid2_s8o1]
        let {
          sat_s8o4 [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup c_a4yl
          [LclId] =
              [$dMonoid2_s8o1] \u [] GHC.Base.$p1Monoid $dMonoid2_s8o1; } in
        let {
          sat_s8o3 [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_a4yk
          [LclId] =
              [$dMonoid1_s8o0] \u [] GHC.Base.$p1Monoid $dMonoid1_s8o0; } in
        let {
          sat_s8o2 [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_a4yj
          [LclId] =
              [$dMonoid_s8nZ] \u [] GHC.Base.$p1Monoid $dMonoid_s8nZ;
        } in  GHC.Base.$fSemigroup(,,) sat_s8o2 sat_s8o3 sat_s8o4;

GHC.Base.$fMonoid(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     GHC.Base.Monoid (a, b, c)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7]
        let {
          sat_s8ob [Occ=Once]
            :: [(a_a4yj, b_a4yk, c_a4yl)] -> (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7] \r [eta_B1]
                  GHC.Base.$fMonoid(,,)_$cmconcat
                      $dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7 eta_B1; } in
        let {
          sat_s8oa [Occ=Once]
            :: (a_a4yj, b_a4yk, c_a4yl)
               -> (a_a4yj, b_a4yk, c_a4yl) -> (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,)_$cmappend
                      $dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7 eta_B2 eta_B1; } in
        let {
          sat_s8o9 [Occ=Once] :: (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7] \u []
                  GHC.Base.$fMonoid(,,)_$cmempty
                      $dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7; } in
        let {
          sat_s8o8 [Occ=Once] :: GHC.Base.Semigroup (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7] \u []
                  GHC.Base.$fMonoid(,,)_$cp1Monoid
                      $dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7;
        } in  GHC.Base.C:Monoid [sat_s8o8 sat_s8o9 sat_s8oa sat_s8ob];

GHC.Base.$fSemigroup(,)_$c<>
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     (a, b) -> (a, b) -> (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8oc $dSemigroup1_s8od ds_s8oe ds1_s8of]
        case ds_s8oe of {
          (,) a1_s8oh [Occ=Once] b1_s8oi [Occ=Once] ->
              case ds1_s8of of {
                (,) a'_s8ok [Occ=Once] b'_s8ol [Occ=Once] ->
                    let {
                      sat_s8on [Occ=Once] :: b_a4E7
                      [LclId] =
                          [$dSemigroup1_s8od b1_s8oi b'_s8ol] \u []
                              GHC.Base.<> $dSemigroup1_s8od b1_s8oi b'_s8ol; } in
                    let {
                      sat_s8om [Occ=Once] :: a_a4E6
                      [LclId] =
                          [$dSemigroup_s8oc a1_s8oh a'_s8ok] \u []
                              GHC.Base.<> $dSemigroup_s8oc a1_s8oh a'_s8ok;
                    } in  (,) [sat_s8om sat_s8on];
              };
        };

GHC.Base.$fSemigroup(,)_$cstimes
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     forall b1. GHC.Real.Integral b1 => b1 -> (a, b) -> (a, b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8oo
           $dSemigroup1_s8op
           $dIntegral_s8oq
           n_s8or
           ds_s8os]
        case ds_s8os of {
          (,) a1_s8ou [Occ=Once] b2_s8ov [Occ=Once] ->
              let {
                sat_s8ox [Occ=Once] :: b_a4E7
                [LclId] =
                    [$dSemigroup1_s8op $dIntegral_s8oq n_s8or b2_s8ov] \u []
                        GHC.Base.stimes
                            $dSemigroup1_s8op $dIntegral_s8oq n_s8or b2_s8ov; } in
              let {
                sat_s8ow [Occ=Once] :: a_a4E6
                [LclId] =
                    [$dSemigroup_s8oo $dIntegral_s8oq n_s8or a1_s8ou] \u []
                        GHC.Base.stimes $dSemigroup_s8oo $dIntegral_s8oq n_s8or a1_s8ou;
              } in  (,) [sat_s8ow sat_s8ox];
        };

GHC.Base.$fSemigroup(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     GHC.Base.Semigroup (a, b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s8oy $dSemigroup1_s8oz]
        let {
          sat_s8oC [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7)
          [LclId] =
              [$dSemigroup_s8oy $dSemigroup1_s8oz] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(,)_$cstimes
                      $dSemigroup_s8oy $dSemigroup1_s8oz eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s8oB [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7)
          [LclId] =
              [$dSemigroup_s8oy $dSemigroup1_s8oz] \r [eta_B1]
                  GHC.Base.$fSemigroup(,)_$csconcat
                      $dSemigroup_s8oy $dSemigroup1_s8oz eta_B1; } in
        let {
          sat_s8oA [Occ=Once]
            :: (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7)
          [LclId] =
              [$dSemigroup_s8oy $dSemigroup1_s8oz] \r [eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(,)_$c<>
                      $dSemigroup_s8oy $dSemigroup1_s8oz eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s8oA sat_s8oB sat_s8oC];

GHC.Base.$fMonoid(,)_$cp1Monoid
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     GHC.Base.Semigroup (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8oD $dMonoid1_s8oE]
        let {
          sat_s8oG [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_a4yQ
          [LclId] =
              [$dMonoid1_s8oE] \u [] GHC.Base.$p1Monoid $dMonoid1_s8oE; } in
        let {
          sat_s8oF [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_a4yP
          [LclId] =
              [$dMonoid_s8oD] \u [] GHC.Base.$p1Monoid $dMonoid_s8oD;
        } in  GHC.Base.$fSemigroup(,) sat_s8oF sat_s8oG;

GHC.Base.$fMonoid(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     GHC.Base.Monoid (a, b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s8oH $dMonoid1_s8oI]
        let {
          sat_s8oM [Occ=Once] :: [(a_a4yP, b_a4yQ)] -> (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_s8oH $dMonoid1_s8oI] \r [eta_B1]
                  GHC.Base.$fMonoid(,)_$cmconcat
                      $dMonoid_s8oH $dMonoid1_s8oI eta_B1; } in
        let {
          sat_s8oL [Occ=Once]
            :: (a_a4yP, b_a4yQ) -> (a_a4yP, b_a4yQ) -> (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_s8oH $dMonoid1_s8oI] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,)_$cmappend
                      $dMonoid_s8oH $dMonoid1_s8oI eta_B2 eta_B1; } in
        let {
          sat_s8oK [Occ=Once] :: (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_s8oH $dMonoid1_s8oI] \u []
                  GHC.Base.$fMonoid(,)_$cmempty $dMonoid_s8oH $dMonoid1_s8oI; } in
        let {
          sat_s8oJ [Occ=Once] :: GHC.Base.Semigroup (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_s8oH $dMonoid1_s8oI] \u []
                  GHC.Base.$fMonoid(,)_$cp1Monoid $dMonoid_s8oH $dMonoid1_s8oI;
        } in  GHC.Base.C:Monoid [sat_s8oJ sat_s8oK sat_s8oL sat_s8oM];

GHC.Base.$fMonoid()_$c<> :: () -> () -> ()
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s8oN ds1_s8oO] () [];

GHC.Base.$fSemigroup()_$csconcat :: GHC.Base.NonEmpty () -> ()
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s8oP] () [];

GHC.Base.$fSemigroup()_$cstimes
  :: forall b. GHC.Real.Integral b => b -> () -> ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s8oQ ds_s8oR ds1_s8oS] () [];

GHC.Base.$fSemigroup() [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup ()
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.$fMonoid()_$c<>
                                         GHC.Base.$fSemigroup()_$csconcat
                                         GHC.Base.$fSemigroup()_$cstimes];

GHC.Base.$fMonoid() [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid ()
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [GHC.Base.$fSemigroup()
                                      GHC.Tuple.()
                                      GHC.Base.$fMonoid()_$c<>
                                      GHC.Base.$fMonoid()_$cmconcat];

GHC.Base.$fSemigroup(->)_$c<>
  :: forall b a.
     GHC.Base.Semigroup b =>
     (a -> b) -> (a -> b) -> a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),1*U(1*C1(C1(U)),A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8oT f_s8oU g_s8oV x_s8oW]
        let {
          sat_s8oY [Occ=Once] :: b_a4EV
          [LclId] =
              [g_s8oV x_s8oW] \u [] g_s8oV x_s8oW; } in
        let {
          sat_s8oX [Occ=Once] :: b_a4EV
          [LclId] =
              [f_s8oU x_s8oW] \u [] f_s8oU x_s8oW;
        } in  GHC.Base.<> $dSemigroup_s8oT sat_s8oX sat_s8oY;

GHC.Base.$fSemigroup(->)_$cstimes
  :: forall b a.
     GHC.Base.Semigroup b =>
     forall b1. GHC.Real.Integral b1 => b1 -> (a -> b) -> a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8oZ $dIntegral_s8p0 n_s8p1 f_s8p2 e_s8p3]
        let {
          sat_s8p4 [Occ=Once] :: b_a4EV
          [LclId] =
              [f_s8p2 e_s8p3] \u [] f_s8p2 e_s8p3;
        } in 
          GHC.Base.stimes $dSemigroup_s8oZ $dIntegral_s8p0 n_s8p1 sat_s8p4;

GHC.Base.$fSemigroup(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall b a. GHC.Base.Semigroup b => GHC.Base.Semigroup (a -> b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s8p5]
        let {
          sat_s8p8 [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> (a_a4EW -> b_a4EV) -> a_a4EW -> b_a4EV
          [LclId] =
              [$dSemigroup_s8p5] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$cstimes
                      $dSemigroup_s8p5 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s8p7 [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4EW -> b_a4EV) -> a_a4EW -> b_a4EV
          [LclId] =
              [$dSemigroup_s8p5] \r [eta_B1]
                  GHC.Base.$fSemigroup(->)_$csconcat $dSemigroup_s8p5 eta_B1; } in
        let {
          sat_s8p6 [Occ=Once]
            :: (a_a4EW -> b_a4EV) -> (a_a4EW -> b_a4EV) -> a_a4EW -> b_a4EV
          [LclId] =
              [$dSemigroup_s8p5] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$c<>
                      $dSemigroup_s8p5 eta_B3 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s8p6 sat_s8p7 sat_s8p8];

GHC.Base.$fMonoid(->)_$cp1Monoid
  :: forall b a. GHC.Base.Monoid b => GHC.Base.Semigroup (a -> b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8p9]
        let {
          sat_s8pa [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_a4zA
          [LclId] =
              [$dMonoid_s8p9] \u [] GHC.Base.$p1Monoid $dMonoid_s8p9;
        } in  GHC.Base.$fSemigroup(->) sat_s8pa;

GHC.Base.$fMonoid(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall b a. GHC.Base.Monoid b => GHC.Base.Monoid (a -> b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s8pb]
        let {
          lvl3_s8pc [Occ=OnceL] :: b_a4zA
          [LclId] =
              [$dMonoid_s8pb] \u [] GHC.Base.mempty $dMonoid_s8pb; } in
        let {
          sat_s8ph [Occ=Once] :: [a_a4zB -> b_a4zA] -> a_a4zB -> b_a4zA
          [LclId] =
              [$dMonoid_s8pb] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmconcat $dMonoid_s8pb eta_B2 eta_B1; } in
        let {
          sat_s8pg [Occ=Once]
            :: (a_a4zB -> b_a4zA) -> (a_a4zB -> b_a4zA) -> a_a4zB -> b_a4zA
          [LclId] =
              [$dMonoid_s8pb] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmappend
                      $dMonoid_s8pb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s8pf [Occ=Once] :: a_a4zB -> b_a4zA
          [LclId] =
              [lvl3_s8pc] \r [ds_s8pe] lvl3_s8pc; } in
        let {
          sat_s8pd [Occ=Once] :: GHC.Base.Semigroup (a_a4zB -> b_a4zA)
          [LclId] =
              [$dMonoid_s8pb] \u []
                  GHC.Base.$fMonoid(->)_$cp1Monoid $dMonoid_s8pb;
        } in  GHC.Base.C:Monoid [sat_s8pd sat_s8pf sat_s8pg sat_s8ph];

GHC.Base.$fSemigroup[]_$cstimes
  :: forall a b. GHC.Real.Integral b => b -> [a] -> [a]
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_s8pi]
        Data.Semigroup.Internal.stimesList $dIntegral_s8pi;

GHC.Base.$fSemigroup[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup [a]
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.++
                                         GHC.Base.$fSemigroup[]_$csconcat
                                         GHC.Base.$fSemigroup[]_$cstimes];

GHC.Base.$fMonoid[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid [a]
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [GHC.Base.$fSemigroup[]
                                      GHC.Types.[]
                                      GHC.Base.++
                                      GHC.Base.$fMonoid[]_$cmconcat];

GHC.Base.$fApplicativeNonEmpty_$cpure
  :: forall a. a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [a1_s8pj] GHC.Base.:| [a1_s8pj GHC.Types.[]];

GHC.Base.$w$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> (# c, [c] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(U,U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s8pk w1_s8pl w2_s8pm]
        let {
          sat_s8pu [Occ=Once] :: a_s6R1 -> GHC.Base.NonEmpty c_s6R3
          [LclId] =
              [w_s8pk w2_s8pm] \r [x1_s8pn]
                  let {
                    sat_s8pq [Occ=Once] :: b_s6R2 -> GHC.Base.NonEmpty c_s6R3
                    [LclId] =
                        [w_s8pk x1_s8pn] \r [x2_s8po]
                            let {
                              sat_s8pp [Occ=Once] :: c_s6R3
                              [LclId] =
                                  [w_s8pk x1_s8pn x2_s8po] \u [] w_s8pk x1_s8pn x2_s8po;
                            } in  GHC.Base.:| [sat_s8pp GHC.Types.[]];
                  } in 
                    case GHC.Base.$w$c>>= w2_s8pm sat_s8pq of {
                      (#,#) ww1_s8ps [Occ=Once] ww2_s8pt [Occ=Once] ->
                          GHC.Base.:| [ww1_s8ps ww2_s8pt];
                    };
        } in  GHC.Base.$w$c>>= w1_s8pl sat_s8pu;

GHC.Base.$fApplicativeNonEmpty_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.NonEmpty a
     -> GHC.Base.NonEmpty b
     -> GHC.Base.NonEmpty c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8pv w1_s8pw w2_s8px]
        case GHC.Base.$w$cliftA2 w_s8pv w1_s8pw w2_s8px of {
          (#,#) ww1_s8pz [Occ=Once] ww2_s8pA [Occ=Once] ->
              GHC.Base.:| [ww1_s8pz ww2_s8pA];
        };

GHC.Base.$w$c<* [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> (# a, [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s8pB w1_s8pC]
        let {
          sat_s8pK [Occ=Once] :: a_s6Rb -> GHC.Base.NonEmpty a_s6Rb
          [LclId] =
              [w1_s8pC] \r [x1_s8pD]
                  let {
                    lvl3_s8pE [Occ=OnceL, Dmd=<L,U(U,U)>] :: GHC.Base.NonEmpty a_s6Rb
                    [LclId, Unf=OtherCon []] =
                        CCCS GHC.Base.:|! [x1_s8pD GHC.Types.[]]; } in
                  let {
                    sat_s8pG [Occ=Once] :: b_s6Rc -> GHC.Base.NonEmpty a_s6Rb
                    [LclId] =
                        [lvl3_s8pE] \r [x2_s8pF] lvl3_s8pE;
                  } in 
                    case GHC.Base.$w$c>>= w1_s8pC sat_s8pG of {
                      (#,#) ww1_s8pI [Occ=Once] ww2_s8pJ [Occ=Once] ->
                          GHC.Base.:| [ww1_s8pI ww2_s8pJ];
                    };
        } in  GHC.Base.$w$c>>= w_s8pB sat_s8pK;

GHC.Base.$fApplicativeNonEmpty_$c<* [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8pL w1_s8pM]
        case GHC.Base.$w$c<* w_s8pL w1_s8pM of {
          (#,#) ww1_s8pO [Occ=Once] ww2_s8pP [Occ=Once] ->
              GHC.Base.:| [ww1_s8pO ww2_s8pP];
        };

GHC.Base.$w$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a -> b) -> GHC.Base.NonEmpty a -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s8pQ w1_s8pR]
        let {
          sat_s8pZ [Occ=Once]
            :: (a_s6Rj -> b_s6Rk) -> GHC.Base.NonEmpty b_s6Rk
          [LclId] =
              [w1_s8pR] \r [x1_s8pS]
                  let {
                    sat_s8pV [Occ=Once] :: a_s6Rj -> GHC.Base.NonEmpty b_s6Rk
                    [LclId] =
                        [x1_s8pS] \r [x2_s8pT]
                            let {
                              sat_s8pU [Occ=Once] :: b_s6Rk
                              [LclId] =
                                  [x1_s8pS x2_s8pT] \u [] x1_s8pS x2_s8pT;
                            } in  GHC.Base.:| [sat_s8pU GHC.Types.[]];
                  } in 
                    case GHC.Base.$w$c>>= w1_s8pR sat_s8pV of {
                      (#,#) ww1_s8pX [Occ=Once] ww2_s8pY [Occ=Once] ->
                          GHC.Base.:| [ww1_s8pX ww2_s8pY];
                    };
        } in  GHC.Base.$w$c>>= w_s8pQ sat_s8pZ;

GHC.Base.$fApplicativeNonEmpty_$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a -> b)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8q0 w1_s8q1]
        case GHC.Base.$w$c<*> w_s8q0 w1_s8q1 of {
          (#,#) ww1_s8q3 [Occ=Once] ww2_s8q4 [Occ=Once] ->
              GHC.Base.:| [ww1_s8q3 ww2_s8q4];
        };

GHC.Base.$fApplicativeNonEmpty1 :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s8q5 eta_s8q6] eta_s8q6;

GHC.Base.$fApplicativeNonEmpty_$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8q7 w1_s8q8]
        let {
          sat_s8qc [Occ=Once] :: [b_s6Rs -> b_s6Rs]
          [LclId] =
              [w_s8q7] \u []
                  case w_s8q7 of {
                    GHC.Base.:| _ [Occ=Dead] as_s8qb [Occ=Once] ->
                        GHC.Base.map GHC.Base.$fApplicativeNonEmpty1 as_s8qb;
                  }; } in
        let {
          sat_s8qd [Occ=Once] :: GHC.Base.NonEmpty (b_s6Rs -> b_s6Rs)
          [LclId] =
              CCCS GHC.Base.:|! [GHC.Base.breakpoint sat_s8qc];
        } in 
          case GHC.Base.$w$c<*> sat_s8qd w1_s8q8 of {
            (#,#) ww1_s8qf [Occ=Once] ww2_s8qg [Occ=Once] ->
                GHC.Base.:| [ww1_s8qf ww2_s8qg];
          };

GHC.Base.$fApplicativeNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctorNonEmpty
                                           GHC.Base.$fApplicativeNonEmpty_$cpure
                                           GHC.Base.$fApplicativeNonEmpty_$c<*>
                                           GHC.Base.$fApplicativeNonEmpty_$cliftA2
                                           GHC.Base.$fApplicativeNonEmpty_$c*>
                                           GHC.Base.$fApplicativeNonEmpty_$c<*];

lvl_r7PJ :: forall a. [GHC.Types.Char] -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s8qh] GHC.Err.errorWithoutStackTrace eta_s8qh;

GHC.Base.$fMonadNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicativeNonEmpty
                                     GHC.Base.$fMonadNonEmpty_$c>>=
                                     GHC.Base.$fMonadNonEmpty_$c>>
                                     GHC.Base.$fApplicativeNonEmpty_$cpure
                                     lvl_r7PJ];

GHC.Base.$fAlternativeIO4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "mzero"#;

GHC.Base.$fAlternativeIO3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.Base.$fAlternativeIO4;

GHC.Base.$fAlternativeIO_$cempty :: forall a. GHC.Types.IO a
[GblId] =
    [] \u [] GHC.IO.failIO GHC.Base.$fAlternativeIO3;

GHC.Base.$fAlternativeIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [GHC.Base.$fApplicativeIO
                                           GHC.Base.$fAlternativeIO_$cempty
                                           GHC.IO.mplusIO
                                           GHC.Base.$fAlternativeIO2
                                           GHC.Base.$fAlternativeIO_$cmany];

GHC.Base.$fMonadPlusIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [GHC.Base.$fAlternativeIO
                                         GHC.Base.$fMonadIO
                                         GHC.Base.$fAlternativeIO_$cempty
                                         GHC.IO.mplusIO];

GHC.Base.$fAlternativeMaybe_$c<|>
  :: forall a.
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s8qi r_s8qj]
        case ds_s8qi of wild_s8qk {
          GHC.Base.Nothing -> r_s8qj;
          GHC.Base.Just _ [Occ=Dead] -> wild_s8qk;
        };

GHC.Base.$fApplicativeMaybe_$cliftA2
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s8qm ds_s8qn ds1_s8qo]
        case ds_s8qn of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s8qq [Occ=Once] ->
              case ds1_s8qo of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just y_s8qs [Occ=Once] ->
                    let {
                      sat_s8qt [Occ=Once] :: c_a4L9
                      [LclId] =
                          [f_s8qm x_s8qq y_s8qs] \u [] f_s8qm x_s8qq y_s8qs;
                    } in  GHC.Base.Just [sat_s8qt];
              };
        };

GHC.Base.$fApplicativeMaybe_$c*>
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s8qu m2_s8qv]
        case ds_s8qu of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> m2_s8qv;
        };

GHC.Base.$fApplicative(->)_$c<*>
  :: forall a1 a2 b. (a1 -> a2 -> b) -> (a1 -> a2) -> a1 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s8qy g_s8qz x_s8qA]
        let {
          sat_s8qB [Occ=Once] :: a1_a4LL
          [LclId] =
              [g_s8qz x_s8qA] \u [] g_s8qz x_s8qA;
        } in  f_s8qy x_s8qA sat_s8qB;

GHC.Base.$fApplicative(->)_$cliftA2
  :: forall a1 a2 b c.
     (a2 -> b -> c) -> (a1 -> a2) -> (a1 -> b) -> a1 -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [q_s8qC f_s8qD g_s8qE x_s8qF]
        let {
          sat_s8qH [Occ=Once] :: b_a4LS
          [LclId] =
              [g_s8qE x_s8qF] \u [] g_s8qE x_s8qF; } in
        let {
          sat_s8qG [Occ=Once] :: a1_a4LR
          [LclId] =
              [f_s8qD x_s8qF] \u [] f_s8qD x_s8qF;
        } in  q_s8qC sat_s8qG sat_s8qH;

GHC.Base.$fApplicative(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Applicative ((->) a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctor(->)
                                           GHC.Base.const
                                           GHC.Base.$fApplicative(->)_$c<*>
                                           GHC.Base.$fApplicative(->)_$cliftA2
                                           GHC.Base.$fApplicative(->)_$c*>
                                           GHC.Base.$fApplicative(->)_$c<*];

lvl1_r7PK :: forall r a. [GHC.Types.Char] -> r -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s8qI] GHC.Err.errorWithoutStackTrace eta_s8qI;

GHC.Base.$fMonad(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall r. GHC.Base.Monad ((->) r)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicative(->)
                                     GHC.Base.$fMonad(->)_$c>>=
                                     GHC.Base.$fMonad(->)_$c>>
                                     GHC.Base.const
                                     lvl1_r7PK];

GHC.Base.$fApplicativeMaybe_$cfmap
  :: forall a b. (a -> b) -> GHC.Base.Maybe a -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s8qJ ds1_s8qK]
        case ds1_s8qK of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_s8qM [Occ=Once] ->
              let {
                sat_s8qN [Occ=Once] :: b_a4MF
                [LclId] =
                    [ds_s8qJ a1_s8qM] \u [] ds_s8qJ a1_s8qM;
              } in  GHC.Base.Just [sat_s8qN];
        };

GHC.Base.$fFunctorMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       GHC.Base.$fFunctorMaybe_$c<$];

GHC.Base.$fApplicativeMaybe_$c<*>
  :: forall a b.
     GHC.Base.Maybe (a -> b) -> GHC.Base.Maybe a -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s8qO m_s8qP]
        case ds_s8qO of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just f_s8qR [Occ=Once] ->
              GHC.Base.$fApplicativeMaybe_$cfmap f_s8qR m_s8qP;
        };

GHC.Base.$fApplicativeMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctorMaybe
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           GHC.Base.$fApplicativeMaybe_$c*>
                                           GHC.Base.$fApplicativeMaybe_$c<*];

GHC.Base.$fMonadMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicativeMaybe
                                     GHC.Base.$fMonadMaybe_$c>>=
                                     GHC.Base.$fApplicativeMaybe_$c*>
                                     GHC.Base.Just
                                     GHC.Base.$fMonadMaybe_$cfail];

GHC.Base.$fAlternativeMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [GHC.Base.$fApplicativeMaybe
                                           GHC.Base.Nothing
                                           GHC.Base.$fAlternativeMaybe_$c<|>
                                           GHC.Base.$fAlternativeMaybe_$csome
                                           GHC.Base.$fAlternativeMaybe_$cmany];

GHC.Base.$fMonadPlusMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [GHC.Base.$fAlternativeMaybe
                                         GHC.Base.$fMonadMaybe
                                         GHC.Base.Nothing
                                         GHC.Base.$fAlternativeMaybe_$c<|>];

GHC.Base.liftA3_$sliftA3 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s8qS a_s8qT b_s8qU c_s8qV]
        case a_s8qT of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s8qX [Occ=Once] ->
              case b_s8qU of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just y_s8qZ [Occ=Once] ->
                    case c_s8qV of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just a4_s8r1 [Occ=Once] ->
                          let {
                            sat_s8r2 [Occ=Once] :: r_a4gI
                            [LclId] =
                                [f_s8qS x_s8qX y_s8qZ a4_s8r1] \u [] f_s8qS x_s8qX y_s8qZ a4_s8r1;
                          } in  GHC.Base.Just [sat_s8r2];
                    };
              };
        };

GHC.Base.liftA3 [InlPrag=INLINABLE]
  :: forall (f :: * -> *) a b c d.
     GHC.Base.Applicative f =>
     (a -> b -> c -> d) -> f a -> f b -> f c -> f d
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(A,A,1*C1(C1(U)),1*C1(C1(C1(U))),A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s8r3 f1_s8r4 a1_s8r5 b1_s8r6 c1_s8r7]
        let {
          sat_s8r8 [Occ=Once] :: f_a4f9 (c_a4fc -> d_a4fd)
          [LclId] =
              [$dApplicative_s8r3 f1_s8r4 a1_s8r5 b1_s8r6] \u []
                  GHC.Base.liftA2 $dApplicative_s8r3 f1_s8r4 a1_s8r5 b1_s8r6;
        } in  GHC.Base.<*> $dApplicative_s8r3 sat_s8r8 c1_s8r7;

GHC.Base.liftA_$sliftA [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Base.Maybe a1 -> GHC.Base.Maybe r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fApplicativeMaybe_$cfmap eta_B2 eta_B1;

GHC.Base.liftA [InlPrag=INLINABLE]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> b) -> f a -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(A,1*C1(U),1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s8r9 f1_s8ra a1_s8rb]
        let {
          sat_s8rc [Occ=Once] :: f_a4gQ (a_a4gR -> b_a4gS)
          [LclId] =
              [$dApplicative_s8r9 f1_s8ra] \u []
                  GHC.Base.pure $dApplicative_s8r9 f1_s8ra;
        } in  GHC.Base.<*> $dApplicative_s8r9 sat_s8rc a1_s8rb;

GHC.Base.$fFunctor(,)_$cfmap
  :: forall a1 a2 b. (a2 -> b) -> (a1, a2) -> (a1, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_s8rd ds_s8re]
        case ds_s8re of {
          (,) x_s8rg [Occ=Once] y_s8rh [Occ=Once] ->
              let {
                sat_s8ri [Occ=Once] :: b_a4N0
                [LclId] =
                    [f_s8rd y_s8rh] \u [] f_s8rd y_s8rh;
              } in  (,) [x_s8rg sat_s8ri];
        };

GHC.Base.$fFunctor(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Functor ((,) a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctor(,)_$cfmap
                                       GHC.Base.$fFunctor(,)_$c<$];

GHC.Base.$fApplicative(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid a => GHC.Base.Applicative ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,A),1*U,A,A)>m] =
    [] \r [$dMonoid_s8rj]
        let {
          lvl3_s8rk [Occ=OnceL] :: a_a4vv
          [LclId] =
              [$dMonoid_s8rj] \u [] GHC.Base.mempty $dMonoid_s8rj; } in
        let {
          sat_s8rq [Occ=Once]
            :: forall a b. (a_a4vv, a) -> (a_a4vv, b) -> (a_a4vv, a)
          [LclId] =
              [$dMonoid_s8rj] \r [eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$c<* $dMonoid_s8rj eta_B2 eta_B1; } in
        let {
          sat_s8rp [Occ=Once]
            :: forall a b. (a_a4vv, a) -> (a_a4vv, b) -> (a_a4vv, b)
          [LclId] =
              [$dMonoid_s8rj] \r [eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$c*> $dMonoid_s8rj eta_B2 eta_B1; } in
        let {
          sat_s8ro [Occ=Once]
            :: forall a b c.
               (a -> b -> c) -> (a_a4vv, a) -> (a_a4vv, b) -> (a_a4vv, c)
          [LclId] =
              [$dMonoid_s8rj] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$cliftA2
                      $dMonoid_s8rj eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s8rn [Occ=Once]
            :: forall a b. (a_a4vv, a -> b) -> (a_a4vv, a) -> (a_a4vv, b)
          [LclId] =
              [$dMonoid_s8rj] \r [eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$c<*> $dMonoid_s8rj eta_B2 eta_B1; } in
        let {
          sat_s8rm [Occ=Once] :: forall a. a -> (a_a4vv, a)
          [LclId] =
              [lvl3_s8rk] \r [x_s8rl] (,) [lvl3_s8rk x_s8rl];
        } in 
          GHC.Base.C:Applicative [GHC.Base.$fFunctor(,)
                                  sat_s8rm
                                  sat_s8rn
                                  sat_s8ro
                                  sat_s8rp
                                  sat_s8rq];

lvl2_r7PL :: forall a1 a2. [GHC.Types.Char] -> (a1, a2)
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s8rr] GHC.Err.errorWithoutStackTrace eta_s8rr;

GHC.Base.$fMonad(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid a => GHC.Base.Monad ((,) a)
[GblId[DFunId], Arity=1, Str=<L,U(U(C(C1(U)),A,A),U,A,A)>m] =
    [] \r [$dMonoid_s8rs]
        let {
          lvl3_s8rt [Occ=OnceL] :: a_a4ul
          [LclId] =
              [$dMonoid_s8rs] \u [] GHC.Base.mempty $dMonoid_s8rs; } in
        let {
          sat_s8ry [Occ=Once] :: forall a. a -> (a_a4ul, a)
          [LclId] =
              [lvl3_s8rt] \r [x_s8rx] (,) [lvl3_s8rt x_s8rx]; } in
        let {
          sat_s8rw [Occ=Once]
            :: forall a b. (a_a4ul, a) -> (a_a4ul, b) -> (a_a4ul, b)
          [LclId] =
              [$dMonoid_s8rs] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonad(,)_$c>> $dMonoid_s8rs eta_B2 eta_B1; } in
        let {
          sat_s8rv [Occ=Once]
            :: forall a b. (a_a4ul, a) -> (a -> (a_a4ul, b)) -> (a_a4ul, b)
          [LclId] =
              [$dMonoid_s8rs] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonad(,)_$c>>= $dMonoid_s8rs eta_B2 eta_B1; } in
        let {
          sat_s8ru [Occ=Once] :: GHC.Base.Applicative ((,) a_a4ul)
          [LclId] =
              [$dMonoid_s8rs] \u [] GHC.Base.$fApplicative(,) $dMonoid_s8rs;
        } in 
          GHC.Base.C:Monad [sat_s8ru sat_s8rv sat_s8rw sat_s8ry lvl2_r7PL];

GHC.Base.C:Monad
  :: forall (m :: * -> *).
     GHC.Base.Applicative m =>
     (forall a b. m a -> (a -> m b) -> m b)
     -> (forall a b. m a -> m b -> m b)
     -> (forall a. a -> m a)
     -> (forall a. GHC.Base.String -> m a)
     -> GHC.Base.Monad m
[GblId[DataCon],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Monad [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.C:Functor
  :: forall (f :: * -> *).
     (forall a b. (a -> b) -> f a -> f b)
     -> (forall a b. a -> f b -> f a) -> GHC.Base.Functor f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.C:Functor [eta_B2 eta_B1];

GHC.Base.C:Applicative
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     (forall a. a -> f a)
     -> (forall a b. f (a -> b) -> f a -> f b)
     -> (forall a b c. (a -> b -> c) -> f a -> f b -> f c)
     -> (forall a b. f a -> f b -> f b)
     -> (forall a b. f a -> f b -> f a)
     -> GHC.Base.Applicative f
[GblId[DataCon],
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Applicative [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.C:Semigroup
  :: forall a.
     (a -> a -> a)
     -> (GHC.Base.NonEmpty a -> a)
     -> (forall b. GHC.Real.Integral b => b -> a -> a)
     -> GHC.Base.Semigroup a
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Semigroup [eta_B3 eta_B2 eta_B1];

GHC.Base.C:Monoid
  :: forall a.
     GHC.Base.Semigroup a =>
     a -> (a -> a -> a) -> ([a] -> a) -> GHC.Base.Monoid a
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Monoid [eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.Nothing :: forall a. GHC.Base.Maybe a
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Nothing! [];

GHC.Base.Just :: forall a. a -> GHC.Base.Maybe a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.Just [eta_B1];

GHC.Base.O :: forall a. a -> GHC.Base.Opaque
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.O [eta_B1];

GHC.Base.:| :: forall a. a -> [a] -> GHC.Base.NonEmpty a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.:| [eta_B2 eta_B1];

GHC.Base.C:MonadPlus
  :: forall (m :: * -> *).
     (GHC.Base.Alternative m, GHC.Base.Monad m) =>
     (forall a. m a)
     -> (forall a. m a -> m a -> m a) -> GHC.Base.MonadPlus m
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:MonadPlus [eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.C:Alternative
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     (forall a. f a)
     -> (forall a. f a -> f a -> f a)
     -> (forall a. f a -> f [a])
     -> (forall a. f a -> f [a])
     -> GHC.Base.Alternative f
[GblId[DataCon],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Alternative [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 15:54:42.490467847 UTC

GHC.Base.$p1Monad
  :: forall (m :: * -> *). GHC.Base.Monad m => GHC.Base.Applicative m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>] =
    [] \r [v_s7PN]
        case v_s7PN of {
          GHC.Base.C:Monad v_s7PP [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s7PP;
        };

GHC.Base.>>=
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. m a -> (a -> m b) -> m b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>] =
    [] \r [v_s7PU]
        case v_s7PU of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           v_s7PX [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s7PX;
        };

GHC.Base.>>
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. m a -> m b -> m b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>] =
    [] \r [v_s7Q1]
        case v_s7Q1 of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s7Q5 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_s7Q5;
        };

GHC.Base.return
  :: forall (m :: * -> *). GHC.Base.Monad m => forall a. a -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>] =
    [] \r [v_s7Q8]
        case v_s7Q8 of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s7Qd [Occ=Once]
                           _ [Occ=Dead] ->
              v_s7Qd;
        };

GHC.Base.fail
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a. GHC.Base.String -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>] =
    [] \r [v_s7Qf]
        case v_s7Qf of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_s7Ql [Occ=Once] ->
              v_s7Ql;
        };

GHC.Base.fmap
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     forall a b. (a -> b) -> f a -> f b
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_s7Qm]
        case v_s7Qm of {
          GHC.Base.C:Functor v_s7Qo [Occ=Once] _ [Occ=Dead] -> v_s7Qo;
        };

GHC.Base.<$
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     forall a b. a -> f b -> f a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_s7Qq]
        case v_s7Qq of {
          GHC.Base.C:Functor _ [Occ=Dead] v_s7Qt [Occ=Once] -> v_s7Qt;
        };

GHC.Base.$p1Applicative
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Base.Functor f
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>] =
    [] \r [v_s7Qu]
        case v_s7Qu of {
          GHC.Base.C:Applicative v_s7Qw [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7Qw;
        };

GHC.Base.pure
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a. a -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>] =
    [] \r [v_s7QC]
        case v_s7QC of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 v_s7QF [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7QF;
        };

GHC.Base.<*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f (a -> b) -> f a -> f b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>] =
    [] \r [v_s7QK]
        case v_s7QK of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7QO [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7QO;
        };

GHC.Base.liftA2
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b c. (a -> b -> c) -> f a -> f b -> f c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>] =
    [] \r [v_s7QS]
        case v_s7QS of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7QX [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7QX;
        };

GHC.Base.*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>] =
    [] \r [v_s7R0]
        case v_s7R0 of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7R6 [Occ=Once]
                                 _ [Occ=Dead] ->
              v_s7R6;
        };

GHC.Base.<*
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>] =
    [] \r [v_s7R8]
        case v_s7R8 of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7Rf [Occ=Once] ->
              v_s7Rf;
        };

GHC.Base.<> :: forall a. GHC.Base.Semigroup a => a -> a -> a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_s7Rg]
        case v_s7Rg of {
          GHC.Base.C:Semigroup v_s7Ri [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
              v_s7Ri;
        };

GHC.Base.sconcat
  :: forall a. GHC.Base.Semigroup a => GHC.Base.NonEmpty a -> a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_s7Rl]
        case v_s7Rl of {
          GHC.Base.C:Semigroup _ [Occ=Dead] v_s7Ro [Occ=Once] _ [Occ=Dead] ->
              v_s7Ro;
        };

GHC.Base.stimes
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b. GHC.Real.Integral b => b -> a -> a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_s7Rq]
        case v_s7Rq of {
          GHC.Base.C:Semigroup _ [Occ=Dead] _ [Occ=Dead] v_s7Ru [Occ=Once] ->
              v_s7Ru;
        };

GHC.Base.$p1Monoid
  :: forall a. GHC.Base.Monoid a => GHC.Base.Semigroup a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_s7Rv]
        case v_s7Rv of {
          GHC.Base.C:Monoid v_s7Rx [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
              v_s7Rx;
        };

GHC.Base.mempty :: forall a. GHC.Base.Monoid a => a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_s7RB]
        case v_s7RB of {
          GHC.Base.C:Monoid _ [Occ=Dead]
                            v_s7RE [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
              v_s7RE;
        };

GHC.Base.mappend :: forall a. GHC.Base.Monoid a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_s7RH]
        case v_s7RH of {
          GHC.Base.C:Monoid _ [Occ=Dead]
                            _ [Occ=Dead]
                            v_s7RL [Occ=Once]
                            _ [Occ=Dead] ->
              v_s7RL;
        };

GHC.Base.mconcat :: forall a. GHC.Base.Monoid a => [a] -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_s7RN]
        case v_s7RN of {
          GHC.Base.C:Monoid _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            v_s7RS [Occ=Once] ->
              v_s7RS;
        };

GHC.Base.$p1MonadPlus
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Base.Alternative m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_s7RT]
        case v_s7RT of {
          GHC.Base.C:MonadPlus v_s7RV [Occ=Once]
                               _ [Occ=Dead]
                               _ [Occ=Dead]
                               _ [Occ=Dead] ->
              v_s7RV;
        };

GHC.Base.$p2MonadPlus
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => GHC.Base.Monad m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_s7RZ]
        case v_s7RZ of {
          GHC.Base.C:MonadPlus _ [Occ=Dead]
                               v_s7S2 [Occ=Once]
                               _ [Occ=Dead]
                               _ [Occ=Dead] ->
              v_s7S2;
        };

GHC.Base.mzero
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => forall a. m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_s7S5]
        case v_s7S5 of {
          GHC.Base.C:MonadPlus _ [Occ=Dead]
                               _ [Occ=Dead]
                               v_s7S9 [Occ=Once]
                               _ [Occ=Dead] ->
              v_s7S9;
        };

GHC.Base.mplus
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a. m a -> m a -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_s7Sb]
        case v_s7Sb of {
          GHC.Base.C:MonadPlus _ [Occ=Dead]
                               _ [Occ=Dead]
                               _ [Occ=Dead]
                               v_s7Sg [Occ=Once] ->
              v_s7Sg;
        };

GHC.Base.$p1Alternative
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     GHC.Base.Applicative f
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>] =
    [] \r [v_s7Sh]
        case v_s7Sh of {
          GHC.Base.C:Alternative v_s7Sj [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7Sj;
        };

GHC.Base.empty
  :: forall (f :: * -> *). GHC.Base.Alternative f => forall a. f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>] =
    [] \r [v_s7So]
        case v_s7So of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 v_s7Sr [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7Sr;
        };

GHC.Base.<|>
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f a -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>] =
    [] \r [v_s7Sv]
        case v_s7Sv of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7Sz [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_s7Sz;
        };

GHC.Base.some
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>] =
    [] \r [v_s7SC]
        case v_s7SC of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7SH [Occ=Once]
                                 _ [Occ=Dead] ->
              v_s7SH;
        };

GHC.Base.many
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>] =
    [] \r [v_s7SJ]
        case v_s7SJ of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_s7SP [Occ=Once] ->
              v_s7SP;
        };

GHC.Base.eqString [Occ=LoopBreaker]
  :: GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s7SQ ds1_s7SR]
        case ds_s7SQ of {
          [] ->
              case ds1_s7SR of {
                [] -> GHC.Types.True [];
                : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
              };
          : c1_s7SW [Occ=Once!] cs1_s7SX [Occ=Once] ->
              case ds1_s7SR of {
                [] -> GHC.Types.False [];
                : c2_s7SZ [Occ=Once!] cs2_s7T0 [Occ=Once] ->
                    case c1_s7SW of {
                      GHC.Types.C# x_s7T2 [Occ=Once] ->
                          case c2_s7SZ of {
                            GHC.Types.C# y_s7T4 [Occ=Once] ->
                                case eqChar# [x_s7T2 y_s7T4] of {
                                  __DEFAULT -> GHC.Types.False [];
                                  1# -> GHC.Base.eqString cs1_s7SX cs2_s7T0;
                                };
                          };
                    };
              };
        };

GHC.Base.when2
  :: GHC.Types.Bool
     -> GHC.Types.IO ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [p_s7T6 s_s7T7 void_0E]
        case p_s7T6 of {
          GHC.Types.False -> Unit# [GHC.Tuple.()];
          GHC.Types.True -> s_s7T7 GHC.Prim.void#;
        };

GHC.Base.when_$swhen1 [InlPrag=INLINABLE]
  :: GHC.Types.Bool -> GHC.Types.IO () -> GHC.Types.IO ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.Base.when2 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.$fFunctorIO2
  :: forall a b.
     (a -> b)
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_s7Ta x_s7Tb void_0E]
        case x_s7Tb GHC.Prim.void# of {
          Unit# ipv1_s7Tf [Occ=Once] ->
              let {
                sat_s7Tg [Occ=Once] :: b_a4qK
                [LclId] =
                    [f_s7Ta ipv1_s7Tf] \u [] f_s7Ta ipv1_s7Tf;
              } in  Unit# [sat_s7Tg];
        };

GHC.Base.$fFunctorIO1
  :: forall a b.
     a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S(SL)),1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [x_s7Th eta_s7Ti void_0E]
        case eta_s7Ti GHC.Prim.void# of {
          Unit# _ [Occ=Dead] -> Unit# [x_s7Th];
        };

GHC.Base.$fFunctorIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.Types.IO
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctorIO2
                                       GHC.Base.$fFunctorIO1];

GHC.Base.$fAlternativeMaybe1 :: forall a. GHC.Base.Maybe [a]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [GHC.Types.[]];

GHC.Base.$fAlternativeMaybe_$cmany
  :: forall a. GHC.Base.Maybe a -> GHC.Base.Maybe [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s7Tn]
        let {
          many_v_s7To [Occ=LoopBreaker] :: GHC.Base.Maybe [a_a4IZ]
          [LclId] =
              [v_s7Tn many_v_s7To] \u []
                  case v_s7Tn of {
                    GHC.Base.Nothing -> GHC.Base.$fAlternativeMaybe1;
                    GHC.Base.Just x_s7Tq [Occ=Once] ->
                        case many_v_s7To of {
                          GHC.Base.Nothing -> GHC.Base.$fAlternativeMaybe1;
                          GHC.Base.Just y_s7Ts [Occ=Once] ->
                              let {
                                sat_s7Tt [Occ=Once] :: [a_a4IZ]
                                [LclId] =
                                    CCCS :! [x_s7Tq y_s7Ts];
                              } in  GHC.Base.Just [sat_s7Tt];
                        };
                  };
        } in  many_v_s7To;

GHC.Base.$fAlternativeMaybe_$csome
  :: forall a. GHC.Base.Maybe a -> GHC.Base.Maybe [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s7Tu]
        let {
          some_v_s7Tv [Occ=LoopBreaker] :: GHC.Base.Maybe [a_a4IR]
          [LclId] =
              [v_s7Tu some_v_s7Tv] \u []
                  case v_s7Tu of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_s7Tx [Occ=Once*] ->
                        case some_v_s7Tv of {
                          GHC.Base.Nothing ->
                              let {
                                sat_s7Tz [Occ=Once] :: [a_a4IR]
                                [LclId] =
                                    CCCS :! [x_s7Tx GHC.Types.[]];
                              } in  GHC.Base.Just [sat_s7Tz];
                          GHC.Base.Just ipv_s7TA [Occ=Once] ->
                              let {
                                sat_s7TB [Occ=Once] :: [a_a4IR]
                                [LclId] =
                                    CCCS :! [x_s7Tx ipv_s7TA];
                              } in  GHC.Base.Just [sat_s7TB];
                        };
                  };
        } in  some_v_s7Tv;

GHC.Base.ap_$sap [InlPrag=INLINABLE]
  :: forall a b.
     GHC.Base.Maybe (a -> b) -> GHC.Base.Maybe a -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_s7TC m2_s7TD]
        case m1_s7TC of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s7TF [Occ=Once!] ->
              case m2_s7TD of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_s7TH [Occ=Once] ->
                    let {
                      sat_s7TI [Occ=Once] :: b_a447
                      [LclId] =
                          [x_s7TF x1_s7TH] \u [] x_s7TF x1_s7TH;
                    } in  GHC.Base.Just [sat_s7TI];
              };
        };

GHC.Base.liftM5_$sliftM5 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe a4
     -> GHC.Base.Maybe a5
     -> GHC.Base.Maybe r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><S,1*U><L,1*U><L,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s7TJ m1_s7TK m2_s7TL m3_s7TM m4_s7TN m5_s7TO]
        case m1_s7TK of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s7TQ [Occ=Once] ->
              case m2_s7TL of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_s7TS [Occ=Once] ->
                    case m3_s7TM of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just x2_s7TU [Occ=Once] ->
                          case m4_s7TN of {
                            GHC.Base.Nothing -> GHC.Base.Nothing [];
                            GHC.Base.Just x3_s7TW [Occ=Once] ->
                                case m5_s7TO of {
                                  GHC.Base.Nothing -> GHC.Base.Nothing [];
                                  GHC.Base.Just x4_s7TY [Occ=Once] ->
                                      let {
                                        sat_s7TZ [Occ=Once] :: r_a46A
                                        [LclId] =
                                            [f_s7TJ x_s7TQ x1_s7TS x2_s7TU x3_s7TW x4_s7TY] \u []
                                                f_s7TJ x_s7TQ x1_s7TS x2_s7TU x3_s7TW x4_s7TY;
                                      } in  GHC.Base.Just [sat_s7TZ];
                                };
                          };
                    };
              };
        };

GHC.Base.liftM4_$sliftM4 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe a4
     -> GHC.Base.Maybe r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><S,1*U><L,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s7U0 m1_s7U1 m2_s7U2 m3_s7U3 m4_s7U4]
        case m1_s7U1 of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s7U6 [Occ=Once] ->
              case m2_s7U2 of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_s7U8 [Occ=Once] ->
                    case m3_s7U3 of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just x2_s7Ua [Occ=Once] ->
                          case m4_s7U4 of {
                            GHC.Base.Nothing -> GHC.Base.Nothing [];
                            GHC.Base.Just x3_s7Uc [Occ=Once] ->
                                let {
                                  sat_s7Ud [Occ=Once] :: r_a48L
                                  [LclId] =
                                      [f_s7U0 x_s7U6 x1_s7U8 x2_s7Ua x3_s7Uc] \u []
                                          f_s7U0 x_s7U6 x1_s7U8 x2_s7Ua x3_s7Uc;
                                } in  GHC.Base.Just [sat_s7Ud];
                          };
                    };
              };
        };

GHC.Base.liftM3_$sliftM3 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s7Ue m1_s7Uf m2_s7Ug m3_s7Uh]
        case m1_s7Uf of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s7Uj [Occ=Once] ->
              case m2_s7Ug of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_s7Ul [Occ=Once] ->
                    case m3_s7Uh of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just x2_s7Un [Occ=Once] ->
                          let {
                            sat_s7Uo [Occ=Once] :: r_a4az
                            [LclId] =
                                [f_s7Ue x_s7Uj x1_s7Ul x2_s7Un] \u []
                                    f_s7Ue x_s7Uj x1_s7Ul x2_s7Un;
                          } in  GHC.Base.Just [sat_s7Uo];
                    };
              };
        };

GHC.Base.liftM2_$sliftM2 [InlPrag=INLINABLE]
  :: forall a1 a2 r.
     (a1 -> a2 -> r)
     -> GHC.Base.Maybe a1 -> GHC.Base.Maybe a2 -> GHC.Base.Maybe r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s7Up m1_s7Uq m2_s7Ur]
        case m1_s7Uq of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s7Ut [Occ=Once] ->
              case m2_s7Ur of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_s7Uv [Occ=Once] ->
                    let {
                      sat_s7Uw [Occ=Once] :: r_a4c0
                      [LclId] =
                          [f_s7Up x_s7Ut x1_s7Uv] \u [] f_s7Up x_s7Ut x1_s7Uv;
                    } in  GHC.Base.Just [sat_s7Uw];
              };
        };

GHC.Base.liftM_$sliftM [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Base.Maybe a1 -> GHC.Base.Maybe r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s7Ux m1_s7Uy]
        case m1_s7Uy of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s7UA [Occ=Once] ->
              let {
                sat_s7UB [Occ=Once] :: r_a4d4
                [LclId] =
                    [f_s7Ux x_s7UA] \u [] f_s7Ux x_s7UA;
              } in  GHC.Base.Just [sat_s7UB];
        };

GHC.Base.when1 :: GHC.Base.Maybe ()
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [GHC.Tuple.()];

GHC.Base.when_$swhen [InlPrag=INLINABLE]
  :: GHC.Types.Bool -> GHC.Base.Maybe () -> GHC.Base.Maybe ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [p_s7UC s_s7UD]
        case p_s7UC of {
          GHC.Types.False -> GHC.Base.when1;
          GHC.Types.True -> s_s7UD;
        };

GHC.Base.when [InlPrag=INLINABLE]
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Types.Bool -> f () -> f ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U),A,A,A,A)><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s7UF p_s7UG s_s7UH]
        case p_s7UG of {
          GHC.Types.False -> GHC.Base.pure $dApplicative_s7UF GHC.Tuple.();
          GHC.Types.True -> s_s7UH;
        };

GHC.Base.$fApplicativeMaybe_$c<*
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s7UJ ds1_s7UK]
        case ds_s7UJ of wild_s7UL {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] ->
              case ds1_s7UK of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just _ [Occ=Dead] -> wild_s7UL;
              };
        };

GHC.Base.$tc'O3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'O"#;

GHC.Base.$tc'O2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'O3];

GHC.Base.$tcOpaque2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Opaque"#;

GHC.Base.$tcOpaque1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcOpaque2];

GHC.Base.$tcMonadPlus2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "MonadPlus"#;

GHC.Base.$tcMonadPlus1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMonadPlus2];

GHC.Base.$tcMonad2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Monad"#;

GHC.Base.$tcMonad1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMonad2];

GHC.Base.$tc'C:Monoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Monoid"#;

GHC.Base.$tc'C:Monoid2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'C:Monoid3];

GHC.Base.$tcMonoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Monoid"#;

GHC.Base.$tcMonoid2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMonoid3];

GHC.Base.$tcSemigroup2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Semigroup"#;

GHC.Base.$tcSemigroup1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcSemigroup2];

GHC.Base.$tc':|3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "':|"#;

GHC.Base.$tc':|2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc':|3];

GHC.Base.$tcNonEmpty2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty"#;

GHC.Base.$tcNonEmpty1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcNonEmpty2];

GHC.Base.$tcAlternative3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Alternative"#;

GHC.Base.$tcAlternative2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcAlternative3];

GHC.Base.$tcApplicative2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Applicative"#;

GHC.Base.$tcApplicative1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcApplicative2];

GHC.Base.$tcFunctor2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Functor"#;

GHC.Base.$tcFunctor1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcFunctor2];

GHC.Base.$tc'Just3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Just"#;

GHC.Base.$tc'Just2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'Just3];

GHC.Base.$tc'Nothing3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Nothing"#;

GHC.Base.$tc'Nothing2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'Nothing3];

GHC.Base.$tcMaybe2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Maybe"#;

GHC.Base.$tcMaybe1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMaybe2];

$krep_r7Pr :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_r7Ps :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep_r7Pr];

$krep2_r7Pt :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep1_r7Ps];

$krep3_r7Pu :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r7Pr GHC.Types.[]];

$krep4_r7Pv :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep3_r7Pu];

$krep5_r7Pw :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r7Pv $krep_r7Pr];

$krep6_r7Px :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.Base.$tcMonoid1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$* $krep6_r7Px];

GHC.Base.$tcAlternative1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep6_r7Px];

GHC.Base.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Base"#;

GHC.Base.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$trModule2];

GHC.Base.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Base.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$trModule4];

GHC.Base.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Base.$trModule3
                                     GHC.Base.$trModule1];

GHC.Base.$tcMaybe :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [625655543500963593##
                                    6391758309165051762##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMaybe1
                                    0#
                                    GHC.Types.krep$*Arr*];

GHC.Base.$tc'Nothing1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep3_r7Pu];

GHC.Base.$tc'Just1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr
                                         GHC.Base.$tc'Nothing1];

GHC.Base.$tc'Nothing :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14633289528184412192##
                                    12773126156421542470##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'Nothing2
                                    1#
                                    GHC.Base.$tc'Nothing1];

GHC.Base.$tc'Just :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5794512144280699493##
                                    9434423460978218117##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'Just2
                                    1#
                                    GHC.Base.$tc'Just1];

GHC.Base.$tcFunctor :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [211182333006544237##
                                    5556320544348084514##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcFunctor1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcApplicative :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12705055220831243597##
                                    2963353171490466073##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcApplicative1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcAlternative :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1073491102990665358##
                                    14320772755704808948##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcAlternative2
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcNonEmpty :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13207016872645468285##
                                    3455542966739695982##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcNonEmpty1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep7_r7Py :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcNonEmpty
                                              $krep3_r7Pu];

$krep8_r7Pz :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r7Pv $krep7_r7Py];

GHC.Base.$tc':|1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep8_r7Pz];

GHC.Base.$tc':| :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9440832435183810765##
                                    3053237465234607583##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc':|2
                                    1#
                                    GHC.Base.$tc':|1];

GHC.Base.$tcSemigroup :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16195352186364298277##
                                    3285685594139281062##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcSemigroup1
                                    0#
                                    GHC.Base.$tcMonoid1];

$krep9_r7PA :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcSemigroup
                                              $krep3_r7Pu];

GHC.Base.$tcMonoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13838560045895743776##
                                    1291018260833769143##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMonoid2
                                    0#
                                    GHC.Base.$tcMonoid1];

$krep10_r7PB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMonoid
                                              $krep3_r7Pu];

$krep11_r7PC :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r7Pw $krep10_r7PB];

$krep12_r7PD :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r7Pt $krep11_r7PC];

$krep13_r7PE :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep12_r7PD];

GHC.Base.$tc'C:Monoid1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep9_r7PA $krep13_r7PE];

GHC.Base.$tc'C:Monoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16099296089107510343##
                                    5895832073319104984##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'C:Monoid2
                                    1#
                                    GHC.Base.$tc'C:Monoid1];

GHC.Base.$tcMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3168880480603756299##
                                    8398240611646296094##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMonad1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcMonadPlus :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14115673251620372550##
                                    14155357326069389390##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMonadPlus1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcOpaque :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9339725405829241186##
                                    15550233501624900571##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcOpaque1
                                    0#
                                    GHC.Types.krep$*];

$krep14_r7PF :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcOpaque
                                              GHC.Types.[]];

GHC.Base.$tc'O1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep14_r7PF];

GHC.Base.$tc'O :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12551274612394834805##
                                    13000664474148134329##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'O2
                                    1#
                                    GHC.Base.$tc'O1];

GHC.Base.quotRemInt
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s7UP ds1_s7UQ]
        case ds_s7UP of {
          GHC.Types.I# x_s7US [Occ=Once] ->
              case ds1_s7UQ of {
                GHC.Types.I# y_s7UU [Occ=Once] ->
                    case quotRemInt# [x_s7US y_s7UU] of {
                      (#,#) ipv_s7UW [Occ=Once] ipv1_s7UX [Occ=Once] ->
                          let {
                            sat_s7UZ [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [ipv1_s7UX]; } in
                          let {
                            sat_s7UY [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [ipv_s7UW];
                          } in  (,) [sat_s7UY sat_s7UZ];
                    };
              };
        };

GHC.Base.modInt :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s7V0 ds1_s7V1]
        case ds_s7V0 of {
          GHC.Types.I# x_s7V3 [Occ=Once] ->
              case ds1_s7V1 of {
                GHC.Types.I# y_s7V5 [Occ=Once] ->
                    case GHC.Classes.modInt# x_s7V3 y_s7V5 of wild2_s7V6 {
                      __DEFAULT -> GHC.Types.I# [wild2_s7V6];
                    };
              };
        };

GHC.Base.divInt :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s7V7 ds1_s7V8]
        case ds_s7V7 of {
          GHC.Types.I# x_s7Va [Occ=Once] ->
              case ds1_s7V8 of {
                GHC.Types.I# y_s7Vc [Occ=Once] ->
                    case GHC.Classes.divInt# x_s7Va y_s7Vc of wild2_s7Vd {
                      __DEFAULT -> GHC.Types.I# [wild2_s7Vd];
                    };
              };
        };

GHC.Base.remInt [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s7Ve ds1_s7Vf]
        case ds_s7Ve of {
          GHC.Types.I# x_s7Vh [Occ=Once] ->
              case ds1_s7Vf of {
                GHC.Types.I# y_s7Vj [Occ=Once] ->
                    case remInt# [x_s7Vh y_s7Vj] of wild2_s7Vk {
                      __DEFAULT -> GHC.Types.I# [wild2_s7Vk];
                    };
              };
        };

GHC.Base.quotInt [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s7Vl ds1_s7Vm]
        case ds_s7Vl of {
          GHC.Types.I# x_s7Vo [Occ=Once] ->
              case ds1_s7Vm of {
                GHC.Types.I# y_s7Vq [Occ=Once] ->
                    case quotInt# [x_s7Vo y_s7Vq] of wild2_s7Vr {
                      __DEFAULT -> GHC.Types.I# [wild2_s7Vr];
                    };
              };
        };

GHC.Base.getTag [InlPrag=INLINE (sat-args=1)]
  :: forall a. a -> GHC.Prim.Int#
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [eta_B1]
        case eta_B1 of sat_s7Vs { __DEFAULT -> dataToTag# [sat_s7Vs]; };

GHC.Base.$fMonadIO1
  :: forall a b.
     GHC.Types.IO a
     -> (a -> GHC.Types.IO b)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_s7Vt k_s7Vu void_0E]
        case ds_s7Vt GHC.Prim.void# of {
          Unit# ipv1_s7Vy [Occ=Once] -> k_s7Vu ipv1_s7Vy GHC.Prim.void#;
        };

GHC.Base.bindIO
  :: forall a b.
     GHC.Types.IO a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.Base.$fMonadIO1 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.$fApplicativeIO2
  :: forall a b.
     GHC.Types.IO a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_s7Vz k_s7VA void_0E]
        case ds_s7Vz GHC.Prim.void# of {
          Unit# _ [Occ=Dead] -> k_s7VA GHC.Prim.void#;
        };

GHC.Base.thenIO
  :: forall a b. GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.Base.$fApplicativeIO2 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.unIO1 :: forall a. GHC.Types.IO a -> GHC.Types.IO a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s7VF] ds_s7VF;

GHC.Base.unIO
  :: forall a.
     GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.unIO1 eta_B1;

GHC.Base.$fApplicativeIO4
  :: forall a.
     a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [x_s7VG void_0E] Unit# [x_s7VG];

GHC.Base.returnIO :: forall a. a -> GHC.Types.IO a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [eta_B2 void_0E]
        GHC.Base.$fApplicativeIO4 eta_B2 GHC.Prim.void#;

GHC.Base.$fApplicativeIO3
  :: forall b a.
     GHC.Types.IO (a -> b)
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_s7VI m2_s7VJ void_0E]
        case m1_s7VI GHC.Prim.void# of {
          Unit# ipv1_s7VN [Occ=Once!] ->
              case m2_s7VJ GHC.Prim.void# of {
                Unit# ipv3_s7VQ [Occ=Once] ->
                    let {
                      sat_s7VR [Occ=Once] :: b_a4Jk
                      [LclId] =
                          [ipv1_s7VN ipv3_s7VQ] \u [] ipv1_s7VN ipv3_s7VQ;
                    } in  Unit# [sat_s7VR];
              };
        };

GHC.Base.liftA_$sliftA1 [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Types.IO a1 -> GHC.Types.IO r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.Base.$fFunctorIO2 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.ap1
  :: forall a b.
     GHC.Types.IO (a -> b)
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_s7VS m2_s7VT void_0E]
        case m1_s7VS GHC.Prim.void# of {
          Unit# ipv1_s7VX [Occ=Once!] ->
              case m2_s7VT GHC.Prim.void# of {
                Unit# ipv3_s7W0 [Occ=Once] ->
                    let {
                      sat_s7W1 [Occ=Once] :: b_a43H
                      [LclId] =
                          [ipv1_s7VX ipv3_s7W0] \u [] ipv1_s7VX ipv3_s7W0;
                    } in  Unit# [sat_s7W1];
              };
        };

GHC.Base.ap_$sap1 [InlPrag=INLINABLE]
  :: forall a b.
     GHC.Types.IO (a -> b) -> GHC.Types.IO a -> GHC.Types.IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.Base.ap1 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.ap [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     m (a -> b) -> m a -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s7W2 m1_s7W3 m2_s7W4]
        let {
          sat_s7W9 [Occ=Once] :: (a_a437 -> b_a438) -> m_a436 b_a438
          [LclId] =
              [$dMonad_s7W2 m2_s7W4] \r [x1_s7W5]
                  let {
                    sat_s7W8 [Occ=Once] :: a_a437 -> m_a436 b_a438
                    [LclId] =
                        [$dMonad_s7W2 x1_s7W5] \r [x2_s7W6]
                            let {
                              sat_s7W7 [Occ=Once] :: b_a438
                              [LclId] =
                                  [x1_s7W5 x2_s7W6] \u [] x1_s7W5 x2_s7W6;
                            } in  GHC.Base.return $dMonad_s7W2 sat_s7W7;
                  } in  GHC.Base.>>= $dMonad_s7W2 m2_s7W4 sat_s7W8;
        } in  GHC.Base.>>= $dMonad_s7W2 m1_s7W3 sat_s7W9;

GHC.Base.liftM1
  :: forall a1 a2 r.
     (a1 -> a2 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_s7Wa m1_s7Wb m2_s7Wc void_0E]
        case m1_s7Wb GHC.Prim.void# of {
          Unit# ipv1_s7Wg [Occ=Once] ->
              case m2_s7Wc GHC.Prim.void# of {
                Unit# ipv3_s7Wj [Occ=Once] ->
                    let {
                      sat_s7Wk [Occ=Once] :: r_a4br
                      [LclId] =
                          [f_s7Wa ipv1_s7Wg ipv3_s7Wj] \u [] f_s7Wa ipv1_s7Wg ipv3_s7Wj;
                    } in  Unit# [sat_s7Wk];
              };
        };

GHC.Base.liftM2_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 r.
     (a1 -> a2 -> r)
     -> GHC.Types.IO a1 -> GHC.Types.IO a2 -> GHC.Types.IO r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 void_0E]
        GHC.Base.liftM1 eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.liftM2 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s7Wl f_s7Wm m1_s7Wn m2_s7Wo]
        let {
          sat_s7Wt [Occ=Once] :: a1_a4aI -> m_a4aH r_a4aK
          [LclId] =
              [$dMonad_s7Wl f_s7Wm m2_s7Wo] \r [x1_s7Wp]
                  let {
                    sat_s7Ws [Occ=Once] :: a2_a4aJ -> m_a4aH r_a4aK
                    [LclId] =
                        [$dMonad_s7Wl f_s7Wm x1_s7Wp] \r [x2_s7Wq]
                            let {
                              sat_s7Wr [Occ=Once] :: r_a4aK
                              [LclId] =
                                  [f_s7Wm x1_s7Wp x2_s7Wq] \u [] f_s7Wm x1_s7Wp x2_s7Wq;
                            } in  GHC.Base.return $dMonad_s7Wl sat_s7Wr;
                  } in  GHC.Base.>>= $dMonad_s7Wl m2_s7Wo sat_s7Ws;
        } in  GHC.Base.>>= $dMonad_s7Wl m1_s7Wn sat_s7Wt;

$cliftA2_r7PG
  :: forall c b a.
     (a -> b -> c)
     -> GHC.Types.IO a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, c #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    sat-only [] \r [f_s7Wu m1_s7Wv m2_s7Ww void_0E]
        case m1_s7Wv GHC.Prim.void# of {
          Unit# ipv1_s7WA [Occ=Once] ->
              case m2_s7Ww GHC.Prim.void# of {
                Unit# ipv3_s7WD [Occ=Once] ->
                    let {
                      sat_s7WE [Occ=Once] :: c_a4Jw
                      [LclId] =
                          [f_s7Wu ipv1_s7WA ipv3_s7WD] \u [] f_s7Wu ipv1_s7WA ipv3_s7WD;
                    } in  Unit# [sat_s7WE];
              };
        };

GHC.Base.$fApplicativeIO_$cliftA2 [InlPrag=INLINE (sat-args=0)]
  :: forall a b c.
     (a -> b -> c) -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 void_0E]
        $cliftA2_r7PG eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.liftA1
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_s7WF a_s7WG b_s7WH c_s7WI void_0E]
        case a_s7WG GHC.Prim.void# of {
          Unit# ipv1_s7WM [Occ=Once] ->
              case b_s7WH GHC.Prim.void# of {
                Unit# ipv3_s7WP [Occ=Once] ->
                    case c_s7WI GHC.Prim.void# of {
                      Unit# ipv5_s7WS [Occ=Once] ->
                          let {
                            sat_s7WT [Occ=Once] :: r_a4g0
                            [LclId] =
                                [f_s7WF ipv1_s7WM ipv3_s7WP ipv5_s7WS] \u []
                                    f_s7WF ipv1_s7WM ipv3_s7WP ipv5_s7WS;
                          } in  Unit# [sat_s7WT];
                    };
              };
        };

GHC.Base.liftA3_$sliftA1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 void_0E]
        GHC.Base.liftA1 eta_B5 eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.$fSemigroupIO2
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Types.IO a
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s7WU eta_s7WV eta1_s7WW void_0E]
        case eta_s7WV GHC.Prim.void# of {
          Unit# ipv1_s7X0 [Occ=Once] ->
              case eta1_s7WW GHC.Prim.void# of {
                Unit# ipv3_s7X3 [Occ=Once] ->
                    let {
                      sat_s7X4 [Occ=Once] :: a_a4Al
                      [LclId] =
                          [$dSemigroup_s7WU ipv1_s7X0 ipv3_s7X3] \u []
                              GHC.Base.<> $dSemigroup_s7WU ipv1_s7X0 ipv3_s7X3;
                    } in  Unit# [sat_s7X4];
              };
        };

GHC.Base.$w$csconcat4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Types.IO a
     -> [GHC.Types.IO a]
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><C(S),1*C1(U(U,U))><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s7X5 ww_s7X6 ww1_s7X7 void_0E]
        let {
          go_s7X9 [Occ=LoopBreaker]
            :: GHC.Types.IO a_s6Fu
               -> [GHC.Types.IO a_s6Fu]
               -> GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, a_s6Fu #)
          [LclId,
           Arity=3,
           Str=<C(S),1*C1(U(U,U))><S,1*U><S,U>,
           Unf=OtherCon []] =
              sat-only [w_s7X5 go_s7X9] \r [b_s7Xa ds_s7Xb void_0E]
                  case ds_s7Xb of {
                    [] -> b_s7Xa GHC.Prim.void#;
                    : c_s7Xe [Occ=Once] cs_s7Xf [Occ=Once] ->
                        case b_s7Xa GHC.Prim.void# of {
                          Unit# ipv1_s7Xi [Occ=Once] ->
                              case go_s7X9 c_s7Xe cs_s7Xf GHC.Prim.void# of {
                                Unit# ipv3_s7Xl [Occ=Once] ->
                                    let {
                                      sat_s7Xm [Occ=Once] :: a_s6Fu
                                      [LclId] =
                                          [w_s7X5 ipv1_s7Xi ipv3_s7Xl] \u []
                                              GHC.Base.<> w_s7X5 ipv1_s7Xi ipv3_s7Xl;
                                    } in  Unit# [sat_s7Xm];
                              };
                        };
                  };
        } in  go_s7X9 ww_s7X6 ww1_s7X7 GHC.Prim.void#;

GHC.Base.$fSemigroupIO1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (GHC.Types.IO a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(C(S)S),1*U(1*C1(U(U,U)),1*U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s7Xn w1_s7Xo void_0E]
        case w1_s7Xo of {
          GHC.Base.:| ww1_s7Xr [Occ=Once] ww2_s7Xs [Occ=Once] ->
              GHC.Base.$w$csconcat4 w_s7Xn ww1_s7Xr ww2_s7Xs GHC.Prim.void#;
        };

GHC.Base.$fSemigroupIO [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (GHC.Types.IO a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,A)>m] =
    [] \r [$dSemigroup_s7Xt]
        let {
          sat_s7Xw [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> GHC.Types.IO a_X4J3 -> GHC.Types.IO a_X4J3
          [LclId] =
              [$dSemigroup_s7Xt] \r [eta_B1]
                  GHC.Base.$fSemigroupIO_$cstimes $dSemigroup_s7Xt eta_B1; } in
        let {
          sat_s7Xv [Occ=Once]
            :: GHC.Base.NonEmpty (GHC.Types.IO a_X4J3) -> GHC.Types.IO a_X4J3
          [LclId] =
              [$dSemigroup_s7Xt] \r [eta_B2 void_0E]
                  GHC.Base.$fSemigroupIO1
                      $dSemigroup_s7Xt eta_B2 GHC.Prim.void#; } in
        let {
          sat_s7Xu [Occ=Once]
            :: GHC.Types.IO a_X4J3
               -> GHC.Types.IO a_X4J3 -> GHC.Types.IO a_X4J3
          [LclId] =
              [$dSemigroup_s7Xt] \r [eta_B3 eta_B2 void_0E]
                  GHC.Base.$fSemigroupIO2
                      $dSemigroup_s7Xt eta_B3 eta_B2 GHC.Prim.void#;
        } in  GHC.Base.C:Semigroup [sat_s7Xu sat_s7Xv sat_s7Xw];
GHC.Base.$fSemigroupIO_$cstimes [Occ=LoopBreaker]
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b.
     GHC.Real.Integral b =>
     b -> GHC.Types.IO a -> GHC.Types.IO a
[GblId, Arity=2, Str=<L,U(C(C1(U)),A,A)><L,U>, Unf=OtherCon []] =
    [] \r [$dSemigroup_s7Xx $dIntegral_s7Xy]
        let {
          sat_s7Xz [Occ=Once] :: GHC.Base.Semigroup (GHC.Types.IO a_X4J4)
          [LclId] =
              [$dSemigroup_s7Xx] \u [] GHC.Base.$fSemigroupIO $dSemigroup_s7Xx;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_s7Xy sat_s7Xz;

GHC.Base.$fMonoidIO_$cp1Monoid
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (GHC.Types.IO a)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(C(C1(U)),A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s7XA]
        let {
          sat_s7XB [Occ=Once, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_X4I6
          [LclId] =
              [$dMonoid_s7XA] \u [] GHC.Base.$p1Monoid $dMonoid_s7XA;
        } in  GHC.Base.$fSemigroupIO sat_s7XB;

$cmappend_r7PH
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Types.IO a
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dMonoid_s7XC eta_s7XD eta1_s7XE void_0E]
        case eta_s7XD GHC.Prim.void# of {
          Unit# ipv1_s7XI [Occ=Once] ->
              case eta1_s7XE GHC.Prim.void# of {
                Unit# ipv3_s7XL [Occ=Once] ->
                    let {
                      sat_s7XN [Occ=Once] :: a_X4I8
                      [LclId] =
                          [$dMonoid_s7XC ipv1_s7XI ipv3_s7XL] \u []
                              case GHC.Base.$p1Monoid $dMonoid_s7XC of sat_s7XM {
                                __DEFAULT -> GHC.Base.<> sat_s7XM ipv1_s7XI ipv3_s7XL;
                              };
                    } in  Unit# [sat_s7XN];
              };
        };

GHC.Base.$fMonoidIO_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Types.IO a -> GHC.Types.IO a -> GHC.Types.IO a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 void_0E]
        $cmappend_r7PH eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.$fAlternativeIO1
  :: forall a.
     GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [void_0E] Unit# [GHC.Types.[]];

GHC.Base.$fAlternativeIO2
  :: forall a.
     GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a] #)
[GblId, Arity=2, Str=<C(S(SL)),C(U(U,U))><S,U>, Unf=OtherCon []] =
    [] \r [v_s7XP void_0E]
        let {
          some_v_s7XR [Occ=LoopBreaker]
            :: GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a_a4HN] #)
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              [v_s7XP some_v_s7XR] \r [void_0E]
                  case v_s7XP GHC.Prim.void# of {
                    Unit# ipv1_s7XV [Occ=Once] ->
                        case
                            GHC.IO.mplusIO some_v_s7XR GHC.Base.$fAlternativeIO1 GHC.Prim.void#
                        of
                        { Unit# ipv3_s7XY [Occ=Once] ->
                              let {
                                sat_s7XZ [Occ=Once] :: [a_a4HN]
                                [LclId] =
                                    CCCS :! [ipv1_s7XV ipv3_s7XY];
                              } in  Unit# [sat_s7XZ];
                        };
                  };
        } in  some_v_s7XR GHC.Prim.void#;

GHC.Base.$fAlternativeIO_$cmany
  :: forall a. GHC.Types.IO a -> GHC.Types.IO [a]
[GblId, Arity=1, Str=<L,C(U(U,U))>, Unf=OtherCon []] =
    [] \r [v_s7Y0]
        let {
          many_v_s7Y1 [Occ=LoopBreaker] :: GHC.Types.IO [a_a4HV]
          [LclId] =
              [v_s7Y0 many_v_s7Y1] \u []
                  let {
                    sat_s7Ya [Occ=Once] :: GHC.Types.IO [a_a4HV]
                    [LclId] =
                        [v_s7Y0 many_v_s7Y1] \r [void_0E]
                            case v_s7Y0 GHC.Prim.void# of {
                              Unit# ipv1_s7Y5 [Occ=Once] ->
                                  case many_v_s7Y1 GHC.Prim.void# of {
                                    Unit# ipv3_s7Y8 [Occ=Once] ->
                                        let {
                                          sat_s7Y9 [Occ=Once] :: [a_a4HV]
                                          [LclId] =
                                              CCCS :! [ipv1_s7Y5 ipv3_s7Y8];
                                        } in  Unit# [sat_s7Y9];
                                  };
                            };
                  } in  GHC.IO.mplusIO sat_s7Ya GHC.Base.$fAlternativeIO1;
        } in  many_v_s7Y1;

GHC.Base.liftM9
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Types.IO a5
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_s7Yb m1_s7Yc m2_s7Yd m3_s7Ye m4_s7Yf m5_s7Yg void_0E]
        case m1_s7Yc GHC.Prim.void# of {
          Unit# ipv1_s7Yk [Occ=Once] ->
              case m2_s7Yd GHC.Prim.void# of {
                Unit# ipv3_s7Yn [Occ=Once] ->
                    case m3_s7Ye GHC.Prim.void# of {
                      Unit# ipv5_s7Yq [Occ=Once] ->
                          case m4_s7Yf GHC.Prim.void# of {
                            Unit# ipv7_s7Yt [Occ=Once] ->
                                case m5_s7Yg GHC.Prim.void# of {
                                  Unit# ipv9_s7Yw [Occ=Once] ->
                                      let {
                                        sat_s7Yx [Occ=Once] :: r_a45A
                                        [LclId] =
                                            [f_s7Yb
                                             ipv1_s7Yk
                                             ipv3_s7Yn
                                             ipv5_s7Yq
                                             ipv7_s7Yt
                                             ipv9_s7Yw] \u []
                                                f_s7Yb
                                                    ipv1_s7Yk
                                                    ipv3_s7Yn
                                                    ipv5_s7Yq
                                                    ipv7_s7Yt
                                                    ipv9_s7Yw;
                                      } in  Unit# [sat_s7Yx];
                                };
                          };
                    };
              };
        };

GHC.Base.liftM5_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Types.IO a5
     -> GHC.Types.IO r
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 void_0E]
        GHC.Base.liftM9
            eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.liftM5 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 a4 a5 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s7Yy f_s7Yz m1_s7YA m2_s7YB m3_s7YC m4_s7YD m5_s7YE]
        let {
          sat_s7YP [Occ=Once] :: a1_a44e -> m_a44d r_a44j
          [LclId] =
              [$dMonad_s7Yy f_s7Yz m2_s7YB m3_s7YC m4_s7YD m5_s7YE] \r [x1_s7YF]
                  let {
                    sat_s7YO [Occ=Once] :: a2_a44f -> m_a44d r_a44j
                    [LclId] =
                        [$dMonad_s7Yy f_s7Yz m3_s7YC m4_s7YD m5_s7YE x1_s7YF] \r [x2_s7YG]
                            let {
                              sat_s7YN [Occ=Once] :: a3_a44g -> m_a44d r_a44j
                              [LclId] =
                                  [$dMonad_s7Yy f_s7Yz m4_s7YD m5_s7YE x1_s7YF x2_s7YG] \r [x3_s7YH]
                                      let {
                                        sat_s7YM [Occ=Once] :: a4_a44h -> m_a44d r_a44j
                                        [LclId] =
                                            [$dMonad_s7Yy
                                             f_s7Yz
                                             m5_s7YE
                                             x1_s7YF
                                             x2_s7YG
                                             x3_s7YH] \r [x4_s7YI]
                                                let {
                                                  sat_s7YL [Occ=Once] :: a5_a44i -> m_a44d r_a44j
                                                  [LclId] =
                                                      [$dMonad_s7Yy
                                                       f_s7Yz
                                                       x1_s7YF
                                                       x2_s7YG
                                                       x3_s7YH
                                                       x4_s7YI] \r [x5_s7YJ]
                                                          let {
                                                            sat_s7YK [Occ=Once] :: r_a44j
                                                            [LclId] =
                                                                [f_s7Yz
                                                                 x1_s7YF
                                                                 x2_s7YG
                                                                 x3_s7YH
                                                                 x4_s7YI
                                                                 x5_s7YJ] \u []
                                                                    f_s7Yz
                                                                        x1_s7YF
                                                                        x2_s7YG
                                                                        x3_s7YH
                                                                        x4_s7YI
                                                                        x5_s7YJ;
                                                          } in 
                                                            GHC.Base.return $dMonad_s7Yy sat_s7YK;
                                                } in  GHC.Base.>>= $dMonad_s7Yy m5_s7YE sat_s7YL;
                                      } in  GHC.Base.>>= $dMonad_s7Yy m4_s7YD sat_s7YM;
                            } in  GHC.Base.>>= $dMonad_s7Yy m3_s7YC sat_s7YN;
                  } in  GHC.Base.>>= $dMonad_s7Yy m2_s7YB sat_s7YO;
        } in  GHC.Base.>>= $dMonad_s7Yy m1_s7YA sat_s7YP;

GHC.Base.liftM8
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_s7YQ m1_s7YR m2_s7YS m3_s7YT m4_s7YU void_0E]
        case m1_s7YR GHC.Prim.void# of {
          Unit# ipv1_s7YY [Occ=Once] ->
              case m2_s7YS GHC.Prim.void# of {
                Unit# ipv3_s7Z1 [Occ=Once] ->
                    case m3_s7YT GHC.Prim.void# of {
                      Unit# ipv5_s7Z4 [Occ=Once] ->
                          case m4_s7YU GHC.Prim.void# of {
                            Unit# ipv7_s7Z7 [Occ=Once] ->
                                let {
                                  sat_s7Z8 [Occ=Once] :: r_a47U
                                  [LclId] =
                                      [f_s7YQ ipv1_s7YY ipv3_s7Z1 ipv5_s7Z4 ipv7_s7Z7] \u []
                                          f_s7YQ ipv1_s7YY ipv3_s7Z1 ipv5_s7Z4 ipv7_s7Z7;
                                } in  Unit# [sat_s7Z8];
                          };
                    };
              };
        };

GHC.Base.liftM4_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Types.IO r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 void_0E]
        GHC.Base.liftM8 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.liftM4 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 a4 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(C1(U))))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s7Z9 f_s7Za m1_s7Zb m2_s7Zc m3_s7Zd m4_s7Ze]
        let {
          sat_s7Zn [Occ=Once] :: a1_a46L -> m_a46K r_a46P
          [LclId] =
              [$dMonad_s7Z9 f_s7Za m2_s7Zc m3_s7Zd m4_s7Ze] \r [x1_s7Zf]
                  let {
                    sat_s7Zm [Occ=Once] :: a2_a46M -> m_a46K r_a46P
                    [LclId] =
                        [$dMonad_s7Z9 f_s7Za m3_s7Zd m4_s7Ze x1_s7Zf] \r [x2_s7Zg]
                            let {
                              sat_s7Zl [Occ=Once] :: a3_a46N -> m_a46K r_a46P
                              [LclId] =
                                  [$dMonad_s7Z9 f_s7Za m4_s7Ze x1_s7Zf x2_s7Zg] \r [x3_s7Zh]
                                      let {
                                        sat_s7Zk [Occ=Once] :: a4_a46O -> m_a46K r_a46P
                                        [LclId] =
                                            [$dMonad_s7Z9
                                             f_s7Za
                                             x1_s7Zf
                                             x2_s7Zg
                                             x3_s7Zh] \r [x4_s7Zi]
                                                let {
                                                  sat_s7Zj [Occ=Once] :: r_a46P
                                                  [LclId] =
                                                      [f_s7Za x1_s7Zf x2_s7Zg x3_s7Zh x4_s7Zi] \u []
                                                          f_s7Za x1_s7Zf x2_s7Zg x3_s7Zh x4_s7Zi;
                                                } in  GHC.Base.return $dMonad_s7Z9 sat_s7Zj;
                                      } in  GHC.Base.>>= $dMonad_s7Z9 m4_s7Ze sat_s7Zk;
                            } in  GHC.Base.>>= $dMonad_s7Z9 m3_s7Zd sat_s7Zl;
                  } in  GHC.Base.>>= $dMonad_s7Z9 m2_s7Zc sat_s7Zm;
        } in  GHC.Base.>>= $dMonad_s7Z9 m1_s7Zb sat_s7Zn;

GHC.Base.liftM3_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 void_0E]
        GHC.Base.liftA1 eta_B5 eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.liftM3 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(U)))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s7Zo f_s7Zp m1_s7Zq m2_s7Zr m3_s7Zs]
        let {
          sat_s7Zz [Occ=Once] :: a1_a48V -> m_a48U r_a48Y
          [LclId] =
              [$dMonad_s7Zo f_s7Zp m2_s7Zr m3_s7Zs] \r [x1_s7Zt]
                  let {
                    sat_s7Zy [Occ=Once] :: a2_a48W -> m_a48U r_a48Y
                    [LclId] =
                        [$dMonad_s7Zo f_s7Zp m3_s7Zs x1_s7Zt] \r [x2_s7Zu]
                            let {
                              sat_s7Zx [Occ=Once] :: a3_a48X -> m_a48U r_a48Y
                              [LclId] =
                                  [$dMonad_s7Zo f_s7Zp x1_s7Zt x2_s7Zu] \r [x3_s7Zv]
                                      let {
                                        sat_s7Zw [Occ=Once] :: r_a48Y
                                        [LclId] =
                                            [f_s7Zp x1_s7Zt x2_s7Zu x3_s7Zv] \u []
                                                f_s7Zp x1_s7Zt x2_s7Zu x3_s7Zv;
                                      } in  GHC.Base.return $dMonad_s7Zo sat_s7Zw;
                            } in  GHC.Base.>>= $dMonad_s7Zo m3_s7Zs sat_s7Zx;
                  } in  GHC.Base.>>= $dMonad_s7Zo m2_s7Zr sat_s7Zy;
        } in  GHC.Base.>>= $dMonad_s7Zo m1_s7Zq sat_s7Zz;

GHC.Base.liftM_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Types.IO a1 -> GHC.Types.IO r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.Base.$fFunctorIO2 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.liftM [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 r.
     GHC.Base.Monad m =>
     (a1 -> r) -> m a1 -> m r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s7ZA f_s7ZB m1_s7ZC]
        let {
          sat_s7ZF [Occ=Once] :: a1_a4c8 -> m_a4c7 r_a4c9
          [LclId] =
              [$dMonad_s7ZA f_s7ZB] \r [x1_s7ZD]
                  let {
                    sat_s7ZE [Occ=Once] :: r_a4c9
                    [LclId] =
                        [f_s7ZB x1_s7ZD] \u [] f_s7ZB x1_s7ZD;
                  } in  GHC.Base.return $dMonad_s7ZA sat_s7ZE;
        } in  GHC.Base.>>= $dMonad_s7ZA m1_s7ZC sat_s7ZF;

GHC.Base.$! :: forall a (b :: TYPE r). (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s7ZG x_s7ZH]
        case x_s7ZH of vx_s7ZI { __DEFAULT -> f_s7ZG vx_s7ZI; };

GHC.Base.$ [InlPrag=INLINE (sat-args=2)]
  :: forall a (b :: TYPE r). (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s7ZJ x_s7ZK] f_s7ZJ x_s7ZK;

GHC.Base.flip :: forall a b c. (a -> b -> c) -> b -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s7ZL x_s7ZM y_s7ZN] f_s7ZL y_s7ZN x_s7ZM;

GHC.Base.$fMonad(->)_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall r a b. (r -> a) -> (r -> b) -> r -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_s7ZO eta1_s7ZP r1_s7ZQ] eta1_s7ZP r1_s7ZQ;

GHC.Base.$fApplicative(->)_$c<*
  :: forall a1 a2 b. (a1 -> a2) -> (a1 -> b) -> a1 -> a2
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s7ZR g_s7ZS x_s7ZT] f_s7ZR x_s7ZT;

GHC.Base.$fMonad(,)_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,A)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s7ZU eta_s7ZV eta1_s7ZW]
        case eta_s7ZV of {
          (,) u_s7ZY [Occ=Once] _ [Occ=Dead] ->
              case eta1_s7ZW of {
                (,) v_s801 [Occ=Once] b1_s802 [Occ=Once] ->
                    let {
                      sat_s804 [Occ=Once] :: a_a4ul
                      [LclId] =
                          [$dMonoid_s7ZU u_s7ZY v_s801] \u []
                              case GHC.Base.$p1Monoid $dMonoid_s7ZU of sat_s803 {
                                __DEFAULT -> GHC.Base.<> sat_s803 u_s7ZY v_s801;
                              };
                    } in  (,) [sat_s804 b1_s802];
              };
        };

GHC.Base.$fApplicative(,)_$c<*
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a, b) -> (a, a1)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><S,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s805 eta_s806 eta1_s807]
        case eta_s806 of {
          (,) u_s809 [Occ=Once] x_s80a [Occ=Once] ->
              case eta1_s807 of {
                (,) v_s80c [Occ=Once] _ [Occ=Dead] ->
                    let {
                      sat_s80f [Occ=Once] :: a_a4vv
                      [LclId] =
                          [$dMonoid_s805 u_s809 v_s80c] \u []
                              case GHC.Base.$p1Monoid $dMonoid_s805 of sat_s80e {
                                __DEFAULT -> GHC.Base.<> sat_s80e u_s809 v_s80c;
                              };
                    } in  (,) [sat_s80f x_s80a];
              };
        };

GHC.Base.$fFunctor(,)_$c<$
  :: forall a1 a2 b. a2 -> (a1, b) -> (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [x_s80g ds_s80h]
        case ds_s80h of {
          (,) x1_s80j [Occ=Once] _ [Occ=Dead] -> (,) [x1_s80j x_s80g];
        };

GHC.Base.$fFunctorMaybe_$c<$
  :: forall a b. a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_s80l ds_s80m]
        case ds_s80m of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Base.Just [x_s80l];
        };

GHC.Base.$dm<$
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     forall a b. a -> f b -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_s80p eta_s80q]
        let {
          sat_s80s [Occ=Once] :: b_a4il -> a_a4ik
          [LclId] =
              [eta_s80q] \r [ds_s80r] eta_s80q;
        } in  GHC.Base.fmap $dFunctor_s80p sat_s80s;

GHC.Base.$fMonoid(->)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall b a. GHC.Base.Monoid b => (a -> b) -> (a -> b) -> a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s80t eta_s80u eta1_s80v eta2_s80w]
        let {
          sat_s80z [Occ=Once] :: b_a4zA
          [LclId] =
              [eta1_s80v eta2_s80w] \u [] eta1_s80v eta2_s80w; } in
        let {
          sat_s80y [Occ=Once] :: b_a4zA
          [LclId] =
              [eta_s80u eta2_s80w] \u [] eta_s80u eta2_s80w;
        } in 
          case GHC.Base.$p1Monoid $dMonoid_s80t of sat_s80x {
            __DEFAULT -> GHC.Base.<> sat_s80x sat_s80y sat_s80z;
          };

GHC.Base.$fMonoid(,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     (a, b) -> (a, b) -> (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s80A $dMonoid1_s80B eta_s80C eta1_s80D]
        case eta_s80C of {
          (,) a1_s80F [Occ=Once] b1_s80G [Occ=Once] ->
              case eta1_s80D of {
                (,) a'_s80I [Occ=Once] b'_s80J [Occ=Once] ->
                    let {
                      sat_s80N [Occ=Once] :: b_a4yQ
                      [LclId] =
                          [$dMonoid1_s80B b1_s80G b'_s80J] \u []
                              case GHC.Base.$p1Monoid $dMonoid1_s80B of sat_s80M {
                                __DEFAULT -> GHC.Base.<> sat_s80M b1_s80G b'_s80J;
                              }; } in
                    let {
                      sat_s80L [Occ=Once] :: a_a4yP
                      [LclId] =
                          [$dMonoid_s80A a1_s80F a'_s80I] \u []
                              case GHC.Base.$p1Monoid $dMonoid_s80A of sat_s80K {
                                __DEFAULT -> GHC.Base.<> sat_s80K a1_s80F a'_s80I;
                              };
                    } in  (,) [sat_s80L sat_s80N];
              };
        };

GHC.Base.$fSemigroupOrdering_go [Occ=LoopBreaker]
  :: GHC.Types.Ordering -> [GHC.Types.Ordering] -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s80O ds_s80P]
        case ds_s80P of {
          [] -> b_s80O;
          : c_s80R [Occ=Once] cs_s80S [Occ=Once] ->
              case b_s80O of {
                GHC.Types.LT -> GHC.Types.LT [];
                GHC.Types.EQ -> GHC.Base.$fSemigroupOrdering_go c_s80R cs_s80S;
                GHC.Types.GT -> GHC.Types.GT [];
              };
        };

GHC.Base.$fSemigroupOrdering_$csconcat
  :: GHC.Base.NonEmpty GHC.Types.Ordering -> GHC.Types.Ordering
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s80U]
        case ds_s80U of {
          GHC.Base.:| a_s80W [Occ=Once] as_s80X [Occ=Once] ->
              GHC.Base.$fSemigroupOrdering_go a_s80W as_s80X;
        };

GHC.Base.. [InlPrag=INLINE (sat-args=2)]
  :: forall b c a. (b -> c) -> (a -> b) -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s80Y g_s80Z x_s810]
        let {
          sat_s811 [Occ=Once] :: b_a41v
          [LclId] =
              [g_s80Z x_s810] \u [] g_s80Z x_s810;
        } in  f_s80Y sat_s811;

GHC.Base.mapFB [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall elt lst a.
     (elt -> lst -> lst) -> (a -> elt) -> a -> lst -> lst
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c_s812 f_s813 x_s814 ys_s815]
        let {
          sat_s816 [Occ=Once] :: elt_a42v
          [LclId] =
              [f_s813 x_s814] \u [] f_s813 x_s814;
        } in  c_s812 sat_s816 ys_s815;

GHC.Base.$fFunctor(->)_$c<$
  :: forall r a b. a -> (r -> b) -> r -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s817 eta_s818 eta1_s819] x_s817;

GHC.Base.$fFunctor(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall r. GHC.Base.Functor ((->) r)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base..
                                       GHC.Base.$fFunctor(->)_$c<$];

GHC.Base.const :: forall a b. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s81a ds_s81b] x_s81a;

GHC.Base.asTypeOf :: forall a. a -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.const eta_B2 eta_B1;

GHC.Base.$dm<*
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s81c]
        GHC.Base.liftA2 $dApplicative_s81c GHC.Base.const;

GHC.Base.$fApplicativeIO1
  :: forall a b.
     GHC.Types.IO a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_s81d m2_s81e void_0E]
        case m1_s81d GHC.Prim.void# of {
          Unit# ipv1_s81i [Occ=Once] ->
              case m2_s81e GHC.Prim.void# of {
                Unit# _ [Occ=Dead] -> Unit# [ipv1_s81i];
              };
        };

GHC.Base.$fApplicativeIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctorIO
                                           GHC.Base.$fApplicativeIO4
                                           GHC.Base.$fApplicativeIO3
                                           GHC.Base.$fApplicativeIO_$cliftA2
                                           GHC.Base.$fApplicativeIO2
                                           GHC.Base.$fApplicativeIO1];

GHC.Base.breakpointCond :: forall a. GHC.Types.Bool -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s81m r_s81n] r_s81n;

GHC.Base.breakpoint :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [r_s81o] r_s81o;

GHC.Base.assert :: forall a. GHC.Types.Bool -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.breakpointCond eta_B2 eta_B1;

GHC.Base.id :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.breakpoint eta_B1;

GHC.Base.join
  :: forall (m :: * -> *) a. GHC.Base.Monad m => m (m a) -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s81p x_s81q]
        GHC.Base.>>= $dMonad_s81p x_s81q GHC.Base.breakpoint;

GHC.Base.$dm<*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f (a -> b) -> f a -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s81r]
        GHC.Base.liftA2 $dApplicative_s81r GHC.Base.breakpoint;

GHC.Base.$dm*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(1*U(A,1*C1(C1(U))),A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s81s eta_s81t eta1_s81u]
        let {
          sat_s81w [Occ=Once] :: f_a37E (b_a4j2 -> b_a4j2)
          [LclId] =
              [$dApplicative_s81s eta_s81t] \u []
                  case GHC.Base.$p1Applicative $dApplicative_s81s of sat_s81v {
                    __DEFAULT -> GHC.Base.<$ sat_s81v GHC.Base.breakpoint eta_s81t;
                  };
        } in  GHC.Base.<*> $dApplicative_s81s sat_s81w eta1_s81u;

GHC.Base.$fApplicative(->)_$c*>
  :: forall a1 a2 b. (a1 -> a2) -> (a1 -> b) -> a1 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [a2_s81x a3_s81y x_s81z] a3_s81y x_s81z;

GHC.Base.maxInt :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [9223372036854775807#];

GHC.Base.minInt :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [-9223372036854775808#];

GHC.Base.ord :: GHC.Types.Char -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s81A]
        case ds_s81A of {
          GHC.Types.C# c#_s81C [Occ=Once] ->
              case ord# [c#_s81C] of sat_s81D {
                __DEFAULT -> GHC.Types.I# [sat_s81D];
              };
        };

GHC.Base.unsafeChr :: GHC.Types.Int -> GHC.Types.Char
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s81E]
        case ds_s81E of {
          GHC.Types.I# i#_s81G [Occ=Once] ->
              case chr# [i#_s81G] of sat_s81H {
                __DEFAULT -> GHC.Types.C# [sat_s81H];
              };
        };

GHC.Base.otherwise :: GHC.Types.Bool
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.True! [];

GHC.Base.until
  :: forall a. (a -> GHC.Types.Bool) -> (a -> a) -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [p_s81I f_s81J eta_s81K]
        let-no-escape {
          go_s81L [Occ=LoopBreakerT[1]] :: a_a41W -> a_a41W
          [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [p_s81I f_s81J go_s81L] \r [x_s81M]
                  case p_s81I x_s81M of {
                    GHC.Types.False ->
                        let {
                          sat_s81O [Occ=Once] :: a_a41W
                          [LclId] =
                              [f_s81J x_s81M] \u [] f_s81J x_s81M;
                        } in  go_s81L sat_s81O;
                    GHC.Types.True -> x_s81M;
                  };
        } in  go_s81L eta_s81K;

GHC.Base.divModInt#
  :: GHC.Prim.Int#
     -> GHC.Prim.Int# -> (# GHC.Prim.Int#, GHC.Prim.Int# #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [x#_s81P y#_s81Q]
        case ># [x#_s81P 0#] of {
          __DEFAULT ->
              case <# [x#_s81P 0#] of {
                __DEFAULT -> quotRemInt# [x#_s81P y#_s81Q];
                1# ->
                    case ># [y#_s81Q 0#] of {
                      __DEFAULT -> quotRemInt# [x#_s81P y#_s81Q];
                      1# ->
                          case +# [x#_s81P 1#] of sat_s81U {
                            __DEFAULT ->
                                case quotRemInt# [sat_s81U y#_s81Q] of {
                                  (#,#) ipv_s81W [Occ=Once] ipv1_s81X [Occ=Once] ->
                                      case +# [ipv1_s81X y#_s81Q] of sat_s81Z {
                                        __DEFAULT ->
                                            case -# [sat_s81Z 1#] of sat_s820 {
                                              __DEFAULT ->
                                                  case -# [ipv_s81W 1#] of sat_s81Y {
                                                    __DEFAULT -> (#,#) [sat_s81Y sat_s820];
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
          1# ->
              case <# [y#_s81Q 0#] of {
                __DEFAULT ->
                    case <# [x#_s81P 0#] of {
                      __DEFAULT -> quotRemInt# [x#_s81P y#_s81Q];
                      1# ->
                          case ># [y#_s81Q 0#] of {
                            __DEFAULT -> quotRemInt# [x#_s81P y#_s81Q];
                            1# ->
                                case +# [x#_s81P 1#] of sat_s824 {
                                  __DEFAULT ->
                                      case quotRemInt# [sat_s824 y#_s81Q] of {
                                        (#,#) ipv_s826 [Occ=Once] ipv1_s827 [Occ=Once] ->
                                            case +# [ipv1_s827 y#_s81Q] of sat_s829 {
                                              __DEFAULT ->
                                                  case -# [sat_s829 1#] of sat_s82a {
                                                    __DEFAULT ->
                                                        case -# [ipv_s826 1#] of sat_s828 {
                                                          __DEFAULT -> (#,#) [sat_s828 sat_s82a];
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
                1# ->
                    case -# [x#_s81P 1#] of sat_s82b {
                      __DEFAULT ->
                          case quotRemInt# [sat_s82b y#_s81Q] of {
                            (#,#) ipv_s82d [Occ=Once] ipv1_s82e [Occ=Once] ->
                                case +# [ipv1_s82e y#_s81Q] of sat_s82g {
                                  __DEFAULT ->
                                      case +# [sat_s82g 1#] of sat_s82h {
                                        __DEFAULT ->
                                            case -# [ipv_s82d 1#] of sat_s82f {
                                              __DEFAULT -> (#,#) [sat_s82f sat_s82h];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Base.divModInt [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_s82i w1_s82j]
        case w_s82i of {
          GHC.Types.I# ww1_s82l ->
              case w1_s82j of {
                GHC.Types.I# ww3_s82n ->
                    case ># [ww1_s82l 0#] of {
                      __DEFAULT ->
                          case <# [ww1_s82l 0#] of {
                            __DEFAULT ->
                                case quotRemInt# [ww1_s82l ww3_s82n] of {
                                  (#,#) ipv_s82r [Occ=Once] ipv1_s82s [Occ=Once] ->
                                      let {
                                        sat_s82u [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv1_s82s]; } in
                                      let {
                                        sat_s82t [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv_s82r];
                                      } in  (,) [sat_s82t sat_s82u];
                                };
                            1# ->
                                case ># [ww3_s82n 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww1_s82l ww3_s82n] of {
                                        (#,#) ipv_s82x [Occ=Once] ipv1_s82y [Occ=Once] ->
                                            let {
                                              sat_s82A [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s82y]; } in
                                            let {
                                              sat_s82z [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_s82x];
                                            } in  (,) [sat_s82z sat_s82A];
                                      };
                                  1# ->
                                      case +# [ww1_s82l 1#] of sat_s82B {
                                        __DEFAULT ->
                                            case quotRemInt# [sat_s82B ww3_s82n] of {
                                              (#,#) ipv_s82D [Occ=Once] ipv1_s82E [Occ=Once] ->
                                                  case +# [ipv1_s82E ww3_s82n] of sat_s82H {
                                                    __DEFAULT ->
                                                        case -# [sat_s82H 1#] of sat_s82I {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_s82J [Occ=Once] :: GHC.Types.Int
                                                                [LclId] =
                                                                    CCCS GHC.Types.I#! [sat_s82I];
                                                              } in 
                                                                case -# [ipv_s82D 1#] of sat_s82F {
                                                                  __DEFAULT ->
                                                                      let {
                                                                        sat_s82G [Occ=Once]
                                                                          :: GHC.Types.Int
                                                                        [LclId] =
                                                                            CCCS GHC.Types.I#! [sat_s82F];
                                                                      } in  (,) [sat_s82G sat_s82J];
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                      1# ->
                          case <# [ww3_s82n 0#] of {
                            __DEFAULT ->
                                case <# [ww1_s82l 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww1_s82l ww3_s82n] of {
                                        (#,#) ipv_s82N [Occ=Once] ipv1_s82O [Occ=Once] ->
                                            let {
                                              sat_s82Q [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s82O]; } in
                                            let {
                                              sat_s82P [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_s82N];
                                            } in  (,) [sat_s82P sat_s82Q];
                                      };
                                  1# ->
                                      case ># [ww3_s82n 0#] of {
                                        __DEFAULT ->
                                            case quotRemInt# [ww1_s82l ww3_s82n] of {
                                              (#,#) ipv_s82T [Occ=Once] ipv1_s82U [Occ=Once] ->
                                                  let {
                                                    sat_s82W [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv1_s82U]; } in
                                                  let {
                                                    sat_s82V [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv_s82T];
                                                  } in  (,) [sat_s82V sat_s82W];
                                            };
                                        1# ->
                                            case +# [ww1_s82l 1#] of sat_s82X {
                                              __DEFAULT ->
                                                  case quotRemInt# [sat_s82X ww3_s82n] of {
                                                    (#,#) ipv_s82Z [Occ=Once]
                                                          ipv1_s830 [Occ=Once] ->
                                                        case +# [ipv1_s830 ww3_s82n] of sat_s833 {
                                                          __DEFAULT ->
                                                              case -# [sat_s833 1#] of sat_s834 {
                                                                __DEFAULT ->
                                                                    let {
                                                                      sat_s835 [Occ=Once]
                                                                        :: GHC.Types.Int
                                                                      [LclId] =
                                                                          CCCS GHC.Types.I#! [sat_s834];
                                                                    } in 
                                                                      case
                                                                          -# [ipv_s82Z 1#]
                                                                      of
                                                                      sat_s831
                                                                      { __DEFAULT ->
                                                                            let {
                                                                              sat_s832 [Occ=Once]
                                                                                :: GHC.Types.Int
                                                                              [LclId] =
                                                                                  CCCS GHC.Types.I#! [sat_s831];
                                                                            } in 
                                                                              (,) [sat_s832
                                                                                   sat_s835];
                                                                      };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            1# ->
                                case -# [ww1_s82l 1#] of sat_s836 {
                                  __DEFAULT ->
                                      case quotRemInt# [sat_s836 ww3_s82n] of {
                                        (#,#) ipv_s838 [Occ=Once] ipv1_s839 [Occ=Once] ->
                                            case +# [ipv1_s839 ww3_s82n] of sat_s83c {
                                              __DEFAULT ->
                                                  case +# [sat_s83c 1#] of sat_s83d {
                                                    __DEFAULT ->
                                                        let {
                                                          sat_s83e [Occ=Once] :: GHC.Types.Int
                                                          [LclId] =
                                                              CCCS GHC.Types.I#! [sat_s83d];
                                                        } in 
                                                          case -# [ipv_s838 1#] of sat_s83a {
                                                            __DEFAULT ->
                                                                let {
                                                                  sat_s83b [Occ=Once]
                                                                    :: GHC.Types.Int
                                                                  [LclId] =
                                                                      CCCS GHC.Types.I#! [sat_s83a];
                                                                } in  (,) [sat_s83b sat_s83e];
                                                          };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Base.shiftL#
  :: GHC.Prim.Word# -> GHC.Prim.Int# -> GHC.Prim.Word#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_s83f b_s83g]
        case >=# [b_s83g 64#] of {
          __DEFAULT -> uncheckedShiftL# [a_s83f b_s83g];
          1# -> 0##;
        };

GHC.Base.shiftRL#
  :: GHC.Prim.Word# -> GHC.Prim.Int# -> GHC.Prim.Word#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_s83i b_s83j]
        case >=# [b_s83j 64#] of {
          __DEFAULT -> uncheckedShiftRL# [a_s83i b_s83j];
          1# -> 0##;
        };

GHC.Base.iShiftL#
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_s83l b_s83m]
        case >=# [b_s83m 64#] of {
          __DEFAULT -> uncheckedIShiftL# [a_s83l b_s83m];
          1# -> 0#;
        };

GHC.Base.iShiftRA#
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [a_s83o b_s83p]
        case >=# [b_s83p 64#] of {
          __DEFAULT -> uncheckedIShiftRA# [a_s83o b_s83p];
          1# ->
              case <# [a_s83o 0#] of {
                __DEFAULT -> 0#;
                1# -> -1#;
              };
        };

GHC.Base.iShiftRL#
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_s83s b_s83t]
        case >=# [b_s83t 64#] of {
          __DEFAULT -> uncheckedIShiftRL# [a_s83s b_s83t];
          1# -> 0#;
        };

GHC.Base.build [InlPrag=INLINE[1] (sat-args=1)]
  :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [g_s83v] g_s83v GHC.Types.: GHC.Types.[];

GHC.Base.$fApplicative[]_$cpure [InlPrag=INLINE (sat-args=1)]
  :: forall a. a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [x_s83w] : [x_s83w GHC.Types.[]];

GHC.Base.augment [InlPrag=INLINE[1] (sat-args=2)]
  :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [g_s83x xs_s83y] g_s83x GHC.Types.: xs_s83y;

GHC.Base.++ [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. [a] -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s83z ys_s83A]
        case ds_s83z of {
          [] -> ys_s83A;
          : x_s83C [Occ=Once] xs_s83D [Occ=Once] ->
              let {
                sat_s83E [Occ=Once] :: [a_a42r]
                [LclId] =
                    [ys_s83A xs_s83D] \u [] GHC.Base.++ xs_s83D ys_s83A;
              } in  : [x_s83C sat_s83E];
        };
GHC.Base.foldr [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_s83F z_s83G eta_s83H]
        let {
          go_s83I [Occ=LoopBreaker] :: [a_a42N] -> b_a42O
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [k_s83F z_s83G go_s83I] \r [ds_s83J]
                  case ds_s83J of {
                    [] -> z_s83G;
                    : y_s83L [Occ=Once] ys_s83M [Occ=Once] ->
                        let {
                          sat_s83N [Occ=Once] :: b_a42O
                          [LclId] =
                              [go_s83I ys_s83M] \u [] go_s83I ys_s83M;
                        } in  k_s83F y_s83L sat_s83N;
                  };
        } in  go_s83I eta_s83H;
GHC.Base.map [InlPrag=NOINLINE[0], Occ=LoopBreaker]
  :: forall a b. (a -> b) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s83O ds1_s83P]
        case ds1_s83P of {
          [] -> [] [];
          : x_s83R [Occ=Once] xs_s83S [Occ=Once] ->
              let {
                sat_s83U [Occ=Once] :: [b_a42A]
                [LclId] =
                    [ds_s83O xs_s83S] \u [] GHC.Base.map ds_s83O xs_s83S; } in
              let {
                sat_s83T [Occ=Once] :: b_a42A
                [LclId] =
                    [ds_s83O x_s83R] \u [] ds_s83O x_s83R;
              } in  : [sat_s83T sat_s83U];
        };

GHC.Base.$fSemigroupNonEmpty_$c<>
  :: forall a.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,1*U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s83V ds1_s83W]
        case ds_s83V of {
          GHC.Base.:| a1_s83Y [Occ=Once] as_s83Z [Occ=Once] ->
              let {
                sat_s849 [Occ=Once] :: [a_a4Fm]
                [LclId] =
                    [ds1_s83W as_s83Z] \u []
                        let {
                          sat_s847 [Occ=Once] :: [a_a4Fm]
                          [LclId] =
                              [ds1_s83W] \u []
                                  case ds1_s83W of {
                                    GHC.Base.:| _ [Occ=Dead] bs_s846 [Occ=Once] -> bs_s846;
                                  }; } in
                        let {
                          sat_s843 [Occ=Once] :: a_a4Fm
                          [LclId] =
                              [ds1_s83W] \u []
                                  case ds1_s83W of {
                                    GHC.Base.:| b_s841 [Occ=Once] _ [Occ=Dead] -> b_s841;
                                  }; } in
                        let {
                          sat_s848 [Occ=Once] :: [a_a4Fm]
                          [LclId] =
                              CCCS :! [sat_s843 sat_s847];
                        } in  GHC.Base.++ as_s83Z sat_s848;
              } in  GHC.Base.:| [a1_s83Y sat_s849];
        };

GHC.Base.$wpoly_go [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. a -> [a] -> [GHC.Base.NonEmpty a] -> (# a, [a] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_s84a ww1_s84b w_s84c]
        case w_s84c of {
          [] -> (#,#) [ww_s84a ww1_s84b];
          : c_s84e [Occ=Once!] cs_s84f [Occ=Once] ->
              let {
                sat_s84w [Occ=Once] :: [a_s6GZ]
                [LclId] =
                    [ww1_s84b c_s84e cs_s84f] \u []
                        let {
                          ds_s84g [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty a_s6GZ
                          [LclId] =
                              [c_s84e cs_s84f] \u []
                                  case c_s84e of {
                                    GHC.Base.:| ww3_s84i [Occ=Once] ww4_s84j [Occ=Once] ->
                                        case GHC.Base.$wpoly_go ww3_s84i ww4_s84j cs_s84f of {
                                          (#,#) ww6_s84l [Occ=Once] ww7_s84m [Occ=Once] ->
                                              GHC.Base.:| [ww6_s84l ww7_s84m];
                                        };
                                  }; } in
                        let {
                          sat_s84u [Occ=Once] :: [a_s6GZ]
                          [LclId] =
                              [ds_s84g] \u []
                                  case ds_s84g of {
                                    GHC.Base.:| _ [Occ=Dead] bs_s84t [Occ=Once] -> bs_s84t;
                                  }; } in
                        let {
                          sat_s84q [Occ=Once] :: a_s6GZ
                          [LclId] =
                              [ds_s84g] \u []
                                  case ds_s84g of {
                                    GHC.Base.:| b_s84o [Occ=Once] _ [Occ=Dead] -> b_s84o;
                                  }; } in
                        let {
                          sat_s84v [Occ=Once] :: [a_s6GZ]
                          [LclId] =
                              CCCS :! [sat_s84q sat_s84u];
                        } in  GHC.Base.++ ww1_s84b sat_s84v;
              } in  (#,#) [ww_s84a sat_s84w];
        };

GHC.Base.$fSemigroupNonEmpty1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.NonEmpty a -> [GHC.Base.NonEmpty a] -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_s84x w1_s84y]
        case w_s84x of {
          GHC.Base.:| ww1_s84A [Occ=Once] ww2_s84B [Occ=Once] ->
              case GHC.Base.$wpoly_go ww1_s84A ww2_s84B w1_s84y of {
                (#,#) ww4_s84D [Occ=Once] ww5_s84E [Occ=Once] ->
                    GHC.Base.:| [ww4_s84D ww5_s84E];
              };
        };

GHC.Base.$fSemigroupNonEmpty_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (GHC.Base.NonEmpty a) -> GHC.Base.NonEmpty a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U(U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_s84F]
        case ds_s84F of {
          GHC.Base.:| a1_s84H [Occ=Once] as_s84I [Occ=Once] ->
              GHC.Base.$fSemigroupNonEmpty1 a1_s84H as_s84I;
        };

GHC.Base.$fSemigroupNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (GHC.Base.NonEmpty a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.$fSemigroupNonEmpty_$c<>
                                         GHC.Base.$fSemigroupNonEmpty_$csconcat
                                         GHC.Base.$fSemigroupNonEmpty_$cstimes];
GHC.Base.$fSemigroupNonEmpty_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_s84J]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_s84J GHC.Base.$fSemigroupNonEmpty;

GHC.Base.$fSemigroup[]1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s84K ds_s84L]
        case ds_s84L of {
          [] -> b_s84K;
          : c_s84N [Occ=Once] cs_s84O [Occ=Once] ->
              let {
                sat_s84P [Occ=Once, Dmd=<L,1*U>] :: [a_a4FL]
                [LclId] =
                    [c_s84N cs_s84O] \s [] GHC.Base.$fSemigroup[]1 c_s84N cs_s84O;
              } in  GHC.Base.++ b_s84K sat_s84P;
        };

GHC.Base.$fSemigroup[]_$csconcat
  :: forall a. GHC.Base.NonEmpty [a] -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s84Q]
        case ds_s84Q of {
          GHC.Base.:| a1_s84S [Occ=Once] as_s84T [Occ=Once] ->
              GHC.Base.$fSemigroup[]1 a1_s84S as_s84T;
        };

GHC.Base.mapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> [a] -> m [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s84U eta_s84V eta1_s84W]
        let {
          z_s84X [Occ=OnceL] :: m_a4da [b_a4dc]
          [LclId] =
              [$dMonad_s84U] \u []
                  GHC.Base.return $dMonad_s84U GHC.Types.[]; } in
        let {
          go_s84Y [Occ=LoopBreaker] :: [a_a4db] -> m_a4da [b_a4dc]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonad_s84U eta_s84V z_s84X go_s84Y] \r [ds_s84Z]
                  case ds_s84Z of {
                    [] -> z_s84X;
                    : y_s851 [Occ=Once] ys_s852 [Occ=Once] ->
                        let {
                          r_s853 [Occ=OnceL] :: m_a4da [b_a4dc]
                          [LclId] =
                              [go_s84Y ys_s852] \u [] go_s84Y ys_s852; } in
                        let {
                          sat_s859 [Occ=Once] :: b_a4dc -> m_a4da [b_a4dc]
                          [LclId] =
                              [$dMonad_s84U r_s853] \r [x_s855]
                                  let {
                                    sat_s858 [Occ=Once] :: [b_a4dc] -> m_a4da [b_a4dc]
                                    [LclId] =
                                        [$dMonad_s84U x_s855] \r [xs_s856]
                                            let {
                                              sat_s857 [Occ=Once] :: [b_a4dc]
                                              [LclId] =
                                                  CCCS :! [x_s855 xs_s856];
                                            } in  GHC.Base.return $dMonad_s84U sat_s857;
                                  } in  GHC.Base.>>= $dMonad_s84U r_s853 sat_s858; } in
                        let {
                          sat_s854 [Occ=Once] :: m_a4da b_a4dc
                          [LclId] =
                              [eta_s84V y_s851] \u [] eta_s84V y_s851;
                        } in  GHC.Base.>>= $dMonad_s84U sat_s854 sat_s859;
                  };
        } in  go_s84Y eta1_s84W;

GHC.Base.sequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. GHC.Base.Monad m => [m a] -> m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s85a eta_B1]
        GHC.Base.mapM $dMonad_s85a GHC.Base.breakpoint eta_B1;

GHC.Base.$dmmconcat :: forall a. GHC.Base.Monoid a => [a] -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s85b eta_s85c]
        let {
          z_s85d [Occ=OnceL] :: a_a37Y
          [LclId] =
              [$dMonoid_s85b] \u [] GHC.Base.mempty $dMonoid_s85b; } in
        let {
          go_s85e [Occ=LoopBreaker] :: [a_a37Y] -> a_a37Y
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_s85b z_s85d go_s85e] \r [ds_s85f]
                  case ds_s85f of {
                    [] -> z_s85d;
                    : y_s85h [Occ=Once] ys_s85i [Occ=Once] ->
                        let {
                          sat_s85j [Occ=Once] :: a_a37Y
                          [LclId] =
                              [go_s85e ys_s85i] \u [] go_s85e ys_s85i;
                        } in  GHC.Base.mappend $dMonoid_s85b y_s85h sat_s85j;
                  };
        } in  go_s85e eta_s85c;

GHC.Base.$fMonoid(->)_$cmconcat
  :: forall b a. GHC.Base.Monoid b => [a -> b] -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s85k eta_s85l eta1_s85m]
        let {
          lvl3_s85n [Occ=OnceL] :: b_a4zA
          [LclId] =
              [$dMonoid_s85k] \u [] GHC.Base.mempty $dMonoid_s85k; } in
        let {
          $dSemigroup_s85o [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_a4zA
          [LclId] =
              [$dMonoid_s85k] \u [] GHC.Base.$p1Monoid $dMonoid_s85k; } in
        let {
          go_s85p [Occ=LoopBreaker] :: [a_a4zB -> b_a4zA] -> a_a4zB -> b_a4zA
          [LclId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
              sat-only [lvl3_s85n $dSemigroup_s85o go_s85p] \r [ds_s85q
                                                                eta2_s85r]
                  case ds_s85q of {
                    [] -> lvl3_s85n;
                    : y_s85t [Occ=Once!] ys_s85u [Occ=Once] ->
                        let {
                          sat_s85w [Occ=Once] :: b_a4zA
                          [LclId] =
                              [go_s85p eta2_s85r ys_s85u] \u [] go_s85p ys_s85u eta2_s85r; } in
                        let {
                          sat_s85v [Occ=Once] :: b_a4zA
                          [LclId] =
                              [eta2_s85r y_s85t] \u [] y_s85t eta2_s85r;
                        } in  GHC.Base.<> $dSemigroup_s85o sat_s85v sat_s85w;
                  };
        } in  go_s85p eta_s85l eta1_s85m;

GHC.Base.$fMonoidIO1
  :: forall a.
     GHC.Base.Monoid a =>
     [GHC.Types.IO a]
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s85x eta_s85y void_0E]
        let {
          $dSemigroup_s85A [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_X4I9
          [LclId] =
              [$dMonoid_s85x] \u [] GHC.Base.$p1Monoid $dMonoid_s85x; } in
        let {
          lvl3_s85B [Occ=OnceL] :: a_X4I9
          [LclId] =
              [$dMonoid_s85x] \u [] GHC.Base.mempty $dMonoid_s85x; } in
        let {
          go_s85C [Occ=LoopBreaker]
            :: [GHC.Types.IO a_X4I9]
               -> GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, a_X4I9 #)
          [LclId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_s85A lvl3_s85B go_s85C] \r [ds_s85D void_0E]
                  case ds_s85D of {
                    [] -> Unit# [lvl3_s85B];
                    : y_s85G [Occ=Once] ys_s85H [Occ=Once] ->
                        case y_s85G GHC.Prim.void# of {
                          Unit# ipv1_s85K [Occ=Once] ->
                              case go_s85C ys_s85H GHC.Prim.void# of {
                                Unit# ipv3_s85N [Occ=Once] ->
                                    let {
                                      sat_s85O [Occ=Once] :: a_X4I9
                                      [LclId] =
                                          [$dSemigroup_s85A ipv1_s85K ipv3_s85N] \u []
                                              GHC.Base.<> $dSemigroup_s85A ipv1_s85K ipv3_s85N;
                                    } in  Unit# [sat_s85O];
                              };
                        };
                  };
        } in  go_s85C eta_s85y GHC.Prim.void#;

GHC.Base.$fMonoidIO [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid a => GHC.Base.Monoid (GHC.Types.IO a)
[GblId[DFunId], Arity=1, Str=<L,U(U(C(C1(U)),A,A),U,A,A)>m] =
    [] \r [$dMonoid_s85P]
        let {
          sat_s85V [Occ=Once] :: [GHC.Types.IO a_X4I7] -> GHC.Types.IO a_X4I7
          [LclId] =
              [$dMonoid_s85P] \r [eta_B2 void_0E]
                  GHC.Base.$fMonoidIO1 $dMonoid_s85P eta_B2 GHC.Prim.void#; } in
        let {
          sat_s85U [Occ=Once]
            :: GHC.Types.IO a_X4I7
               -> GHC.Types.IO a_X4I7 -> GHC.Types.IO a_X4I7
          [LclId] =
              [$dMonoid_s85P] \r [eta_B3 eta_B2 void_0E]
                  GHC.Base.$fMonoidIO_$cmappend
                      $dMonoid_s85P eta_B3 eta_B2 GHC.Prim.void#; } in
        let {
          sat_s85T [Occ=Once] :: GHC.Types.IO a_X4I7
          [LclId] =
              [$dMonoid_s85P] \r [void_0E]
                  let {
                    sat_s85S [Occ=Once] :: a_X4I7
                    [LclId] =
                        [$dMonoid_s85P] \u [] GHC.Base.mempty $dMonoid_s85P;
                  } in  Unit# [sat_s85S]; } in
        let {
          sat_s85Q [Occ=Once] :: GHC.Base.Semigroup (GHC.Types.IO a_X4I7)
          [LclId] =
              [$dMonoid_s85P] \u [] GHC.Base.$fMonoidIO_$cp1Monoid $dMonoid_s85P;
        } in  GHC.Base.C:Monoid [sat_s85Q sat_s85T sat_s85U sat_s85V];

GHC.Base.$fFunctor[]_$c<$ :: forall a b. a -> [b] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_s85W eta_s85X]
        let {
          sat_s85Z [Occ=Once] :: b_a4Mt -> a_a4Ms
          [LclId] =
              [x_s85W] \r [ds_s85Y] x_s85W;
        } in  GHC.Base.map sat_s85Z eta_s85X;

GHC.Base.$fFunctorNonEmpty_$c<$
  :: forall a b. a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,1*U(A,1*U)>m,
 Unf=OtherCon []] =
    [] \r [b1_s860 ds_s861]
        let {
          sat_s867 [Occ=Once] :: [a_a4Hj]
          [LclId] =
              [b1_s860 ds_s861] \u []
                  case ds_s861 of {
                    GHC.Base.:| _ [Occ=Dead] as_s864 [Occ=Once] ->
                        let {
                          sat_s866 [Occ=Once] :: b_a4Hk -> a_a4Hj
                          [LclId] =
                              [b1_s860] \r [ds2_s865] b1_s860;
                        } in  GHC.Base.map sat_s866 as_s864;
                  };
        } in  GHC.Base.:| [b1_s860 sat_s867];

GHC.Base.$fFunctor[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.map
                                       GHC.Base.$fFunctor[]_$c<$];

GHC.Base.$fMonad[]_$c>>= [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a] -> (a -> [b]) -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [xs_s868 f_s869]
        let {
          go_s86a [Occ=LoopBreaker] :: [a_a4rg] -> [b_a4rh]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_s869 go_s86a] \r [ds_s86b]
                  case ds_s86b of {
                    [] -> [] [];
                    : y_s86d [Occ=Once] ys_s86e [Occ=Once] ->
                        let {
                          sat_s86g [Occ=Once, Dmd=<L,1*U>] :: [b_a4rh]
                          [LclId] =
                              [go_s86a ys_s86e] \s [] go_s86a ys_s86e;
                        } in 
                          case f_s869 y_s86d of sat_s86f {
                            __DEFAULT -> GHC.Base.++ sat_s86f sat_s86g;
                          };
                  };
        } in  go_s86a xs_s868;

GHC.Base.=<<_$s=<< :: forall a b. (a -> [b]) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s86h x_s86i] GHC.Base.$fMonad[]_$c>>= x_s86i f_s86h;

GHC.Base.=<<
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> m a -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s86j f_s86k x_s86l]
        GHC.Base.>>= $dMonad_s86j x_s86l f_s86k;

poly_go_r7PI :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds_s86m]
        case ds_s86m of {
          [] -> [] [];
          : y_s86o [Occ=Once] ys_s86p [Occ=Once] ->
              let {
                sat_s86q [Occ=Once, Dmd=<L,1*U>] :: [a_a4zZ]
                [LclId] =
                    [ys_s86p] \s [] poly_go_r7PI ys_s86p;
              } in  GHC.Base.++ y_s86o sat_s86q;
        };

GHC.Base.$fMonoid[]_$cmconcat [InlPrag=INLINE (sat-args=1)]
  :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [xss_s86r] poly_go_r7PI xss_s86r;

GHC.Base.$fApplicative[]_$c<*> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a -> b] -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [fs_s86s xs_s86t]
        let {
          go_s86u [Occ=LoopBreaker] :: [a_a4Ka -> b_a4Kb] -> [b_a4Kb]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [xs_s86t go_s86u] \r [ds_s86v]
                  case ds_s86v of {
                    [] -> [] [];
                    : y_s86x [Occ=OnceL!] ys_s86y [Occ=Once] ->
                        let {
                          z_s86z [Occ=OnceL] :: [b_a4Kb]
                          [LclId] =
                              [go_s86u ys_s86y] \u [] go_s86u ys_s86y; } in
                        let {
                          go1_s86A [Occ=LoopBreaker] :: [a_a4Ka] -> [b_a4Kb]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [y_s86x z_s86z go1_s86A] \r [ds1_s86B]
                                  case ds1_s86B of {
                                    [] -> z_s86z;
                                    : y1_s86D [Occ=Once] ys1_s86E [Occ=Once] ->
                                        let {
                                          sat_s86G [Occ=Once] :: [b_a4Kb]
                                          [LclId] =
                                              [go1_s86A ys1_s86E] \u [] go1_s86A ys1_s86E; } in
                                        let {
                                          sat_s86F [Occ=Once] :: b_a4Kb
                                          [LclId] =
                                              [y_s86x y1_s86D] \u [] y_s86x y1_s86D;
                                        } in  : [sat_s86F sat_s86G];
                                  };
                        } in  go1_s86A xs_s86t;
                  };
        } in  go_s86u fs_s86s;

GHC.Base.$fApplicative[]_$cliftA2 [InlPrag=INLINE (sat-args=3)]
  :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s86H xs_s86I ys_s86J]
        let {
          go_s86K [Occ=LoopBreaker] :: [a_a4Ki] -> [c_a4Kk]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_s86H ys_s86J go_s86K] \r [ds_s86L]
                  case ds_s86L of {
                    [] -> [] [];
                    : y_s86N [Occ=OnceL] ys1_s86O [Occ=Once] ->
                        let {
                          z_s86P [Occ=OnceL] :: [c_a4Kk]
                          [LclId] =
                              [go_s86K ys1_s86O] \u [] go_s86K ys1_s86O; } in
                        let {
                          go1_s86Q [Occ=LoopBreaker] :: [b_a4Kj] -> [c_a4Kk]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [f_s86H y_s86N z_s86P go1_s86Q] \r [ds1_s86R]
                                  case ds1_s86R of {
                                    [] -> z_s86P;
                                    : y1_s86T [Occ=Once] ys2_s86U [Occ=Once] ->
                                        let {
                                          sat_s86W [Occ=Once] :: [c_a4Kk]
                                          [LclId] =
                                              [go1_s86Q ys2_s86U] \u [] go1_s86Q ys2_s86U; } in
                                        let {
                                          sat_s86V [Occ=Once] :: c_a4Kk
                                          [LclId] =
                                              [f_s86H y_s86N y1_s86T] \u [] f_s86H y_s86N y1_s86T;
                                        } in  : [sat_s86V sat_s86W];
                                  };
                        } in  go1_s86Q ys_s86J;
                  };
        } in  go_s86K xs_s86I;

GHC.Base.$fApplicative[]_$c<* :: forall a b. [a] -> [b] -> [a]
[GblId, Arity=2, Caf=NoCafRefs, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fApplicative[]_$cliftA2 GHC.Base.const eta_B2 eta_B1;

GHC.Base.$fApplicative[]_$c*> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a] -> [b] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [xs_s86X ys_s86Y]
        let {
          go_s86Z [Occ=LoopBreaker] :: [a_a4Kr] -> [b_a4Ks]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [ys_s86Y go_s86Z] \r [ds_s870]
                  case ds_s870 of {
                    [] -> [] [];
                    : _ [Occ=Dead] ys1_s873 [Occ=Once] ->
                        let {
                          sat_s874 [Occ=Once, Dmd=<L,1*U>] :: [b_a4Ks]
                          [LclId] =
                              [go_s86Z ys1_s873] \s [] go_s86Z ys1_s873;
                        } in  GHC.Base.++ ys_s86Y sat_s874;
                  };
        } in  go_s86Z xs_s86X;

GHC.Base.$fApplicative[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctor[]
                                           GHC.Base.$fApplicative[]_$cpure
                                           GHC.Base.$fApplicative[]_$c<*>
                                           GHC.Base.$fApplicative[]_$cliftA2
                                           GHC.Base.$fApplicative[]_$c*>
                                           GHC.Base.$fApplicative[]_$c<*];

GHC.Base.$fFunctorNonEmpty_$cfmap
  :: forall a b.
     (a -> b) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_s875 ds_s876]
        let {
          sat_s87f [Occ=Once] :: [b_a4H8]
          [LclId] =
              [f_s875 ds_s876] \u []
                  case ds_s876 of {
                    GHC.Base.:| _ [Occ=Dead] as_s87e [Occ=Once] ->
                        GHC.Base.map f_s875 as_s87e;
                  }; } in
        let {
          sat_s87b [Occ=Once] :: b_a4H8
          [LclId] =
              [f_s875 ds_s876] \u []
                  let {
                    sat_s87a [Occ=Once] :: a_a4H7
                    [LclId] =
                        [ds_s876] \u []
                            case ds_s876 of {
                              GHC.Base.:| a1_s878 [Occ=Once] _ [Occ=Dead] -> a1_s878;
                            };
                  } in  f_s875 sat_s87a;
        } in  GHC.Base.:| [sat_s87b sat_s87f];

GHC.Base.$fFunctorNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctorNonEmpty_$cfmap
                                       GHC.Base.$fFunctorNonEmpty_$c<$];

GHC.Base.$fAlternative[]1 :: forall a. [[a]]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Types.[] GHC.Types.[]];

GHC.Base.$fAlternative[]_$csome :: forall a. [a] -> [[a]]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s87g]
        let {
          some_v_s87h [Occ=LoopBreaker] :: [[a_a4Ik]]
          [LclId] =
              [v_s87g some_v_s87h] \u []
                  let {
                    ys_s87i [Occ=OnceL] :: [[a_a4Ik]]
                    [LclId] =
                        [some_v_s87h] \u []
                            GHC.Base.++ some_v_s87h GHC.Base.$fAlternative[]1; } in
                  let {
                    go_s87j [Occ=LoopBreaker] :: [a_a4Ik] -> [[a_a4Ik]]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                        sat-only [ys_s87i go_s87j] \r [ds_s87k]
                            case ds_s87k of {
                              [] -> [] [];
                              : y_s87m [Occ=OnceL] ys1_s87n [Occ=Once] ->
                                  let {
                                    z_s87o [Occ=OnceL] :: [[a_a4Ik]]
                                    [LclId] =
                                        [go_s87j ys1_s87n] \u [] go_s87j ys1_s87n; } in
                                  let {
                                    go1_s87p [Occ=LoopBreaker] :: [[a_a4Ik]] -> [[a_a4Ik]]
                                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                        sat-only [y_s87m z_s87o go1_s87p] \r [ds1_s87q]
                                            case ds1_s87q of {
                                              [] -> z_s87o;
                                              : y1_s87s [Occ=Once] ys2_s87t [Occ=Once] ->
                                                  let {
                                                    sat_s87v [Occ=Once] :: [[a_a4Ik]]
                                                    [LclId] =
                                                        [go1_s87p ys2_s87t] \u []
                                                            go1_s87p ys2_s87t; } in
                                                  let {
                                                    sat_s87u [Occ=Once] :: [a_a4Ik]
                                                    [LclId] =
                                                        CCCS :! [y_s87m y1_s87s];
                                                  } in  : [sat_s87u sat_s87v];
                                            };
                                  } in  go1_s87p ys_s87i;
                            };
                  } in  go_s87j v_s87g;
        } in  some_v_s87h;

GHC.Base.$fAlternative[]_$cmany :: forall a. [a] -> [[a]]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_s87w]
        let {
          many_v_s87x [Occ=LoopBreaker] :: [[a_a4Is]]
          [LclId] =
              [v_s87w many_v_s87x] \u []
                  let {
                    go_s87y [Occ=LoopBreaker] :: [a_a4Is] -> [[a_a4Is]]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                        sat-only [many_v_s87x go_s87y] \r [ds_s87z]
                            case ds_s87z of {
                              [] -> [] [];
                              : y_s87B [Occ=OnceL] ys_s87C [Occ=Once] ->
                                  let {
                                    z_s87D [Occ=OnceL] :: [[a_a4Is]]
                                    [LclId] =
                                        [go_s87y ys_s87C] \u [] go_s87y ys_s87C; } in
                                  let {
                                    go1_s87E [Occ=LoopBreaker] :: [[a_a4Is]] -> [[a_a4Is]]
                                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                        sat-only [y_s87B z_s87D go1_s87E] \r [ds1_s87F]
                                            case ds1_s87F of {
                                              [] -> z_s87D;
                                              : y1_s87H [Occ=Once] ys1_s87I [Occ=Once] ->
                                                  let {
                                                    sat_s87K [Occ=Once] :: [[a_a4Is]]
                                                    [LclId] =
                                                        [go1_s87E ys1_s87I] \u []
                                                            go1_s87E ys1_s87I; } in
                                                  let {
                                                    sat_s87J [Occ=Once] :: [a_a4Is]
                                                    [LclId] =
                                                        CCCS :! [y_s87B y1_s87H];
                                                  } in  : [sat_s87J sat_s87K];
                                            };
                                  } in  go1_s87E many_v_s87x;
                            };
                  } in 
                    case go_s87y v_s87w of sat_s87L {
                      __DEFAULT -> GHC.Base.++ sat_s87L GHC.Base.$fAlternative[]1;
                    };
        } in  many_v_s87x;

GHC.Base.$fAlternative[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [GHC.Base.$fApplicative[]
                                           GHC.Types.[]
                                           GHC.Base.++
                                           GHC.Base.$fAlternative[]_$csome
                                           GHC.Base.$fAlternative[]_$cmany];

GHC.Base.$w$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> (a -> GHC.Base.NonEmpty b) -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,C(U(1*U,1*U))>,
 Unf=OtherCon []] =
    [] \r [w_s87M w1_s87N]
        let {
          ds_s87O [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty b_s6HN
          [LclId] =
              [w_s87M w1_s87N] \u []
                  let {
                    sat_s87S [Occ=Once] :: a_s6HM
                    [LclId] =
                        [w_s87M] \u []
                            case w_s87M of {
                              GHC.Base.:| a1_s87Q [Occ=Once] _ [Occ=Dead] -> a1_s87Q;
                            };
                  } in  w1_s87N sat_s87S; } in
        let {
          sat_s88k [Occ=Once] :: [b_s6HN]
          [LclId] =
              [w_s87M w1_s87N ds_s87O] \u []
                  case ds_s87O of {
                    GHC.Base.:| _ [Occ=Dead] bs_s87Z [Occ=Once] ->
                        let {
                          sat_s88j [Occ=Once, Dmd=<L,1*U>] :: [b_s6HN]
                          [LclId] =
                              [w_s87M w1_s87N] \s []
                                  case w_s87M of {
                                    GHC.Base.:| _ [Occ=Dead] as_s882 [Occ=Once] ->
                                        let {
                                          go_s883 [Occ=LoopBreaker] :: [a_s6HM] -> [b_s6HN]
                                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                              sat-only [w1_s87N go_s883] \r [ds1_s884]
                                                  case ds1_s884 of {
                                                    [] -> [] [];
                                                    : y_s886 [Occ=Once] ys_s887 [Occ=Once] ->
                                                        let {
                                                          ds2_s888 [Dmd=<L,U(1*U,1*U)>]
                                                            :: GHC.Base.NonEmpty b_s6HN
                                                          [LclId] =
                                                              [w1_s87N y_s886] \u []
                                                                  w1_s87N y_s886; } in
                                                        let {
                                                          sat_s88i [Occ=Once, Dmd=<L,1*U>]
                                                            :: [b_s6HN]
                                                          [LclId] =
                                                              [go_s883 ys_s887] \s []
                                                                  go_s883 ys_s887; } in
                                                        let {
                                                          sat_s88g [Occ=Once] :: [b_s6HN]
                                                          [LclId] =
                                                              [ds2_s888] \u []
                                                                  case ds2_s888 of {
                                                                    GHC.Base.:| _ [Occ=Dead]
                                                                                cs_s88f [Occ=Once] ->
                                                                        cs_s88f;
                                                                  }; } in
                                                        let {
                                                          sat_s88c [Occ=Once] :: b_s6HN
                                                          [LclId] =
                                                              [ds2_s888] \u []
                                                                  case ds2_s888 of {
                                                                    GHC.Base.:| c_s88a [Occ=Once]
                                                                                _ [Occ=Dead] ->
                                                                        c_s88a;
                                                                  }; } in
                                                        let {
                                                          sat_s88h [Occ=Once] :: [b_s6HN]
                                                          [LclId] =
                                                              CCCS :! [sat_s88c sat_s88g];
                                                        } in  GHC.Base.++ sat_s88h sat_s88i;
                                                  };
                                        } in  go_s883 as_s882;
                                  };
                        } in  GHC.Base.++ bs_s87Z sat_s88j;
                  }; } in
        let {
          sat_s87W [Occ=Once] :: b_s6HN
          [LclId] =
              [ds_s87O] \u []
                  case ds_s87O of {
                    GHC.Base.:| b1_s87U [Occ=Once] _ [Occ=Dead] -> b1_s87U;
                  };
        } in  (#,#) [sat_s87W sat_s88k];

GHC.Base.$fMonadNonEmpty_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a
     -> (a -> GHC.Base.NonEmpty b) -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,C(U(1*U,1*U))>m,
 Unf=OtherCon []] =
    [] \r [w_s88l w1_s88m]
        case GHC.Base.$w$c>>= w_s88l w1_s88m of {
          (#,#) ww1_s88o [Occ=Once] ww2_s88p [Occ=Once] ->
              GHC.Base.:| [ww1_s88o ww2_s88p];
        };

GHC.Base.$fMonadNonEmpty_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [eta_s88q eta1_s88r]
        let {
          sat_s88t [Occ=Once] :: a_a4sH -> GHC.Base.NonEmpty b_a4sI
          [LclId] =
              [eta1_s88r] \r [ds_s88s] eta1_s88r;
        } in 
          case GHC.Base.$w$c>>= eta_s88q sat_s88t of {
            (#,#) ww1_s88v [Occ=Once] ww2_s88w [Occ=Once] ->
                GHC.Base.:| [ww1_s88v ww2_s88w];
          };

GHC.Base.<**>1 :: forall a b. a -> (a -> b) -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [a1_s88x f_s88y] f_s88y a1_s88x;

GHC.Base.<**>
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     f a -> f (a -> b) -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s88z]
        GHC.Base.liftA2 $dApplicative_s88z GHC.Base.<**>1;

GHC.Base.$dmliftA2
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b c. (a -> b -> c) -> f a -> f b -> f c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLL),U(1*U(1*C1(C1(U)),A),A,1*C1(U),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s88A eta_s88B eta1_s88C]
        let {
          sat_s88E [Occ=Once] :: f_a37E (b_a4iN -> c_a4iO)
          [LclId] =
              [$dApplicative_s88A eta_s88B eta1_s88C] \u []
                  case GHC.Base.$p1Applicative $dApplicative_s88A of sat_s88D {
                    __DEFAULT -> GHC.Base.fmap sat_s88D eta_s88B eta1_s88C;
                  };
        } in  GHC.Base.<*> $dApplicative_s88A sat_s88E;

GHC.Base.$dmsome
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s88F eta_s88G]
        let {
          some_v_s88H [Occ=LoopBreaker] :: f_a37j [a_a4ju]
          [LclId] =
              [$dAlternative_s88F eta_s88G some_v_s88H] \u []
                  case
                      GHC.Base.$p1Alternative $dAlternative_s88F
                  of
                  $dApplicative_s88I [Dmd=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                  { __DEFAULT ->
                        let {
                          sat_s88K [Occ=Once] :: f_a37j [a_a4ju]
                          [LclId] =
                              [$dAlternative_s88F some_v_s88H $dApplicative_s88I] \u []
                                  let {
                                    sat_s88J [Occ=Once] :: f_a37j [a_a4ju]
                                    [LclId] =
                                        [$dApplicative_s88I] \u []
                                            GHC.Base.pure $dApplicative_s88I GHC.Types.[];
                                  } in  GHC.Base.<|> $dAlternative_s88F some_v_s88H sat_s88J;
                        } in 
                          GHC.Base.liftA2 $dApplicative_s88I GHC.Types.: eta_s88G sat_s88K;
                  };
        } in  some_v_s88H;

GHC.Base.$dmmany
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s88L eta_s88M]
        let {
          many_v_s88N [Occ=LoopBreaker] :: f_a37j [a_a4jX]
          [LclId] =
              [$dAlternative_s88L eta_s88M many_v_s88N] \u []
                  let {
                    $dApplicative_s88O [Dmd=<L,U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                      :: GHC.Base.Applicative f_a37j
                    [LclId] =
                        [$dAlternative_s88L] \u []
                            GHC.Base.$p1Alternative $dAlternative_s88L; } in
                  let {
                    sat_s88Q [Occ=Once] :: f_a37j [a_a4jX]
                    [LclId] =
                        [$dApplicative_s88O] \u []
                            GHC.Base.pure $dApplicative_s88O GHC.Types.[]; } in
                  let {
                    sat_s88P [Occ=Once] :: f_a37j [a_a4jX]
                    [LclId] =
                        [eta_s88M many_v_s88N $dApplicative_s88O] \u []
                            GHC.Base.liftA2
                                $dApplicative_s88O GHC.Types.: eta_s88M many_v_s88N;
                  } in  GHC.Base.<|> $dAlternative_s88L sat_s88P sat_s88Q;
        } in  many_v_s88N;

GHC.Base.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Base.Semigroup b =>
     (a -> b) -> [a -> b] -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s88R ww_s88S ww1_s88T]
        let {
          go_s88U [Occ=LoopBreaker]
            :: (a_s6HX -> b_s6HW) -> [a_s6HX -> b_s6HW] -> a_s6HX -> b_s6HW
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s88R go_s88U] \r [b1_s88V ds_s88W]
                  case ds_s88W of {
                    [] -> b1_s88V;
                    : c_s88Y [Occ=Once] cs_s88Z [Occ=Once] ->
                        let {
                          g_s890 [Occ=OnceL!, Dmd=<L,C(U)>] :: a_s6HX -> b_s6HW
                          [LclId] =
                              [go_s88U c_s88Y cs_s88Z] \u [] go_s88U c_s88Y cs_s88Z; } in
                        let {
                          sat_s894 [Occ=OnceT[0]] :: a_s6HX -> b_s6HW
                          [LclId] =
                              [w_s88R b1_s88V g_s890] \r [x_s891]
                                  let {
                                    sat_s893 [Occ=Once] :: b_s6HW
                                    [LclId] =
                                        [g_s890 x_s891] \u [] g_s890 x_s891; } in
                                  let {
                                    sat_s892 [Occ=Once] :: b_s6HW
                                    [LclId] =
                                        [b1_s88V x_s891] \u [] b1_s88V x_s891;
                                  } in  GHC.Base.<> w_s88R sat_s892 sat_s893;
                        } in  sat_s894;
                  };
        } in  go_s88U ww_s88S ww1_s88T;

GHC.Base.$fSemigroup(->)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Base.Semigroup b =>
     GHC.Base.NonEmpty (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s895 w1_s896]
        case w1_s896 of {
          GHC.Base.:| ww1_s898 [Occ=Once] ww2_s899 [Occ=Once] ->
              GHC.Base.$w$csconcat3 w_s895 ww1_s898 ww2_s899;
        };

GHC.Base.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     a -> b -> [(a, b)] -> (# a, b #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s89a w1_s89b ww_s89c ww1_s89d ww2_s89e]
        let {
          $wgo_s89f [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: a_s6Ih -> b_s6Ii -> [(a_s6Ih, b_s6Ii)] -> (# a_s6Ih, b_s6Ii #)
          [LclId, Arity=3, Str=<L,U><L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s89a w1_s89b $wgo_s89f] \r [ww3_s89g ww4_s89h w2_s89i]
                  case w2_s89i of {
                    [] -> (#,#) [ww3_s89g ww4_s89h];
                    : c_s89k [Occ=Once!] cs_s89l [Occ=Once] ->
                        case c_s89k of {
                          (,) ww6_s89n [Occ=Once] ww7_s89o [Occ=Once] ->
                              case $wgo_s89f ww6_s89n ww7_s89o cs_s89l of {
                                (#,#) ww9_s89q [Occ=Once] ww10_s89r [Occ=Once] ->
                                    let {
                                      sat_s89t [Occ=Once] :: b_s6Ii
                                      [LclId] =
                                          [w1_s89b ww4_s89h ww10_s89r] \u []
                                              GHC.Base.<> w1_s89b ww4_s89h ww10_s89r; } in
                                    let {
                                      sat_s89s [Occ=Once] :: a_s6Ih
                                      [LclId] =
                                          [w_s89a ww3_s89g ww9_s89q] \u []
                                              GHC.Base.<> w_s89a ww3_s89g ww9_s89q;
                                    } in  (#,#) [sat_s89s sat_s89t];
                              };
                        };
                  };
        } in  $wgo_s89f ww_s89c ww1_s89d ww2_s89e;

GHC.Base.$fSemigroup(,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     GHC.Base.NonEmpty (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s89u w1_s89v w2_s89w]
        case w2_s89w of {
          GHC.Base.:| ww1_s89y [Occ=Once!] ww2_s89z [Occ=Once] ->
              case ww1_s89y of {
                (,) ww4_s89B [Occ=Once] ww5_s89C [Occ=Once] ->
                    case
                        GHC.Base.$w$csconcat w_s89u w1_s89v ww4_s89B ww5_s89C ww2_s89z
                    of
                    { (#,#) ww7_s89E [Occ=Once] ww8_s89F [Occ=Once] ->
                          (,) [ww7_s89E ww8_s89F];
                    };
              };
        };

GHC.Base.$dmsconcat
  :: forall a. GHC.Base.Semigroup a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s89G ds_s89H]
        case ds_s89H of {
          GHC.Base.:| a1_s89J [Occ=Once] as_s89K [Occ=Once] ->
              let {
                go_s89L [Occ=LoopBreaker] :: a_a37Z -> [a_a37Z] -> a_a37Z
                [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
                    sat-only [$dSemigroup_s89G go_s89L] \r [b_s89M ds1_s89N]
                        case ds1_s89N of {
                          [] -> b_s89M;
                          : c_s89P [Occ=Once] cs_s89Q [Occ=Once] ->
                              let {
                                sat_s89R [Occ=Once] :: a_a37Z
                                [LclId] =
                                    [go_s89L c_s89P cs_s89Q] \u [] go_s89L c_s89P cs_s89Q;
                              } in  GHC.Base.<> $dSemigroup_s89G b_s89M sat_s89R;
                        };
              } in  go_s89L a1_s89J as_s89K;
        };

GHC.Base.$dmstimes
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b. GHC.Real.Integral b => b -> a -> a
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
    [] \r [$dSemigroup_s89S $dIntegral_s89T]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_s89T $dSemigroup_s89S;

GHC.Base.$dmmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Base.Monoid a => a -> a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(SLL)LLL),1*U(1*U(1*U,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s89U]
        case GHC.Base.$p1Monoid $dMonoid_s89U of sat_s89V {
          __DEFAULT -> GHC.Base.<> sat_s89V;
        };

GHC.Base.$dm>> [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. m a -> m b -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s89W m1_s89X k_s89Y]
        let {
          sat_s8a0 [Occ=Once] :: a_a4lv -> m_a37u b_a4lw
          [LclId] =
              [k_s89Y] \r [ds_s89Z] k_s89Y;
        } in  GHC.Base.>>= $dMonad_s89W m1_s89X sat_s8a0;

GHC.Base.$dmreturn
  :: forall (m :: * -> *). GHC.Base.Monad m => forall a. a -> m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LSLLLL)LLLL),1*U(1*U(A,1*U,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_s8a1]
        case GHC.Base.$p1Monad $dMonad_s8a1 of sat_s8a2 {
          __DEFAULT -> GHC.Base.pure sat_s8a2;
        };

GHC.Base.$dmfail
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a. GHC.Base.String -> m a
[GblId, Arity=2, Str=<B,A><B,U>x, Unf=OtherCon []] =
    [] \r [$dMonad_s8a3 s_s8a4] GHC.Err.errorWithoutStackTrace s_s8a4;

GHC.Base.$dmmzero
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => forall a. m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LSLLL)LLL),1*U(1*U(A,1*U,A,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_s8a5]
        case GHC.Base.$p1MonadPlus $dMonadPlus_s8a5 of sat_s8a6 {
          __DEFAULT -> GHC.Base.empty sat_s8a6;
        };

GHC.Base.$dmmplus
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a. m a -> m a -> m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LLSLL)LLL),1*U(1*U(A,A,1*U,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_s8a7]
        case GHC.Base.$p1MonadPlus $dMonadPlus_s8a7 of sat_s8a8 {
          __DEFAULT -> GHC.Base.<|> sat_s8a8;
        };

GHC.Base.$fEqMaybe_$c==
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s8a9 ds_s8aa ds1_s8ab]
        case ds_s8aa of {
          GHC.Base.Nothing ->
              case ds1_s8ab of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just a1_s8af [Occ=Once] ->
              case ds1_s8ab of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just b1_s8ah [Occ=Once] ->
                    GHC.Classes.== $dEq_s8a9 a1_s8af b1_s8ah;
              };
        };

GHC.Base.$fEqMaybe_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_s8ai eta_s8aj eta1_s8ak]
        case eta_s8aj of {
          GHC.Base.Nothing ->
              case eta1_s8ak of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.True [];
              };
          GHC.Base.Just a1_s8ao [Occ=Once] ->
              case eta1_s8ak of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just b1_s8aq [Occ=Once] ->
                    case GHC.Classes.== $dEq_s8ai a1_s8ao b1_s8aq of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

GHC.Base.$fEqMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Base.Maybe a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s8as]
        let {
          sat_s8au [Occ=Once]
            :: GHC.Base.Maybe a_a4m9 -> GHC.Base.Maybe a_a4m9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s8as] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_s8as eta_B2 eta_B1; } in
        let {
          sat_s8at [Occ=Once]
            :: GHC.Base.Maybe a_a4m9 -> GHC.Base.Maybe a_a4m9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s8as] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_s8as eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s8at sat_s8au];

GHC.Base.$fOrdMaybe_$cp1Ord
  :: forall a. GHC.Classes.Ord a => GHC.Classes.Eq (GHC.Base.Maybe a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8av]
        let {
          sat_s8aw [Occ=Once, Dmd=<L,U(C(C1(U)),A)>] :: GHC.Classes.Eq a_a4mo
          [LclId] =
              [$dOrd_s8av] \u [] GHC.Classes.$p1Ord $dOrd_s8av;
        } in  GHC.Base.$fEqMaybe sat_s8aw;

GHC.Base.$fOrdMaybe_$ccompare
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8ax a1_s8ay b_s8az]
        case a1_s8ay of {
          GHC.Base.Nothing ->
              case b_s8az of {
                GHC.Base.Nothing -> GHC.Types.EQ [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.LT [];
              };
          GHC.Base.Just a2_s8aD [Occ=Once] ->
              case b_s8az of {
                GHC.Base.Nothing -> GHC.Types.GT [];
                GHC.Base.Just b1_s8aF [Occ=Once] ->
                    GHC.Classes.compare $dOrd_s8ax a2_s8aD b1_s8aF;
              };
        };

GHC.Base.$fOrdMaybe_$c<
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8aG a1_s8aH b_s8aI]
        case a1_s8aH of {
          GHC.Base.Nothing ->
              case b_s8aI of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.True [];
              };
          GHC.Base.Just a2_s8aM [Occ=Once] ->
              case b_s8aI of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just b1_s8aO [Occ=Once] ->
                    GHC.Classes.< $dOrd_s8aG a2_s8aM b1_s8aO;
              };
        };

GHC.Base.$fOrdMaybe_$c<=
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8aP a1_s8aQ b_s8aR]
        case b_s8aR of {
          GHC.Base.Nothing ->
              case a1_s8aQ of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just a2_s8aV [Occ=Once] ->
              case a1_s8aQ of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just b1_s8aX [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s8aP a2_s8aV b1_s8aX of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

GHC.Base.$fOrdMaybe_$cmax
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8aZ x_s8b0 y_s8b1]
        case y_s8b1 of wild_s8b2 {
          GHC.Base.Nothing -> x_s8b0;
          GHC.Base.Just a1_s8b3 [Occ=Once] ->
              case x_s8b0 of wild1_s8b4 {
                GHC.Base.Nothing -> wild_s8b2;
                GHC.Base.Just b1_s8b5 [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s8aZ a1_s8b3 b1_s8b5 of {
                      GHC.Types.False -> wild_s8b2;
                      GHC.Types.True -> wild1_s8b4;
                    };
              };
        };

GHC.Base.$fOrdMaybe_$cmin
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8b7 x_s8b8 y_s8b9]
        case y_s8b9 of wild_s8ba {
          GHC.Base.Nothing ->
              case x_s8b8 of { __DEFAULT -> GHC.Base.Nothing []; };
          GHC.Base.Just a1_s8bc [Occ=Once] ->
              case x_s8b8 of wild1_s8bd {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just b1_s8be [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s8b7 a1_s8bc b1_s8be of {
                      GHC.Types.False -> wild1_s8bd;
                      GHC.Types.True -> wild_s8ba;
                    };
              };
        };

GHC.Base.$fOrdMaybe_$c>=
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8bg a1_s8bh b_s8bi]
        case a1_s8bh of {
          GHC.Base.Nothing ->
              case b_s8bi of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just a2_s8bm [Occ=Once] ->
              case b_s8bi of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just b1_s8bo [Occ=Once] ->
                    case GHC.Classes.< $dOrd_s8bg a2_s8bm b1_s8bo of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

GHC.Base.$fOrdMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (GHC.Base.Maybe a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s8bq]
        let {
          sat_s8bA [Occ=Once]
            :: GHC.Base.Maybe a_a4mo
               -> GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo
          [LclId] =
              [$dOrd_s8bq] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_s8bq eta_B2 eta_B1; } in
        let {
          sat_s8bz [Occ=Once]
            :: GHC.Base.Maybe a_a4mo
               -> GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo
          [LclId] =
              [$dOrd_s8bq] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_s8bq eta_B2 eta_B1; } in
        let {
          sat_s8by [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8bq] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_s8bq eta_B2 eta_B1; } in
        let {
          sat_s8bx [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8bq] \r [a1_s8bv b_s8bw]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s8bq b_s8bw a1_s8bv; } in
        let {
          sat_s8bu [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8bq] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_s8bq eta_B2 eta_B1; } in
        let {
          sat_s8bt [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8bq] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s8bq eta_B2 eta_B1; } in
        let {
          sat_s8bs [Occ=Once]
            :: GHC.Base.Maybe a_a4mo
               -> GHC.Base.Maybe a_a4mo -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s8bq] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_s8bq eta_B2 eta_B1; } in
        let {
          sat_s8br [Occ=Once] :: GHC.Classes.Eq (GHC.Base.Maybe a_a4mo)
          [LclId] =
              [$dOrd_s8bq] \u [] GHC.Base.$fOrdMaybe_$cp1Ord $dOrd_s8bq;
        } in 
          GHC.Classes.C:Ord [sat_s8br
                             sat_s8bs
                             sat_s8bt
                             sat_s8bu
                             sat_s8bx
                             sat_s8by
                             sat_s8bz
                             sat_s8bA];

GHC.Base.$fEqNonEmpty_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_s8bB eta_s8bC eta1_s8bD]
        case eta_s8bC of {
          GHC.Base.:| a1_s8bF [Occ=Once] a2_s8bG [Occ=Once] ->
              case eta1_s8bD of {
                GHC.Base.:| b1_s8bI [Occ=Once] b2_s8bJ [Occ=Once] ->
                    case GHC.Classes.== $dEq_s8bB a1_s8bF b1_s8bI of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True ->
                          case GHC.Classes.$fEq[]_$c== $dEq_s8bB a2_s8bG b2_s8bJ of {
                            GHC.Types.False -> GHC.Types.True [];
                            GHC.Types.True -> GHC.Types.False [];
                          };
                    };
              };
        };

GHC.Base.$w$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8bM ww_s8bN ww1_s8bO ww2_s8bP ww3_s8bQ]
        case GHC.Classes.== w_s8bM ww_s8bN ww2_s8bP of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True -> GHC.Classes.$fEq[]_$c== w_s8bM ww1_s8bO ww3_s8bQ;
        };

GHC.Base.$fEqNonEmpty_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s8bS w1_s8bT w2_s8bU]
        case w1_s8bT of {
          GHC.Base.:| ww1_s8bW [Occ=Once] ww2_s8bX [Occ=Once] ->
              case w2_s8bU of {
                GHC.Base.:| ww4_s8bZ [Occ=Once] ww5_s8c0 [Occ=Once] ->
                    GHC.Base.$w$c== w_s8bS ww1_s8bW ww2_s8bX ww4_s8bZ ww5_s8c0;
              };
        };

GHC.Base.$fEqNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (GHC.Base.NonEmpty a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s8c1]
        let {
          sat_s8c3 [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nu
               -> GHC.Base.NonEmpty a_a4nu -> GHC.Types.Bool
          [LclId] =
              [$dEq_s8c1] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqNonEmpty_$c/= $dEq_s8c1 eta_B2 eta_B1; } in
        let {
          sat_s8c2 [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nu
               -> GHC.Base.NonEmpty a_a4nu -> GHC.Types.Bool
          [LclId] =
              [$dEq_s8c1] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqNonEmpty_$c== $dEq_s8c1 eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s8c2 sat_s8c3];

GHC.Base.$fOrdNonEmpty_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (GHC.Base.NonEmpty a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s8c4]
        let {
          sat_s8c5 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>] :: GHC.Classes.Eq a_a4nL
          [LclId] =
              [$dOrd_s8c4] \u [] GHC.Classes.$p1Ord $dOrd_s8c4;
        } in  GHC.Base.$fEqNonEmpty sat_s8c5;

GHC.Base.$w$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8c6 ww_s8c7 ww1_s8c8 ww2_s8c9 ww3_s8ca]
        case GHC.Classes.compare w_s8c6 ww_s8c7 ww2_s8c9 of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ ->
              GHC.Classes.$fOrd[]_$ccompare w_s8c6 ww1_s8c8 ww3_s8ca;
          GHC.Types.GT -> GHC.Types.GT [];
        };

GHC.Base.$fOrdNonEmpty_$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s8cc w1_s8cd w2_s8ce]
        case w1_s8cd of {
          GHC.Base.:| ww1_s8cg [Occ=Once] ww2_s8ch [Occ=Once] ->
              case w2_s8ce of {
                GHC.Base.:| ww4_s8cj [Occ=Once] ww5_s8ck [Occ=Once] ->
                    GHC.Base.$w$ccompare w_s8cc ww1_s8cg ww2_s8ch ww4_s8cj ww5_s8ck;
              };
        };

GHC.Base.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8cl ww_s8cm ww1_s8cn ww2_s8co ww3_s8cp]
        case GHC.Classes.compare w_s8cl ww_s8cm ww2_s8co of {
          GHC.Types.LT -> GHC.Types.True [];
          GHC.Types.EQ -> GHC.Classes.$fOrd[]_$c< w_s8cl ww1_s8cn ww3_s8cp;
          GHC.Types.GT -> GHC.Types.False [];
        };

GHC.Base.$fOrdNonEmpty_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s8cr w1_s8cs w2_s8ct]
        case w1_s8cs of {
          GHC.Base.:| ww1_s8cv [Occ=Once] ww2_s8cw [Occ=Once] ->
              case w2_s8ct of {
                GHC.Base.:| ww4_s8cy [Occ=Once] ww5_s8cz [Occ=Once] ->
                    GHC.Base.$w$c< w_s8cr ww1_s8cv ww2_s8cw ww4_s8cy ww5_s8cz;
              };
        };

GHC.Base.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8cA ww_s8cB ww1_s8cC ww2_s8cD ww3_s8cE]
        case GHC.Classes.compare w_s8cA ww2_s8cD ww_s8cB of {
          GHC.Types.LT -> GHC.Types.False [];
          GHC.Types.EQ ->
              case GHC.Classes.$fOrd[]_$ccompare w_s8cA ww3_s8cE ww1_s8cC of {
                __DEFAULT -> GHC.Types.True [];
                GHC.Types.LT -> GHC.Types.False [];
              };
          GHC.Types.GT -> GHC.Types.True [];
        };

GHC.Base.$fOrdNonEmpty_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s8cH w1_s8cI w2_s8cJ]
        case w1_s8cI of {
          GHC.Base.:| ww1_s8cL [Occ=Once] ww2_s8cM [Occ=Once] ->
              case w2_s8cJ of {
                GHC.Base.:| ww4_s8cO [Occ=Once] ww5_s8cP [Occ=Once] ->
                    GHC.Base.$w$c<= w_s8cH ww1_s8cL ww2_s8cM ww4_s8cO ww5_s8cP;
              };
        };

GHC.Base.$fOrdNonEmpty_$cmax [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8cQ w1_s8cR w2_s8cS]
        case w1_s8cR of ww_s8cT {
          GHC.Base.:| ww1_s8cU [Occ=Once] ww2_s8cV [Occ=Once] ->
              case w2_s8cS of ww3_s8cW {
                GHC.Base.:| ww4_s8cX [Occ=Once] ww5_s8cY [Occ=Once] ->
                    case GHC.Classes.compare w_s8cQ ww4_s8cX ww1_s8cU of {
                      GHC.Types.LT -> ww_s8cT;
                      GHC.Types.EQ ->
                          case GHC.Classes.$fOrd[]_$ccompare w_s8cQ ww5_s8cY ww2_s8cV of {
                            __DEFAULT -> ww3_s8cW;
                            GHC.Types.LT -> ww_s8cT;
                          };
                      GHC.Types.GT -> ww3_s8cW;
                    };
              };
        };

GHC.Base.$fOrdNonEmpty_$cmin [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8d1 w1_s8d2 w2_s8d3]
        case w1_s8d2 of ww_s8d4 {
          GHC.Base.:| ww1_s8d5 [Occ=Once] ww2_s8d6 [Occ=Once] ->
              case w2_s8d3 of ww3_s8d7 {
                GHC.Base.:| ww4_s8d8 [Occ=Once] ww5_s8d9 [Occ=Once] ->
                    case GHC.Classes.compare w_s8d1 ww4_s8d8 ww1_s8d5 of {
                      GHC.Types.LT -> ww3_s8d7;
                      GHC.Types.EQ ->
                          case GHC.Classes.$fOrd[]_$ccompare w_s8d1 ww5_s8d9 ww2_s8d6 of {
                            __DEFAULT -> ww_s8d4;
                            GHC.Types.LT -> ww3_s8d7;
                          };
                      GHC.Types.GT -> ww_s8d4;
                    };
              };
        };

GHC.Base.$w$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8dc ww_s8dd ww1_s8de ww2_s8df ww3_s8dg]
        case GHC.Classes.compare w_s8dc ww_s8dd ww2_s8df of {
          GHC.Types.LT -> GHC.Types.False [];
          GHC.Types.EQ ->
              case GHC.Classes.$fOrd[]_$ccompare w_s8dc ww1_s8de ww3_s8dg of {
                __DEFAULT -> GHC.Types.True [];
                GHC.Types.LT -> GHC.Types.False [];
              };
          GHC.Types.GT -> GHC.Types.True [];
        };

GHC.Base.$fOrdNonEmpty_$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s8dj w1_s8dk w2_s8dl]
        case w1_s8dk of {
          GHC.Base.:| ww1_s8dn [Occ=Once] ww2_s8do [Occ=Once] ->
              case w2_s8dl of {
                GHC.Base.:| ww4_s8dq [Occ=Once] ww5_s8dr [Occ=Once] ->
                    GHC.Base.$w$c>= w_s8dj ww1_s8dn ww2_s8do ww4_s8dq ww5_s8dr;
              };
        };

GHC.Base.$fOrdNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (GHC.Base.NonEmpty a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_s8ds]
        let {
          sat_s8dC [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Base.NonEmpty a_a4nL
          [LclId] =
              [$dOrd_s8ds] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$cmin $dOrd_s8ds eta_B2 eta_B1; } in
        let {
          sat_s8dB [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Base.NonEmpty a_a4nL
          [LclId] =
              [$dOrd_s8ds] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$cmax $dOrd_s8ds eta_B2 eta_B1; } in
        let {
          sat_s8dA [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8ds] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$c>= $dOrd_s8ds eta_B2 eta_B1; } in
        let {
          sat_s8dz [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8ds] \r [a1_s8dx b_s8dy]
                  GHC.Base.$fOrdNonEmpty_$c< $dOrd_s8ds b_s8dy a1_s8dx; } in
        let {
          sat_s8dw [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8ds] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$c<= $dOrd_s8ds eta_B2 eta_B1; } in
        let {
          sat_s8dv [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s8ds] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$c< $dOrd_s8ds eta_B2 eta_B1; } in
        let {
          sat_s8du [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s8ds] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$ccompare $dOrd_s8ds eta_B2 eta_B1; } in
        let {
          sat_s8dt [Occ=Once] :: GHC.Classes.Eq (GHC.Base.NonEmpty a_a4nL)
          [LclId] =
              [$dOrd_s8ds] \u [] GHC.Base.$fOrdNonEmpty_$cp1Ord $dOrd_s8ds;
        } in 
          GHC.Classes.C:Ord [sat_s8dt
                             sat_s8du
                             sat_s8dv
                             sat_s8dw
                             sat_s8dz
                             sat_s8dA
                             sat_s8dB
                             sat_s8dC];

GHC.Base.$fMonadIO_$cfail
  :: forall a. GHC.Base.String -> GHC.Types.IO a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [s_s8dD] GHC.IO.failIO s_s8dD;

GHC.Base.$fMonadIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicativeIO
                                     GHC.Base.$fMonadIO1
                                     GHC.Base.$fApplicativeIO2
                                     GHC.Base.$fApplicativeIO4
                                     GHC.Base.$fMonadIO_$cfail];

GHC.Base.$fMonad[]_$cfail [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Base.String -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s8dE] [] [];

GHC.Base.$fMonad[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicative[]
                                     GHC.Base.$fMonad[]_$c>>=
                                     GHC.Base.$fApplicative[]_$c*>
                                     GHC.Base.$fApplicative[]_$cpure
                                     GHC.Base.$fMonad[]_$cfail];

GHC.Base.$fMonadPlus[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [GHC.Base.$fAlternative[]
                                         GHC.Base.$fMonad[]
                                         GHC.Types.[]
                                         GHC.Base.++];

GHC.Base.$fMonadMaybe_$c>>=
  :: forall a b.
     GHC.Base.Maybe a -> (a -> GHC.Base.Maybe b) -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_s8dF k_s8dG]
        case ds_s8dF of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s8dI [Occ=Once] -> k_s8dG x_s8dI;
        };

GHC.Base.$fMonadMaybe_$cfail
  :: forall a. GHC.Base.String -> GHC.Base.Maybe a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s8dJ] GHC.Base.Nothing [];

GHC.Base.$fMonad(->)_$c>>=
  :: forall r a b. (r -> a) -> (a -> r -> b) -> r -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s8dK k_s8dL r1_s8dM]
        let {
          sat_s8dN [Occ=Once] :: a_a4tQ
          [LclId] =
              [f_s8dK r1_s8dM] \u [] f_s8dK r1_s8dM;
        } in  k_s8dL sat_s8dN r1_s8dM;

GHC.Base.$fMonad(,)_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a1 -> (a, b)) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><C(S),1*C1(U(U,U))>m,
 Unf=OtherCon []] =
    [] \r [w_s8dO w1_s8dP w2_s8dQ]
        case w1_s8dP of {
          (,) ww1_s8dS [Occ=Once] ww2_s8dT [Occ=Once] ->
              case w2_s8dQ ww2_s8dT of {
                (,) v_s8dV [Occ=Once] b1_s8dW [Occ=Once] ->
                    let {
                      sat_s8dY [Occ=Once] :: a_s6KB
                      [LclId] =
                          [w_s8dO ww1_s8dS v_s8dV] \u []
                              case GHC.Base.$p1Monoid w_s8dO of sat_s8dX {
                                __DEFAULT -> GHC.Base.<> sat_s8dX ww1_s8dS v_s8dV;
                              };
                    } in  (,) [sat_s8dY b1_s8dW];
              };
        };

GHC.Base.$fApplicative(,)_$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1 -> b) -> (a, a1) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,1*C1(U))><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8dZ w1_s8e0 w2_s8e1]
        case w1_s8e0 of {
          (,) ww1_s8e3 [Occ=Once] ww2_s8e4 [Occ=Once!] ->
              case w2_s8e1 of {
                (,) ww4_s8e6 [Occ=Once] ww5_s8e7 [Occ=Once] ->
                    let {
                      sat_s8ea [Occ=Once] :: b_s6KT
                      [LclId] =
                          [ww2_s8e4 ww5_s8e7] \u [] ww2_s8e4 ww5_s8e7; } in
                    let {
                      sat_s8e9 [Occ=Once] :: a_s6KQ
                      [LclId] =
                          [w_s8dZ ww1_s8e3 ww4_s8e6] \u []
                              case GHC.Base.$p1Monoid w_s8dZ of sat_s8e8 {
                                __DEFAULT -> GHC.Base.<> sat_s8e8 ww1_s8e3 ww4_s8e6;
                              };
                    } in  (,) [sat_s8e9 sat_s8ea];
              };
        };

GHC.Base.$fApplicative(,)_$c*>
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,A)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8eb a2_s8ec a3_s8ed]
        case a2_s8ec of {
          (,) x_s8ef [Occ=Once] _ [Occ=Dead] ->
              case a3_s8ed of {
                (,) v_s8ei [Occ=Once] x1_s8ej [Occ=Once] ->
                    let {
                      sat_s8el [Occ=Once] :: a_a4vv
                      [LclId] =
                          [$dMonoid_s8eb x_s8ef v_s8ei] \u []
                              case GHC.Base.$p1Monoid $dMonoid_s8eb of sat_s8ek {
                                __DEFAULT -> GHC.Base.<> sat_s8ek x_s8ef v_s8ei;
                              };
                    } in  (,) [sat_s8el x1_s8ej];
              };
        };

GHC.Base.$fApplicative(,)_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b c. (a1 -> b -> c) -> (a, a1) -> (a, b) -> (a, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8em w1_s8en w2_s8eo w3_s8ep]
        case w2_s8eo of {
          (,) ww1_s8er [Occ=Once] ww2_s8es [Occ=Once] ->
              case w3_s8ep of {
                (,) ww4_s8eu [Occ=Once] ww5_s8ev [Occ=Once] ->
                    let {
                      sat_s8ey [Occ=Once] :: c_s6Le
                      [LclId] =
                          [w1_s8en ww2_s8es ww5_s8ev] \u [] w1_s8en ww2_s8es ww5_s8ev; } in
                    let {
                      sat_s8ex [Occ=Once] :: a_s6La
                      [LclId] =
                          [w_s8em ww1_s8er ww4_s8eu] \u []
                              case GHC.Base.$p1Monoid w_s8em of sat_s8ew {
                                __DEFAULT -> GHC.Base.<> sat_s8ew ww1_s8er ww4_s8eu;
                              };
                    } in  (,) [sat_s8ex sat_s8ey];
              };
        };

GHC.Base.$fMonoid(,,,,)_$cmempty
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8ez
           $dMonoid1_s8eA
           $dMonoid2_s8eB
           $dMonoid3_s8eC
           $dMonoid4_s8eD]
        let {
          sat_s8eI [Occ=Once] :: e_a4x9
          [LclId] =
              [$dMonoid4_s8eD] \u [] GHC.Base.mempty $dMonoid4_s8eD; } in
        let {
          sat_s8eH [Occ=Once] :: d_a4x8
          [LclId] =
              [$dMonoid3_s8eC] \u [] GHC.Base.mempty $dMonoid3_s8eC; } in
        let {
          sat_s8eG [Occ=Once] :: c_a4x7
          [LclId] =
              [$dMonoid2_s8eB] \u [] GHC.Base.mempty $dMonoid2_s8eB; } in
        let {
          sat_s8eF [Occ=Once] :: b_a4x6
          [LclId] =
              [$dMonoid1_s8eA] \u [] GHC.Base.mempty $dMonoid1_s8eA; } in
        let {
          sat_s8eE [Occ=Once] :: a_a4x5
          [LclId] =
              [$dMonoid_s8ez] \u [] GHC.Base.mempty $dMonoid_s8ez;
        } in  (,,,,) [sat_s8eE sat_s8eF sat_s8eG sat_s8eH sat_s8eI];

GHC.Base.$fMonoid(,,,)_$cmempty
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8eJ $dMonoid1_s8eK $dMonoid2_s8eL $dMonoid3_s8eM]
        let {
          sat_s8eQ [Occ=Once] :: d_a4xM
          [LclId] =
              [$dMonoid3_s8eM] \u [] GHC.Base.mempty $dMonoid3_s8eM; } in
        let {
          sat_s8eP [Occ=Once] :: c_a4xL
          [LclId] =
              [$dMonoid2_s8eL] \u [] GHC.Base.mempty $dMonoid2_s8eL; } in
        let {
          sat_s8eO [Occ=Once] :: b_a4xK
          [LclId] =
              [$dMonoid1_s8eK] \u [] GHC.Base.mempty $dMonoid1_s8eK; } in
        let {
          sat_s8eN [Occ=Once] :: a_a4xJ
          [LclId] =
              [$dMonoid_s8eJ] \u [] GHC.Base.mempty $dMonoid_s8eJ;
        } in  (,,,) [sat_s8eN sat_s8eO sat_s8eP sat_s8eQ];

GHC.Base.$fMonoid(,,)_$cmempty
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     (a, b, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8eR $dMonoid1_s8eS $dMonoid2_s8eT]
        let {
          sat_s8eW [Occ=Once] :: c_a4yl
          [LclId] =
              [$dMonoid2_s8eT] \u [] GHC.Base.mempty $dMonoid2_s8eT; } in
        let {
          sat_s8eV [Occ=Once] :: b_a4yk
          [LclId] =
              [$dMonoid1_s8eS] \u [] GHC.Base.mempty $dMonoid1_s8eS; } in
        let {
          sat_s8eU [Occ=Once] :: a_a4yj
          [LclId] =
              [$dMonoid_s8eR] \u [] GHC.Base.mempty $dMonoid_s8eR;
        } in  (,,) [sat_s8eU sat_s8eV sat_s8eW];

GHC.Base.$fMonoid(,)_$cmempty
  :: forall a b. (GHC.Base.Monoid a, GHC.Base.Monoid b) => (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8eX $dMonoid1_s8eY]
        let {
          sat_s8f0 [Occ=Once] :: b_a4yQ
          [LclId] =
              [$dMonoid1_s8eY] \u [] GHC.Base.mempty $dMonoid1_s8eY; } in
        let {
          sat_s8eZ [Occ=Once] :: a_a4yP
          [LclId] =
              [$dMonoid_s8eX] \u [] GHC.Base.mempty $dMonoid_s8eX;
        } in  (,) [sat_s8eZ sat_s8f0];

GHC.Base.$fMonoid(,)_$cmconcat
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     [(a, b)] -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8f1 $dMonoid1_s8f2 eta_s8f3]
        let {
          $dSemigroup_s8f4 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_a4yP
          [LclId] =
              [$dMonoid_s8f1] \u [] GHC.Base.$p1Monoid $dMonoid_s8f1; } in
        let {
          $dSemigroup1_s8f5 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_a4yQ
          [LclId] =
              [$dMonoid1_s8f2] \u [] GHC.Base.$p1Monoid $dMonoid1_s8f2; } in
        let {
          z_s8f6 [Occ=OnceL] :: a_a4yP
          [LclId] =
              [$dMonoid_s8f1] \u [] GHC.Base.mempty $dMonoid_s8f1; } in
        let {
          z1_s8f7 [Occ=OnceL] :: b_a4yQ
          [LclId] =
              [$dMonoid1_s8f2] \u [] GHC.Base.mempty $dMonoid1_s8f2; } in
        let {
          z2_s8f8 [Occ=OnceL, Dmd=<S,U(U,U)>] :: (a_a4yP, b_a4yQ)
          [LclId, Unf=OtherCon []] =
              CCCS (,)! [z_s8f6 z1_s8f7]; } in
        let {
          go_s8f9 [Occ=LoopBreaker] :: [(a_a4yP, b_a4yQ)] -> (a_a4yP, b_a4yQ)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_s8f4
                        $dSemigroup1_s8f5
                        z2_s8f8
                        go_s8f9] \r [ds_s8fa]
                  case ds_s8fa of {
                    [] -> z2_s8f8;
                    : y_s8fc [Occ=Once!] ys_s8fd [Occ=Once] ->
                        case y_s8fc of {
                          (,) a1_s8ff [Occ=Once] b1_s8fg [Occ=Once] ->
                              case go_s8f9 ys_s8fd of {
                                (,) a'_s8fi [Occ=Once] b'_s8fj [Occ=Once] ->
                                    let {
                                      sat_s8fl [Occ=Once] :: b_a4yQ
                                      [LclId] =
                                          [$dSemigroup1_s8f5 b1_s8fg b'_s8fj] \u []
                                              GHC.Base.<> $dSemigroup1_s8f5 b1_s8fg b'_s8fj; } in
                                    let {
                                      sat_s8fk [Occ=Once] :: a_a4yP
                                      [LclId] =
                                          [$dSemigroup_s8f4 a1_s8ff a'_s8fi] \u []
                                              GHC.Base.<> $dSemigroup_s8f4 a1_s8ff a'_s8fi;
                                    } in  (,) [sat_s8fk sat_s8fl];
                              };
                        };
                  };
        } in  go_s8f9 eta_s8f3;

GHC.Base.$fMonoid()_$cmconcat :: [()] -> ()
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s8fm] () [];

GHC.Base.$fMonoidMaybe_$c<>
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8fn ds_s8fo b_s8fp]
        case ds_s8fo of wild_s8fq {
          GHC.Base.Nothing -> b_s8fp;
          GHC.Base.Just ipv_s8fr [Occ=Once] ->
              case b_s8fp of {
                GHC.Base.Nothing -> wild_s8fq;
                GHC.Base.Just ipv1_s8ft [Occ=Once] ->
                    let {
                      sat_s8fu [Occ=Once] :: a_a4AP
                      [LclId] =
                          [$dSemigroup_s8fn ipv_s8fr ipv1_s8ft] \u []
                              GHC.Base.<> $dSemigroup_s8fn ipv_s8fr ipv1_s8ft;
                    } in  GHC.Base.Just [sat_s8fu];
              };
        };

GHC.Base.$w$csconcat5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Maybe a -> [GHC.Base.Maybe a] -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8fv ww_s8fw ww1_s8fx]
        let {
          go_s8fy [Occ=LoopBreaker]
            :: GHC.Base.Maybe a_s6LE
               -> [GHC.Base.Maybe a_s6LE] -> GHC.Base.Maybe a_s6LE
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s8fv go_s8fy] \r [b_s8fz ds_s8fA]
                  case ds_s8fA of {
                    [] -> b_s8fz;
                    : c_s8fC [Occ=Once*] cs_s8fD [Occ=Once*] ->
                        case b_s8fz of wild1_s8fE {
                          GHC.Base.Nothing -> go_s8fy c_s8fC cs_s8fD;
                          GHC.Base.Just ipv_s8fF [Occ=Once] ->
                              case go_s8fy c_s8fC cs_s8fD of {
                                GHC.Base.Nothing -> wild1_s8fE;
                                GHC.Base.Just ipv1_s8fH [Occ=Once] ->
                                    let {
                                      sat_s8fI [Occ=Once] :: a_s6LE
                                      [LclId] =
                                          [w_s8fv ipv_s8fF ipv1_s8fH] \u []
                                              GHC.Base.<> w_s8fv ipv_s8fF ipv1_s8fH;
                                    } in  GHC.Base.Just [sat_s8fI];
                              };
                        };
                  };
        } in  go_s8fy ww_s8fw ww1_s8fx;

GHC.Base.$fSemigroupMaybe_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (GHC.Base.Maybe a) -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s8fJ w1_s8fK]
        case w1_s8fK of {
          GHC.Base.:| ww1_s8fM [Occ=Once] ww2_s8fN [Occ=Once] ->
              GHC.Base.$w$csconcat5 w_s8fJ ww1_s8fM ww2_s8fN;
        };

GHC.Base.$fSemigroupMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (GHC.Base.Maybe a)
[GblId[DFunId], Arity=1, Str=<L,U(U,U,U)>m] =
    [] \r [$dSemigroup_s8fO]
        let {
          sat_s8fS [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> GHC.Base.Maybe a_a4AP -> GHC.Base.Maybe a_a4AP
          [LclId] =
              [$dSemigroup_s8fO] \r [$dIntegral_s8fR]
                  Data.Semigroup.Internal.stimesMaybe
                      $dIntegral_s8fR $dSemigroup_s8fO; } in
        let {
          sat_s8fQ [Occ=Once]
            :: GHC.Base.NonEmpty (GHC.Base.Maybe a_a4AP)
               -> GHC.Base.Maybe a_a4AP
          [LclId] =
              [$dSemigroup_s8fO] \r [eta_B1]
                  GHC.Base.$fSemigroupMaybe_$csconcat $dSemigroup_s8fO eta_B1; } in
        let {
          sat_s8fP [Occ=Once]
            :: GHC.Base.Maybe a_a4AP
               -> GHC.Base.Maybe a_a4AP -> GHC.Base.Maybe a_a4AP
          [LclId] =
              [$dSemigroup_s8fO] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_s8fO eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s8fP sat_s8fQ sat_s8fS];

GHC.Base.$fMonoidMaybe_$cmconcat
  :: forall a.
     GHC.Base.Semigroup a =>
     [GHC.Base.Maybe a] -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8fT eta_s8fU]
        let {
          go_s8fV [Occ=LoopBreaker]
            :: [GHC.Base.Maybe a_a4wo] -> GHC.Base.Maybe a_a4wo
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_s8fT go_s8fV] \r [ds_s8fW]
                  case ds_s8fW of {
                    [] -> GHC.Base.Nothing [];
                    : y_s8fY [Occ=Once!] ys_s8fZ [Occ=Once*] ->
                        case y_s8fY of wild1_s8g0 {
                          GHC.Base.Nothing -> go_s8fV ys_s8fZ;
                          GHC.Base.Just ipv_s8g1 [Occ=Once] ->
                              case go_s8fV ys_s8fZ of {
                                GHC.Base.Nothing -> wild1_s8g0;
                                GHC.Base.Just ipv1_s8g3 [Occ=Once] ->
                                    let {
                                      sat_s8g4 [Occ=Once] :: a_a4wo
                                      [LclId] =
                                          [$dSemigroup_s8fT ipv_s8g1 ipv1_s8g3] \u []
                                              GHC.Base.<> $dSemigroup_s8fT ipv_s8g1 ipv1_s8g3;
                                    } in  GHC.Base.Just [sat_s8g4];
                              };
                        };
                  };
        } in  go_s8fV eta_s8fU;

GHC.Base.$fMonoidMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Monoid (GHC.Base.Maybe a)
[GblId[DFunId], Arity=1, Str=<L,U(U,U,U)>m] =
    [] \r [$dSemigroup_s8g5]
        let {
          sat_s8g8 [Occ=Once]
            :: [GHC.Base.Maybe a_a4wo] -> GHC.Base.Maybe a_a4wo
          [LclId] =
              [$dSemigroup_s8g5] \r [eta_B1]
                  GHC.Base.$fMonoidMaybe_$cmconcat $dSemigroup_s8g5 eta_B1; } in
        let {
          sat_s8g7 [Occ=Once]
            :: GHC.Base.Maybe a_a4wo
               -> GHC.Base.Maybe a_a4wo -> GHC.Base.Maybe a_a4wo
          [LclId] =
              [$dSemigroup_s8g5] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_s8g5 eta_B2 eta_B1; } in
        let {
          sat_s8g6 [Occ=Once] :: GHC.Base.Semigroup (GHC.Base.Maybe a_a4wo)
          [LclId] =
              [$dSemigroup_s8g5] \u []
                  GHC.Base.$fSemigroupMaybe $dSemigroup_s8g5;
        } in 
          GHC.Base.C:Monoid [sat_s8g6 GHC.Base.Nothing sat_s8g7 sat_s8g8];

GHC.Base.$fMonoidOrdering_$c<>
  :: GHC.Types.Ordering -> GHC.Types.Ordering -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s8g9 ds1_s8ga]
        case ds_s8g9 of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ -> ds1_s8ga;
          GHC.Types.GT -> GHC.Types.GT [];
        };

GHC.Base.$fMonoidOrdering_go [Occ=LoopBreaker]
  :: [GHC.Types.Ordering] -> GHC.Types.Ordering
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s8gc]
        case ds_s8gc of {
          [] -> GHC.Types.EQ [];
          : y_s8ge [Occ=Once!] ys_s8gf [Occ=Once] ->
              case y_s8ge of {
                GHC.Types.LT -> GHC.Types.LT [];
                GHC.Types.EQ -> GHC.Base.$fMonoidOrdering_go ys_s8gf;
                GHC.Types.GT -> GHC.Types.GT [];
              };
        };

GHC.Base.$fSemigroupOrdering [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup GHC.Types.Ordering
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.$fMonoidOrdering_$c<>
                                         GHC.Base.$fSemigroupOrdering_$csconcat
                                         GHC.Base.$fSemigroupOrdering_$cstimes];
GHC.Base.$fMonoidOrdering [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid GHC.Types.Ordering
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [GHC.Base.$fSemigroupOrdering
                                      GHC.Types.EQ
                                      GHC.Base.$fMonoidOrdering_$c<>
                                      GHC.Base.$fMonoidOrdering_go];
GHC.Base.$fSemigroupOrdering_$cstimes [Occ=LoopBreaker]
  :: forall b.
     GHC.Real.Integral b =>
     b -> GHC.Types.Ordering -> GHC.Types.Ordering
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_s8gh]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s8gh GHC.Base.$fMonoidOrdering;

GHC.Base.$fMonoid(,,,,)_$c<>
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U,U,U)><S,1*U(U,U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8gi
           $dSemigroup1_s8gj
           $dSemigroup2_s8gk
           $dSemigroup3_s8gl
           $dSemigroup4_s8gm
           ds_s8gn
           ds1_s8go]
        case ds_s8gn of {
          (,,,,) a1_s8gq [Occ=Once]
                 b1_s8gr [Occ=Once]
                 c1_s8gs [Occ=Once]
                 d1_s8gt [Occ=Once]
                 e1_s8gu [Occ=Once] ->
              case ds1_s8go of {
                (,,,,) a'_s8gw [Occ=Once]
                       b'_s8gx [Occ=Once]
                       c'_s8gy [Occ=Once]
                       d'_s8gz [Occ=Once]
                       e'_s8gA [Occ=Once] ->
                    let {
                      sat_s8gF [Occ=Once] :: e_a4BK
                      [LclId] =
                          [$dSemigroup4_s8gm e1_s8gu e'_s8gA] \u []
                              GHC.Base.<> $dSemigroup4_s8gm e1_s8gu e'_s8gA; } in
                    let {
                      sat_s8gE [Occ=Once] :: d_a4BJ
                      [LclId] =
                          [$dSemigroup3_s8gl d1_s8gt d'_s8gz] \u []
                              GHC.Base.<> $dSemigroup3_s8gl d1_s8gt d'_s8gz; } in
                    let {
                      sat_s8gD [Occ=Once] :: c_a4BI
                      [LclId] =
                          [$dSemigroup2_s8gk c1_s8gs c'_s8gy] \u []
                              GHC.Base.<> $dSemigroup2_s8gk c1_s8gs c'_s8gy; } in
                    let {
                      sat_s8gC [Occ=Once] :: b_a4BH
                      [LclId] =
                          [$dSemigroup1_s8gj b1_s8gr b'_s8gx] \u []
                              GHC.Base.<> $dSemigroup1_s8gj b1_s8gr b'_s8gx; } in
                    let {
                      sat_s8gB [Occ=Once] :: a_a4BG
                      [LclId] =
                          [$dSemigroup_s8gi a1_s8gq a'_s8gw] \u []
                              GHC.Base.<> $dSemigroup_s8gi a1_s8gq a'_s8gw;
                    } in  (,,,,) [sat_s8gB sat_s8gC sat_s8gD sat_s8gE sat_s8gF];
              };
        };

GHC.Base.$fMonoid(,,,,)_$csconcat
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     GHC.Base.NonEmpty (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U,U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8gG
           $dSemigroup1_s8gH
           $dSemigroup2_s8gI
           $dSemigroup3_s8gJ
           $dSemigroup4_s8gK
           ds_s8gL]
        case ds_s8gL of {
          GHC.Base.:| a1_s8gN [Occ=Once!] as_s8gO [Occ=Once] ->
              case a1_s8gN of {
                (,,,,) ww1_s8gQ [Occ=Once]
                       ww2_s8gR [Occ=Once]
                       ww3_s8gS [Occ=Once]
                       ww4_s8gT [Occ=Once]
                       ww5_s8gU [Occ=Once] ->
                    let {
                      $wgo_s8gV [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                        :: a_a4BG
                           -> b_a4BH
                           -> c_a4BI
                           -> d_a4BJ
                           -> e_a4BK
                           -> [(a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)]
                           -> (# a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK #)
                      [LclId,
                       Arity=6,
                       Str=<L,U><L,U><L,U><L,U><L,U><S,1*U>,
                       Unf=OtherCon []] =
                          sat-only [$dSemigroup_s8gG
                                    $dSemigroup1_s8gH
                                    $dSemigroup2_s8gI
                                    $dSemigroup3_s8gJ
                                    $dSemigroup4_s8gK
                                    $wgo_s8gV] \r [ww6_s8gW
                                                   ww7_s8gX
                                                   ww8_s8gY
                                                   ww9_s8gZ
                                                   ww10_s8h0
                                                   w_s8h1]
                              case w_s8h1 of {
                                [] -> (#,,,,#) [ww6_s8gW ww7_s8gX ww8_s8gY ww9_s8gZ ww10_s8h0];
                                : c1_s8h3 [Occ=Once!] cs_s8h4 [Occ=Once] ->
                                    case c1_s8h3 of {
                                      (,,,,) ww12_s8h6 [Occ=Once]
                                             ww13_s8h7 [Occ=Once]
                                             ww14_s8h8 [Occ=Once]
                                             ww15_s8h9 [Occ=Once]
                                             ww16_s8ha [Occ=Once] ->
                                          case
                                              $wgo_s8gV
                                                  ww12_s8h6
                                                  ww13_s8h7
                                                  ww14_s8h8
                                                  ww15_s8h9
                                                  ww16_s8ha
                                                  cs_s8h4
                                          of
                                          { (#,,,,#) ww18_s8hc [Occ=Once]
                                                     ww19_s8hd [Occ=Once]
                                                     ww20_s8he [Occ=Once]
                                                     ww21_s8hf [Occ=Once]
                                                     ww22_s8hg [Occ=Once] ->
                                                let {
                                                  sat_s8hl [Occ=Once] :: e_a4BK
                                                  [LclId] =
                                                      [$dSemigroup4_s8gK ww10_s8h0 ww22_s8hg] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup4_s8gK
                                                              ww10_s8h0
                                                              ww22_s8hg; } in
                                                let {
                                                  sat_s8hk [Occ=Once] :: d_a4BJ
                                                  [LclId] =
                                                      [$dSemigroup3_s8gJ ww9_s8gZ ww21_s8hf] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup3_s8gJ
                                                              ww9_s8gZ
                                                              ww21_s8hf; } in
                                                let {
                                                  sat_s8hj [Occ=Once] :: c_a4BI
                                                  [LclId] =
                                                      [$dSemigroup2_s8gI ww8_s8gY ww20_s8he] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup2_s8gI
                                                              ww8_s8gY
                                                              ww20_s8he; } in
                                                let {
                                                  sat_s8hi [Occ=Once] :: b_a4BH
                                                  [LclId] =
                                                      [$dSemigroup1_s8gH ww7_s8gX ww19_s8hd] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup1_s8gH
                                                              ww7_s8gX
                                                              ww19_s8hd; } in
                                                let {
                                                  sat_s8hh [Occ=Once] :: a_a4BG
                                                  [LclId] =
                                                      [$dSemigroup_s8gG ww6_s8gW ww18_s8hc] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup_s8gG ww6_s8gW ww18_s8hc;
                                                } in 
                                                  (#,,,,#) [sat_s8hh
                                                            sat_s8hi
                                                            sat_s8hj
                                                            sat_s8hk
                                                            sat_s8hl];
                                          };
                                    };
                              };
                    } in 
                      case
                          $wgo_s8gV ww1_s8gQ ww2_s8gR ww3_s8gS ww4_s8gT ww5_s8gU as_s8gO
                      of
                      { (#,,,,#) ww7_s8hn [Occ=Once]
                                 ww8_s8ho [Occ=Once]
                                 ww9_s8hp [Occ=Once]
                                 ww10_s8hq [Occ=Once]
                                 ww11_s8hr [Occ=Once] ->
                            (,,,,) [ww7_s8hn ww8_s8ho ww9_s8hp ww10_s8hq ww11_s8hr];
                      };
              };
        };

GHC.Base.$fMonoid(,,,,)_$cstimes
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     forall b1.
     GHC.Real.Integral b1 =>
     b1 -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8hs
           $dSemigroup1_s8ht
           $dSemigroup2_s8hu
           $dSemigroup3_s8hv
           $dSemigroup4_s8hw
           $dIntegral_s8hx
           n_s8hy
           ds_s8hz]
        case ds_s8hz of {
          (,,,,) a1_s8hB [Occ=Once]
                 b2_s8hC [Occ=Once]
                 c1_s8hD [Occ=Once]
                 d1_s8hE [Occ=Once]
                 e1_s8hF [Occ=Once] ->
              let {
                sat_s8hK [Occ=Once] :: e_a4BK
                [LclId] =
                    [$dSemigroup4_s8hw $dIntegral_s8hx n_s8hy e1_s8hF] \u []
                        GHC.Base.stimes
                            $dSemigroup4_s8hw $dIntegral_s8hx n_s8hy e1_s8hF; } in
              let {
                sat_s8hJ [Occ=Once] :: d_a4BJ
                [LclId] =
                    [$dSemigroup3_s8hv $dIntegral_s8hx n_s8hy d1_s8hE] \u []
                        GHC.Base.stimes
                            $dSemigroup3_s8hv $dIntegral_s8hx n_s8hy d1_s8hE; } in
              let {
                sat_s8hI [Occ=Once] :: c_a4BI
                [LclId] =
                    [$dSemigroup2_s8hu $dIntegral_s8hx n_s8hy c1_s8hD] \u []
                        GHC.Base.stimes
                            $dSemigroup2_s8hu $dIntegral_s8hx n_s8hy c1_s8hD; } in
              let {
                sat_s8hH [Occ=Once] :: b_a4BH
                [LclId] =
                    [$dSemigroup1_s8ht $dIntegral_s8hx n_s8hy b2_s8hC] \u []
                        GHC.Base.stimes
                            $dSemigroup1_s8ht $dIntegral_s8hx n_s8hy b2_s8hC; } in
              let {
                sat_s8hG [Occ=Once] :: a_a4BG
                [LclId] =
                    [$dSemigroup_s8hs $dIntegral_s8hx n_s8hy a1_s8hB] \u []
                        GHC.Base.stimes $dSemigroup_s8hs $dIntegral_s8hx n_s8hy a1_s8hB;
              } in  (,,,,) [sat_s8hG sat_s8hH sat_s8hI sat_s8hJ sat_s8hK];
        };

GHC.Base.$fSemigroup(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     GHC.Base.Semigroup (a, b, c, d, e)
[GblId[DFunId],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s8hL
           $dSemigroup1_s8hM
           $dSemigroup2_s8hN
           $dSemigroup3_s8hO
           $dSemigroup4_s8hP]
        let {
          sat_s8hS [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
          [LclId] =
              [$dSemigroup_s8hL
               $dSemigroup1_s8hM
               $dSemigroup2_s8hN
               $dSemigroup3_s8hO
               $dSemigroup4_s8hP] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$cstimes
                      $dSemigroup_s8hL
                      $dSemigroup1_s8hM
                      $dSemigroup2_s8hN
                      $dSemigroup3_s8hO
                      $dSemigroup4_s8hP
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_s8hR [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
          [LclId] =
              [$dSemigroup_s8hL
               $dSemigroup1_s8hM
               $dSemigroup2_s8hN
               $dSemigroup3_s8hO
               $dSemigroup4_s8hP] \r [eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$csconcat
                      $dSemigroup_s8hL
                      $dSemigroup1_s8hM
                      $dSemigroup2_s8hN
                      $dSemigroup3_s8hO
                      $dSemigroup4_s8hP
                      eta_B1; } in
        let {
          sat_s8hQ [Occ=Once]
            :: (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
          [LclId] =
              [$dSemigroup_s8hL
               $dSemigroup1_s8hM
               $dSemigroup2_s8hN
               $dSemigroup3_s8hO
               $dSemigroup4_s8hP] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$c<>
                      $dSemigroup_s8hL
                      $dSemigroup1_s8hM
                      $dSemigroup2_s8hN
                      $dSemigroup3_s8hO
                      $dSemigroup4_s8hP
                      eta_B2
                      eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s8hQ sat_s8hR sat_s8hS];

GHC.Base.$w$cp1Monoid1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     (# (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e),
        GHC.Base.NonEmpty (a, b, c, d, e) -> (a, b, c, d, e),
        forall b1.
        GHC.Real.Integral b1 =>
        b1 -> (a, b, c, d, e) -> (a, b, c, d, e) #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [w_s8hT w1_s8hU w2_s8hV w3_s8hW w4_s8hX]
        let {
          sat_s8ie [Occ=OnceL] :: GHC.Base.Semigroup e_s6Nx
          [LclId] =
              [w4_s8hX] \u [] GHC.Base.$p1Monoid w4_s8hX; } in
        let {
          sat_s8id [Occ=OnceL] :: GHC.Base.Semigroup d_s6Nw
          [LclId] =
              [w3_s8hW] \u [] GHC.Base.$p1Monoid w3_s8hW; } in
        let {
          sat_s8ic [Occ=OnceL] :: GHC.Base.Semigroup c_s6Nv
          [LclId] =
              [w2_s8hV] \u [] GHC.Base.$p1Monoid w2_s8hV; } in
        let {
          sat_s8ib [Occ=OnceL] :: GHC.Base.Semigroup b_s6Nu
          [LclId] =
              [w1_s8hU] \u [] GHC.Base.$p1Monoid w1_s8hU; } in
        let {
          sat_s8ia [Occ=OnceL] :: GHC.Base.Semigroup a_s6Nt
          [LclId] =
              [w_s8hT] \u [] GHC.Base.$p1Monoid w_s8hT; } in
        let {
          sat_s8if [Occ=Once]
            :: forall b1.
               GHC.Real.Integral b1 =>
               b1
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
          [LclId] =
              [sat_s8ia sat_s8ib sat_s8ic sat_s8id sat_s8ie] \r [eta_B3
                                                                 eta_B2
                                                                 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$cstimes
                      sat_s8ia
                      sat_s8ib
                      sat_s8ic
                      sat_s8id
                      sat_s8ie
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_s8i8 [Occ=OnceL] :: GHC.Base.Semigroup e_s6Nx
          [LclId] =
              [w4_s8hX] \u [] GHC.Base.$p1Monoid w4_s8hX; } in
        let {
          sat_s8i7 [Occ=OnceL] :: GHC.Base.Semigroup d_s6Nw
          [LclId] =
              [w3_s8hW] \u [] GHC.Base.$p1Monoid w3_s8hW; } in
        let {
          sat_s8i6 [Occ=OnceL] :: GHC.Base.Semigroup c_s6Nv
          [LclId] =
              [w2_s8hV] \u [] GHC.Base.$p1Monoid w2_s8hV; } in
        let {
          sat_s8i5 [Occ=OnceL] :: GHC.Base.Semigroup b_s6Nu
          [LclId] =
              [w1_s8hU] \u [] GHC.Base.$p1Monoid w1_s8hU; } in
        let {
          sat_s8i4 [Occ=OnceL] :: GHC.Base.Semigroup a_s6Nt
          [LclId] =
              [w_s8hT] \u [] GHC.Base.$p1Monoid w_s8hT; } in
        let {
          sat_s8i9 [Occ=Once]
            :: GHC.Base.NonEmpty (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
          [LclId] =
              [sat_s8i4 sat_s8i5 sat_s8i6 sat_s8i7 sat_s8i8] \r [eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$csconcat
                      sat_s8i4 sat_s8i5 sat_s8i6 sat_s8i7 sat_s8i8 eta_B1; } in
        let {
          sat_s8i2 [Occ=OnceL] :: GHC.Base.Semigroup e_s6Nx
          [LclId] =
              [w4_s8hX] \u [] GHC.Base.$p1Monoid w4_s8hX; } in
        let {
          sat_s8i1 [Occ=OnceL] :: GHC.Base.Semigroup d_s6Nw
          [LclId] =
              [w3_s8hW] \u [] GHC.Base.$p1Monoid w3_s8hW; } in
        let {
          sat_s8i0 [Occ=OnceL] :: GHC.Base.Semigroup c_s6Nv
          [LclId] =
              [w2_s8hV] \u [] GHC.Base.$p1Monoid w2_s8hV; } in
        let {
          sat_s8hZ [Occ=OnceL] :: GHC.Base.Semigroup b_s6Nu
          [LclId] =
              [w1_s8hU] \u [] GHC.Base.$p1Monoid w1_s8hU; } in
        let {
          sat_s8hY [Occ=OnceL] :: GHC.Base.Semigroup a_s6Nt
          [LclId] =
              [w_s8hT] \u [] GHC.Base.$p1Monoid w_s8hT; } in
        let {
          sat_s8i3 [Occ=Once]
            :: (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
          [LclId] =
              [sat_s8hY sat_s8hZ sat_s8i0 sat_s8i1 sat_s8i2] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$c<>
                      sat_s8hY sat_s8hZ sat_s8i0 sat_s8i1 sat_s8i2 eta_B2 eta_B1;
        } in  (#,,#) [sat_s8i3 sat_s8i9 sat_s8if];

GHC.Base.$fMonoid(,,,,)_$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     GHC.Base.Semigroup (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [w_s8ig w1_s8ih w2_s8ii w3_s8ij w4_s8ik]
        case
            GHC.Base.$w$cp1Monoid1 w_s8ig w1_s8ih w2_s8ii w3_s8ij w4_s8ik
        of
        { (#,,#) ww1_s8im [Occ=Once]
                 ww2_s8in [Occ=Once]
                 ww3_s8io [Occ=Once] ->
              GHC.Base.C:Semigroup [ww1_s8im ww2_s8in ww3_s8io];
        };

GHC.Base.$fMonoid(,,,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8ip
           $dMonoid1_s8iq
           $dMonoid2_s8ir
           $dMonoid3_s8is
           $dMonoid4_s8it]
        case
            GHC.Base.$w$cp1Monoid1
                $dMonoid_s8ip
                $dMonoid1_s8iq
                $dMonoid2_s8ir
                $dMonoid3_s8is
                $dMonoid4_s8it
        of
        { (#,,#) ww1_s8iv [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> ww1_s8iv;
        };

GHC.Base.$fMonoid(,,,,)_$cmconcat
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     [(a, b, c, d, e)] -> (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8iy
           $dMonoid1_s8iz
           $dMonoid2_s8iA
           $dMonoid3_s8iB
           $dMonoid4_s8iC]
        let {
          k_s8iD [Occ=OnceL, Dmd=<L,1*U(1*C(C1(U(U,U,U,U,U))),A,A)>]
            :: GHC.Base.Semigroup (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_s8iy
               $dMonoid1_s8iz
               $dMonoid2_s8iA
               $dMonoid3_s8iB
               $dMonoid4_s8iC] \s []
                  case
                      GHC.Base.$w$cp1Monoid1
                          $dMonoid_s8iy
                          $dMonoid1_s8iz
                          $dMonoid2_s8iA
                          $dMonoid3_s8iB
                          $dMonoid4_s8iC
                  of
                  { (#,,#) ww1_s8iF [Occ=Once]
                           ww2_s8iG [Occ=Once]
                           ww3_s8iH [Occ=Once] ->
                        GHC.Base.C:Semigroup [ww1_s8iF ww2_s8iG ww3_s8iH];
                  }; } in
        let {
          k1_s8iI [Occ=OnceL!, Dmd=<L,C(C1(U(U,U,U,U,U)))>]
            :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [k_s8iD] \u [] GHC.Base.<> k_s8iD; } in
        let {
          z_s8iJ [Occ=OnceL] :: a_a4x5
          [LclId] =
              [$dMonoid_s8iy] \u [] GHC.Base.mempty $dMonoid_s8iy; } in
        let {
          z1_s8iK [Occ=OnceL] :: b_a4x6
          [LclId] =
              [$dMonoid1_s8iz] \u [] GHC.Base.mempty $dMonoid1_s8iz; } in
        let {
          z2_s8iL [Occ=OnceL] :: c_a4x7
          [LclId] =
              [$dMonoid2_s8iA] \u [] GHC.Base.mempty $dMonoid2_s8iA; } in
        let {
          z3_s8iM [Occ=OnceL] :: d_a4x8
          [LclId] =
              [$dMonoid3_s8iB] \u [] GHC.Base.mempty $dMonoid3_s8iB; } in
        let {
          z4_s8iN [Occ=OnceL] :: e_a4x9
          [LclId] =
              [$dMonoid4_s8iC] \u [] GHC.Base.mempty $dMonoid4_s8iC; } in
        let {
          z5_s8iO [Occ=OnceL, Dmd=<L,U(U,U,U,U,U)>]
            :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId, Unf=OtherCon []] =
              CCCS (,,,,)! [z_s8iJ z1_s8iK z2_s8iL z3_s8iM z4_s8iN]; } in
        let {
          go_s8iP [Occ=LoopBreaker]
            :: [(a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)]
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [k1_s8iI z5_s8iO go_s8iP] \r [ds_s8iQ]
                  case ds_s8iQ of {
                    [] -> z5_s8iO;
                    : y_s8iS [Occ=Once] ys_s8iT [Occ=Once] ->
                        let {
                          sat_s8iU [Occ=Once] :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
                          [LclId] =
                              [go_s8iP ys_s8iT] \u [] go_s8iP ys_s8iT;
                        } in  k1_s8iI y_s8iS sat_s8iU;
                  };
        } in  go_s8iP;

GHC.Base.$fMonoid(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     GHC.Base.Monoid (a, b, c, d, e)
[GblId[DFunId],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s8iV
           $dMonoid1_s8iW
           $dMonoid2_s8iX
           $dMonoid3_s8iY
           $dMonoid4_s8iZ]
        let {
          sat_s8j3 [Occ=Once]
            :: [(a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)]
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_s8iV
               $dMonoid1_s8iW
               $dMonoid2_s8iX
               $dMonoid3_s8iY
               $dMonoid4_s8iZ] \u []
                  GHC.Base.$fMonoid(,,,,)_$cmconcat
                      $dMonoid_s8iV
                      $dMonoid1_s8iW
                      $dMonoid2_s8iX
                      $dMonoid3_s8iY
                      $dMonoid4_s8iZ; } in
        let {
          sat_s8j2 [Occ=Once]
            :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_s8iV
               $dMonoid1_s8iW
               $dMonoid2_s8iX
               $dMonoid3_s8iY
               $dMonoid4_s8iZ] \u []
                  GHC.Base.$fMonoid(,,,,)_$cmappend
                      $dMonoid_s8iV
                      $dMonoid1_s8iW
                      $dMonoid2_s8iX
                      $dMonoid3_s8iY
                      $dMonoid4_s8iZ; } in
        let {
          sat_s8j1 [Occ=Once] :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_s8iV
               $dMonoid1_s8iW
               $dMonoid2_s8iX
               $dMonoid3_s8iY
               $dMonoid4_s8iZ] \u []
                  GHC.Base.$fMonoid(,,,,)_$cmempty
                      $dMonoid_s8iV
                      $dMonoid1_s8iW
                      $dMonoid2_s8iX
                      $dMonoid3_s8iY
                      $dMonoid4_s8iZ; } in
        let {
          sat_s8j0 [Occ=Once]
            :: GHC.Base.Semigroup (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_s8iV
               $dMonoid1_s8iW
               $dMonoid2_s8iX
               $dMonoid3_s8iY
               $dMonoid4_s8iZ] \u []
                  GHC.Base.$fMonoid(,,,,)_$cp1Monoid
                      $dMonoid_s8iV
                      $dMonoid1_s8iW
                      $dMonoid2_s8iX
                      $dMonoid3_s8iY
                      $dMonoid4_s8iZ;
        } in  GHC.Base.C:Monoid [sat_s8j0 sat_s8j1 sat_s8j2 sat_s8j3];

GHC.Base.$fMonoid(,,,)_$c<>
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U,U)><S,1*U(U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8j4
           $dSemigroup1_s8j5
           $dSemigroup2_s8j6
           $dSemigroup3_s8j7
           ds_s8j8
           ds1_s8j9]
        case ds_s8j8 of {
          (,,,) a1_s8jb [Occ=Once]
                b1_s8jc [Occ=Once]
                c1_s8jd [Occ=Once]
                d1_s8je [Occ=Once] ->
              case ds1_s8j9 of {
                (,,,) a'_s8jg [Occ=Once]
                      b'_s8jh [Occ=Once]
                      c'_s8ji [Occ=Once]
                      d'_s8jj [Occ=Once] ->
                    let {
                      sat_s8jn [Occ=Once] :: d_a4CF
                      [LclId] =
                          [$dSemigroup3_s8j7 d1_s8je d'_s8jj] \u []
                              GHC.Base.<> $dSemigroup3_s8j7 d1_s8je d'_s8jj; } in
                    let {
                      sat_s8jm [Occ=Once] :: c_a4CE
                      [LclId] =
                          [$dSemigroup2_s8j6 c1_s8jd c'_s8ji] \u []
                              GHC.Base.<> $dSemigroup2_s8j6 c1_s8jd c'_s8ji; } in
                    let {
                      sat_s8jl [Occ=Once] :: b_a4CD
                      [LclId] =
                          [$dSemigroup1_s8j5 b1_s8jc b'_s8jh] \u []
                              GHC.Base.<> $dSemigroup1_s8j5 b1_s8jc b'_s8jh; } in
                    let {
                      sat_s8jk [Occ=Once] :: a_a4CC
                      [LclId] =
                          [$dSemigroup_s8j4 a1_s8jb a'_s8jg] \u []
                              GHC.Base.<> $dSemigroup_s8j4 a1_s8jb a'_s8jg;
                    } in  (,,,) [sat_s8jk sat_s8jl sat_s8jm sat_s8jn];
              };
        };

GHC.Base.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     a -> b -> c -> d -> [(a, b, c, d)] -> (# a, b, c, d #)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8jo
           w1_s8jp
           w2_s8jq
           w3_s8jr
           ww_s8js
           ww1_s8jt
           ww2_s8ju
           ww3_s8jv
           ww4_s8jw]
        let {
          $wgo_s8jx [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: a_s6Ow
               -> b_s6Ox
               -> c_s6Oy
               -> d_s6Oz
               -> [(a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz)]
               -> (# a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz #)
          [LclId,
           Arity=5,
           Str=<L,U><L,U><L,U><L,U><S,1*U>,
           Unf=OtherCon []] =
              sat-only [w_s8jo w1_s8jp w2_s8jq w3_s8jr $wgo_s8jx] \r [ww5_s8jy
                                                                      ww6_s8jz
                                                                      ww7_s8jA
                                                                      ww8_s8jB
                                                                      w4_s8jC]
                  case w4_s8jC of {
                    [] -> (#,,,#) [ww5_s8jy ww6_s8jz ww7_s8jA ww8_s8jB];
                    : c1_s8jE [Occ=Once!] cs_s8jF [Occ=Once] ->
                        case c1_s8jE of {
                          (,,,) ww10_s8jH [Occ=Once]
                                ww11_s8jI [Occ=Once]
                                ww12_s8jJ [Occ=Once]
                                ww13_s8jK [Occ=Once] ->
                              case $wgo_s8jx ww10_s8jH ww11_s8jI ww12_s8jJ ww13_s8jK cs_s8jF of {
                                (#,,,#) ww15_s8jM [Occ=Once]
                                        ww16_s8jN [Occ=Once]
                                        ww17_s8jO [Occ=Once]
                                        ww18_s8jP [Occ=Once] ->
                                    let {
                                      sat_s8jT [Occ=Once] :: d_s6Oz
                                      [LclId] =
                                          [w3_s8jr ww8_s8jB ww18_s8jP] \u []
                                              GHC.Base.<> w3_s8jr ww8_s8jB ww18_s8jP; } in
                                    let {
                                      sat_s8jS [Occ=Once] :: c_s6Oy
                                      [LclId] =
                                          [w2_s8jq ww7_s8jA ww17_s8jO] \u []
                                              GHC.Base.<> w2_s8jq ww7_s8jA ww17_s8jO; } in
                                    let {
                                      sat_s8jR [Occ=Once] :: b_s6Ox
                                      [LclId] =
                                          [w1_s8jp ww6_s8jz ww16_s8jN] \u []
                                              GHC.Base.<> w1_s8jp ww6_s8jz ww16_s8jN; } in
                                    let {
                                      sat_s8jQ [Occ=Once] :: a_s6Ow
                                      [LclId] =
                                          [w_s8jo ww5_s8jy ww15_s8jM] \u []
                                              GHC.Base.<> w_s8jo ww5_s8jy ww15_s8jM;
                                    } in  (#,,,#) [sat_s8jQ sat_s8jR sat_s8jS sat_s8jT];
                              };
                        };
                  };
        } in  $wgo_s8jx ww_s8js ww1_s8jt ww2_s8ju ww3_s8jv ww4_s8jw;

GHC.Base.$fSemigroup(,,,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     GHC.Base.NonEmpty (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8jU w1_s8jV w2_s8jW w3_s8jX w4_s8jY]
        case w4_s8jY of {
          GHC.Base.:| ww1_s8k0 [Occ=Once!] ww2_s8k1 [Occ=Once] ->
              case ww1_s8k0 of {
                (,,,) ww4_s8k3 [Occ=Once]
                      ww5_s8k4 [Occ=Once]
                      ww6_s8k5 [Occ=Once]
                      ww7_s8k6 [Occ=Once] ->
                    case
                        GHC.Base.$w$csconcat2
                            w_s8jU
                            w1_s8jV
                            w2_s8jW
                            w3_s8jX
                            ww4_s8k3
                            ww5_s8k4
                            ww6_s8k5
                            ww7_s8k6
                            ww2_s8k1
                    of
                    { (#,,,#) ww9_s8k8 [Occ=Once]
                              ww10_s8k9 [Occ=Once]
                              ww11_s8ka [Occ=Once]
                              ww12_s8kb [Occ=Once] ->
                          (,,,) [ww9_s8k8 ww10_s8k9 ww11_s8ka ww12_s8kb];
                    };
              };
        };

GHC.Base.$fSemigroup(,,,)_$cstimes [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     forall b1.
     GHC.Real.Integral b1 =>
     b1 -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8kc w1_s8kd w2_s8ke w3_s8kf w4_s8kg w5_s8kh w6_s8ki]
        case w6_s8ki of {
          (,,,) ww1_s8kk [Occ=Once]
                ww2_s8kl [Occ=Once]
                ww3_s8km [Occ=Once]
                ww4_s8kn [Occ=Once] ->
              let {
                sat_s8kr [Occ=Once] :: d_s6OY
                [LclId] =
                    [w3_s8kf w4_s8kg w5_s8kh ww4_s8kn] \u []
                        GHC.Base.stimes w3_s8kf w4_s8kg w5_s8kh ww4_s8kn; } in
              let {
                sat_s8kq [Occ=Once] :: c_s6OX
                [LclId] =
                    [w2_s8ke w4_s8kg w5_s8kh ww3_s8km] \u []
                        GHC.Base.stimes w2_s8ke w4_s8kg w5_s8kh ww3_s8km; } in
              let {
                sat_s8kp [Occ=Once] :: b_s6OW
                [LclId] =
                    [w1_s8kd w4_s8kg w5_s8kh ww2_s8kl] \u []
                        GHC.Base.stimes w1_s8kd w4_s8kg w5_s8kh ww2_s8kl; } in
              let {
                sat_s8ko [Occ=Once] :: a_s6OV
                [LclId] =
                    [w_s8kc w4_s8kg w5_s8kh ww1_s8kk] \u []
                        GHC.Base.stimes w_s8kc w4_s8kg w5_s8kh ww1_s8kk;
              } in  (,,,) [sat_s8ko sat_s8kp sat_s8kq sat_s8kr];
        };

GHC.Base.$fSemigroup(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     GHC.Base.Semigroup (a, b, c, d)
[GblId[DFunId],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s8ks
           $dSemigroup1_s8kt
           $dSemigroup2_s8ku
           $dSemigroup3_s8kv]
        let {
          sat_s8ky [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
          [LclId] =
              [$dSemigroup_s8ks
               $dSemigroup1_s8kt
               $dSemigroup2_s8ku
               $dSemigroup3_s8kv] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(,,,)_$cstimes
                      $dSemigroup_s8ks
                      $dSemigroup1_s8kt
                      $dSemigroup2_s8ku
                      $dSemigroup3_s8kv
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_s8kx [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
          [LclId] =
              [$dSemigroup_s8ks
               $dSemigroup1_s8kt
               $dSemigroup2_s8ku
               $dSemigroup3_s8kv] \r [eta_B1]
                  GHC.Base.$fSemigroup(,,,)_$csconcat
                      $dSemigroup_s8ks
                      $dSemigroup1_s8kt
                      $dSemigroup2_s8ku
                      $dSemigroup3_s8kv
                      eta_B1; } in
        let {
          sat_s8kw [Occ=Once]
            :: (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
          [LclId] =
              [$dSemigroup_s8ks
               $dSemigroup1_s8kt
               $dSemigroup2_s8ku
               $dSemigroup3_s8kv] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,)_$c<>
                      $dSemigroup_s8ks
                      $dSemigroup1_s8kt
                      $dSemigroup2_s8ku
                      $dSemigroup3_s8kv
                      eta_B2
                      eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s8kw sat_s8kx sat_s8ky];

GHC.Base.$w$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     (# (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d),
        GHC.Base.NonEmpty (a, b, c, d) -> (a, b, c, d),
        forall b1.
        GHC.Real.Integral b1 =>
        b1 -> (a, b, c, d) -> (a, b, c, d) #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [w_s8kz w1_s8kA w2_s8kB w3_s8kC]
        let {
          w4_s8l1 [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup d_s6Pl
          [LclId] =
              [w3_s8kC] \u [] GHC.Base.$p1Monoid w3_s8kC; } in
        let {
          w5_s8l2 [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup c_s6Pk
          [LclId] =
              [w2_s8kB] \u [] GHC.Base.$p1Monoid w2_s8kB; } in
        let {
          w6_s8l3 [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_s6Pj
          [LclId] =
              [w1_s8kA] \u [] GHC.Base.$p1Monoid w1_s8kA; } in
        let {
          w7_s8l4 [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_s6Pi
          [LclId] =
              [w_s8kz] \u [] GHC.Base.$p1Monoid w_s8kz; } in
        let {
          sat_s8lh [Occ=Once]
            :: forall b1.
               GHC.Real.Integral b1 =>
               b1
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
          [LclId] =
              [w4_s8l1 w5_s8l2 w6_s8l3 w7_s8l4] \r [w8_s8l5 w9_s8l6 w10_s8l7]
                  case w10_s8l7 of {
                    (,,,) ww1_s8l9 [Occ=Once]
                          ww2_s8la [Occ=Once]
                          ww3_s8lb [Occ=Once]
                          ww4_s8lc [Occ=Once] ->
                        let {
                          sat_s8lg [Occ=Once] :: d_s6Pl
                          [LclId] =
                              [w4_s8l1 w8_s8l5 w9_s8l6 ww4_s8lc] \u []
                                  GHC.Base.stimes w4_s8l1 w8_s8l5 w9_s8l6 ww4_s8lc; } in
                        let {
                          sat_s8lf [Occ=Once] :: c_s6Pk
                          [LclId] =
                              [w5_s8l2 w8_s8l5 w9_s8l6 ww3_s8lb] \u []
                                  GHC.Base.stimes w5_s8l2 w8_s8l5 w9_s8l6 ww3_s8lb; } in
                        let {
                          sat_s8le [Occ=Once] :: b_s6Pj
                          [LclId] =
                              [w6_s8l3 w8_s8l5 w9_s8l6 ww2_s8la] \u []
                                  GHC.Base.stimes w6_s8l3 w8_s8l5 w9_s8l6 ww2_s8la; } in
                        let {
                          sat_s8ld [Occ=Once] :: a_s6Pi
                          [LclId] =
                              [w7_s8l4 w8_s8l5 w9_s8l6 ww1_s8l9] \u []
                                  GHC.Base.stimes w7_s8l4 w8_s8l5 w9_s8l6 ww1_s8l9;
                        } in  (,,,) [sat_s8ld sat_s8le sat_s8lf sat_s8lg];
                  }; } in
        let {
          w4_s8kI [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup d_s6Pl
          [LclId] =
              [w3_s8kC] \u [] GHC.Base.$p1Monoid w3_s8kC; } in
        let {
          w5_s8kJ [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup c_s6Pk
          [LclId] =
              [w2_s8kB] \u [] GHC.Base.$p1Monoid w2_s8kB; } in
        let {
          w6_s8kK [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_s6Pj
          [LclId] =
              [w1_s8kA] \u [] GHC.Base.$p1Monoid w1_s8kA; } in
        let {
          w7_s8kL [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_s6Pi
          [LclId] =
              [w_s8kz] \u [] GHC.Base.$p1Monoid w_s8kz; } in
        let {
          sat_s8l0 [Occ=Once]
            :: GHC.Base.NonEmpty (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
          [LclId] =
              [w4_s8kI w5_s8kJ w6_s8kK w7_s8kL] \r [w8_s8kM]
                  case w8_s8kM of {
                    GHC.Base.:| ww1_s8kO [Occ=Once!] ww2_s8kP [Occ=Once] ->
                        case ww1_s8kO of {
                          (,,,) ww4_s8kR [Occ=Once]
                                ww5_s8kS [Occ=Once]
                                ww6_s8kT [Occ=Once]
                                ww7_s8kU [Occ=Once] ->
                              case
                                  GHC.Base.$w$csconcat2
                                      w7_s8kL
                                      w6_s8kK
                                      w5_s8kJ
                                      w4_s8kI
                                      ww4_s8kR
                                      ww5_s8kS
                                      ww6_s8kT
                                      ww7_s8kU
                                      ww2_s8kP
                              of
                              { (#,,,#) ww9_s8kW [Occ=Once]
                                        ww10_s8kX [Occ=Once]
                                        ww11_s8kY [Occ=Once]
                                        ww12_s8kZ [Occ=Once] ->
                                    (,,,) [ww9_s8kW ww10_s8kX ww11_s8kY ww12_s8kZ];
                              };
                        };
                  }; } in
        let {
          sat_s8kG [Occ=OnceL] :: GHC.Base.Semigroup d_s6Pl
          [LclId] =
              [w3_s8kC] \u [] GHC.Base.$p1Monoid w3_s8kC; } in
        let {
          sat_s8kF [Occ=OnceL] :: GHC.Base.Semigroup c_s6Pk
          [LclId] =
              [w2_s8kB] \u [] GHC.Base.$p1Monoid w2_s8kB; } in
        let {
          sat_s8kE [Occ=OnceL] :: GHC.Base.Semigroup b_s6Pj
          [LclId] =
              [w1_s8kA] \u [] GHC.Base.$p1Monoid w1_s8kA; } in
        let {
          sat_s8kD [Occ=OnceL] :: GHC.Base.Semigroup a_s6Pi
          [LclId] =
              [w_s8kz] \u [] GHC.Base.$p1Monoid w_s8kz; } in
        let {
          sat_s8kH [Occ=Once]
            :: (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
          [LclId] =
              [sat_s8kD sat_s8kE sat_s8kF sat_s8kG] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,)_$c<>
                      sat_s8kD sat_s8kE sat_s8kF sat_s8kG eta_B2 eta_B1;
        } in  (#,,#) [sat_s8kH sat_s8l0 sat_s8lh];

GHC.Base.$fMonoid(,,,)_$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     GHC.Base.Semigroup (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [w_s8li w1_s8lj w2_s8lk w3_s8ll]
        case GHC.Base.$w$cp1Monoid w_s8li w1_s8lj w2_s8lk w3_s8ll of {
          (#,,#) ww1_s8ln [Occ=Once]
                 ww2_s8lo [Occ=Once]
                 ww3_s8lp [Occ=Once] ->
              GHC.Base.C:Semigroup [ww1_s8ln ww2_s8lo ww3_s8lp];
        };

GHC.Base.$fMonoid(,,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8lq $dMonoid1_s8lr $dMonoid2_s8ls $dMonoid3_s8lt]
        case
            GHC.Base.$w$cp1Monoid
                $dMonoid_s8lq $dMonoid1_s8lr $dMonoid2_s8ls $dMonoid3_s8lt
        of
        { (#,,#) ww1_s8lv [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> ww1_s8lv;
        };

GHC.Base.$fMonoid(,,,)_$cmconcat
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     [(a, b, c, d)] -> (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8ly $dMonoid1_s8lz $dMonoid2_s8lA $dMonoid3_s8lB]
        let {
          k_s8lC [Occ=OnceL, Dmd=<L,1*U(1*C(C1(U(U,U,U,U))),A,A)>]
            :: GHC.Base.Semigroup (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_s8ly $dMonoid1_s8lz $dMonoid2_s8lA $dMonoid3_s8lB] \s []
                  case
                      GHC.Base.$w$cp1Monoid
                          $dMonoid_s8ly $dMonoid1_s8lz $dMonoid2_s8lA $dMonoid3_s8lB
                  of
                  { (#,,#) ww1_s8lE [Occ=Once]
                           ww2_s8lF [Occ=Once]
                           ww3_s8lG [Occ=Once] ->
                        GHC.Base.C:Semigroup [ww1_s8lE ww2_s8lF ww3_s8lG];
                  }; } in
        let {
          k1_s8lH [Occ=OnceL!, Dmd=<L,C(C1(U(U,U,U,U)))>]
            :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [k_s8lC] \u [] GHC.Base.<> k_s8lC; } in
        let {
          z_s8lI [Occ=OnceL] :: a_a4xJ
          [LclId] =
              [$dMonoid_s8ly] \u [] GHC.Base.mempty $dMonoid_s8ly; } in
        let {
          z1_s8lJ [Occ=OnceL] :: b_a4xK
          [LclId] =
              [$dMonoid1_s8lz] \u [] GHC.Base.mempty $dMonoid1_s8lz; } in
        let {
          z2_s8lK [Occ=OnceL] :: c_a4xL
          [LclId] =
              [$dMonoid2_s8lA] \u [] GHC.Base.mempty $dMonoid2_s8lA; } in
        let {
          z3_s8lL [Occ=OnceL] :: d_a4xM
          [LclId] =
              [$dMonoid3_s8lB] \u [] GHC.Base.mempty $dMonoid3_s8lB; } in
        let {
          z4_s8lM [Occ=OnceL, Dmd=<L,U(U,U,U,U)>]
            :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId, Unf=OtherCon []] =
              CCCS (,,,)! [z_s8lI z1_s8lJ z2_s8lK z3_s8lL]; } in
        let {
          go_s8lN [Occ=LoopBreaker]
            :: [(a_a4xJ, b_a4xK, c_a4xL, d_a4xM)]
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [k1_s8lH z4_s8lM go_s8lN] \r [ds_s8lO]
                  case ds_s8lO of {
                    [] -> z4_s8lM;
                    : y_s8lQ [Occ=Once] ys_s8lR [Occ=Once] ->
                        let {
                          sat_s8lS [Occ=Once] :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
                          [LclId] =
                              [go_s8lN ys_s8lR] \u [] go_s8lN ys_s8lR;
                        } in  k1_s8lH y_s8lQ sat_s8lS;
                  };
        } in  go_s8lN;

GHC.Base.$fMonoid(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     GHC.Base.Monoid (a, b, c, d)
[GblId[DFunId],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW]
        let {
          sat_s8m0 [Occ=Once]
            :: [(a_a4xJ, b_a4xK, c_a4xL, d_a4xM)]
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW] \u []
                  GHC.Base.$fMonoid(,,,)_$cmconcat
                      $dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW; } in
        let {
          sat_s8lZ [Occ=Once]
            :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW] \u []
                  GHC.Base.$fMonoid(,,,)_$cmappend
                      $dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW; } in
        let {
          sat_s8lY [Occ=Once] :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW] \u []
                  GHC.Base.$fMonoid(,,,)_$cmempty
                      $dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW; } in
        let {
          sat_s8lX [Occ=Once]
            :: GHC.Base.Semigroup (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW] \u []
                  GHC.Base.$fMonoid(,,,)_$cp1Monoid
                      $dMonoid_s8lT $dMonoid1_s8lU $dMonoid2_s8lV $dMonoid3_s8lW;
        } in  GHC.Base.C:Monoid [sat_s8lX sat_s8lY sat_s8lZ sat_s8m0];

GHC.Base.$fMonoid(,,)_$c<> [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     (a, b, c) -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U)><S,1*U(U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8m1 w1_s8m2 w2_s8m3 w3_s8m4 w4_s8m5]
        case w3_s8m4 of {
          (,,) ww1_s8m7 [Occ=Once] ww2_s8m8 [Occ=Once] ww3_s8m9 [Occ=Once] ->
              case w4_s8m5 of {
                (,,) ww5_s8mb [Occ=Once] ww6_s8mc [Occ=Once] ww7_s8md [Occ=Once] ->
                    let {
                      sat_s8mg [Occ=Once] :: c_s6PF
                      [LclId] =
                          [w2_s8m3 ww3_s8m9 ww7_s8md] \u []
                              GHC.Base.<> w2_s8m3 ww3_s8m9 ww7_s8md; } in
                    let {
                      sat_s8mf [Occ=Once] :: b_s6PE
                      [LclId] =
                          [w1_s8m2 ww2_s8m8 ww6_s8mc] \u []
                              GHC.Base.<> w1_s8m2 ww2_s8m8 ww6_s8mc; } in
                    let {
                      sat_s8me [Occ=Once] :: a_s6PD
                      [LclId] =
                          [w_s8m1 ww1_s8m7 ww5_s8mb] \u []
                              GHC.Base.<> w_s8m1 ww1_s8m7 ww5_s8mb;
                    } in  (,,) [sat_s8me sat_s8mf sat_s8mg];
              };
        };

GHC.Base.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     a -> b -> c -> [(a, b, c)] -> (# a, b, c #)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s8mh w1_s8mi w2_s8mj ww_s8mk ww1_s8ml ww2_s8mm ww3_s8mn]
        let {
          $wgo_s8mo [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: a_s6Qd
               -> b_s6Qe
               -> c_s6Qf
               -> [(a_s6Qd, b_s6Qe, c_s6Qf)]
               -> (# a_s6Qd, b_s6Qe, c_s6Qf #)
          [LclId, Arity=4, Str=<L,U><L,U><L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s8mh w1_s8mi w2_s8mj $wgo_s8mo] \r [ww4_s8mp
                                                              ww5_s8mq
                                                              ww6_s8mr
                                                              w3_s8ms]
                  case w3_s8ms of {
                    [] -> (#,,#) [ww4_s8mp ww5_s8mq ww6_s8mr];
                    : c1_s8mu [Occ=Once!] cs_s8mv [Occ=Once] ->
                        case c1_s8mu of {
                          (,,) ww8_s8mx [Occ=Once]
                               ww9_s8my [Occ=Once]
                               ww10_s8mz [Occ=Once] ->
                              case $wgo_s8mo ww8_s8mx ww9_s8my ww10_s8mz cs_s8mv of {
                                (#,,#) ww12_s8mB [Occ=Once]
                                       ww13_s8mC [Occ=Once]
                                       ww14_s8mD [Occ=Once] ->
                                    let {
                                      sat_s8mG [Occ=Once] :: c_s6Qf
                                      [LclId] =
                                          [w2_s8mj ww6_s8mr ww14_s8mD] \u []
                                              GHC.Base.<> w2_s8mj ww6_s8mr ww14_s8mD; } in
                                    let {
                                      sat_s8mF [Occ=Once] :: b_s6Qe
                                      [LclId] =
                                          [w1_s8mi ww5_s8mq ww13_s8mC] \u []
                                              GHC.Base.<> w1_s8mi ww5_s8mq ww13_s8mC; } in
                                    let {
                                      sat_s8mE [Occ=Once] :: a_s6Qd
                                      [LclId] =
                                          [w_s8mh ww4_s8mp ww12_s8mB] \u []
                                              GHC.Base.<> w_s8mh ww4_s8mp ww12_s8mB;
                                    } in  (#,,#) [sat_s8mE sat_s8mF sat_s8mG];
                              };
                        };
                  };
        } in  $wgo_s8mo ww_s8mk ww1_s8ml ww2_s8mm ww3_s8mn;

GHC.Base.$fSemigroup(,,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     GHC.Base.NonEmpty (a, b, c) -> (a, b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8mH w1_s8mI w2_s8mJ w3_s8mK]
        case w3_s8mK of {
          GHC.Base.:| ww1_s8mM [Occ=Once!] ww2_s8mN [Occ=Once] ->
              case ww1_s8mM of {
                (,,) ww4_s8mP [Occ=Once] ww5_s8mQ [Occ=Once] ww6_s8mR [Occ=Once] ->
                    case
                        GHC.Base.$w$csconcat1
                            w_s8mH w1_s8mI w2_s8mJ ww4_s8mP ww5_s8mQ ww6_s8mR ww2_s8mN
                    of
                    { (#,,#) ww8_s8mT [Occ=Once]
                             ww9_s8mU [Occ=Once]
                             ww10_s8mV [Occ=Once] ->
                          (,,) [ww8_s8mT ww9_s8mU ww10_s8mV];
                    };
              };
        };

GHC.Base.$fMonoid(,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     (a, b, c) -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U,U)><S,1*U(U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8mW
           $dMonoid1_s8mX
           $dMonoid2_s8mY
           eta_s8mZ
           eta1_s8n0]
        case eta_s8mZ of {
          (,,) a1_s8n2 [Occ=Once] b1_s8n3 [Occ=Once] c1_s8n4 [Occ=Once] ->
              case eta1_s8n0 of {
                (,,) a'_s8n6 [Occ=Once] b'_s8n7 [Occ=Once] c'_s8n8 [Occ=Once] ->
                    let {
                      sat_s8ne [Occ=Once] :: c_a4yl
                      [LclId] =
                          [$dMonoid2_s8mY c1_s8n4 c'_s8n8] \u []
                              case GHC.Base.$p1Monoid $dMonoid2_s8mY of sat_s8nd {
                                __DEFAULT -> GHC.Base.<> sat_s8nd c1_s8n4 c'_s8n8;
                              }; } in
                    let {
                      sat_s8nc [Occ=Once] :: b_a4yk
                      [LclId] =
                          [$dMonoid1_s8mX b1_s8n3 b'_s8n7] \u []
                              case GHC.Base.$p1Monoid $dMonoid1_s8mX of sat_s8nb {
                                __DEFAULT -> GHC.Base.<> sat_s8nb b1_s8n3 b'_s8n7;
                              }; } in
                    let {
                      sat_s8na [Occ=Once] :: a_a4yj
                      [LclId] =
                          [$dMonoid_s8mW a1_s8n2 a'_s8n6] \u []
                              case GHC.Base.$p1Monoid $dMonoid_s8mW of sat_s8n9 {
                                __DEFAULT -> GHC.Base.<> sat_s8n9 a1_s8n2 a'_s8n6;
                              };
                    } in  (,,) [sat_s8na sat_s8nc sat_s8ne];
              };
        };

GHC.Base.$fMonoid(,,)_$cmconcat
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     [(a, b, c)] -> (a, b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8nf $dMonoid1_s8ng $dMonoid2_s8nh eta_s8ni]
        let {
          $dSemigroup_s8nj [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_a4yj
          [LclId] =
              [$dMonoid_s8nf] \u [] GHC.Base.$p1Monoid $dMonoid_s8nf; } in
        let {
          $dSemigroup1_s8nk [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_a4yk
          [LclId] =
              [$dMonoid1_s8ng] \u [] GHC.Base.$p1Monoid $dMonoid1_s8ng; } in
        let {
          $dSemigroup2_s8nl [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup c_a4yl
          [LclId] =
              [$dMonoid2_s8nh] \u [] GHC.Base.$p1Monoid $dMonoid2_s8nh; } in
        let {
          z_s8nm [Occ=OnceL] :: a_a4yj
          [LclId] =
              [$dMonoid_s8nf] \u [] GHC.Base.mempty $dMonoid_s8nf; } in
        let {
          z1_s8nn [Occ=OnceL] :: b_a4yk
          [LclId] =
              [$dMonoid1_s8ng] \u [] GHC.Base.mempty $dMonoid1_s8ng; } in
        let {
          z2_s8no [Occ=OnceL] :: c_a4yl
          [LclId] =
              [$dMonoid2_s8nh] \u [] GHC.Base.mempty $dMonoid2_s8nh; } in
        let {
          z3_s8np [Occ=OnceL, Dmd=<S,U(U,U,U)>] :: (a_a4yj, b_a4yk, c_a4yl)
          [LclId, Unf=OtherCon []] =
              CCCS (,,)! [z_s8nm z1_s8nn z2_s8no]; } in
        let {
          go_s8nq [Occ=LoopBreaker]
            :: [(a_a4yj, b_a4yk, c_a4yl)] -> (a_a4yj, b_a4yk, c_a4yl)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_s8nj
                        $dSemigroup1_s8nk
                        $dSemigroup2_s8nl
                        z3_s8np
                        go_s8nq] \r [ds_s8nr]
                  case ds_s8nr of {
                    [] -> z3_s8np;
                    : y_s8nt [Occ=Once!] ys_s8nu [Occ=Once] ->
                        case y_s8nt of {
                          (,,) a1_s8nw [Occ=Once] b1_s8nx [Occ=Once] c1_s8ny [Occ=Once] ->
                              case go_s8nq ys_s8nu of {
                                (,,) a'_s8nA [Occ=Once] b'_s8nB [Occ=Once] c'_s8nC [Occ=Once] ->
                                    let {
                                      sat_s8nF [Occ=Once] :: c_a4yl
                                      [LclId] =
                                          [$dSemigroup2_s8nl c1_s8ny c'_s8nC] \u []
                                              GHC.Base.<> $dSemigroup2_s8nl c1_s8ny c'_s8nC; } in
                                    let {
                                      sat_s8nE [Occ=Once] :: b_a4yk
                                      [LclId] =
                                          [$dSemigroup1_s8nk b1_s8nx b'_s8nB] \u []
                                              GHC.Base.<> $dSemigroup1_s8nk b1_s8nx b'_s8nB; } in
                                    let {
                                      sat_s8nD [Occ=Once] :: a_a4yj
                                      [LclId] =
                                          [$dSemigroup_s8nj a1_s8nw a'_s8nA] \u []
                                              GHC.Base.<> $dSemigroup_s8nj a1_s8nw a'_s8nA;
                                    } in  (,,) [sat_s8nD sat_s8nE sat_s8nF];
                              };
                        };
                  };
        } in  go_s8nq eta_s8ni;

GHC.Base.$fSemigroup(,,)_$cstimes [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     forall b1. GHC.Real.Integral b1 => b1 -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8nG w1_s8nH w2_s8nI w3_s8nJ w4_s8nK w5_s8nL]
        case w5_s8nL of {
          (,,) ww1_s8nN [Occ=Once] ww2_s8nO [Occ=Once] ww3_s8nP [Occ=Once] ->
              let {
                sat_s8nS [Occ=Once] :: c_s6QJ
                [LclId] =
                    [w2_s8nI w3_s8nJ w4_s8nK ww3_s8nP] \u []
                        GHC.Base.stimes w2_s8nI w3_s8nJ w4_s8nK ww3_s8nP; } in
              let {
                sat_s8nR [Occ=Once] :: b_s6QI
                [LclId] =
                    [w1_s8nH w3_s8nJ w4_s8nK ww2_s8nO] \u []
                        GHC.Base.stimes w1_s8nH w3_s8nJ w4_s8nK ww2_s8nO; } in
              let {
                sat_s8nQ [Occ=Once] :: a_s6QH
                [LclId] =
                    [w_s8nG w3_s8nJ w4_s8nK ww1_s8nN] \u []
                        GHC.Base.stimes w_s8nG w3_s8nJ w4_s8nK ww1_s8nN;
              } in  (,,) [sat_s8nQ sat_s8nR sat_s8nS];
        };

GHC.Base.$fSemigroup(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     GHC.Base.Semigroup (a, b, c)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s8nT $dSemigroup1_s8nU $dSemigroup2_s8nV]
        let {
          sat_s8nY [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> (a_a4Dq, b_a4Dr, c_a4Ds) -> (a_a4Dq, b_a4Dr, c_a4Ds)
          [LclId] =
              [$dSemigroup_s8nT $dSemigroup1_s8nU $dSemigroup2_s8nV] \r [eta_B3
                                                                         eta_B2
                                                                         eta_B1]
                  GHC.Base.$fSemigroup(,,)_$cstimes
                      $dSemigroup_s8nT
                      $dSemigroup1_s8nU
                      $dSemigroup2_s8nV
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_s8nX [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4Dq, b_a4Dr, c_a4Ds)
               -> (a_a4Dq, b_a4Dr, c_a4Ds)
          [LclId] =
              [$dSemigroup_s8nT $dSemigroup1_s8nU $dSemigroup2_s8nV] \r [eta_B1]
                  GHC.Base.$fSemigroup(,,)_$csconcat
                      $dSemigroup_s8nT $dSemigroup1_s8nU $dSemigroup2_s8nV eta_B1; } in
        let {
          sat_s8nW [Occ=Once]
            :: (a_a4Dq, b_a4Dr, c_a4Ds)
               -> (a_a4Dq, b_a4Dr, c_a4Ds) -> (a_a4Dq, b_a4Dr, c_a4Ds)
          [LclId] =
              [$dSemigroup_s8nT $dSemigroup1_s8nU $dSemigroup2_s8nV] \r [eta_B2
                                                                         eta_B1]
                  GHC.Base.$fMonoid(,,)_$c<>
                      $dSemigroup_s8nT $dSemigroup1_s8nU $dSemigroup2_s8nV eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s8nW sat_s8nX sat_s8nY];

GHC.Base.$fMonoid(,,)_$cp1Monoid
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     GHC.Base.Semigroup (a, b, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8nZ $dMonoid1_s8o0 $dMonoid2_s8o1]
        let {
          sat_s8o4 [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup c_a4yl
          [LclId] =
              [$dMonoid2_s8o1] \u [] GHC.Base.$p1Monoid $dMonoid2_s8o1; } in
        let {
          sat_s8o3 [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_a4yk
          [LclId] =
              [$dMonoid1_s8o0] \u [] GHC.Base.$p1Monoid $dMonoid1_s8o0; } in
        let {
          sat_s8o2 [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_a4yj
          [LclId] =
              [$dMonoid_s8nZ] \u [] GHC.Base.$p1Monoid $dMonoid_s8nZ;
        } in  GHC.Base.$fSemigroup(,,) sat_s8o2 sat_s8o3 sat_s8o4;

GHC.Base.$fMonoid(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     GHC.Base.Monoid (a, b, c)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7]
        let {
          sat_s8ob [Occ=Once]
            :: [(a_a4yj, b_a4yk, c_a4yl)] -> (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7] \r [eta_B1]
                  GHC.Base.$fMonoid(,,)_$cmconcat
                      $dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7 eta_B1; } in
        let {
          sat_s8oa [Occ=Once]
            :: (a_a4yj, b_a4yk, c_a4yl)
               -> (a_a4yj, b_a4yk, c_a4yl) -> (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,)_$cmappend
                      $dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7 eta_B2 eta_B1; } in
        let {
          sat_s8o9 [Occ=Once] :: (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7] \u []
                  GHC.Base.$fMonoid(,,)_$cmempty
                      $dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7; } in
        let {
          sat_s8o8 [Occ=Once] :: GHC.Base.Semigroup (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7] \u []
                  GHC.Base.$fMonoid(,,)_$cp1Monoid
                      $dMonoid_s8o5 $dMonoid1_s8o6 $dMonoid2_s8o7;
        } in  GHC.Base.C:Monoid [sat_s8o8 sat_s8o9 sat_s8oa sat_s8ob];

GHC.Base.$fSemigroup(,)_$c<>
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     (a, b) -> (a, b) -> (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8oc $dSemigroup1_s8od ds_s8oe ds1_s8of]
        case ds_s8oe of {
          (,) a1_s8oh [Occ=Once] b1_s8oi [Occ=Once] ->
              case ds1_s8of of {
                (,) a'_s8ok [Occ=Once] b'_s8ol [Occ=Once] ->
                    let {
                      sat_s8on [Occ=Once] :: b_a4E7
                      [LclId] =
                          [$dSemigroup1_s8od b1_s8oi b'_s8ol] \u []
                              GHC.Base.<> $dSemigroup1_s8od b1_s8oi b'_s8ol; } in
                    let {
                      sat_s8om [Occ=Once] :: a_a4E6
                      [LclId] =
                          [$dSemigroup_s8oc a1_s8oh a'_s8ok] \u []
                              GHC.Base.<> $dSemigroup_s8oc a1_s8oh a'_s8ok;
                    } in  (,) [sat_s8om sat_s8on];
              };
        };

GHC.Base.$fSemigroup(,)_$cstimes
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     forall b1. GHC.Real.Integral b1 => b1 -> (a, b) -> (a, b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8oo
           $dSemigroup1_s8op
           $dIntegral_s8oq
           n_s8or
           ds_s8os]
        case ds_s8os of {
          (,) a1_s8ou [Occ=Once] b2_s8ov [Occ=Once] ->
              let {
                sat_s8ox [Occ=Once] :: b_a4E7
                [LclId] =
                    [$dSemigroup1_s8op $dIntegral_s8oq n_s8or b2_s8ov] \u []
                        GHC.Base.stimes
                            $dSemigroup1_s8op $dIntegral_s8oq n_s8or b2_s8ov; } in
              let {
                sat_s8ow [Occ=Once] :: a_a4E6
                [LclId] =
                    [$dSemigroup_s8oo $dIntegral_s8oq n_s8or a1_s8ou] \u []
                        GHC.Base.stimes $dSemigroup_s8oo $dIntegral_s8oq n_s8or a1_s8ou;
              } in  (,) [sat_s8ow sat_s8ox];
        };

GHC.Base.$fSemigroup(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     GHC.Base.Semigroup (a, b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s8oy $dSemigroup1_s8oz]
        let {
          sat_s8oC [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7)
          [LclId] =
              [$dSemigroup_s8oy $dSemigroup1_s8oz] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(,)_$cstimes
                      $dSemigroup_s8oy $dSemigroup1_s8oz eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s8oB [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7)
          [LclId] =
              [$dSemigroup_s8oy $dSemigroup1_s8oz] \r [eta_B1]
                  GHC.Base.$fSemigroup(,)_$csconcat
                      $dSemigroup_s8oy $dSemigroup1_s8oz eta_B1; } in
        let {
          sat_s8oA [Occ=Once]
            :: (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7)
          [LclId] =
              [$dSemigroup_s8oy $dSemigroup1_s8oz] \r [eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(,)_$c<>
                      $dSemigroup_s8oy $dSemigroup1_s8oz eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s8oA sat_s8oB sat_s8oC];

GHC.Base.$fMonoid(,)_$cp1Monoid
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     GHC.Base.Semigroup (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8oD $dMonoid1_s8oE]
        let {
          sat_s8oG [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_a4yQ
          [LclId] =
              [$dMonoid1_s8oE] \u [] GHC.Base.$p1Monoid $dMonoid1_s8oE; } in
        let {
          sat_s8oF [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_a4yP
          [LclId] =
              [$dMonoid_s8oD] \u [] GHC.Base.$p1Monoid $dMonoid_s8oD;
        } in  GHC.Base.$fSemigroup(,) sat_s8oF sat_s8oG;

GHC.Base.$fMonoid(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     GHC.Base.Monoid (a, b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s8oH $dMonoid1_s8oI]
        let {
          sat_s8oM [Occ=Once] :: [(a_a4yP, b_a4yQ)] -> (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_s8oH $dMonoid1_s8oI] \r [eta_B1]
                  GHC.Base.$fMonoid(,)_$cmconcat
                      $dMonoid_s8oH $dMonoid1_s8oI eta_B1; } in
        let {
          sat_s8oL [Occ=Once]
            :: (a_a4yP, b_a4yQ) -> (a_a4yP, b_a4yQ) -> (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_s8oH $dMonoid1_s8oI] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,)_$cmappend
                      $dMonoid_s8oH $dMonoid1_s8oI eta_B2 eta_B1; } in
        let {
          sat_s8oK [Occ=Once] :: (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_s8oH $dMonoid1_s8oI] \u []
                  GHC.Base.$fMonoid(,)_$cmempty $dMonoid_s8oH $dMonoid1_s8oI; } in
        let {
          sat_s8oJ [Occ=Once] :: GHC.Base.Semigroup (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_s8oH $dMonoid1_s8oI] \u []
                  GHC.Base.$fMonoid(,)_$cp1Monoid $dMonoid_s8oH $dMonoid1_s8oI;
        } in  GHC.Base.C:Monoid [sat_s8oJ sat_s8oK sat_s8oL sat_s8oM];

GHC.Base.$fMonoid()_$c<> :: () -> () -> ()
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_s8oN ds1_s8oO] () [];

GHC.Base.$fSemigroup()_$csconcat :: GHC.Base.NonEmpty () -> ()
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_s8oP] () [];

GHC.Base.$fSemigroup()_$cstimes
  :: forall b. GHC.Real.Integral b => b -> () -> ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s8oQ ds_s8oR ds1_s8oS] () [];

GHC.Base.$fSemigroup() [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup ()
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.$fMonoid()_$c<>
                                         GHC.Base.$fSemigroup()_$csconcat
                                         GHC.Base.$fSemigroup()_$cstimes];

GHC.Base.$fMonoid() [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid ()
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [GHC.Base.$fSemigroup()
                                      GHC.Tuple.()
                                      GHC.Base.$fMonoid()_$c<>
                                      GHC.Base.$fMonoid()_$cmconcat];

GHC.Base.$fSemigroup(->)_$c<>
  :: forall b a.
     GHC.Base.Semigroup b =>
     (a -> b) -> (a -> b) -> a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),1*U(1*C1(C1(U)),A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8oT f_s8oU g_s8oV x_s8oW]
        let {
          sat_s8oY [Occ=Once] :: b_a4EV
          [LclId] =
              [g_s8oV x_s8oW] \u [] g_s8oV x_s8oW; } in
        let {
          sat_s8oX [Occ=Once] :: b_a4EV
          [LclId] =
              [f_s8oU x_s8oW] \u [] f_s8oU x_s8oW;
        } in  GHC.Base.<> $dSemigroup_s8oT sat_s8oX sat_s8oY;

GHC.Base.$fSemigroup(->)_$cstimes
  :: forall b a.
     GHC.Base.Semigroup b =>
     forall b1. GHC.Real.Integral b1 => b1 -> (a -> b) -> a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_s8oZ $dIntegral_s8p0 n_s8p1 f_s8p2 e_s8p3]
        let {
          sat_s8p4 [Occ=Once] :: b_a4EV
          [LclId] =
              [f_s8p2 e_s8p3] \u [] f_s8p2 e_s8p3;
        } in 
          GHC.Base.stimes $dSemigroup_s8oZ $dIntegral_s8p0 n_s8p1 sat_s8p4;

GHC.Base.$fSemigroup(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall b a. GHC.Base.Semigroup b => GHC.Base.Semigroup (a -> b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s8p5]
        let {
          sat_s8p8 [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> (a_a4EW -> b_a4EV) -> a_a4EW -> b_a4EV
          [LclId] =
              [$dSemigroup_s8p5] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$cstimes
                      $dSemigroup_s8p5 eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s8p7 [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4EW -> b_a4EV) -> a_a4EW -> b_a4EV
          [LclId] =
              [$dSemigroup_s8p5] \r [eta_B1]
                  GHC.Base.$fSemigroup(->)_$csconcat $dSemigroup_s8p5 eta_B1; } in
        let {
          sat_s8p6 [Occ=Once]
            :: (a_a4EW -> b_a4EV) -> (a_a4EW -> b_a4EV) -> a_a4EW -> b_a4EV
          [LclId] =
              [$dSemigroup_s8p5] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$c<>
                      $dSemigroup_s8p5 eta_B3 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_s8p6 sat_s8p7 sat_s8p8];

GHC.Base.$fMonoid(->)_$cp1Monoid
  :: forall b a. GHC.Base.Monoid b => GHC.Base.Semigroup (a -> b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s8p9]
        let {
          sat_s8pa [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_a4zA
          [LclId] =
              [$dMonoid_s8p9] \u [] GHC.Base.$p1Monoid $dMonoid_s8p9;
        } in  GHC.Base.$fSemigroup(->) sat_s8pa;

GHC.Base.$fMonoid(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall b a. GHC.Base.Monoid b => GHC.Base.Monoid (a -> b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s8pb]
        let {
          lvl3_s8pc [Occ=OnceL] :: b_a4zA
          [LclId] =
              [$dMonoid_s8pb] \u [] GHC.Base.mempty $dMonoid_s8pb; } in
        let {
          sat_s8ph [Occ=Once] :: [a_a4zB -> b_a4zA] -> a_a4zB -> b_a4zA
          [LclId] =
              [$dMonoid_s8pb] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmconcat $dMonoid_s8pb eta_B2 eta_B1; } in
        let {
          sat_s8pg [Occ=Once]
            :: (a_a4zB -> b_a4zA) -> (a_a4zB -> b_a4zA) -> a_a4zB -> b_a4zA
          [LclId] =
              [$dMonoid_s8pb] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmappend
                      $dMonoid_s8pb eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s8pf [Occ=Once] :: a_a4zB -> b_a4zA
          [LclId] =
              [lvl3_s8pc] \r [ds_s8pe] lvl3_s8pc; } in
        let {
          sat_s8pd [Occ=Once] :: GHC.Base.Semigroup (a_a4zB -> b_a4zA)
          [LclId] =
              [$dMonoid_s8pb] \u []
                  GHC.Base.$fMonoid(->)_$cp1Monoid $dMonoid_s8pb;
        } in  GHC.Base.C:Monoid [sat_s8pd sat_s8pf sat_s8pg sat_s8ph];

GHC.Base.$fSemigroup[]_$cstimes
  :: forall a b. GHC.Real.Integral b => b -> [a] -> [a]
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_s8pi]
        Data.Semigroup.Internal.stimesList $dIntegral_s8pi;

GHC.Base.$fSemigroup[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup [a]
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.++
                                         GHC.Base.$fSemigroup[]_$csconcat
                                         GHC.Base.$fSemigroup[]_$cstimes];

GHC.Base.$fMonoid[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid [a]
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [GHC.Base.$fSemigroup[]
                                      GHC.Types.[]
                                      GHC.Base.++
                                      GHC.Base.$fMonoid[]_$cmconcat];

GHC.Base.$fApplicativeNonEmpty_$cpure
  :: forall a. a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [a1_s8pj] GHC.Base.:| [a1_s8pj GHC.Types.[]];

GHC.Base.$w$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> (# c, [c] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(U,U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s8pk w1_s8pl w2_s8pm]
        let {
          sat_s8pu [Occ=Once] :: a_s6R1 -> GHC.Base.NonEmpty c_s6R3
          [LclId] =
              [w_s8pk w2_s8pm] \r [x1_s8pn]
                  let {
                    sat_s8pq [Occ=Once] :: b_s6R2 -> GHC.Base.NonEmpty c_s6R3
                    [LclId] =
                        [w_s8pk x1_s8pn] \r [x2_s8po]
                            let {
                              sat_s8pp [Occ=Once] :: c_s6R3
                              [LclId] =
                                  [w_s8pk x1_s8pn x2_s8po] \u [] w_s8pk x1_s8pn x2_s8po;
                            } in  GHC.Base.:| [sat_s8pp GHC.Types.[]];
                  } in 
                    case GHC.Base.$w$c>>= w2_s8pm sat_s8pq of {
                      (#,#) ww1_s8ps [Occ=Once] ww2_s8pt [Occ=Once] ->
                          GHC.Base.:| [ww1_s8ps ww2_s8pt];
                    };
        } in  GHC.Base.$w$c>>= w1_s8pl sat_s8pu;

GHC.Base.$fApplicativeNonEmpty_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.NonEmpty a
     -> GHC.Base.NonEmpty b
     -> GHC.Base.NonEmpty c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8pv w1_s8pw w2_s8px]
        case GHC.Base.$w$cliftA2 w_s8pv w1_s8pw w2_s8px of {
          (#,#) ww1_s8pz [Occ=Once] ww2_s8pA [Occ=Once] ->
              GHC.Base.:| [ww1_s8pz ww2_s8pA];
        };

GHC.Base.$w$c<* [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> (# a, [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s8pB w1_s8pC]
        let {
          sat_s8pK [Occ=Once] :: a_s6Rb -> GHC.Base.NonEmpty a_s6Rb
          [LclId] =
              [w1_s8pC] \r [x1_s8pD]
                  let {
                    lvl3_s8pE [Occ=OnceL, Dmd=<L,U(U,U)>] :: GHC.Base.NonEmpty a_s6Rb
                    [LclId, Unf=OtherCon []] =
                        CCCS GHC.Base.:|! [x1_s8pD GHC.Types.[]]; } in
                  let {
                    sat_s8pG [Occ=Once] :: b_s6Rc -> GHC.Base.NonEmpty a_s6Rb
                    [LclId] =
                        [lvl3_s8pE] \r [x2_s8pF] lvl3_s8pE;
                  } in 
                    case GHC.Base.$w$c>>= w1_s8pC sat_s8pG of {
                      (#,#) ww1_s8pI [Occ=Once] ww2_s8pJ [Occ=Once] ->
                          GHC.Base.:| [ww1_s8pI ww2_s8pJ];
                    };
        } in  GHC.Base.$w$c>>= w_s8pB sat_s8pK;

GHC.Base.$fApplicativeNonEmpty_$c<* [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8pL w1_s8pM]
        case GHC.Base.$w$c<* w_s8pL w1_s8pM of {
          (#,#) ww1_s8pO [Occ=Once] ww2_s8pP [Occ=Once] ->
              GHC.Base.:| [ww1_s8pO ww2_s8pP];
        };

GHC.Base.$w$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a -> b) -> GHC.Base.NonEmpty a -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_s8pQ w1_s8pR]
        let {
          sat_s8pZ [Occ=Once]
            :: (a_s6Rj -> b_s6Rk) -> GHC.Base.NonEmpty b_s6Rk
          [LclId] =
              [w1_s8pR] \r [x1_s8pS]
                  let {
                    sat_s8pV [Occ=Once] :: a_s6Rj -> GHC.Base.NonEmpty b_s6Rk
                    [LclId] =
                        [x1_s8pS] \r [x2_s8pT]
                            let {
                              sat_s8pU [Occ=Once] :: b_s6Rk
                              [LclId] =
                                  [x1_s8pS x2_s8pT] \u [] x1_s8pS x2_s8pT;
                            } in  GHC.Base.:| [sat_s8pU GHC.Types.[]];
                  } in 
                    case GHC.Base.$w$c>>= w1_s8pR sat_s8pV of {
                      (#,#) ww1_s8pX [Occ=Once] ww2_s8pY [Occ=Once] ->
                          GHC.Base.:| [ww1_s8pX ww2_s8pY];
                    };
        } in  GHC.Base.$w$c>>= w_s8pQ sat_s8pZ;

GHC.Base.$fApplicativeNonEmpty_$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a -> b)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8q0 w1_s8q1]
        case GHC.Base.$w$c<*> w_s8q0 w1_s8q1 of {
          (#,#) ww1_s8q3 [Occ=Once] ww2_s8q4 [Occ=Once] ->
              GHC.Base.:| [ww1_s8q3 ww2_s8q4];
        };

GHC.Base.$fApplicativeNonEmpty1 :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s8q5 eta_s8q6] eta_s8q6;

GHC.Base.$fApplicativeNonEmpty_$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_s8q7 w1_s8q8]
        let {
          sat_s8qc [Occ=Once] :: [b_s6Rs -> b_s6Rs]
          [LclId] =
              [w_s8q7] \u []
                  case w_s8q7 of {
                    GHC.Base.:| _ [Occ=Dead] as_s8qb [Occ=Once] ->
                        GHC.Base.map GHC.Base.$fApplicativeNonEmpty1 as_s8qb;
                  }; } in
        let {
          sat_s8qd [Occ=Once] :: GHC.Base.NonEmpty (b_s6Rs -> b_s6Rs)
          [LclId] =
              CCCS GHC.Base.:|! [GHC.Base.breakpoint sat_s8qc];
        } in 
          case GHC.Base.$w$c<*> sat_s8qd w1_s8q8 of {
            (#,#) ww1_s8qf [Occ=Once] ww2_s8qg [Occ=Once] ->
                GHC.Base.:| [ww1_s8qf ww2_s8qg];
          };

GHC.Base.$fApplicativeNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctorNonEmpty
                                           GHC.Base.$fApplicativeNonEmpty_$cpure
                                           GHC.Base.$fApplicativeNonEmpty_$c<*>
                                           GHC.Base.$fApplicativeNonEmpty_$cliftA2
                                           GHC.Base.$fApplicativeNonEmpty_$c*>
                                           GHC.Base.$fApplicativeNonEmpty_$c<*];

lvl_r7PJ :: forall a. [GHC.Types.Char] -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s8qh] GHC.Err.errorWithoutStackTrace eta_s8qh;

GHC.Base.$fMonadNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicativeNonEmpty
                                     GHC.Base.$fMonadNonEmpty_$c>>=
                                     GHC.Base.$fMonadNonEmpty_$c>>
                                     GHC.Base.$fApplicativeNonEmpty_$cpure
                                     lvl_r7PJ];

GHC.Base.$fAlternativeIO4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "mzero"#;

GHC.Base.$fAlternativeIO3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.Base.$fAlternativeIO4;

GHC.Base.$fAlternativeIO_$cempty :: forall a. GHC.Types.IO a
[GblId] =
    [] \u [] GHC.IO.failIO GHC.Base.$fAlternativeIO3;

GHC.Base.$fAlternativeIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [GHC.Base.$fApplicativeIO
                                           GHC.Base.$fAlternativeIO_$cempty
                                           GHC.IO.mplusIO
                                           GHC.Base.$fAlternativeIO2
                                           GHC.Base.$fAlternativeIO_$cmany];

GHC.Base.$fMonadPlusIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [GHC.Base.$fAlternativeIO
                                         GHC.Base.$fMonadIO
                                         GHC.Base.$fAlternativeIO_$cempty
                                         GHC.IO.mplusIO];

GHC.Base.$fAlternativeMaybe_$c<|>
  :: forall a.
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s8qi r_s8qj]
        case ds_s8qi of wild_s8qk {
          GHC.Base.Nothing -> r_s8qj;
          GHC.Base.Just _ [Occ=Dead] -> wild_s8qk;
        };

GHC.Base.$fApplicativeMaybe_$cliftA2
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s8qm ds_s8qn ds1_s8qo]
        case ds_s8qn of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s8qq [Occ=Once] ->
              case ds1_s8qo of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just y_s8qs [Occ=Once] ->
                    let {
                      sat_s8qt [Occ=Once] :: c_a4L9
                      [LclId] =
                          [f_s8qm x_s8qq y_s8qs] \u [] f_s8qm x_s8qq y_s8qs;
                    } in  GHC.Base.Just [sat_s8qt];
              };
        };

GHC.Base.$fApplicativeMaybe_$c*>
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s8qu m2_s8qv]
        case ds_s8qu of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> m2_s8qv;
        };

GHC.Base.$fApplicative(->)_$c<*>
  :: forall a1 a2 b. (a1 -> a2 -> b) -> (a1 -> a2) -> a1 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_s8qy g_s8qz x_s8qA]
        let {
          sat_s8qB [Occ=Once] :: a1_a4LL
          [LclId] =
              [g_s8qz x_s8qA] \u [] g_s8qz x_s8qA;
        } in  f_s8qy x_s8qA sat_s8qB;

GHC.Base.$fApplicative(->)_$cliftA2
  :: forall a1 a2 b c.
     (a2 -> b -> c) -> (a1 -> a2) -> (a1 -> b) -> a1 -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [q_s8qC f_s8qD g_s8qE x_s8qF]
        let {
          sat_s8qH [Occ=Once] :: b_a4LS
          [LclId] =
              [g_s8qE x_s8qF] \u [] g_s8qE x_s8qF; } in
        let {
          sat_s8qG [Occ=Once] :: a1_a4LR
          [LclId] =
              [f_s8qD x_s8qF] \u [] f_s8qD x_s8qF;
        } in  q_s8qC sat_s8qG sat_s8qH;

GHC.Base.$fApplicative(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Applicative ((->) a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctor(->)
                                           GHC.Base.const
                                           GHC.Base.$fApplicative(->)_$c<*>
                                           GHC.Base.$fApplicative(->)_$cliftA2
                                           GHC.Base.$fApplicative(->)_$c*>
                                           GHC.Base.$fApplicative(->)_$c<*];

lvl1_r7PK :: forall r a. [GHC.Types.Char] -> r -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s8qI] GHC.Err.errorWithoutStackTrace eta_s8qI;

GHC.Base.$fMonad(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall r. GHC.Base.Monad ((->) r)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicative(->)
                                     GHC.Base.$fMonad(->)_$c>>=
                                     GHC.Base.$fMonad(->)_$c>>
                                     GHC.Base.const
                                     lvl1_r7PK];

GHC.Base.$fApplicativeMaybe_$cfmap
  :: forall a b. (a -> b) -> GHC.Base.Maybe a -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s8qJ ds1_s8qK]
        case ds1_s8qK of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_s8qM [Occ=Once] ->
              let {
                sat_s8qN [Occ=Once] :: b_a4MF
                [LclId] =
                    [ds_s8qJ a1_s8qM] \u [] ds_s8qJ a1_s8qM;
              } in  GHC.Base.Just [sat_s8qN];
        };

GHC.Base.$fFunctorMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       GHC.Base.$fFunctorMaybe_$c<$];

GHC.Base.$fApplicativeMaybe_$c<*>
  :: forall a b.
     GHC.Base.Maybe (a -> b) -> GHC.Base.Maybe a -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s8qO m_s8qP]
        case ds_s8qO of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just f_s8qR [Occ=Once] ->
              GHC.Base.$fApplicativeMaybe_$cfmap f_s8qR m_s8qP;
        };

GHC.Base.$fApplicativeMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctorMaybe
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           GHC.Base.$fApplicativeMaybe_$c*>
                                           GHC.Base.$fApplicativeMaybe_$c<*];

GHC.Base.$fMonadMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicativeMaybe
                                     GHC.Base.$fMonadMaybe_$c>>=
                                     GHC.Base.$fApplicativeMaybe_$c*>
                                     GHC.Base.Just
                                     GHC.Base.$fMonadMaybe_$cfail];

GHC.Base.$fAlternativeMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [GHC.Base.$fApplicativeMaybe
                                           GHC.Base.Nothing
                                           GHC.Base.$fAlternativeMaybe_$c<|>
                                           GHC.Base.$fAlternativeMaybe_$csome
                                           GHC.Base.$fAlternativeMaybe_$cmany];

GHC.Base.$fMonadPlusMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [GHC.Base.$fAlternativeMaybe
                                         GHC.Base.$fMonadMaybe
                                         GHC.Base.Nothing
                                         GHC.Base.$fAlternativeMaybe_$c<|>];

GHC.Base.liftA3_$sliftA3 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_s8qS a_s8qT b_s8qU c_s8qV]
        case a_s8qT of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_s8qX [Occ=Once] ->
              case b_s8qU of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just y_s8qZ [Occ=Once] ->
                    case c_s8qV of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just a4_s8r1 [Occ=Once] ->
                          let {
                            sat_s8r2 [Occ=Once] :: r_a4gI
                            [LclId] =
                                [f_s8qS x_s8qX y_s8qZ a4_s8r1] \u [] f_s8qS x_s8qX y_s8qZ a4_s8r1;
                          } in  GHC.Base.Just [sat_s8r2];
                    };
              };
        };

GHC.Base.liftA3 [InlPrag=INLINABLE]
  :: forall (f :: * -> *) a b c d.
     GHC.Base.Applicative f =>
     (a -> b -> c -> d) -> f a -> f b -> f c -> f d
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(A,A,1*C1(C1(U)),1*C1(C1(C1(U))),A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s8r3 f1_s8r4 a1_s8r5 b1_s8r6 c1_s8r7]
        let {
          sat_s8r8 [Occ=Once] :: f_a4f9 (c_a4fc -> d_a4fd)
          [LclId] =
              [$dApplicative_s8r3 f1_s8r4 a1_s8r5 b1_s8r6] \u []
                  GHC.Base.liftA2 $dApplicative_s8r3 f1_s8r4 a1_s8r5 b1_s8r6;
        } in  GHC.Base.<*> $dApplicative_s8r3 sat_s8r8 c1_s8r7;

GHC.Base.liftA_$sliftA [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Base.Maybe a1 -> GHC.Base.Maybe r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fApplicativeMaybe_$cfmap eta_B2 eta_B1;

GHC.Base.liftA [InlPrag=INLINABLE]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> b) -> f a -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(A,1*C1(U),1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s8r9 f1_s8ra a1_s8rb]
        let {
          sat_s8rc [Occ=Once] :: f_a4gQ (a_a4gR -> b_a4gS)
          [LclId] =
              [$dApplicative_s8r9 f1_s8ra] \u []
                  GHC.Base.pure $dApplicative_s8r9 f1_s8ra;
        } in  GHC.Base.<*> $dApplicative_s8r9 sat_s8rc a1_s8rb;

GHC.Base.$fFunctor(,)_$cfmap
  :: forall a1 a2 b. (a2 -> b) -> (a1, a2) -> (a1, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_s8rd ds_s8re]
        case ds_s8re of {
          (,) x_s8rg [Occ=Once] y_s8rh [Occ=Once] ->
              let {
                sat_s8ri [Occ=Once] :: b_a4N0
                [LclId] =
                    [f_s8rd y_s8rh] \u [] f_s8rd y_s8rh;
              } in  (,) [x_s8rg sat_s8ri];
        };

GHC.Base.$fFunctor(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Functor ((,) a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctor(,)_$cfmap
                                       GHC.Base.$fFunctor(,)_$c<$];

GHC.Base.$fApplicative(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid a => GHC.Base.Applicative ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,A),1*U,A,A)>m] =
    [] \r [$dMonoid_s8rj]
        let {
          lvl3_s8rk [Occ=OnceL] :: a_a4vv
          [LclId] =
              [$dMonoid_s8rj] \u [] GHC.Base.mempty $dMonoid_s8rj; } in
        let {
          sat_s8rq [Occ=Once]
            :: forall a b. (a_a4vv, a) -> (a_a4vv, b) -> (a_a4vv, a)
          [LclId] =
              [$dMonoid_s8rj] \r [eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$c<* $dMonoid_s8rj eta_B2 eta_B1; } in
        let {
          sat_s8rp [Occ=Once]
            :: forall a b. (a_a4vv, a) -> (a_a4vv, b) -> (a_a4vv, b)
          [LclId] =
              [$dMonoid_s8rj] \r [eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$c*> $dMonoid_s8rj eta_B2 eta_B1; } in
        let {
          sat_s8ro [Occ=Once]
            :: forall a b c.
               (a -> b -> c) -> (a_a4vv, a) -> (a_a4vv, b) -> (a_a4vv, c)
          [LclId] =
              [$dMonoid_s8rj] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$cliftA2
                      $dMonoid_s8rj eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s8rn [Occ=Once]
            :: forall a b. (a_a4vv, a -> b) -> (a_a4vv, a) -> (a_a4vv, b)
          [LclId] =
              [$dMonoid_s8rj] \r [eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$c<*> $dMonoid_s8rj eta_B2 eta_B1; } in
        let {
          sat_s8rm [Occ=Once] :: forall a. a -> (a_a4vv, a)
          [LclId] =
              [lvl3_s8rk] \r [x_s8rl] (,) [lvl3_s8rk x_s8rl];
        } in 
          GHC.Base.C:Applicative [GHC.Base.$fFunctor(,)
                                  sat_s8rm
                                  sat_s8rn
                                  sat_s8ro
                                  sat_s8rp
                                  sat_s8rq];

lvl2_r7PL :: forall a1 a2. [GHC.Types.Char] -> (a1, a2)
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s8rr] GHC.Err.errorWithoutStackTrace eta_s8rr;

GHC.Base.$fMonad(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid a => GHC.Base.Monad ((,) a)
[GblId[DFunId], Arity=1, Str=<L,U(U(C(C1(U)),A,A),U,A,A)>m] =
    [] \r [$dMonoid_s8rs]
        let {
          lvl3_s8rt [Occ=OnceL] :: a_a4ul
          [LclId] =
              [$dMonoid_s8rs] \u [] GHC.Base.mempty $dMonoid_s8rs; } in
        let {
          sat_s8ry [Occ=Once] :: forall a. a -> (a_a4ul, a)
          [LclId] =
              [lvl3_s8rt] \r [x_s8rx] (,) [lvl3_s8rt x_s8rx]; } in
        let {
          sat_s8rw [Occ=Once]
            :: forall a b. (a_a4ul, a) -> (a_a4ul, b) -> (a_a4ul, b)
          [LclId] =
              [$dMonoid_s8rs] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonad(,)_$c>> $dMonoid_s8rs eta_B2 eta_B1; } in
        let {
          sat_s8rv [Occ=Once]
            :: forall a b. (a_a4ul, a) -> (a -> (a_a4ul, b)) -> (a_a4ul, b)
          [LclId] =
              [$dMonoid_s8rs] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonad(,)_$c>>= $dMonoid_s8rs eta_B2 eta_B1; } in
        let {
          sat_s8ru [Occ=Once] :: GHC.Base.Applicative ((,) a_a4ul)
          [LclId] =
              [$dMonoid_s8rs] \u [] GHC.Base.$fApplicative(,) $dMonoid_s8rs;
        } in 
          GHC.Base.C:Monad [sat_s8ru sat_s8rv sat_s8rw sat_s8ry lvl2_r7PL];

GHC.Base.C:Monad
  :: forall (m :: * -> *).
     GHC.Base.Applicative m =>
     (forall a b. m a -> (a -> m b) -> m b)
     -> (forall a b. m a -> m b -> m b)
     -> (forall a. a -> m a)
     -> (forall a. GHC.Base.String -> m a)
     -> GHC.Base.Monad m
[GblId[DataCon],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Monad [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.C:Functor
  :: forall (f :: * -> *).
     (forall a b. (a -> b) -> f a -> f b)
     -> (forall a b. a -> f b -> f a) -> GHC.Base.Functor f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.C:Functor [eta_B2 eta_B1];

GHC.Base.C:Applicative
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     (forall a. a -> f a)
     -> (forall a b. f (a -> b) -> f a -> f b)
     -> (forall a b c. (a -> b -> c) -> f a -> f b -> f c)
     -> (forall a b. f a -> f b -> f b)
     -> (forall a b. f a -> f b -> f a)
     -> GHC.Base.Applicative f
[GblId[DataCon],
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Applicative [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.C:Semigroup
  :: forall a.
     (a -> a -> a)
     -> (GHC.Base.NonEmpty a -> a)
     -> (forall b. GHC.Real.Integral b => b -> a -> a)
     -> GHC.Base.Semigroup a
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Semigroup [eta_B3 eta_B2 eta_B1];

GHC.Base.C:Monoid
  :: forall a.
     GHC.Base.Semigroup a =>
     a -> (a -> a -> a) -> ([a] -> a) -> GHC.Base.Monoid a
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Monoid [eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.Nothing :: forall a. GHC.Base.Maybe a
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Nothing! [];

GHC.Base.Just :: forall a. a -> GHC.Base.Maybe a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.Just [eta_B1];

GHC.Base.O :: forall a. a -> GHC.Base.Opaque
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.O [eta_B1];

GHC.Base.:| :: forall a. a -> [a] -> GHC.Base.NonEmpty a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.:| [eta_B2 eta_B1];

GHC.Base.C:MonadPlus
  :: forall (m :: * -> *).
     (GHC.Base.Alternative m, GHC.Base.Monad m) =>
     (forall a. m a)
     -> (forall a. m a -> m a -> m a) -> GHC.Base.MonadPlus m
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:MonadPlus [eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.C:Alternative
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     (forall a. f a)
     -> (forall a. f a -> f a -> f a)
     -> (forall a. f a -> f [a])
     -> (forall a. f a -> f [a])
     -> GHC.Base.Alternative f
[GblId[DataCon],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Alternative [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];


==================== Pre unarise: ====================
2018-03-16 15:54:55.998183342 UTC

GHC.Base.$p1Monad
  :: forall (m :: * -> *). GHC.Base.Monad m => GHC.Base.Applicative m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>] =
    [] \r [v_sgJ5]
        case v_sgJ5 of {
          GHC.Base.C:Monad v_sgJ7 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_sgJ7;
        };

GHC.Base.>>=
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. m a -> (a -> m b) -> m b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>] =
    [] \r [v_sgJc]
        case v_sgJc of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           v_sgJf [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_sgJf;
        };

GHC.Base.>>
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. m a -> m b -> m b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>] =
    [] \r [v_sgJj]
        case v_sgJj of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_sgJn [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_sgJn;
        };

GHC.Base.return
  :: forall (m :: * -> *). GHC.Base.Monad m => forall a. a -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>] =
    [] \r [v_sgJq]
        case v_sgJq of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_sgJv [Occ=Once]
                           _ [Occ=Dead] ->
              v_sgJv;
        };

GHC.Base.fail
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a. GHC.Base.String -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>] =
    [] \r [v_sgJx]
        case v_sgJx of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_sgJD [Occ=Once] ->
              v_sgJD;
        };

GHC.Base.fmap
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     forall a b. (a -> b) -> f a -> f b
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sgJE]
        case v_sgJE of {
          GHC.Base.C:Functor v_sgJG [Occ=Once] _ [Occ=Dead] -> v_sgJG;
        };

GHC.Base.<$
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     forall a b. a -> f b -> f a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sgJI]
        case v_sgJI of {
          GHC.Base.C:Functor _ [Occ=Dead] v_sgJL [Occ=Once] -> v_sgJL;
        };

GHC.Base.$p1Applicative
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Base.Functor f
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>] =
    [] \r [v_sgJM]
        case v_sgJM of {
          GHC.Base.C:Applicative v_sgJO [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgJO;
        };

GHC.Base.pure
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a. a -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>] =
    [] \r [v_sgJU]
        case v_sgJU of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 v_sgJX [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgJX;
        };

GHC.Base.<*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f (a -> b) -> f a -> f b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>] =
    [] \r [v_sgK2]
        case v_sgK2 of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgK6 [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgK6;
        };

GHC.Base.liftA2
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b c. (a -> b -> c) -> f a -> f b -> f c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>] =
    [] \r [v_sgKa]
        case v_sgKa of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgKf [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgKf;
        };

GHC.Base.*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>] =
    [] \r [v_sgKi]
        case v_sgKi of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgKo [Occ=Once]
                                 _ [Occ=Dead] ->
              v_sgKo;
        };

GHC.Base.<*
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>] =
    [] \r [v_sgKq]
        case v_sgKq of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgKx [Occ=Once] ->
              v_sgKx;
        };

GHC.Base.<> :: forall a. GHC.Base.Semigroup a => a -> a -> a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sgKy]
        case v_sgKy of {
          GHC.Base.C:Semigroup v_sgKA [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
              v_sgKA;
        };

GHC.Base.sconcat
  :: forall a. GHC.Base.Semigroup a => GHC.Base.NonEmpty a -> a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sgKD]
        case v_sgKD of {
          GHC.Base.C:Semigroup _ [Occ=Dead] v_sgKG [Occ=Once] _ [Occ=Dead] ->
              v_sgKG;
        };

GHC.Base.stimes
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b. GHC.Real.Integral b => b -> a -> a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sgKI]
        case v_sgKI of {
          GHC.Base.C:Semigroup _ [Occ=Dead] _ [Occ=Dead] v_sgKM [Occ=Once] ->
              v_sgKM;
        };

GHC.Base.$p1Monoid
  :: forall a. GHC.Base.Monoid a => GHC.Base.Semigroup a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sgKN]
        case v_sgKN of {
          GHC.Base.C:Monoid v_sgKP [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
              v_sgKP;
        };

GHC.Base.mempty :: forall a. GHC.Base.Monoid a => a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sgKT]
        case v_sgKT of {
          GHC.Base.C:Monoid _ [Occ=Dead]
                            v_sgKW [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
              v_sgKW;
        };

GHC.Base.mappend :: forall a. GHC.Base.Monoid a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sgKZ]
        case v_sgKZ of {
          GHC.Base.C:Monoid _ [Occ=Dead]
                            _ [Occ=Dead]
                            v_sgL3 [Occ=Once]
                            _ [Occ=Dead] ->
              v_sgL3;
        };

GHC.Base.mconcat :: forall a. GHC.Base.Monoid a => [a] -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sgL5]
        case v_sgL5 of {
          GHC.Base.C:Monoid _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            v_sgLa [Occ=Once] ->
              v_sgLa;
        };

GHC.Base.$p1MonadPlus
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Base.Alternative m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sgLb]
        case v_sgLb of {
          GHC.Base.C:MonadPlus v_sgLd [Occ=Once]
                               _ [Occ=Dead]
                               _ [Occ=Dead]
                               _ [Occ=Dead] ->
              v_sgLd;
        };

GHC.Base.$p2MonadPlus
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => GHC.Base.Monad m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sgLh]
        case v_sgLh of {
          GHC.Base.C:MonadPlus _ [Occ=Dead]
                               v_sgLk [Occ=Once]
                               _ [Occ=Dead]
                               _ [Occ=Dead] ->
              v_sgLk;
        };

GHC.Base.mzero
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => forall a. m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sgLn]
        case v_sgLn of {
          GHC.Base.C:MonadPlus _ [Occ=Dead]
                               _ [Occ=Dead]
                               v_sgLr [Occ=Once]
                               _ [Occ=Dead] ->
              v_sgLr;
        };

GHC.Base.mplus
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a. m a -> m a -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sgLt]
        case v_sgLt of {
          GHC.Base.C:MonadPlus _ [Occ=Dead]
                               _ [Occ=Dead]
                               _ [Occ=Dead]
                               v_sgLy [Occ=Once] ->
              v_sgLy;
        };

GHC.Base.$p1Alternative
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     GHC.Base.Applicative f
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>] =
    [] \r [v_sgLz]
        case v_sgLz of {
          GHC.Base.C:Alternative v_sgLB [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgLB;
        };

GHC.Base.empty
  :: forall (f :: * -> *). GHC.Base.Alternative f => forall a. f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>] =
    [] \r [v_sgLG]
        case v_sgLG of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 v_sgLJ [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgLJ;
        };

GHC.Base.<|>
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f a -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>] =
    [] \r [v_sgLN]
        case v_sgLN of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgLR [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgLR;
        };

GHC.Base.some
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>] =
    [] \r [v_sgLU]
        case v_sgLU of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgLZ [Occ=Once]
                                 _ [Occ=Dead] ->
              v_sgLZ;
        };

GHC.Base.many
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>] =
    [] \r [v_sgM1]
        case v_sgM1 of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgM7 [Occ=Once] ->
              v_sgM7;
        };

GHC.Base.eqString [Occ=LoopBreaker]
  :: GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgM8 ds1_sgM9]
        case ds_sgM8 of {
          [] ->
              case ds1_sgM9 of {
                [] -> GHC.Types.True [];
                : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
              };
          : c1_sgMe [Occ=Once!] cs1_sgMf [Occ=Once] ->
              case ds1_sgM9 of {
                [] -> GHC.Types.False [];
                : c2_sgMh [Occ=Once!] cs2_sgMi [Occ=Once] ->
                    case c1_sgMe of {
                      GHC.Types.C# x_sgMk [Occ=Once] ->
                          case c2_sgMh of {
                            GHC.Types.C# y_sgMm [Occ=Once] ->
                                case eqChar# [x_sgMk y_sgMm] of {
                                  __DEFAULT -> GHC.Types.False [];
                                  1# -> GHC.Base.eqString cs1_sgMf cs2_sgMi;
                                };
                          };
                    };
              };
        };

GHC.Base.when2
  :: GHC.Types.Bool
     -> GHC.Types.IO ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [p_sgMo s_sgMp eta_sgMq]
        case p_sgMo of {
          GHC.Types.False -> (#,#) [eta_sgMq GHC.Tuple.()];
          GHC.Types.True -> s_sgMp eta_sgMq;
        };

GHC.Base.when_$swhen1 [InlPrag=INLINABLE]
  :: GHC.Types.Bool -> GHC.Types.IO () -> GHC.Types.IO ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] GHC.Base.when2 eta_B3 eta_B2 eta_B1;

GHC.Base.$fFunctorIO2
  :: forall a b.
     (a -> b)
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_sgMs x_sgMt s_sgMu]
        case x_sgMt s_sgMu of {
          (#,#) ipv_sgMw [Occ=Once] ipv1_sgMx [Occ=Once] ->
              let {
                sat_sgMy [Occ=Once] :: b_a4qK
                [LclId] =
                    [f_sgMs ipv1_sgMx] \u [] f_sgMs ipv1_sgMx;
              } in  (#,#) [ipv_sgMw sat_sgMy];
        };

GHC.Base.$fFunctorIO1
  :: forall a b.
     a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S(SL)),1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [x_sgMz eta_sgMA eta1_sgMB]
        case eta_sgMA eta1_sgMB of {
          (#,#) ipv_sgMD [Occ=Once] _ [Occ=Dead] -> (#,#) [ipv_sgMD x_sgMz];
        };

GHC.Base.$fFunctorIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.Types.IO
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctorIO2
                                       GHC.Base.$fFunctorIO1];

GHC.Base.$fAlternativeMaybe1 :: forall a. GHC.Base.Maybe [a]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [GHC.Types.[]];

GHC.Base.$fAlternativeMaybe_$cmany
  :: forall a. GHC.Base.Maybe a -> GHC.Base.Maybe [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sgMF]
        let {
          many_v_sgMG [Occ=LoopBreaker] :: GHC.Base.Maybe [a_a4IZ]
          [LclId] =
              [v_sgMF many_v_sgMG] \u []
                  case v_sgMF of {
                    GHC.Base.Nothing -> GHC.Base.$fAlternativeMaybe1;
                    GHC.Base.Just x_sgMI [Occ=Once] ->
                        case many_v_sgMG of {
                          GHC.Base.Nothing -> GHC.Base.$fAlternativeMaybe1;
                          GHC.Base.Just y_sgMK [Occ=Once] ->
                              let {
                                sat_sgML [Occ=Once] :: [a_a4IZ]
                                [LclId] =
                                    CCCS :! [x_sgMI y_sgMK];
                              } in  GHC.Base.Just [sat_sgML];
                        };
                  };
        } in  many_v_sgMG;

GHC.Base.$fAlternativeMaybe_$csome
  :: forall a. GHC.Base.Maybe a -> GHC.Base.Maybe [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sgMM]
        let {
          some_v_sgMN [Occ=LoopBreaker] :: GHC.Base.Maybe [a_a4IR]
          [LclId] =
              [v_sgMM some_v_sgMN] \u []
                  case v_sgMM of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sgMP [Occ=Once*] ->
                        case some_v_sgMN of {
                          GHC.Base.Nothing ->
                              let {
                                sat_sgMR [Occ=Once] :: [a_a4IR]
                                [LclId] =
                                    CCCS :! [x_sgMP GHC.Types.[]];
                              } in  GHC.Base.Just [sat_sgMR];
                          GHC.Base.Just ipv_sgMS [Occ=Once] ->
                              let {
                                sat_sgMT [Occ=Once] :: [a_a4IR]
                                [LclId] =
                                    CCCS :! [x_sgMP ipv_sgMS];
                              } in  GHC.Base.Just [sat_sgMT];
                        };
                  };
        } in  some_v_sgMN;

GHC.Base.ap_$sap [InlPrag=INLINABLE]
  :: forall a b.
     GHC.Base.Maybe (a -> b) -> GHC.Base.Maybe a -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sgMU m2_sgMV]
        case m1_sgMU of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sgMX [Occ=Once!] ->
              case m2_sgMV of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sgMZ [Occ=Once] ->
                    let {
                      sat_sgN0 [Occ=Once] :: b_a447
                      [LclId] =
                          [x_sgMX x1_sgMZ] \u [] x_sgMX x1_sgMZ;
                    } in  GHC.Base.Just [sat_sgN0];
              };
        };

GHC.Base.liftM5_$sliftM5 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe a4
     -> GHC.Base.Maybe a5
     -> GHC.Base.Maybe r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><S,1*U><L,1*U><L,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgN1 m1_sgN2 m2_sgN3 m3_sgN4 m4_sgN5 m5_sgN6]
        case m1_sgN2 of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sgN8 [Occ=Once] ->
              case m2_sgN3 of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sgNa [Occ=Once] ->
                    case m3_sgN4 of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just x2_sgNc [Occ=Once] ->
                          case m4_sgN5 of {
                            GHC.Base.Nothing -> GHC.Base.Nothing [];
                            GHC.Base.Just x3_sgNe [Occ=Once] ->
                                case m5_sgN6 of {
                                  GHC.Base.Nothing -> GHC.Base.Nothing [];
                                  GHC.Base.Just x4_sgNg [Occ=Once] ->
                                      let {
                                        sat_sgNh [Occ=Once] :: r_a46A
                                        [LclId] =
                                            [f_sgN1 x_sgN8 x1_sgNa x2_sgNc x3_sgNe x4_sgNg] \u []
                                                f_sgN1 x_sgN8 x1_sgNa x2_sgNc x3_sgNe x4_sgNg;
                                      } in  GHC.Base.Just [sat_sgNh];
                                };
                          };
                    };
              };
        };

GHC.Base.liftM4_$sliftM4 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe a4
     -> GHC.Base.Maybe r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><S,1*U><L,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgNi m1_sgNj m2_sgNk m3_sgNl m4_sgNm]
        case m1_sgNj of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sgNo [Occ=Once] ->
              case m2_sgNk of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sgNq [Occ=Once] ->
                    case m3_sgNl of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just x2_sgNs [Occ=Once] ->
                          case m4_sgNm of {
                            GHC.Base.Nothing -> GHC.Base.Nothing [];
                            GHC.Base.Just x3_sgNu [Occ=Once] ->
                                let {
                                  sat_sgNv [Occ=Once] :: r_a48L
                                  [LclId] =
                                      [f_sgNi x_sgNo x1_sgNq x2_sgNs x3_sgNu] \u []
                                          f_sgNi x_sgNo x1_sgNq x2_sgNs x3_sgNu;
                                } in  GHC.Base.Just [sat_sgNv];
                          };
                    };
              };
        };

GHC.Base.liftM3_$sliftM3 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgNw m1_sgNx m2_sgNy m3_sgNz]
        case m1_sgNx of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sgNB [Occ=Once] ->
              case m2_sgNy of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sgND [Occ=Once] ->
                    case m3_sgNz of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just x2_sgNF [Occ=Once] ->
                          let {
                            sat_sgNG [Occ=Once] :: r_a4az
                            [LclId] =
                                [f_sgNw x_sgNB x1_sgND x2_sgNF] \u []
                                    f_sgNw x_sgNB x1_sgND x2_sgNF;
                          } in  GHC.Base.Just [sat_sgNG];
                    };
              };
        };

GHC.Base.liftM2_$sliftM2 [InlPrag=INLINABLE]
  :: forall a1 a2 r.
     (a1 -> a2 -> r)
     -> GHC.Base.Maybe a1 -> GHC.Base.Maybe a2 -> GHC.Base.Maybe r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgNH m1_sgNI m2_sgNJ]
        case m1_sgNI of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sgNL [Occ=Once] ->
              case m2_sgNJ of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sgNN [Occ=Once] ->
                    let {
                      sat_sgNO [Occ=Once] :: r_a4c0
                      [LclId] =
                          [f_sgNH x_sgNL x1_sgNN] \u [] f_sgNH x_sgNL x1_sgNN;
                    } in  GHC.Base.Just [sat_sgNO];
              };
        };

GHC.Base.liftM_$sliftM [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Base.Maybe a1 -> GHC.Base.Maybe r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgNP m1_sgNQ]
        case m1_sgNQ of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sgNS [Occ=Once] ->
              let {
                sat_sgNT [Occ=Once] :: r_a4d4
                [LclId] =
                    [f_sgNP x_sgNS] \u [] f_sgNP x_sgNS;
              } in  GHC.Base.Just [sat_sgNT];
        };

GHC.Base.when1 :: GHC.Base.Maybe ()
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [GHC.Tuple.()];

GHC.Base.when_$swhen [InlPrag=INLINABLE]
  :: GHC.Types.Bool -> GHC.Base.Maybe () -> GHC.Base.Maybe ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [p_sgNU s_sgNV]
        case p_sgNU of {
          GHC.Types.False -> GHC.Base.when1;
          GHC.Types.True -> s_sgNV;
        };

GHC.Base.when [InlPrag=INLINABLE]
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Types.Bool -> f () -> f ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U),A,A,A,A)><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgNX p_sgNY s_sgNZ]
        case p_sgNY of {
          GHC.Types.False -> GHC.Base.pure $dApplicative_sgNX GHC.Tuple.();
          GHC.Types.True -> s_sgNZ;
        };

GHC.Base.$fApplicativeMaybe_$c<*
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgO1 ds1_sgO2]
        case ds_sgO1 of wild_sgO3 {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] ->
              case ds1_sgO2 of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just _ [Occ=Dead] -> wild_sgO3;
              };
        };

GHC.Base.$tc'O3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'O"#;

GHC.Base.$tc'O2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'O3];

GHC.Base.$tcOpaque2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Opaque"#;

GHC.Base.$tcOpaque1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcOpaque2];

GHC.Base.$tcMonadPlus2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "MonadPlus"#;

GHC.Base.$tcMonadPlus1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMonadPlus2];

GHC.Base.$tcMonad2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Monad"#;

GHC.Base.$tcMonad1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMonad2];

GHC.Base.$tc'C:Monoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Monoid"#;

GHC.Base.$tc'C:Monoid2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'C:Monoid3];

GHC.Base.$tcMonoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Monoid"#;

GHC.Base.$tcMonoid2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMonoid3];

GHC.Base.$tcSemigroup2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Semigroup"#;

GHC.Base.$tcSemigroup1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcSemigroup2];

GHC.Base.$tc':|3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "':|"#;

GHC.Base.$tc':|2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc':|3];

GHC.Base.$tcNonEmpty2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty"#;

GHC.Base.$tcNonEmpty1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcNonEmpty2];

GHC.Base.$tcAlternative3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Alternative"#;

GHC.Base.$tcAlternative2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcAlternative3];

GHC.Base.$tcApplicative2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Applicative"#;

GHC.Base.$tcApplicative1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcApplicative2];

GHC.Base.$tcFunctor2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Functor"#;

GHC.Base.$tcFunctor1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcFunctor2];

GHC.Base.$tc'Just3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Just"#;

GHC.Base.$tc'Just2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'Just3];

GHC.Base.$tc'Nothing3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Nothing"#;

GHC.Base.$tc'Nothing2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'Nothing3];

GHC.Base.$tcMaybe2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Maybe"#;

GHC.Base.$tcMaybe1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMaybe2];

$krep_r7Pr :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_r7Ps :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep_r7Pr];

$krep2_r7Pt :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep1_r7Ps];

$krep3_r7Pu :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r7Pr GHC.Types.[]];

$krep4_r7Pv :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep3_r7Pu];

$krep5_r7Pw :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r7Pv $krep_r7Pr];

$krep6_r7Px :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.Base.$tcMonoid1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$* $krep6_r7Px];

GHC.Base.$tcAlternative1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep6_r7Px];

GHC.Base.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Base"#;

GHC.Base.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$trModule2];

GHC.Base.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Base.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$trModule4];

GHC.Base.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Base.$trModule3
                                     GHC.Base.$trModule1];

GHC.Base.$tcMaybe :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [625655543500963593##
                                    6391758309165051762##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMaybe1
                                    0#
                                    GHC.Types.krep$*Arr*];

GHC.Base.$tc'Nothing1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep3_r7Pu];

GHC.Base.$tc'Just1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr
                                         GHC.Base.$tc'Nothing1];

GHC.Base.$tc'Nothing :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14633289528184412192##
                                    12773126156421542470##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'Nothing2
                                    1#
                                    GHC.Base.$tc'Nothing1];

GHC.Base.$tc'Just :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5794512144280699493##
                                    9434423460978218117##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'Just2
                                    1#
                                    GHC.Base.$tc'Just1];

GHC.Base.$tcFunctor :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [211182333006544237##
                                    5556320544348084514##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcFunctor1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcApplicative :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12705055220831243597##
                                    2963353171490466073##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcApplicative1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcAlternative :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1073491102990665358##
                                    14320772755704808948##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcAlternative2
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcNonEmpty :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13207016872645468285##
                                    3455542966739695982##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcNonEmpty1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep7_r7Py :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcNonEmpty
                                              $krep3_r7Pu];

$krep8_r7Pz :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r7Pv $krep7_r7Py];

GHC.Base.$tc':|1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep8_r7Pz];

GHC.Base.$tc':| :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9440832435183810765##
                                    3053237465234607583##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc':|2
                                    1#
                                    GHC.Base.$tc':|1];

GHC.Base.$tcSemigroup :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16195352186364298277##
                                    3285685594139281062##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcSemigroup1
                                    0#
                                    GHC.Base.$tcMonoid1];

$krep9_r7PA :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcSemigroup
                                              $krep3_r7Pu];

GHC.Base.$tcMonoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13838560045895743776##
                                    1291018260833769143##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMonoid2
                                    0#
                                    GHC.Base.$tcMonoid1];

$krep10_r7PB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMonoid
                                              $krep3_r7Pu];

$krep11_r7PC :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r7Pw $krep10_r7PB];

$krep12_r7PD :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r7Pt $krep11_r7PC];

$krep13_r7PE :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep12_r7PD];

GHC.Base.$tc'C:Monoid1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep9_r7PA $krep13_r7PE];

GHC.Base.$tc'C:Monoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16099296089107510343##
                                    5895832073319104984##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'C:Monoid2
                                    1#
                                    GHC.Base.$tc'C:Monoid1];

GHC.Base.$tcMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3168880480603756299##
                                    8398240611646296094##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMonad1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcMonadPlus :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14115673251620372550##
                                    14155357326069389390##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMonadPlus1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcOpaque :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9339725405829241186##
                                    15550233501624900571##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcOpaque1
                                    0#
                                    GHC.Types.krep$*];

$krep14_r7PF :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcOpaque
                                              GHC.Types.[]];

GHC.Base.$tc'O1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep14_r7PF];

GHC.Base.$tc'O :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12551274612394834805##
                                    13000664474148134329##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'O2
                                    1#
                                    GHC.Base.$tc'O1];

GHC.Base.quotRemInt
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgO7 ds1_sgO8]
        case ds_sgO7 of {
          GHC.Types.I# x_sgOa [Occ=Once] ->
              case ds1_sgO8 of {
                GHC.Types.I# y_sgOc [Occ=Once] ->
                    case quotRemInt# [x_sgOa y_sgOc] of {
                      (#,#) ipv_sgOe [Occ=Once] ipv1_sgOf [Occ=Once] ->
                          let {
                            sat_sgOh [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [ipv1_sgOf]; } in
                          let {
                            sat_sgOg [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [ipv_sgOe];
                          } in  (,) [sat_sgOg sat_sgOh];
                    };
              };
        };

GHC.Base.modInt :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgOi ds1_sgOj]
        case ds_sgOi of {
          GHC.Types.I# x_sgOl [Occ=Once] ->
              case ds1_sgOj of {
                GHC.Types.I# y_sgOn [Occ=Once] ->
                    case GHC.Classes.modInt# x_sgOl y_sgOn of wild2_sgOo {
                      __DEFAULT -> GHC.Types.I# [wild2_sgOo];
                    };
              };
        };

GHC.Base.divInt :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgOp ds1_sgOq]
        case ds_sgOp of {
          GHC.Types.I# x_sgOs [Occ=Once] ->
              case ds1_sgOq of {
                GHC.Types.I# y_sgOu [Occ=Once] ->
                    case GHC.Classes.divInt# x_sgOs y_sgOu of wild2_sgOv {
                      __DEFAULT -> GHC.Types.I# [wild2_sgOv];
                    };
              };
        };

GHC.Base.remInt [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgOw ds1_sgOx]
        case ds_sgOw of {
          GHC.Types.I# x_sgOz [Occ=Once] ->
              case ds1_sgOx of {
                GHC.Types.I# y_sgOB [Occ=Once] ->
                    case remInt# [x_sgOz y_sgOB] of wild2_sgOC {
                      __DEFAULT -> GHC.Types.I# [wild2_sgOC];
                    };
              };
        };

GHC.Base.quotInt [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgOD ds1_sgOE]
        case ds_sgOD of {
          GHC.Types.I# x_sgOG [Occ=Once] ->
              case ds1_sgOE of {
                GHC.Types.I# y_sgOI [Occ=Once] ->
                    case quotInt# [x_sgOG y_sgOI] of wild2_sgOJ {
                      __DEFAULT -> GHC.Types.I# [wild2_sgOJ];
                    };
              };
        };

GHC.Base.getTag [InlPrag=INLINE (sat-args=1)]
  :: forall a. a -> GHC.Prim.Int#
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [eta_B1]
        case eta_B1 of sat_sgOK { __DEFAULT -> dataToTag# [sat_sgOK]; };

GHC.Base.$fMonadIO1
  :: forall a b.
     GHC.Types.IO a
     -> (a -> GHC.Types.IO b)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgOL k_sgOM s_sgON]
        case ds_sgOL s_sgON of {
          (#,#) ipv_sgOP [Occ=Once] ipv1_sgOQ [Occ=Once] ->
              k_sgOM ipv1_sgOQ ipv_sgOP;
        };

GHC.Base.bindIO
  :: forall a b.
     GHC.Types.IO a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Base.$fMonadIO1 eta_B3 eta_B2 eta_B1;

GHC.Base.$fApplicativeIO2
  :: forall a b.
     GHC.Types.IO a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgOR k_sgOS s_sgOT]
        case ds_sgOR s_sgOT of {
          (#,#) ipv_sgOV [Occ=Once] _ [Occ=Dead] -> k_sgOS ipv_sgOV;
        };

GHC.Base.thenIO
  :: forall a b. GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Base.$fApplicativeIO2 eta_B3 eta_B2 eta_B1;

GHC.Base.unIO1 :: forall a. GHC.Types.IO a -> GHC.Types.IO a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgOX] ds_sgOX;

GHC.Base.unIO
  :: forall a.
     GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.unIO1 eta_B1;

GHC.Base.$fApplicativeIO4
  :: forall a.
     a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [x_sgOY s_sgOZ] (#,#) [s_sgOZ x_sgOY];

GHC.Base.returnIO :: forall a. a -> GHC.Types.IO a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.$fApplicativeIO4 eta_B2 eta_B1;

GHC.Base.$fApplicativeIO3
  :: forall b a.
     GHC.Types.IO (a -> b)
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_sgP0 m2_sgP1 s_sgP2]
        case m1_sgP0 s_sgP2 of {
          (#,#) ipv_sgP4 [Occ=Once] ipv1_sgP5 [Occ=Once!] ->
              case m2_sgP1 ipv_sgP4 of {
                (#,#) ipv2_sgP7 [Occ=Once] ipv3_sgP8 [Occ=Once] ->
                    let {
                      sat_sgP9 [Occ=Once] :: b_a4Jk
                      [LclId] =
                          [ipv1_sgP5 ipv3_sgP8] \u [] ipv1_sgP5 ipv3_sgP8;
                    } in  (#,#) [ipv2_sgP7 sat_sgP9];
              };
        };

GHC.Base.liftA_$sliftA1 [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Types.IO a1 -> GHC.Types.IO r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Base.$fFunctorIO2 eta_B3 eta_B2 eta_B1;

GHC.Base.ap1
  :: forall a b.
     GHC.Types.IO (a -> b)
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_sgPa m2_sgPb s_sgPc]
        case m1_sgPa s_sgPc of {
          (#,#) ipv_sgPe [Occ=Once] ipv1_sgPf [Occ=Once!] ->
              case m2_sgPb ipv_sgPe of {
                (#,#) ipv2_sgPh [Occ=Once] ipv3_sgPi [Occ=Once] ->
                    let {
                      sat_sgPj [Occ=Once] :: b_a43H
                      [LclId] =
                          [ipv1_sgPf ipv3_sgPi] \u [] ipv1_sgPf ipv3_sgPi;
                    } in  (#,#) [ipv2_sgPh sat_sgPj];
              };
        };

GHC.Base.ap_$sap1 [InlPrag=INLINABLE]
  :: forall a b.
     GHC.Types.IO (a -> b) -> GHC.Types.IO a -> GHC.Types.IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] GHC.Base.ap1 eta_B3 eta_B2 eta_B1;

GHC.Base.ap [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     m (a -> b) -> m a -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgPk m1_sgPl m2_sgPm]
        let {
          sat_sgPr [Occ=Once] :: (a_a437 -> b_a438) -> m_a436 b_a438
          [LclId] =
              [$dMonad_sgPk m2_sgPm] \r [x1_sgPn]
                  let {
                    sat_sgPq [Occ=Once] :: a_a437 -> m_a436 b_a438
                    [LclId] =
                        [$dMonad_sgPk x1_sgPn] \r [x2_sgPo]
                            let {
                              sat_sgPp [Occ=Once] :: b_a438
                              [LclId] =
                                  [x1_sgPn x2_sgPo] \u [] x1_sgPn x2_sgPo;
                            } in  GHC.Base.return $dMonad_sgPk sat_sgPp;
                  } in  GHC.Base.>>= $dMonad_sgPk m2_sgPm sat_sgPq;
        } in  GHC.Base.>>= $dMonad_sgPk m1_sgPl sat_sgPr;

GHC.Base.liftM1
  :: forall a1 a2 r.
     (a1 -> a2 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_sgPs m1_sgPt m2_sgPu s_sgPv]
        case m1_sgPt s_sgPv of {
          (#,#) ipv_sgPx [Occ=Once] ipv1_sgPy [Occ=Once] ->
              case m2_sgPu ipv_sgPx of {
                (#,#) ipv2_sgPA [Occ=Once] ipv3_sgPB [Occ=Once] ->
                    let {
                      sat_sgPC [Occ=Once] :: r_a4br
                      [LclId] =
                          [f_sgPs ipv1_sgPy ipv3_sgPB] \u [] f_sgPs ipv1_sgPy ipv3_sgPB;
                    } in  (#,#) [ipv2_sgPA sat_sgPC];
              };
        };

GHC.Base.liftM2_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 r.
     (a1 -> a2 -> r)
     -> GHC.Types.IO a1 -> GHC.Types.IO a2 -> GHC.Types.IO r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.liftM1 eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.liftM2 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgPD f_sgPE m1_sgPF m2_sgPG]
        let {
          sat_sgPL [Occ=Once] :: a1_a4aI -> m_a4aH r_a4aK
          [LclId] =
              [$dMonad_sgPD f_sgPE m2_sgPG] \r [x1_sgPH]
                  let {
                    sat_sgPK [Occ=Once] :: a2_a4aJ -> m_a4aH r_a4aK
                    [LclId] =
                        [$dMonad_sgPD f_sgPE x1_sgPH] \r [x2_sgPI]
                            let {
                              sat_sgPJ [Occ=Once] :: r_a4aK
                              [LclId] =
                                  [f_sgPE x1_sgPH x2_sgPI] \u [] f_sgPE x1_sgPH x2_sgPI;
                            } in  GHC.Base.return $dMonad_sgPD sat_sgPJ;
                  } in  GHC.Base.>>= $dMonad_sgPD m2_sgPG sat_sgPK;
        } in  GHC.Base.>>= $dMonad_sgPD m1_sgPF sat_sgPL;

$cliftA2_r7PG
  :: forall c b a.
     (a -> b -> c)
     -> GHC.Types.IO a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, c #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    sat-only [] \r [f_sgPM m1_sgPN m2_sgPO s_sgPP]
        case m1_sgPN s_sgPP of {
          (#,#) ipv_sgPR [Occ=Once] ipv1_sgPS [Occ=Once] ->
              case m2_sgPO ipv_sgPR of {
                (#,#) ipv2_sgPU [Occ=Once] ipv3_sgPV [Occ=Once] ->
                    let {
                      sat_sgPW [Occ=Once] :: c_a4Jw
                      [LclId] =
                          [f_sgPM ipv1_sgPS ipv3_sgPV] \u [] f_sgPM ipv1_sgPS ipv3_sgPV;
                    } in  (#,#) [ipv2_sgPU sat_sgPW];
              };
        };

GHC.Base.$fApplicativeIO_$cliftA2 [InlPrag=INLINE (sat-args=0)]
  :: forall a b c.
     (a -> b -> c) -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        $cliftA2_r7PG eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.liftA1
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_sgPX a_sgPY b_sgPZ c_sgQ0 eta_sgQ1]
        case a_sgPY eta_sgQ1 of {
          (#,#) ipv_sgQ3 [Occ=Once] ipv1_sgQ4 [Occ=Once] ->
              case b_sgPZ ipv_sgQ3 of {
                (#,#) ipv2_sgQ6 [Occ=Once] ipv3_sgQ7 [Occ=Once] ->
                    case c_sgQ0 ipv2_sgQ6 of {
                      (#,#) ipv4_sgQ9 [Occ=Once] ipv5_sgQa [Occ=Once] ->
                          let {
                            sat_sgQb [Occ=Once] :: r_a4g0
                            [LclId] =
                                [f_sgPX ipv1_sgQ4 ipv3_sgQ7 ipv5_sgQa] \u []
                                    f_sgPX ipv1_sgQ4 ipv3_sgQ7 ipv5_sgQa;
                          } in  (#,#) [ipv4_sgQ9 sat_sgQb];
                    };
              };
        };

GHC.Base.liftA3_$sliftA1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.liftA1 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.$fSemigroupIO2
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Types.IO a
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sgQc eta_sgQd eta1_sgQe eta2_sgQf]
        case eta_sgQd eta2_sgQf of {
          (#,#) ipv_sgQh [Occ=Once] ipv1_sgQi [Occ=Once] ->
              case eta1_sgQe ipv_sgQh of {
                (#,#) ipv2_sgQk [Occ=Once] ipv3_sgQl [Occ=Once] ->
                    let {
                      sat_sgQm [Occ=Once] :: a_a4Al
                      [LclId] =
                          [$dSemigroup_sgQc ipv1_sgQi ipv3_sgQl] \u []
                              GHC.Base.<> $dSemigroup_sgQc ipv1_sgQi ipv3_sgQl;
                    } in  (#,#) [ipv2_sgQk sat_sgQm];
              };
        };

GHC.Base.$w$csconcat4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Types.IO a
     -> [GHC.Types.IO a]
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><C(S),1*C1(U(U,U))><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgQn ww_sgQo ww1_sgQp w1_sgQq]
        let {
          go_sgQr [Occ=LoopBreaker]
            :: GHC.Types.IO a_s6Fu
               -> [GHC.Types.IO a_s6Fu]
               -> GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, a_s6Fu #)
          [LclId,
           Arity=3,
           Str=<C(S),1*C1(U(U,U))><S,1*U><S,U>,
           Unf=OtherCon []] =
              sat-only [w_sgQn go_sgQr] \r [b_sgQs ds_sgQt eta_sgQu]
                  case ds_sgQt of {
                    [] -> b_sgQs eta_sgQu;
                    : c_sgQw [Occ=Once] cs_sgQx [Occ=Once] ->
                        case b_sgQs eta_sgQu of {
                          (#,#) ipv_sgQz [Occ=Once] ipv1_sgQA [Occ=Once] ->
                              case go_sgQr c_sgQw cs_sgQx ipv_sgQz of {
                                (#,#) ipv2_sgQC [Occ=Once] ipv3_sgQD [Occ=Once] ->
                                    let {
                                      sat_sgQE [Occ=Once] :: a_s6Fu
                                      [LclId] =
                                          [w_sgQn ipv1_sgQA ipv3_sgQD] \u []
                                              GHC.Base.<> w_sgQn ipv1_sgQA ipv3_sgQD;
                                    } in  (#,#) [ipv2_sgQC sat_sgQE];
                              };
                        };
                  };
        } in  go_sgQr ww_sgQo ww1_sgQp w1_sgQq;

GHC.Base.$fSemigroupIO1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (GHC.Types.IO a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(C(S)S),1*U(1*C1(U(U,U)),1*U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgQF w1_sgQG w2_sgQH]
        case w1_sgQG of {
          GHC.Base.:| ww1_sgQJ [Occ=Once] ww2_sgQK [Occ=Once] ->
              GHC.Base.$w$csconcat4 w_sgQF ww1_sgQJ ww2_sgQK w2_sgQH;
        };

GHC.Base.$fSemigroupIO [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (GHC.Types.IO a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,A)>m] =
    [] \r [$dSemigroup_sgQL]
        let {
          sat_sgQO [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> GHC.Types.IO a_X4J3 -> GHC.Types.IO a_X4J3
          [LclId] =
              [$dSemigroup_sgQL] \r [eta_B1]
                  GHC.Base.$fSemigroupIO_$cstimes $dSemigroup_sgQL eta_B1; } in
        let {
          sat_sgQN [Occ=Once]
            :: GHC.Base.NonEmpty (GHC.Types.IO a_X4J3) -> GHC.Types.IO a_X4J3
          [LclId] =
              [$dSemigroup_sgQL] \r [eta_B2 eta_B1]
                  GHC.Base.$fSemigroupIO1 $dSemigroup_sgQL eta_B2 eta_B1; } in
        let {
          sat_sgQM [Occ=Once]
            :: GHC.Types.IO a_X4J3
               -> GHC.Types.IO a_X4J3 -> GHC.Types.IO a_X4J3
          [LclId] =
              [$dSemigroup_sgQL] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroupIO2 $dSemigroup_sgQL eta_B3 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_sgQM sat_sgQN sat_sgQO];
GHC.Base.$fSemigroupIO_$cstimes [Occ=LoopBreaker]
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b.
     GHC.Real.Integral b =>
     b -> GHC.Types.IO a -> GHC.Types.IO a
[GblId, Arity=2, Str=<L,U(C(C1(U)),A,A)><L,U>, Unf=OtherCon []] =
    [] \r [$dSemigroup_sgQP $dIntegral_sgQQ]
        let {
          sat_sgQR [Occ=Once] :: GHC.Base.Semigroup (GHC.Types.IO a_X4J4)
          [LclId] =
              [$dSemigroup_sgQP] \u [] GHC.Base.$fSemigroupIO $dSemigroup_sgQP;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_sgQQ sat_sgQR;

GHC.Base.$fMonoidIO_$cp1Monoid
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (GHC.Types.IO a)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(C(C1(U)),A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgQS]
        let {
          sat_sgQT [Occ=Once, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_X4I6
          [LclId] =
              [$dMonoid_sgQS] \u [] GHC.Base.$p1Monoid $dMonoid_sgQS;
        } in  GHC.Base.$fSemigroupIO sat_sgQT;

$cmappend_r7PH
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Types.IO a
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dMonoid_sgQU eta_sgQV eta1_sgQW eta2_sgQX]
        case eta_sgQV eta2_sgQX of {
          (#,#) ipv_sgQZ [Occ=Once] ipv1_sgR0 [Occ=Once] ->
              case eta1_sgQW ipv_sgQZ of {
                (#,#) ipv2_sgR2 [Occ=Once] ipv3_sgR3 [Occ=Once] ->
                    let {
                      sat_sgR5 [Occ=Once] :: a_X4I8
                      [LclId] =
                          [$dMonoid_sgQU ipv1_sgR0 ipv3_sgR3] \u []
                              case GHC.Base.$p1Monoid $dMonoid_sgQU of sat_sgR4 {
                                __DEFAULT -> GHC.Base.<> sat_sgR4 ipv1_sgR0 ipv3_sgR3;
                              };
                    } in  (#,#) [ipv2_sgR2 sat_sgR5];
              };
        };

GHC.Base.$fMonoidIO_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Types.IO a -> GHC.Types.IO a -> GHC.Types.IO a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        $cmappend_r7PH eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.$fAlternativeIO1
  :: forall a.
     GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [s_sgR6] (#,#) [s_sgR6 GHC.Types.[]];

GHC.Base.$fAlternativeIO2
  :: forall a.
     GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a] #)
[GblId, Arity=2, Str=<C(S(SL)),C(U(U,U))><S,U>, Unf=OtherCon []] =
    [] \r [v_sgR7 eta_sgR8]
        let {
          some_v_sgR9 [Occ=LoopBreaker]
            :: GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a_a4HN] #)
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              [v_sgR7 some_v_sgR9] \r [s_sgRa]
                  case v_sgR7 s_sgRa of {
                    (#,#) ipv_sgRc [Occ=Once] ipv1_sgRd [Occ=Once] ->
                        case
                            GHC.IO.mplusIO some_v_sgR9 GHC.Base.$fAlternativeIO1 ipv_sgRc
                        of
                        { (#,#) ipv2_sgRf [Occ=Once] ipv3_sgRg [Occ=Once] ->
                              let {
                                sat_sgRh [Occ=Once] :: [a_a4HN]
                                [LclId] =
                                    CCCS :! [ipv1_sgRd ipv3_sgRg];
                              } in  (#,#) [ipv2_sgRf sat_sgRh];
                        };
                  };
        } in  some_v_sgR9 eta_sgR8;

GHC.Base.$fAlternativeIO_$cmany
  :: forall a. GHC.Types.IO a -> GHC.Types.IO [a]
[GblId, Arity=1, Str=<L,C(U(U,U))>, Unf=OtherCon []] =
    [] \r [v_sgRi]
        let {
          many_v_sgRj [Occ=LoopBreaker] :: GHC.Types.IO [a_a4HV]
          [LclId] =
              [v_sgRi many_v_sgRj] \u []
                  let {
                    sat_sgRs [Occ=Once] :: GHC.Types.IO [a_a4HV]
                    [LclId] =
                        [v_sgRi many_v_sgRj] \r [s_sgRk]
                            case v_sgRi s_sgRk of {
                              (#,#) ipv_sgRm [Occ=Once] ipv1_sgRn [Occ=Once] ->
                                  case many_v_sgRj ipv_sgRm of {
                                    (#,#) ipv2_sgRp [Occ=Once] ipv3_sgRq [Occ=Once] ->
                                        let {
                                          sat_sgRr [Occ=Once] :: [a_a4HV]
                                          [LclId] =
                                              CCCS :! [ipv1_sgRn ipv3_sgRq];
                                        } in  (#,#) [ipv2_sgRp sat_sgRr];
                                  };
                            };
                  } in  GHC.IO.mplusIO sat_sgRs GHC.Base.$fAlternativeIO1;
        } in  many_v_sgRj;

GHC.Base.liftM9
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Types.IO a5
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_sgRt m1_sgRu m2_sgRv m3_sgRw m4_sgRx m5_sgRy s_sgRz]
        case m1_sgRu s_sgRz of {
          (#,#) ipv_sgRB [Occ=Once] ipv1_sgRC [Occ=Once] ->
              case m2_sgRv ipv_sgRB of {
                (#,#) ipv2_sgRE [Occ=Once] ipv3_sgRF [Occ=Once] ->
                    case m3_sgRw ipv2_sgRE of {
                      (#,#) ipv4_sgRH [Occ=Once] ipv5_sgRI [Occ=Once] ->
                          case m4_sgRx ipv4_sgRH of {
                            (#,#) ipv6_sgRK [Occ=Once] ipv7_sgRL [Occ=Once] ->
                                case m5_sgRy ipv6_sgRK of {
                                  (#,#) ipv8_sgRN [Occ=Once] ipv9_sgRO [Occ=Once] ->
                                      let {
                                        sat_sgRP [Occ=Once] :: r_a45A
                                        [LclId] =
                                            [f_sgRt
                                             ipv1_sgRC
                                             ipv3_sgRF
                                             ipv5_sgRI
                                             ipv7_sgRL
                                             ipv9_sgRO] \u []
                                                f_sgRt
                                                    ipv1_sgRC
                                                    ipv3_sgRF
                                                    ipv5_sgRI
                                                    ipv7_sgRL
                                                    ipv9_sgRO;
                                      } in  (#,#) [ipv8_sgRN sat_sgRP];
                                };
                          };
                    };
              };
        };

GHC.Base.liftM5_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Types.IO a5
     -> GHC.Types.IO r
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.liftM9 eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.liftM5 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 a4 a5 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgRQ f_sgRR m1_sgRS m2_sgRT m3_sgRU m4_sgRV m5_sgRW]
        let {
          sat_sgS7 [Occ=Once] :: a1_a44e -> m_a44d r_a44j
          [LclId] =
              [$dMonad_sgRQ f_sgRR m2_sgRT m3_sgRU m4_sgRV m5_sgRW] \r [x1_sgRX]
                  let {
                    sat_sgS6 [Occ=Once] :: a2_a44f -> m_a44d r_a44j
                    [LclId] =
                        [$dMonad_sgRQ f_sgRR m3_sgRU m4_sgRV m5_sgRW x1_sgRX] \r [x2_sgRY]
                            let {
                              sat_sgS5 [Occ=Once] :: a3_a44g -> m_a44d r_a44j
                              [LclId] =
                                  [$dMonad_sgRQ f_sgRR m4_sgRV m5_sgRW x1_sgRX x2_sgRY] \r [x3_sgRZ]
                                      let {
                                        sat_sgS4 [Occ=Once] :: a4_a44h -> m_a44d r_a44j
                                        [LclId] =
                                            [$dMonad_sgRQ
                                             f_sgRR
                                             m5_sgRW
                                             x1_sgRX
                                             x2_sgRY
                                             x3_sgRZ] \r [x4_sgS0]
                                                let {
                                                  sat_sgS3 [Occ=Once] :: a5_a44i -> m_a44d r_a44j
                                                  [LclId] =
                                                      [$dMonad_sgRQ
                                                       f_sgRR
                                                       x1_sgRX
                                                       x2_sgRY
                                                       x3_sgRZ
                                                       x4_sgS0] \r [x5_sgS1]
                                                          let {
                                                            sat_sgS2 [Occ=Once] :: r_a44j
                                                            [LclId] =
                                                                [f_sgRR
                                                                 x1_sgRX
                                                                 x2_sgRY
                                                                 x3_sgRZ
                                                                 x4_sgS0
                                                                 x5_sgS1] \u []
                                                                    f_sgRR
                                                                        x1_sgRX
                                                                        x2_sgRY
                                                                        x3_sgRZ
                                                                        x4_sgS0
                                                                        x5_sgS1;
                                                          } in 
                                                            GHC.Base.return $dMonad_sgRQ sat_sgS2;
                                                } in  GHC.Base.>>= $dMonad_sgRQ m5_sgRW sat_sgS3;
                                      } in  GHC.Base.>>= $dMonad_sgRQ m4_sgRV sat_sgS4;
                            } in  GHC.Base.>>= $dMonad_sgRQ m3_sgRU sat_sgS5;
                  } in  GHC.Base.>>= $dMonad_sgRQ m2_sgRT sat_sgS6;
        } in  GHC.Base.>>= $dMonad_sgRQ m1_sgRS sat_sgS7;

GHC.Base.liftM8
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_sgS8 m1_sgS9 m2_sgSa m3_sgSb m4_sgSc s_sgSd]
        case m1_sgS9 s_sgSd of {
          (#,#) ipv_sgSf [Occ=Once] ipv1_sgSg [Occ=Once] ->
              case m2_sgSa ipv_sgSf of {
                (#,#) ipv2_sgSi [Occ=Once] ipv3_sgSj [Occ=Once] ->
                    case m3_sgSb ipv2_sgSi of {
                      (#,#) ipv4_sgSl [Occ=Once] ipv5_sgSm [Occ=Once] ->
                          case m4_sgSc ipv4_sgSl of {
                            (#,#) ipv6_sgSo [Occ=Once] ipv7_sgSp [Occ=Once] ->
                                let {
                                  sat_sgSq [Occ=Once] :: r_a47U
                                  [LclId] =
                                      [f_sgS8 ipv1_sgSg ipv3_sgSj ipv5_sgSm ipv7_sgSp] \u []
                                          f_sgS8 ipv1_sgSg ipv3_sgSj ipv5_sgSm ipv7_sgSp;
                                } in  (#,#) [ipv6_sgSo sat_sgSq];
                          };
                    };
              };
        };

GHC.Base.liftM4_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Types.IO r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.liftM8 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.liftM4 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 a4 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(C1(U))))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgSr f_sgSs m1_sgSt m2_sgSu m3_sgSv m4_sgSw]
        let {
          sat_sgSF [Occ=Once] :: a1_a46L -> m_a46K r_a46P
          [LclId] =
              [$dMonad_sgSr f_sgSs m2_sgSu m3_sgSv m4_sgSw] \r [x1_sgSx]
                  let {
                    sat_sgSE [Occ=Once] :: a2_a46M -> m_a46K r_a46P
                    [LclId] =
                        [$dMonad_sgSr f_sgSs m3_sgSv m4_sgSw x1_sgSx] \r [x2_sgSy]
                            let {
                              sat_sgSD [Occ=Once] :: a3_a46N -> m_a46K r_a46P
                              [LclId] =
                                  [$dMonad_sgSr f_sgSs m4_sgSw x1_sgSx x2_sgSy] \r [x3_sgSz]
                                      let {
                                        sat_sgSC [Occ=Once] :: a4_a46O -> m_a46K r_a46P
                                        [LclId] =
                                            [$dMonad_sgSr
                                             f_sgSs
                                             x1_sgSx
                                             x2_sgSy
                                             x3_sgSz] \r [x4_sgSA]
                                                let {
                                                  sat_sgSB [Occ=Once] :: r_a46P
                                                  [LclId] =
                                                      [f_sgSs x1_sgSx x2_sgSy x3_sgSz x4_sgSA] \u []
                                                          f_sgSs x1_sgSx x2_sgSy x3_sgSz x4_sgSA;
                                                } in  GHC.Base.return $dMonad_sgSr sat_sgSB;
                                      } in  GHC.Base.>>= $dMonad_sgSr m4_sgSw sat_sgSC;
                            } in  GHC.Base.>>= $dMonad_sgSr m3_sgSv sat_sgSD;
                  } in  GHC.Base.>>= $dMonad_sgSr m2_sgSu sat_sgSE;
        } in  GHC.Base.>>= $dMonad_sgSr m1_sgSt sat_sgSF;

GHC.Base.liftM3_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.liftA1 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

GHC.Base.liftM3 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(U)))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgSG f_sgSH m1_sgSI m2_sgSJ m3_sgSK]
        let {
          sat_sgSR [Occ=Once] :: a1_a48V -> m_a48U r_a48Y
          [LclId] =
              [$dMonad_sgSG f_sgSH m2_sgSJ m3_sgSK] \r [x1_sgSL]
                  let {
                    sat_sgSQ [Occ=Once] :: a2_a48W -> m_a48U r_a48Y
                    [LclId] =
                        [$dMonad_sgSG f_sgSH m3_sgSK x1_sgSL] \r [x2_sgSM]
                            let {
                              sat_sgSP [Occ=Once] :: a3_a48X -> m_a48U r_a48Y
                              [LclId] =
                                  [$dMonad_sgSG f_sgSH x1_sgSL x2_sgSM] \r [x3_sgSN]
                                      let {
                                        sat_sgSO [Occ=Once] :: r_a48Y
                                        [LclId] =
                                            [f_sgSH x1_sgSL x2_sgSM x3_sgSN] \u []
                                                f_sgSH x1_sgSL x2_sgSM x3_sgSN;
                                      } in  GHC.Base.return $dMonad_sgSG sat_sgSO;
                            } in  GHC.Base.>>= $dMonad_sgSG m3_sgSK sat_sgSP;
                  } in  GHC.Base.>>= $dMonad_sgSG m2_sgSJ sat_sgSQ;
        } in  GHC.Base.>>= $dMonad_sgSG m1_sgSI sat_sgSR;

GHC.Base.liftM_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Types.IO a1 -> GHC.Types.IO r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Base.$fFunctorIO2 eta_B3 eta_B2 eta_B1;

GHC.Base.liftM [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 r.
     GHC.Base.Monad m =>
     (a1 -> r) -> m a1 -> m r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgSS f_sgST m1_sgSU]
        let {
          sat_sgSX [Occ=Once] :: a1_a4c8 -> m_a4c7 r_a4c9
          [LclId] =
              [$dMonad_sgSS f_sgST] \r [x1_sgSV]
                  let {
                    sat_sgSW [Occ=Once] :: r_a4c9
                    [LclId] =
                        [f_sgST x1_sgSV] \u [] f_sgST x1_sgSV;
                  } in  GHC.Base.return $dMonad_sgSS sat_sgSW;
        } in  GHC.Base.>>= $dMonad_sgSS m1_sgSU sat_sgSX;

GHC.Base.$! :: forall a (b :: TYPE r). (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgSY x_sgSZ]
        case x_sgSZ of vx_sgT0 { __DEFAULT -> f_sgSY vx_sgT0; };

GHC.Base.$ [InlPrag=INLINE (sat-args=2)]
  :: forall a (b :: TYPE r). (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgT1 x_sgT2] f_sgT1 x_sgT2;

GHC.Base.flip :: forall a b c. (a -> b -> c) -> b -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgT3 x_sgT4 y_sgT5] f_sgT3 y_sgT5 x_sgT4;

GHC.Base.$fMonad(->)_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall r a b. (r -> a) -> (r -> b) -> r -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_sgT6 eta1_sgT7 r1_sgT8] eta1_sgT7 r1_sgT8;

GHC.Base.$fApplicative(->)_$c<*
  :: forall a1 a2 b. (a1 -> a2) -> (a1 -> b) -> a1 -> a2
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgT9 g_sgTa x_sgTb] f_sgT9 x_sgTb;

GHC.Base.$fMonad(,)_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,A)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgTc eta_sgTd eta1_sgTe]
        case eta_sgTd of {
          (,) u_sgTg [Occ=Once] _ [Occ=Dead] ->
              case eta1_sgTe of {
                (,) v_sgTj [Occ=Once] b1_sgTk [Occ=Once] ->
                    let {
                      sat_sgTm [Occ=Once] :: a_a4ul
                      [LclId] =
                          [$dMonoid_sgTc u_sgTg v_sgTj] \u []
                              case GHC.Base.$p1Monoid $dMonoid_sgTc of sat_sgTl {
                                __DEFAULT -> GHC.Base.<> sat_sgTl u_sgTg v_sgTj;
                              };
                    } in  (,) [sat_sgTm b1_sgTk];
              };
        };

GHC.Base.$fApplicative(,)_$c<*
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a, b) -> (a, a1)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><S,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgTn eta_sgTo eta1_sgTp]
        case eta_sgTo of {
          (,) u_sgTr [Occ=Once] x_sgTs [Occ=Once] ->
              case eta1_sgTp of {
                (,) v_sgTu [Occ=Once] _ [Occ=Dead] ->
                    let {
                      sat_sgTx [Occ=Once] :: a_a4vv
                      [LclId] =
                          [$dMonoid_sgTn u_sgTr v_sgTu] \u []
                              case GHC.Base.$p1Monoid $dMonoid_sgTn of sat_sgTw {
                                __DEFAULT -> GHC.Base.<> sat_sgTw u_sgTr v_sgTu;
                              };
                    } in  (,) [sat_sgTx x_sgTs];
              };
        };

GHC.Base.$fFunctor(,)_$c<$
  :: forall a1 a2 b. a2 -> (a1, b) -> (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [x_sgTy ds_sgTz]
        case ds_sgTz of {
          (,) x1_sgTB [Occ=Once] _ [Occ=Dead] -> (,) [x1_sgTB x_sgTy];
        };

GHC.Base.$fFunctorMaybe_$c<$
  :: forall a b. a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sgTD ds_sgTE]
        case ds_sgTE of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Base.Just [x_sgTD];
        };

GHC.Base.$dm<$
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     forall a b. a -> f b -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgTH eta_sgTI]
        let {
          sat_sgTK [Occ=Once] :: b_a4il -> a_a4ik
          [LclId] =
              [eta_sgTI] \r [ds_sgTJ] eta_sgTI;
        } in  GHC.Base.fmap $dFunctor_sgTH sat_sgTK;

GHC.Base.$fMonoid(->)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall b a. GHC.Base.Monoid b => (a -> b) -> (a -> b) -> a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgTL eta_sgTM eta1_sgTN eta2_sgTO]
        let {
          sat_sgTR [Occ=Once] :: b_a4zA
          [LclId] =
              [eta1_sgTN eta2_sgTO] \u [] eta1_sgTN eta2_sgTO; } in
        let {
          sat_sgTQ [Occ=Once] :: b_a4zA
          [LclId] =
              [eta_sgTM eta2_sgTO] \u [] eta_sgTM eta2_sgTO;
        } in 
          case GHC.Base.$p1Monoid $dMonoid_sgTL of sat_sgTP {
            __DEFAULT -> GHC.Base.<> sat_sgTP sat_sgTQ sat_sgTR;
          };

GHC.Base.$fMonoid(,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     (a, b) -> (a, b) -> (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgTS $dMonoid1_sgTT eta_sgTU eta1_sgTV]
        case eta_sgTU of {
          (,) a1_sgTX [Occ=Once] b1_sgTY [Occ=Once] ->
              case eta1_sgTV of {
                (,) a'_sgU0 [Occ=Once] b'_sgU1 [Occ=Once] ->
                    let {
                      sat_sgU5 [Occ=Once] :: b_a4yQ
                      [LclId] =
                          [$dMonoid1_sgTT b1_sgTY b'_sgU1] \u []
                              case GHC.Base.$p1Monoid $dMonoid1_sgTT of sat_sgU4 {
                                __DEFAULT -> GHC.Base.<> sat_sgU4 b1_sgTY b'_sgU1;
                              }; } in
                    let {
                      sat_sgU3 [Occ=Once] :: a_a4yP
                      [LclId] =
                          [$dMonoid_sgTS a1_sgTX a'_sgU0] \u []
                              case GHC.Base.$p1Monoid $dMonoid_sgTS of sat_sgU2 {
                                __DEFAULT -> GHC.Base.<> sat_sgU2 a1_sgTX a'_sgU0;
                              };
                    } in  (,) [sat_sgU3 sat_sgU5];
              };
        };

GHC.Base.$fSemigroupOrdering_go [Occ=LoopBreaker]
  :: GHC.Types.Ordering -> [GHC.Types.Ordering] -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sgU6 ds_sgU7]
        case ds_sgU7 of {
          [] -> b_sgU6;
          : c_sgU9 [Occ=Once] cs_sgUa [Occ=Once] ->
              case b_sgU6 of {
                GHC.Types.LT -> GHC.Types.LT [];
                GHC.Types.EQ -> GHC.Base.$fSemigroupOrdering_go c_sgU9 cs_sgUa;
                GHC.Types.GT -> GHC.Types.GT [];
              };
        };

GHC.Base.$fSemigroupOrdering_$csconcat
  :: GHC.Base.NonEmpty GHC.Types.Ordering -> GHC.Types.Ordering
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgUc]
        case ds_sgUc of {
          GHC.Base.:| a_sgUe [Occ=Once] as_sgUf [Occ=Once] ->
              GHC.Base.$fSemigroupOrdering_go a_sgUe as_sgUf;
        };

GHC.Base.. [InlPrag=INLINE (sat-args=2)]
  :: forall b c a. (b -> c) -> (a -> b) -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgUg g_sgUh x_sgUi]
        let {
          sat_sgUj [Occ=Once] :: b_a41v
          [LclId] =
              [g_sgUh x_sgUi] \u [] g_sgUh x_sgUi;
        } in  f_sgUg sat_sgUj;

GHC.Base.mapFB [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall elt lst a.
     (elt -> lst -> lst) -> (a -> elt) -> a -> lst -> lst
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c_sgUk f_sgUl x_sgUm ys_sgUn]
        let {
          sat_sgUo [Occ=Once] :: elt_a42v
          [LclId] =
              [f_sgUl x_sgUm] \u [] f_sgUl x_sgUm;
        } in  c_sgUk sat_sgUo ys_sgUn;

GHC.Base.$fFunctor(->)_$c<$
  :: forall r a b. a -> (r -> b) -> r -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgUp eta_sgUq eta1_sgUr] x_sgUp;

GHC.Base.$fFunctor(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall r. GHC.Base.Functor ((->) r)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base..
                                       GHC.Base.$fFunctor(->)_$c<$];

GHC.Base.const :: forall a b. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgUs ds_sgUt] x_sgUs;

GHC.Base.asTypeOf :: forall a. a -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.const eta_B2 eta_B1;

GHC.Base.$dm<*
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgUu]
        GHC.Base.liftA2 $dApplicative_sgUu GHC.Base.const;

GHC.Base.$fApplicativeIO1
  :: forall a b.
     GHC.Types.IO a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_sgUv m2_sgUw s_sgUx]
        case m1_sgUv s_sgUx of {
          (#,#) ipv_sgUz [Occ=Once] ipv1_sgUA [Occ=Once] ->
              case m2_sgUw ipv_sgUz of {
                (#,#) ipv2_sgUC [Occ=Once] _ [Occ=Dead] ->
                    (#,#) [ipv2_sgUC ipv1_sgUA];
              };
        };

GHC.Base.$fApplicativeIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctorIO
                                           GHC.Base.$fApplicativeIO4
                                           GHC.Base.$fApplicativeIO3
                                           GHC.Base.$fApplicativeIO_$cliftA2
                                           GHC.Base.$fApplicativeIO2
                                           GHC.Base.$fApplicativeIO1];

GHC.Base.breakpointCond :: forall a. GHC.Types.Bool -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgUE r_sgUF] r_sgUF;

GHC.Base.breakpoint :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [r_sgUG] r_sgUG;

GHC.Base.assert :: forall a. GHC.Types.Bool -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.breakpointCond eta_B2 eta_B1;

GHC.Base.id :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.breakpoint eta_B1;

GHC.Base.join
  :: forall (m :: * -> *) a. GHC.Base.Monad m => m (m a) -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgUH x_sgUI]
        GHC.Base.>>= $dMonad_sgUH x_sgUI GHC.Base.breakpoint;

GHC.Base.$dm<*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f (a -> b) -> f a -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgUJ]
        GHC.Base.liftA2 $dApplicative_sgUJ GHC.Base.breakpoint;

GHC.Base.$dm*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(1*U(A,1*C1(C1(U))),A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgUK eta_sgUL eta1_sgUM]
        let {
          sat_sgUO [Occ=Once] :: f_a37E (b_a4j2 -> b_a4j2)
          [LclId] =
              [$dApplicative_sgUK eta_sgUL] \u []
                  case GHC.Base.$p1Applicative $dApplicative_sgUK of sat_sgUN {
                    __DEFAULT -> GHC.Base.<$ sat_sgUN GHC.Base.breakpoint eta_sgUL;
                  };
        } in  GHC.Base.<*> $dApplicative_sgUK sat_sgUO eta1_sgUM;

GHC.Base.$fApplicative(->)_$c*>
  :: forall a1 a2 b. (a1 -> a2) -> (a1 -> b) -> a1 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [a2_sgUP a3_sgUQ x_sgUR] a3_sgUQ x_sgUR;

GHC.Base.maxInt :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [9223372036854775807#];

GHC.Base.minInt :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [-9223372036854775808#];

GHC.Base.ord :: GHC.Types.Char -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgUS]
        case ds_sgUS of {
          GHC.Types.C# c#_sgUU [Occ=Once] ->
              case ord# [c#_sgUU] of sat_sgUV {
                __DEFAULT -> GHC.Types.I# [sat_sgUV];
              };
        };

GHC.Base.unsafeChr :: GHC.Types.Int -> GHC.Types.Char
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgUW]
        case ds_sgUW of {
          GHC.Types.I# i#_sgUY [Occ=Once] ->
              case chr# [i#_sgUY] of sat_sgUZ {
                __DEFAULT -> GHC.Types.C# [sat_sgUZ];
              };
        };

GHC.Base.otherwise :: GHC.Types.Bool
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.True! [];

GHC.Base.until
  :: forall a. (a -> GHC.Types.Bool) -> (a -> a) -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [p_sgV0 f_sgV1 eta_sgV2]
        let-no-escape {
          go_sgV3 [Occ=LoopBreakerT[1]] :: a_a41W -> a_a41W
          [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [p_sgV0 f_sgV1 go_sgV3] \r [x_sgV4]
                  case p_sgV0 x_sgV4 of {
                    GHC.Types.False ->
                        let {
                          sat_sgV6 [Occ=Once] :: a_a41W
                          [LclId] =
                              [f_sgV1 x_sgV4] \u [] f_sgV1 x_sgV4;
                        } in  go_sgV3 sat_sgV6;
                    GHC.Types.True -> x_sgV4;
                  };
        } in  go_sgV3 eta_sgV2;

GHC.Base.divModInt#
  :: GHC.Prim.Int#
     -> GHC.Prim.Int# -> (# GHC.Prim.Int#, GHC.Prim.Int# #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [x#_sgV7 y#_sgV8]
        case ># [x#_sgV7 0#] of {
          __DEFAULT ->
              case <# [x#_sgV7 0#] of {
                __DEFAULT -> quotRemInt# [x#_sgV7 y#_sgV8];
                1# ->
                    case ># [y#_sgV8 0#] of {
                      __DEFAULT -> quotRemInt# [x#_sgV7 y#_sgV8];
                      1# ->
                          case +# [x#_sgV7 1#] of sat_sgVc {
                            __DEFAULT ->
                                case quotRemInt# [sat_sgVc y#_sgV8] of {
                                  (#,#) ipv_sgVe [Occ=Once] ipv1_sgVf [Occ=Once] ->
                                      case +# [ipv1_sgVf y#_sgV8] of sat_sgVh {
                                        __DEFAULT ->
                                            case -# [sat_sgVh 1#] of sat_sgVi {
                                              __DEFAULT ->
                                                  case -# [ipv_sgVe 1#] of sat_sgVg {
                                                    __DEFAULT -> (#,#) [sat_sgVg sat_sgVi];
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
          1# ->
              case <# [y#_sgV8 0#] of {
                __DEFAULT ->
                    case <# [x#_sgV7 0#] of {
                      __DEFAULT -> quotRemInt# [x#_sgV7 y#_sgV8];
                      1# ->
                          case ># [y#_sgV8 0#] of {
                            __DEFAULT -> quotRemInt# [x#_sgV7 y#_sgV8];
                            1# ->
                                case +# [x#_sgV7 1#] of sat_sgVm {
                                  __DEFAULT ->
                                      case quotRemInt# [sat_sgVm y#_sgV8] of {
                                        (#,#) ipv_sgVo [Occ=Once] ipv1_sgVp [Occ=Once] ->
                                            case +# [ipv1_sgVp y#_sgV8] of sat_sgVr {
                                              __DEFAULT ->
                                                  case -# [sat_sgVr 1#] of sat_sgVs {
                                                    __DEFAULT ->
                                                        case -# [ipv_sgVo 1#] of sat_sgVq {
                                                          __DEFAULT -> (#,#) [sat_sgVq sat_sgVs];
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
                1# ->
                    case -# [x#_sgV7 1#] of sat_sgVt {
                      __DEFAULT ->
                          case quotRemInt# [sat_sgVt y#_sgV8] of {
                            (#,#) ipv_sgVv [Occ=Once] ipv1_sgVw [Occ=Once] ->
                                case +# [ipv1_sgVw y#_sgV8] of sat_sgVy {
                                  __DEFAULT ->
                                      case +# [sat_sgVy 1#] of sat_sgVz {
                                        __DEFAULT ->
                                            case -# [ipv_sgVv 1#] of sat_sgVx {
                                              __DEFAULT -> (#,#) [sat_sgVx sat_sgVz];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Base.divModInt [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgVA w1_sgVB]
        case w_sgVA of {
          GHC.Types.I# ww1_sgVD ->
              case w1_sgVB of {
                GHC.Types.I# ww3_sgVF ->
                    case ># [ww1_sgVD 0#] of {
                      __DEFAULT ->
                          case <# [ww1_sgVD 0#] of {
                            __DEFAULT ->
                                case quotRemInt# [ww1_sgVD ww3_sgVF] of {
                                  (#,#) ipv_sgVJ [Occ=Once] ipv1_sgVK [Occ=Once] ->
                                      let {
                                        sat_sgVM [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv1_sgVK]; } in
                                      let {
                                        sat_sgVL [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv_sgVJ];
                                      } in  (,) [sat_sgVL sat_sgVM];
                                };
                            1# ->
                                case ># [ww3_sgVF 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww1_sgVD ww3_sgVF] of {
                                        (#,#) ipv_sgVP [Occ=Once] ipv1_sgVQ [Occ=Once] ->
                                            let {
                                              sat_sgVS [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_sgVQ]; } in
                                            let {
                                              sat_sgVR [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_sgVP];
                                            } in  (,) [sat_sgVR sat_sgVS];
                                      };
                                  1# ->
                                      case +# [ww1_sgVD 1#] of sat_sgVT {
                                        __DEFAULT ->
                                            case quotRemInt# [sat_sgVT ww3_sgVF] of {
                                              (#,#) ipv_sgVV [Occ=Once] ipv1_sgVW [Occ=Once] ->
                                                  case +# [ipv1_sgVW ww3_sgVF] of sat_sgVZ {
                                                    __DEFAULT ->
                                                        case -# [sat_sgVZ 1#] of sat_sgW0 {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_sgW1 [Occ=Once] :: GHC.Types.Int
                                                                [LclId] =
                                                                    CCCS GHC.Types.I#! [sat_sgW0];
                                                              } in 
                                                                case -# [ipv_sgVV 1#] of sat_sgVX {
                                                                  __DEFAULT ->
                                                                      let {
                                                                        sat_sgVY [Occ=Once]
                                                                          :: GHC.Types.Int
                                                                        [LclId] =
                                                                            CCCS GHC.Types.I#! [sat_sgVX];
                                                                      } in  (,) [sat_sgVY sat_sgW1];
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                      1# ->
                          case <# [ww3_sgVF 0#] of {
                            __DEFAULT ->
                                case <# [ww1_sgVD 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww1_sgVD ww3_sgVF] of {
                                        (#,#) ipv_sgW5 [Occ=Once] ipv1_sgW6 [Occ=Once] ->
                                            let {
                                              sat_sgW8 [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_sgW6]; } in
                                            let {
                                              sat_sgW7 [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_sgW5];
                                            } in  (,) [sat_sgW7 sat_sgW8];
                                      };
                                  1# ->
                                      case ># [ww3_sgVF 0#] of {
                                        __DEFAULT ->
                                            case quotRemInt# [ww1_sgVD ww3_sgVF] of {
                                              (#,#) ipv_sgWb [Occ=Once] ipv1_sgWc [Occ=Once] ->
                                                  let {
                                                    sat_sgWe [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv1_sgWc]; } in
                                                  let {
                                                    sat_sgWd [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv_sgWb];
                                                  } in  (,) [sat_sgWd sat_sgWe];
                                            };
                                        1# ->
                                            case +# [ww1_sgVD 1#] of sat_sgWf {
                                              __DEFAULT ->
                                                  case quotRemInt# [sat_sgWf ww3_sgVF] of {
                                                    (#,#) ipv_sgWh [Occ=Once]
                                                          ipv1_sgWi [Occ=Once] ->
                                                        case +# [ipv1_sgWi ww3_sgVF] of sat_sgWl {
                                                          __DEFAULT ->
                                                              case -# [sat_sgWl 1#] of sat_sgWm {
                                                                __DEFAULT ->
                                                                    let {
                                                                      sat_sgWn [Occ=Once]
                                                                        :: GHC.Types.Int
                                                                      [LclId] =
                                                                          CCCS GHC.Types.I#! [sat_sgWm];
                                                                    } in 
                                                                      case
                                                                          -# [ipv_sgWh 1#]
                                                                      of
                                                                      sat_sgWj
                                                                      { __DEFAULT ->
                                                                            let {
                                                                              sat_sgWk [Occ=Once]
                                                                                :: GHC.Types.Int
                                                                              [LclId] =
                                                                                  CCCS GHC.Types.I#! [sat_sgWj];
                                                                            } in 
                                                                              (,) [sat_sgWk
                                                                                   sat_sgWn];
                                                                      };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            1# ->
                                case -# [ww1_sgVD 1#] of sat_sgWo {
                                  __DEFAULT ->
                                      case quotRemInt# [sat_sgWo ww3_sgVF] of {
                                        (#,#) ipv_sgWq [Occ=Once] ipv1_sgWr [Occ=Once] ->
                                            case +# [ipv1_sgWr ww3_sgVF] of sat_sgWu {
                                              __DEFAULT ->
                                                  case +# [sat_sgWu 1#] of sat_sgWv {
                                                    __DEFAULT ->
                                                        let {
                                                          sat_sgWw [Occ=Once] :: GHC.Types.Int
                                                          [LclId] =
                                                              CCCS GHC.Types.I#! [sat_sgWv];
                                                        } in 
                                                          case -# [ipv_sgWq 1#] of sat_sgWs {
                                                            __DEFAULT ->
                                                                let {
                                                                  sat_sgWt [Occ=Once]
                                                                    :: GHC.Types.Int
                                                                  [LclId] =
                                                                      CCCS GHC.Types.I#! [sat_sgWs];
                                                                } in  (,) [sat_sgWt sat_sgWw];
                                                          };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Base.shiftL#
  :: GHC.Prim.Word# -> GHC.Prim.Int# -> GHC.Prim.Word#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_sgWx b_sgWy]
        case >=# [b_sgWy 64#] of {
          __DEFAULT -> uncheckedShiftL# [a_sgWx b_sgWy];
          1# -> 0##;
        };

GHC.Base.shiftRL#
  :: GHC.Prim.Word# -> GHC.Prim.Int# -> GHC.Prim.Word#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_sgWA b_sgWB]
        case >=# [b_sgWB 64#] of {
          __DEFAULT -> uncheckedShiftRL# [a_sgWA b_sgWB];
          1# -> 0##;
        };

GHC.Base.iShiftL#
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_sgWD b_sgWE]
        case >=# [b_sgWE 64#] of {
          __DEFAULT -> uncheckedIShiftL# [a_sgWD b_sgWE];
          1# -> 0#;
        };

GHC.Base.iShiftRA#
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [a_sgWG b_sgWH]
        case >=# [b_sgWH 64#] of {
          __DEFAULT -> uncheckedIShiftRA# [a_sgWG b_sgWH];
          1# ->
              case <# [a_sgWG 0#] of {
                __DEFAULT -> 0#;
                1# -> -1#;
              };
        };

GHC.Base.iShiftRL#
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_sgWK b_sgWL]
        case >=# [b_sgWL 64#] of {
          __DEFAULT -> uncheckedIShiftRL# [a_sgWK b_sgWL];
          1# -> 0#;
        };

GHC.Base.build [InlPrag=INLINE[1] (sat-args=1)]
  :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [g_sgWN] g_sgWN GHC.Types.: GHC.Types.[];

GHC.Base.$fApplicative[]_$cpure [InlPrag=INLINE (sat-args=1)]
  :: forall a. a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [x_sgWO] : [x_sgWO GHC.Types.[]];

GHC.Base.augment [InlPrag=INLINE[1] (sat-args=2)]
  :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [g_sgWP xs_sgWQ] g_sgWP GHC.Types.: xs_sgWQ;

GHC.Base.++ [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. [a] -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgWR ys_sgWS]
        case ds_sgWR of {
          [] -> ys_sgWS;
          : x_sgWU [Occ=Once] xs_sgWV [Occ=Once] ->
              let {
                sat_sgWW [Occ=Once] :: [a_a42r]
                [LclId] =
                    [ys_sgWS xs_sgWV] \u [] GHC.Base.++ xs_sgWV ys_sgWS;
              } in  : [x_sgWU sat_sgWW];
        };
GHC.Base.foldr [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sgWX z_sgWY eta_sgWZ]
        let {
          go_sgX0 [Occ=LoopBreaker] :: [a_a42N] -> b_a42O
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [k_sgWX z_sgWY go_sgX0] \r [ds_sgX1]
                  case ds_sgX1 of {
                    [] -> z_sgWY;
                    : y_sgX3 [Occ=Once] ys_sgX4 [Occ=Once] ->
                        let {
                          sat_sgX5 [Occ=Once] :: b_a42O
                          [LclId] =
                              [go_sgX0 ys_sgX4] \u [] go_sgX0 ys_sgX4;
                        } in  k_sgWX y_sgX3 sat_sgX5;
                  };
        } in  go_sgX0 eta_sgWZ;
GHC.Base.map [InlPrag=NOINLINE[0], Occ=LoopBreaker]
  :: forall a b. (a -> b) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgX6 ds1_sgX7]
        case ds1_sgX7 of {
          [] -> [] [];
          : x_sgX9 [Occ=Once] xs_sgXa [Occ=Once] ->
              let {
                sat_sgXc [Occ=Once] :: [b_a42A]
                [LclId] =
                    [ds_sgX6 xs_sgXa] \u [] GHC.Base.map ds_sgX6 xs_sgXa; } in
              let {
                sat_sgXb [Occ=Once] :: b_a42A
                [LclId] =
                    [ds_sgX6 x_sgX9] \u [] ds_sgX6 x_sgX9;
              } in  : [sat_sgXb sat_sgXc];
        };

GHC.Base.$fSemigroupNonEmpty_$c<>
  :: forall a.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,1*U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgXd ds1_sgXe]
        case ds_sgXd of {
          GHC.Base.:| a1_sgXg [Occ=Once] as_sgXh [Occ=Once] ->
              let {
                sat_sgXr [Occ=Once] :: [a_a4Fm]
                [LclId] =
                    [ds1_sgXe as_sgXh] \u []
                        let {
                          sat_sgXp [Occ=Once] :: [a_a4Fm]
                          [LclId] =
                              [ds1_sgXe] \u []
                                  case ds1_sgXe of {
                                    GHC.Base.:| _ [Occ=Dead] bs_sgXo [Occ=Once] -> bs_sgXo;
                                  }; } in
                        let {
                          sat_sgXl [Occ=Once] :: a_a4Fm
                          [LclId] =
                              [ds1_sgXe] \u []
                                  case ds1_sgXe of {
                                    GHC.Base.:| b_sgXj [Occ=Once] _ [Occ=Dead] -> b_sgXj;
                                  }; } in
                        let {
                          sat_sgXq [Occ=Once] :: [a_a4Fm]
                          [LclId] =
                              CCCS :! [sat_sgXl sat_sgXp];
                        } in  GHC.Base.++ as_sgXh sat_sgXq;
              } in  GHC.Base.:| [a1_sgXg sat_sgXr];
        };

GHC.Base.$wpoly_go [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. a -> [a] -> [GHC.Base.NonEmpty a] -> (# a, [a] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sgXs ww1_sgXt w_sgXu]
        case w_sgXu of {
          [] -> (#,#) [ww_sgXs ww1_sgXt];
          : c_sgXw [Occ=Once!] cs_sgXx [Occ=Once] ->
              let {
                sat_sgXO [Occ=Once] :: [a_s6GZ]
                [LclId] =
                    [ww1_sgXt c_sgXw cs_sgXx] \u []
                        let {
                          ds_sgXy [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty a_s6GZ
                          [LclId] =
                              [c_sgXw cs_sgXx] \u []
                                  case c_sgXw of {
                                    GHC.Base.:| ww3_sgXA [Occ=Once] ww4_sgXB [Occ=Once] ->
                                        case GHC.Base.$wpoly_go ww3_sgXA ww4_sgXB cs_sgXx of {
                                          (#,#) ww6_sgXD [Occ=Once] ww7_sgXE [Occ=Once] ->
                                              GHC.Base.:| [ww6_sgXD ww7_sgXE];
                                        };
                                  }; } in
                        let {
                          sat_sgXM [Occ=Once] :: [a_s6GZ]
                          [LclId] =
                              [ds_sgXy] \u []
                                  case ds_sgXy of {
                                    GHC.Base.:| _ [Occ=Dead] bs_sgXL [Occ=Once] -> bs_sgXL;
                                  }; } in
                        let {
                          sat_sgXI [Occ=Once] :: a_s6GZ
                          [LclId] =
                              [ds_sgXy] \u []
                                  case ds_sgXy of {
                                    GHC.Base.:| b_sgXG [Occ=Once] _ [Occ=Dead] -> b_sgXG;
                                  }; } in
                        let {
                          sat_sgXN [Occ=Once] :: [a_s6GZ]
                          [LclId] =
                              CCCS :! [sat_sgXI sat_sgXM];
                        } in  GHC.Base.++ ww1_sgXt sat_sgXN;
              } in  (#,#) [ww_sgXs sat_sgXO];
        };

GHC.Base.$fSemigroupNonEmpty1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.NonEmpty a -> [GHC.Base.NonEmpty a] -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sgXP w1_sgXQ]
        case w_sgXP of {
          GHC.Base.:| ww1_sgXS [Occ=Once] ww2_sgXT [Occ=Once] ->
              case GHC.Base.$wpoly_go ww1_sgXS ww2_sgXT w1_sgXQ of {
                (#,#) ww4_sgXV [Occ=Once] ww5_sgXW [Occ=Once] ->
                    GHC.Base.:| [ww4_sgXV ww5_sgXW];
              };
        };

GHC.Base.$fSemigroupNonEmpty_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (GHC.Base.NonEmpty a) -> GHC.Base.NonEmpty a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U(U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgXX]
        case ds_sgXX of {
          GHC.Base.:| a1_sgXZ [Occ=Once] as_sgY0 [Occ=Once] ->
              GHC.Base.$fSemigroupNonEmpty1 a1_sgXZ as_sgY0;
        };

GHC.Base.$fSemigroupNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (GHC.Base.NonEmpty a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.$fSemigroupNonEmpty_$c<>
                                         GHC.Base.$fSemigroupNonEmpty_$csconcat
                                         GHC.Base.$fSemigroupNonEmpty_$cstimes];
GHC.Base.$fSemigroupNonEmpty_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgY1]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_sgY1 GHC.Base.$fSemigroupNonEmpty;

GHC.Base.$fSemigroup[]1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sgY2 ds_sgY3]
        case ds_sgY3 of {
          [] -> b_sgY2;
          : c_sgY5 [Occ=Once] cs_sgY6 [Occ=Once] ->
              let {
                sat_sgY7 [Occ=Once, Dmd=<L,1*U>] :: [a_a4FL]
                [LclId] =
                    [c_sgY5 cs_sgY6] \s [] GHC.Base.$fSemigroup[]1 c_sgY5 cs_sgY6;
              } in  GHC.Base.++ b_sgY2 sat_sgY7;
        };

GHC.Base.$fSemigroup[]_$csconcat
  :: forall a. GHC.Base.NonEmpty [a] -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgY8]
        case ds_sgY8 of {
          GHC.Base.:| a1_sgYa [Occ=Once] as_sgYb [Occ=Once] ->
              GHC.Base.$fSemigroup[]1 a1_sgYa as_sgYb;
        };

GHC.Base.mapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> [a] -> m [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgYc eta_sgYd eta1_sgYe]
        let {
          z_sgYf [Occ=OnceL] :: m_a4da [b_a4dc]
          [LclId] =
              [$dMonad_sgYc] \u []
                  GHC.Base.return $dMonad_sgYc GHC.Types.[]; } in
        let {
          go_sgYg [Occ=LoopBreaker] :: [a_a4db] -> m_a4da [b_a4dc]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonad_sgYc eta_sgYd z_sgYf go_sgYg] \r [ds_sgYh]
                  case ds_sgYh of {
                    [] -> z_sgYf;
                    : y_sgYj [Occ=Once] ys_sgYk [Occ=Once] ->
                        let {
                          r_sgYl [Occ=OnceL] :: m_a4da [b_a4dc]
                          [LclId] =
                              [go_sgYg ys_sgYk] \u [] go_sgYg ys_sgYk; } in
                        let {
                          sat_sgYr [Occ=Once] :: b_a4dc -> m_a4da [b_a4dc]
                          [LclId] =
                              [$dMonad_sgYc r_sgYl] \r [x_sgYn]
                                  let {
                                    sat_sgYq [Occ=Once] :: [b_a4dc] -> m_a4da [b_a4dc]
                                    [LclId] =
                                        [$dMonad_sgYc x_sgYn] \r [xs_sgYo]
                                            let {
                                              sat_sgYp [Occ=Once] :: [b_a4dc]
                                              [LclId] =
                                                  CCCS :! [x_sgYn xs_sgYo];
                                            } in  GHC.Base.return $dMonad_sgYc sat_sgYp;
                                  } in  GHC.Base.>>= $dMonad_sgYc r_sgYl sat_sgYq; } in
                        let {
                          sat_sgYm [Occ=Once] :: m_a4da b_a4dc
                          [LclId] =
                              [eta_sgYd y_sgYj] \u [] eta_sgYd y_sgYj;
                        } in  GHC.Base.>>= $dMonad_sgYc sat_sgYm sat_sgYr;
                  };
        } in  go_sgYg eta1_sgYe;

GHC.Base.sequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. GHC.Base.Monad m => [m a] -> m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgYs eta_B1]
        GHC.Base.mapM $dMonad_sgYs GHC.Base.breakpoint eta_B1;

GHC.Base.$dmmconcat :: forall a. GHC.Base.Monoid a => [a] -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgYt eta_sgYu]
        let {
          z_sgYv [Occ=OnceL] :: a_a37Y
          [LclId] =
              [$dMonoid_sgYt] \u [] GHC.Base.mempty $dMonoid_sgYt; } in
        let {
          go_sgYw [Occ=LoopBreaker] :: [a_a37Y] -> a_a37Y
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_sgYt z_sgYv go_sgYw] \r [ds_sgYx]
                  case ds_sgYx of {
                    [] -> z_sgYv;
                    : y_sgYz [Occ=Once] ys_sgYA [Occ=Once] ->
                        let {
                          sat_sgYB [Occ=Once] :: a_a37Y
                          [LclId] =
                              [go_sgYw ys_sgYA] \u [] go_sgYw ys_sgYA;
                        } in  GHC.Base.mappend $dMonoid_sgYt y_sgYz sat_sgYB;
                  };
        } in  go_sgYw eta_sgYu;

GHC.Base.$fMonoid(->)_$cmconcat
  :: forall b a. GHC.Base.Monoid b => [a -> b] -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgYC eta_sgYD eta1_sgYE]
        let {
          lvl3_sgYF [Occ=OnceL] :: b_a4zA
          [LclId] =
              [$dMonoid_sgYC] \u [] GHC.Base.mempty $dMonoid_sgYC; } in
        let {
          $dSemigroup_sgYG [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_a4zA
          [LclId] =
              [$dMonoid_sgYC] \u [] GHC.Base.$p1Monoid $dMonoid_sgYC; } in
        let {
          go_sgYH [Occ=LoopBreaker] :: [a_a4zB -> b_a4zA] -> a_a4zB -> b_a4zA
          [LclId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
              sat-only [lvl3_sgYF $dSemigroup_sgYG go_sgYH] \r [ds_sgYI
                                                                eta2_sgYJ]
                  case ds_sgYI of {
                    [] -> lvl3_sgYF;
                    : y_sgYL [Occ=Once!] ys_sgYM [Occ=Once] ->
                        let {
                          sat_sgYO [Occ=Once] :: b_a4zA
                          [LclId] =
                              [go_sgYH eta2_sgYJ ys_sgYM] \u [] go_sgYH ys_sgYM eta2_sgYJ; } in
                        let {
                          sat_sgYN [Occ=Once] :: b_a4zA
                          [LclId] =
                              [eta2_sgYJ y_sgYL] \u [] y_sgYL eta2_sgYJ;
                        } in  GHC.Base.<> $dSemigroup_sgYG sat_sgYN sat_sgYO;
                  };
        } in  go_sgYH eta_sgYD eta1_sgYE;

GHC.Base.$fMonoidIO1
  :: forall a.
     GHC.Base.Monoid a =>
     [GHC.Types.IO a]
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgYP eta_sgYQ eta1_sgYR]
        let {
          $dSemigroup_sgYS [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_X4I9
          [LclId] =
              [$dMonoid_sgYP] \u [] GHC.Base.$p1Monoid $dMonoid_sgYP; } in
        let {
          lvl3_sgYT [Occ=OnceL] :: a_X4I9
          [LclId] =
              [$dMonoid_sgYP] \u [] GHC.Base.mempty $dMonoid_sgYP; } in
        let {
          go_sgYU [Occ=LoopBreaker]
            :: [GHC.Types.IO a_X4I9]
               -> GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, a_X4I9 #)
          [LclId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_sgYS lvl3_sgYT go_sgYU] \r [ds_sgYV
                                                                eta2_sgYW]
                  case ds_sgYV of {
                    [] -> (#,#) [eta2_sgYW lvl3_sgYT];
                    : y_sgYY [Occ=Once] ys_sgYZ [Occ=Once] ->
                        case y_sgYY eta2_sgYW of {
                          (#,#) ipv_sgZ1 [Occ=Once] ipv1_sgZ2 [Occ=Once] ->
                              case go_sgYU ys_sgYZ ipv_sgZ1 of {
                                (#,#) ipv2_sgZ4 [Occ=Once] ipv3_sgZ5 [Occ=Once] ->
                                    let {
                                      sat_sgZ6 [Occ=Once] :: a_X4I9
                                      [LclId] =
                                          [$dSemigroup_sgYS ipv1_sgZ2 ipv3_sgZ5] \u []
                                              GHC.Base.<> $dSemigroup_sgYS ipv1_sgZ2 ipv3_sgZ5;
                                    } in  (#,#) [ipv2_sgZ4 sat_sgZ6];
                              };
                        };
                  };
        } in  go_sgYU eta_sgYQ eta1_sgYR;

GHC.Base.$fMonoidIO [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid a => GHC.Base.Monoid (GHC.Types.IO a)
[GblId[DFunId], Arity=1, Str=<L,U(U(C(C1(U)),A,A),U,A,A)>m] =
    [] \r [$dMonoid_sgZ7]
        let {
          sat_sgZd [Occ=Once] :: [GHC.Types.IO a_X4I7] -> GHC.Types.IO a_X4I7
          [LclId] =
              [$dMonoid_sgZ7] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidIO1 $dMonoid_sgZ7 eta_B2 eta_B1; } in
        let {
          sat_sgZc [Occ=Once]
            :: GHC.Types.IO a_X4I7
               -> GHC.Types.IO a_X4I7 -> GHC.Types.IO a_X4I7
          [LclId] =
              [$dMonoid_sgZ7] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoidIO_$cmappend
                      $dMonoid_sgZ7 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_sgZb [Occ=Once] :: GHC.Types.IO a_X4I7
          [LclId] =
              [$dMonoid_sgZ7] \r [s_sgZ9]
                  let {
                    sat_sgZa [Occ=Once] :: a_X4I7
                    [LclId] =
                        [$dMonoid_sgZ7] \u [] GHC.Base.mempty $dMonoid_sgZ7;
                  } in  (#,#) [s_sgZ9 sat_sgZa]; } in
        let {
          sat_sgZ8 [Occ=Once] :: GHC.Base.Semigroup (GHC.Types.IO a_X4I7)
          [LclId] =
              [$dMonoid_sgZ7] \u [] GHC.Base.$fMonoidIO_$cp1Monoid $dMonoid_sgZ7;
        } in  GHC.Base.C:Monoid [sat_sgZ8 sat_sgZb sat_sgZc sat_sgZd];

GHC.Base.$fFunctor[]_$c<$ :: forall a b. a -> [b] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sgZe eta_sgZf]
        let {
          sat_sgZh [Occ=Once] :: b_a4Mt -> a_a4Ms
          [LclId] =
              [x_sgZe] \r [ds_sgZg] x_sgZe;
        } in  GHC.Base.map sat_sgZh eta_sgZf;

GHC.Base.$fFunctorNonEmpty_$c<$
  :: forall a b. a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,1*U(A,1*U)>m,
 Unf=OtherCon []] =
    [] \r [b1_sgZi ds_sgZj]
        let {
          sat_sgZp [Occ=Once] :: [a_a4Hj]
          [LclId] =
              [b1_sgZi ds_sgZj] \u []
                  case ds_sgZj of {
                    GHC.Base.:| _ [Occ=Dead] as_sgZm [Occ=Once] ->
                        let {
                          sat_sgZo [Occ=Once] :: b_a4Hk -> a_a4Hj
                          [LclId] =
                              [b1_sgZi] \r [ds2_sgZn] b1_sgZi;
                        } in  GHC.Base.map sat_sgZo as_sgZm;
                  };
        } in  GHC.Base.:| [b1_sgZi sat_sgZp];

GHC.Base.$fFunctor[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.map
                                       GHC.Base.$fFunctor[]_$c<$];

GHC.Base.$fMonad[]_$c>>= [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a] -> (a -> [b]) -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [xs_sgZq f_sgZr]
        let {
          go_sgZs [Occ=LoopBreaker] :: [a_a4rg] -> [b_a4rh]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_sgZr go_sgZs] \r [ds_sgZt]
                  case ds_sgZt of {
                    [] -> [] [];
                    : y_sgZv [Occ=Once] ys_sgZw [Occ=Once] ->
                        let {
                          sat_sgZy [Occ=Once, Dmd=<L,1*U>] :: [b_a4rh]
                          [LclId] =
                              [go_sgZs ys_sgZw] \s [] go_sgZs ys_sgZw;
                        } in 
                          case f_sgZr y_sgZv of sat_sgZx {
                            __DEFAULT -> GHC.Base.++ sat_sgZx sat_sgZy;
                          };
                  };
        } in  go_sgZs xs_sgZq;

GHC.Base.=<<_$s=<< :: forall a b. (a -> [b]) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgZz x_sgZA] GHC.Base.$fMonad[]_$c>>= x_sgZA f_sgZz;

GHC.Base.=<<
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> m a -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgZB f_sgZC x_sgZD]
        GHC.Base.>>= $dMonad_sgZB x_sgZD f_sgZC;

poly_go_r7PI :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds_sgZE]
        case ds_sgZE of {
          [] -> [] [];
          : y_sgZG [Occ=Once] ys_sgZH [Occ=Once] ->
              let {
                sat_sgZI [Occ=Once, Dmd=<L,1*U>] :: [a_a4zZ]
                [LclId] =
                    [ys_sgZH] \s [] poly_go_r7PI ys_sgZH;
              } in  GHC.Base.++ y_sgZG sat_sgZI;
        };

GHC.Base.$fMonoid[]_$cmconcat [InlPrag=INLINE (sat-args=1)]
  :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [xss_sgZJ] poly_go_r7PI xss_sgZJ;

GHC.Base.$fApplicative[]_$c<*> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a -> b] -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [fs_sgZK xs_sgZL]
        let {
          go_sgZM [Occ=LoopBreaker] :: [a_a4Ka -> b_a4Kb] -> [b_a4Kb]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [xs_sgZL go_sgZM] \r [ds_sgZN]
                  case ds_sgZN of {
                    [] -> [] [];
                    : y_sgZP [Occ=OnceL!] ys_sgZQ [Occ=Once] ->
                        let {
                          z_sgZR [Occ=OnceL] :: [b_a4Kb]
                          [LclId] =
                              [go_sgZM ys_sgZQ] \u [] go_sgZM ys_sgZQ; } in
                        let {
                          go1_sgZS [Occ=LoopBreaker] :: [a_a4Ka] -> [b_a4Kb]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [y_sgZP z_sgZR go1_sgZS] \r [ds1_sgZT]
                                  case ds1_sgZT of {
                                    [] -> z_sgZR;
                                    : y1_sgZV [Occ=Once] ys1_sgZW [Occ=Once] ->
                                        let {
                                          sat_sgZY [Occ=Once] :: [b_a4Kb]
                                          [LclId] =
                                              [go1_sgZS ys1_sgZW] \u [] go1_sgZS ys1_sgZW; } in
                                        let {
                                          sat_sgZX [Occ=Once] :: b_a4Kb
                                          [LclId] =
                                              [y_sgZP y1_sgZV] \u [] y_sgZP y1_sgZV;
                                        } in  : [sat_sgZX sat_sgZY];
                                  };
                        } in  go1_sgZS xs_sgZL;
                  };
        } in  go_sgZM fs_sgZK;

GHC.Base.$fApplicative[]_$cliftA2 [InlPrag=INLINE (sat-args=3)]
  :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgZZ xs_sh00 ys_sh01]
        let {
          go_sh02 [Occ=LoopBreaker] :: [a_a4Ki] -> [c_a4Kk]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_sgZZ ys_sh01 go_sh02] \r [ds_sh03]
                  case ds_sh03 of {
                    [] -> [] [];
                    : y_sh05 [Occ=OnceL] ys1_sh06 [Occ=Once] ->
                        let {
                          z_sh07 [Occ=OnceL] :: [c_a4Kk]
                          [LclId] =
                              [go_sh02 ys1_sh06] \u [] go_sh02 ys1_sh06; } in
                        let {
                          go1_sh08 [Occ=LoopBreaker] :: [b_a4Kj] -> [c_a4Kk]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [f_sgZZ y_sh05 z_sh07 go1_sh08] \r [ds1_sh09]
                                  case ds1_sh09 of {
                                    [] -> z_sh07;
                                    : y1_sh0b [Occ=Once] ys2_sh0c [Occ=Once] ->
                                        let {
                                          sat_sh0e [Occ=Once] :: [c_a4Kk]
                                          [LclId] =
                                              [go1_sh08 ys2_sh0c] \u [] go1_sh08 ys2_sh0c; } in
                                        let {
                                          sat_sh0d [Occ=Once] :: c_a4Kk
                                          [LclId] =
                                              [f_sgZZ y_sh05 y1_sh0b] \u [] f_sgZZ y_sh05 y1_sh0b;
                                        } in  : [sat_sh0d sat_sh0e];
                                  };
                        } in  go1_sh08 ys_sh01;
                  };
        } in  go_sh02 xs_sh00;

GHC.Base.$fApplicative[]_$c<* :: forall a b. [a] -> [b] -> [a]
[GblId, Arity=2, Caf=NoCafRefs, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fApplicative[]_$cliftA2 GHC.Base.const eta_B2 eta_B1;

GHC.Base.$fApplicative[]_$c*> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a] -> [b] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [xs_sh0f ys_sh0g]
        let {
          go_sh0h [Occ=LoopBreaker] :: [a_a4Kr] -> [b_a4Ks]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [ys_sh0g go_sh0h] \r [ds_sh0i]
                  case ds_sh0i of {
                    [] -> [] [];
                    : _ [Occ=Dead] ys1_sh0l [Occ=Once] ->
                        let {
                          sat_sh0m [Occ=Once, Dmd=<L,1*U>] :: [b_a4Ks]
                          [LclId] =
                              [go_sh0h ys1_sh0l] \s [] go_sh0h ys1_sh0l;
                        } in  GHC.Base.++ ys_sh0g sat_sh0m;
                  };
        } in  go_sh0h xs_sh0f;

GHC.Base.$fApplicative[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctor[]
                                           GHC.Base.$fApplicative[]_$cpure
                                           GHC.Base.$fApplicative[]_$c<*>
                                           GHC.Base.$fApplicative[]_$cliftA2
                                           GHC.Base.$fApplicative[]_$c*>
                                           GHC.Base.$fApplicative[]_$c<*];

GHC.Base.$fFunctorNonEmpty_$cfmap
  :: forall a b.
     (a -> b) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sh0n ds_sh0o]
        let {
          sat_sh0x [Occ=Once] :: [b_a4H8]
          [LclId] =
              [f_sh0n ds_sh0o] \u []
                  case ds_sh0o of {
                    GHC.Base.:| _ [Occ=Dead] as_sh0w [Occ=Once] ->
                        GHC.Base.map f_sh0n as_sh0w;
                  }; } in
        let {
          sat_sh0t [Occ=Once] :: b_a4H8
          [LclId] =
              [f_sh0n ds_sh0o] \u []
                  let {
                    sat_sh0s [Occ=Once] :: a_a4H7
                    [LclId] =
                        [ds_sh0o] \u []
                            case ds_sh0o of {
                              GHC.Base.:| a1_sh0q [Occ=Once] _ [Occ=Dead] -> a1_sh0q;
                            };
                  } in  f_sh0n sat_sh0s;
        } in  GHC.Base.:| [sat_sh0t sat_sh0x];

GHC.Base.$fFunctorNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctorNonEmpty_$cfmap
                                       GHC.Base.$fFunctorNonEmpty_$c<$];

GHC.Base.$fAlternative[]1 :: forall a. [[a]]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Types.[] GHC.Types.[]];

GHC.Base.$fAlternative[]_$csome :: forall a. [a] -> [[a]]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sh0y]
        let {
          some_v_sh0z [Occ=LoopBreaker] :: [[a_a4Ik]]
          [LclId] =
              [v_sh0y some_v_sh0z] \u []
                  let {
                    ys_sh0A [Occ=OnceL] :: [[a_a4Ik]]
                    [LclId] =
                        [some_v_sh0z] \u []
                            GHC.Base.++ some_v_sh0z GHC.Base.$fAlternative[]1; } in
                  let {
                    go_sh0B [Occ=LoopBreaker] :: [a_a4Ik] -> [[a_a4Ik]]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                        sat-only [ys_sh0A go_sh0B] \r [ds_sh0C]
                            case ds_sh0C of {
                              [] -> [] [];
                              : y_sh0E [Occ=OnceL] ys1_sh0F [Occ=Once] ->
                                  let {
                                    z_sh0G [Occ=OnceL] :: [[a_a4Ik]]
                                    [LclId] =
                                        [go_sh0B ys1_sh0F] \u [] go_sh0B ys1_sh0F; } in
                                  let {
                                    go1_sh0H [Occ=LoopBreaker] :: [[a_a4Ik]] -> [[a_a4Ik]]
                                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                        sat-only [y_sh0E z_sh0G go1_sh0H] \r [ds1_sh0I]
                                            case ds1_sh0I of {
                                              [] -> z_sh0G;
                                              : y1_sh0K [Occ=Once] ys2_sh0L [Occ=Once] ->
                                                  let {
                                                    sat_sh0N [Occ=Once] :: [[a_a4Ik]]
                                                    [LclId] =
                                                        [go1_sh0H ys2_sh0L] \u []
                                                            go1_sh0H ys2_sh0L; } in
                                                  let {
                                                    sat_sh0M [Occ=Once] :: [a_a4Ik]
                                                    [LclId] =
                                                        CCCS :! [y_sh0E y1_sh0K];
                                                  } in  : [sat_sh0M sat_sh0N];
                                            };
                                  } in  go1_sh0H ys_sh0A;
                            };
                  } in  go_sh0B v_sh0y;
        } in  some_v_sh0z;

GHC.Base.$fAlternative[]_$cmany :: forall a. [a] -> [[a]]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sh0O]
        let {
          many_v_sh0P [Occ=LoopBreaker] :: [[a_a4Is]]
          [LclId] =
              [v_sh0O many_v_sh0P] \u []
                  let {
                    go_sh0Q [Occ=LoopBreaker] :: [a_a4Is] -> [[a_a4Is]]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                        sat-only [many_v_sh0P go_sh0Q] \r [ds_sh0R]
                            case ds_sh0R of {
                              [] -> [] [];
                              : y_sh0T [Occ=OnceL] ys_sh0U [Occ=Once] ->
                                  let {
                                    z_sh0V [Occ=OnceL] :: [[a_a4Is]]
                                    [LclId] =
                                        [go_sh0Q ys_sh0U] \u [] go_sh0Q ys_sh0U; } in
                                  let {
                                    go1_sh0W [Occ=LoopBreaker] :: [[a_a4Is]] -> [[a_a4Is]]
                                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                        sat-only [y_sh0T z_sh0V go1_sh0W] \r [ds1_sh0X]
                                            case ds1_sh0X of {
                                              [] -> z_sh0V;
                                              : y1_sh0Z [Occ=Once] ys1_sh10 [Occ=Once] ->
                                                  let {
                                                    sat_sh12 [Occ=Once] :: [[a_a4Is]]
                                                    [LclId] =
                                                        [go1_sh0W ys1_sh10] \u []
                                                            go1_sh0W ys1_sh10; } in
                                                  let {
                                                    sat_sh11 [Occ=Once] :: [a_a4Is]
                                                    [LclId] =
                                                        CCCS :! [y_sh0T y1_sh0Z];
                                                  } in  : [sat_sh11 sat_sh12];
                                            };
                                  } in  go1_sh0W many_v_sh0P;
                            };
                  } in 
                    case go_sh0Q v_sh0O of sat_sh13 {
                      __DEFAULT -> GHC.Base.++ sat_sh13 GHC.Base.$fAlternative[]1;
                    };
        } in  many_v_sh0P;

GHC.Base.$fAlternative[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [GHC.Base.$fApplicative[]
                                           GHC.Types.[]
                                           GHC.Base.++
                                           GHC.Base.$fAlternative[]_$csome
                                           GHC.Base.$fAlternative[]_$cmany];

GHC.Base.$w$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> (a -> GHC.Base.NonEmpty b) -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,C(U(1*U,1*U))>,
 Unf=OtherCon []] =
    [] \r [w_sh14 w1_sh15]
        let {
          ds_sh16 [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty b_s6HN
          [LclId] =
              [w_sh14 w1_sh15] \u []
                  let {
                    sat_sh1a [Occ=Once] :: a_s6HM
                    [LclId] =
                        [w_sh14] \u []
                            case w_sh14 of {
                              GHC.Base.:| a1_sh18 [Occ=Once] _ [Occ=Dead] -> a1_sh18;
                            };
                  } in  w1_sh15 sat_sh1a; } in
        let {
          sat_sh1C [Occ=Once] :: [b_s6HN]
          [LclId] =
              [w_sh14 w1_sh15 ds_sh16] \u []
                  case ds_sh16 of {
                    GHC.Base.:| _ [Occ=Dead] bs_sh1h [Occ=Once] ->
                        let {
                          sat_sh1B [Occ=Once, Dmd=<L,1*U>] :: [b_s6HN]
                          [LclId] =
                              [w_sh14 w1_sh15] \s []
                                  case w_sh14 of {
                                    GHC.Base.:| _ [Occ=Dead] as_sh1k [Occ=Once] ->
                                        let {
                                          go_sh1l [Occ=LoopBreaker] :: [a_s6HM] -> [b_s6HN]
                                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                              sat-only [w1_sh15 go_sh1l] \r [ds1_sh1m]
                                                  case ds1_sh1m of {
                                                    [] -> [] [];
                                                    : y_sh1o [Occ=Once] ys_sh1p [Occ=Once] ->
                                                        let {
                                                          ds2_sh1q [Dmd=<L,U(1*U,1*U)>]
                                                            :: GHC.Base.NonEmpty b_s6HN
                                                          [LclId] =
                                                              [w1_sh15 y_sh1o] \u []
                                                                  w1_sh15 y_sh1o; } in
                                                        let {
                                                          sat_sh1A [Occ=Once, Dmd=<L,1*U>]
                                                            :: [b_s6HN]
                                                          [LclId] =
                                                              [go_sh1l ys_sh1p] \s []
                                                                  go_sh1l ys_sh1p; } in
                                                        let {
                                                          sat_sh1y [Occ=Once] :: [b_s6HN]
                                                          [LclId] =
                                                              [ds2_sh1q] \u []
                                                                  case ds2_sh1q of {
                                                                    GHC.Base.:| _ [Occ=Dead]
                                                                                cs_sh1x [Occ=Once] ->
                                                                        cs_sh1x;
                                                                  }; } in
                                                        let {
                                                          sat_sh1u [Occ=Once] :: b_s6HN
                                                          [LclId] =
                                                              [ds2_sh1q] \u []
                                                                  case ds2_sh1q of {
                                                                    GHC.Base.:| c_sh1s [Occ=Once]
                                                                                _ [Occ=Dead] ->
                                                                        c_sh1s;
                                                                  }; } in
                                                        let {
                                                          sat_sh1z [Occ=Once] :: [b_s6HN]
                                                          [LclId] =
                                                              CCCS :! [sat_sh1u sat_sh1y];
                                                        } in  GHC.Base.++ sat_sh1z sat_sh1A;
                                                  };
                                        } in  go_sh1l as_sh1k;
                                  };
                        } in  GHC.Base.++ bs_sh1h sat_sh1B;
                  }; } in
        let {
          sat_sh1e [Occ=Once] :: b_s6HN
          [LclId] =
              [ds_sh16] \u []
                  case ds_sh16 of {
                    GHC.Base.:| b1_sh1c [Occ=Once] _ [Occ=Dead] -> b1_sh1c;
                  };
        } in  (#,#) [sat_sh1e sat_sh1C];

GHC.Base.$fMonadNonEmpty_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a
     -> (a -> GHC.Base.NonEmpty b) -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,C(U(1*U,1*U))>m,
 Unf=OtherCon []] =
    [] \r [w_sh1D w1_sh1E]
        case GHC.Base.$w$c>>= w_sh1D w1_sh1E of {
          (#,#) ww1_sh1G [Occ=Once] ww2_sh1H [Occ=Once] ->
              GHC.Base.:| [ww1_sh1G ww2_sh1H];
        };

GHC.Base.$fMonadNonEmpty_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [eta_sh1I eta1_sh1J]
        let {
          sat_sh1L [Occ=Once] :: a_a4sH -> GHC.Base.NonEmpty b_a4sI
          [LclId] =
              [eta1_sh1J] \r [ds_sh1K] eta1_sh1J;
        } in 
          case GHC.Base.$w$c>>= eta_sh1I sat_sh1L of {
            (#,#) ww1_sh1N [Occ=Once] ww2_sh1O [Occ=Once] ->
                GHC.Base.:| [ww1_sh1N ww2_sh1O];
          };

GHC.Base.<**>1 :: forall a b. a -> (a -> b) -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [a1_sh1P f_sh1Q] f_sh1Q a1_sh1P;

GHC.Base.<**>
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     f a -> f (a -> b) -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sh1R]
        GHC.Base.liftA2 $dApplicative_sh1R GHC.Base.<**>1;

GHC.Base.$dmliftA2
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b c. (a -> b -> c) -> f a -> f b -> f c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLL),U(1*U(1*C1(C1(U)),A),A,1*C1(U),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sh1S eta_sh1T eta1_sh1U]
        let {
          sat_sh1W [Occ=Once] :: f_a37E (b_a4iN -> c_a4iO)
          [LclId] =
              [$dApplicative_sh1S eta_sh1T eta1_sh1U] \u []
                  case GHC.Base.$p1Applicative $dApplicative_sh1S of sat_sh1V {
                    __DEFAULT -> GHC.Base.fmap sat_sh1V eta_sh1T eta1_sh1U;
                  };
        } in  GHC.Base.<*> $dApplicative_sh1S sat_sh1W;

GHC.Base.$dmsome
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sh1X eta_sh1Y]
        let {
          some_v_sh1Z [Occ=LoopBreaker] :: f_a37j [a_a4ju]
          [LclId] =
              [$dAlternative_sh1X eta_sh1Y some_v_sh1Z] \u []
                  case
                      GHC.Base.$p1Alternative $dAlternative_sh1X
                  of
                  $dApplicative_sh20 [Dmd=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                  { __DEFAULT ->
                        let {
                          sat_sh22 [Occ=Once] :: f_a37j [a_a4ju]
                          [LclId] =
                              [$dAlternative_sh1X some_v_sh1Z $dApplicative_sh20] \u []
                                  let {
                                    sat_sh21 [Occ=Once] :: f_a37j [a_a4ju]
                                    [LclId] =
                                        [$dApplicative_sh20] \u []
                                            GHC.Base.pure $dApplicative_sh20 GHC.Types.[];
                                  } in  GHC.Base.<|> $dAlternative_sh1X some_v_sh1Z sat_sh21;
                        } in 
                          GHC.Base.liftA2 $dApplicative_sh20 GHC.Types.: eta_sh1Y sat_sh22;
                  };
        } in  some_v_sh1Z;

GHC.Base.$dmmany
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sh23 eta_sh24]
        let {
          many_v_sh25 [Occ=LoopBreaker] :: f_a37j [a_a4jX]
          [LclId] =
              [$dAlternative_sh23 eta_sh24 many_v_sh25] \u []
                  let {
                    $dApplicative_sh26 [Dmd=<L,U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                      :: GHC.Base.Applicative f_a37j
                    [LclId] =
                        [$dAlternative_sh23] \u []
                            GHC.Base.$p1Alternative $dAlternative_sh23; } in
                  let {
                    sat_sh28 [Occ=Once] :: f_a37j [a_a4jX]
                    [LclId] =
                        [$dApplicative_sh26] \u []
                            GHC.Base.pure $dApplicative_sh26 GHC.Types.[]; } in
                  let {
                    sat_sh27 [Occ=Once] :: f_a37j [a_a4jX]
                    [LclId] =
                        [eta_sh24 many_v_sh25 $dApplicative_sh26] \u []
                            GHC.Base.liftA2
                                $dApplicative_sh26 GHC.Types.: eta_sh24 many_v_sh25;
                  } in  GHC.Base.<|> $dAlternative_sh23 sat_sh27 sat_sh28;
        } in  many_v_sh25;

GHC.Base.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Base.Semigroup b =>
     (a -> b) -> [a -> b] -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh29 ww_sh2a ww1_sh2b]
        let {
          go_sh2c [Occ=LoopBreaker]
            :: (a_s6HX -> b_s6HW) -> [a_s6HX -> b_s6HW] -> a_s6HX -> b_s6HW
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sh29 go_sh2c] \r [b1_sh2d ds_sh2e]
                  case ds_sh2e of {
                    [] -> b1_sh2d;
                    : c_sh2g [Occ=Once] cs_sh2h [Occ=Once] ->
                        let {
                          g_sh2i [Occ=OnceL!, Dmd=<L,C(U)>] :: a_s6HX -> b_s6HW
                          [LclId] =
                              [go_sh2c c_sh2g cs_sh2h] \u [] go_sh2c c_sh2g cs_sh2h; } in
                        let {
                          sat_sh2m [Occ=OnceT[0]] :: a_s6HX -> b_s6HW
                          [LclId] =
                              [w_sh29 b1_sh2d g_sh2i] \r [x_sh2j]
                                  let {
                                    sat_sh2l [Occ=Once] :: b_s6HW
                                    [LclId] =
                                        [g_sh2i x_sh2j] \u [] g_sh2i x_sh2j; } in
                                  let {
                                    sat_sh2k [Occ=Once] :: b_s6HW
                                    [LclId] =
                                        [b1_sh2d x_sh2j] \u [] b1_sh2d x_sh2j;
                                  } in  GHC.Base.<> w_sh29 sat_sh2k sat_sh2l;
                        } in  sat_sh2m;
                  };
        } in  go_sh2c ww_sh2a ww1_sh2b;

GHC.Base.$fSemigroup(->)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Base.Semigroup b =>
     GHC.Base.NonEmpty (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh2n w1_sh2o]
        case w1_sh2o of {
          GHC.Base.:| ww1_sh2q [Occ=Once] ww2_sh2r [Occ=Once] ->
              GHC.Base.$w$csconcat3 w_sh2n ww1_sh2q ww2_sh2r;
        };

GHC.Base.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     a -> b -> [(a, b)] -> (# a, b #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh2s w1_sh2t ww_sh2u ww1_sh2v ww2_sh2w]
        let {
          $wgo_sh2x [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: a_s6Ih -> b_s6Ii -> [(a_s6Ih, b_s6Ii)] -> (# a_s6Ih, b_s6Ii #)
          [LclId, Arity=3, Str=<L,U><L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sh2s w1_sh2t $wgo_sh2x] \r [ww3_sh2y ww4_sh2z w2_sh2A]
                  case w2_sh2A of {
                    [] -> (#,#) [ww3_sh2y ww4_sh2z];
                    : c_sh2C [Occ=Once!] cs_sh2D [Occ=Once] ->
                        case c_sh2C of {
                          (,) ww6_sh2F [Occ=Once] ww7_sh2G [Occ=Once] ->
                              case $wgo_sh2x ww6_sh2F ww7_sh2G cs_sh2D of {
                                (#,#) ww9_sh2I [Occ=Once] ww10_sh2J [Occ=Once] ->
                                    let {
                                      sat_sh2L [Occ=Once] :: b_s6Ii
                                      [LclId] =
                                          [w1_sh2t ww4_sh2z ww10_sh2J] \u []
                                              GHC.Base.<> w1_sh2t ww4_sh2z ww10_sh2J; } in
                                    let {
                                      sat_sh2K [Occ=Once] :: a_s6Ih
                                      [LclId] =
                                          [w_sh2s ww3_sh2y ww9_sh2I] \u []
                                              GHC.Base.<> w_sh2s ww3_sh2y ww9_sh2I;
                                    } in  (#,#) [sat_sh2K sat_sh2L];
                              };
                        };
                  };
        } in  $wgo_sh2x ww_sh2u ww1_sh2v ww2_sh2w;

GHC.Base.$fSemigroup(,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     GHC.Base.NonEmpty (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sh2M w1_sh2N w2_sh2O]
        case w2_sh2O of {
          GHC.Base.:| ww1_sh2Q [Occ=Once!] ww2_sh2R [Occ=Once] ->
              case ww1_sh2Q of {
                (,) ww4_sh2T [Occ=Once] ww5_sh2U [Occ=Once] ->
                    case
                        GHC.Base.$w$csconcat w_sh2M w1_sh2N ww4_sh2T ww5_sh2U ww2_sh2R
                    of
                    { (#,#) ww7_sh2W [Occ=Once] ww8_sh2X [Occ=Once] ->
                          (,) [ww7_sh2W ww8_sh2X];
                    };
              };
        };

GHC.Base.$dmsconcat
  :: forall a. GHC.Base.Semigroup a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sh2Y ds_sh2Z]
        case ds_sh2Z of {
          GHC.Base.:| a1_sh31 [Occ=Once] as_sh32 [Occ=Once] ->
              let {
                go_sh33 [Occ=LoopBreaker] :: a_a37Z -> [a_a37Z] -> a_a37Z
                [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
                    sat-only [$dSemigroup_sh2Y go_sh33] \r [b_sh34 ds1_sh35]
                        case ds1_sh35 of {
                          [] -> b_sh34;
                          : c_sh37 [Occ=Once] cs_sh38 [Occ=Once] ->
                              let {
                                sat_sh39 [Occ=Once] :: a_a37Z
                                [LclId] =
                                    [go_sh33 c_sh37 cs_sh38] \u [] go_sh33 c_sh37 cs_sh38;
                              } in  GHC.Base.<> $dSemigroup_sh2Y b_sh34 sat_sh39;
                        };
              } in  go_sh33 a1_sh31 as_sh32;
        };

GHC.Base.$dmstimes
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b. GHC.Real.Integral b => b -> a -> a
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
    [] \r [$dSemigroup_sh3a $dIntegral_sh3b]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_sh3b $dSemigroup_sh3a;

GHC.Base.$dmmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Base.Monoid a => a -> a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(SLL)LLL),1*U(1*U(1*U,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh3c]
        case GHC.Base.$p1Monoid $dMonoid_sh3c of sat_sh3d {
          __DEFAULT -> GHC.Base.<> sat_sh3d;
        };

GHC.Base.$dm>> [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. m a -> m b -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sh3e m1_sh3f k_sh3g]
        let {
          sat_sh3i [Occ=Once] :: a_a4lv -> m_a37u b_a4lw
          [LclId] =
              [k_sh3g] \r [ds_sh3h] k_sh3g;
        } in  GHC.Base.>>= $dMonad_sh3e m1_sh3f sat_sh3i;

GHC.Base.$dmreturn
  :: forall (m :: * -> *). GHC.Base.Monad m => forall a. a -> m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LSLLLL)LLLL),1*U(1*U(A,1*U,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sh3j]
        case GHC.Base.$p1Monad $dMonad_sh3j of sat_sh3k {
          __DEFAULT -> GHC.Base.pure sat_sh3k;
        };

GHC.Base.$dmfail
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a. GHC.Base.String -> m a
[GblId, Arity=2, Str=<B,A><B,U>x, Unf=OtherCon []] =
    [] \r [$dMonad_sh3l s_sh3m] GHC.Err.errorWithoutStackTrace s_sh3m;

GHC.Base.$dmmzero
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => forall a. m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LSLLL)LLL),1*U(1*U(A,1*U,A,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sh3n]
        case GHC.Base.$p1MonadPlus $dMonadPlus_sh3n of sat_sh3o {
          __DEFAULT -> GHC.Base.empty sat_sh3o;
        };

GHC.Base.$dmmplus
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a. m a -> m a -> m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LLSLL)LLL),1*U(1*U(A,A,1*U,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sh3p]
        case GHC.Base.$p1MonadPlus $dMonadPlus_sh3p of sat_sh3q {
          __DEFAULT -> GHC.Base.<|> sat_sh3q;
        };

GHC.Base.$fEqMaybe_$c==
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sh3r ds_sh3s ds1_sh3t]
        case ds_sh3s of {
          GHC.Base.Nothing ->
              case ds1_sh3t of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just a1_sh3x [Occ=Once] ->
              case ds1_sh3t of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just b1_sh3z [Occ=Once] ->
                    GHC.Classes.== $dEq_sh3r a1_sh3x b1_sh3z;
              };
        };

GHC.Base.$fEqMaybe_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sh3A eta_sh3B eta1_sh3C]
        case eta_sh3B of {
          GHC.Base.Nothing ->
              case eta1_sh3C of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.True [];
              };
          GHC.Base.Just a1_sh3G [Occ=Once] ->
              case eta1_sh3C of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just b1_sh3I [Occ=Once] ->
                    case GHC.Classes.== $dEq_sh3A a1_sh3G b1_sh3I of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

GHC.Base.$fEqMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Base.Maybe a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sh3K]
        let {
          sat_sh3M [Occ=Once]
            :: GHC.Base.Maybe a_a4m9 -> GHC.Base.Maybe a_a4m9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_sh3K] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_sh3K eta_B2 eta_B1; } in
        let {
          sat_sh3L [Occ=Once]
            :: GHC.Base.Maybe a_a4m9 -> GHC.Base.Maybe a_a4m9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_sh3K] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_sh3K eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sh3L sat_sh3M];

GHC.Base.$fOrdMaybe_$cp1Ord
  :: forall a. GHC.Classes.Ord a => GHC.Classes.Eq (GHC.Base.Maybe a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh3N]
        let {
          sat_sh3O [Occ=Once, Dmd=<L,U(C(C1(U)),A)>] :: GHC.Classes.Eq a_a4mo
          [LclId] =
              [$dOrd_sh3N] \u [] GHC.Classes.$p1Ord $dOrd_sh3N;
        } in  GHC.Base.$fEqMaybe sat_sh3O;

GHC.Base.$fOrdMaybe_$ccompare
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh3P a1_sh3Q b_sh3R]
        case a1_sh3Q of {
          GHC.Base.Nothing ->
              case b_sh3R of {
                GHC.Base.Nothing -> GHC.Types.EQ [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.LT [];
              };
          GHC.Base.Just a2_sh3V [Occ=Once] ->
              case b_sh3R of {
                GHC.Base.Nothing -> GHC.Types.GT [];
                GHC.Base.Just b1_sh3X [Occ=Once] ->
                    GHC.Classes.compare $dOrd_sh3P a2_sh3V b1_sh3X;
              };
        };

GHC.Base.$fOrdMaybe_$c<
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh3Y a1_sh3Z b_sh40]
        case a1_sh3Z of {
          GHC.Base.Nothing ->
              case b_sh40 of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.True [];
              };
          GHC.Base.Just a2_sh44 [Occ=Once] ->
              case b_sh40 of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just b1_sh46 [Occ=Once] ->
                    GHC.Classes.< $dOrd_sh3Y a2_sh44 b1_sh46;
              };
        };

GHC.Base.$fOrdMaybe_$c<=
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh47 a1_sh48 b_sh49]
        case b_sh49 of {
          GHC.Base.Nothing ->
              case a1_sh48 of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just a2_sh4d [Occ=Once] ->
              case a1_sh48 of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just b1_sh4f [Occ=Once] ->
                    case GHC.Classes.< $dOrd_sh47 a2_sh4d b1_sh4f of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

GHC.Base.$fOrdMaybe_$cmax
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh4h x_sh4i y_sh4j]
        case y_sh4j of wild_sh4k {
          GHC.Base.Nothing -> x_sh4i;
          GHC.Base.Just a1_sh4l [Occ=Once] ->
              case x_sh4i of wild1_sh4m {
                GHC.Base.Nothing -> wild_sh4k;
                GHC.Base.Just b1_sh4n [Occ=Once] ->
                    case GHC.Classes.< $dOrd_sh4h a1_sh4l b1_sh4n of {
                      GHC.Types.False -> wild_sh4k;
                      GHC.Types.True -> wild1_sh4m;
                    };
              };
        };

GHC.Base.$fOrdMaybe_$cmin
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh4p x_sh4q y_sh4r]
        case y_sh4r of wild_sh4s {
          GHC.Base.Nothing ->
              case x_sh4q of { __DEFAULT -> GHC.Base.Nothing []; };
          GHC.Base.Just a1_sh4u [Occ=Once] ->
              case x_sh4q of wild1_sh4v {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just b1_sh4w [Occ=Once] ->
                    case GHC.Classes.< $dOrd_sh4p a1_sh4u b1_sh4w of {
                      GHC.Types.False -> wild1_sh4v;
                      GHC.Types.True -> wild_sh4s;
                    };
              };
        };

GHC.Base.$fOrdMaybe_$c>=
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh4y a1_sh4z b_sh4A]
        case a1_sh4z of {
          GHC.Base.Nothing ->
              case b_sh4A of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just a2_sh4E [Occ=Once] ->
              case b_sh4A of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just b1_sh4G [Occ=Once] ->
                    case GHC.Classes.< $dOrd_sh4y a2_sh4E b1_sh4G of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

GHC.Base.$fOrdMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (GHC.Base.Maybe a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_sh4I]
        let {
          sat_sh4S [Occ=Once]
            :: GHC.Base.Maybe a_a4mo
               -> GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo
          [LclId] =
              [$dOrd_sh4I] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_sh4I eta_B2 eta_B1; } in
        let {
          sat_sh4R [Occ=Once]
            :: GHC.Base.Maybe a_a4mo
               -> GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo
          [LclId] =
              [$dOrd_sh4I] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_sh4I eta_B2 eta_B1; } in
        let {
          sat_sh4Q [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh4I] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_sh4I eta_B2 eta_B1; } in
        let {
          sat_sh4P [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh4I] \r [a1_sh4N b_sh4O]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_sh4I b_sh4O a1_sh4N; } in
        let {
          sat_sh4M [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh4I] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_sh4I eta_B2 eta_B1; } in
        let {
          sat_sh4L [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh4I] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_sh4I eta_B2 eta_B1; } in
        let {
          sat_sh4K [Occ=Once]
            :: GHC.Base.Maybe a_a4mo
               -> GHC.Base.Maybe a_a4mo -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sh4I] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_sh4I eta_B2 eta_B1; } in
        let {
          sat_sh4J [Occ=Once] :: GHC.Classes.Eq (GHC.Base.Maybe a_a4mo)
          [LclId] =
              [$dOrd_sh4I] \u [] GHC.Base.$fOrdMaybe_$cp1Ord $dOrd_sh4I;
        } in 
          GHC.Classes.C:Ord [sat_sh4J
                             sat_sh4K
                             sat_sh4L
                             sat_sh4M
                             sat_sh4P
                             sat_sh4Q
                             sat_sh4R
                             sat_sh4S];

GHC.Base.$fEqNonEmpty_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sh4T eta_sh4U eta1_sh4V]
        case eta_sh4U of {
          GHC.Base.:| a1_sh4X [Occ=Once] a2_sh4Y [Occ=Once] ->
              case eta1_sh4V of {
                GHC.Base.:| b1_sh50 [Occ=Once] b2_sh51 [Occ=Once] ->
                    case GHC.Classes.== $dEq_sh4T a1_sh4X b1_sh50 of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True ->
                          case GHC.Classes.$fEq[]_$c== $dEq_sh4T a2_sh4Y b2_sh51 of {
                            GHC.Types.False -> GHC.Types.True [];
                            GHC.Types.True -> GHC.Types.False [];
                          };
                    };
              };
        };

GHC.Base.$w$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh54 ww_sh55 ww1_sh56 ww2_sh57 ww3_sh58]
        case GHC.Classes.== w_sh54 ww_sh55 ww2_sh57 of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True -> GHC.Classes.$fEq[]_$c== w_sh54 ww1_sh56 ww3_sh58;
        };

GHC.Base.$fEqNonEmpty_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh5a w1_sh5b w2_sh5c]
        case w1_sh5b of {
          GHC.Base.:| ww1_sh5e [Occ=Once] ww2_sh5f [Occ=Once] ->
              case w2_sh5c of {
                GHC.Base.:| ww4_sh5h [Occ=Once] ww5_sh5i [Occ=Once] ->
                    GHC.Base.$w$c== w_sh5a ww1_sh5e ww2_sh5f ww4_sh5h ww5_sh5i;
              };
        };

GHC.Base.$fEqNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (GHC.Base.NonEmpty a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sh5j]
        let {
          sat_sh5l [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nu
               -> GHC.Base.NonEmpty a_a4nu -> GHC.Types.Bool
          [LclId] =
              [$dEq_sh5j] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqNonEmpty_$c/= $dEq_sh5j eta_B2 eta_B1; } in
        let {
          sat_sh5k [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nu
               -> GHC.Base.NonEmpty a_a4nu -> GHC.Types.Bool
          [LclId] =
              [$dEq_sh5j] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqNonEmpty_$c== $dEq_sh5j eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sh5k sat_sh5l];

GHC.Base.$fOrdNonEmpty_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (GHC.Base.NonEmpty a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh5m]
        let {
          sat_sh5n [Occ=Once, Dmd=<L,U(C(C1(U)),A)>] :: GHC.Classes.Eq a_a4nL
          [LclId] =
              [$dOrd_sh5m] \u [] GHC.Classes.$p1Ord $dOrd_sh5m;
        } in  GHC.Base.$fEqNonEmpty sat_sh5n;

GHC.Base.$w$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh5o ww_sh5p ww1_sh5q ww2_sh5r ww3_sh5s]
        case GHC.Classes.compare w_sh5o ww_sh5p ww2_sh5r of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ ->
              GHC.Classes.$fOrd[]_$ccompare w_sh5o ww1_sh5q ww3_sh5s;
          GHC.Types.GT -> GHC.Types.GT [];
        };

GHC.Base.$fOrdNonEmpty_$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh5u w1_sh5v w2_sh5w]
        case w1_sh5v of {
          GHC.Base.:| ww1_sh5y [Occ=Once] ww2_sh5z [Occ=Once] ->
              case w2_sh5w of {
                GHC.Base.:| ww4_sh5B [Occ=Once] ww5_sh5C [Occ=Once] ->
                    GHC.Base.$w$ccompare w_sh5u ww1_sh5y ww2_sh5z ww4_sh5B ww5_sh5C;
              };
        };

GHC.Base.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh5D ww_sh5E ww1_sh5F ww2_sh5G ww3_sh5H]
        case GHC.Classes.compare w_sh5D ww_sh5E ww2_sh5G of {
          GHC.Types.LT -> GHC.Types.True [];
          GHC.Types.EQ -> GHC.Classes.$fOrd[]_$c< w_sh5D ww1_sh5F ww3_sh5H;
          GHC.Types.GT -> GHC.Types.False [];
        };

GHC.Base.$fOrdNonEmpty_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh5J w1_sh5K w2_sh5L]
        case w1_sh5K of {
          GHC.Base.:| ww1_sh5N [Occ=Once] ww2_sh5O [Occ=Once] ->
              case w2_sh5L of {
                GHC.Base.:| ww4_sh5Q [Occ=Once] ww5_sh5R [Occ=Once] ->
                    GHC.Base.$w$c< w_sh5J ww1_sh5N ww2_sh5O ww4_sh5Q ww5_sh5R;
              };
        };

GHC.Base.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh5S ww_sh5T ww1_sh5U ww2_sh5V ww3_sh5W]
        case GHC.Classes.compare w_sh5S ww2_sh5V ww_sh5T of {
          GHC.Types.LT -> GHC.Types.False [];
          GHC.Types.EQ ->
              case GHC.Classes.$fOrd[]_$ccompare w_sh5S ww3_sh5W ww1_sh5U of {
                __DEFAULT -> GHC.Types.True [];
                GHC.Types.LT -> GHC.Types.False [];
              };
          GHC.Types.GT -> GHC.Types.True [];
        };

GHC.Base.$fOrdNonEmpty_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh5Z w1_sh60 w2_sh61]
        case w1_sh60 of {
          GHC.Base.:| ww1_sh63 [Occ=Once] ww2_sh64 [Occ=Once] ->
              case w2_sh61 of {
                GHC.Base.:| ww4_sh66 [Occ=Once] ww5_sh67 [Occ=Once] ->
                    GHC.Base.$w$c<= w_sh5Z ww1_sh63 ww2_sh64 ww4_sh66 ww5_sh67;
              };
        };

GHC.Base.$fOrdNonEmpty_$cmax [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sh68 w1_sh69 w2_sh6a]
        case w1_sh69 of ww_sh6b {
          GHC.Base.:| ww1_sh6c [Occ=Once] ww2_sh6d [Occ=Once] ->
              case w2_sh6a of ww3_sh6e {
                GHC.Base.:| ww4_sh6f [Occ=Once] ww5_sh6g [Occ=Once] ->
                    case GHC.Classes.compare w_sh68 ww4_sh6f ww1_sh6c of {
                      GHC.Types.LT -> ww_sh6b;
                      GHC.Types.EQ ->
                          case GHC.Classes.$fOrd[]_$ccompare w_sh68 ww5_sh6g ww2_sh6d of {
                            __DEFAULT -> ww3_sh6e;
                            GHC.Types.LT -> ww_sh6b;
                          };
                      GHC.Types.GT -> ww3_sh6e;
                    };
              };
        };

GHC.Base.$fOrdNonEmpty_$cmin [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sh6j w1_sh6k w2_sh6l]
        case w1_sh6k of ww_sh6m {
          GHC.Base.:| ww1_sh6n [Occ=Once] ww2_sh6o [Occ=Once] ->
              case w2_sh6l of ww3_sh6p {
                GHC.Base.:| ww4_sh6q [Occ=Once] ww5_sh6r [Occ=Once] ->
                    case GHC.Classes.compare w_sh6j ww4_sh6q ww1_sh6n of {
                      GHC.Types.LT -> ww3_sh6p;
                      GHC.Types.EQ ->
                          case GHC.Classes.$fOrd[]_$ccompare w_sh6j ww5_sh6r ww2_sh6o of {
                            __DEFAULT -> ww_sh6m;
                            GHC.Types.LT -> ww3_sh6p;
                          };
                      GHC.Types.GT -> ww_sh6m;
                    };
              };
        };

GHC.Base.$w$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh6u ww_sh6v ww1_sh6w ww2_sh6x ww3_sh6y]
        case GHC.Classes.compare w_sh6u ww_sh6v ww2_sh6x of {
          GHC.Types.LT -> GHC.Types.False [];
          GHC.Types.EQ ->
              case GHC.Classes.$fOrd[]_$ccompare w_sh6u ww1_sh6w ww3_sh6y of {
                __DEFAULT -> GHC.Types.True [];
                GHC.Types.LT -> GHC.Types.False [];
              };
          GHC.Types.GT -> GHC.Types.True [];
        };

GHC.Base.$fOrdNonEmpty_$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh6B w1_sh6C w2_sh6D]
        case w1_sh6C of {
          GHC.Base.:| ww1_sh6F [Occ=Once] ww2_sh6G [Occ=Once] ->
              case w2_sh6D of {
                GHC.Base.:| ww4_sh6I [Occ=Once] ww5_sh6J [Occ=Once] ->
                    GHC.Base.$w$c>= w_sh6B ww1_sh6F ww2_sh6G ww4_sh6I ww5_sh6J;
              };
        };

GHC.Base.$fOrdNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (GHC.Base.NonEmpty a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sh6K]
        let {
          sat_sh6U [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Base.NonEmpty a_a4nL
          [LclId] =
              [$dOrd_sh6K] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$cmin $dOrd_sh6K eta_B2 eta_B1; } in
        let {
          sat_sh6T [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Base.NonEmpty a_a4nL
          [LclId] =
              [$dOrd_sh6K] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$cmax $dOrd_sh6K eta_B2 eta_B1; } in
        let {
          sat_sh6S [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh6K] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$c>= $dOrd_sh6K eta_B2 eta_B1; } in
        let {
          sat_sh6R [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh6K] \r [a1_sh6P b_sh6Q]
                  GHC.Base.$fOrdNonEmpty_$c< $dOrd_sh6K b_sh6Q a1_sh6P; } in
        let {
          sat_sh6O [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh6K] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$c<= $dOrd_sh6K eta_B2 eta_B1; } in
        let {
          sat_sh6N [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh6K] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$c< $dOrd_sh6K eta_B2 eta_B1; } in
        let {
          sat_sh6M [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sh6K] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$ccompare $dOrd_sh6K eta_B2 eta_B1; } in
        let {
          sat_sh6L [Occ=Once] :: GHC.Classes.Eq (GHC.Base.NonEmpty a_a4nL)
          [LclId] =
              [$dOrd_sh6K] \u [] GHC.Base.$fOrdNonEmpty_$cp1Ord $dOrd_sh6K;
        } in 
          GHC.Classes.C:Ord [sat_sh6L
                             sat_sh6M
                             sat_sh6N
                             sat_sh6O
                             sat_sh6R
                             sat_sh6S
                             sat_sh6T
                             sat_sh6U];

GHC.Base.$fMonadIO_$cfail
  :: forall a. GHC.Base.String -> GHC.Types.IO a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [s_sh6V] GHC.IO.failIO s_sh6V;

GHC.Base.$fMonadIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicativeIO
                                     GHC.Base.$fMonadIO1
                                     GHC.Base.$fApplicativeIO2
                                     GHC.Base.$fApplicativeIO4
                                     GHC.Base.$fMonadIO_$cfail];

GHC.Base.$fMonad[]_$cfail [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Base.String -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sh6W] [] [];

GHC.Base.$fMonad[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicative[]
                                     GHC.Base.$fMonad[]_$c>>=
                                     GHC.Base.$fApplicative[]_$c*>
                                     GHC.Base.$fApplicative[]_$cpure
                                     GHC.Base.$fMonad[]_$cfail];

GHC.Base.$fMonadPlus[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [GHC.Base.$fAlternative[]
                                         GHC.Base.$fMonad[]
                                         GHC.Types.[]
                                         GHC.Base.++];

GHC.Base.$fMonadMaybe_$c>>=
  :: forall a b.
     GHC.Base.Maybe a -> (a -> GHC.Base.Maybe b) -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sh6X k_sh6Y]
        case ds_sh6X of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sh70 [Occ=Once] -> k_sh6Y x_sh70;
        };

GHC.Base.$fMonadMaybe_$cfail
  :: forall a. GHC.Base.String -> GHC.Base.Maybe a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sh71] GHC.Base.Nothing [];

GHC.Base.$fMonad(->)_$c>>=
  :: forall r a b. (r -> a) -> (a -> r -> b) -> r -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sh72 k_sh73 r1_sh74]
        let {
          sat_sh75 [Occ=Once] :: a_a4tQ
          [LclId] =
              [f_sh72 r1_sh74] \u [] f_sh72 r1_sh74;
        } in  k_sh73 sat_sh75 r1_sh74;

GHC.Base.$fMonad(,)_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a1 -> (a, b)) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><C(S),1*C1(U(U,U))>m,
 Unf=OtherCon []] =
    [] \r [w_sh76 w1_sh77 w2_sh78]
        case w1_sh77 of {
          (,) ww1_sh7a [Occ=Once] ww2_sh7b [Occ=Once] ->
              case w2_sh78 ww2_sh7b of {
                (,) v_sh7d [Occ=Once] b1_sh7e [Occ=Once] ->
                    let {
                      sat_sh7g [Occ=Once] :: a_s6KB
                      [LclId] =
                          [w_sh76 ww1_sh7a v_sh7d] \u []
                              case GHC.Base.$p1Monoid w_sh76 of sat_sh7f {
                                __DEFAULT -> GHC.Base.<> sat_sh7f ww1_sh7a v_sh7d;
                              };
                    } in  (,) [sat_sh7g b1_sh7e];
              };
        };

GHC.Base.$fApplicative(,)_$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1 -> b) -> (a, a1) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,1*C1(U))><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sh7h w1_sh7i w2_sh7j]
        case w1_sh7i of {
          (,) ww1_sh7l [Occ=Once] ww2_sh7m [Occ=Once!] ->
              case w2_sh7j of {
                (,) ww4_sh7o [Occ=Once] ww5_sh7p [Occ=Once] ->
                    let {
                      sat_sh7s [Occ=Once] :: b_s6KT
                      [LclId] =
                          [ww2_sh7m ww5_sh7p] \u [] ww2_sh7m ww5_sh7p; } in
                    let {
                      sat_sh7r [Occ=Once] :: a_s6KQ
                      [LclId] =
                          [w_sh7h ww1_sh7l ww4_sh7o] \u []
                              case GHC.Base.$p1Monoid w_sh7h of sat_sh7q {
                                __DEFAULT -> GHC.Base.<> sat_sh7q ww1_sh7l ww4_sh7o;
                              };
                    } in  (,) [sat_sh7r sat_sh7s];
              };
        };

GHC.Base.$fApplicative(,)_$c*>
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,A)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh7t a2_sh7u a3_sh7v]
        case a2_sh7u of {
          (,) x_sh7x [Occ=Once] _ [Occ=Dead] ->
              case a3_sh7v of {
                (,) v_sh7A [Occ=Once] x1_sh7B [Occ=Once] ->
                    let {
                      sat_sh7D [Occ=Once] :: a_a4vv
                      [LclId] =
                          [$dMonoid_sh7t x_sh7x v_sh7A] \u []
                              case GHC.Base.$p1Monoid $dMonoid_sh7t of sat_sh7C {
                                __DEFAULT -> GHC.Base.<> sat_sh7C x_sh7x v_sh7A;
                              };
                    } in  (,) [sat_sh7D x1_sh7B];
              };
        };

GHC.Base.$fApplicative(,)_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b c. (a1 -> b -> c) -> (a, a1) -> (a, b) -> (a, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sh7E w1_sh7F w2_sh7G w3_sh7H]
        case w2_sh7G of {
          (,) ww1_sh7J [Occ=Once] ww2_sh7K [Occ=Once] ->
              case w3_sh7H of {
                (,) ww4_sh7M [Occ=Once] ww5_sh7N [Occ=Once] ->
                    let {
                      sat_sh7Q [Occ=Once] :: c_s6Le
                      [LclId] =
                          [w1_sh7F ww2_sh7K ww5_sh7N] \u [] w1_sh7F ww2_sh7K ww5_sh7N; } in
                    let {
                      sat_sh7P [Occ=Once] :: a_s6La
                      [LclId] =
                          [w_sh7E ww1_sh7J ww4_sh7M] \u []
                              case GHC.Base.$p1Monoid w_sh7E of sat_sh7O {
                                __DEFAULT -> GHC.Base.<> sat_sh7O ww1_sh7J ww4_sh7M;
                              };
                    } in  (,) [sat_sh7P sat_sh7Q];
              };
        };

GHC.Base.$fMonoid(,,,,)_$cmempty
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh7R
           $dMonoid1_sh7S
           $dMonoid2_sh7T
           $dMonoid3_sh7U
           $dMonoid4_sh7V]
        let {
          sat_sh80 [Occ=Once] :: e_a4x9
          [LclId] =
              [$dMonoid4_sh7V] \u [] GHC.Base.mempty $dMonoid4_sh7V; } in
        let {
          sat_sh7Z [Occ=Once] :: d_a4x8
          [LclId] =
              [$dMonoid3_sh7U] \u [] GHC.Base.mempty $dMonoid3_sh7U; } in
        let {
          sat_sh7Y [Occ=Once] :: c_a4x7
          [LclId] =
              [$dMonoid2_sh7T] \u [] GHC.Base.mempty $dMonoid2_sh7T; } in
        let {
          sat_sh7X [Occ=Once] :: b_a4x6
          [LclId] =
              [$dMonoid1_sh7S] \u [] GHC.Base.mempty $dMonoid1_sh7S; } in
        let {
          sat_sh7W [Occ=Once] :: a_a4x5
          [LclId] =
              [$dMonoid_sh7R] \u [] GHC.Base.mempty $dMonoid_sh7R;
        } in  (,,,,) [sat_sh7W sat_sh7X sat_sh7Y sat_sh7Z sat_sh80];

GHC.Base.$fMonoid(,,,)_$cmempty
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh81 $dMonoid1_sh82 $dMonoid2_sh83 $dMonoid3_sh84]
        let {
          sat_sh88 [Occ=Once] :: d_a4xM
          [LclId] =
              [$dMonoid3_sh84] \u [] GHC.Base.mempty $dMonoid3_sh84; } in
        let {
          sat_sh87 [Occ=Once] :: c_a4xL
          [LclId] =
              [$dMonoid2_sh83] \u [] GHC.Base.mempty $dMonoid2_sh83; } in
        let {
          sat_sh86 [Occ=Once] :: b_a4xK
          [LclId] =
              [$dMonoid1_sh82] \u [] GHC.Base.mempty $dMonoid1_sh82; } in
        let {
          sat_sh85 [Occ=Once] :: a_a4xJ
          [LclId] =
              [$dMonoid_sh81] \u [] GHC.Base.mempty $dMonoid_sh81;
        } in  (,,,) [sat_sh85 sat_sh86 sat_sh87 sat_sh88];

GHC.Base.$fMonoid(,,)_$cmempty
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     (a, b, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh89 $dMonoid1_sh8a $dMonoid2_sh8b]
        let {
          sat_sh8e [Occ=Once] :: c_a4yl
          [LclId] =
              [$dMonoid2_sh8b] \u [] GHC.Base.mempty $dMonoid2_sh8b; } in
        let {
          sat_sh8d [Occ=Once] :: b_a4yk
          [LclId] =
              [$dMonoid1_sh8a] \u [] GHC.Base.mempty $dMonoid1_sh8a; } in
        let {
          sat_sh8c [Occ=Once] :: a_a4yj
          [LclId] =
              [$dMonoid_sh89] \u [] GHC.Base.mempty $dMonoid_sh89;
        } in  (,,) [sat_sh8c sat_sh8d sat_sh8e];

GHC.Base.$fMonoid(,)_$cmempty
  :: forall a b. (GHC.Base.Monoid a, GHC.Base.Monoid b) => (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh8f $dMonoid1_sh8g]
        let {
          sat_sh8i [Occ=Once] :: b_a4yQ
          [LclId] =
              [$dMonoid1_sh8g] \u [] GHC.Base.mempty $dMonoid1_sh8g; } in
        let {
          sat_sh8h [Occ=Once] :: a_a4yP
          [LclId] =
              [$dMonoid_sh8f] \u [] GHC.Base.mempty $dMonoid_sh8f;
        } in  (,) [sat_sh8h sat_sh8i];

GHC.Base.$fMonoid(,)_$cmconcat
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     [(a, b)] -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh8j $dMonoid1_sh8k eta_sh8l]
        let {
          $dSemigroup_sh8m [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_a4yP
          [LclId] =
              [$dMonoid_sh8j] \u [] GHC.Base.$p1Monoid $dMonoid_sh8j; } in
        let {
          $dSemigroup1_sh8n [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_a4yQ
          [LclId] =
              [$dMonoid1_sh8k] \u [] GHC.Base.$p1Monoid $dMonoid1_sh8k; } in
        let {
          z_sh8o [Occ=OnceL] :: a_a4yP
          [LclId] =
              [$dMonoid_sh8j] \u [] GHC.Base.mempty $dMonoid_sh8j; } in
        let {
          z1_sh8p [Occ=OnceL] :: b_a4yQ
          [LclId] =
              [$dMonoid1_sh8k] \u [] GHC.Base.mempty $dMonoid1_sh8k; } in
        let {
          z2_sh8q [Occ=OnceL, Dmd=<S,U(U,U)>] :: (a_a4yP, b_a4yQ)
          [LclId, Unf=OtherCon []] =
              CCCS (,)! [z_sh8o z1_sh8p]; } in
        let {
          go_sh8r [Occ=LoopBreaker] :: [(a_a4yP, b_a4yQ)] -> (a_a4yP, b_a4yQ)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_sh8m
                        $dSemigroup1_sh8n
                        z2_sh8q
                        go_sh8r] \r [ds_sh8s]
                  case ds_sh8s of {
                    [] -> z2_sh8q;
                    : y_sh8u [Occ=Once!] ys_sh8v [Occ=Once] ->
                        case y_sh8u of {
                          (,) a1_sh8x [Occ=Once] b1_sh8y [Occ=Once] ->
                              case go_sh8r ys_sh8v of {
                                (,) a'_sh8A [Occ=Once] b'_sh8B [Occ=Once] ->
                                    let {
                                      sat_sh8D [Occ=Once] :: b_a4yQ
                                      [LclId] =
                                          [$dSemigroup1_sh8n b1_sh8y b'_sh8B] \u []
                                              GHC.Base.<> $dSemigroup1_sh8n b1_sh8y b'_sh8B; } in
                                    let {
                                      sat_sh8C [Occ=Once] :: a_a4yP
                                      [LclId] =
                                          [$dSemigroup_sh8m a1_sh8x a'_sh8A] \u []
                                              GHC.Base.<> $dSemigroup_sh8m a1_sh8x a'_sh8A;
                                    } in  (,) [sat_sh8C sat_sh8D];
                              };
                        };
                  };
        } in  go_sh8r eta_sh8l;

GHC.Base.$fMonoid()_$cmconcat :: [()] -> ()
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sh8E] () [];

GHC.Base.$fMonoidMaybe_$c<>
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sh8F ds_sh8G b_sh8H]
        case ds_sh8G of wild_sh8I {
          GHC.Base.Nothing -> b_sh8H;
          GHC.Base.Just ipv_sh8J [Occ=Once] ->
              case b_sh8H of {
                GHC.Base.Nothing -> wild_sh8I;
                GHC.Base.Just ipv1_sh8L [Occ=Once] ->
                    let {
                      sat_sh8M [Occ=Once] :: a_a4AP
                      [LclId] =
                          [$dSemigroup_sh8F ipv_sh8J ipv1_sh8L] \u []
                              GHC.Base.<> $dSemigroup_sh8F ipv_sh8J ipv1_sh8L;
                    } in  GHC.Base.Just [sat_sh8M];
              };
        };

GHC.Base.$w$csconcat5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Maybe a -> [GHC.Base.Maybe a] -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh8N ww_sh8O ww1_sh8P]
        let {
          go_sh8Q [Occ=LoopBreaker]
            :: GHC.Base.Maybe a_s6LE
               -> [GHC.Base.Maybe a_s6LE] -> GHC.Base.Maybe a_s6LE
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sh8N go_sh8Q] \r [b_sh8R ds_sh8S]
                  case ds_sh8S of {
                    [] -> b_sh8R;
                    : c_sh8U [Occ=Once*] cs_sh8V [Occ=Once*] ->
                        case b_sh8R of wild1_sh8W {
                          GHC.Base.Nothing -> go_sh8Q c_sh8U cs_sh8V;
                          GHC.Base.Just ipv_sh8X [Occ=Once] ->
                              case go_sh8Q c_sh8U cs_sh8V of {
                                GHC.Base.Nothing -> wild1_sh8W;
                                GHC.Base.Just ipv1_sh8Z [Occ=Once] ->
                                    let {
                                      sat_sh90 [Occ=Once] :: a_s6LE
                                      [LclId] =
                                          [w_sh8N ipv_sh8X ipv1_sh8Z] \u []
                                              GHC.Base.<> w_sh8N ipv_sh8X ipv1_sh8Z;
                                    } in  GHC.Base.Just [sat_sh90];
                              };
                        };
                  };
        } in  go_sh8Q ww_sh8O ww1_sh8P;

GHC.Base.$fSemigroupMaybe_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (GHC.Base.Maybe a) -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh91 w1_sh92]
        case w1_sh92 of {
          GHC.Base.:| ww1_sh94 [Occ=Once] ww2_sh95 [Occ=Once] ->
              GHC.Base.$w$csconcat5 w_sh91 ww1_sh94 ww2_sh95;
        };

GHC.Base.$fSemigroupMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (GHC.Base.Maybe a)
[GblId[DFunId], Arity=1, Str=<L,U(U,U,U)>m] =
    [] \r [$dSemigroup_sh96]
        let {
          sat_sh9a [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> GHC.Base.Maybe a_a4AP -> GHC.Base.Maybe a_a4AP
          [LclId] =
              [$dSemigroup_sh96] \r [$dIntegral_sh99]
                  Data.Semigroup.Internal.stimesMaybe
                      $dIntegral_sh99 $dSemigroup_sh96; } in
        let {
          sat_sh98 [Occ=Once]
            :: GHC.Base.NonEmpty (GHC.Base.Maybe a_a4AP)
               -> GHC.Base.Maybe a_a4AP
          [LclId] =
              [$dSemigroup_sh96] \r [eta_B1]
                  GHC.Base.$fSemigroupMaybe_$csconcat $dSemigroup_sh96 eta_B1; } in
        let {
          sat_sh97 [Occ=Once]
            :: GHC.Base.Maybe a_a4AP
               -> GHC.Base.Maybe a_a4AP -> GHC.Base.Maybe a_a4AP
          [LclId] =
              [$dSemigroup_sh96] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_sh96 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_sh97 sat_sh98 sat_sh9a];

GHC.Base.$fMonoidMaybe_$cmconcat
  :: forall a.
     GHC.Base.Semigroup a =>
     [GHC.Base.Maybe a] -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sh9b eta_sh9c]
        let {
          go_sh9d [Occ=LoopBreaker]
            :: [GHC.Base.Maybe a_a4wo] -> GHC.Base.Maybe a_a4wo
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_sh9b go_sh9d] \r [ds_sh9e]
                  case ds_sh9e of {
                    [] -> GHC.Base.Nothing [];
                    : y_sh9g [Occ=Once!] ys_sh9h [Occ=Once*] ->
                        case y_sh9g of wild1_sh9i {
                          GHC.Base.Nothing -> go_sh9d ys_sh9h;
                          GHC.Base.Just ipv_sh9j [Occ=Once] ->
                              case go_sh9d ys_sh9h of {
                                GHC.Base.Nothing -> wild1_sh9i;
                                GHC.Base.Just ipv1_sh9l [Occ=Once] ->
                                    let {
                                      sat_sh9m [Occ=Once] :: a_a4wo
                                      [LclId] =
                                          [$dSemigroup_sh9b ipv_sh9j ipv1_sh9l] \u []
                                              GHC.Base.<> $dSemigroup_sh9b ipv_sh9j ipv1_sh9l;
                                    } in  GHC.Base.Just [sat_sh9m];
                              };
                        };
                  };
        } in  go_sh9d eta_sh9c;

GHC.Base.$fMonoidMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Monoid (GHC.Base.Maybe a)
[GblId[DFunId], Arity=1, Str=<L,U(U,U,U)>m] =
    [] \r [$dSemigroup_sh9n]
        let {
          sat_sh9q [Occ=Once]
            :: [GHC.Base.Maybe a_a4wo] -> GHC.Base.Maybe a_a4wo
          [LclId] =
              [$dSemigroup_sh9n] \r [eta_B1]
                  GHC.Base.$fMonoidMaybe_$cmconcat $dSemigroup_sh9n eta_B1; } in
        let {
          sat_sh9p [Occ=Once]
            :: GHC.Base.Maybe a_a4wo
               -> GHC.Base.Maybe a_a4wo -> GHC.Base.Maybe a_a4wo
          [LclId] =
              [$dSemigroup_sh9n] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_sh9n eta_B2 eta_B1; } in
        let {
          sat_sh9o [Occ=Once] :: GHC.Base.Semigroup (GHC.Base.Maybe a_a4wo)
          [LclId] =
              [$dSemigroup_sh9n] \u []
                  GHC.Base.$fSemigroupMaybe $dSemigroup_sh9n;
        } in 
          GHC.Base.C:Monoid [sat_sh9o GHC.Base.Nothing sat_sh9p sat_sh9q];

GHC.Base.$fMonoidOrdering_$c<>
  :: GHC.Types.Ordering -> GHC.Types.Ordering -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sh9r ds1_sh9s]
        case ds_sh9r of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ -> ds1_sh9s;
          GHC.Types.GT -> GHC.Types.GT [];
        };

GHC.Base.$fMonoidOrdering_go [Occ=LoopBreaker]
  :: [GHC.Types.Ordering] -> GHC.Types.Ordering
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sh9u]
        case ds_sh9u of {
          [] -> GHC.Types.EQ [];
          : y_sh9w [Occ=Once!] ys_sh9x [Occ=Once] ->
              case y_sh9w of {
                GHC.Types.LT -> GHC.Types.LT [];
                GHC.Types.EQ -> GHC.Base.$fMonoidOrdering_go ys_sh9x;
                GHC.Types.GT -> GHC.Types.GT [];
              };
        };

GHC.Base.$fSemigroupOrdering [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup GHC.Types.Ordering
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.$fMonoidOrdering_$c<>
                                         GHC.Base.$fSemigroupOrdering_$csconcat
                                         GHC.Base.$fSemigroupOrdering_$cstimes];
GHC.Base.$fMonoidOrdering [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid GHC.Types.Ordering
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [GHC.Base.$fSemigroupOrdering
                                      GHC.Types.EQ
                                      GHC.Base.$fMonoidOrdering_$c<>
                                      GHC.Base.$fMonoidOrdering_go];
GHC.Base.$fSemigroupOrdering_$cstimes [Occ=LoopBreaker]
  :: forall b.
     GHC.Real.Integral b =>
     b -> GHC.Types.Ordering -> GHC.Types.Ordering
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sh9z]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_sh9z GHC.Base.$fMonoidOrdering;

GHC.Base.$fMonoid(,,,,)_$c<>
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U,U,U)><S,1*U(U,U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sh9A
           $dSemigroup1_sh9B
           $dSemigroup2_sh9C
           $dSemigroup3_sh9D
           $dSemigroup4_sh9E
           ds_sh9F
           ds1_sh9G]
        case ds_sh9F of {
          (,,,,) a1_sh9I [Occ=Once]
                 b1_sh9J [Occ=Once]
                 c1_sh9K [Occ=Once]
                 d1_sh9L [Occ=Once]
                 e1_sh9M [Occ=Once] ->
              case ds1_sh9G of {
                (,,,,) a'_sh9O [Occ=Once]
                       b'_sh9P [Occ=Once]
                       c'_sh9Q [Occ=Once]
                       d'_sh9R [Occ=Once]
                       e'_sh9S [Occ=Once] ->
                    let {
                      sat_sh9X [Occ=Once] :: e_a4BK
                      [LclId] =
                          [$dSemigroup4_sh9E e1_sh9M e'_sh9S] \u []
                              GHC.Base.<> $dSemigroup4_sh9E e1_sh9M e'_sh9S; } in
                    let {
                      sat_sh9W [Occ=Once] :: d_a4BJ
                      [LclId] =
                          [$dSemigroup3_sh9D d1_sh9L d'_sh9R] \u []
                              GHC.Base.<> $dSemigroup3_sh9D d1_sh9L d'_sh9R; } in
                    let {
                      sat_sh9V [Occ=Once] :: c_a4BI
                      [LclId] =
                          [$dSemigroup2_sh9C c1_sh9K c'_sh9Q] \u []
                              GHC.Base.<> $dSemigroup2_sh9C c1_sh9K c'_sh9Q; } in
                    let {
                      sat_sh9U [Occ=Once] :: b_a4BH
                      [LclId] =
                          [$dSemigroup1_sh9B b1_sh9J b'_sh9P] \u []
                              GHC.Base.<> $dSemigroup1_sh9B b1_sh9J b'_sh9P; } in
                    let {
                      sat_sh9T [Occ=Once] :: a_a4BG
                      [LclId] =
                          [$dSemigroup_sh9A a1_sh9I a'_sh9O] \u []
                              GHC.Base.<> $dSemigroup_sh9A a1_sh9I a'_sh9O;
                    } in  (,,,,) [sat_sh9T sat_sh9U sat_sh9V sat_sh9W sat_sh9X];
              };
        };

GHC.Base.$fMonoid(,,,,)_$csconcat
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     GHC.Base.NonEmpty (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U,U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sh9Y
           $dSemigroup1_sh9Z
           $dSemigroup2_sha0
           $dSemigroup3_sha1
           $dSemigroup4_sha2
           ds_sha3]
        case ds_sha3 of {
          GHC.Base.:| a1_sha5 [Occ=Once!] as_sha6 [Occ=Once] ->
              case a1_sha5 of {
                (,,,,) ww1_sha8 [Occ=Once]
                       ww2_sha9 [Occ=Once]
                       ww3_shaa [Occ=Once]
                       ww4_shab [Occ=Once]
                       ww5_shac [Occ=Once] ->
                    let {
                      $wgo_shad [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                        :: a_a4BG
                           -> b_a4BH
                           -> c_a4BI
                           -> d_a4BJ
                           -> e_a4BK
                           -> [(a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)]
                           -> (# a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK #)
                      [LclId,
                       Arity=6,
                       Str=<L,U><L,U><L,U><L,U><L,U><S,1*U>,
                       Unf=OtherCon []] =
                          sat-only [$dSemigroup_sh9Y
                                    $dSemigroup1_sh9Z
                                    $dSemigroup2_sha0
                                    $dSemigroup3_sha1
                                    $dSemigroup4_sha2
                                    $wgo_shad] \r [ww6_shae
                                                   ww7_shaf
                                                   ww8_shag
                                                   ww9_shah
                                                   ww10_shai
                                                   w_shaj]
                              case w_shaj of {
                                [] -> (#,,,,#) [ww6_shae ww7_shaf ww8_shag ww9_shah ww10_shai];
                                : c1_shal [Occ=Once!] cs_sham [Occ=Once] ->
                                    case c1_shal of {
                                      (,,,,) ww12_shao [Occ=Once]
                                             ww13_shap [Occ=Once]
                                             ww14_shaq [Occ=Once]
                                             ww15_shar [Occ=Once]
                                             ww16_shas [Occ=Once] ->
                                          case
                                              $wgo_shad
                                                  ww12_shao
                                                  ww13_shap
                                                  ww14_shaq
                                                  ww15_shar
                                                  ww16_shas
                                                  cs_sham
                                          of
                                          { (#,,,,#) ww18_shau [Occ=Once]
                                                     ww19_shav [Occ=Once]
                                                     ww20_shaw [Occ=Once]
                                                     ww21_shax [Occ=Once]
                                                     ww22_shay [Occ=Once] ->
                                                let {
                                                  sat_shaD [Occ=Once] :: e_a4BK
                                                  [LclId] =
                                                      [$dSemigroup4_sha2 ww10_shai ww22_shay] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup4_sha2
                                                              ww10_shai
                                                              ww22_shay; } in
                                                let {
                                                  sat_shaC [Occ=Once] :: d_a4BJ
                                                  [LclId] =
                                                      [$dSemigroup3_sha1 ww9_shah ww21_shax] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup3_sha1
                                                              ww9_shah
                                                              ww21_shax; } in
                                                let {
                                                  sat_shaB [Occ=Once] :: c_a4BI
                                                  [LclId] =
                                                      [$dSemigroup2_sha0 ww8_shag ww20_shaw] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup2_sha0
                                                              ww8_shag
                                                              ww20_shaw; } in
                                                let {
                                                  sat_shaA [Occ=Once] :: b_a4BH
                                                  [LclId] =
                                                      [$dSemigroup1_sh9Z ww7_shaf ww19_shav] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup1_sh9Z
                                                              ww7_shaf
                                                              ww19_shav; } in
                                                let {
                                                  sat_shaz [Occ=Once] :: a_a4BG
                                                  [LclId] =
                                                      [$dSemigroup_sh9Y ww6_shae ww18_shau] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup_sh9Y ww6_shae ww18_shau;
                                                } in 
                                                  (#,,,,#) [sat_shaz
                                                            sat_shaA
                                                            sat_shaB
                                                            sat_shaC
                                                            sat_shaD];
                                          };
                                    };
                              };
                    } in 
                      case
                          $wgo_shad ww1_sha8 ww2_sha9 ww3_shaa ww4_shab ww5_shac as_sha6
                      of
                      { (#,,,,#) ww7_shaF [Occ=Once]
                                 ww8_shaG [Occ=Once]
                                 ww9_shaH [Occ=Once]
                                 ww10_shaI [Occ=Once]
                                 ww11_shaJ [Occ=Once] ->
                            (,,,,) [ww7_shaF ww8_shaG ww9_shaH ww10_shaI ww11_shaJ];
                      };
              };
        };

GHC.Base.$fMonoid(,,,,)_$cstimes
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     forall b1.
     GHC.Real.Integral b1 =>
     b1 -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_shaK
           $dSemigroup1_shaL
           $dSemigroup2_shaM
           $dSemigroup3_shaN
           $dSemigroup4_shaO
           $dIntegral_shaP
           n_shaQ
           ds_shaR]
        case ds_shaR of {
          (,,,,) a1_shaT [Occ=Once]
                 b2_shaU [Occ=Once]
                 c1_shaV [Occ=Once]
                 d1_shaW [Occ=Once]
                 e1_shaX [Occ=Once] ->
              let {
                sat_shb2 [Occ=Once] :: e_a4BK
                [LclId] =
                    [$dSemigroup4_shaO $dIntegral_shaP n_shaQ e1_shaX] \u []
                        GHC.Base.stimes
                            $dSemigroup4_shaO $dIntegral_shaP n_shaQ e1_shaX; } in
              let {
                sat_shb1 [Occ=Once] :: d_a4BJ
                [LclId] =
                    [$dSemigroup3_shaN $dIntegral_shaP n_shaQ d1_shaW] \u []
                        GHC.Base.stimes
                            $dSemigroup3_shaN $dIntegral_shaP n_shaQ d1_shaW; } in
              let {
                sat_shb0 [Occ=Once] :: c_a4BI
                [LclId] =
                    [$dSemigroup2_shaM $dIntegral_shaP n_shaQ c1_shaV] \u []
                        GHC.Base.stimes
                            $dSemigroup2_shaM $dIntegral_shaP n_shaQ c1_shaV; } in
              let {
                sat_shaZ [Occ=Once] :: b_a4BH
                [LclId] =
                    [$dSemigroup1_shaL $dIntegral_shaP n_shaQ b2_shaU] \u []
                        GHC.Base.stimes
                            $dSemigroup1_shaL $dIntegral_shaP n_shaQ b2_shaU; } in
              let {
                sat_shaY [Occ=Once] :: a_a4BG
                [LclId] =
                    [$dSemigroup_shaK $dIntegral_shaP n_shaQ a1_shaT] \u []
                        GHC.Base.stimes $dSemigroup_shaK $dIntegral_shaP n_shaQ a1_shaT;
              } in  (,,,,) [sat_shaY sat_shaZ sat_shb0 sat_shb1 sat_shb2];
        };

GHC.Base.$fSemigroup(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     GHC.Base.Semigroup (a, b, c, d, e)
[GblId[DFunId],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_shb3
           $dSemigroup1_shb4
           $dSemigroup2_shb5
           $dSemigroup3_shb6
           $dSemigroup4_shb7]
        let {
          sat_shba [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
          [LclId] =
              [$dSemigroup_shb3
               $dSemigroup1_shb4
               $dSemigroup2_shb5
               $dSemigroup3_shb6
               $dSemigroup4_shb7] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$cstimes
                      $dSemigroup_shb3
                      $dSemigroup1_shb4
                      $dSemigroup2_shb5
                      $dSemigroup3_shb6
                      $dSemigroup4_shb7
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_shb9 [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
          [LclId] =
              [$dSemigroup_shb3
               $dSemigroup1_shb4
               $dSemigroup2_shb5
               $dSemigroup3_shb6
               $dSemigroup4_shb7] \r [eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$csconcat
                      $dSemigroup_shb3
                      $dSemigroup1_shb4
                      $dSemigroup2_shb5
                      $dSemigroup3_shb6
                      $dSemigroup4_shb7
                      eta_B1; } in
        let {
          sat_shb8 [Occ=Once]
            :: (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
          [LclId] =
              [$dSemigroup_shb3
               $dSemigroup1_shb4
               $dSemigroup2_shb5
               $dSemigroup3_shb6
               $dSemigroup4_shb7] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$c<>
                      $dSemigroup_shb3
                      $dSemigroup1_shb4
                      $dSemigroup2_shb5
                      $dSemigroup3_shb6
                      $dSemigroup4_shb7
                      eta_B2
                      eta_B1;
        } in  GHC.Base.C:Semigroup [sat_shb8 sat_shb9 sat_shba];

GHC.Base.$w$cp1Monoid1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     (# (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e),
        GHC.Base.NonEmpty (a, b, c, d, e) -> (a, b, c, d, e),
        forall b1.
        GHC.Real.Integral b1 =>
        b1 -> (a, b, c, d, e) -> (a, b, c, d, e) #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [w_shbb w1_shbc w2_shbd w3_shbe w4_shbf]
        let {
          sat_shbw [Occ=OnceL] :: GHC.Base.Semigroup e_s6Nx
          [LclId] =
              [w4_shbf] \u [] GHC.Base.$p1Monoid w4_shbf; } in
        let {
          sat_shbv [Occ=OnceL] :: GHC.Base.Semigroup d_s6Nw
          [LclId] =
              [w3_shbe] \u [] GHC.Base.$p1Monoid w3_shbe; } in
        let {
          sat_shbu [Occ=OnceL] :: GHC.Base.Semigroup c_s6Nv
          [LclId] =
              [w2_shbd] \u [] GHC.Base.$p1Monoid w2_shbd; } in
        let {
          sat_shbt [Occ=OnceL] :: GHC.Base.Semigroup b_s6Nu
          [LclId] =
              [w1_shbc] \u [] GHC.Base.$p1Monoid w1_shbc; } in
        let {
          sat_shbs [Occ=OnceL] :: GHC.Base.Semigroup a_s6Nt
          [LclId] =
              [w_shbb] \u [] GHC.Base.$p1Monoid w_shbb; } in
        let {
          sat_shbx [Occ=Once]
            :: forall b1.
               GHC.Real.Integral b1 =>
               b1
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
          [LclId] =
              [sat_shbs sat_shbt sat_shbu sat_shbv sat_shbw] \r [eta_B3
                                                                 eta_B2
                                                                 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$cstimes
                      sat_shbs
                      sat_shbt
                      sat_shbu
                      sat_shbv
                      sat_shbw
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_shbq [Occ=OnceL] :: GHC.Base.Semigroup e_s6Nx
          [LclId] =
              [w4_shbf] \u [] GHC.Base.$p1Monoid w4_shbf; } in
        let {
          sat_shbp [Occ=OnceL] :: GHC.Base.Semigroup d_s6Nw
          [LclId] =
              [w3_shbe] \u [] GHC.Base.$p1Monoid w3_shbe; } in
        let {
          sat_shbo [Occ=OnceL] :: GHC.Base.Semigroup c_s6Nv
          [LclId] =
              [w2_shbd] \u [] GHC.Base.$p1Monoid w2_shbd; } in
        let {
          sat_shbn [Occ=OnceL] :: GHC.Base.Semigroup b_s6Nu
          [LclId] =
              [w1_shbc] \u [] GHC.Base.$p1Monoid w1_shbc; } in
        let {
          sat_shbm [Occ=OnceL] :: GHC.Base.Semigroup a_s6Nt
          [LclId] =
              [w_shbb] \u [] GHC.Base.$p1Monoid w_shbb; } in
        let {
          sat_shbr [Occ=Once]
            :: GHC.Base.NonEmpty (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
          [LclId] =
              [sat_shbm sat_shbn sat_shbo sat_shbp sat_shbq] \r [eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$csconcat
                      sat_shbm sat_shbn sat_shbo sat_shbp sat_shbq eta_B1; } in
        let {
          sat_shbk [Occ=OnceL] :: GHC.Base.Semigroup e_s6Nx
          [LclId] =
              [w4_shbf] \u [] GHC.Base.$p1Monoid w4_shbf; } in
        let {
          sat_shbj [Occ=OnceL] :: GHC.Base.Semigroup d_s6Nw
          [LclId] =
              [w3_shbe] \u [] GHC.Base.$p1Monoid w3_shbe; } in
        let {
          sat_shbi [Occ=OnceL] :: GHC.Base.Semigroup c_s6Nv
          [LclId] =
              [w2_shbd] \u [] GHC.Base.$p1Monoid w2_shbd; } in
        let {
          sat_shbh [Occ=OnceL] :: GHC.Base.Semigroup b_s6Nu
          [LclId] =
              [w1_shbc] \u [] GHC.Base.$p1Monoid w1_shbc; } in
        let {
          sat_shbg [Occ=OnceL] :: GHC.Base.Semigroup a_s6Nt
          [LclId] =
              [w_shbb] \u [] GHC.Base.$p1Monoid w_shbb; } in
        let {
          sat_shbl [Occ=Once]
            :: (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
          [LclId] =
              [sat_shbg sat_shbh sat_shbi sat_shbj sat_shbk] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$c<>
                      sat_shbg sat_shbh sat_shbi sat_shbj sat_shbk eta_B2 eta_B1;
        } in  (#,,#) [sat_shbl sat_shbr sat_shbx];

GHC.Base.$fMonoid(,,,,)_$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     GHC.Base.Semigroup (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [w_shby w1_shbz w2_shbA w3_shbB w4_shbC]
        case
            GHC.Base.$w$cp1Monoid1 w_shby w1_shbz w2_shbA w3_shbB w4_shbC
        of
        { (#,,#) ww1_shbE [Occ=Once]
                 ww2_shbF [Occ=Once]
                 ww3_shbG [Occ=Once] ->
              GHC.Base.C:Semigroup [ww1_shbE ww2_shbF ww3_shbG];
        };

GHC.Base.$fMonoid(,,,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shbH
           $dMonoid1_shbI
           $dMonoid2_shbJ
           $dMonoid3_shbK
           $dMonoid4_shbL]
        case
            GHC.Base.$w$cp1Monoid1
                $dMonoid_shbH
                $dMonoid1_shbI
                $dMonoid2_shbJ
                $dMonoid3_shbK
                $dMonoid4_shbL
        of
        { (#,,#) ww1_shbN [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> ww1_shbN;
        };

GHC.Base.$fMonoid(,,,,)_$cmconcat
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     [(a, b, c, d, e)] -> (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shbQ
           $dMonoid1_shbR
           $dMonoid2_shbS
           $dMonoid3_shbT
           $dMonoid4_shbU]
        let {
          k_shbV [Occ=OnceL, Dmd=<L,1*U(1*C(C1(U(U,U,U,U,U))),A,A)>]
            :: GHC.Base.Semigroup (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_shbQ
               $dMonoid1_shbR
               $dMonoid2_shbS
               $dMonoid3_shbT
               $dMonoid4_shbU] \s []
                  case
                      GHC.Base.$w$cp1Monoid1
                          $dMonoid_shbQ
                          $dMonoid1_shbR
                          $dMonoid2_shbS
                          $dMonoid3_shbT
                          $dMonoid4_shbU
                  of
                  { (#,,#) ww1_shbX [Occ=Once]
                           ww2_shbY [Occ=Once]
                           ww3_shbZ [Occ=Once] ->
                        GHC.Base.C:Semigroup [ww1_shbX ww2_shbY ww3_shbZ];
                  }; } in
        let {
          k1_shc0 [Occ=OnceL!, Dmd=<L,C(C1(U(U,U,U,U,U)))>]
            :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [k_shbV] \u [] GHC.Base.<> k_shbV; } in
        let {
          z_shc1 [Occ=OnceL] :: a_a4x5
          [LclId] =
              [$dMonoid_shbQ] \u [] GHC.Base.mempty $dMonoid_shbQ; } in
        let {
          z1_shc2 [Occ=OnceL] :: b_a4x6
          [LclId] =
              [$dMonoid1_shbR] \u [] GHC.Base.mempty $dMonoid1_shbR; } in
        let {
          z2_shc3 [Occ=OnceL] :: c_a4x7
          [LclId] =
              [$dMonoid2_shbS] \u [] GHC.Base.mempty $dMonoid2_shbS; } in
        let {
          z3_shc4 [Occ=OnceL] :: d_a4x8
          [LclId] =
              [$dMonoid3_shbT] \u [] GHC.Base.mempty $dMonoid3_shbT; } in
        let {
          z4_shc5 [Occ=OnceL] :: e_a4x9
          [LclId] =
              [$dMonoid4_shbU] \u [] GHC.Base.mempty $dMonoid4_shbU; } in
        let {
          z5_shc6 [Occ=OnceL, Dmd=<L,U(U,U,U,U,U)>]
            :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId, Unf=OtherCon []] =
              CCCS (,,,,)! [z_shc1 z1_shc2 z2_shc3 z3_shc4 z4_shc5]; } in
        let {
          go_shc7 [Occ=LoopBreaker]
            :: [(a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)]
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [k1_shc0 z5_shc6 go_shc7] \r [ds_shc8]
                  case ds_shc8 of {
                    [] -> z5_shc6;
                    : y_shca [Occ=Once] ys_shcb [Occ=Once] ->
                        let {
                          sat_shcc [Occ=Once] :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
                          [LclId] =
                              [go_shc7 ys_shcb] \u [] go_shc7 ys_shcb;
                        } in  k1_shc0 y_shca sat_shcc;
                  };
        } in  go_shc7;

GHC.Base.$fMonoid(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     GHC.Base.Monoid (a, b, c, d, e)
[GblId[DFunId],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_shcd
           $dMonoid1_shce
           $dMonoid2_shcf
           $dMonoid3_shcg
           $dMonoid4_shch]
        let {
          sat_shcl [Occ=Once]
            :: [(a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)]
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_shcd
               $dMonoid1_shce
               $dMonoid2_shcf
               $dMonoid3_shcg
               $dMonoid4_shch] \u []
                  GHC.Base.$fMonoid(,,,,)_$cmconcat
                      $dMonoid_shcd
                      $dMonoid1_shce
                      $dMonoid2_shcf
                      $dMonoid3_shcg
                      $dMonoid4_shch; } in
        let {
          sat_shck [Occ=Once]
            :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_shcd
               $dMonoid1_shce
               $dMonoid2_shcf
               $dMonoid3_shcg
               $dMonoid4_shch] \u []
                  GHC.Base.$fMonoid(,,,,)_$cmappend
                      $dMonoid_shcd
                      $dMonoid1_shce
                      $dMonoid2_shcf
                      $dMonoid3_shcg
                      $dMonoid4_shch; } in
        let {
          sat_shcj [Occ=Once] :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_shcd
               $dMonoid1_shce
               $dMonoid2_shcf
               $dMonoid3_shcg
               $dMonoid4_shch] \u []
                  GHC.Base.$fMonoid(,,,,)_$cmempty
                      $dMonoid_shcd
                      $dMonoid1_shce
                      $dMonoid2_shcf
                      $dMonoid3_shcg
                      $dMonoid4_shch; } in
        let {
          sat_shci [Occ=Once]
            :: GHC.Base.Semigroup (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_shcd
               $dMonoid1_shce
               $dMonoid2_shcf
               $dMonoid3_shcg
               $dMonoid4_shch] \u []
                  GHC.Base.$fMonoid(,,,,)_$cp1Monoid
                      $dMonoid_shcd
                      $dMonoid1_shce
                      $dMonoid2_shcf
                      $dMonoid3_shcg
                      $dMonoid4_shch;
        } in  GHC.Base.C:Monoid [sat_shci sat_shcj sat_shck sat_shcl];

GHC.Base.$fMonoid(,,,)_$c<>
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U,U)><S,1*U(U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_shcm
           $dSemigroup1_shcn
           $dSemigroup2_shco
           $dSemigroup3_shcp
           ds_shcq
           ds1_shcr]
        case ds_shcq of {
          (,,,) a1_shct [Occ=Once]
                b1_shcu [Occ=Once]
                c1_shcv [Occ=Once]
                d1_shcw [Occ=Once] ->
              case ds1_shcr of {
                (,,,) a'_shcy [Occ=Once]
                      b'_shcz [Occ=Once]
                      c'_shcA [Occ=Once]
                      d'_shcB [Occ=Once] ->
                    let {
                      sat_shcF [Occ=Once] :: d_a4CF
                      [LclId] =
                          [$dSemigroup3_shcp d1_shcw d'_shcB] \u []
                              GHC.Base.<> $dSemigroup3_shcp d1_shcw d'_shcB; } in
                    let {
                      sat_shcE [Occ=Once] :: c_a4CE
                      [LclId] =
                          [$dSemigroup2_shco c1_shcv c'_shcA] \u []
                              GHC.Base.<> $dSemigroup2_shco c1_shcv c'_shcA; } in
                    let {
                      sat_shcD [Occ=Once] :: b_a4CD
                      [LclId] =
                          [$dSemigroup1_shcn b1_shcu b'_shcz] \u []
                              GHC.Base.<> $dSemigroup1_shcn b1_shcu b'_shcz; } in
                    let {
                      sat_shcC [Occ=Once] :: a_a4CC
                      [LclId] =
                          [$dSemigroup_shcm a1_shct a'_shcy] \u []
                              GHC.Base.<> $dSemigroup_shcm a1_shct a'_shcy;
                    } in  (,,,) [sat_shcC sat_shcD sat_shcE sat_shcF];
              };
        };

GHC.Base.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     a -> b -> c -> d -> [(a, b, c, d)] -> (# a, b, c, d #)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_shcG
           w1_shcH
           w2_shcI
           w3_shcJ
           ww_shcK
           ww1_shcL
           ww2_shcM
           ww3_shcN
           ww4_shcO]
        let {
          $wgo_shcP [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: a_s6Ow
               -> b_s6Ox
               -> c_s6Oy
               -> d_s6Oz
               -> [(a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz)]
               -> (# a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz #)
          [LclId,
           Arity=5,
           Str=<L,U><L,U><L,U><L,U><S,1*U>,
           Unf=OtherCon []] =
              sat-only [w_shcG w1_shcH w2_shcI w3_shcJ $wgo_shcP] \r [ww5_shcQ
                                                                      ww6_shcR
                                                                      ww7_shcS
                                                                      ww8_shcT
                                                                      w4_shcU]
                  case w4_shcU of {
                    [] -> (#,,,#) [ww5_shcQ ww6_shcR ww7_shcS ww8_shcT];
                    : c1_shcW [Occ=Once!] cs_shcX [Occ=Once] ->
                        case c1_shcW of {
                          (,,,) ww10_shcZ [Occ=Once]
                                ww11_shd0 [Occ=Once]
                                ww12_shd1 [Occ=Once]
                                ww13_shd2 [Occ=Once] ->
                              case $wgo_shcP ww10_shcZ ww11_shd0 ww12_shd1 ww13_shd2 cs_shcX of {
                                (#,,,#) ww15_shd4 [Occ=Once]
                                        ww16_shd5 [Occ=Once]
                                        ww17_shd6 [Occ=Once]
                                        ww18_shd7 [Occ=Once] ->
                                    let {
                                      sat_shdb [Occ=Once] :: d_s6Oz
                                      [LclId] =
                                          [w3_shcJ ww8_shcT ww18_shd7] \u []
                                              GHC.Base.<> w3_shcJ ww8_shcT ww18_shd7; } in
                                    let {
                                      sat_shda [Occ=Once] :: c_s6Oy
                                      [LclId] =
                                          [w2_shcI ww7_shcS ww17_shd6] \u []
                                              GHC.Base.<> w2_shcI ww7_shcS ww17_shd6; } in
                                    let {
                                      sat_shd9 [Occ=Once] :: b_s6Ox
                                      [LclId] =
                                          [w1_shcH ww6_shcR ww16_shd5] \u []
                                              GHC.Base.<> w1_shcH ww6_shcR ww16_shd5; } in
                                    let {
                                      sat_shd8 [Occ=Once] :: a_s6Ow
                                      [LclId] =
                                          [w_shcG ww5_shcQ ww15_shd4] \u []
                                              GHC.Base.<> w_shcG ww5_shcQ ww15_shd4;
                                    } in  (#,,,#) [sat_shd8 sat_shd9 sat_shda sat_shdb];
                              };
                        };
                  };
        } in  $wgo_shcP ww_shcK ww1_shcL ww2_shcM ww3_shcN ww4_shcO;

GHC.Base.$fSemigroup(,,,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     GHC.Base.NonEmpty (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_shdc w1_shdd w2_shde w3_shdf w4_shdg]
        case w4_shdg of {
          GHC.Base.:| ww1_shdi [Occ=Once!] ww2_shdj [Occ=Once] ->
              case ww1_shdi of {
                (,,,) ww4_shdl [Occ=Once]
                      ww5_shdm [Occ=Once]
                      ww6_shdn [Occ=Once]
                      ww7_shdo [Occ=Once] ->
                    case
                        GHC.Base.$w$csconcat2
                            w_shdc
                            w1_shdd
                            w2_shde
                            w3_shdf
                            ww4_shdl
                            ww5_shdm
                            ww6_shdn
                            ww7_shdo
                            ww2_shdj
                    of
                    { (#,,,#) ww9_shdq [Occ=Once]
                              ww10_shdr [Occ=Once]
                              ww11_shds [Occ=Once]
                              ww12_shdt [Occ=Once] ->
                          (,,,) [ww9_shdq ww10_shdr ww11_shds ww12_shdt];
                    };
              };
        };

GHC.Base.$fSemigroup(,,,)_$cstimes [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     forall b1.
     GHC.Real.Integral b1 =>
     b1 -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shdu w1_shdv w2_shdw w3_shdx w4_shdy w5_shdz w6_shdA]
        case w6_shdA of {
          (,,,) ww1_shdC [Occ=Once]
                ww2_shdD [Occ=Once]
                ww3_shdE [Occ=Once]
                ww4_shdF [Occ=Once] ->
              let {
                sat_shdJ [Occ=Once] :: d_s6OY
                [LclId] =
                    [w3_shdx w4_shdy w5_shdz ww4_shdF] \u []
                        GHC.Base.stimes w3_shdx w4_shdy w5_shdz ww4_shdF; } in
              let {
                sat_shdI [Occ=Once] :: c_s6OX
                [LclId] =
                    [w2_shdw w4_shdy w5_shdz ww3_shdE] \u []
                        GHC.Base.stimes w2_shdw w4_shdy w5_shdz ww3_shdE; } in
              let {
                sat_shdH [Occ=Once] :: b_s6OW
                [LclId] =
                    [w1_shdv w4_shdy w5_shdz ww2_shdD] \u []
                        GHC.Base.stimes w1_shdv w4_shdy w5_shdz ww2_shdD; } in
              let {
                sat_shdG [Occ=Once] :: a_s6OV
                [LclId] =
                    [w_shdu w4_shdy w5_shdz ww1_shdC] \u []
                        GHC.Base.stimes w_shdu w4_shdy w5_shdz ww1_shdC;
              } in  (,,,) [sat_shdG sat_shdH sat_shdI sat_shdJ];
        };

GHC.Base.$fSemigroup(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     GHC.Base.Semigroup (a, b, c, d)
[GblId[DFunId],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_shdK
           $dSemigroup1_shdL
           $dSemigroup2_shdM
           $dSemigroup3_shdN]
        let {
          sat_shdQ [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
          [LclId] =
              [$dSemigroup_shdK
               $dSemigroup1_shdL
               $dSemigroup2_shdM
               $dSemigroup3_shdN] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(,,,)_$cstimes
                      $dSemigroup_shdK
                      $dSemigroup1_shdL
                      $dSemigroup2_shdM
                      $dSemigroup3_shdN
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_shdP [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
          [LclId] =
              [$dSemigroup_shdK
               $dSemigroup1_shdL
               $dSemigroup2_shdM
               $dSemigroup3_shdN] \r [eta_B1]
                  GHC.Base.$fSemigroup(,,,)_$csconcat
                      $dSemigroup_shdK
                      $dSemigroup1_shdL
                      $dSemigroup2_shdM
                      $dSemigroup3_shdN
                      eta_B1; } in
        let {
          sat_shdO [Occ=Once]
            :: (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
          [LclId] =
              [$dSemigroup_shdK
               $dSemigroup1_shdL
               $dSemigroup2_shdM
               $dSemigroup3_shdN] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,)_$c<>
                      $dSemigroup_shdK
                      $dSemigroup1_shdL
                      $dSemigroup2_shdM
                      $dSemigroup3_shdN
                      eta_B2
                      eta_B1;
        } in  GHC.Base.C:Semigroup [sat_shdO sat_shdP sat_shdQ];

GHC.Base.$w$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     (# (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d),
        GHC.Base.NonEmpty (a, b, c, d) -> (a, b, c, d),
        forall b1.
        GHC.Real.Integral b1 =>
        b1 -> (a, b, c, d) -> (a, b, c, d) #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [w_shdR w1_shdS w2_shdT w3_shdU]
        let {
          w4_shej [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup d_s6Pl
          [LclId] =
              [w3_shdU] \u [] GHC.Base.$p1Monoid w3_shdU; } in
        let {
          w5_shek [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup c_s6Pk
          [LclId] =
              [w2_shdT] \u [] GHC.Base.$p1Monoid w2_shdT; } in
        let {
          w6_shel [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_s6Pj
          [LclId] =
              [w1_shdS] \u [] GHC.Base.$p1Monoid w1_shdS; } in
        let {
          w7_shem [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_s6Pi
          [LclId] =
              [w_shdR] \u [] GHC.Base.$p1Monoid w_shdR; } in
        let {
          sat_shez [Occ=Once]
            :: forall b1.
               GHC.Real.Integral b1 =>
               b1
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
          [LclId] =
              [w4_shej w5_shek w6_shel w7_shem] \r [w8_shen w9_sheo w10_shep]
                  case w10_shep of {
                    (,,,) ww1_sher [Occ=Once]
                          ww2_shes [Occ=Once]
                          ww3_shet [Occ=Once]
                          ww4_sheu [Occ=Once] ->
                        let {
                          sat_shey [Occ=Once] :: d_s6Pl
                          [LclId] =
                              [w4_shej w8_shen w9_sheo ww4_sheu] \u []
                                  GHC.Base.stimes w4_shej w8_shen w9_sheo ww4_sheu; } in
                        let {
                          sat_shex [Occ=Once] :: c_s6Pk
                          [LclId] =
                              [w5_shek w8_shen w9_sheo ww3_shet] \u []
                                  GHC.Base.stimes w5_shek w8_shen w9_sheo ww3_shet; } in
                        let {
                          sat_shew [Occ=Once] :: b_s6Pj
                          [LclId] =
                              [w6_shel w8_shen w9_sheo ww2_shes] \u []
                                  GHC.Base.stimes w6_shel w8_shen w9_sheo ww2_shes; } in
                        let {
                          sat_shev [Occ=Once] :: a_s6Pi
                          [LclId] =
                              [w7_shem w8_shen w9_sheo ww1_sher] \u []
                                  GHC.Base.stimes w7_shem w8_shen w9_sheo ww1_sher;
                        } in  (,,,) [sat_shev sat_shew sat_shex sat_shey];
                  }; } in
        let {
          w4_she0 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup d_s6Pl
          [LclId] =
              [w3_shdU] \u [] GHC.Base.$p1Monoid w3_shdU; } in
        let {
          w5_she1 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup c_s6Pk
          [LclId] =
              [w2_shdT] \u [] GHC.Base.$p1Monoid w2_shdT; } in
        let {
          w6_she2 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_s6Pj
          [LclId] =
              [w1_shdS] \u [] GHC.Base.$p1Monoid w1_shdS; } in
        let {
          w7_she3 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_s6Pi
          [LclId] =
              [w_shdR] \u [] GHC.Base.$p1Monoid w_shdR; } in
        let {
          sat_shei [Occ=Once]
            :: GHC.Base.NonEmpty (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
          [LclId] =
              [w4_she0 w5_she1 w6_she2 w7_she3] \r [w8_she4]
                  case w8_she4 of {
                    GHC.Base.:| ww1_she6 [Occ=Once!] ww2_she7 [Occ=Once] ->
                        case ww1_she6 of {
                          (,,,) ww4_she9 [Occ=Once]
                                ww5_shea [Occ=Once]
                                ww6_sheb [Occ=Once]
                                ww7_shec [Occ=Once] ->
                              case
                                  GHC.Base.$w$csconcat2
                                      w7_she3
                                      w6_she2
                                      w5_she1
                                      w4_she0
                                      ww4_she9
                                      ww5_shea
                                      ww6_sheb
                                      ww7_shec
                                      ww2_she7
                              of
                              { (#,,,#) ww9_shee [Occ=Once]
                                        ww10_shef [Occ=Once]
                                        ww11_sheg [Occ=Once]
                                        ww12_sheh [Occ=Once] ->
                                    (,,,) [ww9_shee ww10_shef ww11_sheg ww12_sheh];
                              };
                        };
                  }; } in
        let {
          sat_shdY [Occ=OnceL] :: GHC.Base.Semigroup d_s6Pl
          [LclId] =
              [w3_shdU] \u [] GHC.Base.$p1Monoid w3_shdU; } in
        let {
          sat_shdX [Occ=OnceL] :: GHC.Base.Semigroup c_s6Pk
          [LclId] =
              [w2_shdT] \u [] GHC.Base.$p1Monoid w2_shdT; } in
        let {
          sat_shdW [Occ=OnceL] :: GHC.Base.Semigroup b_s6Pj
          [LclId] =
              [w1_shdS] \u [] GHC.Base.$p1Monoid w1_shdS; } in
        let {
          sat_shdV [Occ=OnceL] :: GHC.Base.Semigroup a_s6Pi
          [LclId] =
              [w_shdR] \u [] GHC.Base.$p1Monoid w_shdR; } in
        let {
          sat_shdZ [Occ=Once]
            :: (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
          [LclId] =
              [sat_shdV sat_shdW sat_shdX sat_shdY] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,)_$c<>
                      sat_shdV sat_shdW sat_shdX sat_shdY eta_B2 eta_B1;
        } in  (#,,#) [sat_shdZ sat_shei sat_shez];

GHC.Base.$fMonoid(,,,)_$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     GHC.Base.Semigroup (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [w_sheA w1_sheB w2_sheC w3_sheD]
        case GHC.Base.$w$cp1Monoid w_sheA w1_sheB w2_sheC w3_sheD of {
          (#,,#) ww1_sheF [Occ=Once]
                 ww2_sheG [Occ=Once]
                 ww3_sheH [Occ=Once] ->
              GHC.Base.C:Semigroup [ww1_sheF ww2_sheG ww3_sheH];
        };

GHC.Base.$fMonoid(,,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sheI $dMonoid1_sheJ $dMonoid2_sheK $dMonoid3_sheL]
        case
            GHC.Base.$w$cp1Monoid
                $dMonoid_sheI $dMonoid1_sheJ $dMonoid2_sheK $dMonoid3_sheL
        of
        { (#,,#) ww1_sheN [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> ww1_sheN;
        };

GHC.Base.$fMonoid(,,,)_$cmconcat
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     [(a, b, c, d)] -> (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sheQ $dMonoid1_sheR $dMonoid2_sheS $dMonoid3_sheT]
        let {
          k_sheU [Occ=OnceL, Dmd=<L,1*U(1*C(C1(U(U,U,U,U))),A,A)>]
            :: GHC.Base.Semigroup (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_sheQ $dMonoid1_sheR $dMonoid2_sheS $dMonoid3_sheT] \s []
                  case
                      GHC.Base.$w$cp1Monoid
                          $dMonoid_sheQ $dMonoid1_sheR $dMonoid2_sheS $dMonoid3_sheT
                  of
                  { (#,,#) ww1_sheW [Occ=Once]
                           ww2_sheX [Occ=Once]
                           ww3_sheY [Occ=Once] ->
                        GHC.Base.C:Semigroup [ww1_sheW ww2_sheX ww3_sheY];
                  }; } in
        let {
          k1_sheZ [Occ=OnceL!, Dmd=<L,C(C1(U(U,U,U,U)))>]
            :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [k_sheU] \u [] GHC.Base.<> k_sheU; } in
        let {
          z_shf0 [Occ=OnceL] :: a_a4xJ
          [LclId] =
              [$dMonoid_sheQ] \u [] GHC.Base.mempty $dMonoid_sheQ; } in
        let {
          z1_shf1 [Occ=OnceL] :: b_a4xK
          [LclId] =
              [$dMonoid1_sheR] \u [] GHC.Base.mempty $dMonoid1_sheR; } in
        let {
          z2_shf2 [Occ=OnceL] :: c_a4xL
          [LclId] =
              [$dMonoid2_sheS] \u [] GHC.Base.mempty $dMonoid2_sheS; } in
        let {
          z3_shf3 [Occ=OnceL] :: d_a4xM
          [LclId] =
              [$dMonoid3_sheT] \u [] GHC.Base.mempty $dMonoid3_sheT; } in
        let {
          z4_shf4 [Occ=OnceL, Dmd=<L,U(U,U,U,U)>]
            :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId, Unf=OtherCon []] =
              CCCS (,,,)! [z_shf0 z1_shf1 z2_shf2 z3_shf3]; } in
        let {
          go_shf5 [Occ=LoopBreaker]
            :: [(a_a4xJ, b_a4xK, c_a4xL, d_a4xM)]
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [k1_sheZ z4_shf4 go_shf5] \r [ds_shf6]
                  case ds_shf6 of {
                    [] -> z4_shf4;
                    : y_shf8 [Occ=Once] ys_shf9 [Occ=Once] ->
                        let {
                          sat_shfa [Occ=Once] :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
                          [LclId] =
                              [go_shf5 ys_shf9] \u [] go_shf5 ys_shf9;
                        } in  k1_sheZ y_shf8 sat_shfa;
                  };
        } in  go_shf5;

GHC.Base.$fMonoid(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     GHC.Base.Monoid (a, b, c, d)
[GblId[DFunId],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe]
        let {
          sat_shfi [Occ=Once]
            :: [(a_a4xJ, b_a4xK, c_a4xL, d_a4xM)]
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe] \u []
                  GHC.Base.$fMonoid(,,,)_$cmconcat
                      $dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe; } in
        let {
          sat_shfh [Occ=Once]
            :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe] \u []
                  GHC.Base.$fMonoid(,,,)_$cmappend
                      $dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe; } in
        let {
          sat_shfg [Occ=Once] :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe] \u []
                  GHC.Base.$fMonoid(,,,)_$cmempty
                      $dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe; } in
        let {
          sat_shff [Occ=Once]
            :: GHC.Base.Semigroup (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe] \u []
                  GHC.Base.$fMonoid(,,,)_$cp1Monoid
                      $dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe;
        } in  GHC.Base.C:Monoid [sat_shff sat_shfg sat_shfh sat_shfi];

GHC.Base.$fMonoid(,,)_$c<> [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     (a, b, c) -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U)><S,1*U(U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shfj w1_shfk w2_shfl w3_shfm w4_shfn]
        case w3_shfm of {
          (,,) ww1_shfp [Occ=Once] ww2_shfq [Occ=Once] ww3_shfr [Occ=Once] ->
              case w4_shfn of {
                (,,) ww5_shft [Occ=Once] ww6_shfu [Occ=Once] ww7_shfv [Occ=Once] ->
                    let {
                      sat_shfy [Occ=Once] :: c_s6PF
                      [LclId] =
                          [w2_shfl ww3_shfr ww7_shfv] \u []
                              GHC.Base.<> w2_shfl ww3_shfr ww7_shfv; } in
                    let {
                      sat_shfx [Occ=Once] :: b_s6PE
                      [LclId] =
                          [w1_shfk ww2_shfq ww6_shfu] \u []
                              GHC.Base.<> w1_shfk ww2_shfq ww6_shfu; } in
                    let {
                      sat_shfw [Occ=Once] :: a_s6PD
                      [LclId] =
                          [w_shfj ww1_shfp ww5_shft] \u []
                              GHC.Base.<> w_shfj ww1_shfp ww5_shft;
                    } in  (,,) [sat_shfw sat_shfx sat_shfy];
              };
        };

GHC.Base.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     a -> b -> c -> [(a, b, c)] -> (# a, b, c #)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_shfz w1_shfA w2_shfB ww_shfC ww1_shfD ww2_shfE ww3_shfF]
        let {
          $wgo_shfG [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: a_s6Qd
               -> b_s6Qe
               -> c_s6Qf
               -> [(a_s6Qd, b_s6Qe, c_s6Qf)]
               -> (# a_s6Qd, b_s6Qe, c_s6Qf #)
          [LclId, Arity=4, Str=<L,U><L,U><L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_shfz w1_shfA w2_shfB $wgo_shfG] \r [ww4_shfH
                                                              ww5_shfI
                                                              ww6_shfJ
                                                              w3_shfK]
                  case w3_shfK of {
                    [] -> (#,,#) [ww4_shfH ww5_shfI ww6_shfJ];
                    : c1_shfM [Occ=Once!] cs_shfN [Occ=Once] ->
                        case c1_shfM of {
                          (,,) ww8_shfP [Occ=Once]
                               ww9_shfQ [Occ=Once]
                               ww10_shfR [Occ=Once] ->
                              case $wgo_shfG ww8_shfP ww9_shfQ ww10_shfR cs_shfN of {
                                (#,,#) ww12_shfT [Occ=Once]
                                       ww13_shfU [Occ=Once]
                                       ww14_shfV [Occ=Once] ->
                                    let {
                                      sat_shfY [Occ=Once] :: c_s6Qf
                                      [LclId] =
                                          [w2_shfB ww6_shfJ ww14_shfV] \u []
                                              GHC.Base.<> w2_shfB ww6_shfJ ww14_shfV; } in
                                    let {
                                      sat_shfX [Occ=Once] :: b_s6Qe
                                      [LclId] =
                                          [w1_shfA ww5_shfI ww13_shfU] \u []
                                              GHC.Base.<> w1_shfA ww5_shfI ww13_shfU; } in
                                    let {
                                      sat_shfW [Occ=Once] :: a_s6Qd
                                      [LclId] =
                                          [w_shfz ww4_shfH ww12_shfT] \u []
                                              GHC.Base.<> w_shfz ww4_shfH ww12_shfT;
                                    } in  (#,,#) [sat_shfW sat_shfX sat_shfY];
                              };
                        };
                  };
        } in  $wgo_shfG ww_shfC ww1_shfD ww2_shfE ww3_shfF;

GHC.Base.$fSemigroup(,,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     GHC.Base.NonEmpty (a, b, c) -> (a, b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_shfZ w1_shg0 w2_shg1 w3_shg2]
        case w3_shg2 of {
          GHC.Base.:| ww1_shg4 [Occ=Once!] ww2_shg5 [Occ=Once] ->
              case ww1_shg4 of {
                (,,) ww4_shg7 [Occ=Once] ww5_shg8 [Occ=Once] ww6_shg9 [Occ=Once] ->
                    case
                        GHC.Base.$w$csconcat1
                            w_shfZ w1_shg0 w2_shg1 ww4_shg7 ww5_shg8 ww6_shg9 ww2_shg5
                    of
                    { (#,,#) ww8_shgb [Occ=Once]
                             ww9_shgc [Occ=Once]
                             ww10_shgd [Occ=Once] ->
                          (,,) [ww8_shgb ww9_shgc ww10_shgd];
                    };
              };
        };

GHC.Base.$fMonoid(,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     (a, b, c) -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U,U)><S,1*U(U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shge
           $dMonoid1_shgf
           $dMonoid2_shgg
           eta_shgh
           eta1_shgi]
        case eta_shgh of {
          (,,) a1_shgk [Occ=Once] b1_shgl [Occ=Once] c1_shgm [Occ=Once] ->
              case eta1_shgi of {
                (,,) a'_shgo [Occ=Once] b'_shgp [Occ=Once] c'_shgq [Occ=Once] ->
                    let {
                      sat_shgw [Occ=Once] :: c_a4yl
                      [LclId] =
                          [$dMonoid2_shgg c1_shgm c'_shgq] \u []
                              case GHC.Base.$p1Monoid $dMonoid2_shgg of sat_shgv {
                                __DEFAULT -> GHC.Base.<> sat_shgv c1_shgm c'_shgq;
                              }; } in
                    let {
                      sat_shgu [Occ=Once] :: b_a4yk
                      [LclId] =
                          [$dMonoid1_shgf b1_shgl b'_shgp] \u []
                              case GHC.Base.$p1Monoid $dMonoid1_shgf of sat_shgt {
                                __DEFAULT -> GHC.Base.<> sat_shgt b1_shgl b'_shgp;
                              }; } in
                    let {
                      sat_shgs [Occ=Once] :: a_a4yj
                      [LclId] =
                          [$dMonoid_shge a1_shgk a'_shgo] \u []
                              case GHC.Base.$p1Monoid $dMonoid_shge of sat_shgr {
                                __DEFAULT -> GHC.Base.<> sat_shgr a1_shgk a'_shgo;
                              };
                    } in  (,,) [sat_shgs sat_shgu sat_shgw];
              };
        };

GHC.Base.$fMonoid(,,)_$cmconcat
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     [(a, b, c)] -> (a, b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shgx $dMonoid1_shgy $dMonoid2_shgz eta_shgA]
        let {
          $dSemigroup_shgB [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_a4yj
          [LclId] =
              [$dMonoid_shgx] \u [] GHC.Base.$p1Monoid $dMonoid_shgx; } in
        let {
          $dSemigroup1_shgC [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_a4yk
          [LclId] =
              [$dMonoid1_shgy] \u [] GHC.Base.$p1Monoid $dMonoid1_shgy; } in
        let {
          $dSemigroup2_shgD [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup c_a4yl
          [LclId] =
              [$dMonoid2_shgz] \u [] GHC.Base.$p1Monoid $dMonoid2_shgz; } in
        let {
          z_shgE [Occ=OnceL] :: a_a4yj
          [LclId] =
              [$dMonoid_shgx] \u [] GHC.Base.mempty $dMonoid_shgx; } in
        let {
          z1_shgF [Occ=OnceL] :: b_a4yk
          [LclId] =
              [$dMonoid1_shgy] \u [] GHC.Base.mempty $dMonoid1_shgy; } in
        let {
          z2_shgG [Occ=OnceL] :: c_a4yl
          [LclId] =
              [$dMonoid2_shgz] \u [] GHC.Base.mempty $dMonoid2_shgz; } in
        let {
          z3_shgH [Occ=OnceL, Dmd=<S,U(U,U,U)>] :: (a_a4yj, b_a4yk, c_a4yl)
          [LclId, Unf=OtherCon []] =
              CCCS (,,)! [z_shgE z1_shgF z2_shgG]; } in
        let {
          go_shgI [Occ=LoopBreaker]
            :: [(a_a4yj, b_a4yk, c_a4yl)] -> (a_a4yj, b_a4yk, c_a4yl)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_shgB
                        $dSemigroup1_shgC
                        $dSemigroup2_shgD
                        z3_shgH
                        go_shgI] \r [ds_shgJ]
                  case ds_shgJ of {
                    [] -> z3_shgH;
                    : y_shgL [Occ=Once!] ys_shgM [Occ=Once] ->
                        case y_shgL of {
                          (,,) a1_shgO [Occ=Once] b1_shgP [Occ=Once] c1_shgQ [Occ=Once] ->
                              case go_shgI ys_shgM of {
                                (,,) a'_shgS [Occ=Once] b'_shgT [Occ=Once] c'_shgU [Occ=Once] ->
                                    let {
                                      sat_shgX [Occ=Once] :: c_a4yl
                                      [LclId] =
                                          [$dSemigroup2_shgD c1_shgQ c'_shgU] \u []
                                              GHC.Base.<> $dSemigroup2_shgD c1_shgQ c'_shgU; } in
                                    let {
                                      sat_shgW [Occ=Once] :: b_a4yk
                                      [LclId] =
                                          [$dSemigroup1_shgC b1_shgP b'_shgT] \u []
                                              GHC.Base.<> $dSemigroup1_shgC b1_shgP b'_shgT; } in
                                    let {
                                      sat_shgV [Occ=Once] :: a_a4yj
                                      [LclId] =
                                          [$dSemigroup_shgB a1_shgO a'_shgS] \u []
                                              GHC.Base.<> $dSemigroup_shgB a1_shgO a'_shgS;
                                    } in  (,,) [sat_shgV sat_shgW sat_shgX];
                              };
                        };
                  };
        } in  go_shgI eta_shgA;

GHC.Base.$fSemigroup(,,)_$cstimes [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     forall b1. GHC.Real.Integral b1 => b1 -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shgY w1_shgZ w2_shh0 w3_shh1 w4_shh2 w5_shh3]
        case w5_shh3 of {
          (,,) ww1_shh5 [Occ=Once] ww2_shh6 [Occ=Once] ww3_shh7 [Occ=Once] ->
              let {
                sat_shha [Occ=Once] :: c_s6QJ
                [LclId] =
                    [w2_shh0 w3_shh1 w4_shh2 ww3_shh7] \u []
                        GHC.Base.stimes w2_shh0 w3_shh1 w4_shh2 ww3_shh7; } in
              let {
                sat_shh9 [Occ=Once] :: b_s6QI
                [LclId] =
                    [w1_shgZ w3_shh1 w4_shh2 ww2_shh6] \u []
                        GHC.Base.stimes w1_shgZ w3_shh1 w4_shh2 ww2_shh6; } in
              let {
                sat_shh8 [Occ=Once] :: a_s6QH
                [LclId] =
                    [w_shgY w3_shh1 w4_shh2 ww1_shh5] \u []
                        GHC.Base.stimes w_shgY w3_shh1 w4_shh2 ww1_shh5;
              } in  (,,) [sat_shh8 sat_shh9 sat_shha];
        };

GHC.Base.$fSemigroup(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     GHC.Base.Semigroup (a, b, c)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_shhb $dSemigroup1_shhc $dSemigroup2_shhd]
        let {
          sat_shhg [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> (a_a4Dq, b_a4Dr, c_a4Ds) -> (a_a4Dq, b_a4Dr, c_a4Ds)
          [LclId] =
              [$dSemigroup_shhb $dSemigroup1_shhc $dSemigroup2_shhd] \r [eta_B3
                                                                         eta_B2
                                                                         eta_B1]
                  GHC.Base.$fSemigroup(,,)_$cstimes
                      $dSemigroup_shhb
                      $dSemigroup1_shhc
                      $dSemigroup2_shhd
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_shhf [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4Dq, b_a4Dr, c_a4Ds)
               -> (a_a4Dq, b_a4Dr, c_a4Ds)
          [LclId] =
              [$dSemigroup_shhb $dSemigroup1_shhc $dSemigroup2_shhd] \r [eta_B1]
                  GHC.Base.$fSemigroup(,,)_$csconcat
                      $dSemigroup_shhb $dSemigroup1_shhc $dSemigroup2_shhd eta_B1; } in
        let {
          sat_shhe [Occ=Once]
            :: (a_a4Dq, b_a4Dr, c_a4Ds)
               -> (a_a4Dq, b_a4Dr, c_a4Ds) -> (a_a4Dq, b_a4Dr, c_a4Ds)
          [LclId] =
              [$dSemigroup_shhb $dSemigroup1_shhc $dSemigroup2_shhd] \r [eta_B2
                                                                         eta_B1]
                  GHC.Base.$fMonoid(,,)_$c<>
                      $dSemigroup_shhb $dSemigroup1_shhc $dSemigroup2_shhd eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_shhe sat_shhf sat_shhg];

GHC.Base.$fMonoid(,,)_$cp1Monoid
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     GHC.Base.Semigroup (a, b, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shhh $dMonoid1_shhi $dMonoid2_shhj]
        let {
          sat_shhm [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup c_a4yl
          [LclId] =
              [$dMonoid2_shhj] \u [] GHC.Base.$p1Monoid $dMonoid2_shhj; } in
        let {
          sat_shhl [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_a4yk
          [LclId] =
              [$dMonoid1_shhi] \u [] GHC.Base.$p1Monoid $dMonoid1_shhi; } in
        let {
          sat_shhk [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_a4yj
          [LclId] =
              [$dMonoid_shhh] \u [] GHC.Base.$p1Monoid $dMonoid_shhh;
        } in  GHC.Base.$fSemigroup(,,) sat_shhk sat_shhl sat_shhm;

GHC.Base.$fMonoid(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     GHC.Base.Monoid (a, b, c)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp]
        let {
          sat_shht [Occ=Once]
            :: [(a_a4yj, b_a4yk, c_a4yl)] -> (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp] \r [eta_B1]
                  GHC.Base.$fMonoid(,,)_$cmconcat
                      $dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp eta_B1; } in
        let {
          sat_shhs [Occ=Once]
            :: (a_a4yj, b_a4yk, c_a4yl)
               -> (a_a4yj, b_a4yk, c_a4yl) -> (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,)_$cmappend
                      $dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp eta_B2 eta_B1; } in
        let {
          sat_shhr [Occ=Once] :: (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp] \u []
                  GHC.Base.$fMonoid(,,)_$cmempty
                      $dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp; } in
        let {
          sat_shhq [Occ=Once] :: GHC.Base.Semigroup (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp] \u []
                  GHC.Base.$fMonoid(,,)_$cp1Monoid
                      $dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp;
        } in  GHC.Base.C:Monoid [sat_shhq sat_shhr sat_shhs sat_shht];

GHC.Base.$fSemigroup(,)_$c<>
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     (a, b) -> (a, b) -> (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_shhu $dSemigroup1_shhv ds_shhw ds1_shhx]
        case ds_shhw of {
          (,) a1_shhz [Occ=Once] b1_shhA [Occ=Once] ->
              case ds1_shhx of {
                (,) a'_shhC [Occ=Once] b'_shhD [Occ=Once] ->
                    let {
                      sat_shhF [Occ=Once] :: b_a4E7
                      [LclId] =
                          [$dSemigroup1_shhv b1_shhA b'_shhD] \u []
                              GHC.Base.<> $dSemigroup1_shhv b1_shhA b'_shhD; } in
                    let {
                      sat_shhE [Occ=Once] :: a_a4E6
                      [LclId] =
                          [$dSemigroup_shhu a1_shhz a'_shhC] \u []
                              GHC.Base.<> $dSemigroup_shhu a1_shhz a'_shhC;
                    } in  (,) [sat_shhE sat_shhF];
              };
        };

GHC.Base.$fSemigroup(,)_$cstimes
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     forall b1. GHC.Real.Integral b1 => b1 -> (a, b) -> (a, b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_shhG
           $dSemigroup1_shhH
           $dIntegral_shhI
           n_shhJ
           ds_shhK]
        case ds_shhK of {
          (,) a1_shhM [Occ=Once] b2_shhN [Occ=Once] ->
              let {
                sat_shhP [Occ=Once] :: b_a4E7
                [LclId] =
                    [$dSemigroup1_shhH $dIntegral_shhI n_shhJ b2_shhN] \u []
                        GHC.Base.stimes
                            $dSemigroup1_shhH $dIntegral_shhI n_shhJ b2_shhN; } in
              let {
                sat_shhO [Occ=Once] :: a_a4E6
                [LclId] =
                    [$dSemigroup_shhG $dIntegral_shhI n_shhJ a1_shhM] \u []
                        GHC.Base.stimes $dSemigroup_shhG $dIntegral_shhI n_shhJ a1_shhM;
              } in  (,) [sat_shhO sat_shhP];
        };

GHC.Base.$fSemigroup(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     GHC.Base.Semigroup (a, b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_shhQ $dSemigroup1_shhR]
        let {
          sat_shhU [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7)
          [LclId] =
              [$dSemigroup_shhQ $dSemigroup1_shhR] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(,)_$cstimes
                      $dSemigroup_shhQ $dSemigroup1_shhR eta_B3 eta_B2 eta_B1; } in
        let {
          sat_shhT [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7)
          [LclId] =
              [$dSemigroup_shhQ $dSemigroup1_shhR] \r [eta_B1]
                  GHC.Base.$fSemigroup(,)_$csconcat
                      $dSemigroup_shhQ $dSemigroup1_shhR eta_B1; } in
        let {
          sat_shhS [Occ=Once]
            :: (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7)
          [LclId] =
              [$dSemigroup_shhQ $dSemigroup1_shhR] \r [eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(,)_$c<>
                      $dSemigroup_shhQ $dSemigroup1_shhR eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_shhS sat_shhT sat_shhU];

GHC.Base.$fMonoid(,)_$cp1Monoid
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     GHC.Base.Semigroup (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shhV $dMonoid1_shhW]
        let {
          sat_shhY [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_a4yQ
          [LclId] =
              [$dMonoid1_shhW] \u [] GHC.Base.$p1Monoid $dMonoid1_shhW; } in
        let {
          sat_shhX [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_a4yP
          [LclId] =
              [$dMonoid_shhV] \u [] GHC.Base.$p1Monoid $dMonoid_shhV;
        } in  GHC.Base.$fSemigroup(,) sat_shhX sat_shhY;

GHC.Base.$fMonoid(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     GHC.Base.Monoid (a, b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_shhZ $dMonoid1_shi0]
        let {
          sat_shi4 [Occ=Once] :: [(a_a4yP, b_a4yQ)] -> (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_shhZ $dMonoid1_shi0] \r [eta_B1]
                  GHC.Base.$fMonoid(,)_$cmconcat
                      $dMonoid_shhZ $dMonoid1_shi0 eta_B1; } in
        let {
          sat_shi3 [Occ=Once]
            :: (a_a4yP, b_a4yQ) -> (a_a4yP, b_a4yQ) -> (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_shhZ $dMonoid1_shi0] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,)_$cmappend
                      $dMonoid_shhZ $dMonoid1_shi0 eta_B2 eta_B1; } in
        let {
          sat_shi2 [Occ=Once] :: (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_shhZ $dMonoid1_shi0] \u []
                  GHC.Base.$fMonoid(,)_$cmempty $dMonoid_shhZ $dMonoid1_shi0; } in
        let {
          sat_shi1 [Occ=Once] :: GHC.Base.Semigroup (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_shhZ $dMonoid1_shi0] \u []
                  GHC.Base.$fMonoid(,)_$cp1Monoid $dMonoid_shhZ $dMonoid1_shi0;
        } in  GHC.Base.C:Monoid [sat_shi1 sat_shi2 sat_shi3 sat_shi4];

GHC.Base.$fMonoid()_$c<> :: () -> () -> ()
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_shi5 ds1_shi6] () [];

GHC.Base.$fSemigroup()_$csconcat :: GHC.Base.NonEmpty () -> ()
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_shi7] () [];

GHC.Base.$fSemigroup()_$cstimes
  :: forall b. GHC.Real.Integral b => b -> () -> ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_shi8 ds_shi9 ds1_shia] () [];

GHC.Base.$fSemigroup() [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup ()
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.$fMonoid()_$c<>
                                         GHC.Base.$fSemigroup()_$csconcat
                                         GHC.Base.$fSemigroup()_$cstimes];

GHC.Base.$fMonoid() [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid ()
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [GHC.Base.$fSemigroup()
                                      GHC.Tuple.()
                                      GHC.Base.$fMonoid()_$c<>
                                      GHC.Base.$fMonoid()_$cmconcat];

GHC.Base.$fSemigroup(->)_$c<>
  :: forall b a.
     GHC.Base.Semigroup b =>
     (a -> b) -> (a -> b) -> a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),1*U(1*C1(C1(U)),A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_shib f_shic g_shid x_shie]
        let {
          sat_shig [Occ=Once] :: b_a4EV
          [LclId] =
              [g_shid x_shie] \u [] g_shid x_shie; } in
        let {
          sat_shif [Occ=Once] :: b_a4EV
          [LclId] =
              [f_shic x_shie] \u [] f_shic x_shie;
        } in  GHC.Base.<> $dSemigroup_shib sat_shif sat_shig;

GHC.Base.$fSemigroup(->)_$cstimes
  :: forall b a.
     GHC.Base.Semigroup b =>
     forall b1. GHC.Real.Integral b1 => b1 -> (a -> b) -> a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_shih $dIntegral_shii n_shij f_shik e_shil]
        let {
          sat_shim [Occ=Once] :: b_a4EV
          [LclId] =
              [f_shik e_shil] \u [] f_shik e_shil;
        } in 
          GHC.Base.stimes $dSemigroup_shih $dIntegral_shii n_shij sat_shim;

GHC.Base.$fSemigroup(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall b a. GHC.Base.Semigroup b => GHC.Base.Semigroup (a -> b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_shin]
        let {
          sat_shiq [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> (a_a4EW -> b_a4EV) -> a_a4EW -> b_a4EV
          [LclId] =
              [$dSemigroup_shin] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$cstimes
                      $dSemigroup_shin eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_ship [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4EW -> b_a4EV) -> a_a4EW -> b_a4EV
          [LclId] =
              [$dSemigroup_shin] \r [eta_B1]
                  GHC.Base.$fSemigroup(->)_$csconcat $dSemigroup_shin eta_B1; } in
        let {
          sat_shio [Occ=Once]
            :: (a_a4EW -> b_a4EV) -> (a_a4EW -> b_a4EV) -> a_a4EW -> b_a4EV
          [LclId] =
              [$dSemigroup_shin] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$c<>
                      $dSemigroup_shin eta_B3 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_shio sat_ship sat_shiq];

GHC.Base.$fMonoid(->)_$cp1Monoid
  :: forall b a. GHC.Base.Monoid b => GHC.Base.Semigroup (a -> b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shir]
        let {
          sat_shis [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_a4zA
          [LclId] =
              [$dMonoid_shir] \u [] GHC.Base.$p1Monoid $dMonoid_shir;
        } in  GHC.Base.$fSemigroup(->) sat_shis;

GHC.Base.$fMonoid(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall b a. GHC.Base.Monoid b => GHC.Base.Monoid (a -> b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_shit]
        let {
          lvl3_shiu [Occ=OnceL] :: b_a4zA
          [LclId] =
              [$dMonoid_shit] \u [] GHC.Base.mempty $dMonoid_shit; } in
        let {
          sat_shiz [Occ=Once] :: [a_a4zB -> b_a4zA] -> a_a4zB -> b_a4zA
          [LclId] =
              [$dMonoid_shit] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmconcat $dMonoid_shit eta_B2 eta_B1; } in
        let {
          sat_shiy [Occ=Once]
            :: (a_a4zB -> b_a4zA) -> (a_a4zB -> b_a4zA) -> a_a4zB -> b_a4zA
          [LclId] =
              [$dMonoid_shit] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmappend
                      $dMonoid_shit eta_B3 eta_B2 eta_B1; } in
        let {
          sat_shix [Occ=Once] :: a_a4zB -> b_a4zA
          [LclId] =
              [lvl3_shiu] \r [ds_shiw] lvl3_shiu; } in
        let {
          sat_shiv [Occ=Once] :: GHC.Base.Semigroup (a_a4zB -> b_a4zA)
          [LclId] =
              [$dMonoid_shit] \u []
                  GHC.Base.$fMonoid(->)_$cp1Monoid $dMonoid_shit;
        } in  GHC.Base.C:Monoid [sat_shiv sat_shix sat_shiy sat_shiz];

GHC.Base.$fSemigroup[]_$cstimes
  :: forall a b. GHC.Real.Integral b => b -> [a] -> [a]
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_shiA]
        Data.Semigroup.Internal.stimesList $dIntegral_shiA;

GHC.Base.$fSemigroup[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup [a]
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.++
                                         GHC.Base.$fSemigroup[]_$csconcat
                                         GHC.Base.$fSemigroup[]_$cstimes];

GHC.Base.$fMonoid[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid [a]
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [GHC.Base.$fSemigroup[]
                                      GHC.Types.[]
                                      GHC.Base.++
                                      GHC.Base.$fMonoid[]_$cmconcat];

GHC.Base.$fApplicativeNonEmpty_$cpure
  :: forall a. a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [a1_shiB] GHC.Base.:| [a1_shiB GHC.Types.[]];

GHC.Base.$w$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> (# c, [c] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(U,U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_shiC w1_shiD w2_shiE]
        let {
          sat_shiM [Occ=Once] :: a_s6R1 -> GHC.Base.NonEmpty c_s6R3
          [LclId] =
              [w_shiC w2_shiE] \r [x1_shiF]
                  let {
                    sat_shiI [Occ=Once] :: b_s6R2 -> GHC.Base.NonEmpty c_s6R3
                    [LclId] =
                        [w_shiC x1_shiF] \r [x2_shiG]
                            let {
                              sat_shiH [Occ=Once] :: c_s6R3
                              [LclId] =
                                  [w_shiC x1_shiF x2_shiG] \u [] w_shiC x1_shiF x2_shiG;
                            } in  GHC.Base.:| [sat_shiH GHC.Types.[]];
                  } in 
                    case GHC.Base.$w$c>>= w2_shiE sat_shiI of {
                      (#,#) ww1_shiK [Occ=Once] ww2_shiL [Occ=Once] ->
                          GHC.Base.:| [ww1_shiK ww2_shiL];
                    };
        } in  GHC.Base.$w$c>>= w1_shiD sat_shiM;

GHC.Base.$fApplicativeNonEmpty_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.NonEmpty a
     -> GHC.Base.NonEmpty b
     -> GHC.Base.NonEmpty c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shiN w1_shiO w2_shiP]
        case GHC.Base.$w$cliftA2 w_shiN w1_shiO w2_shiP of {
          (#,#) ww1_shiR [Occ=Once] ww2_shiS [Occ=Once] ->
              GHC.Base.:| [ww1_shiR ww2_shiS];
        };

GHC.Base.$w$c<* [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> (# a, [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_shiT w1_shiU]
        let {
          sat_shj2 [Occ=Once] :: a_s6Rb -> GHC.Base.NonEmpty a_s6Rb
          [LclId] =
              [w1_shiU] \r [x1_shiV]
                  let {
                    lvl3_shiW [Occ=OnceL, Dmd=<L,U(U,U)>] :: GHC.Base.NonEmpty a_s6Rb
                    [LclId, Unf=OtherCon []] =
                        CCCS GHC.Base.:|! [x1_shiV GHC.Types.[]]; } in
                  let {
                    sat_shiY [Occ=Once] :: b_s6Rc -> GHC.Base.NonEmpty a_s6Rb
                    [LclId] =
                        [lvl3_shiW] \r [x2_shiX] lvl3_shiW;
                  } in 
                    case GHC.Base.$w$c>>= w1_shiU sat_shiY of {
                      (#,#) ww1_shj0 [Occ=Once] ww2_shj1 [Occ=Once] ->
                          GHC.Base.:| [ww1_shj0 ww2_shj1];
                    };
        } in  GHC.Base.$w$c>>= w_shiT sat_shj2;

GHC.Base.$fApplicativeNonEmpty_$c<* [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shj3 w1_shj4]
        case GHC.Base.$w$c<* w_shj3 w1_shj4 of {
          (#,#) ww1_shj6 [Occ=Once] ww2_shj7 [Occ=Once] ->
              GHC.Base.:| [ww1_shj6 ww2_shj7];
        };

GHC.Base.$w$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a -> b) -> GHC.Base.NonEmpty a -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_shj8 w1_shj9]
        let {
          sat_shjh [Occ=Once]
            :: (a_s6Rj -> b_s6Rk) -> GHC.Base.NonEmpty b_s6Rk
          [LclId] =
              [w1_shj9] \r [x1_shja]
                  let {
                    sat_shjd [Occ=Once] :: a_s6Rj -> GHC.Base.NonEmpty b_s6Rk
                    [LclId] =
                        [x1_shja] \r [x2_shjb]
                            let {
                              sat_shjc [Occ=Once] :: b_s6Rk
                              [LclId] =
                                  [x1_shja x2_shjb] \u [] x1_shja x2_shjb;
                            } in  GHC.Base.:| [sat_shjc GHC.Types.[]];
                  } in 
                    case GHC.Base.$w$c>>= w1_shj9 sat_shjd of {
                      (#,#) ww1_shjf [Occ=Once] ww2_shjg [Occ=Once] ->
                          GHC.Base.:| [ww1_shjf ww2_shjg];
                    };
        } in  GHC.Base.$w$c>>= w_shj8 sat_shjh;

GHC.Base.$fApplicativeNonEmpty_$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a -> b)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shji w1_shjj]
        case GHC.Base.$w$c<*> w_shji w1_shjj of {
          (#,#) ww1_shjl [Occ=Once] ww2_shjm [Occ=Once] ->
              GHC.Base.:| [ww1_shjl ww2_shjm];
        };

GHC.Base.$fApplicativeNonEmpty1 :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_shjn eta_shjo] eta_shjo;

GHC.Base.$fApplicativeNonEmpty_$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shjp w1_shjq]
        let {
          sat_shju [Occ=Once] :: [b_s6Rs -> b_s6Rs]
          [LclId] =
              [w_shjp] \u []
                  case w_shjp of {
                    GHC.Base.:| _ [Occ=Dead] as_shjt [Occ=Once] ->
                        GHC.Base.map GHC.Base.$fApplicativeNonEmpty1 as_shjt;
                  }; } in
        let {
          sat_shjv [Occ=Once] :: GHC.Base.NonEmpty (b_s6Rs -> b_s6Rs)
          [LclId] =
              CCCS GHC.Base.:|! [GHC.Base.breakpoint sat_shju];
        } in 
          case GHC.Base.$w$c<*> sat_shjv w1_shjq of {
            (#,#) ww1_shjx [Occ=Once] ww2_shjy [Occ=Once] ->
                GHC.Base.:| [ww1_shjx ww2_shjy];
          };

GHC.Base.$fApplicativeNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctorNonEmpty
                                           GHC.Base.$fApplicativeNonEmpty_$cpure
                                           GHC.Base.$fApplicativeNonEmpty_$c<*>
                                           GHC.Base.$fApplicativeNonEmpty_$cliftA2
                                           GHC.Base.$fApplicativeNonEmpty_$c*>
                                           GHC.Base.$fApplicativeNonEmpty_$c<*];

lvl_r7PJ :: forall a. [GHC.Types.Char] -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_shjz] GHC.Err.errorWithoutStackTrace eta_shjz;

GHC.Base.$fMonadNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicativeNonEmpty
                                     GHC.Base.$fMonadNonEmpty_$c>>=
                                     GHC.Base.$fMonadNonEmpty_$c>>
                                     GHC.Base.$fApplicativeNonEmpty_$cpure
                                     lvl_r7PJ];

GHC.Base.$fAlternativeIO4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "mzero"#;

GHC.Base.$fAlternativeIO3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.Base.$fAlternativeIO4;

GHC.Base.$fAlternativeIO_$cempty :: forall a. GHC.Types.IO a
[GblId] =
    [] \u [] GHC.IO.failIO GHC.Base.$fAlternativeIO3;

GHC.Base.$fAlternativeIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [GHC.Base.$fApplicativeIO
                                           GHC.Base.$fAlternativeIO_$cempty
                                           GHC.IO.mplusIO
                                           GHC.Base.$fAlternativeIO2
                                           GHC.Base.$fAlternativeIO_$cmany];

GHC.Base.$fMonadPlusIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [GHC.Base.$fAlternativeIO
                                         GHC.Base.$fMonadIO
                                         GHC.Base.$fAlternativeIO_$cempty
                                         GHC.IO.mplusIO];

GHC.Base.$fAlternativeMaybe_$c<|>
  :: forall a.
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_shjA r_shjB]
        case ds_shjA of wild_shjC {
          GHC.Base.Nothing -> r_shjB;
          GHC.Base.Just _ [Occ=Dead] -> wild_shjC;
        };

GHC.Base.$fApplicativeMaybe_$cliftA2
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_shjE ds_shjF ds1_shjG]
        case ds_shjF of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_shjI [Occ=Once] ->
              case ds1_shjG of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just y_shjK [Occ=Once] ->
                    let {
                      sat_shjL [Occ=Once] :: c_a4L9
                      [LclId] =
                          [f_shjE x_shjI y_shjK] \u [] f_shjE x_shjI y_shjK;
                    } in  GHC.Base.Just [sat_shjL];
              };
        };

GHC.Base.$fApplicativeMaybe_$c*>
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_shjM m2_shjN]
        case ds_shjM of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> m2_shjN;
        };

GHC.Base.$fApplicative(->)_$c<*>
  :: forall a1 a2 b. (a1 -> a2 -> b) -> (a1 -> a2) -> a1 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_shjQ g_shjR x_shjS]
        let {
          sat_shjT [Occ=Once] :: a1_a4LL
          [LclId] =
              [g_shjR x_shjS] \u [] g_shjR x_shjS;
        } in  f_shjQ x_shjS sat_shjT;

GHC.Base.$fApplicative(->)_$cliftA2
  :: forall a1 a2 b c.
     (a2 -> b -> c) -> (a1 -> a2) -> (a1 -> b) -> a1 -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [q_shjU f_shjV g_shjW x_shjX]
        let {
          sat_shjZ [Occ=Once] :: b_a4LS
          [LclId] =
              [g_shjW x_shjX] \u [] g_shjW x_shjX; } in
        let {
          sat_shjY [Occ=Once] :: a1_a4LR
          [LclId] =
              [f_shjV x_shjX] \u [] f_shjV x_shjX;
        } in  q_shjU sat_shjY sat_shjZ;

GHC.Base.$fApplicative(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Applicative ((->) a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctor(->)
                                           GHC.Base.const
                                           GHC.Base.$fApplicative(->)_$c<*>
                                           GHC.Base.$fApplicative(->)_$cliftA2
                                           GHC.Base.$fApplicative(->)_$c*>
                                           GHC.Base.$fApplicative(->)_$c<*];

lvl1_r7PK :: forall r a. [GHC.Types.Char] -> r -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_shk0] GHC.Err.errorWithoutStackTrace eta_shk0;

GHC.Base.$fMonad(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall r. GHC.Base.Monad ((->) r)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicative(->)
                                     GHC.Base.$fMonad(->)_$c>>=
                                     GHC.Base.$fMonad(->)_$c>>
                                     GHC.Base.const
                                     lvl1_r7PK];

GHC.Base.$fApplicativeMaybe_$cfmap
  :: forall a b. (a -> b) -> GHC.Base.Maybe a -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_shk1 ds1_shk2]
        case ds1_shk2 of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_shk4 [Occ=Once] ->
              let {
                sat_shk5 [Occ=Once] :: b_a4MF
                [LclId] =
                    [ds_shk1 a1_shk4] \u [] ds_shk1 a1_shk4;
              } in  GHC.Base.Just [sat_shk5];
        };

GHC.Base.$fFunctorMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       GHC.Base.$fFunctorMaybe_$c<$];

GHC.Base.$fApplicativeMaybe_$c<*>
  :: forall a b.
     GHC.Base.Maybe (a -> b) -> GHC.Base.Maybe a -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_shk6 m_shk7]
        case ds_shk6 of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just f_shk9 [Occ=Once] ->
              GHC.Base.$fApplicativeMaybe_$cfmap f_shk9 m_shk7;
        };

GHC.Base.$fApplicativeMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctorMaybe
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           GHC.Base.$fApplicativeMaybe_$c*>
                                           GHC.Base.$fApplicativeMaybe_$c<*];

GHC.Base.$fMonadMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicativeMaybe
                                     GHC.Base.$fMonadMaybe_$c>>=
                                     GHC.Base.$fApplicativeMaybe_$c*>
                                     GHC.Base.Just
                                     GHC.Base.$fMonadMaybe_$cfail];

GHC.Base.$fAlternativeMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [GHC.Base.$fApplicativeMaybe
                                           GHC.Base.Nothing
                                           GHC.Base.$fAlternativeMaybe_$c<|>
                                           GHC.Base.$fAlternativeMaybe_$csome
                                           GHC.Base.$fAlternativeMaybe_$cmany];

GHC.Base.$fMonadPlusMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [GHC.Base.$fAlternativeMaybe
                                         GHC.Base.$fMonadMaybe
                                         GHC.Base.Nothing
                                         GHC.Base.$fAlternativeMaybe_$c<|>];

GHC.Base.liftA3_$sliftA3 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_shka a_shkb b_shkc c_shkd]
        case a_shkb of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_shkf [Occ=Once] ->
              case b_shkc of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just y_shkh [Occ=Once] ->
                    case c_shkd of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just a4_shkj [Occ=Once] ->
                          let {
                            sat_shkk [Occ=Once] :: r_a4gI
                            [LclId] =
                                [f_shka x_shkf y_shkh a4_shkj] \u [] f_shka x_shkf y_shkh a4_shkj;
                          } in  GHC.Base.Just [sat_shkk];
                    };
              };
        };

GHC.Base.liftA3 [InlPrag=INLINABLE]
  :: forall (f :: * -> *) a b c d.
     GHC.Base.Applicative f =>
     (a -> b -> c -> d) -> f a -> f b -> f c -> f d
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(A,A,1*C1(C1(U)),1*C1(C1(C1(U))),A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_shkl f1_shkm a1_shkn b1_shko c1_shkp]
        let {
          sat_shkq [Occ=Once] :: f_a4f9 (c_a4fc -> d_a4fd)
          [LclId] =
              [$dApplicative_shkl f1_shkm a1_shkn b1_shko] \u []
                  GHC.Base.liftA2 $dApplicative_shkl f1_shkm a1_shkn b1_shko;
        } in  GHC.Base.<*> $dApplicative_shkl sat_shkq c1_shkp;

GHC.Base.liftA_$sliftA [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Base.Maybe a1 -> GHC.Base.Maybe r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fApplicativeMaybe_$cfmap eta_B2 eta_B1;

GHC.Base.liftA [InlPrag=INLINABLE]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> b) -> f a -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(A,1*C1(U),1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_shkr f1_shks a1_shkt]
        let {
          sat_shku [Occ=Once] :: f_a4gQ (a_a4gR -> b_a4gS)
          [LclId] =
              [$dApplicative_shkr f1_shks] \u []
                  GHC.Base.pure $dApplicative_shkr f1_shks;
        } in  GHC.Base.<*> $dApplicative_shkr sat_shku a1_shkt;

GHC.Base.$fFunctor(,)_$cfmap
  :: forall a1 a2 b. (a2 -> b) -> (a1, a2) -> (a1, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_shkv ds_shkw]
        case ds_shkw of {
          (,) x_shky [Occ=Once] y_shkz [Occ=Once] ->
              let {
                sat_shkA [Occ=Once] :: b_a4N0
                [LclId] =
                    [f_shkv y_shkz] \u [] f_shkv y_shkz;
              } in  (,) [x_shky sat_shkA];
        };

GHC.Base.$fFunctor(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Functor ((,) a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctor(,)_$cfmap
                                       GHC.Base.$fFunctor(,)_$c<$];

GHC.Base.$fApplicative(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid a => GHC.Base.Applicative ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,A),1*U,A,A)>m] =
    [] \r [$dMonoid_shkB]
        let {
          lvl3_shkC [Occ=OnceL] :: a_a4vv
          [LclId] =
              [$dMonoid_shkB] \u [] GHC.Base.mempty $dMonoid_shkB; } in
        let {
          sat_shkI [Occ=Once]
            :: forall a b. (a_a4vv, a) -> (a_a4vv, b) -> (a_a4vv, a)
          [LclId] =
              [$dMonoid_shkB] \r [eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$c<* $dMonoid_shkB eta_B2 eta_B1; } in
        let {
          sat_shkH [Occ=Once]
            :: forall a b. (a_a4vv, a) -> (a_a4vv, b) -> (a_a4vv, b)
          [LclId] =
              [$dMonoid_shkB] \r [eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$c*> $dMonoid_shkB eta_B2 eta_B1; } in
        let {
          sat_shkG [Occ=Once]
            :: forall a b c.
               (a -> b -> c) -> (a_a4vv, a) -> (a_a4vv, b) -> (a_a4vv, c)
          [LclId] =
              [$dMonoid_shkB] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$cliftA2
                      $dMonoid_shkB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_shkF [Occ=Once]
            :: forall a b. (a_a4vv, a -> b) -> (a_a4vv, a) -> (a_a4vv, b)
          [LclId] =
              [$dMonoid_shkB] \r [eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$c<*> $dMonoid_shkB eta_B2 eta_B1; } in
        let {
          sat_shkE [Occ=Once] :: forall a. a -> (a_a4vv, a)
          [LclId] =
              [lvl3_shkC] \r [x_shkD] (,) [lvl3_shkC x_shkD];
        } in 
          GHC.Base.C:Applicative [GHC.Base.$fFunctor(,)
                                  sat_shkE
                                  sat_shkF
                                  sat_shkG
                                  sat_shkH
                                  sat_shkI];

lvl2_r7PL :: forall a1 a2. [GHC.Types.Char] -> (a1, a2)
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_shkJ] GHC.Err.errorWithoutStackTrace eta_shkJ;

GHC.Base.$fMonad(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid a => GHC.Base.Monad ((,) a)
[GblId[DFunId], Arity=1, Str=<L,U(U(C(C1(U)),A,A),U,A,A)>m] =
    [] \r [$dMonoid_shkK]
        let {
          lvl3_shkL [Occ=OnceL] :: a_a4ul
          [LclId] =
              [$dMonoid_shkK] \u [] GHC.Base.mempty $dMonoid_shkK; } in
        let {
          sat_shkQ [Occ=Once] :: forall a. a -> (a_a4ul, a)
          [LclId] =
              [lvl3_shkL] \r [x_shkP] (,) [lvl3_shkL x_shkP]; } in
        let {
          sat_shkO [Occ=Once]
            :: forall a b. (a_a4ul, a) -> (a_a4ul, b) -> (a_a4ul, b)
          [LclId] =
              [$dMonoid_shkK] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonad(,)_$c>> $dMonoid_shkK eta_B2 eta_B1; } in
        let {
          sat_shkN [Occ=Once]
            :: forall a b. (a_a4ul, a) -> (a -> (a_a4ul, b)) -> (a_a4ul, b)
          [LclId] =
              [$dMonoid_shkK] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonad(,)_$c>>= $dMonoid_shkK eta_B2 eta_B1; } in
        let {
          sat_shkM [Occ=Once] :: GHC.Base.Applicative ((,) a_a4ul)
          [LclId] =
              [$dMonoid_shkK] \u [] GHC.Base.$fApplicative(,) $dMonoid_shkK;
        } in 
          GHC.Base.C:Monad [sat_shkM sat_shkN sat_shkO sat_shkQ lvl2_r7PL];

GHC.Base.C:Monad
  :: forall (m :: * -> *).
     GHC.Base.Applicative m =>
     (forall a b. m a -> (a -> m b) -> m b)
     -> (forall a b. m a -> m b -> m b)
     -> (forall a. a -> m a)
     -> (forall a. GHC.Base.String -> m a)
     -> GHC.Base.Monad m
[GblId[DataCon],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Monad [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.C:Functor
  :: forall (f :: * -> *).
     (forall a b. (a -> b) -> f a -> f b)
     -> (forall a b. a -> f b -> f a) -> GHC.Base.Functor f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.C:Functor [eta_B2 eta_B1];

GHC.Base.C:Applicative
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     (forall a. a -> f a)
     -> (forall a b. f (a -> b) -> f a -> f b)
     -> (forall a b c. (a -> b -> c) -> f a -> f b -> f c)
     -> (forall a b. f a -> f b -> f b)
     -> (forall a b. f a -> f b -> f a)
     -> GHC.Base.Applicative f
[GblId[DataCon],
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Applicative [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.C:Semigroup
  :: forall a.
     (a -> a -> a)
     -> (GHC.Base.NonEmpty a -> a)
     -> (forall b. GHC.Real.Integral b => b -> a -> a)
     -> GHC.Base.Semigroup a
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Semigroup [eta_B3 eta_B2 eta_B1];

GHC.Base.C:Monoid
  :: forall a.
     GHC.Base.Semigroup a =>
     a -> (a -> a -> a) -> ([a] -> a) -> GHC.Base.Monoid a
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Monoid [eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.Nothing :: forall a. GHC.Base.Maybe a
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Nothing! [];

GHC.Base.Just :: forall a. a -> GHC.Base.Maybe a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.Just [eta_B1];

GHC.Base.O :: forall a. a -> GHC.Base.Opaque
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.O [eta_B1];

GHC.Base.:| :: forall a. a -> [a] -> GHC.Base.NonEmpty a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.:| [eta_B2 eta_B1];

GHC.Base.C:MonadPlus
  :: forall (m :: * -> *).
     (GHC.Base.Alternative m, GHC.Base.Monad m) =>
     (forall a. m a)
     -> (forall a. m a -> m a -> m a) -> GHC.Base.MonadPlus m
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:MonadPlus [eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.C:Alternative
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     (forall a. f a)
     -> (forall a. f a -> f a -> f a)
     -> (forall a. f a -> f [a])
     -> (forall a. f a -> f [a])
     -> GHC.Base.Alternative f
[GblId[DataCon],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Alternative [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 15:54:56.13932008 UTC

GHC.Base.$p1Monad
  :: forall (m :: * -> *). GHC.Base.Monad m => GHC.Base.Applicative m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>] =
    [] \r [v_sgJ5]
        case v_sgJ5 of {
          GHC.Base.C:Monad v_sgJ7 [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_sgJ7;
        };

GHC.Base.>>=
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. m a -> (a -> m b) -> m b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>] =
    [] \r [v_sgJc]
        case v_sgJc of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           v_sgJf [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_sgJf;
        };

GHC.Base.>>
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. m a -> m b -> m b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>] =
    [] \r [v_sgJj]
        case v_sgJj of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_sgJn [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead] ->
              v_sgJn;
        };

GHC.Base.return
  :: forall (m :: * -> *). GHC.Base.Monad m => forall a. a -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>] =
    [] \r [v_sgJq]
        case v_sgJq of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_sgJv [Occ=Once]
                           _ [Occ=Dead] ->
              v_sgJv;
        };

GHC.Base.fail
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a. GHC.Base.String -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>] =
    [] \r [v_sgJx]
        case v_sgJx of {
          GHC.Base.C:Monad _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           v_sgJD [Occ=Once] ->
              v_sgJD;
        };

GHC.Base.fmap
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     forall a b. (a -> b) -> f a -> f b
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SL),U(U,A)>] =
    [] \r [v_sgJE]
        case v_sgJE of {
          GHC.Base.C:Functor v_sgJG [Occ=Once] _ [Occ=Dead] -> v_sgJG;
        };

GHC.Base.<$
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     forall a b. a -> f b -> f a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LS),U(A,U)>] =
    [] \r [v_sgJI]
        case v_sgJI of {
          GHC.Base.C:Functor _ [Occ=Dead] v_sgJL [Occ=Once] -> v_sgJL;
        };

GHC.Base.$p1Applicative
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Base.Functor f
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>] =
    [] \r [v_sgJM]
        case v_sgJM of {
          GHC.Base.C:Applicative v_sgJO [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgJO;
        };

GHC.Base.pure
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a. a -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>] =
    [] \r [v_sgJU]
        case v_sgJU of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 v_sgJX [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgJX;
        };

GHC.Base.<*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f (a -> b) -> f a -> f b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>] =
    [] \r [v_sgK2]
        case v_sgK2 of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgK6 [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgK6;
        };

GHC.Base.liftA2
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b c. (a -> b -> c) -> f a -> f b -> f c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>] =
    [] \r [v_sgKa]
        case v_sgKa of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgKf [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgKf;
        };

GHC.Base.*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>] =
    [] \r [v_sgKi]
        case v_sgKi of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgKo [Occ=Once]
                                 _ [Occ=Dead] ->
              v_sgKo;
        };

GHC.Base.<*
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>] =
    [] \r [v_sgKq]
        case v_sgKq of {
          GHC.Base.C:Applicative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgKx [Occ=Once] ->
              v_sgKx;
        };

GHC.Base.<> :: forall a. GHC.Base.Semigroup a => a -> a -> a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sgKy]
        case v_sgKy of {
          GHC.Base.C:Semigroup v_sgKA [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
              v_sgKA;
        };

GHC.Base.sconcat
  :: forall a. GHC.Base.Semigroup a => GHC.Base.NonEmpty a -> a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sgKD]
        case v_sgKD of {
          GHC.Base.C:Semigroup _ [Occ=Dead] v_sgKG [Occ=Once] _ [Occ=Dead] ->
              v_sgKG;
        };

GHC.Base.stimes
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b. GHC.Real.Integral b => b -> a -> a
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sgKI]
        case v_sgKI of {
          GHC.Base.C:Semigroup _ [Occ=Dead] _ [Occ=Dead] v_sgKM [Occ=Once] ->
              v_sgKM;
        };

GHC.Base.$p1Monoid
  :: forall a. GHC.Base.Monoid a => GHC.Base.Semigroup a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sgKN]
        case v_sgKN of {
          GHC.Base.C:Monoid v_sgKP [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
              v_sgKP;
        };

GHC.Base.mempty :: forall a. GHC.Base.Monoid a => a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sgKT]
        case v_sgKT of {
          GHC.Base.C:Monoid _ [Occ=Dead]
                            v_sgKW [Occ=Once]
                            _ [Occ=Dead]
                            _ [Occ=Dead] ->
              v_sgKW;
        };

GHC.Base.mappend :: forall a. GHC.Base.Monoid a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sgKZ]
        case v_sgKZ of {
          GHC.Base.C:Monoid _ [Occ=Dead]
                            _ [Occ=Dead]
                            v_sgL3 [Occ=Once]
                            _ [Occ=Dead] ->
              v_sgL3;
        };

GHC.Base.mconcat :: forall a. GHC.Base.Monoid a => [a] -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sgL5]
        case v_sgL5 of {
          GHC.Base.C:Monoid _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            v_sgLa [Occ=Once] ->
              v_sgLa;
        };

GHC.Base.$p1MonadPlus
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Base.Alternative m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sgLb]
        case v_sgLb of {
          GHC.Base.C:MonadPlus v_sgLd [Occ=Once]
                               _ [Occ=Dead]
                               _ [Occ=Dead]
                               _ [Occ=Dead] ->
              v_sgLd;
        };

GHC.Base.$p2MonadPlus
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => GHC.Base.Monad m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sgLh]
        case v_sgLh of {
          GHC.Base.C:MonadPlus _ [Occ=Dead]
                               v_sgLk [Occ=Once]
                               _ [Occ=Dead]
                               _ [Occ=Dead] ->
              v_sgLk;
        };

GHC.Base.mzero
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => forall a. m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sgLn]
        case v_sgLn of {
          GHC.Base.C:MonadPlus _ [Occ=Dead]
                               _ [Occ=Dead]
                               v_sgLr [Occ=Once]
                               _ [Occ=Dead] ->
              v_sgLr;
        };

GHC.Base.mplus
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a. m a -> m a -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sgLt]
        case v_sgLt of {
          GHC.Base.C:MonadPlus _ [Occ=Dead]
                               _ [Occ=Dead]
                               _ [Occ=Dead]
                               v_sgLy [Occ=Once] ->
              v_sgLy;
        };

GHC.Base.$p1Alternative
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     GHC.Base.Applicative f
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>] =
    [] \r [v_sgLz]
        case v_sgLz of {
          GHC.Base.C:Alternative v_sgLB [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgLB;
        };

GHC.Base.empty
  :: forall (f :: * -> *). GHC.Base.Alternative f => forall a. f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>] =
    [] \r [v_sgLG]
        case v_sgLG of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 v_sgLJ [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgLJ;
        };

GHC.Base.<|>
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f a -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>] =
    [] \r [v_sgLN]
        case v_sgLN of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgLR [Occ=Once]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead] ->
              v_sgLR;
        };

GHC.Base.some
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>] =
    [] \r [v_sgLU]
        case v_sgLU of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgLZ [Occ=Once]
                                 _ [Occ=Dead] ->
              v_sgLZ;
        };

GHC.Base.many
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>] =
    [] \r [v_sgM1]
        case v_sgM1 of {
          GHC.Base.C:Alternative _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 _ [Occ=Dead]
                                 v_sgM7 [Occ=Once] ->
              v_sgM7;
        };

GHC.Base.eqString [Occ=LoopBreaker]
  :: GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgM8 ds1_sgM9]
        case ds_sgM8 of {
          [] ->
              case ds1_sgM9 of {
                [] -> GHC.Types.True [];
                : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
              };
          : c1_sgMe [Occ=Once!] cs1_sgMf [Occ=Once] ->
              case ds1_sgM9 of {
                [] -> GHC.Types.False [];
                : c2_sgMh [Occ=Once!] cs2_sgMi [Occ=Once] ->
                    case c1_sgMe of {
                      GHC.Types.C# x_sgMk [Occ=Once] ->
                          case c2_sgMh of {
                            GHC.Types.C# y_sgMm [Occ=Once] ->
                                case eqChar# [x_sgMk y_sgMm] of {
                                  __DEFAULT -> GHC.Types.False [];
                                  1# -> GHC.Base.eqString cs1_sgMf cs2_sgMi;
                                };
                          };
                    };
              };
        };

GHC.Base.when2
  :: GHC.Types.Bool
     -> GHC.Types.IO ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [p_sgMo s_sgMp void_0E]
        case p_sgMo of {
          GHC.Types.False -> Unit# [GHC.Tuple.()];
          GHC.Types.True -> s_sgMp GHC.Prim.void#;
        };

GHC.Base.when_$swhen1 [InlPrag=INLINABLE]
  :: GHC.Types.Bool -> GHC.Types.IO () -> GHC.Types.IO ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.Base.when2 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.$fFunctorIO2
  :: forall a b.
     (a -> b)
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_sgMs x_sgMt void_0E]
        case x_sgMt GHC.Prim.void# of {
          Unit# ipv1_sgMx [Occ=Once] ->
              let {
                sat_sgMy [Occ=Once] :: b_a4qK
                [LclId] =
                    [f_sgMs ipv1_sgMx] \u [] f_sgMs ipv1_sgMx;
              } in  Unit# [sat_sgMy];
        };

GHC.Base.$fFunctorIO1
  :: forall a b.
     a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S(SL)),1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [x_sgMz eta_sgMA void_0E]
        case eta_sgMA GHC.Prim.void# of {
          Unit# _ [Occ=Dead] -> Unit# [x_sgMz];
        };

GHC.Base.$fFunctorIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.Types.IO
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctorIO2
                                       GHC.Base.$fFunctorIO1];

GHC.Base.$fAlternativeMaybe1 :: forall a. GHC.Base.Maybe [a]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [GHC.Types.[]];

GHC.Base.$fAlternativeMaybe_$cmany
  :: forall a. GHC.Base.Maybe a -> GHC.Base.Maybe [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sgMF]
        let {
          many_v_sgMG [Occ=LoopBreaker] :: GHC.Base.Maybe [a_a4IZ]
          [LclId] =
              [v_sgMF many_v_sgMG] \u []
                  case v_sgMF of {
                    GHC.Base.Nothing -> GHC.Base.$fAlternativeMaybe1;
                    GHC.Base.Just x_sgMI [Occ=Once] ->
                        case many_v_sgMG of {
                          GHC.Base.Nothing -> GHC.Base.$fAlternativeMaybe1;
                          GHC.Base.Just y_sgMK [Occ=Once] ->
                              let {
                                sat_sgML [Occ=Once] :: [a_a4IZ]
                                [LclId] =
                                    CCCS :! [x_sgMI y_sgMK];
                              } in  GHC.Base.Just [sat_sgML];
                        };
                  };
        } in  many_v_sgMG;

GHC.Base.$fAlternativeMaybe_$csome
  :: forall a. GHC.Base.Maybe a -> GHC.Base.Maybe [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sgMM]
        let {
          some_v_sgMN [Occ=LoopBreaker] :: GHC.Base.Maybe [a_a4IR]
          [LclId] =
              [v_sgMM some_v_sgMN] \u []
                  case v_sgMM of {
                    GHC.Base.Nothing -> GHC.Base.Nothing [];
                    GHC.Base.Just x_sgMP [Occ=Once*] ->
                        case some_v_sgMN of {
                          GHC.Base.Nothing ->
                              let {
                                sat_sgMR [Occ=Once] :: [a_a4IR]
                                [LclId] =
                                    CCCS :! [x_sgMP GHC.Types.[]];
                              } in  GHC.Base.Just [sat_sgMR];
                          GHC.Base.Just ipv_sgMS [Occ=Once] ->
                              let {
                                sat_sgMT [Occ=Once] :: [a_a4IR]
                                [LclId] =
                                    CCCS :! [x_sgMP ipv_sgMS];
                              } in  GHC.Base.Just [sat_sgMT];
                        };
                  };
        } in  some_v_sgMN;

GHC.Base.ap_$sap [InlPrag=INLINABLE]
  :: forall a b.
     GHC.Base.Maybe (a -> b) -> GHC.Base.Maybe a -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [m1_sgMU m2_sgMV]
        case m1_sgMU of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sgMX [Occ=Once!] ->
              case m2_sgMV of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sgMZ [Occ=Once] ->
                    let {
                      sat_sgN0 [Occ=Once] :: b_a447
                      [LclId] =
                          [x_sgMX x1_sgMZ] \u [] x_sgMX x1_sgMZ;
                    } in  GHC.Base.Just [sat_sgN0];
              };
        };

GHC.Base.liftM5_$sliftM5 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe a4
     -> GHC.Base.Maybe a5
     -> GHC.Base.Maybe r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><S,1*U><L,1*U><L,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgN1 m1_sgN2 m2_sgN3 m3_sgN4 m4_sgN5 m5_sgN6]
        case m1_sgN2 of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sgN8 [Occ=Once] ->
              case m2_sgN3 of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sgNa [Occ=Once] ->
                    case m3_sgN4 of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just x2_sgNc [Occ=Once] ->
                          case m4_sgN5 of {
                            GHC.Base.Nothing -> GHC.Base.Nothing [];
                            GHC.Base.Just x3_sgNe [Occ=Once] ->
                                case m5_sgN6 of {
                                  GHC.Base.Nothing -> GHC.Base.Nothing [];
                                  GHC.Base.Just x4_sgNg [Occ=Once] ->
                                      let {
                                        sat_sgNh [Occ=Once] :: r_a46A
                                        [LclId] =
                                            [f_sgN1 x_sgN8 x1_sgNa x2_sgNc x3_sgNe x4_sgNg] \u []
                                                f_sgN1 x_sgN8 x1_sgNa x2_sgNc x3_sgNe x4_sgNg;
                                      } in  GHC.Base.Just [sat_sgNh];
                                };
                          };
                    };
              };
        };

GHC.Base.liftM4_$sliftM4 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe a4
     -> GHC.Base.Maybe r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><S,1*U><L,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgNi m1_sgNj m2_sgNk m3_sgNl m4_sgNm]
        case m1_sgNj of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sgNo [Occ=Once] ->
              case m2_sgNk of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sgNq [Occ=Once] ->
                    case m3_sgNl of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just x2_sgNs [Occ=Once] ->
                          case m4_sgNm of {
                            GHC.Base.Nothing -> GHC.Base.Nothing [];
                            GHC.Base.Just x3_sgNu [Occ=Once] ->
                                let {
                                  sat_sgNv [Occ=Once] :: r_a48L
                                  [LclId] =
                                      [f_sgNi x_sgNo x1_sgNq x2_sgNs x3_sgNu] \u []
                                          f_sgNi x_sgNo x1_sgNq x2_sgNs x3_sgNu;
                                } in  GHC.Base.Just [sat_sgNv];
                          };
                    };
              };
        };

GHC.Base.liftM3_$sliftM3 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgNw m1_sgNx m2_sgNy m3_sgNz]
        case m1_sgNx of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sgNB [Occ=Once] ->
              case m2_sgNy of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sgND [Occ=Once] ->
                    case m3_sgNz of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just x2_sgNF [Occ=Once] ->
                          let {
                            sat_sgNG [Occ=Once] :: r_a4az
                            [LclId] =
                                [f_sgNw x_sgNB x1_sgND x2_sgNF] \u []
                                    f_sgNw x_sgNB x1_sgND x2_sgNF;
                          } in  GHC.Base.Just [sat_sgNG];
                    };
              };
        };

GHC.Base.liftM2_$sliftM2 [InlPrag=INLINABLE]
  :: forall a1 a2 r.
     (a1 -> a2 -> r)
     -> GHC.Base.Maybe a1 -> GHC.Base.Maybe a2 -> GHC.Base.Maybe r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgNH m1_sgNI m2_sgNJ]
        case m1_sgNI of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sgNL [Occ=Once] ->
              case m2_sgNJ of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just x1_sgNN [Occ=Once] ->
                    let {
                      sat_sgNO [Occ=Once] :: r_a4c0
                      [LclId] =
                          [f_sgNH x_sgNL x1_sgNN] \u [] f_sgNH x_sgNL x1_sgNN;
                    } in  GHC.Base.Just [sat_sgNO];
              };
        };

GHC.Base.liftM_$sliftM [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Base.Maybe a1 -> GHC.Base.Maybe r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgNP m1_sgNQ]
        case m1_sgNQ of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sgNS [Occ=Once] ->
              let {
                sat_sgNT [Occ=Once] :: r_a4d4
                [LclId] =
                    [f_sgNP x_sgNS] \u [] f_sgNP x_sgNS;
              } in  GHC.Base.Just [sat_sgNT];
        };

GHC.Base.when1 :: GHC.Base.Maybe ()
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Just! [GHC.Tuple.()];

GHC.Base.when_$swhen [InlPrag=INLINABLE]
  :: GHC.Types.Bool -> GHC.Base.Maybe () -> GHC.Base.Maybe ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [p_sgNU s_sgNV]
        case p_sgNU of {
          GHC.Types.False -> GHC.Base.when1;
          GHC.Types.True -> s_sgNV;
        };

GHC.Base.when [InlPrag=INLINABLE]
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Types.Bool -> f () -> f ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U),A,A,A,A)><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgNX p_sgNY s_sgNZ]
        case p_sgNY of {
          GHC.Types.False -> GHC.Base.pure $dApplicative_sgNX GHC.Tuple.();
          GHC.Types.True -> s_sgNZ;
        };

GHC.Base.$fApplicativeMaybe_$c<*
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgO1 ds1_sgO2]
        case ds_sgO1 of wild_sgO3 {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] ->
              case ds1_sgO2 of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just _ [Occ=Dead] -> wild_sgO3;
              };
        };

GHC.Base.$tc'O3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'O"#;

GHC.Base.$tc'O2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'O3];

GHC.Base.$tcOpaque2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Opaque"#;

GHC.Base.$tcOpaque1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcOpaque2];

GHC.Base.$tcMonadPlus2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "MonadPlus"#;

GHC.Base.$tcMonadPlus1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMonadPlus2];

GHC.Base.$tcMonad2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Monad"#;

GHC.Base.$tcMonad1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMonad2];

GHC.Base.$tc'C:Monoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'C:Monoid"#;

GHC.Base.$tc'C:Monoid2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'C:Monoid3];

GHC.Base.$tcMonoid3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Monoid"#;

GHC.Base.$tcMonoid2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMonoid3];

GHC.Base.$tcSemigroup2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Semigroup"#;

GHC.Base.$tcSemigroup1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcSemigroup2];

GHC.Base.$tc':|3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "':|"#;

GHC.Base.$tc':|2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc':|3];

GHC.Base.$tcNonEmpty2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty"#;

GHC.Base.$tcNonEmpty1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcNonEmpty2];

GHC.Base.$tcAlternative3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Alternative"#;

GHC.Base.$tcAlternative2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcAlternative3];

GHC.Base.$tcApplicative2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Applicative"#;

GHC.Base.$tcApplicative1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcApplicative2];

GHC.Base.$tcFunctor2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Functor"#;

GHC.Base.$tcFunctor1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcFunctor2];

GHC.Base.$tc'Just3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Just"#;

GHC.Base.$tc'Just2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'Just3];

GHC.Base.$tc'Nothing3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Nothing"#;

GHC.Base.$tc'Nothing2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tc'Nothing3];

GHC.Base.$tcMaybe2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Maybe"#;

GHC.Base.$tcMaybe1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$tcMaybe2];

$krep_r7Pr :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_r7Ps :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep_r7Pr];

$krep2_r7Pt :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep1_r7Ps];

$krep3_r7Pu :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r7Pr GHC.Types.[]];

$krep4_r7Pv :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tc[]
                                              $krep3_r7Pu];

$krep5_r7Pw :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r7Pv $krep_r7Pr];

$krep6_r7Px :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.Base.$tcMonoid1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$* $krep6_r7Px];

GHC.Base.$tcAlternative1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*Arr*
                                         $krep6_r7Px];

GHC.Base.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Base"#;

GHC.Base.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$trModule2];

GHC.Base.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Base.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Base.$trModule4];

GHC.Base.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Base.$trModule3
                                     GHC.Base.$trModule1];

GHC.Base.$tcMaybe :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [625655543500963593##
                                    6391758309165051762##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMaybe1
                                    0#
                                    GHC.Types.krep$*Arr*];

GHC.Base.$tc'Nothing1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep3_r7Pu];

GHC.Base.$tc'Just1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr
                                         GHC.Base.$tc'Nothing1];

GHC.Base.$tc'Nothing :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14633289528184412192##
                                    12773126156421542470##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'Nothing2
                                    1#
                                    GHC.Base.$tc'Nothing1];

GHC.Base.$tc'Just :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5794512144280699493##
                                    9434423460978218117##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'Just2
                                    1#
                                    GHC.Base.$tc'Just1];

GHC.Base.$tcFunctor :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [211182333006544237##
                                    5556320544348084514##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcFunctor1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcApplicative :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12705055220831243597##
                                    2963353171490466073##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcApplicative1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcAlternative :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1073491102990665358##
                                    14320772755704808948##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcAlternative2
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcNonEmpty :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13207016872645468285##
                                    3455542966739695982##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcNonEmpty1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep7_r7Py :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcNonEmpty
                                              $krep3_r7Pu];

$krep8_r7Pz :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep4_r7Pv $krep7_r7Py];

GHC.Base.$tc':|1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep8_r7Pz];

GHC.Base.$tc':| :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9440832435183810765##
                                    3053237465234607583##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc':|2
                                    1#
                                    GHC.Base.$tc':|1];

GHC.Base.$tcSemigroup :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16195352186364298277##
                                    3285685594139281062##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcSemigroup1
                                    0#
                                    GHC.Base.$tcMonoid1];

$krep9_r7PA :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcSemigroup
                                              $krep3_r7Pu];

GHC.Base.$tcMonoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13838560045895743776##
                                    1291018260833769143##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMonoid2
                                    0#
                                    GHC.Base.$tcMonoid1];

$krep10_r7PB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMonoid
                                              $krep3_r7Pu];

$krep11_r7PC :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep5_r7Pw $krep10_r7PB];

$krep12_r7PD :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r7Pt $krep11_r7PC];

$krep13_r7PE :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep12_r7PD];

GHC.Base.$tc'C:Monoid1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep9_r7PA $krep13_r7PE];

GHC.Base.$tc'C:Monoid :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16099296089107510343##
                                    5895832073319104984##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'C:Monoid2
                                    1#
                                    GHC.Base.$tc'C:Monoid1];

GHC.Base.$tcMonad :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3168880480603756299##
                                    8398240611646296094##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMonad1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcMonadPlus :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14115673251620372550##
                                    14155357326069389390##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcMonadPlus1
                                    0#
                                    GHC.Base.$tcAlternative1];

GHC.Base.$tcOpaque :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9339725405829241186##
                                    15550233501624900571##
                                    GHC.Base.$trModule
                                    GHC.Base.$tcOpaque1
                                    0#
                                    GHC.Types.krep$*];

$krep14_r7PF :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcOpaque
                                              GHC.Types.[]];

GHC.Base.$tc'O1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r7Pr $krep14_r7PF];

GHC.Base.$tc'O :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12551274612394834805##
                                    13000664474148134329##
                                    GHC.Base.$trModule
                                    GHC.Base.$tc'O2
                                    1#
                                    GHC.Base.$tc'O1];

GHC.Base.quotRemInt
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgO7 ds1_sgO8]
        case ds_sgO7 of {
          GHC.Types.I# x_sgOa [Occ=Once] ->
              case ds1_sgO8 of {
                GHC.Types.I# y_sgOc [Occ=Once] ->
                    case quotRemInt# [x_sgOa y_sgOc] of {
                      (#,#) ipv_sgOe [Occ=Once] ipv1_sgOf [Occ=Once] ->
                          let {
                            sat_sgOh [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [ipv1_sgOf]; } in
                          let {
                            sat_sgOg [Occ=Once] :: GHC.Types.Int
                            [LclId] =
                                CCCS GHC.Types.I#! [ipv_sgOe];
                          } in  (,) [sat_sgOg sat_sgOh];
                    };
              };
        };

GHC.Base.modInt :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgOi ds1_sgOj]
        case ds_sgOi of {
          GHC.Types.I# x_sgOl [Occ=Once] ->
              case ds1_sgOj of {
                GHC.Types.I# y_sgOn [Occ=Once] ->
                    case GHC.Classes.modInt# x_sgOl y_sgOn of wild2_sgOo {
                      __DEFAULT -> GHC.Types.I# [wild2_sgOo];
                    };
              };
        };

GHC.Base.divInt :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgOp ds1_sgOq]
        case ds_sgOp of {
          GHC.Types.I# x_sgOs [Occ=Once] ->
              case ds1_sgOq of {
                GHC.Types.I# y_sgOu [Occ=Once] ->
                    case GHC.Classes.divInt# x_sgOs y_sgOu of wild2_sgOv {
                      __DEFAULT -> GHC.Types.I# [wild2_sgOv];
                    };
              };
        };

GHC.Base.remInt [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgOw ds1_sgOx]
        case ds_sgOw of {
          GHC.Types.I# x_sgOz [Occ=Once] ->
              case ds1_sgOx of {
                GHC.Types.I# y_sgOB [Occ=Once] ->
                    case remInt# [x_sgOz y_sgOB] of wild2_sgOC {
                      __DEFAULT -> GHC.Types.I# [wild2_sgOC];
                    };
              };
        };

GHC.Base.quotInt [InlPrag=INLINE (sat-args=2)]
  :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgOD ds1_sgOE]
        case ds_sgOD of {
          GHC.Types.I# x_sgOG [Occ=Once] ->
              case ds1_sgOE of {
                GHC.Types.I# y_sgOI [Occ=Once] ->
                    case quotInt# [x_sgOG y_sgOI] of wild2_sgOJ {
                      __DEFAULT -> GHC.Types.I# [wild2_sgOJ];
                    };
              };
        };

GHC.Base.getTag [InlPrag=INLINE (sat-args=1)]
  :: forall a. a -> GHC.Prim.Int#
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [eta_B1]
        case eta_B1 of sat_sgOK { __DEFAULT -> dataToTag# [sat_sgOK]; };

GHC.Base.$fMonadIO1
  :: forall a b.
     GHC.Types.IO a
     -> (a -> GHC.Types.IO b)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgOL k_sgOM void_0E]
        case ds_sgOL GHC.Prim.void# of {
          Unit# ipv1_sgOQ [Occ=Once] -> k_sgOM ipv1_sgOQ GHC.Prim.void#;
        };

GHC.Base.bindIO
  :: forall a b.
     GHC.Types.IO a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.Base.$fMonadIO1 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.$fApplicativeIO2
  :: forall a b.
     GHC.Types.IO a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_sgOR k_sgOS void_0E]
        case ds_sgOR GHC.Prim.void# of {
          Unit# _ [Occ=Dead] -> k_sgOS GHC.Prim.void#;
        };

GHC.Base.thenIO
  :: forall a b. GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.Base.$fApplicativeIO2 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.unIO1 :: forall a. GHC.Types.IO a -> GHC.Types.IO a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sgOX] ds_sgOX;

GHC.Base.unIO
  :: forall a.
     GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.unIO1 eta_B1;

GHC.Base.$fApplicativeIO4
  :: forall a.
     a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [x_sgOY void_0E] Unit# [x_sgOY];

GHC.Base.returnIO :: forall a. a -> GHC.Types.IO a
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [eta_B2 void_0E]
        GHC.Base.$fApplicativeIO4 eta_B2 GHC.Prim.void#;

GHC.Base.$fApplicativeIO3
  :: forall b a.
     GHC.Types.IO (a -> b)
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_sgP0 m2_sgP1 void_0E]
        case m1_sgP0 GHC.Prim.void# of {
          Unit# ipv1_sgP5 [Occ=Once!] ->
              case m2_sgP1 GHC.Prim.void# of {
                Unit# ipv3_sgP8 [Occ=Once] ->
                    let {
                      sat_sgP9 [Occ=Once] :: b_a4Jk
                      [LclId] =
                          [ipv1_sgP5 ipv3_sgP8] \u [] ipv1_sgP5 ipv3_sgP8;
                    } in  Unit# [sat_sgP9];
              };
        };

GHC.Base.liftA_$sliftA1 [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Types.IO a1 -> GHC.Types.IO r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.Base.$fFunctorIO2 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.ap1
  :: forall a b.
     GHC.Types.IO (a -> b)
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_sgPa m2_sgPb void_0E]
        case m1_sgPa GHC.Prim.void# of {
          Unit# ipv1_sgPf [Occ=Once!] ->
              case m2_sgPb GHC.Prim.void# of {
                Unit# ipv3_sgPi [Occ=Once] ->
                    let {
                      sat_sgPj [Occ=Once] :: b_a43H
                      [LclId] =
                          [ipv1_sgPf ipv3_sgPi] \u [] ipv1_sgPf ipv3_sgPi;
                    } in  Unit# [sat_sgPj];
              };
        };

GHC.Base.ap_$sap1 [InlPrag=INLINABLE]
  :: forall a b.
     GHC.Types.IO (a -> b) -> GHC.Types.IO a -> GHC.Types.IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.Base.ap1 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.ap [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     m (a -> b) -> m a -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgPk m1_sgPl m2_sgPm]
        let {
          sat_sgPr [Occ=Once] :: (a_a437 -> b_a438) -> m_a436 b_a438
          [LclId] =
              [$dMonad_sgPk m2_sgPm] \r [x1_sgPn]
                  let {
                    sat_sgPq [Occ=Once] :: a_a437 -> m_a436 b_a438
                    [LclId] =
                        [$dMonad_sgPk x1_sgPn] \r [x2_sgPo]
                            let {
                              sat_sgPp [Occ=Once] :: b_a438
                              [LclId] =
                                  [x1_sgPn x2_sgPo] \u [] x1_sgPn x2_sgPo;
                            } in  GHC.Base.return $dMonad_sgPk sat_sgPp;
                  } in  GHC.Base.>>= $dMonad_sgPk m2_sgPm sat_sgPq;
        } in  GHC.Base.>>= $dMonad_sgPk m1_sgPl sat_sgPr;

GHC.Base.liftM1
  :: forall a1 a2 r.
     (a1 -> a2 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_sgPs m1_sgPt m2_sgPu void_0E]
        case m1_sgPt GHC.Prim.void# of {
          Unit# ipv1_sgPy [Occ=Once] ->
              case m2_sgPu GHC.Prim.void# of {
                Unit# ipv3_sgPB [Occ=Once] ->
                    let {
                      sat_sgPC [Occ=Once] :: r_a4br
                      [LclId] =
                          [f_sgPs ipv1_sgPy ipv3_sgPB] \u [] f_sgPs ipv1_sgPy ipv3_sgPB;
                    } in  Unit# [sat_sgPC];
              };
        };

GHC.Base.liftM2_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 r.
     (a1 -> a2 -> r)
     -> GHC.Types.IO a1 -> GHC.Types.IO a2 -> GHC.Types.IO r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 void_0E]
        GHC.Base.liftM1 eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.liftM2 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgPD f_sgPE m1_sgPF m2_sgPG]
        let {
          sat_sgPL [Occ=Once] :: a1_a4aI -> m_a4aH r_a4aK
          [LclId] =
              [$dMonad_sgPD f_sgPE m2_sgPG] \r [x1_sgPH]
                  let {
                    sat_sgPK [Occ=Once] :: a2_a4aJ -> m_a4aH r_a4aK
                    [LclId] =
                        [$dMonad_sgPD f_sgPE x1_sgPH] \r [x2_sgPI]
                            let {
                              sat_sgPJ [Occ=Once] :: r_a4aK
                              [LclId] =
                                  [f_sgPE x1_sgPH x2_sgPI] \u [] f_sgPE x1_sgPH x2_sgPI;
                            } in  GHC.Base.return $dMonad_sgPD sat_sgPJ;
                  } in  GHC.Base.>>= $dMonad_sgPD m2_sgPG sat_sgPK;
        } in  GHC.Base.>>= $dMonad_sgPD m1_sgPF sat_sgPL;

$cliftA2_r7PG
  :: forall c b a.
     (a -> b -> c)
     -> GHC.Types.IO a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, c #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    sat-only [] \r [f_sgPM m1_sgPN m2_sgPO void_0E]
        case m1_sgPN GHC.Prim.void# of {
          Unit# ipv1_sgPS [Occ=Once] ->
              case m2_sgPO GHC.Prim.void# of {
                Unit# ipv3_sgPV [Occ=Once] ->
                    let {
                      sat_sgPW [Occ=Once] :: c_a4Jw
                      [LclId] =
                          [f_sgPM ipv1_sgPS ipv3_sgPV] \u [] f_sgPM ipv1_sgPS ipv3_sgPV;
                    } in  Unit# [sat_sgPW];
              };
        };

GHC.Base.$fApplicativeIO_$cliftA2 [InlPrag=INLINE (sat-args=0)]
  :: forall a b c.
     (a -> b -> c) -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 void_0E]
        $cliftA2_r7PG eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.liftA1
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_sgPX a_sgPY b_sgPZ c_sgQ0 void_0E]
        case a_sgPY GHC.Prim.void# of {
          Unit# ipv1_sgQ4 [Occ=Once] ->
              case b_sgPZ GHC.Prim.void# of {
                Unit# ipv3_sgQ7 [Occ=Once] ->
                    case c_sgQ0 GHC.Prim.void# of {
                      Unit# ipv5_sgQa [Occ=Once] ->
                          let {
                            sat_sgQb [Occ=Once] :: r_a4g0
                            [LclId] =
                                [f_sgPX ipv1_sgQ4 ipv3_sgQ7 ipv5_sgQa] \u []
                                    f_sgPX ipv1_sgQ4 ipv3_sgQ7 ipv5_sgQa;
                          } in  Unit# [sat_sgQb];
                    };
              };
        };

GHC.Base.liftA3_$sliftA1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 void_0E]
        GHC.Base.liftA1 eta_B5 eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.$fSemigroupIO2
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Types.IO a
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sgQc eta_sgQd eta1_sgQe void_0E]
        case eta_sgQd GHC.Prim.void# of {
          Unit# ipv1_sgQi [Occ=Once] ->
              case eta1_sgQe GHC.Prim.void# of {
                Unit# ipv3_sgQl [Occ=Once] ->
                    let {
                      sat_sgQm [Occ=Once] :: a_a4Al
                      [LclId] =
                          [$dSemigroup_sgQc ipv1_sgQi ipv3_sgQl] \u []
                              GHC.Base.<> $dSemigroup_sgQc ipv1_sgQi ipv3_sgQl;
                    } in  Unit# [sat_sgQm];
              };
        };

GHC.Base.$w$csconcat4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Types.IO a
     -> [GHC.Types.IO a]
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><C(S),1*C1(U(U,U))><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgQn ww_sgQo ww1_sgQp void_0E]
        let {
          go_sgQr [Occ=LoopBreaker]
            :: GHC.Types.IO a_s6Fu
               -> [GHC.Types.IO a_s6Fu]
               -> GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, a_s6Fu #)
          [LclId,
           Arity=3,
           Str=<C(S),1*C1(U(U,U))><S,1*U><S,U>,
           Unf=OtherCon []] =
              sat-only [w_sgQn go_sgQr] \r [b_sgQs ds_sgQt void_0E]
                  case ds_sgQt of {
                    [] -> b_sgQs GHC.Prim.void#;
                    : c_sgQw [Occ=Once] cs_sgQx [Occ=Once] ->
                        case b_sgQs GHC.Prim.void# of {
                          Unit# ipv1_sgQA [Occ=Once] ->
                              case go_sgQr c_sgQw cs_sgQx GHC.Prim.void# of {
                                Unit# ipv3_sgQD [Occ=Once] ->
                                    let {
                                      sat_sgQE [Occ=Once] :: a_s6Fu
                                      [LclId] =
                                          [w_sgQn ipv1_sgQA ipv3_sgQD] \u []
                                              GHC.Base.<> w_sgQn ipv1_sgQA ipv3_sgQD;
                                    } in  Unit# [sat_sgQE];
                              };
                        };
                  };
        } in  go_sgQr ww_sgQo ww1_sgQp GHC.Prim.void#;

GHC.Base.$fSemigroupIO1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (GHC.Types.IO a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(C(S)S),1*U(1*C1(U(U,U)),1*U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sgQF w1_sgQG void_0E]
        case w1_sgQG of {
          GHC.Base.:| ww1_sgQJ [Occ=Once] ww2_sgQK [Occ=Once] ->
              GHC.Base.$w$csconcat4 w_sgQF ww1_sgQJ ww2_sgQK GHC.Prim.void#;
        };

GHC.Base.$fSemigroupIO [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (GHC.Types.IO a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(U)),A,A)>m] =
    [] \r [$dSemigroup_sgQL]
        let {
          sat_sgQO [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> GHC.Types.IO a_X4J3 -> GHC.Types.IO a_X4J3
          [LclId] =
              [$dSemigroup_sgQL] \r [eta_B1]
                  GHC.Base.$fSemigroupIO_$cstimes $dSemigroup_sgQL eta_B1; } in
        let {
          sat_sgQN [Occ=Once]
            :: GHC.Base.NonEmpty (GHC.Types.IO a_X4J3) -> GHC.Types.IO a_X4J3
          [LclId] =
              [$dSemigroup_sgQL] \r [eta_B2 void_0E]
                  GHC.Base.$fSemigroupIO1
                      $dSemigroup_sgQL eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgQM [Occ=Once]
            :: GHC.Types.IO a_X4J3
               -> GHC.Types.IO a_X4J3 -> GHC.Types.IO a_X4J3
          [LclId] =
              [$dSemigroup_sgQL] \r [eta_B3 eta_B2 void_0E]
                  GHC.Base.$fSemigroupIO2
                      $dSemigroup_sgQL eta_B3 eta_B2 GHC.Prim.void#;
        } in  GHC.Base.C:Semigroup [sat_sgQM sat_sgQN sat_sgQO];
GHC.Base.$fSemigroupIO_$cstimes [Occ=LoopBreaker]
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b.
     GHC.Real.Integral b =>
     b -> GHC.Types.IO a -> GHC.Types.IO a
[GblId, Arity=2, Str=<L,U(C(C1(U)),A,A)><L,U>, Unf=OtherCon []] =
    [] \r [$dSemigroup_sgQP $dIntegral_sgQQ]
        let {
          sat_sgQR [Occ=Once] :: GHC.Base.Semigroup (GHC.Types.IO a_X4J4)
          [LclId] =
              [$dSemigroup_sgQP] \u [] GHC.Base.$fSemigroupIO $dSemigroup_sgQP;
        } in 
          Data.Semigroup.Internal.stimesDefault $dIntegral_sgQQ sat_sgQR;

GHC.Base.$fMonoidIO_$cp1Monoid
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (GHC.Types.IO a)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(C(C1(U)),A,A),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgQS]
        let {
          sat_sgQT [Occ=Once, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_X4I6
          [LclId] =
              [$dMonoid_sgQS] \u [] GHC.Base.$p1Monoid $dMonoid_sgQS;
        } in  GHC.Base.$fSemigroupIO sat_sgQT;

$cmappend_r7PH
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Types.IO a
     -> GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dMonoid_sgQU eta_sgQV eta1_sgQW void_0E]
        case eta_sgQV GHC.Prim.void# of {
          Unit# ipv1_sgR0 [Occ=Once] ->
              case eta1_sgQW GHC.Prim.void# of {
                Unit# ipv3_sgR3 [Occ=Once] ->
                    let {
                      sat_sgR5 [Occ=Once] :: a_X4I8
                      [LclId] =
                          [$dMonoid_sgQU ipv1_sgR0 ipv3_sgR3] \u []
                              case GHC.Base.$p1Monoid $dMonoid_sgQU of sat_sgR4 {
                                __DEFAULT -> GHC.Base.<> sat_sgR4 ipv1_sgR0 ipv3_sgR3;
                              };
                    } in  Unit# [sat_sgR5];
              };
        };

GHC.Base.$fMonoidIO_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Types.IO a -> GHC.Types.IO a -> GHC.Types.IO a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 void_0E]
        $cmappend_r7PH eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.$fAlternativeIO1
  :: forall a.
     GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [void_0E] Unit# [GHC.Types.[]];

GHC.Base.$fAlternativeIO2
  :: forall a.
     GHC.Types.IO a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a] #)
[GblId, Arity=2, Str=<C(S(SL)),C(U(U,U))><S,U>, Unf=OtherCon []] =
    [] \r [v_sgR7 void_0E]
        let {
          some_v_sgR9 [Occ=LoopBreaker]
            :: GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, [a_a4HN] #)
          [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []] =
              [v_sgR7 some_v_sgR9] \r [void_0E]
                  case v_sgR7 GHC.Prim.void# of {
                    Unit# ipv1_sgRd [Occ=Once] ->
                        case
                            GHC.IO.mplusIO some_v_sgR9 GHC.Base.$fAlternativeIO1 GHC.Prim.void#
                        of
                        { Unit# ipv3_sgRg [Occ=Once] ->
                              let {
                                sat_sgRh [Occ=Once] :: [a_a4HN]
                                [LclId] =
                                    CCCS :! [ipv1_sgRd ipv3_sgRg];
                              } in  Unit# [sat_sgRh];
                        };
                  };
        } in  some_v_sgR9 GHC.Prim.void#;

GHC.Base.$fAlternativeIO_$cmany
  :: forall a. GHC.Types.IO a -> GHC.Types.IO [a]
[GblId, Arity=1, Str=<L,C(U(U,U))>, Unf=OtherCon []] =
    [] \r [v_sgRi]
        let {
          many_v_sgRj [Occ=LoopBreaker] :: GHC.Types.IO [a_a4HV]
          [LclId] =
              [v_sgRi many_v_sgRj] \u []
                  let {
                    sat_sgRs [Occ=Once] :: GHC.Types.IO [a_a4HV]
                    [LclId] =
                        [v_sgRi many_v_sgRj] \r [void_0E]
                            case v_sgRi GHC.Prim.void# of {
                              Unit# ipv1_sgRn [Occ=Once] ->
                                  case many_v_sgRj GHC.Prim.void# of {
                                    Unit# ipv3_sgRq [Occ=Once] ->
                                        let {
                                          sat_sgRr [Occ=Once] :: [a_a4HV]
                                          [LclId] =
                                              CCCS :! [ipv1_sgRn ipv3_sgRq];
                                        } in  Unit# [sat_sgRr];
                                  };
                            };
                  } in  GHC.IO.mplusIO sat_sgRs GHC.Base.$fAlternativeIO1;
        } in  many_v_sgRj;

GHC.Base.liftM9
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Types.IO a5
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_sgRt m1_sgRu m2_sgRv m3_sgRw m4_sgRx m5_sgRy void_0E]
        case m1_sgRu GHC.Prim.void# of {
          Unit# ipv1_sgRC [Occ=Once] ->
              case m2_sgRv GHC.Prim.void# of {
                Unit# ipv3_sgRF [Occ=Once] ->
                    case m3_sgRw GHC.Prim.void# of {
                      Unit# ipv5_sgRI [Occ=Once] ->
                          case m4_sgRx GHC.Prim.void# of {
                            Unit# ipv7_sgRL [Occ=Once] ->
                                case m5_sgRy GHC.Prim.void# of {
                                  Unit# ipv9_sgRO [Occ=Once] ->
                                      let {
                                        sat_sgRP [Occ=Once] :: r_a45A
                                        [LclId] =
                                            [f_sgRt
                                             ipv1_sgRC
                                             ipv3_sgRF
                                             ipv5_sgRI
                                             ipv7_sgRL
                                             ipv9_sgRO] \u []
                                                f_sgRt
                                                    ipv1_sgRC
                                                    ipv3_sgRF
                                                    ipv5_sgRI
                                                    ipv7_sgRL
                                                    ipv9_sgRO;
                                      } in  Unit# [sat_sgRP];
                                };
                          };
                    };
              };
        };

GHC.Base.liftM5_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Types.IO a5
     -> GHC.Types.IO r
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 void_0E]
        GHC.Base.liftM9
            eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.liftM5 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 a4 a5 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgRQ f_sgRR m1_sgRS m2_sgRT m3_sgRU m4_sgRV m5_sgRW]
        let {
          sat_sgS7 [Occ=Once] :: a1_a44e -> m_a44d r_a44j
          [LclId] =
              [$dMonad_sgRQ f_sgRR m2_sgRT m3_sgRU m4_sgRV m5_sgRW] \r [x1_sgRX]
                  let {
                    sat_sgS6 [Occ=Once] :: a2_a44f -> m_a44d r_a44j
                    [LclId] =
                        [$dMonad_sgRQ f_sgRR m3_sgRU m4_sgRV m5_sgRW x1_sgRX] \r [x2_sgRY]
                            let {
                              sat_sgS5 [Occ=Once] :: a3_a44g -> m_a44d r_a44j
                              [LclId] =
                                  [$dMonad_sgRQ f_sgRR m4_sgRV m5_sgRW x1_sgRX x2_sgRY] \r [x3_sgRZ]
                                      let {
                                        sat_sgS4 [Occ=Once] :: a4_a44h -> m_a44d r_a44j
                                        [LclId] =
                                            [$dMonad_sgRQ
                                             f_sgRR
                                             m5_sgRW
                                             x1_sgRX
                                             x2_sgRY
                                             x3_sgRZ] \r [x4_sgS0]
                                                let {
                                                  sat_sgS3 [Occ=Once] :: a5_a44i -> m_a44d r_a44j
                                                  [LclId] =
                                                      [$dMonad_sgRQ
                                                       f_sgRR
                                                       x1_sgRX
                                                       x2_sgRY
                                                       x3_sgRZ
                                                       x4_sgS0] \r [x5_sgS1]
                                                          let {
                                                            sat_sgS2 [Occ=Once] :: r_a44j
                                                            [LclId] =
                                                                [f_sgRR
                                                                 x1_sgRX
                                                                 x2_sgRY
                                                                 x3_sgRZ
                                                                 x4_sgS0
                                                                 x5_sgS1] \u []
                                                                    f_sgRR
                                                                        x1_sgRX
                                                                        x2_sgRY
                                                                        x3_sgRZ
                                                                        x4_sgS0
                                                                        x5_sgS1;
                                                          } in 
                                                            GHC.Base.return $dMonad_sgRQ sat_sgS2;
                                                } in  GHC.Base.>>= $dMonad_sgRQ m5_sgRW sat_sgS3;
                                      } in  GHC.Base.>>= $dMonad_sgRQ m4_sgRV sat_sgS4;
                            } in  GHC.Base.>>= $dMonad_sgRQ m3_sgRU sat_sgS5;
                  } in  GHC.Base.>>= $dMonad_sgRQ m2_sgRT sat_sgS6;
        } in  GHC.Base.>>= $dMonad_sgRQ m1_sgRS sat_sgS7;

GHC.Base.liftM8
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, r #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [f_sgS8 m1_sgS9 m2_sgSa m3_sgSb m4_sgSc void_0E]
        case m1_sgS9 GHC.Prim.void# of {
          Unit# ipv1_sgSg [Occ=Once] ->
              case m2_sgSa GHC.Prim.void# of {
                Unit# ipv3_sgSj [Occ=Once] ->
                    case m3_sgSb GHC.Prim.void# of {
                      Unit# ipv5_sgSm [Occ=Once] ->
                          case m4_sgSc GHC.Prim.void# of {
                            Unit# ipv7_sgSp [Occ=Once] ->
                                let {
                                  sat_sgSq [Occ=Once] :: r_a47U
                                  [LclId] =
                                      [f_sgS8 ipv1_sgSg ipv3_sgSj ipv5_sgSm ipv7_sgSp] \u []
                                          f_sgS8 ipv1_sgSg ipv3_sgSj ipv5_sgSm ipv7_sgSp;
                                } in  Unit# [sat_sgSq];
                          };
                    };
              };
        };

GHC.Base.liftM4_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO a4
     -> GHC.Types.IO r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 void_0E]
        GHC.Base.liftM8 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.liftM4 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 a4 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(C1(U))))><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgSr f_sgSs m1_sgSt m2_sgSu m3_sgSv m4_sgSw]
        let {
          sat_sgSF [Occ=Once] :: a1_a46L -> m_a46K r_a46P
          [LclId] =
              [$dMonad_sgSr f_sgSs m2_sgSu m3_sgSv m4_sgSw] \r [x1_sgSx]
                  let {
                    sat_sgSE [Occ=Once] :: a2_a46M -> m_a46K r_a46P
                    [LclId] =
                        [$dMonad_sgSr f_sgSs m3_sgSv m4_sgSw x1_sgSx] \r [x2_sgSy]
                            let {
                              sat_sgSD [Occ=Once] :: a3_a46N -> m_a46K r_a46P
                              [LclId] =
                                  [$dMonad_sgSr f_sgSs m4_sgSw x1_sgSx x2_sgSy] \r [x3_sgSz]
                                      let {
                                        sat_sgSC [Occ=Once] :: a4_a46O -> m_a46K r_a46P
                                        [LclId] =
                                            [$dMonad_sgSr
                                             f_sgSs
                                             x1_sgSx
                                             x2_sgSy
                                             x3_sgSz] \r [x4_sgSA]
                                                let {
                                                  sat_sgSB [Occ=Once] :: r_a46P
                                                  [LclId] =
                                                      [f_sgSs x1_sgSx x2_sgSy x3_sgSz x4_sgSA] \u []
                                                          f_sgSs x1_sgSx x2_sgSy x3_sgSz x4_sgSA;
                                                } in  GHC.Base.return $dMonad_sgSr sat_sgSB;
                                      } in  GHC.Base.>>= $dMonad_sgSr m4_sgSw sat_sgSC;
                            } in  GHC.Base.>>= $dMonad_sgSr m3_sgSv sat_sgSD;
                  } in  GHC.Base.>>= $dMonad_sgSr m2_sgSu sat_sgSE;
        } in  GHC.Base.>>= $dMonad_sgSr m1_sgSt sat_sgSF;

GHC.Base.liftM3_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Types.IO a1
     -> GHC.Types.IO a2
     -> GHC.Types.IO a3
     -> GHC.Types.IO r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 void_0E]
        GHC.Base.liftA1 eta_B5 eta_B4 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.liftM3 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 r.
     GHC.Base.Monad m =>
     (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(U)))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgSG f_sgSH m1_sgSI m2_sgSJ m3_sgSK]
        let {
          sat_sgSR [Occ=Once] :: a1_a48V -> m_a48U r_a48Y
          [LclId] =
              [$dMonad_sgSG f_sgSH m2_sgSJ m3_sgSK] \r [x1_sgSL]
                  let {
                    sat_sgSQ [Occ=Once] :: a2_a48W -> m_a48U r_a48Y
                    [LclId] =
                        [$dMonad_sgSG f_sgSH m3_sgSK x1_sgSL] \r [x2_sgSM]
                            let {
                              sat_sgSP [Occ=Once] :: a3_a48X -> m_a48U r_a48Y
                              [LclId] =
                                  [$dMonad_sgSG f_sgSH x1_sgSL x2_sgSM] \r [x3_sgSN]
                                      let {
                                        sat_sgSO [Occ=Once] :: r_a48Y
                                        [LclId] =
                                            [f_sgSH x1_sgSL x2_sgSM x3_sgSN] \u []
                                                f_sgSH x1_sgSL x2_sgSM x3_sgSN;
                                      } in  GHC.Base.return $dMonad_sgSG sat_sgSO;
                            } in  GHC.Base.>>= $dMonad_sgSG m3_sgSK sat_sgSP;
                  } in  GHC.Base.>>= $dMonad_sgSG m2_sgSJ sat_sgSQ;
        } in  GHC.Base.>>= $dMonad_sgSG m1_sgSI sat_sgSR;

GHC.Base.liftM_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Types.IO a1 -> GHC.Types.IO r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 void_0E]
        GHC.Base.$fFunctorIO2 eta_B3 eta_B2 GHC.Prim.void#;

GHC.Base.liftM [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 r.
     GHC.Base.Monad m =>
     (a1 -> r) -> m a1 -> m r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgSS f_sgST m1_sgSU]
        let {
          sat_sgSX [Occ=Once] :: a1_a4c8 -> m_a4c7 r_a4c9
          [LclId] =
              [$dMonad_sgSS f_sgST] \r [x1_sgSV]
                  let {
                    sat_sgSW [Occ=Once] :: r_a4c9
                    [LclId] =
                        [f_sgST x1_sgSV] \u [] f_sgST x1_sgSV;
                  } in  GHC.Base.return $dMonad_sgSS sat_sgSW;
        } in  GHC.Base.>>= $dMonad_sgSS m1_sgSU sat_sgSX;

GHC.Base.$! :: forall a (b :: TYPE r). (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgSY x_sgSZ]
        case x_sgSZ of vx_sgT0 { __DEFAULT -> f_sgSY vx_sgT0; };

GHC.Base.$ [InlPrag=INLINE (sat-args=2)]
  :: forall a (b :: TYPE r). (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgT1 x_sgT2] f_sgT1 x_sgT2;

GHC.Base.flip :: forall a b c. (a -> b -> c) -> b -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgT3 x_sgT4 y_sgT5] f_sgT3 y_sgT5 x_sgT4;

GHC.Base.$fMonad(->)_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall r a b. (r -> a) -> (r -> b) -> r -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_sgT6 eta1_sgT7 r1_sgT8] eta1_sgT7 r1_sgT8;

GHC.Base.$fApplicative(->)_$c<*
  :: forall a1 a2 b. (a1 -> a2) -> (a1 -> b) -> a1 -> a2
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgT9 g_sgTa x_sgTb] f_sgT9 x_sgTb;

GHC.Base.$fMonad(,)_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,A)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgTc eta_sgTd eta1_sgTe]
        case eta_sgTd of {
          (,) u_sgTg [Occ=Once] _ [Occ=Dead] ->
              case eta1_sgTe of {
                (,) v_sgTj [Occ=Once] b1_sgTk [Occ=Once] ->
                    let {
                      sat_sgTm [Occ=Once] :: a_a4ul
                      [LclId] =
                          [$dMonoid_sgTc u_sgTg v_sgTj] \u []
                              case GHC.Base.$p1Monoid $dMonoid_sgTc of sat_sgTl {
                                __DEFAULT -> GHC.Base.<> sat_sgTl u_sgTg v_sgTj;
                              };
                    } in  (,) [sat_sgTm b1_sgTk];
              };
        };

GHC.Base.$fApplicative(,)_$c<*
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a, b) -> (a, a1)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><S,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgTn eta_sgTo eta1_sgTp]
        case eta_sgTo of {
          (,) u_sgTr [Occ=Once] x_sgTs [Occ=Once] ->
              case eta1_sgTp of {
                (,) v_sgTu [Occ=Once] _ [Occ=Dead] ->
                    let {
                      sat_sgTx [Occ=Once] :: a_a4vv
                      [LclId] =
                          [$dMonoid_sgTn u_sgTr v_sgTu] \u []
                              case GHC.Base.$p1Monoid $dMonoid_sgTn of sat_sgTw {
                                __DEFAULT -> GHC.Base.<> sat_sgTw u_sgTr v_sgTu;
                              };
                    } in  (,) [sat_sgTx x_sgTs];
              };
        };

GHC.Base.$fFunctor(,)_$c<$
  :: forall a1 a2 b. a2 -> (a1, b) -> (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U(U,A)>m,
 Unf=OtherCon []] =
    [] \r [x_sgTy ds_sgTz]
        case ds_sgTz of {
          (,) x1_sgTB [Occ=Once] _ [Occ=Dead] -> (,) [x1_sgTB x_sgTy];
        };

GHC.Base.$fFunctorMaybe_$c<$
  :: forall a b. a -> GHC.Base.Maybe b -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sgTD ds_sgTE]
        case ds_sgTE of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> GHC.Base.Just [x_sgTD];
        };

GHC.Base.$dm<$
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     forall a b. a -> f b -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sgTH eta_sgTI]
        let {
          sat_sgTK [Occ=Once] :: b_a4il -> a_a4ik
          [LclId] =
              [eta_sgTI] \r [ds_sgTJ] eta_sgTI;
        } in  GHC.Base.fmap $dFunctor_sgTH sat_sgTK;

GHC.Base.$fMonoid(->)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall b a. GHC.Base.Monoid b => (a -> b) -> (a -> b) -> a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgTL eta_sgTM eta1_sgTN eta2_sgTO]
        let {
          sat_sgTR [Occ=Once] :: b_a4zA
          [LclId] =
              [eta1_sgTN eta2_sgTO] \u [] eta1_sgTN eta2_sgTO; } in
        let {
          sat_sgTQ [Occ=Once] :: b_a4zA
          [LclId] =
              [eta_sgTM eta2_sgTO] \u [] eta_sgTM eta2_sgTO;
        } in 
          case GHC.Base.$p1Monoid $dMonoid_sgTL of sat_sgTP {
            __DEFAULT -> GHC.Base.<> sat_sgTP sat_sgTQ sat_sgTR;
          };

GHC.Base.$fMonoid(,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     (a, b) -> (a, b) -> (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgTS $dMonoid1_sgTT eta_sgTU eta1_sgTV]
        case eta_sgTU of {
          (,) a1_sgTX [Occ=Once] b1_sgTY [Occ=Once] ->
              case eta1_sgTV of {
                (,) a'_sgU0 [Occ=Once] b'_sgU1 [Occ=Once] ->
                    let {
                      sat_sgU5 [Occ=Once] :: b_a4yQ
                      [LclId] =
                          [$dMonoid1_sgTT b1_sgTY b'_sgU1] \u []
                              case GHC.Base.$p1Monoid $dMonoid1_sgTT of sat_sgU4 {
                                __DEFAULT -> GHC.Base.<> sat_sgU4 b1_sgTY b'_sgU1;
                              }; } in
                    let {
                      sat_sgU3 [Occ=Once] :: a_a4yP
                      [LclId] =
                          [$dMonoid_sgTS a1_sgTX a'_sgU0] \u []
                              case GHC.Base.$p1Monoid $dMonoid_sgTS of sat_sgU2 {
                                __DEFAULT -> GHC.Base.<> sat_sgU2 a1_sgTX a'_sgU0;
                              };
                    } in  (,) [sat_sgU3 sat_sgU5];
              };
        };

GHC.Base.$fSemigroupOrdering_go [Occ=LoopBreaker]
  :: GHC.Types.Ordering -> [GHC.Types.Ordering] -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sgU6 ds_sgU7]
        case ds_sgU7 of {
          [] -> b_sgU6;
          : c_sgU9 [Occ=Once] cs_sgUa [Occ=Once] ->
              case b_sgU6 of {
                GHC.Types.LT -> GHC.Types.LT [];
                GHC.Types.EQ -> GHC.Base.$fSemigroupOrdering_go c_sgU9 cs_sgUa;
                GHC.Types.GT -> GHC.Types.GT [];
              };
        };

GHC.Base.$fSemigroupOrdering_$csconcat
  :: GHC.Base.NonEmpty GHC.Types.Ordering -> GHC.Types.Ordering
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgUc]
        case ds_sgUc of {
          GHC.Base.:| a_sgUe [Occ=Once] as_sgUf [Occ=Once] ->
              GHC.Base.$fSemigroupOrdering_go a_sgUe as_sgUf;
        };

GHC.Base.. [InlPrag=INLINE (sat-args=2)]
  :: forall b c a. (b -> c) -> (a -> b) -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgUg g_sgUh x_sgUi]
        let {
          sat_sgUj [Occ=Once] :: b_a41v
          [LclId] =
              [g_sgUh x_sgUi] \u [] g_sgUh x_sgUi;
        } in  f_sgUg sat_sgUj;

GHC.Base.mapFB [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall elt lst a.
     (elt -> lst -> lst) -> (a -> elt) -> a -> lst -> lst
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c_sgUk f_sgUl x_sgUm ys_sgUn]
        let {
          sat_sgUo [Occ=Once] :: elt_a42v
          [LclId] =
              [f_sgUl x_sgUm] \u [] f_sgUl x_sgUm;
        } in  c_sgUk sat_sgUo ys_sgUn;

GHC.Base.$fFunctor(->)_$c<$
  :: forall r a b. a -> (r -> b) -> r -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgUp eta_sgUq eta1_sgUr] x_sgUp;

GHC.Base.$fFunctor(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall r. GHC.Base.Functor ((->) r)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base..
                                       GHC.Base.$fFunctor(->)_$c<$];

GHC.Base.const :: forall a b. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_sgUs ds_sgUt] x_sgUs;

GHC.Base.asTypeOf :: forall a. a -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.const eta_B2 eta_B1;

GHC.Base.$dm<*
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgUu]
        GHC.Base.liftA2 $dApplicative_sgUu GHC.Base.const;

GHC.Base.$fApplicativeIO1
  :: forall a b.
     GHC.Types.IO a
     -> GHC.Types.IO b
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,A))><S,U>,
 Unf=OtherCon []] =
    [] \r [m1_sgUv m2_sgUw void_0E]
        case m1_sgUv GHC.Prim.void# of {
          Unit# ipv1_sgUA [Occ=Once] ->
              case m2_sgUw GHC.Prim.void# of {
                Unit# _ [Occ=Dead] -> Unit# [ipv1_sgUA];
              };
        };

GHC.Base.$fApplicativeIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctorIO
                                           GHC.Base.$fApplicativeIO4
                                           GHC.Base.$fApplicativeIO3
                                           GHC.Base.$fApplicativeIO_$cliftA2
                                           GHC.Base.$fApplicativeIO2
                                           GHC.Base.$fApplicativeIO1];

GHC.Base.breakpointCond :: forall a. GHC.Types.Bool -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgUE r_sgUF] r_sgUF;

GHC.Base.breakpoint :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [r_sgUG] r_sgUG;

GHC.Base.assert :: forall a. GHC.Types.Bool -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.breakpointCond eta_B2 eta_B1;

GHC.Base.id :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.breakpoint eta_B1;

GHC.Base.join
  :: forall (m :: * -> *) a. GHC.Base.Monad m => m (m a) -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgUH x_sgUI]
        GHC.Base.>>= $dMonad_sgUH x_sgUI GHC.Base.breakpoint;

GHC.Base.$dm<*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f (a -> b) -> f a -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgUJ]
        GHC.Base.liftA2 $dApplicative_sgUJ GHC.Base.breakpoint;

GHC.Base.$dm*>
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b. f a -> f b -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(1*U(A,1*C1(C1(U))),A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sgUK eta_sgUL eta1_sgUM]
        let {
          sat_sgUO [Occ=Once] :: f_a37E (b_a4j2 -> b_a4j2)
          [LclId] =
              [$dApplicative_sgUK eta_sgUL] \u []
                  case GHC.Base.$p1Applicative $dApplicative_sgUK of sat_sgUN {
                    __DEFAULT -> GHC.Base.<$ sat_sgUN GHC.Base.breakpoint eta_sgUL;
                  };
        } in  GHC.Base.<*> $dApplicative_sgUK sat_sgUO eta1_sgUM;

GHC.Base.$fApplicative(->)_$c*>
  :: forall a1 a2 b. (a1 -> a2) -> (a1 -> b) -> a1 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [a2_sgUP a3_sgUQ x_sgUR] a3_sgUQ x_sgUR;

GHC.Base.maxInt :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [9223372036854775807#];

GHC.Base.minInt :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [-9223372036854775808#];

GHC.Base.ord :: GHC.Types.Char -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgUS]
        case ds_sgUS of {
          GHC.Types.C# c#_sgUU [Occ=Once] ->
              case ord# [c#_sgUU] of sat_sgUV {
                __DEFAULT -> GHC.Types.I# [sat_sgUV];
              };
        };

GHC.Base.unsafeChr :: GHC.Types.Int -> GHC.Types.Char
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgUW]
        case ds_sgUW of {
          GHC.Types.I# i#_sgUY [Occ=Once] ->
              case chr# [i#_sgUY] of sat_sgUZ {
                __DEFAULT -> GHC.Types.C# [sat_sgUZ];
              };
        };

GHC.Base.otherwise :: GHC.Types.Bool
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.True! [];

GHC.Base.until
  :: forall a. (a -> GHC.Types.Bool) -> (a -> a) -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [p_sgV0 f_sgV1 eta_sgV2]
        let-no-escape {
          go_sgV3 [Occ=LoopBreakerT[1]] :: a_a41W -> a_a41W
          [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [p_sgV0 f_sgV1 go_sgV3] \r [x_sgV4]
                  case p_sgV0 x_sgV4 of {
                    GHC.Types.False ->
                        let {
                          sat_sgV6 [Occ=Once] :: a_a41W
                          [LclId] =
                              [f_sgV1 x_sgV4] \u [] f_sgV1 x_sgV4;
                        } in  go_sgV3 sat_sgV6;
                    GHC.Types.True -> x_sgV4;
                  };
        } in  go_sgV3 eta_sgV2;

GHC.Base.divModInt#
  :: GHC.Prim.Int#
     -> GHC.Prim.Int# -> (# GHC.Prim.Int#, GHC.Prim.Int# #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [x#_sgV7 y#_sgV8]
        case ># [x#_sgV7 0#] of {
          __DEFAULT ->
              case <# [x#_sgV7 0#] of {
                __DEFAULT -> quotRemInt# [x#_sgV7 y#_sgV8];
                1# ->
                    case ># [y#_sgV8 0#] of {
                      __DEFAULT -> quotRemInt# [x#_sgV7 y#_sgV8];
                      1# ->
                          case +# [x#_sgV7 1#] of sat_sgVc {
                            __DEFAULT ->
                                case quotRemInt# [sat_sgVc y#_sgV8] of {
                                  (#,#) ipv_sgVe [Occ=Once] ipv1_sgVf [Occ=Once] ->
                                      case +# [ipv1_sgVf y#_sgV8] of sat_sgVh {
                                        __DEFAULT ->
                                            case -# [sat_sgVh 1#] of sat_sgVi {
                                              __DEFAULT ->
                                                  case -# [ipv_sgVe 1#] of sat_sgVg {
                                                    __DEFAULT -> (#,#) [sat_sgVg sat_sgVi];
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
          1# ->
              case <# [y#_sgV8 0#] of {
                __DEFAULT ->
                    case <# [x#_sgV7 0#] of {
                      __DEFAULT -> quotRemInt# [x#_sgV7 y#_sgV8];
                      1# ->
                          case ># [y#_sgV8 0#] of {
                            __DEFAULT -> quotRemInt# [x#_sgV7 y#_sgV8];
                            1# ->
                                case +# [x#_sgV7 1#] of sat_sgVm {
                                  __DEFAULT ->
                                      case quotRemInt# [sat_sgVm y#_sgV8] of {
                                        (#,#) ipv_sgVo [Occ=Once] ipv1_sgVp [Occ=Once] ->
                                            case +# [ipv1_sgVp y#_sgV8] of sat_sgVr {
                                              __DEFAULT ->
                                                  case -# [sat_sgVr 1#] of sat_sgVs {
                                                    __DEFAULT ->
                                                        case -# [ipv_sgVo 1#] of sat_sgVq {
                                                          __DEFAULT -> (#,#) [sat_sgVq sat_sgVs];
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
                1# ->
                    case -# [x#_sgV7 1#] of sat_sgVt {
                      __DEFAULT ->
                          case quotRemInt# [sat_sgVt y#_sgV8] of {
                            (#,#) ipv_sgVv [Occ=Once] ipv1_sgVw [Occ=Once] ->
                                case +# [ipv1_sgVw y#_sgV8] of sat_sgVy {
                                  __DEFAULT ->
                                      case +# [sat_sgVy 1#] of sat_sgVz {
                                        __DEFAULT ->
                                            case -# [ipv_sgVv 1#] of sat_sgVx {
                                              __DEFAULT -> (#,#) [sat_sgVx sat_sgVz];
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Base.divModInt [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_sgVA w1_sgVB]
        case w_sgVA of {
          GHC.Types.I# ww1_sgVD ->
              case w1_sgVB of {
                GHC.Types.I# ww3_sgVF ->
                    case ># [ww1_sgVD 0#] of {
                      __DEFAULT ->
                          case <# [ww1_sgVD 0#] of {
                            __DEFAULT ->
                                case quotRemInt# [ww1_sgVD ww3_sgVF] of {
                                  (#,#) ipv_sgVJ [Occ=Once] ipv1_sgVK [Occ=Once] ->
                                      let {
                                        sat_sgVM [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv1_sgVK]; } in
                                      let {
                                        sat_sgVL [Occ=Once] :: GHC.Types.Int
                                        [LclId] =
                                            CCCS GHC.Types.I#! [ipv_sgVJ];
                                      } in  (,) [sat_sgVL sat_sgVM];
                                };
                            1# ->
                                case ># [ww3_sgVF 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww1_sgVD ww3_sgVF] of {
                                        (#,#) ipv_sgVP [Occ=Once] ipv1_sgVQ [Occ=Once] ->
                                            let {
                                              sat_sgVS [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_sgVQ]; } in
                                            let {
                                              sat_sgVR [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_sgVP];
                                            } in  (,) [sat_sgVR sat_sgVS];
                                      };
                                  1# ->
                                      case +# [ww1_sgVD 1#] of sat_sgVT {
                                        __DEFAULT ->
                                            case quotRemInt# [sat_sgVT ww3_sgVF] of {
                                              (#,#) ipv_sgVV [Occ=Once] ipv1_sgVW [Occ=Once] ->
                                                  case +# [ipv1_sgVW ww3_sgVF] of sat_sgVZ {
                                                    __DEFAULT ->
                                                        case -# [sat_sgVZ 1#] of sat_sgW0 {
                                                          __DEFAULT ->
                                                              let {
                                                                sat_sgW1 [Occ=Once] :: GHC.Types.Int
                                                                [LclId] =
                                                                    CCCS GHC.Types.I#! [sat_sgW0];
                                                              } in 
                                                                case -# [ipv_sgVV 1#] of sat_sgVX {
                                                                  __DEFAULT ->
                                                                      let {
                                                                        sat_sgVY [Occ=Once]
                                                                          :: GHC.Types.Int
                                                                        [LclId] =
                                                                            CCCS GHC.Types.I#! [sat_sgVX];
                                                                      } in  (,) [sat_sgVY sat_sgW1];
                                                                };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                      1# ->
                          case <# [ww3_sgVF 0#] of {
                            __DEFAULT ->
                                case <# [ww1_sgVD 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww1_sgVD ww3_sgVF] of {
                                        (#,#) ipv_sgW5 [Occ=Once] ipv1_sgW6 [Occ=Once] ->
                                            let {
                                              sat_sgW8 [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_sgW6]; } in
                                            let {
                                              sat_sgW7 [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv_sgW5];
                                            } in  (,) [sat_sgW7 sat_sgW8];
                                      };
                                  1# ->
                                      case ># [ww3_sgVF 0#] of {
                                        __DEFAULT ->
                                            case quotRemInt# [ww1_sgVD ww3_sgVF] of {
                                              (#,#) ipv_sgWb [Occ=Once] ipv1_sgWc [Occ=Once] ->
                                                  let {
                                                    sat_sgWe [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv1_sgWc]; } in
                                                  let {
                                                    sat_sgWd [Occ=Once] :: GHC.Types.Int
                                                    [LclId] =
                                                        CCCS GHC.Types.I#! [ipv_sgWb];
                                                  } in  (,) [sat_sgWd sat_sgWe];
                                            };
                                        1# ->
                                            case +# [ww1_sgVD 1#] of sat_sgWf {
                                              __DEFAULT ->
                                                  case quotRemInt# [sat_sgWf ww3_sgVF] of {
                                                    (#,#) ipv_sgWh [Occ=Once]
                                                          ipv1_sgWi [Occ=Once] ->
                                                        case +# [ipv1_sgWi ww3_sgVF] of sat_sgWl {
                                                          __DEFAULT ->
                                                              case -# [sat_sgWl 1#] of sat_sgWm {
                                                                __DEFAULT ->
                                                                    let {
                                                                      sat_sgWn [Occ=Once]
                                                                        :: GHC.Types.Int
                                                                      [LclId] =
                                                                          CCCS GHC.Types.I#! [sat_sgWm];
                                                                    } in 
                                                                      case
                                                                          -# [ipv_sgWh 1#]
                                                                      of
                                                                      sat_sgWj
                                                                      { __DEFAULT ->
                                                                            let {
                                                                              sat_sgWk [Occ=Once]
                                                                                :: GHC.Types.Int
                                                                              [LclId] =
                                                                                  CCCS GHC.Types.I#! [sat_sgWj];
                                                                            } in 
                                                                              (,) [sat_sgWk
                                                                                   sat_sgWn];
                                                                      };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            1# ->
                                case -# [ww1_sgVD 1#] of sat_sgWo {
                                  __DEFAULT ->
                                      case quotRemInt# [sat_sgWo ww3_sgVF] of {
                                        (#,#) ipv_sgWq [Occ=Once] ipv1_sgWr [Occ=Once] ->
                                            case +# [ipv1_sgWr ww3_sgVF] of sat_sgWu {
                                              __DEFAULT ->
                                                  case +# [sat_sgWu 1#] of sat_sgWv {
                                                    __DEFAULT ->
                                                        let {
                                                          sat_sgWw [Occ=Once] :: GHC.Types.Int
                                                          [LclId] =
                                                              CCCS GHC.Types.I#! [sat_sgWv];
                                                        } in 
                                                          case -# [ipv_sgWq 1#] of sat_sgWs {
                                                            __DEFAULT ->
                                                                let {
                                                                  sat_sgWt [Occ=Once]
                                                                    :: GHC.Types.Int
                                                                  [LclId] =
                                                                      CCCS GHC.Types.I#! [sat_sgWs];
                                                                } in  (,) [sat_sgWt sat_sgWw];
                                                          };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

GHC.Base.shiftL#
  :: GHC.Prim.Word# -> GHC.Prim.Int# -> GHC.Prim.Word#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_sgWx b_sgWy]
        case >=# [b_sgWy 64#] of {
          __DEFAULT -> uncheckedShiftL# [a_sgWx b_sgWy];
          1# -> 0##;
        };

GHC.Base.shiftRL#
  :: GHC.Prim.Word# -> GHC.Prim.Int# -> GHC.Prim.Word#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_sgWA b_sgWB]
        case >=# [b_sgWB 64#] of {
          __DEFAULT -> uncheckedShiftRL# [a_sgWA b_sgWB];
          1# -> 0##;
        };

GHC.Base.iShiftL#
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_sgWD b_sgWE]
        case >=# [b_sgWE 64#] of {
          __DEFAULT -> uncheckedIShiftL# [a_sgWD b_sgWE];
          1# -> 0#;
        };

GHC.Base.iShiftRA#
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<S,U><S,U>, Unf=OtherCon []] =
    [] \r [a_sgWG b_sgWH]
        case >=# [b_sgWH 64#] of {
          __DEFAULT -> uncheckedIShiftRA# [a_sgWG b_sgWH];
          1# ->
              case <# [a_sgWG 0#] of {
                __DEFAULT -> 0#;
                1# -> -1#;
              };
        };

GHC.Base.iShiftRL#
  :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [a_sgWK b_sgWL]
        case >=# [b_sgWL 64#] of {
          __DEFAULT -> uncheckedIShiftRL# [a_sgWK b_sgWL];
          1# -> 0#;
        };

GHC.Base.build [InlPrag=INLINE[1] (sat-args=1)]
  :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))>,
 Unf=OtherCon []] =
    [] \r [g_sgWN] g_sgWN GHC.Types.: GHC.Types.[];

GHC.Base.$fApplicative[]_$cpure [InlPrag=INLINE (sat-args=1)]
  :: forall a. a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [x_sgWO] : [x_sgWO GHC.Types.[]];

GHC.Base.augment [InlPrag=INLINE[1] (sat-args=2)]
  :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [g_sgWP xs_sgWQ] g_sgWP GHC.Types.: xs_sgWQ;

GHC.Base.++ [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. [a] -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgWR ys_sgWS]
        case ds_sgWR of {
          [] -> ys_sgWS;
          : x_sgWU [Occ=Once] xs_sgWV [Occ=Once] ->
              let {
                sat_sgWW [Occ=Once] :: [a_a42r]
                [LclId] =
                    [ys_sgWS xs_sgWV] \u [] GHC.Base.++ xs_sgWV ys_sgWS;
              } in  : [x_sgWU sat_sgWW];
        };
GHC.Base.foldr [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sgWX z_sgWY eta_sgWZ]
        let {
          go_sgX0 [Occ=LoopBreaker] :: [a_a42N] -> b_a42O
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [k_sgWX z_sgWY go_sgX0] \r [ds_sgX1]
                  case ds_sgX1 of {
                    [] -> z_sgWY;
                    : y_sgX3 [Occ=Once] ys_sgX4 [Occ=Once] ->
                        let {
                          sat_sgX5 [Occ=Once] :: b_a42O
                          [LclId] =
                              [go_sgX0 ys_sgX4] \u [] go_sgX0 ys_sgX4;
                        } in  k_sgWX y_sgX3 sat_sgX5;
                  };
        } in  go_sgX0 eta_sgWZ;
GHC.Base.map [InlPrag=NOINLINE[0], Occ=LoopBreaker]
  :: forall a b. (a -> b) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sgX6 ds1_sgX7]
        case ds1_sgX7 of {
          [] -> [] [];
          : x_sgX9 [Occ=Once] xs_sgXa [Occ=Once] ->
              let {
                sat_sgXc [Occ=Once] :: [b_a42A]
                [LclId] =
                    [ds_sgX6 xs_sgXa] \u [] GHC.Base.map ds_sgX6 xs_sgXa; } in
              let {
                sat_sgXb [Occ=Once] :: b_a42A
                [LclId] =
                    [ds_sgX6 x_sgX9] \u [] ds_sgX6 x_sgX9;
              } in  : [sat_sgXb sat_sgXc];
        };

GHC.Base.$fSemigroupNonEmpty_$c<>
  :: forall a.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,1*U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgXd ds1_sgXe]
        case ds_sgXd of {
          GHC.Base.:| a1_sgXg [Occ=Once] as_sgXh [Occ=Once] ->
              let {
                sat_sgXr [Occ=Once] :: [a_a4Fm]
                [LclId] =
                    [ds1_sgXe as_sgXh] \u []
                        let {
                          sat_sgXp [Occ=Once] :: [a_a4Fm]
                          [LclId] =
                              [ds1_sgXe] \u []
                                  case ds1_sgXe of {
                                    GHC.Base.:| _ [Occ=Dead] bs_sgXo [Occ=Once] -> bs_sgXo;
                                  }; } in
                        let {
                          sat_sgXl [Occ=Once] :: a_a4Fm
                          [LclId] =
                              [ds1_sgXe] \u []
                                  case ds1_sgXe of {
                                    GHC.Base.:| b_sgXj [Occ=Once] _ [Occ=Dead] -> b_sgXj;
                                  }; } in
                        let {
                          sat_sgXq [Occ=Once] :: [a_a4Fm]
                          [LclId] =
                              CCCS :! [sat_sgXl sat_sgXp];
                        } in  GHC.Base.++ as_sgXh sat_sgXq;
              } in  GHC.Base.:| [a1_sgXg sat_sgXr];
        };

GHC.Base.$wpoly_go [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. a -> [a] -> [GHC.Base.NonEmpty a] -> (# a, [a] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sgXs ww1_sgXt w_sgXu]
        case w_sgXu of {
          [] -> (#,#) [ww_sgXs ww1_sgXt];
          : c_sgXw [Occ=Once!] cs_sgXx [Occ=Once] ->
              let {
                sat_sgXO [Occ=Once] :: [a_s6GZ]
                [LclId] =
                    [ww1_sgXt c_sgXw cs_sgXx] \u []
                        let {
                          ds_sgXy [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty a_s6GZ
                          [LclId] =
                              [c_sgXw cs_sgXx] \u []
                                  case c_sgXw of {
                                    GHC.Base.:| ww3_sgXA [Occ=Once] ww4_sgXB [Occ=Once] ->
                                        case GHC.Base.$wpoly_go ww3_sgXA ww4_sgXB cs_sgXx of {
                                          (#,#) ww6_sgXD [Occ=Once] ww7_sgXE [Occ=Once] ->
                                              GHC.Base.:| [ww6_sgXD ww7_sgXE];
                                        };
                                  }; } in
                        let {
                          sat_sgXM [Occ=Once] :: [a_s6GZ]
                          [LclId] =
                              [ds_sgXy] \u []
                                  case ds_sgXy of {
                                    GHC.Base.:| _ [Occ=Dead] bs_sgXL [Occ=Once] -> bs_sgXL;
                                  }; } in
                        let {
                          sat_sgXI [Occ=Once] :: a_s6GZ
                          [LclId] =
                              [ds_sgXy] \u []
                                  case ds_sgXy of {
                                    GHC.Base.:| b_sgXG [Occ=Once] _ [Occ=Dead] -> b_sgXG;
                                  }; } in
                        let {
                          sat_sgXN [Occ=Once] :: [a_s6GZ]
                          [LclId] =
                              CCCS :! [sat_sgXI sat_sgXM];
                        } in  GHC.Base.++ ww1_sgXt sat_sgXN;
              } in  (#,#) [ww_sgXs sat_sgXO];
        };

GHC.Base.$fSemigroupNonEmpty1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.NonEmpty a -> [GHC.Base.NonEmpty a] -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sgXP w1_sgXQ]
        case w_sgXP of {
          GHC.Base.:| ww1_sgXS [Occ=Once] ww2_sgXT [Occ=Once] ->
              case GHC.Base.$wpoly_go ww1_sgXS ww2_sgXT w1_sgXQ of {
                (#,#) ww4_sgXV [Occ=Once] ww5_sgXW [Occ=Once] ->
                    GHC.Base.:| [ww4_sgXV ww5_sgXW];
              };
        };

GHC.Base.$fSemigroupNonEmpty_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (GHC.Base.NonEmpty a) -> GHC.Base.NonEmpty a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U(U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sgXX]
        case ds_sgXX of {
          GHC.Base.:| a1_sgXZ [Occ=Once] as_sgY0 [Occ=Once] ->
              GHC.Base.$fSemigroupNonEmpty1 a1_sgXZ as_sgY0;
        };

GHC.Base.$fSemigroupNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (GHC.Base.NonEmpty a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.$fSemigroupNonEmpty_$c<>
                                         GHC.Base.$fSemigroupNonEmpty_$csconcat
                                         GHC.Base.$fSemigroupNonEmpty_$cstimes];
GHC.Base.$fSemigroupNonEmpty_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sgY1]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_sgY1 GHC.Base.$fSemigroupNonEmpty;

GHC.Base.$fSemigroup[]1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_sgY2 ds_sgY3]
        case ds_sgY3 of {
          [] -> b_sgY2;
          : c_sgY5 [Occ=Once] cs_sgY6 [Occ=Once] ->
              let {
                sat_sgY7 [Occ=Once, Dmd=<L,1*U>] :: [a_a4FL]
                [LclId] =
                    [c_sgY5 cs_sgY6] \s [] GHC.Base.$fSemigroup[]1 c_sgY5 cs_sgY6;
              } in  GHC.Base.++ b_sgY2 sat_sgY7;
        };

GHC.Base.$fSemigroup[]_$csconcat
  :: forall a. GHC.Base.NonEmpty [a] -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sgY8]
        case ds_sgY8 of {
          GHC.Base.:| a1_sgYa [Occ=Once] as_sgYb [Occ=Once] ->
              GHC.Base.$fSemigroup[]1 a1_sgYa as_sgYb;
        };

GHC.Base.mapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> [a] -> m [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgYc eta_sgYd eta1_sgYe]
        let {
          z_sgYf [Occ=OnceL] :: m_a4da [b_a4dc]
          [LclId] =
              [$dMonad_sgYc] \u []
                  GHC.Base.return $dMonad_sgYc GHC.Types.[]; } in
        let {
          go_sgYg [Occ=LoopBreaker] :: [a_a4db] -> m_a4da [b_a4dc]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonad_sgYc eta_sgYd z_sgYf go_sgYg] \r [ds_sgYh]
                  case ds_sgYh of {
                    [] -> z_sgYf;
                    : y_sgYj [Occ=Once] ys_sgYk [Occ=Once] ->
                        let {
                          r_sgYl [Occ=OnceL] :: m_a4da [b_a4dc]
                          [LclId] =
                              [go_sgYg ys_sgYk] \u [] go_sgYg ys_sgYk; } in
                        let {
                          sat_sgYr [Occ=Once] :: b_a4dc -> m_a4da [b_a4dc]
                          [LclId] =
                              [$dMonad_sgYc r_sgYl] \r [x_sgYn]
                                  let {
                                    sat_sgYq [Occ=Once] :: [b_a4dc] -> m_a4da [b_a4dc]
                                    [LclId] =
                                        [$dMonad_sgYc x_sgYn] \r [xs_sgYo]
                                            let {
                                              sat_sgYp [Occ=Once] :: [b_a4dc]
                                              [LclId] =
                                                  CCCS :! [x_sgYn xs_sgYo];
                                            } in  GHC.Base.return $dMonad_sgYc sat_sgYp;
                                  } in  GHC.Base.>>= $dMonad_sgYc r_sgYl sat_sgYq; } in
                        let {
                          sat_sgYm [Occ=Once] :: m_a4da b_a4dc
                          [LclId] =
                              [eta_sgYd y_sgYj] \u [] eta_sgYd y_sgYj;
                        } in  GHC.Base.>>= $dMonad_sgYc sat_sgYm sat_sgYr;
                  };
        } in  go_sgYg eta1_sgYe;

GHC.Base.sequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. GHC.Base.Monad m => [m a] -> m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgYs eta_B1]
        GHC.Base.mapM $dMonad_sgYs GHC.Base.breakpoint eta_B1;

GHC.Base.$dmmconcat :: forall a. GHC.Base.Monoid a => [a] -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgYt eta_sgYu]
        let {
          z_sgYv [Occ=OnceL] :: a_a37Y
          [LclId] =
              [$dMonoid_sgYt] \u [] GHC.Base.mempty $dMonoid_sgYt; } in
        let {
          go_sgYw [Occ=LoopBreaker] :: [a_a37Y] -> a_a37Y
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dMonoid_sgYt z_sgYv go_sgYw] \r [ds_sgYx]
                  case ds_sgYx of {
                    [] -> z_sgYv;
                    : y_sgYz [Occ=Once] ys_sgYA [Occ=Once] ->
                        let {
                          sat_sgYB [Occ=Once] :: a_a37Y
                          [LclId] =
                              [go_sgYw ys_sgYA] \u [] go_sgYw ys_sgYA;
                        } in  GHC.Base.mappend $dMonoid_sgYt y_sgYz sat_sgYB;
                  };
        } in  go_sgYw eta_sgYu;

GHC.Base.$fMonoid(->)_$cmconcat
  :: forall b a. GHC.Base.Monoid b => [a -> b] -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgYC eta_sgYD eta1_sgYE]
        let {
          lvl3_sgYF [Occ=OnceL] :: b_a4zA
          [LclId] =
              [$dMonoid_sgYC] \u [] GHC.Base.mempty $dMonoid_sgYC; } in
        let {
          $dSemigroup_sgYG [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_a4zA
          [LclId] =
              [$dMonoid_sgYC] \u [] GHC.Base.$p1Monoid $dMonoid_sgYC; } in
        let {
          go_sgYH [Occ=LoopBreaker] :: [a_a4zB -> b_a4zA] -> a_a4zB -> b_a4zA
          [LclId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
              sat-only [lvl3_sgYF $dSemigroup_sgYG go_sgYH] \r [ds_sgYI
                                                                eta2_sgYJ]
                  case ds_sgYI of {
                    [] -> lvl3_sgYF;
                    : y_sgYL [Occ=Once!] ys_sgYM [Occ=Once] ->
                        let {
                          sat_sgYO [Occ=Once] :: b_a4zA
                          [LclId] =
                              [go_sgYH eta2_sgYJ ys_sgYM] \u [] go_sgYH ys_sgYM eta2_sgYJ; } in
                        let {
                          sat_sgYN [Occ=Once] :: b_a4zA
                          [LclId] =
                              [eta2_sgYJ y_sgYL] \u [] y_sgYL eta2_sgYJ;
                        } in  GHC.Base.<> $dSemigroup_sgYG sat_sgYN sat_sgYO;
                  };
        } in  go_sgYH eta_sgYD eta1_sgYE;

GHC.Base.$fMonoidIO1
  :: forall a.
     GHC.Base.Monoid a =>
     [GHC.Types.IO a]
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sgYP eta_sgYQ void_0E]
        let {
          $dSemigroup_sgYS [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_X4I9
          [LclId] =
              [$dMonoid_sgYP] \u [] GHC.Base.$p1Monoid $dMonoid_sgYP; } in
        let {
          lvl3_sgYT [Occ=OnceL] :: a_X4I9
          [LclId] =
              [$dMonoid_sgYP] \u [] GHC.Base.mempty $dMonoid_sgYP; } in
        let {
          go_sgYU [Occ=LoopBreaker]
            :: [GHC.Types.IO a_X4I9]
               -> GHC.Prim.State# GHC.Prim.RealWorld
               -> (# GHC.Prim.State# GHC.Prim.RealWorld, a_X4I9 #)
          [LclId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_sgYS lvl3_sgYT go_sgYU] \r [ds_sgYV void_0E]
                  case ds_sgYV of {
                    [] -> Unit# [lvl3_sgYT];
                    : y_sgYY [Occ=Once] ys_sgYZ [Occ=Once] ->
                        case y_sgYY GHC.Prim.void# of {
                          Unit# ipv1_sgZ2 [Occ=Once] ->
                              case go_sgYU ys_sgYZ GHC.Prim.void# of {
                                Unit# ipv3_sgZ5 [Occ=Once] ->
                                    let {
                                      sat_sgZ6 [Occ=Once] :: a_X4I9
                                      [LclId] =
                                          [$dSemigroup_sgYS ipv1_sgZ2 ipv3_sgZ5] \u []
                                              GHC.Base.<> $dSemigroup_sgYS ipv1_sgZ2 ipv3_sgZ5;
                                    } in  Unit# [sat_sgZ6];
                              };
                        };
                  };
        } in  go_sgYU eta_sgYQ GHC.Prim.void#;

GHC.Base.$fMonoidIO [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid a => GHC.Base.Monoid (GHC.Types.IO a)
[GblId[DFunId], Arity=1, Str=<L,U(U(C(C1(U)),A,A),U,A,A)>m] =
    [] \r [$dMonoid_sgZ7]
        let {
          sat_sgZd [Occ=Once] :: [GHC.Types.IO a_X4I7] -> GHC.Types.IO a_X4I7
          [LclId] =
              [$dMonoid_sgZ7] \r [eta_B2 void_0E]
                  GHC.Base.$fMonoidIO1 $dMonoid_sgZ7 eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgZc [Occ=Once]
            :: GHC.Types.IO a_X4I7
               -> GHC.Types.IO a_X4I7 -> GHC.Types.IO a_X4I7
          [LclId] =
              [$dMonoid_sgZ7] \r [eta_B3 eta_B2 void_0E]
                  GHC.Base.$fMonoidIO_$cmappend
                      $dMonoid_sgZ7 eta_B3 eta_B2 GHC.Prim.void#; } in
        let {
          sat_sgZb [Occ=Once] :: GHC.Types.IO a_X4I7
          [LclId] =
              [$dMonoid_sgZ7] \r [void_0E]
                  let {
                    sat_sgZa [Occ=Once] :: a_X4I7
                    [LclId] =
                        [$dMonoid_sgZ7] \u [] GHC.Base.mempty $dMonoid_sgZ7;
                  } in  Unit# [sat_sgZa]; } in
        let {
          sat_sgZ8 [Occ=Once] :: GHC.Base.Semigroup (GHC.Types.IO a_X4I7)
          [LclId] =
              [$dMonoid_sgZ7] \u [] GHC.Base.$fMonoidIO_$cp1Monoid $dMonoid_sgZ7;
        } in  GHC.Base.C:Monoid [sat_sgZ8 sat_sgZb sat_sgZc sat_sgZd];

GHC.Base.$fFunctor[]_$c<$ :: forall a b. a -> [b] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [x_sgZe eta_sgZf]
        let {
          sat_sgZh [Occ=Once] :: b_a4Mt -> a_a4Ms
          [LclId] =
              [x_sgZe] \r [ds_sgZg] x_sgZe;
        } in  GHC.Base.map sat_sgZh eta_sgZf;

GHC.Base.$fFunctorNonEmpty_$c<$
  :: forall a b. a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,1*U(A,1*U)>m,
 Unf=OtherCon []] =
    [] \r [b1_sgZi ds_sgZj]
        let {
          sat_sgZp [Occ=Once] :: [a_a4Hj]
          [LclId] =
              [b1_sgZi ds_sgZj] \u []
                  case ds_sgZj of {
                    GHC.Base.:| _ [Occ=Dead] as_sgZm [Occ=Once] ->
                        let {
                          sat_sgZo [Occ=Once] :: b_a4Hk -> a_a4Hj
                          [LclId] =
                              [b1_sgZi] \r [ds2_sgZn] b1_sgZi;
                        } in  GHC.Base.map sat_sgZo as_sgZm;
                  };
        } in  GHC.Base.:| [b1_sgZi sat_sgZp];

GHC.Base.$fFunctor[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.map
                                       GHC.Base.$fFunctor[]_$c<$];

GHC.Base.$fMonad[]_$c>>= [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a] -> (a -> [b]) -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [xs_sgZq f_sgZr]
        let {
          go_sgZs [Occ=LoopBreaker] :: [a_a4rg] -> [b_a4rh]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_sgZr go_sgZs] \r [ds_sgZt]
                  case ds_sgZt of {
                    [] -> [] [];
                    : y_sgZv [Occ=Once] ys_sgZw [Occ=Once] ->
                        let {
                          sat_sgZy [Occ=Once, Dmd=<L,1*U>] :: [b_a4rh]
                          [LclId] =
                              [go_sgZs ys_sgZw] \s [] go_sgZs ys_sgZw;
                        } in 
                          case f_sgZr y_sgZv of sat_sgZx {
                            __DEFAULT -> GHC.Base.++ sat_sgZx sat_sgZy;
                          };
                  };
        } in  go_sgZs xs_sgZq;

GHC.Base.=<<_$s=<< :: forall a b. (a -> [b]) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sgZz x_sgZA] GHC.Base.$fMonad[]_$c>>= x_sgZA f_sgZz;

GHC.Base.=<<
  :: forall (m :: * -> *) a b.
     GHC.Base.Monad m =>
     (a -> m b) -> m a -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sgZB f_sgZC x_sgZD]
        GHC.Base.>>= $dMonad_sgZB x_sgZD f_sgZC;

poly_go_r7PI :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds_sgZE]
        case ds_sgZE of {
          [] -> [] [];
          : y_sgZG [Occ=Once] ys_sgZH [Occ=Once] ->
              let {
                sat_sgZI [Occ=Once, Dmd=<L,1*U>] :: [a_a4zZ]
                [LclId] =
                    [ys_sgZH] \s [] poly_go_r7PI ys_sgZH;
              } in  GHC.Base.++ y_sgZG sat_sgZI;
        };

GHC.Base.$fMonoid[]_$cmconcat [InlPrag=INLINE (sat-args=1)]
  :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [xss_sgZJ] poly_go_r7PI xss_sgZJ;

GHC.Base.$fApplicative[]_$c<*> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a -> b] -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [fs_sgZK xs_sgZL]
        let {
          go_sgZM [Occ=LoopBreaker] :: [a_a4Ka -> b_a4Kb] -> [b_a4Kb]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [xs_sgZL go_sgZM] \r [ds_sgZN]
                  case ds_sgZN of {
                    [] -> [] [];
                    : y_sgZP [Occ=OnceL!] ys_sgZQ [Occ=Once] ->
                        let {
                          z_sgZR [Occ=OnceL] :: [b_a4Kb]
                          [LclId] =
                              [go_sgZM ys_sgZQ] \u [] go_sgZM ys_sgZQ; } in
                        let {
                          go1_sgZS [Occ=LoopBreaker] :: [a_a4Ka] -> [b_a4Kb]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [y_sgZP z_sgZR go1_sgZS] \r [ds1_sgZT]
                                  case ds1_sgZT of {
                                    [] -> z_sgZR;
                                    : y1_sgZV [Occ=Once] ys1_sgZW [Occ=Once] ->
                                        let {
                                          sat_sgZY [Occ=Once] :: [b_a4Kb]
                                          [LclId] =
                                              [go1_sgZS ys1_sgZW] \u [] go1_sgZS ys1_sgZW; } in
                                        let {
                                          sat_sgZX [Occ=Once] :: b_a4Kb
                                          [LclId] =
                                              [y_sgZP y1_sgZV] \u [] y_sgZP y1_sgZV;
                                        } in  : [sat_sgZX sat_sgZY];
                                  };
                        } in  go1_sgZS xs_sgZL;
                  };
        } in  go_sgZM fs_sgZK;

GHC.Base.$fApplicative[]_$cliftA2 [InlPrag=INLINE (sat-args=3)]
  :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sgZZ xs_sh00 ys_sh01]
        let {
          go_sh02 [Occ=LoopBreaker] :: [a_a4Ki] -> [c_a4Kk]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_sgZZ ys_sh01 go_sh02] \r [ds_sh03]
                  case ds_sh03 of {
                    [] -> [] [];
                    : y_sh05 [Occ=OnceL] ys1_sh06 [Occ=Once] ->
                        let {
                          z_sh07 [Occ=OnceL] :: [c_a4Kk]
                          [LclId] =
                              [go_sh02 ys1_sh06] \u [] go_sh02 ys1_sh06; } in
                        let {
                          go1_sh08 [Occ=LoopBreaker] :: [b_a4Kj] -> [c_a4Kk]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                              sat-only [f_sgZZ y_sh05 z_sh07 go1_sh08] \r [ds1_sh09]
                                  case ds1_sh09 of {
                                    [] -> z_sh07;
                                    : y1_sh0b [Occ=Once] ys2_sh0c [Occ=Once] ->
                                        let {
                                          sat_sh0e [Occ=Once] :: [c_a4Kk]
                                          [LclId] =
                                              [go1_sh08 ys2_sh0c] \u [] go1_sh08 ys2_sh0c; } in
                                        let {
                                          sat_sh0d [Occ=Once] :: c_a4Kk
                                          [LclId] =
                                              [f_sgZZ y_sh05 y1_sh0b] \u [] f_sgZZ y_sh05 y1_sh0b;
                                        } in  : [sat_sh0d sat_sh0e];
                                  };
                        } in  go1_sh08 ys_sh01;
                  };
        } in  go_sh02 xs_sh00;

GHC.Base.$fApplicative[]_$c<* :: forall a b. [a] -> [b] -> [a]
[GblId, Arity=2, Caf=NoCafRefs, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fApplicative[]_$cliftA2 GHC.Base.const eta_B2 eta_B1;

GHC.Base.$fApplicative[]_$c*> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a] -> [b] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [xs_sh0f ys_sh0g]
        let {
          go_sh0h [Occ=LoopBreaker] :: [a_a4Kr] -> [b_a4Ks]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [ys_sh0g go_sh0h] \r [ds_sh0i]
                  case ds_sh0i of {
                    [] -> [] [];
                    : _ [Occ=Dead] ys1_sh0l [Occ=Once] ->
                        let {
                          sat_sh0m [Occ=Once, Dmd=<L,1*U>] :: [b_a4Ks]
                          [LclId] =
                              [go_sh0h ys1_sh0l] \s [] go_sh0h ys1_sh0l;
                        } in  GHC.Base.++ ys_sh0g sat_sh0m;
                  };
        } in  go_sh0h xs_sh0f;

GHC.Base.$fApplicative[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctor[]
                                           GHC.Base.$fApplicative[]_$cpure
                                           GHC.Base.$fApplicative[]_$c<*>
                                           GHC.Base.$fApplicative[]_$cliftA2
                                           GHC.Base.$fApplicative[]_$c*>
                                           GHC.Base.$fApplicative[]_$c<*];

GHC.Base.$fFunctorNonEmpty_$cfmap
  :: forall a b.
     (a -> b) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sh0n ds_sh0o]
        let {
          sat_sh0x [Occ=Once] :: [b_a4H8]
          [LclId] =
              [f_sh0n ds_sh0o] \u []
                  case ds_sh0o of {
                    GHC.Base.:| _ [Occ=Dead] as_sh0w [Occ=Once] ->
                        GHC.Base.map f_sh0n as_sh0w;
                  }; } in
        let {
          sat_sh0t [Occ=Once] :: b_a4H8
          [LclId] =
              [f_sh0n ds_sh0o] \u []
                  let {
                    sat_sh0s [Occ=Once] :: a_a4H7
                    [LclId] =
                        [ds_sh0o] \u []
                            case ds_sh0o of {
                              GHC.Base.:| a1_sh0q [Occ=Once] _ [Occ=Dead] -> a1_sh0q;
                            };
                  } in  f_sh0n sat_sh0s;
        } in  GHC.Base.:| [sat_sh0t sat_sh0x];

GHC.Base.$fFunctorNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctorNonEmpty_$cfmap
                                       GHC.Base.$fFunctorNonEmpty_$c<$];

GHC.Base.$fAlternative[]1 :: forall a. [[a]]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Types.[] GHC.Types.[]];

GHC.Base.$fAlternative[]_$csome :: forall a. [a] -> [[a]]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sh0y]
        let {
          some_v_sh0z [Occ=LoopBreaker] :: [[a_a4Ik]]
          [LclId] =
              [v_sh0y some_v_sh0z] \u []
                  let {
                    ys_sh0A [Occ=OnceL] :: [[a_a4Ik]]
                    [LclId] =
                        [some_v_sh0z] \u []
                            GHC.Base.++ some_v_sh0z GHC.Base.$fAlternative[]1; } in
                  let {
                    go_sh0B [Occ=LoopBreaker] :: [a_a4Ik] -> [[a_a4Ik]]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                        sat-only [ys_sh0A go_sh0B] \r [ds_sh0C]
                            case ds_sh0C of {
                              [] -> [] [];
                              : y_sh0E [Occ=OnceL] ys1_sh0F [Occ=Once] ->
                                  let {
                                    z_sh0G [Occ=OnceL] :: [[a_a4Ik]]
                                    [LclId] =
                                        [go_sh0B ys1_sh0F] \u [] go_sh0B ys1_sh0F; } in
                                  let {
                                    go1_sh0H [Occ=LoopBreaker] :: [[a_a4Ik]] -> [[a_a4Ik]]
                                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                        sat-only [y_sh0E z_sh0G go1_sh0H] \r [ds1_sh0I]
                                            case ds1_sh0I of {
                                              [] -> z_sh0G;
                                              : y1_sh0K [Occ=Once] ys2_sh0L [Occ=Once] ->
                                                  let {
                                                    sat_sh0N [Occ=Once] :: [[a_a4Ik]]
                                                    [LclId] =
                                                        [go1_sh0H ys2_sh0L] \u []
                                                            go1_sh0H ys2_sh0L; } in
                                                  let {
                                                    sat_sh0M [Occ=Once] :: [a_a4Ik]
                                                    [LclId] =
                                                        CCCS :! [y_sh0E y1_sh0K];
                                                  } in  : [sat_sh0M sat_sh0N];
                                            };
                                  } in  go1_sh0H ys_sh0A;
                            };
                  } in  go_sh0B v_sh0y;
        } in  some_v_sh0z;

GHC.Base.$fAlternative[]_$cmany :: forall a. [a] -> [[a]]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,U>, Unf=OtherCon []] =
    [] \r [v_sh0O]
        let {
          many_v_sh0P [Occ=LoopBreaker] :: [[a_a4Is]]
          [LclId] =
              [v_sh0O many_v_sh0P] \u []
                  let {
                    go_sh0Q [Occ=LoopBreaker] :: [a_a4Is] -> [[a_a4Is]]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                        sat-only [many_v_sh0P go_sh0Q] \r [ds_sh0R]
                            case ds_sh0R of {
                              [] -> [] [];
                              : y_sh0T [Occ=OnceL] ys_sh0U [Occ=Once] ->
                                  let {
                                    z_sh0V [Occ=OnceL] :: [[a_a4Is]]
                                    [LclId] =
                                        [go_sh0Q ys_sh0U] \u [] go_sh0Q ys_sh0U; } in
                                  let {
                                    go1_sh0W [Occ=LoopBreaker] :: [[a_a4Is]] -> [[a_a4Is]]
                                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                        sat-only [y_sh0T z_sh0V go1_sh0W] \r [ds1_sh0X]
                                            case ds1_sh0X of {
                                              [] -> z_sh0V;
                                              : y1_sh0Z [Occ=Once] ys1_sh10 [Occ=Once] ->
                                                  let {
                                                    sat_sh12 [Occ=Once] :: [[a_a4Is]]
                                                    [LclId] =
                                                        [go1_sh0W ys1_sh10] \u []
                                                            go1_sh0W ys1_sh10; } in
                                                  let {
                                                    sat_sh11 [Occ=Once] :: [a_a4Is]
                                                    [LclId] =
                                                        CCCS :! [y_sh0T y1_sh0Z];
                                                  } in  : [sat_sh11 sat_sh12];
                                            };
                                  } in  go1_sh0W many_v_sh0P;
                            };
                  } in 
                    case go_sh0Q v_sh0O of sat_sh13 {
                      __DEFAULT -> GHC.Base.++ sat_sh13 GHC.Base.$fAlternative[]1;
                    };
        } in  many_v_sh0P;

GHC.Base.$fAlternative[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [GHC.Base.$fApplicative[]
                                           GHC.Types.[]
                                           GHC.Base.++
                                           GHC.Base.$fAlternative[]_$csome
                                           GHC.Base.$fAlternative[]_$cmany];

GHC.Base.$w$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> (a -> GHC.Base.NonEmpty b) -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,C(U(1*U,1*U))>,
 Unf=OtherCon []] =
    [] \r [w_sh14 w1_sh15]
        let {
          ds_sh16 [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty b_s6HN
          [LclId] =
              [w_sh14 w1_sh15] \u []
                  let {
                    sat_sh1a [Occ=Once] :: a_s6HM
                    [LclId] =
                        [w_sh14] \u []
                            case w_sh14 of {
                              GHC.Base.:| a1_sh18 [Occ=Once] _ [Occ=Dead] -> a1_sh18;
                            };
                  } in  w1_sh15 sat_sh1a; } in
        let {
          sat_sh1C [Occ=Once] :: [b_s6HN]
          [LclId] =
              [w_sh14 w1_sh15 ds_sh16] \u []
                  case ds_sh16 of {
                    GHC.Base.:| _ [Occ=Dead] bs_sh1h [Occ=Once] ->
                        let {
                          sat_sh1B [Occ=Once, Dmd=<L,1*U>] :: [b_s6HN]
                          [LclId] =
                              [w_sh14 w1_sh15] \s []
                                  case w_sh14 of {
                                    GHC.Base.:| _ [Occ=Dead] as_sh1k [Occ=Once] ->
                                        let {
                                          go_sh1l [Occ=LoopBreaker] :: [a_s6HM] -> [b_s6HN]
                                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                              sat-only [w1_sh15 go_sh1l] \r [ds1_sh1m]
                                                  case ds1_sh1m of {
                                                    [] -> [] [];
                                                    : y_sh1o [Occ=Once] ys_sh1p [Occ=Once] ->
                                                        let {
                                                          ds2_sh1q [Dmd=<L,U(1*U,1*U)>]
                                                            :: GHC.Base.NonEmpty b_s6HN
                                                          [LclId] =
                                                              [w1_sh15 y_sh1o] \u []
                                                                  w1_sh15 y_sh1o; } in
                                                        let {
                                                          sat_sh1A [Occ=Once, Dmd=<L,1*U>]
                                                            :: [b_s6HN]
                                                          [LclId] =
                                                              [go_sh1l ys_sh1p] \s []
                                                                  go_sh1l ys_sh1p; } in
                                                        let {
                                                          sat_sh1y [Occ=Once] :: [b_s6HN]
                                                          [LclId] =
                                                              [ds2_sh1q] \u []
                                                                  case ds2_sh1q of {
                                                                    GHC.Base.:| _ [Occ=Dead]
                                                                                cs_sh1x [Occ=Once] ->
                                                                        cs_sh1x;
                                                                  }; } in
                                                        let {
                                                          sat_sh1u [Occ=Once] :: b_s6HN
                                                          [LclId] =
                                                              [ds2_sh1q] \u []
                                                                  case ds2_sh1q of {
                                                                    GHC.Base.:| c_sh1s [Occ=Once]
                                                                                _ [Occ=Dead] ->
                                                                        c_sh1s;
                                                                  }; } in
                                                        let {
                                                          sat_sh1z [Occ=Once] :: [b_s6HN]
                                                          [LclId] =
                                                              CCCS :! [sat_sh1u sat_sh1y];
                                                        } in  GHC.Base.++ sat_sh1z sat_sh1A;
                                                  };
                                        } in  go_sh1l as_sh1k;
                                  };
                        } in  GHC.Base.++ bs_sh1h sat_sh1B;
                  }; } in
        let {
          sat_sh1e [Occ=Once] :: b_s6HN
          [LclId] =
              [ds_sh16] \u []
                  case ds_sh16 of {
                    GHC.Base.:| b1_sh1c [Occ=Once] _ [Occ=Dead] -> b1_sh1c;
                  };
        } in  (#,#) [sat_sh1e sat_sh1C];

GHC.Base.$fMonadNonEmpty_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a
     -> (a -> GHC.Base.NonEmpty b) -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,C(U(1*U,1*U))>m,
 Unf=OtherCon []] =
    [] \r [w_sh1D w1_sh1E]
        case GHC.Base.$w$c>>= w_sh1D w1_sh1E of {
          (#,#) ww1_sh1G [Occ=Once] ww2_sh1H [Occ=Once] ->
              GHC.Base.:| [ww1_sh1G ww2_sh1H];
        };

GHC.Base.$fMonadNonEmpty_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [eta_sh1I eta1_sh1J]
        let {
          sat_sh1L [Occ=Once] :: a_a4sH -> GHC.Base.NonEmpty b_a4sI
          [LclId] =
              [eta1_sh1J] \r [ds_sh1K] eta1_sh1J;
        } in 
          case GHC.Base.$w$c>>= eta_sh1I sat_sh1L of {
            (#,#) ww1_sh1N [Occ=Once] ww2_sh1O [Occ=Once] ->
                GHC.Base.:| [ww1_sh1N ww2_sh1O];
          };

GHC.Base.<**>1 :: forall a b. a -> (a -> b) -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [a1_sh1P f_sh1Q] f_sh1Q a1_sh1P;

GHC.Base.<**>
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     f a -> f (a -> b) -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sh1R]
        GHC.Base.liftA2 $dApplicative_sh1R GHC.Base.<**>1;

GHC.Base.$dmliftA2
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     forall a b c. (a -> b -> c) -> f a -> f b -> f c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLL),U(1*U(1*C1(C1(U)),A),A,1*C1(U),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_sh1S eta_sh1T eta1_sh1U]
        let {
          sat_sh1W [Occ=Once] :: f_a37E (b_a4iN -> c_a4iO)
          [LclId] =
              [$dApplicative_sh1S eta_sh1T eta1_sh1U] \u []
                  case GHC.Base.$p1Applicative $dApplicative_sh1S of sat_sh1V {
                    __DEFAULT -> GHC.Base.fmap sat_sh1V eta_sh1T eta1_sh1U;
                  };
        } in  GHC.Base.<*> $dApplicative_sh1S sat_sh1W;

GHC.Base.$dmsome
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sh1X eta_sh1Y]
        let {
          some_v_sh1Z [Occ=LoopBreaker] :: f_a37j [a_a4ju]
          [LclId] =
              [$dAlternative_sh1X eta_sh1Y some_v_sh1Z] \u []
                  case
                      GHC.Base.$p1Alternative $dAlternative_sh1X
                  of
                  $dApplicative_sh20 [Dmd=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                  { __DEFAULT ->
                        let {
                          sat_sh22 [Occ=Once] :: f_a37j [a_a4ju]
                          [LclId] =
                              [$dAlternative_sh1X some_v_sh1Z $dApplicative_sh20] \u []
                                  let {
                                    sat_sh21 [Occ=Once] :: f_a37j [a_a4ju]
                                    [LclId] =
                                        [$dApplicative_sh20] \u []
                                            GHC.Base.pure $dApplicative_sh20 GHC.Types.[];
                                  } in  GHC.Base.<|> $dAlternative_sh1X some_v_sh1Z sat_sh21;
                        } in 
                          GHC.Base.liftA2 $dApplicative_sh20 GHC.Types.: eta_sh1Y sat_sh22;
                  };
        } in  some_v_sh1Z;

GHC.Base.$dmmany
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     forall a. f a -> f [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sh23 eta_sh24]
        let {
          many_v_sh25 [Occ=LoopBreaker] :: f_a37j [a_a4jX]
          [LclId] =
              [$dAlternative_sh23 eta_sh24 many_v_sh25] \u []
                  let {
                    $dApplicative_sh26 [Dmd=<L,U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                      :: GHC.Base.Applicative f_a37j
                    [LclId] =
                        [$dAlternative_sh23] \u []
                            GHC.Base.$p1Alternative $dAlternative_sh23; } in
                  let {
                    sat_sh28 [Occ=Once] :: f_a37j [a_a4jX]
                    [LclId] =
                        [$dApplicative_sh26] \u []
                            GHC.Base.pure $dApplicative_sh26 GHC.Types.[]; } in
                  let {
                    sat_sh27 [Occ=Once] :: f_a37j [a_a4jX]
                    [LclId] =
                        [eta_sh24 many_v_sh25 $dApplicative_sh26] \u []
                            GHC.Base.liftA2
                                $dApplicative_sh26 GHC.Types.: eta_sh24 many_v_sh25;
                  } in  GHC.Base.<|> $dAlternative_sh23 sat_sh27 sat_sh28;
        } in  many_v_sh25;

GHC.Base.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Base.Semigroup b =>
     (a -> b) -> [a -> b] -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh29 ww_sh2a ww1_sh2b]
        let {
          go_sh2c [Occ=LoopBreaker]
            :: (a_s6HX -> b_s6HW) -> [a_s6HX -> b_s6HW] -> a_s6HX -> b_s6HW
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sh29 go_sh2c] \r [b1_sh2d ds_sh2e]
                  case ds_sh2e of {
                    [] -> b1_sh2d;
                    : c_sh2g [Occ=Once] cs_sh2h [Occ=Once] ->
                        let {
                          g_sh2i [Occ=OnceL!, Dmd=<L,C(U)>] :: a_s6HX -> b_s6HW
                          [LclId] =
                              [go_sh2c c_sh2g cs_sh2h] \u [] go_sh2c c_sh2g cs_sh2h; } in
                        let {
                          sat_sh2m [Occ=OnceT[0]] :: a_s6HX -> b_s6HW
                          [LclId] =
                              [w_sh29 b1_sh2d g_sh2i] \r [x_sh2j]
                                  let {
                                    sat_sh2l [Occ=Once] :: b_s6HW
                                    [LclId] =
                                        [g_sh2i x_sh2j] \u [] g_sh2i x_sh2j; } in
                                  let {
                                    sat_sh2k [Occ=Once] :: b_s6HW
                                    [LclId] =
                                        [b1_sh2d x_sh2j] \u [] b1_sh2d x_sh2j;
                                  } in  GHC.Base.<> w_sh29 sat_sh2k sat_sh2l;
                        } in  sat_sh2m;
                  };
        } in  go_sh2c ww_sh2a ww1_sh2b;

GHC.Base.$fSemigroup(->)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Base.Semigroup b =>
     GHC.Base.NonEmpty (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh2n w1_sh2o]
        case w1_sh2o of {
          GHC.Base.:| ww1_sh2q [Occ=Once] ww2_sh2r [Occ=Once] ->
              GHC.Base.$w$csconcat3 w_sh2n ww1_sh2q ww2_sh2r;
        };

GHC.Base.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     a -> b -> [(a, b)] -> (# a, b #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh2s w1_sh2t ww_sh2u ww1_sh2v ww2_sh2w]
        let {
          $wgo_sh2x [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: a_s6Ih -> b_s6Ii -> [(a_s6Ih, b_s6Ii)] -> (# a_s6Ih, b_s6Ii #)
          [LclId, Arity=3, Str=<L,U><L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sh2s w1_sh2t $wgo_sh2x] \r [ww3_sh2y ww4_sh2z w2_sh2A]
                  case w2_sh2A of {
                    [] -> (#,#) [ww3_sh2y ww4_sh2z];
                    : c_sh2C [Occ=Once!] cs_sh2D [Occ=Once] ->
                        case c_sh2C of {
                          (,) ww6_sh2F [Occ=Once] ww7_sh2G [Occ=Once] ->
                              case $wgo_sh2x ww6_sh2F ww7_sh2G cs_sh2D of {
                                (#,#) ww9_sh2I [Occ=Once] ww10_sh2J [Occ=Once] ->
                                    let {
                                      sat_sh2L [Occ=Once] :: b_s6Ii
                                      [LclId] =
                                          [w1_sh2t ww4_sh2z ww10_sh2J] \u []
                                              GHC.Base.<> w1_sh2t ww4_sh2z ww10_sh2J; } in
                                    let {
                                      sat_sh2K [Occ=Once] :: a_s6Ih
                                      [LclId] =
                                          [w_sh2s ww3_sh2y ww9_sh2I] \u []
                                              GHC.Base.<> w_sh2s ww3_sh2y ww9_sh2I;
                                    } in  (#,#) [sat_sh2K sat_sh2L];
                              };
                        };
                  };
        } in  $wgo_sh2x ww_sh2u ww1_sh2v ww2_sh2w;

GHC.Base.$fSemigroup(,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     GHC.Base.NonEmpty (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sh2M w1_sh2N w2_sh2O]
        case w2_sh2O of {
          GHC.Base.:| ww1_sh2Q [Occ=Once!] ww2_sh2R [Occ=Once] ->
              case ww1_sh2Q of {
                (,) ww4_sh2T [Occ=Once] ww5_sh2U [Occ=Once] ->
                    case
                        GHC.Base.$w$csconcat w_sh2M w1_sh2N ww4_sh2T ww5_sh2U ww2_sh2R
                    of
                    { (#,#) ww7_sh2W [Occ=Once] ww8_sh2X [Occ=Once] ->
                          (,) [ww7_sh2W ww8_sh2X];
                    };
              };
        };

GHC.Base.$dmsconcat
  :: forall a. GHC.Base.Semigroup a => GHC.Base.NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sh2Y ds_sh2Z]
        case ds_sh2Z of {
          GHC.Base.:| a1_sh31 [Occ=Once] as_sh32 [Occ=Once] ->
              let {
                go_sh33 [Occ=LoopBreaker] :: a_a37Z -> [a_a37Z] -> a_a37Z
                [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
                    sat-only [$dSemigroup_sh2Y go_sh33] \r [b_sh34 ds1_sh35]
                        case ds1_sh35 of {
                          [] -> b_sh34;
                          : c_sh37 [Occ=Once] cs_sh38 [Occ=Once] ->
                              let {
                                sat_sh39 [Occ=Once] :: a_a37Z
                                [LclId] =
                                    [go_sh33 c_sh37 cs_sh38] \u [] go_sh33 c_sh37 cs_sh38;
                              } in  GHC.Base.<> $dSemigroup_sh2Y b_sh34 sat_sh39;
                        };
              } in  go_sh33 a1_sh31 as_sh32;
        };

GHC.Base.$dmstimes
  :: forall a.
     GHC.Base.Semigroup a =>
     forall b. GHC.Real.Integral b => b -> a -> a
[GblId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
    [] \r [$dSemigroup_sh3a $dIntegral_sh3b]
        Data.Semigroup.Internal.stimesDefault
            $dIntegral_sh3b $dSemigroup_sh3a;

GHC.Base.$dmmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Base.Monoid a => a -> a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(SLL)LLL),1*U(1*U(1*U,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh3c]
        case GHC.Base.$p1Monoid $dMonoid_sh3c of sat_sh3d {
          __DEFAULT -> GHC.Base.<> sat_sh3d;
        };

GHC.Base.$dm>> [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a b. m a -> m b -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sh3e m1_sh3f k_sh3g]
        let {
          sat_sh3i [Occ=Once] :: a_a4lv -> m_a37u b_a4lw
          [LclId] =
              [k_sh3g] \r [ds_sh3h] k_sh3g;
        } in  GHC.Base.>>= $dMonad_sh3e m1_sh3f sat_sh3i;

GHC.Base.$dmreturn
  :: forall (m :: * -> *). GHC.Base.Monad m => forall a. a -> m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LSLLLL)LLLL),1*U(1*U(A,1*U,A,A,A,A),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sh3j]
        case GHC.Base.$p1Monad $dMonad_sh3j of sat_sh3k {
          __DEFAULT -> GHC.Base.pure sat_sh3k;
        };

GHC.Base.$dmfail
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     forall a. GHC.Base.String -> m a
[GblId, Arity=2, Str=<B,A><B,U>x, Unf=OtherCon []] =
    [] \r [$dMonad_sh3l s_sh3m] GHC.Err.errorWithoutStackTrace s_sh3m;

GHC.Base.$dmmzero
  :: forall (m :: * -> *). GHC.Base.MonadPlus m => forall a. m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LSLLL)LLL),1*U(1*U(A,1*U,A,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sh3n]
        case GHC.Base.$p1MonadPlus $dMonadPlus_sh3n of sat_sh3o {
          __DEFAULT -> GHC.Base.empty sat_sh3o;
        };

GHC.Base.$dmmplus
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     forall a. m a -> m a -> m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LLSLL)LLL),1*U(1*U(A,A,1*U,A,A),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_sh3p]
        case GHC.Base.$p1MonadPlus $dMonadPlus_sh3p of sat_sh3q {
          __DEFAULT -> GHC.Base.<|> sat_sh3q;
        };

GHC.Base.$fEqMaybe_$c==
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sh3r ds_sh3s ds1_sh3t]
        case ds_sh3s of {
          GHC.Base.Nothing ->
              case ds1_sh3t of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just a1_sh3x [Occ=Once] ->
              case ds1_sh3t of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just b1_sh3z [Occ=Once] ->
                    GHC.Classes.== $dEq_sh3r a1_sh3x b1_sh3z;
              };
        };

GHC.Base.$fEqMaybe_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sh3A eta_sh3B eta1_sh3C]
        case eta_sh3B of {
          GHC.Base.Nothing ->
              case eta1_sh3C of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.True [];
              };
          GHC.Base.Just a1_sh3G [Occ=Once] ->
              case eta1_sh3C of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just b1_sh3I [Occ=Once] ->
                    case GHC.Classes.== $dEq_sh3A a1_sh3G b1_sh3I of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

GHC.Base.$fEqMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Base.Maybe a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sh3K]
        let {
          sat_sh3M [Occ=Once]
            :: GHC.Base.Maybe a_a4m9 -> GHC.Base.Maybe a_a4m9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_sh3K] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_sh3K eta_B2 eta_B1; } in
        let {
          sat_sh3L [Occ=Once]
            :: GHC.Base.Maybe a_a4m9 -> GHC.Base.Maybe a_a4m9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_sh3K] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_sh3K eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sh3L sat_sh3M];

GHC.Base.$fOrdMaybe_$cp1Ord
  :: forall a. GHC.Classes.Ord a => GHC.Classes.Eq (GHC.Base.Maybe a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh3N]
        let {
          sat_sh3O [Occ=Once, Dmd=<L,U(C(C1(U)),A)>] :: GHC.Classes.Eq a_a4mo
          [LclId] =
              [$dOrd_sh3N] \u [] GHC.Classes.$p1Ord $dOrd_sh3N;
        } in  GHC.Base.$fEqMaybe sat_sh3O;

GHC.Base.$fOrdMaybe_$ccompare
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh3P a1_sh3Q b_sh3R]
        case a1_sh3Q of {
          GHC.Base.Nothing ->
              case b_sh3R of {
                GHC.Base.Nothing -> GHC.Types.EQ [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.LT [];
              };
          GHC.Base.Just a2_sh3V [Occ=Once] ->
              case b_sh3R of {
                GHC.Base.Nothing -> GHC.Types.GT [];
                GHC.Base.Just b1_sh3X [Occ=Once] ->
                    GHC.Classes.compare $dOrd_sh3P a2_sh3V b1_sh3X;
              };
        };

GHC.Base.$fOrdMaybe_$c<
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh3Y a1_sh3Z b_sh40]
        case a1_sh3Z of {
          GHC.Base.Nothing ->
              case b_sh40 of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.True [];
              };
          GHC.Base.Just a2_sh44 [Occ=Once] ->
              case b_sh40 of {
                GHC.Base.Nothing -> GHC.Types.False [];
                GHC.Base.Just b1_sh46 [Occ=Once] ->
                    GHC.Classes.< $dOrd_sh3Y a2_sh44 b1_sh46;
              };
        };

GHC.Base.$fOrdMaybe_$c<=
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh47 a1_sh48 b_sh49]
        case b_sh49 of {
          GHC.Base.Nothing ->
              case a1_sh48 of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just a2_sh4d [Occ=Once] ->
              case a1_sh48 of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just b1_sh4f [Occ=Once] ->
                    case GHC.Classes.< $dOrd_sh47 a2_sh4d b1_sh4f of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

GHC.Base.$fOrdMaybe_$cmax
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh4h x_sh4i y_sh4j]
        case y_sh4j of wild_sh4k {
          GHC.Base.Nothing -> x_sh4i;
          GHC.Base.Just a1_sh4l [Occ=Once] ->
              case x_sh4i of wild1_sh4m {
                GHC.Base.Nothing -> wild_sh4k;
                GHC.Base.Just b1_sh4n [Occ=Once] ->
                    case GHC.Classes.< $dOrd_sh4h a1_sh4l b1_sh4n of {
                      GHC.Types.False -> wild_sh4k;
                      GHC.Types.True -> wild1_sh4m;
                    };
              };
        };

GHC.Base.$fOrdMaybe_$cmin
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh4p x_sh4q y_sh4r]
        case y_sh4r of wild_sh4s {
          GHC.Base.Nothing ->
              case x_sh4q of { __DEFAULT -> GHC.Base.Nothing []; };
          GHC.Base.Just a1_sh4u [Occ=Once] ->
              case x_sh4q of wild1_sh4v {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just b1_sh4w [Occ=Once] ->
                    case GHC.Classes.< $dOrd_sh4p a1_sh4u b1_sh4w of {
                      GHC.Types.False -> wild1_sh4v;
                      GHC.Types.True -> wild_sh4s;
                    };
              };
        };

GHC.Base.$fOrdMaybe_$c>=
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh4y a1_sh4z b_sh4A]
        case a1_sh4z of {
          GHC.Base.Nothing ->
              case b_sh4A of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just _ [Occ=Dead] -> GHC.Types.False [];
              };
          GHC.Base.Just a2_sh4E [Occ=Once] ->
              case b_sh4A of {
                GHC.Base.Nothing -> GHC.Types.True [];
                GHC.Base.Just b1_sh4G [Occ=Once] ->
                    case GHC.Classes.< $dOrd_sh4y a2_sh4E b1_sh4G of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True -> GHC.Types.False [];
                    };
              };
        };

GHC.Base.$fOrdMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (GHC.Base.Maybe a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_sh4I]
        let {
          sat_sh4S [Occ=Once]
            :: GHC.Base.Maybe a_a4mo
               -> GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo
          [LclId] =
              [$dOrd_sh4I] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_sh4I eta_B2 eta_B1; } in
        let {
          sat_sh4R [Occ=Once]
            :: GHC.Base.Maybe a_a4mo
               -> GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo
          [LclId] =
              [$dOrd_sh4I] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_sh4I eta_B2 eta_B1; } in
        let {
          sat_sh4Q [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh4I] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_sh4I eta_B2 eta_B1; } in
        let {
          sat_sh4P [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh4I] \r [a1_sh4N b_sh4O]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_sh4I b_sh4O a1_sh4N; } in
        let {
          sat_sh4M [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh4I] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_sh4I eta_B2 eta_B1; } in
        let {
          sat_sh4L [Occ=Once]
            :: GHC.Base.Maybe a_a4mo -> GHC.Base.Maybe a_a4mo -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh4I] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_sh4I eta_B2 eta_B1; } in
        let {
          sat_sh4K [Occ=Once]
            :: GHC.Base.Maybe a_a4mo
               -> GHC.Base.Maybe a_a4mo -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sh4I] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_sh4I eta_B2 eta_B1; } in
        let {
          sat_sh4J [Occ=Once] :: GHC.Classes.Eq (GHC.Base.Maybe a_a4mo)
          [LclId] =
              [$dOrd_sh4I] \u [] GHC.Base.$fOrdMaybe_$cp1Ord $dOrd_sh4I;
        } in 
          GHC.Classes.C:Ord [sat_sh4J
                             sat_sh4K
                             sat_sh4L
                             sat_sh4M
                             sat_sh4P
                             sat_sh4Q
                             sat_sh4R
                             sat_sh4S];

GHC.Base.$fEqNonEmpty_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sh4T eta_sh4U eta1_sh4V]
        case eta_sh4U of {
          GHC.Base.:| a1_sh4X [Occ=Once] a2_sh4Y [Occ=Once] ->
              case eta1_sh4V of {
                GHC.Base.:| b1_sh50 [Occ=Once] b2_sh51 [Occ=Once] ->
                    case GHC.Classes.== $dEq_sh4T a1_sh4X b1_sh50 of {
                      GHC.Types.False -> GHC.Types.True [];
                      GHC.Types.True ->
                          case GHC.Classes.$fEq[]_$c== $dEq_sh4T a2_sh4Y b2_sh51 of {
                            GHC.Types.False -> GHC.Types.True [];
                            GHC.Types.True -> GHC.Types.False [];
                          };
                    };
              };
        };

GHC.Base.$w$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh54 ww_sh55 ww1_sh56 ww2_sh57 ww3_sh58]
        case GHC.Classes.== w_sh54 ww_sh55 ww2_sh57 of {
          GHC.Types.False -> GHC.Types.False [];
          GHC.Types.True -> GHC.Classes.$fEq[]_$c== w_sh54 ww1_sh56 ww3_sh58;
        };

GHC.Base.$fEqNonEmpty_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh5a w1_sh5b w2_sh5c]
        case w1_sh5b of {
          GHC.Base.:| ww1_sh5e [Occ=Once] ww2_sh5f [Occ=Once] ->
              case w2_sh5c of {
                GHC.Base.:| ww4_sh5h [Occ=Once] ww5_sh5i [Occ=Once] ->
                    GHC.Base.$w$c== w_sh5a ww1_sh5e ww2_sh5f ww4_sh5h ww5_sh5i;
              };
        };

GHC.Base.$fEqNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (GHC.Base.NonEmpty a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_sh5j]
        let {
          sat_sh5l [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nu
               -> GHC.Base.NonEmpty a_a4nu -> GHC.Types.Bool
          [LclId] =
              [$dEq_sh5j] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqNonEmpty_$c/= $dEq_sh5j eta_B2 eta_B1; } in
        let {
          sat_sh5k [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nu
               -> GHC.Base.NonEmpty a_a4nu -> GHC.Types.Bool
          [LclId] =
              [$dEq_sh5j] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqNonEmpty_$c== $dEq_sh5j eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_sh5k sat_sh5l];

GHC.Base.$fOrdNonEmpty_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (GHC.Base.NonEmpty a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_sh5m]
        let {
          sat_sh5n [Occ=Once, Dmd=<L,U(C(C1(U)),A)>] :: GHC.Classes.Eq a_a4nL
          [LclId] =
              [$dOrd_sh5m] \u [] GHC.Classes.$p1Ord $dOrd_sh5m;
        } in  GHC.Base.$fEqNonEmpty sat_sh5n;

GHC.Base.$w$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh5o ww_sh5p ww1_sh5q ww2_sh5r ww3_sh5s]
        case GHC.Classes.compare w_sh5o ww_sh5p ww2_sh5r of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ ->
              GHC.Classes.$fOrd[]_$ccompare w_sh5o ww1_sh5q ww3_sh5s;
          GHC.Types.GT -> GHC.Types.GT [];
        };

GHC.Base.$fOrdNonEmpty_$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh5u w1_sh5v w2_sh5w]
        case w1_sh5v of {
          GHC.Base.:| ww1_sh5y [Occ=Once] ww2_sh5z [Occ=Once] ->
              case w2_sh5w of {
                GHC.Base.:| ww4_sh5B [Occ=Once] ww5_sh5C [Occ=Once] ->
                    GHC.Base.$w$ccompare w_sh5u ww1_sh5y ww2_sh5z ww4_sh5B ww5_sh5C;
              };
        };

GHC.Base.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh5D ww_sh5E ww1_sh5F ww2_sh5G ww3_sh5H]
        case GHC.Classes.compare w_sh5D ww_sh5E ww2_sh5G of {
          GHC.Types.LT -> GHC.Types.True [];
          GHC.Types.EQ -> GHC.Classes.$fOrd[]_$c< w_sh5D ww1_sh5F ww3_sh5H;
          GHC.Types.GT -> GHC.Types.False [];
        };

GHC.Base.$fOrdNonEmpty_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh5J w1_sh5K w2_sh5L]
        case w1_sh5K of {
          GHC.Base.:| ww1_sh5N [Occ=Once] ww2_sh5O [Occ=Once] ->
              case w2_sh5L of {
                GHC.Base.:| ww4_sh5Q [Occ=Once] ww5_sh5R [Occ=Once] ->
                    GHC.Base.$w$c< w_sh5J ww1_sh5N ww2_sh5O ww4_sh5Q ww5_sh5R;
              };
        };

GHC.Base.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh5S ww_sh5T ww1_sh5U ww2_sh5V ww3_sh5W]
        case GHC.Classes.compare w_sh5S ww2_sh5V ww_sh5T of {
          GHC.Types.LT -> GHC.Types.False [];
          GHC.Types.EQ ->
              case GHC.Classes.$fOrd[]_$ccompare w_sh5S ww3_sh5W ww1_sh5U of {
                __DEFAULT -> GHC.Types.True [];
                GHC.Types.LT -> GHC.Types.False [];
              };
          GHC.Types.GT -> GHC.Types.True [];
        };

GHC.Base.$fOrdNonEmpty_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh5Z w1_sh60 w2_sh61]
        case w1_sh60 of {
          GHC.Base.:| ww1_sh63 [Occ=Once] ww2_sh64 [Occ=Once] ->
              case w2_sh61 of {
                GHC.Base.:| ww4_sh66 [Occ=Once] ww5_sh67 [Occ=Once] ->
                    GHC.Base.$w$c<= w_sh5Z ww1_sh63 ww2_sh64 ww4_sh66 ww5_sh67;
              };
        };

GHC.Base.$fOrdNonEmpty_$cmax [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sh68 w1_sh69 w2_sh6a]
        case w1_sh69 of ww_sh6b {
          GHC.Base.:| ww1_sh6c [Occ=Once] ww2_sh6d [Occ=Once] ->
              case w2_sh6a of ww3_sh6e {
                GHC.Base.:| ww4_sh6f [Occ=Once] ww5_sh6g [Occ=Once] ->
                    case GHC.Classes.compare w_sh68 ww4_sh6f ww1_sh6c of {
                      GHC.Types.LT -> ww_sh6b;
                      GHC.Types.EQ ->
                          case GHC.Classes.$fOrd[]_$ccompare w_sh68 ww5_sh6g ww2_sh6d of {
                            __DEFAULT -> ww3_sh6e;
                            GHC.Types.LT -> ww_sh6b;
                          };
                      GHC.Types.GT -> ww3_sh6e;
                    };
              };
        };

GHC.Base.$fOrdNonEmpty_$cmin [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sh6j w1_sh6k w2_sh6l]
        case w1_sh6k of ww_sh6m {
          GHC.Base.:| ww1_sh6n [Occ=Once] ww2_sh6o [Occ=Once] ->
              case w2_sh6l of ww3_sh6p {
                GHC.Base.:| ww4_sh6q [Occ=Once] ww5_sh6r [Occ=Once] ->
                    case GHC.Classes.compare w_sh6j ww4_sh6q ww1_sh6n of {
                      GHC.Types.LT -> ww3_sh6p;
                      GHC.Types.EQ ->
                          case GHC.Classes.$fOrd[]_$ccompare w_sh6j ww5_sh6r ww2_sh6o of {
                            __DEFAULT -> ww_sh6m;
                            GHC.Types.LT -> ww3_sh6p;
                          };
                      GHC.Types.GT -> ww_sh6m;
                    };
              };
        };

GHC.Base.$w$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     a -> [a] -> a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh6u ww_sh6v ww1_sh6w ww2_sh6x ww3_sh6y]
        case GHC.Classes.compare w_sh6u ww_sh6v ww2_sh6x of {
          GHC.Types.LT -> GHC.Types.False [];
          GHC.Types.EQ ->
              case GHC.Classes.$fOrd[]_$ccompare w_sh6u ww1_sh6w ww3_sh6y of {
                __DEFAULT -> GHC.Types.True [];
                GHC.Types.LT -> GHC.Types.False [];
              };
          GHC.Types.GT -> GHC.Types.True [];
        };

GHC.Base.$fOrdNonEmpty_$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh6B w1_sh6C w2_sh6D]
        case w1_sh6C of {
          GHC.Base.:| ww1_sh6F [Occ=Once] ww2_sh6G [Occ=Once] ->
              case w2_sh6D of {
                GHC.Base.:| ww4_sh6I [Occ=Once] ww5_sh6J [Occ=Once] ->
                    GHC.Base.$w$c>= w_sh6B ww1_sh6F ww2_sh6G ww4_sh6I ww5_sh6J;
              };
        };

GHC.Base.$fOrdNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (GHC.Base.NonEmpty a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m] =
    [] \r [$dOrd_sh6K]
        let {
          sat_sh6U [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Base.NonEmpty a_a4nL
          [LclId] =
              [$dOrd_sh6K] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$cmin $dOrd_sh6K eta_B2 eta_B1; } in
        let {
          sat_sh6T [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Base.NonEmpty a_a4nL
          [LclId] =
              [$dOrd_sh6K] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$cmax $dOrd_sh6K eta_B2 eta_B1; } in
        let {
          sat_sh6S [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh6K] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$c>= $dOrd_sh6K eta_B2 eta_B1; } in
        let {
          sat_sh6R [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh6K] \r [a1_sh6P b_sh6Q]
                  GHC.Base.$fOrdNonEmpty_$c< $dOrd_sh6K b_sh6Q a1_sh6P; } in
        let {
          sat_sh6O [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh6K] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$c<= $dOrd_sh6K eta_B2 eta_B1; } in
        let {
          sat_sh6N [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Bool
          [LclId] =
              [$dOrd_sh6K] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$c< $dOrd_sh6K eta_B2 eta_B1; } in
        let {
          sat_sh6M [Occ=Once]
            :: GHC.Base.NonEmpty a_a4nL
               -> GHC.Base.NonEmpty a_a4nL -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sh6K] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdNonEmpty_$ccompare $dOrd_sh6K eta_B2 eta_B1; } in
        let {
          sat_sh6L [Occ=Once] :: GHC.Classes.Eq (GHC.Base.NonEmpty a_a4nL)
          [LclId] =
              [$dOrd_sh6K] \u [] GHC.Base.$fOrdNonEmpty_$cp1Ord $dOrd_sh6K;
        } in 
          GHC.Classes.C:Ord [sat_sh6L
                             sat_sh6M
                             sat_sh6N
                             sat_sh6O
                             sat_sh6R
                             sat_sh6S
                             sat_sh6T
                             sat_sh6U];

GHC.Base.$fMonadIO_$cfail
  :: forall a. GHC.Base.String -> GHC.Types.IO a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [s_sh6V] GHC.IO.failIO s_sh6V;

GHC.Base.$fMonadIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicativeIO
                                     GHC.Base.$fMonadIO1
                                     GHC.Base.$fApplicativeIO2
                                     GHC.Base.$fApplicativeIO4
                                     GHC.Base.$fMonadIO_$cfail];

GHC.Base.$fMonad[]_$cfail [InlPrag=INLINE (sat-args=1)]
  :: forall a. GHC.Base.String -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sh6W] [] [];

GHC.Base.$fMonad[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicative[]
                                     GHC.Base.$fMonad[]_$c>>=
                                     GHC.Base.$fApplicative[]_$c*>
                                     GHC.Base.$fApplicative[]_$cpure
                                     GHC.Base.$fMonad[]_$cfail];

GHC.Base.$fMonadPlus[] [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus []
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [GHC.Base.$fAlternative[]
                                         GHC.Base.$fMonad[]
                                         GHC.Types.[]
                                         GHC.Base.++];

GHC.Base.$fMonadMaybe_$c>>=
  :: forall a b.
     GHC.Base.Maybe a -> (a -> GHC.Base.Maybe b) -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [ds_sh6X k_sh6Y]
        case ds_sh6X of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_sh70 [Occ=Once] -> k_sh6Y x_sh70;
        };

GHC.Base.$fMonadMaybe_$cfail
  :: forall a. GHC.Base.String -> GHC.Base.Maybe a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sh71] GHC.Base.Nothing [];

GHC.Base.$fMonad(->)_$c>>=
  :: forall r a b. (r -> a) -> (a -> r -> b) -> r -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sh72 k_sh73 r1_sh74]
        let {
          sat_sh75 [Occ=Once] :: a_a4tQ
          [LclId] =
              [f_sh72 r1_sh74] \u [] f_sh72 r1_sh74;
        } in  k_sh73 sat_sh75 r1_sh74;

GHC.Base.$fMonad(,)_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a1 -> (a, b)) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><C(S),1*C1(U(U,U))>m,
 Unf=OtherCon []] =
    [] \r [w_sh76 w1_sh77 w2_sh78]
        case w1_sh77 of {
          (,) ww1_sh7a [Occ=Once] ww2_sh7b [Occ=Once] ->
              case w2_sh78 ww2_sh7b of {
                (,) v_sh7d [Occ=Once] b1_sh7e [Occ=Once] ->
                    let {
                      sat_sh7g [Occ=Once] :: a_s6KB
                      [LclId] =
                          [w_sh76 ww1_sh7a v_sh7d] \u []
                              case GHC.Base.$p1Monoid w_sh76 of sat_sh7f {
                                __DEFAULT -> GHC.Base.<> sat_sh7f ww1_sh7a v_sh7d;
                              };
                    } in  (,) [sat_sh7g b1_sh7e];
              };
        };

GHC.Base.$fApplicative(,)_$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1 -> b) -> (a, a1) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,1*C1(U))><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sh7h w1_sh7i w2_sh7j]
        case w1_sh7i of {
          (,) ww1_sh7l [Occ=Once] ww2_sh7m [Occ=Once!] ->
              case w2_sh7j of {
                (,) ww4_sh7o [Occ=Once] ww5_sh7p [Occ=Once] ->
                    let {
                      sat_sh7s [Occ=Once] :: b_s6KT
                      [LclId] =
                          [ww2_sh7m ww5_sh7p] \u [] ww2_sh7m ww5_sh7p; } in
                    let {
                      sat_sh7r [Occ=Once] :: a_s6KQ
                      [LclId] =
                          [w_sh7h ww1_sh7l ww4_sh7o] \u []
                              case GHC.Base.$p1Monoid w_sh7h of sat_sh7q {
                                __DEFAULT -> GHC.Base.<> sat_sh7q ww1_sh7l ww4_sh7o;
                              };
                    } in  (,) [sat_sh7r sat_sh7s];
              };
        };

GHC.Base.$fApplicative(,)_$c*>
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b. (a, a1) -> (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,A)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh7t a2_sh7u a3_sh7v]
        case a2_sh7u of {
          (,) x_sh7x [Occ=Once] _ [Occ=Dead] ->
              case a3_sh7v of {
                (,) v_sh7A [Occ=Once] x1_sh7B [Occ=Once] ->
                    let {
                      sat_sh7D [Occ=Once] :: a_a4vv
                      [LclId] =
                          [$dMonoid_sh7t x_sh7x v_sh7A] \u []
                              case GHC.Base.$p1Monoid $dMonoid_sh7t of sat_sh7C {
                                __DEFAULT -> GHC.Base.<> sat_sh7C x_sh7x v_sh7A;
                              };
                    } in  (,) [sat_sh7D x1_sh7B];
              };
        };

GHC.Base.$fApplicative(,)_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Monoid a =>
     forall a1 b c. (a1 -> b -> c) -> (a, a1) -> (a, b) -> (a, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sh7E w1_sh7F w2_sh7G w3_sh7H]
        case w2_sh7G of {
          (,) ww1_sh7J [Occ=Once] ww2_sh7K [Occ=Once] ->
              case w3_sh7H of {
                (,) ww4_sh7M [Occ=Once] ww5_sh7N [Occ=Once] ->
                    let {
                      sat_sh7Q [Occ=Once] :: c_s6Le
                      [LclId] =
                          [w1_sh7F ww2_sh7K ww5_sh7N] \u [] w1_sh7F ww2_sh7K ww5_sh7N; } in
                    let {
                      sat_sh7P [Occ=Once] :: a_s6La
                      [LclId] =
                          [w_sh7E ww1_sh7J ww4_sh7M] \u []
                              case GHC.Base.$p1Monoid w_sh7E of sat_sh7O {
                                __DEFAULT -> GHC.Base.<> sat_sh7O ww1_sh7J ww4_sh7M;
                              };
                    } in  (,) [sat_sh7P sat_sh7Q];
              };
        };

GHC.Base.$fMonoid(,,,,)_$cmempty
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh7R
           $dMonoid1_sh7S
           $dMonoid2_sh7T
           $dMonoid3_sh7U
           $dMonoid4_sh7V]
        let {
          sat_sh80 [Occ=Once] :: e_a4x9
          [LclId] =
              [$dMonoid4_sh7V] \u [] GHC.Base.mempty $dMonoid4_sh7V; } in
        let {
          sat_sh7Z [Occ=Once] :: d_a4x8
          [LclId] =
              [$dMonoid3_sh7U] \u [] GHC.Base.mempty $dMonoid3_sh7U; } in
        let {
          sat_sh7Y [Occ=Once] :: c_a4x7
          [LclId] =
              [$dMonoid2_sh7T] \u [] GHC.Base.mempty $dMonoid2_sh7T; } in
        let {
          sat_sh7X [Occ=Once] :: b_a4x6
          [LclId] =
              [$dMonoid1_sh7S] \u [] GHC.Base.mempty $dMonoid1_sh7S; } in
        let {
          sat_sh7W [Occ=Once] :: a_a4x5
          [LclId] =
              [$dMonoid_sh7R] \u [] GHC.Base.mempty $dMonoid_sh7R;
        } in  (,,,,) [sat_sh7W sat_sh7X sat_sh7Y sat_sh7Z sat_sh80];

GHC.Base.$fMonoid(,,,)_$cmempty
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh81 $dMonoid1_sh82 $dMonoid2_sh83 $dMonoid3_sh84]
        let {
          sat_sh88 [Occ=Once] :: d_a4xM
          [LclId] =
              [$dMonoid3_sh84] \u [] GHC.Base.mempty $dMonoid3_sh84; } in
        let {
          sat_sh87 [Occ=Once] :: c_a4xL
          [LclId] =
              [$dMonoid2_sh83] \u [] GHC.Base.mempty $dMonoid2_sh83; } in
        let {
          sat_sh86 [Occ=Once] :: b_a4xK
          [LclId] =
              [$dMonoid1_sh82] \u [] GHC.Base.mempty $dMonoid1_sh82; } in
        let {
          sat_sh85 [Occ=Once] :: a_a4xJ
          [LclId] =
              [$dMonoid_sh81] \u [] GHC.Base.mempty $dMonoid_sh81;
        } in  (,,,) [sat_sh85 sat_sh86 sat_sh87 sat_sh88];

GHC.Base.$fMonoid(,,)_$cmempty
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     (a, b, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh89 $dMonoid1_sh8a $dMonoid2_sh8b]
        let {
          sat_sh8e [Occ=Once] :: c_a4yl
          [LclId] =
              [$dMonoid2_sh8b] \u [] GHC.Base.mempty $dMonoid2_sh8b; } in
        let {
          sat_sh8d [Occ=Once] :: b_a4yk
          [LclId] =
              [$dMonoid1_sh8a] \u [] GHC.Base.mempty $dMonoid1_sh8a; } in
        let {
          sat_sh8c [Occ=Once] :: a_a4yj
          [LclId] =
              [$dMonoid_sh89] \u [] GHC.Base.mempty $dMonoid_sh89;
        } in  (,,) [sat_sh8c sat_sh8d sat_sh8e];

GHC.Base.$fMonoid(,)_$cmempty
  :: forall a b. (GHC.Base.Monoid a, GHC.Base.Monoid b) => (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh8f $dMonoid1_sh8g]
        let {
          sat_sh8i [Occ=Once] :: b_a4yQ
          [LclId] =
              [$dMonoid1_sh8g] \u [] GHC.Base.mempty $dMonoid1_sh8g; } in
        let {
          sat_sh8h [Occ=Once] :: a_a4yP
          [LclId] =
              [$dMonoid_sh8f] \u [] GHC.Base.mempty $dMonoid_sh8f;
        } in  (,) [sat_sh8h sat_sh8i];

GHC.Base.$fMonoid(,)_$cmconcat
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     [(a, b)] -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sh8j $dMonoid1_sh8k eta_sh8l]
        let {
          $dSemigroup_sh8m [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_a4yP
          [LclId] =
              [$dMonoid_sh8j] \u [] GHC.Base.$p1Monoid $dMonoid_sh8j; } in
        let {
          $dSemigroup1_sh8n [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_a4yQ
          [LclId] =
              [$dMonoid1_sh8k] \u [] GHC.Base.$p1Monoid $dMonoid1_sh8k; } in
        let {
          z_sh8o [Occ=OnceL] :: a_a4yP
          [LclId] =
              [$dMonoid_sh8j] \u [] GHC.Base.mempty $dMonoid_sh8j; } in
        let {
          z1_sh8p [Occ=OnceL] :: b_a4yQ
          [LclId] =
              [$dMonoid1_sh8k] \u [] GHC.Base.mempty $dMonoid1_sh8k; } in
        let {
          z2_sh8q [Occ=OnceL, Dmd=<S,U(U,U)>] :: (a_a4yP, b_a4yQ)
          [LclId, Unf=OtherCon []] =
              CCCS (,)! [z_sh8o z1_sh8p]; } in
        let {
          go_sh8r [Occ=LoopBreaker] :: [(a_a4yP, b_a4yQ)] -> (a_a4yP, b_a4yQ)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_sh8m
                        $dSemigroup1_sh8n
                        z2_sh8q
                        go_sh8r] \r [ds_sh8s]
                  case ds_sh8s of {
                    [] -> z2_sh8q;
                    : y_sh8u [Occ=Once!] ys_sh8v [Occ=Once] ->
                        case y_sh8u of {
                          (,) a1_sh8x [Occ=Once] b1_sh8y [Occ=Once] ->
                              case go_sh8r ys_sh8v of {
                                (,) a'_sh8A [Occ=Once] b'_sh8B [Occ=Once] ->
                                    let {
                                      sat_sh8D [Occ=Once] :: b_a4yQ
                                      [LclId] =
                                          [$dSemigroup1_sh8n b1_sh8y b'_sh8B] \u []
                                              GHC.Base.<> $dSemigroup1_sh8n b1_sh8y b'_sh8B; } in
                                    let {
                                      sat_sh8C [Occ=Once] :: a_a4yP
                                      [LclId] =
                                          [$dSemigroup_sh8m a1_sh8x a'_sh8A] \u []
                                              GHC.Base.<> $dSemigroup_sh8m a1_sh8x a'_sh8A;
                                    } in  (,) [sat_sh8C sat_sh8D];
                              };
                        };
                  };
        } in  go_sh8r eta_sh8l;

GHC.Base.$fMonoid()_$cmconcat :: [()] -> ()
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sh8E] () [];

GHC.Base.$fMonoidMaybe_$c<>
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sh8F ds_sh8G b_sh8H]
        case ds_sh8G of wild_sh8I {
          GHC.Base.Nothing -> b_sh8H;
          GHC.Base.Just ipv_sh8J [Occ=Once] ->
              case b_sh8H of {
                GHC.Base.Nothing -> wild_sh8I;
                GHC.Base.Just ipv1_sh8L [Occ=Once] ->
                    let {
                      sat_sh8M [Occ=Once] :: a_a4AP
                      [LclId] =
                          [$dSemigroup_sh8F ipv_sh8J ipv1_sh8L] \u []
                              GHC.Base.<> $dSemigroup_sh8F ipv_sh8J ipv1_sh8L;
                    } in  GHC.Base.Just [sat_sh8M];
              };
        };

GHC.Base.$w$csconcat5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Maybe a -> [GHC.Base.Maybe a] -> GHC.Base.Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sh8N ww_sh8O ww1_sh8P]
        let {
          go_sh8Q [Occ=LoopBreaker]
            :: GHC.Base.Maybe a_s6LE
               -> [GHC.Base.Maybe a_s6LE] -> GHC.Base.Maybe a_s6LE
          [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_sh8N go_sh8Q] \r [b_sh8R ds_sh8S]
                  case ds_sh8S of {
                    [] -> b_sh8R;
                    : c_sh8U [Occ=Once*] cs_sh8V [Occ=Once*] ->
                        case b_sh8R of wild1_sh8W {
                          GHC.Base.Nothing -> go_sh8Q c_sh8U cs_sh8V;
                          GHC.Base.Just ipv_sh8X [Occ=Once] ->
                              case go_sh8Q c_sh8U cs_sh8V of {
                                GHC.Base.Nothing -> wild1_sh8W;
                                GHC.Base.Just ipv1_sh8Z [Occ=Once] ->
                                    let {
                                      sat_sh90 [Occ=Once] :: a_s6LE
                                      [LclId] =
                                          [w_sh8N ipv_sh8X ipv1_sh8Z] \u []
                                              GHC.Base.<> w_sh8N ipv_sh8X ipv1_sh8Z;
                                    } in  GHC.Base.Just [sat_sh90];
                              };
                        };
                  };
        } in  go_sh8Q ww_sh8O ww1_sh8P;

GHC.Base.$fSemigroupMaybe_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (GHC.Base.Maybe a) -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sh91 w1_sh92]
        case w1_sh92 of {
          GHC.Base.:| ww1_sh94 [Occ=Once] ww2_sh95 [Occ=Once] ->
              GHC.Base.$w$csconcat5 w_sh91 ww1_sh94 ww2_sh95;
        };

GHC.Base.$fSemigroupMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (GHC.Base.Maybe a)
[GblId[DFunId], Arity=1, Str=<L,U(U,U,U)>m] =
    [] \r [$dSemigroup_sh96]
        let {
          sat_sh9a [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> GHC.Base.Maybe a_a4AP -> GHC.Base.Maybe a_a4AP
          [LclId] =
              [$dSemigroup_sh96] \r [$dIntegral_sh99]
                  Data.Semigroup.Internal.stimesMaybe
                      $dIntegral_sh99 $dSemigroup_sh96; } in
        let {
          sat_sh98 [Occ=Once]
            :: GHC.Base.NonEmpty (GHC.Base.Maybe a_a4AP)
               -> GHC.Base.Maybe a_a4AP
          [LclId] =
              [$dSemigroup_sh96] \r [eta_B1]
                  GHC.Base.$fSemigroupMaybe_$csconcat $dSemigroup_sh96 eta_B1; } in
        let {
          sat_sh97 [Occ=Once]
            :: GHC.Base.Maybe a_a4AP
               -> GHC.Base.Maybe a_a4AP -> GHC.Base.Maybe a_a4AP
          [LclId] =
              [$dSemigroup_sh96] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_sh96 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_sh97 sat_sh98 sat_sh9a];

GHC.Base.$fMonoidMaybe_$cmconcat
  :: forall a.
     GHC.Base.Semigroup a =>
     [GHC.Base.Maybe a] -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sh9b eta_sh9c]
        let {
          go_sh9d [Occ=LoopBreaker]
            :: [GHC.Base.Maybe a_a4wo] -> GHC.Base.Maybe a_a4wo
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_sh9b go_sh9d] \r [ds_sh9e]
                  case ds_sh9e of {
                    [] -> GHC.Base.Nothing [];
                    : y_sh9g [Occ=Once!] ys_sh9h [Occ=Once*] ->
                        case y_sh9g of wild1_sh9i {
                          GHC.Base.Nothing -> go_sh9d ys_sh9h;
                          GHC.Base.Just ipv_sh9j [Occ=Once] ->
                              case go_sh9d ys_sh9h of {
                                GHC.Base.Nothing -> wild1_sh9i;
                                GHC.Base.Just ipv1_sh9l [Occ=Once] ->
                                    let {
                                      sat_sh9m [Occ=Once] :: a_a4wo
                                      [LclId] =
                                          [$dSemigroup_sh9b ipv_sh9j ipv1_sh9l] \u []
                                              GHC.Base.<> $dSemigroup_sh9b ipv_sh9j ipv1_sh9l;
                                    } in  GHC.Base.Just [sat_sh9m];
                              };
                        };
                  };
        } in  go_sh9d eta_sh9c;

GHC.Base.$fMonoidMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Monoid (GHC.Base.Maybe a)
[GblId[DFunId], Arity=1, Str=<L,U(U,U,U)>m] =
    [] \r [$dSemigroup_sh9n]
        let {
          sat_sh9q [Occ=Once]
            :: [GHC.Base.Maybe a_a4wo] -> GHC.Base.Maybe a_a4wo
          [LclId] =
              [$dSemigroup_sh9n] \r [eta_B1]
                  GHC.Base.$fMonoidMaybe_$cmconcat $dSemigroup_sh9n eta_B1; } in
        let {
          sat_sh9p [Occ=Once]
            :: GHC.Base.Maybe a_a4wo
               -> GHC.Base.Maybe a_a4wo -> GHC.Base.Maybe a_a4wo
          [LclId] =
              [$dSemigroup_sh9n] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoidMaybe_$c<> $dSemigroup_sh9n eta_B2 eta_B1; } in
        let {
          sat_sh9o [Occ=Once] :: GHC.Base.Semigroup (GHC.Base.Maybe a_a4wo)
          [LclId] =
              [$dSemigroup_sh9n] \u []
                  GHC.Base.$fSemigroupMaybe $dSemigroup_sh9n;
        } in 
          GHC.Base.C:Monoid [sat_sh9o GHC.Base.Nothing sat_sh9p sat_sh9q];

GHC.Base.$fMonoidOrdering_$c<>
  :: GHC.Types.Ordering -> GHC.Types.Ordering -> GHC.Types.Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sh9r ds1_sh9s]
        case ds_sh9r of {
          GHC.Types.LT -> GHC.Types.LT [];
          GHC.Types.EQ -> ds1_sh9s;
          GHC.Types.GT -> GHC.Types.GT [];
        };

GHC.Base.$fMonoidOrdering_go [Occ=LoopBreaker]
  :: [GHC.Types.Ordering] -> GHC.Types.Ordering
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sh9u]
        case ds_sh9u of {
          [] -> GHC.Types.EQ [];
          : y_sh9w [Occ=Once!] ys_sh9x [Occ=Once] ->
              case y_sh9w of {
                GHC.Types.LT -> GHC.Types.LT [];
                GHC.Types.EQ -> GHC.Base.$fMonoidOrdering_go ys_sh9x;
                GHC.Types.GT -> GHC.Types.GT [];
              };
        };

GHC.Base.$fSemigroupOrdering [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup GHC.Types.Ordering
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.$fMonoidOrdering_$c<>
                                         GHC.Base.$fSemigroupOrdering_$csconcat
                                         GHC.Base.$fSemigroupOrdering_$cstimes];
GHC.Base.$fMonoidOrdering [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid GHC.Types.Ordering
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [GHC.Base.$fSemigroupOrdering
                                      GHC.Types.EQ
                                      GHC.Base.$fMonoidOrdering_$c<>
                                      GHC.Base.$fMonoidOrdering_go];
GHC.Base.$fSemigroupOrdering_$cstimes [Occ=LoopBreaker]
  :: forall b.
     GHC.Real.Integral b =>
     b -> GHC.Types.Ordering -> GHC.Types.Ordering
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_sh9z]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_sh9z GHC.Base.$fMonoidOrdering;

GHC.Base.$fMonoid(,,,,)_$c<>
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U,U,U)><S,1*U(U,U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sh9A
           $dSemigroup1_sh9B
           $dSemigroup2_sh9C
           $dSemigroup3_sh9D
           $dSemigroup4_sh9E
           ds_sh9F
           ds1_sh9G]
        case ds_sh9F of {
          (,,,,) a1_sh9I [Occ=Once]
                 b1_sh9J [Occ=Once]
                 c1_sh9K [Occ=Once]
                 d1_sh9L [Occ=Once]
                 e1_sh9M [Occ=Once] ->
              case ds1_sh9G of {
                (,,,,) a'_sh9O [Occ=Once]
                       b'_sh9P [Occ=Once]
                       c'_sh9Q [Occ=Once]
                       d'_sh9R [Occ=Once]
                       e'_sh9S [Occ=Once] ->
                    let {
                      sat_sh9X [Occ=Once] :: e_a4BK
                      [LclId] =
                          [$dSemigroup4_sh9E e1_sh9M e'_sh9S] \u []
                              GHC.Base.<> $dSemigroup4_sh9E e1_sh9M e'_sh9S; } in
                    let {
                      sat_sh9W [Occ=Once] :: d_a4BJ
                      [LclId] =
                          [$dSemigroup3_sh9D d1_sh9L d'_sh9R] \u []
                              GHC.Base.<> $dSemigroup3_sh9D d1_sh9L d'_sh9R; } in
                    let {
                      sat_sh9V [Occ=Once] :: c_a4BI
                      [LclId] =
                          [$dSemigroup2_sh9C c1_sh9K c'_sh9Q] \u []
                              GHC.Base.<> $dSemigroup2_sh9C c1_sh9K c'_sh9Q; } in
                    let {
                      sat_sh9U [Occ=Once] :: b_a4BH
                      [LclId] =
                          [$dSemigroup1_sh9B b1_sh9J b'_sh9P] \u []
                              GHC.Base.<> $dSemigroup1_sh9B b1_sh9J b'_sh9P; } in
                    let {
                      sat_sh9T [Occ=Once] :: a_a4BG
                      [LclId] =
                          [$dSemigroup_sh9A a1_sh9I a'_sh9O] \u []
                              GHC.Base.<> $dSemigroup_sh9A a1_sh9I a'_sh9O;
                    } in  (,,,,) [sat_sh9T sat_sh9U sat_sh9V sat_sh9W sat_sh9X];
              };
        };

GHC.Base.$fMonoid(,,,,)_$csconcat
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     GHC.Base.NonEmpty (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U,U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_sh9Y
           $dSemigroup1_sh9Z
           $dSemigroup2_sha0
           $dSemigroup3_sha1
           $dSemigroup4_sha2
           ds_sha3]
        case ds_sha3 of {
          GHC.Base.:| a1_sha5 [Occ=Once!] as_sha6 [Occ=Once] ->
              case a1_sha5 of {
                (,,,,) ww1_sha8 [Occ=Once]
                       ww2_sha9 [Occ=Once]
                       ww3_shaa [Occ=Once]
                       ww4_shab [Occ=Once]
                       ww5_shac [Occ=Once] ->
                    let {
                      $wgo_shad [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                        :: a_a4BG
                           -> b_a4BH
                           -> c_a4BI
                           -> d_a4BJ
                           -> e_a4BK
                           -> [(a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)]
                           -> (# a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK #)
                      [LclId,
                       Arity=6,
                       Str=<L,U><L,U><L,U><L,U><L,U><S,1*U>,
                       Unf=OtherCon []] =
                          sat-only [$dSemigroup_sh9Y
                                    $dSemigroup1_sh9Z
                                    $dSemigroup2_sha0
                                    $dSemigroup3_sha1
                                    $dSemigroup4_sha2
                                    $wgo_shad] \r [ww6_shae
                                                   ww7_shaf
                                                   ww8_shag
                                                   ww9_shah
                                                   ww10_shai
                                                   w_shaj]
                              case w_shaj of {
                                [] -> (#,,,,#) [ww6_shae ww7_shaf ww8_shag ww9_shah ww10_shai];
                                : c1_shal [Occ=Once!] cs_sham [Occ=Once] ->
                                    case c1_shal of {
                                      (,,,,) ww12_shao [Occ=Once]
                                             ww13_shap [Occ=Once]
                                             ww14_shaq [Occ=Once]
                                             ww15_shar [Occ=Once]
                                             ww16_shas [Occ=Once] ->
                                          case
                                              $wgo_shad
                                                  ww12_shao
                                                  ww13_shap
                                                  ww14_shaq
                                                  ww15_shar
                                                  ww16_shas
                                                  cs_sham
                                          of
                                          { (#,,,,#) ww18_shau [Occ=Once]
                                                     ww19_shav [Occ=Once]
                                                     ww20_shaw [Occ=Once]
                                                     ww21_shax [Occ=Once]
                                                     ww22_shay [Occ=Once] ->
                                                let {
                                                  sat_shaD [Occ=Once] :: e_a4BK
                                                  [LclId] =
                                                      [$dSemigroup4_sha2 ww10_shai ww22_shay] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup4_sha2
                                                              ww10_shai
                                                              ww22_shay; } in
                                                let {
                                                  sat_shaC [Occ=Once] :: d_a4BJ
                                                  [LclId] =
                                                      [$dSemigroup3_sha1 ww9_shah ww21_shax] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup3_sha1
                                                              ww9_shah
                                                              ww21_shax; } in
                                                let {
                                                  sat_shaB [Occ=Once] :: c_a4BI
                                                  [LclId] =
                                                      [$dSemigroup2_sha0 ww8_shag ww20_shaw] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup2_sha0
                                                              ww8_shag
                                                              ww20_shaw; } in
                                                let {
                                                  sat_shaA [Occ=Once] :: b_a4BH
                                                  [LclId] =
                                                      [$dSemigroup1_sh9Z ww7_shaf ww19_shav] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup1_sh9Z
                                                              ww7_shaf
                                                              ww19_shav; } in
                                                let {
                                                  sat_shaz [Occ=Once] :: a_a4BG
                                                  [LclId] =
                                                      [$dSemigroup_sh9Y ww6_shae ww18_shau] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup_sh9Y ww6_shae ww18_shau;
                                                } in 
                                                  (#,,,,#) [sat_shaz
                                                            sat_shaA
                                                            sat_shaB
                                                            sat_shaC
                                                            sat_shaD];
                                          };
                                    };
                              };
                    } in 
                      case
                          $wgo_shad ww1_sha8 ww2_sha9 ww3_shaa ww4_shab ww5_shac as_sha6
                      of
                      { (#,,,,#) ww7_shaF [Occ=Once]
                                 ww8_shaG [Occ=Once]
                                 ww9_shaH [Occ=Once]
                                 ww10_shaI [Occ=Once]
                                 ww11_shaJ [Occ=Once] ->
                            (,,,,) [ww7_shaF ww8_shaG ww9_shaH ww10_shaI ww11_shaJ];
                      };
              };
        };

GHC.Base.$fMonoid(,,,,)_$cstimes
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     forall b1.
     GHC.Real.Integral b1 =>
     b1 -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_shaK
           $dSemigroup1_shaL
           $dSemigroup2_shaM
           $dSemigroup3_shaN
           $dSemigroup4_shaO
           $dIntegral_shaP
           n_shaQ
           ds_shaR]
        case ds_shaR of {
          (,,,,) a1_shaT [Occ=Once]
                 b2_shaU [Occ=Once]
                 c1_shaV [Occ=Once]
                 d1_shaW [Occ=Once]
                 e1_shaX [Occ=Once] ->
              let {
                sat_shb2 [Occ=Once] :: e_a4BK
                [LclId] =
                    [$dSemigroup4_shaO $dIntegral_shaP n_shaQ e1_shaX] \u []
                        GHC.Base.stimes
                            $dSemigroup4_shaO $dIntegral_shaP n_shaQ e1_shaX; } in
              let {
                sat_shb1 [Occ=Once] :: d_a4BJ
                [LclId] =
                    [$dSemigroup3_shaN $dIntegral_shaP n_shaQ d1_shaW] \u []
                        GHC.Base.stimes
                            $dSemigroup3_shaN $dIntegral_shaP n_shaQ d1_shaW; } in
              let {
                sat_shb0 [Occ=Once] :: c_a4BI
                [LclId] =
                    [$dSemigroup2_shaM $dIntegral_shaP n_shaQ c1_shaV] \u []
                        GHC.Base.stimes
                            $dSemigroup2_shaM $dIntegral_shaP n_shaQ c1_shaV; } in
              let {
                sat_shaZ [Occ=Once] :: b_a4BH
                [LclId] =
                    [$dSemigroup1_shaL $dIntegral_shaP n_shaQ b2_shaU] \u []
                        GHC.Base.stimes
                            $dSemigroup1_shaL $dIntegral_shaP n_shaQ b2_shaU; } in
              let {
                sat_shaY [Occ=Once] :: a_a4BG
                [LclId] =
                    [$dSemigroup_shaK $dIntegral_shaP n_shaQ a1_shaT] \u []
                        GHC.Base.stimes $dSemigroup_shaK $dIntegral_shaP n_shaQ a1_shaT;
              } in  (,,,,) [sat_shaY sat_shaZ sat_shb0 sat_shb1 sat_shb2];
        };

GHC.Base.$fSemigroup(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d, GHC.Base.Semigroup e) =>
     GHC.Base.Semigroup (a, b, c, d, e)
[GblId[DFunId],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_shb3
           $dSemigroup1_shb4
           $dSemigroup2_shb5
           $dSemigroup3_shb6
           $dSemigroup4_shb7]
        let {
          sat_shba [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
          [LclId] =
              [$dSemigroup_shb3
               $dSemigroup1_shb4
               $dSemigroup2_shb5
               $dSemigroup3_shb6
               $dSemigroup4_shb7] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$cstimes
                      $dSemigroup_shb3
                      $dSemigroup1_shb4
                      $dSemigroup2_shb5
                      $dSemigroup3_shb6
                      $dSemigroup4_shb7
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_shb9 [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
          [LclId] =
              [$dSemigroup_shb3
               $dSemigroup1_shb4
               $dSemigroup2_shb5
               $dSemigroup3_shb6
               $dSemigroup4_shb7] \r [eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$csconcat
                      $dSemigroup_shb3
                      $dSemigroup1_shb4
                      $dSemigroup2_shb5
                      $dSemigroup3_shb6
                      $dSemigroup4_shb7
                      eta_B1; } in
        let {
          sat_shb8 [Occ=Once]
            :: (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
               -> (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
          [LclId] =
              [$dSemigroup_shb3
               $dSemigroup1_shb4
               $dSemigroup2_shb5
               $dSemigroup3_shb6
               $dSemigroup4_shb7] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$c<>
                      $dSemigroup_shb3
                      $dSemigroup1_shb4
                      $dSemigroup2_shb5
                      $dSemigroup3_shb6
                      $dSemigroup4_shb7
                      eta_B2
                      eta_B1;
        } in  GHC.Base.C:Semigroup [sat_shb8 sat_shb9 sat_shba];

GHC.Base.$w$cp1Monoid1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     (# (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e),
        GHC.Base.NonEmpty (a, b, c, d, e) -> (a, b, c, d, e),
        forall b1.
        GHC.Real.Integral b1 =>
        b1 -> (a, b, c, d, e) -> (a, b, c, d, e) #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [w_shbb w1_shbc w2_shbd w3_shbe w4_shbf]
        let {
          sat_shbw [Occ=OnceL] :: GHC.Base.Semigroup e_s6Nx
          [LclId] =
              [w4_shbf] \u [] GHC.Base.$p1Monoid w4_shbf; } in
        let {
          sat_shbv [Occ=OnceL] :: GHC.Base.Semigroup d_s6Nw
          [LclId] =
              [w3_shbe] \u [] GHC.Base.$p1Monoid w3_shbe; } in
        let {
          sat_shbu [Occ=OnceL] :: GHC.Base.Semigroup c_s6Nv
          [LclId] =
              [w2_shbd] \u [] GHC.Base.$p1Monoid w2_shbd; } in
        let {
          sat_shbt [Occ=OnceL] :: GHC.Base.Semigroup b_s6Nu
          [LclId] =
              [w1_shbc] \u [] GHC.Base.$p1Monoid w1_shbc; } in
        let {
          sat_shbs [Occ=OnceL] :: GHC.Base.Semigroup a_s6Nt
          [LclId] =
              [w_shbb] \u [] GHC.Base.$p1Monoid w_shbb; } in
        let {
          sat_shbx [Occ=Once]
            :: forall b1.
               GHC.Real.Integral b1 =>
               b1
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
          [LclId] =
              [sat_shbs sat_shbt sat_shbu sat_shbv sat_shbw] \r [eta_B3
                                                                 eta_B2
                                                                 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$cstimes
                      sat_shbs
                      sat_shbt
                      sat_shbu
                      sat_shbv
                      sat_shbw
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_shbq [Occ=OnceL] :: GHC.Base.Semigroup e_s6Nx
          [LclId] =
              [w4_shbf] \u [] GHC.Base.$p1Monoid w4_shbf; } in
        let {
          sat_shbp [Occ=OnceL] :: GHC.Base.Semigroup d_s6Nw
          [LclId] =
              [w3_shbe] \u [] GHC.Base.$p1Monoid w3_shbe; } in
        let {
          sat_shbo [Occ=OnceL] :: GHC.Base.Semigroup c_s6Nv
          [LclId] =
              [w2_shbd] \u [] GHC.Base.$p1Monoid w2_shbd; } in
        let {
          sat_shbn [Occ=OnceL] :: GHC.Base.Semigroup b_s6Nu
          [LclId] =
              [w1_shbc] \u [] GHC.Base.$p1Monoid w1_shbc; } in
        let {
          sat_shbm [Occ=OnceL] :: GHC.Base.Semigroup a_s6Nt
          [LclId] =
              [w_shbb] \u [] GHC.Base.$p1Monoid w_shbb; } in
        let {
          sat_shbr [Occ=Once]
            :: GHC.Base.NonEmpty (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
          [LclId] =
              [sat_shbm sat_shbn sat_shbo sat_shbp sat_shbq] \r [eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$csconcat
                      sat_shbm sat_shbn sat_shbo sat_shbp sat_shbq eta_B1; } in
        let {
          sat_shbk [Occ=OnceL] :: GHC.Base.Semigroup e_s6Nx
          [LclId] =
              [w4_shbf] \u [] GHC.Base.$p1Monoid w4_shbf; } in
        let {
          sat_shbj [Occ=OnceL] :: GHC.Base.Semigroup d_s6Nw
          [LclId] =
              [w3_shbe] \u [] GHC.Base.$p1Monoid w3_shbe; } in
        let {
          sat_shbi [Occ=OnceL] :: GHC.Base.Semigroup c_s6Nv
          [LclId] =
              [w2_shbd] \u [] GHC.Base.$p1Monoid w2_shbd; } in
        let {
          sat_shbh [Occ=OnceL] :: GHC.Base.Semigroup b_s6Nu
          [LclId] =
              [w1_shbc] \u [] GHC.Base.$p1Monoid w1_shbc; } in
        let {
          sat_shbg [Occ=OnceL] :: GHC.Base.Semigroup a_s6Nt
          [LclId] =
              [w_shbb] \u [] GHC.Base.$p1Monoid w_shbb; } in
        let {
          sat_shbl [Occ=Once]
            :: (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
               -> (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
          [LclId] =
              [sat_shbg sat_shbh sat_shbi sat_shbj sat_shbk] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,,)_$c<>
                      sat_shbg sat_shbh sat_shbi sat_shbj sat_shbk eta_B2 eta_B1;
        } in  (#,,#) [sat_shbl sat_shbr sat_shbx];

GHC.Base.$fMonoid(,,,,)_$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     GHC.Base.Semigroup (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [w_shby w1_shbz w2_shbA w3_shbB w4_shbC]
        case
            GHC.Base.$w$cp1Monoid1 w_shby w1_shbz w2_shbA w3_shbB w4_shbC
        of
        { (#,,#) ww1_shbE [Occ=Once]
                 ww2_shbF [Occ=Once]
                 ww3_shbG [Occ=Once] ->
              GHC.Base.C:Semigroup [ww1_shbE ww2_shbF ww3_shbG];
        };

GHC.Base.$fMonoid(,,,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shbH
           $dMonoid1_shbI
           $dMonoid2_shbJ
           $dMonoid3_shbK
           $dMonoid4_shbL]
        case
            GHC.Base.$w$cp1Monoid1
                $dMonoid_shbH
                $dMonoid1_shbI
                $dMonoid2_shbJ
                $dMonoid3_shbK
                $dMonoid4_shbL
        of
        { (#,,#) ww1_shbN [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> ww1_shbN;
        };

GHC.Base.$fMonoid(,,,,)_$cmconcat
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     [(a, b, c, d, e)] -> (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shbQ
           $dMonoid1_shbR
           $dMonoid2_shbS
           $dMonoid3_shbT
           $dMonoid4_shbU]
        let {
          k_shbV [Occ=OnceL, Dmd=<L,1*U(1*C(C1(U(U,U,U,U,U))),A,A)>]
            :: GHC.Base.Semigroup (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_shbQ
               $dMonoid1_shbR
               $dMonoid2_shbS
               $dMonoid3_shbT
               $dMonoid4_shbU] \s []
                  case
                      GHC.Base.$w$cp1Monoid1
                          $dMonoid_shbQ
                          $dMonoid1_shbR
                          $dMonoid2_shbS
                          $dMonoid3_shbT
                          $dMonoid4_shbU
                  of
                  { (#,,#) ww1_shbX [Occ=Once]
                           ww2_shbY [Occ=Once]
                           ww3_shbZ [Occ=Once] ->
                        GHC.Base.C:Semigroup [ww1_shbX ww2_shbY ww3_shbZ];
                  }; } in
        let {
          k1_shc0 [Occ=OnceL!, Dmd=<L,C(C1(U(U,U,U,U,U)))>]
            :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [k_shbV] \u [] GHC.Base.<> k_shbV; } in
        let {
          z_shc1 [Occ=OnceL] :: a_a4x5
          [LclId] =
              [$dMonoid_shbQ] \u [] GHC.Base.mempty $dMonoid_shbQ; } in
        let {
          z1_shc2 [Occ=OnceL] :: b_a4x6
          [LclId] =
              [$dMonoid1_shbR] \u [] GHC.Base.mempty $dMonoid1_shbR; } in
        let {
          z2_shc3 [Occ=OnceL] :: c_a4x7
          [LclId] =
              [$dMonoid2_shbS] \u [] GHC.Base.mempty $dMonoid2_shbS; } in
        let {
          z3_shc4 [Occ=OnceL] :: d_a4x8
          [LclId] =
              [$dMonoid3_shbT] \u [] GHC.Base.mempty $dMonoid3_shbT; } in
        let {
          z4_shc5 [Occ=OnceL] :: e_a4x9
          [LclId] =
              [$dMonoid4_shbU] \u [] GHC.Base.mempty $dMonoid4_shbU; } in
        let {
          z5_shc6 [Occ=OnceL, Dmd=<L,U(U,U,U,U,U)>]
            :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId, Unf=OtherCon []] =
              CCCS (,,,,)! [z_shc1 z1_shc2 z2_shc3 z3_shc4 z4_shc5]; } in
        let {
          go_shc7 [Occ=LoopBreaker]
            :: [(a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)]
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [k1_shc0 z5_shc6 go_shc7] \r [ds_shc8]
                  case ds_shc8 of {
                    [] -> z5_shc6;
                    : y_shca [Occ=Once] ys_shcb [Occ=Once] ->
                        let {
                          sat_shcc [Occ=Once] :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
                          [LclId] =
                              [go_shc7 ys_shcb] \u [] go_shc7 ys_shcb;
                        } in  k1_shc0 y_shca sat_shcc;
                  };
        } in  go_shc7;

GHC.Base.$fMonoid(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d, GHC.Base.Monoid e) =>
     GHC.Base.Monoid (a, b, c, d, e)
[GblId[DFunId],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_shcd
           $dMonoid1_shce
           $dMonoid2_shcf
           $dMonoid3_shcg
           $dMonoid4_shch]
        let {
          sat_shcl [Occ=Once]
            :: [(a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)]
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_shcd
               $dMonoid1_shce
               $dMonoid2_shcf
               $dMonoid3_shcg
               $dMonoid4_shch] \u []
                  GHC.Base.$fMonoid(,,,,)_$cmconcat
                      $dMonoid_shcd
                      $dMonoid1_shce
                      $dMonoid2_shcf
                      $dMonoid3_shcg
                      $dMonoid4_shch; } in
        let {
          sat_shck [Occ=Once]
            :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
               -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_shcd
               $dMonoid1_shce
               $dMonoid2_shcf
               $dMonoid3_shcg
               $dMonoid4_shch] \u []
                  GHC.Base.$fMonoid(,,,,)_$cmappend
                      $dMonoid_shcd
                      $dMonoid1_shce
                      $dMonoid2_shcf
                      $dMonoid3_shcg
                      $dMonoid4_shch; } in
        let {
          sat_shcj [Occ=Once] :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_shcd
               $dMonoid1_shce
               $dMonoid2_shcf
               $dMonoid3_shcg
               $dMonoid4_shch] \u []
                  GHC.Base.$fMonoid(,,,,)_$cmempty
                      $dMonoid_shcd
                      $dMonoid1_shce
                      $dMonoid2_shcf
                      $dMonoid3_shcg
                      $dMonoid4_shch; } in
        let {
          sat_shci [Occ=Once]
            :: GHC.Base.Semigroup (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
          [LclId] =
              [$dMonoid_shcd
               $dMonoid1_shce
               $dMonoid2_shcf
               $dMonoid3_shcg
               $dMonoid4_shch] \u []
                  GHC.Base.$fMonoid(,,,,)_$cp1Monoid
                      $dMonoid_shcd
                      $dMonoid1_shce
                      $dMonoid2_shcf
                      $dMonoid3_shcg
                      $dMonoid4_shch;
        } in  GHC.Base.C:Monoid [sat_shci sat_shcj sat_shck sat_shcl];

GHC.Base.$fMonoid(,,,)_$c<>
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U,U)><S,1*U(U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_shcm
           $dSemigroup1_shcn
           $dSemigroup2_shco
           $dSemigroup3_shcp
           ds_shcq
           ds1_shcr]
        case ds_shcq of {
          (,,,) a1_shct [Occ=Once]
                b1_shcu [Occ=Once]
                c1_shcv [Occ=Once]
                d1_shcw [Occ=Once] ->
              case ds1_shcr of {
                (,,,) a'_shcy [Occ=Once]
                      b'_shcz [Occ=Once]
                      c'_shcA [Occ=Once]
                      d'_shcB [Occ=Once] ->
                    let {
                      sat_shcF [Occ=Once] :: d_a4CF
                      [LclId] =
                          [$dSemigroup3_shcp d1_shcw d'_shcB] \u []
                              GHC.Base.<> $dSemigroup3_shcp d1_shcw d'_shcB; } in
                    let {
                      sat_shcE [Occ=Once] :: c_a4CE
                      [LclId] =
                          [$dSemigroup2_shco c1_shcv c'_shcA] \u []
                              GHC.Base.<> $dSemigroup2_shco c1_shcv c'_shcA; } in
                    let {
                      sat_shcD [Occ=Once] :: b_a4CD
                      [LclId] =
                          [$dSemigroup1_shcn b1_shcu b'_shcz] \u []
                              GHC.Base.<> $dSemigroup1_shcn b1_shcu b'_shcz; } in
                    let {
                      sat_shcC [Occ=Once] :: a_a4CC
                      [LclId] =
                          [$dSemigroup_shcm a1_shct a'_shcy] \u []
                              GHC.Base.<> $dSemigroup_shcm a1_shct a'_shcy;
                    } in  (,,,) [sat_shcC sat_shcD sat_shcE sat_shcF];
              };
        };

GHC.Base.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     a -> b -> c -> d -> [(a, b, c, d)] -> (# a, b, c, d #)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_shcG
           w1_shcH
           w2_shcI
           w3_shcJ
           ww_shcK
           ww1_shcL
           ww2_shcM
           ww3_shcN
           ww4_shcO]
        let {
          $wgo_shcP [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: a_s6Ow
               -> b_s6Ox
               -> c_s6Oy
               -> d_s6Oz
               -> [(a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz)]
               -> (# a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz #)
          [LclId,
           Arity=5,
           Str=<L,U><L,U><L,U><L,U><S,1*U>,
           Unf=OtherCon []] =
              sat-only [w_shcG w1_shcH w2_shcI w3_shcJ $wgo_shcP] \r [ww5_shcQ
                                                                      ww6_shcR
                                                                      ww7_shcS
                                                                      ww8_shcT
                                                                      w4_shcU]
                  case w4_shcU of {
                    [] -> (#,,,#) [ww5_shcQ ww6_shcR ww7_shcS ww8_shcT];
                    : c1_shcW [Occ=Once!] cs_shcX [Occ=Once] ->
                        case c1_shcW of {
                          (,,,) ww10_shcZ [Occ=Once]
                                ww11_shd0 [Occ=Once]
                                ww12_shd1 [Occ=Once]
                                ww13_shd2 [Occ=Once] ->
                              case $wgo_shcP ww10_shcZ ww11_shd0 ww12_shd1 ww13_shd2 cs_shcX of {
                                (#,,,#) ww15_shd4 [Occ=Once]
                                        ww16_shd5 [Occ=Once]
                                        ww17_shd6 [Occ=Once]
                                        ww18_shd7 [Occ=Once] ->
                                    let {
                                      sat_shdb [Occ=Once] :: d_s6Oz
                                      [LclId] =
                                          [w3_shcJ ww8_shcT ww18_shd7] \u []
                                              GHC.Base.<> w3_shcJ ww8_shcT ww18_shd7; } in
                                    let {
                                      sat_shda [Occ=Once] :: c_s6Oy
                                      [LclId] =
                                          [w2_shcI ww7_shcS ww17_shd6] \u []
                                              GHC.Base.<> w2_shcI ww7_shcS ww17_shd6; } in
                                    let {
                                      sat_shd9 [Occ=Once] :: b_s6Ox
                                      [LclId] =
                                          [w1_shcH ww6_shcR ww16_shd5] \u []
                                              GHC.Base.<> w1_shcH ww6_shcR ww16_shd5; } in
                                    let {
                                      sat_shd8 [Occ=Once] :: a_s6Ow
                                      [LclId] =
                                          [w_shcG ww5_shcQ ww15_shd4] \u []
                                              GHC.Base.<> w_shcG ww5_shcQ ww15_shd4;
                                    } in  (#,,,#) [sat_shd8 sat_shd9 sat_shda sat_shdb];
                              };
                        };
                  };
        } in  $wgo_shcP ww_shcK ww1_shcL ww2_shcM ww3_shcN ww4_shcO;

GHC.Base.$fSemigroup(,,,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     GHC.Base.NonEmpty (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_shdc w1_shdd w2_shde w3_shdf w4_shdg]
        case w4_shdg of {
          GHC.Base.:| ww1_shdi [Occ=Once!] ww2_shdj [Occ=Once] ->
              case ww1_shdi of {
                (,,,) ww4_shdl [Occ=Once]
                      ww5_shdm [Occ=Once]
                      ww6_shdn [Occ=Once]
                      ww7_shdo [Occ=Once] ->
                    case
                        GHC.Base.$w$csconcat2
                            w_shdc
                            w1_shdd
                            w2_shde
                            w3_shdf
                            ww4_shdl
                            ww5_shdm
                            ww6_shdn
                            ww7_shdo
                            ww2_shdj
                    of
                    { (#,,,#) ww9_shdq [Occ=Once]
                              ww10_shdr [Occ=Once]
                              ww11_shds [Occ=Once]
                              ww12_shdt [Occ=Once] ->
                          (,,,) [ww9_shdq ww10_shdr ww11_shds ww12_shdt];
                    };
              };
        };

GHC.Base.$fSemigroup(,,,)_$cstimes [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     forall b1.
     GHC.Real.Integral b1 =>
     b1 -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shdu w1_shdv w2_shdw w3_shdx w4_shdy w5_shdz w6_shdA]
        case w6_shdA of {
          (,,,) ww1_shdC [Occ=Once]
                ww2_shdD [Occ=Once]
                ww3_shdE [Occ=Once]
                ww4_shdF [Occ=Once] ->
              let {
                sat_shdJ [Occ=Once] :: d_s6OY
                [LclId] =
                    [w3_shdx w4_shdy w5_shdz ww4_shdF] \u []
                        GHC.Base.stimes w3_shdx w4_shdy w5_shdz ww4_shdF; } in
              let {
                sat_shdI [Occ=Once] :: c_s6OX
                [LclId] =
                    [w2_shdw w4_shdy w5_shdz ww3_shdE] \u []
                        GHC.Base.stimes w2_shdw w4_shdy w5_shdz ww3_shdE; } in
              let {
                sat_shdH [Occ=Once] :: b_s6OW
                [LclId] =
                    [w1_shdv w4_shdy w5_shdz ww2_shdD] \u []
                        GHC.Base.stimes w1_shdv w4_shdy w5_shdz ww2_shdD; } in
              let {
                sat_shdG [Occ=Once] :: a_s6OV
                [LclId] =
                    [w_shdu w4_shdy w5_shdz ww1_shdC] \u []
                        GHC.Base.stimes w_shdu w4_shdy w5_shdz ww1_shdC;
              } in  (,,,) [sat_shdG sat_shdH sat_shdI sat_shdJ];
        };

GHC.Base.$fSemigroup(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
      GHC.Base.Semigroup d) =>
     GHC.Base.Semigroup (a, b, c, d)
[GblId[DFunId],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_shdK
           $dSemigroup1_shdL
           $dSemigroup2_shdM
           $dSemigroup3_shdN]
        let {
          sat_shdQ [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
          [LclId] =
              [$dSemigroup_shdK
               $dSemigroup1_shdL
               $dSemigroup2_shdM
               $dSemigroup3_shdN] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(,,,)_$cstimes
                      $dSemigroup_shdK
                      $dSemigroup1_shdL
                      $dSemigroup2_shdM
                      $dSemigroup3_shdN
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_shdP [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
          [LclId] =
              [$dSemigroup_shdK
               $dSemigroup1_shdL
               $dSemigroup2_shdM
               $dSemigroup3_shdN] \r [eta_B1]
                  GHC.Base.$fSemigroup(,,,)_$csconcat
                      $dSemigroup_shdK
                      $dSemigroup1_shdL
                      $dSemigroup2_shdM
                      $dSemigroup3_shdN
                      eta_B1; } in
        let {
          sat_shdO [Occ=Once]
            :: (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
               -> (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
          [LclId] =
              [$dSemigroup_shdK
               $dSemigroup1_shdL
               $dSemigroup2_shdM
               $dSemigroup3_shdN] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,)_$c<>
                      $dSemigroup_shdK
                      $dSemigroup1_shdL
                      $dSemigroup2_shdM
                      $dSemigroup3_shdN
                      eta_B2
                      eta_B1;
        } in  GHC.Base.C:Semigroup [sat_shdO sat_shdP sat_shdQ];

GHC.Base.$w$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     (# (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d),
        GHC.Base.NonEmpty (a, b, c, d) -> (a, b, c, d),
        forall b1.
        GHC.Real.Integral b1 =>
        b1 -> (a, b, c, d) -> (a, b, c, d) #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [w_shdR w1_shdS w2_shdT w3_shdU]
        let {
          w4_shej [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup d_s6Pl
          [LclId] =
              [w3_shdU] \u [] GHC.Base.$p1Monoid w3_shdU; } in
        let {
          w5_shek [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup c_s6Pk
          [LclId] =
              [w2_shdT] \u [] GHC.Base.$p1Monoid w2_shdT; } in
        let {
          w6_shel [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_s6Pj
          [LclId] =
              [w1_shdS] \u [] GHC.Base.$p1Monoid w1_shdS; } in
        let {
          w7_shem [Occ=OnceL, Dmd=<L,U(A,A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_s6Pi
          [LclId] =
              [w_shdR] \u [] GHC.Base.$p1Monoid w_shdR; } in
        let {
          sat_shez [Occ=Once]
            :: forall b1.
               GHC.Real.Integral b1 =>
               b1
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
          [LclId] =
              [w4_shej w5_shek w6_shel w7_shem] \r [w8_shen w9_sheo w10_shep]
                  case w10_shep of {
                    (,,,) ww1_sher [Occ=Once]
                          ww2_shes [Occ=Once]
                          ww3_shet [Occ=Once]
                          ww4_sheu [Occ=Once] ->
                        let {
                          sat_shey [Occ=Once] :: d_s6Pl
                          [LclId] =
                              [w4_shej w8_shen w9_sheo ww4_sheu] \u []
                                  GHC.Base.stimes w4_shej w8_shen w9_sheo ww4_sheu; } in
                        let {
                          sat_shex [Occ=Once] :: c_s6Pk
                          [LclId] =
                              [w5_shek w8_shen w9_sheo ww3_shet] \u []
                                  GHC.Base.stimes w5_shek w8_shen w9_sheo ww3_shet; } in
                        let {
                          sat_shew [Occ=Once] :: b_s6Pj
                          [LclId] =
                              [w6_shel w8_shen w9_sheo ww2_shes] \u []
                                  GHC.Base.stimes w6_shel w8_shen w9_sheo ww2_shes; } in
                        let {
                          sat_shev [Occ=Once] :: a_s6Pi
                          [LclId] =
                              [w7_shem w8_shen w9_sheo ww1_sher] \u []
                                  GHC.Base.stimes w7_shem w8_shen w9_sheo ww1_sher;
                        } in  (,,,) [sat_shev sat_shew sat_shex sat_shey];
                  }; } in
        let {
          w4_she0 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup d_s6Pl
          [LclId] =
              [w3_shdU] \u [] GHC.Base.$p1Monoid w3_shdU; } in
        let {
          w5_she1 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup c_s6Pk
          [LclId] =
              [w2_shdT] \u [] GHC.Base.$p1Monoid w2_shdT; } in
        let {
          w6_she2 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_s6Pj
          [LclId] =
              [w1_shdS] \u [] GHC.Base.$p1Monoid w1_shdS; } in
        let {
          w7_she3 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_s6Pi
          [LclId] =
              [w_shdR] \u [] GHC.Base.$p1Monoid w_shdR; } in
        let {
          sat_shei [Occ=Once]
            :: GHC.Base.NonEmpty (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
          [LclId] =
              [w4_she0 w5_she1 w6_she2 w7_she3] \r [w8_she4]
                  case w8_she4 of {
                    GHC.Base.:| ww1_she6 [Occ=Once!] ww2_she7 [Occ=Once] ->
                        case ww1_she6 of {
                          (,,,) ww4_she9 [Occ=Once]
                                ww5_shea [Occ=Once]
                                ww6_sheb [Occ=Once]
                                ww7_shec [Occ=Once] ->
                              case
                                  GHC.Base.$w$csconcat2
                                      w7_she3
                                      w6_she2
                                      w5_she1
                                      w4_she0
                                      ww4_she9
                                      ww5_shea
                                      ww6_sheb
                                      ww7_shec
                                      ww2_she7
                              of
                              { (#,,,#) ww9_shee [Occ=Once]
                                        ww10_shef [Occ=Once]
                                        ww11_sheg [Occ=Once]
                                        ww12_sheh [Occ=Once] ->
                                    (,,,) [ww9_shee ww10_shef ww11_sheg ww12_sheh];
                              };
                        };
                  }; } in
        let {
          sat_shdY [Occ=OnceL] :: GHC.Base.Semigroup d_s6Pl
          [LclId] =
              [w3_shdU] \u [] GHC.Base.$p1Monoid w3_shdU; } in
        let {
          sat_shdX [Occ=OnceL] :: GHC.Base.Semigroup c_s6Pk
          [LclId] =
              [w2_shdT] \u [] GHC.Base.$p1Monoid w2_shdT; } in
        let {
          sat_shdW [Occ=OnceL] :: GHC.Base.Semigroup b_s6Pj
          [LclId] =
              [w1_shdS] \u [] GHC.Base.$p1Monoid w1_shdS; } in
        let {
          sat_shdV [Occ=OnceL] :: GHC.Base.Semigroup a_s6Pi
          [LclId] =
              [w_shdR] \u [] GHC.Base.$p1Monoid w_shdR; } in
        let {
          sat_shdZ [Occ=Once]
            :: (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
               -> (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)
          [LclId] =
              [sat_shdV sat_shdW sat_shdX sat_shdY] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,,)_$c<>
                      sat_shdV sat_shdW sat_shdX sat_shdY eta_B2 eta_B1;
        } in  (#,,#) [sat_shdZ sat_shei sat_shez];

GHC.Base.$fMonoid(,,,)_$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     GHC.Base.Semigroup (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [w_sheA w1_sheB w2_sheC w3_sheD]
        case GHC.Base.$w$cp1Monoid w_sheA w1_sheB w2_sheC w3_sheD of {
          (#,,#) ww1_sheF [Occ=Once]
                 ww2_sheG [Occ=Once]
                 ww3_sheH [Occ=Once] ->
              GHC.Base.C:Semigroup [ww1_sheF ww2_sheG ww3_sheH];
        };

GHC.Base.$fMonoid(,,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sheI $dMonoid1_sheJ $dMonoid2_sheK $dMonoid3_sheL]
        case
            GHC.Base.$w$cp1Monoid
                $dMonoid_sheI $dMonoid1_sheJ $dMonoid2_sheK $dMonoid3_sheL
        of
        { (#,,#) ww1_sheN [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> ww1_sheN;
        };

GHC.Base.$fMonoid(,,,)_$cmconcat
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     [(a, b, c, d)] -> (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sheQ $dMonoid1_sheR $dMonoid2_sheS $dMonoid3_sheT]
        let {
          k_sheU [Occ=OnceL, Dmd=<L,1*U(1*C(C1(U(U,U,U,U))),A,A)>]
            :: GHC.Base.Semigroup (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_sheQ $dMonoid1_sheR $dMonoid2_sheS $dMonoid3_sheT] \s []
                  case
                      GHC.Base.$w$cp1Monoid
                          $dMonoid_sheQ $dMonoid1_sheR $dMonoid2_sheS $dMonoid3_sheT
                  of
                  { (#,,#) ww1_sheW [Occ=Once]
                           ww2_sheX [Occ=Once]
                           ww3_sheY [Occ=Once] ->
                        GHC.Base.C:Semigroup [ww1_sheW ww2_sheX ww3_sheY];
                  }; } in
        let {
          k1_sheZ [Occ=OnceL!, Dmd=<L,C(C1(U(U,U,U,U)))>]
            :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [k_sheU] \u [] GHC.Base.<> k_sheU; } in
        let {
          z_shf0 [Occ=OnceL] :: a_a4xJ
          [LclId] =
              [$dMonoid_sheQ] \u [] GHC.Base.mempty $dMonoid_sheQ; } in
        let {
          z1_shf1 [Occ=OnceL] :: b_a4xK
          [LclId] =
              [$dMonoid1_sheR] \u [] GHC.Base.mempty $dMonoid1_sheR; } in
        let {
          z2_shf2 [Occ=OnceL] :: c_a4xL
          [LclId] =
              [$dMonoid2_sheS] \u [] GHC.Base.mempty $dMonoid2_sheS; } in
        let {
          z3_shf3 [Occ=OnceL] :: d_a4xM
          [LclId] =
              [$dMonoid3_sheT] \u [] GHC.Base.mempty $dMonoid3_sheT; } in
        let {
          z4_shf4 [Occ=OnceL, Dmd=<L,U(U,U,U,U)>]
            :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId, Unf=OtherCon []] =
              CCCS (,,,)! [z_shf0 z1_shf1 z2_shf2 z3_shf3]; } in
        let {
          go_shf5 [Occ=LoopBreaker]
            :: [(a_a4xJ, b_a4xK, c_a4xL, d_a4xM)]
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [k1_sheZ z4_shf4 go_shf5] \r [ds_shf6]
                  case ds_shf6 of {
                    [] -> z4_shf4;
                    : y_shf8 [Occ=Once] ys_shf9 [Occ=Once] ->
                        let {
                          sat_shfa [Occ=Once] :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
                          [LclId] =
                              [go_shf5 ys_shf9] \u [] go_shf5 ys_shf9;
                        } in  k1_sheZ y_shf8 sat_shfa;
                  };
        } in  go_shf5;

GHC.Base.$fMonoid(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c,
      GHC.Base.Monoid d) =>
     GHC.Base.Monoid (a, b, c, d)
[GblId[DFunId],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe]
        let {
          sat_shfi [Occ=Once]
            :: [(a_a4xJ, b_a4xK, c_a4xL, d_a4xM)]
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe] \u []
                  GHC.Base.$fMonoid(,,,)_$cmconcat
                      $dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe; } in
        let {
          sat_shfh [Occ=Once]
            :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
               -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe] \u []
                  GHC.Base.$fMonoid(,,,)_$cmappend
                      $dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe; } in
        let {
          sat_shfg [Occ=Once] :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe] \u []
                  GHC.Base.$fMonoid(,,,)_$cmempty
                      $dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe; } in
        let {
          sat_shff [Occ=Once]
            :: GHC.Base.Semigroup (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
          [LclId] =
              [$dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe] \u []
                  GHC.Base.$fMonoid(,,,)_$cp1Monoid
                      $dMonoid_shfb $dMonoid1_shfc $dMonoid2_shfd $dMonoid3_shfe;
        } in  GHC.Base.C:Monoid [sat_shff sat_shfg sat_shfh sat_shfi];

GHC.Base.$fMonoid(,,)_$c<> [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     (a, b, c) -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U)><S,1*U(U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shfj w1_shfk w2_shfl w3_shfm w4_shfn]
        case w3_shfm of {
          (,,) ww1_shfp [Occ=Once] ww2_shfq [Occ=Once] ww3_shfr [Occ=Once] ->
              case w4_shfn of {
                (,,) ww5_shft [Occ=Once] ww6_shfu [Occ=Once] ww7_shfv [Occ=Once] ->
                    let {
                      sat_shfy [Occ=Once] :: c_s6PF
                      [LclId] =
                          [w2_shfl ww3_shfr ww7_shfv] \u []
                              GHC.Base.<> w2_shfl ww3_shfr ww7_shfv; } in
                    let {
                      sat_shfx [Occ=Once] :: b_s6PE
                      [LclId] =
                          [w1_shfk ww2_shfq ww6_shfu] \u []
                              GHC.Base.<> w1_shfk ww2_shfq ww6_shfu; } in
                    let {
                      sat_shfw [Occ=Once] :: a_s6PD
                      [LclId] =
                          [w_shfj ww1_shfp ww5_shft] \u []
                              GHC.Base.<> w_shfj ww1_shfp ww5_shft;
                    } in  (,,) [sat_shfw sat_shfx sat_shfy];
              };
        };

GHC.Base.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     a -> b -> c -> [(a, b, c)] -> (# a, b, c #)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_shfz w1_shfA w2_shfB ww_shfC ww1_shfD ww2_shfE ww3_shfF]
        let {
          $wgo_shfG [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: a_s6Qd
               -> b_s6Qe
               -> c_s6Qf
               -> [(a_s6Qd, b_s6Qe, c_s6Qf)]
               -> (# a_s6Qd, b_s6Qe, c_s6Qf #)
          [LclId, Arity=4, Str=<L,U><L,U><L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_shfz w1_shfA w2_shfB $wgo_shfG] \r [ww4_shfH
                                                              ww5_shfI
                                                              ww6_shfJ
                                                              w3_shfK]
                  case w3_shfK of {
                    [] -> (#,,#) [ww4_shfH ww5_shfI ww6_shfJ];
                    : c1_shfM [Occ=Once!] cs_shfN [Occ=Once] ->
                        case c1_shfM of {
                          (,,) ww8_shfP [Occ=Once]
                               ww9_shfQ [Occ=Once]
                               ww10_shfR [Occ=Once] ->
                              case $wgo_shfG ww8_shfP ww9_shfQ ww10_shfR cs_shfN of {
                                (#,,#) ww12_shfT [Occ=Once]
                                       ww13_shfU [Occ=Once]
                                       ww14_shfV [Occ=Once] ->
                                    let {
                                      sat_shfY [Occ=Once] :: c_s6Qf
                                      [LclId] =
                                          [w2_shfB ww6_shfJ ww14_shfV] \u []
                                              GHC.Base.<> w2_shfB ww6_shfJ ww14_shfV; } in
                                    let {
                                      sat_shfX [Occ=Once] :: b_s6Qe
                                      [LclId] =
                                          [w1_shfA ww5_shfI ww13_shfU] \u []
                                              GHC.Base.<> w1_shfA ww5_shfI ww13_shfU; } in
                                    let {
                                      sat_shfW [Occ=Once] :: a_s6Qd
                                      [LclId] =
                                          [w_shfz ww4_shfH ww12_shfT] \u []
                                              GHC.Base.<> w_shfz ww4_shfH ww12_shfT;
                                    } in  (#,,#) [sat_shfW sat_shfX sat_shfY];
                              };
                        };
                  };
        } in  $wgo_shfG ww_shfC ww1_shfD ww2_shfE ww3_shfF;

GHC.Base.$fSemigroup(,,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     GHC.Base.NonEmpty (a, b, c) -> (a, b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U),1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_shfZ w1_shg0 w2_shg1 w3_shg2]
        case w3_shg2 of {
          GHC.Base.:| ww1_shg4 [Occ=Once!] ww2_shg5 [Occ=Once] ->
              case ww1_shg4 of {
                (,,) ww4_shg7 [Occ=Once] ww5_shg8 [Occ=Once] ww6_shg9 [Occ=Once] ->
                    case
                        GHC.Base.$w$csconcat1
                            w_shfZ w1_shg0 w2_shg1 ww4_shg7 ww5_shg8 ww6_shg9 ww2_shg5
                    of
                    { (#,,#) ww8_shgb [Occ=Once]
                             ww9_shgc [Occ=Once]
                             ww10_shgd [Occ=Once] ->
                          (,,) [ww8_shgb ww9_shgc ww10_shgd];
                    };
              };
        };

GHC.Base.$fMonoid(,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     (a, b, c) -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U,U)><S,1*U(U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shge
           $dMonoid1_shgf
           $dMonoid2_shgg
           eta_shgh
           eta1_shgi]
        case eta_shgh of {
          (,,) a1_shgk [Occ=Once] b1_shgl [Occ=Once] c1_shgm [Occ=Once] ->
              case eta1_shgi of {
                (,,) a'_shgo [Occ=Once] b'_shgp [Occ=Once] c'_shgq [Occ=Once] ->
                    let {
                      sat_shgw [Occ=Once] :: c_a4yl
                      [LclId] =
                          [$dMonoid2_shgg c1_shgm c'_shgq] \u []
                              case GHC.Base.$p1Monoid $dMonoid2_shgg of sat_shgv {
                                __DEFAULT -> GHC.Base.<> sat_shgv c1_shgm c'_shgq;
                              }; } in
                    let {
                      sat_shgu [Occ=Once] :: b_a4yk
                      [LclId] =
                          [$dMonoid1_shgf b1_shgl b'_shgp] \u []
                              case GHC.Base.$p1Monoid $dMonoid1_shgf of sat_shgt {
                                __DEFAULT -> GHC.Base.<> sat_shgt b1_shgl b'_shgp;
                              }; } in
                    let {
                      sat_shgs [Occ=Once] :: a_a4yj
                      [LclId] =
                          [$dMonoid_shge a1_shgk a'_shgo] \u []
                              case GHC.Base.$p1Monoid $dMonoid_shge of sat_shgr {
                                __DEFAULT -> GHC.Base.<> sat_shgr a1_shgk a'_shgo;
                              };
                    } in  (,,) [sat_shgs sat_shgu sat_shgw];
              };
        };

GHC.Base.$fMonoid(,,)_$cmconcat
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     [(a, b, c)] -> (a, b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shgx $dMonoid1_shgy $dMonoid2_shgz eta_shgA]
        let {
          $dSemigroup_shgB [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_a4yj
          [LclId] =
              [$dMonoid_shgx] \u [] GHC.Base.$p1Monoid $dMonoid_shgx; } in
        let {
          $dSemigroup1_shgC [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup b_a4yk
          [LclId] =
              [$dMonoid1_shgy] \u [] GHC.Base.$p1Monoid $dMonoid1_shgy; } in
        let {
          $dSemigroup2_shgD [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup c_a4yl
          [LclId] =
              [$dMonoid2_shgz] \u [] GHC.Base.$p1Monoid $dMonoid2_shgz; } in
        let {
          z_shgE [Occ=OnceL] :: a_a4yj
          [LclId] =
              [$dMonoid_shgx] \u [] GHC.Base.mempty $dMonoid_shgx; } in
        let {
          z1_shgF [Occ=OnceL] :: b_a4yk
          [LclId] =
              [$dMonoid1_shgy] \u [] GHC.Base.mempty $dMonoid1_shgy; } in
        let {
          z2_shgG [Occ=OnceL] :: c_a4yl
          [LclId] =
              [$dMonoid2_shgz] \u [] GHC.Base.mempty $dMonoid2_shgz; } in
        let {
          z3_shgH [Occ=OnceL, Dmd=<S,U(U,U,U)>] :: (a_a4yj, b_a4yk, c_a4yl)
          [LclId, Unf=OtherCon []] =
              CCCS (,,)! [z_shgE z1_shgF z2_shgG]; } in
        let {
          go_shgI [Occ=LoopBreaker]
            :: [(a_a4yj, b_a4yk, c_a4yl)] -> (a_a4yj, b_a4yk, c_a4yl)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dSemigroup_shgB
                        $dSemigroup1_shgC
                        $dSemigroup2_shgD
                        z3_shgH
                        go_shgI] \r [ds_shgJ]
                  case ds_shgJ of {
                    [] -> z3_shgH;
                    : y_shgL [Occ=Once!] ys_shgM [Occ=Once] ->
                        case y_shgL of {
                          (,,) a1_shgO [Occ=Once] b1_shgP [Occ=Once] c1_shgQ [Occ=Once] ->
                              case go_shgI ys_shgM of {
                                (,,) a'_shgS [Occ=Once] b'_shgT [Occ=Once] c'_shgU [Occ=Once] ->
                                    let {
                                      sat_shgX [Occ=Once] :: c_a4yl
                                      [LclId] =
                                          [$dSemigroup2_shgD c1_shgQ c'_shgU] \u []
                                              GHC.Base.<> $dSemigroup2_shgD c1_shgQ c'_shgU; } in
                                    let {
                                      sat_shgW [Occ=Once] :: b_a4yk
                                      [LclId] =
                                          [$dSemigroup1_shgC b1_shgP b'_shgT] \u []
                                              GHC.Base.<> $dSemigroup1_shgC b1_shgP b'_shgT; } in
                                    let {
                                      sat_shgV [Occ=Once] :: a_a4yj
                                      [LclId] =
                                          [$dSemigroup_shgB a1_shgO a'_shgS] \u []
                                              GHC.Base.<> $dSemigroup_shgB a1_shgO a'_shgS;
                                    } in  (,,) [sat_shgV sat_shgW sat_shgX];
                              };
                        };
                  };
        } in  go_shgI eta_shgA;

GHC.Base.$fSemigroup(,,)_$cstimes [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     forall b1. GHC.Real.Integral b1 => b1 -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shgY w1_shgZ w2_shh0 w3_shh1 w4_shh2 w5_shh3]
        case w5_shh3 of {
          (,,) ww1_shh5 [Occ=Once] ww2_shh6 [Occ=Once] ww3_shh7 [Occ=Once] ->
              let {
                sat_shha [Occ=Once] :: c_s6QJ
                [LclId] =
                    [w2_shh0 w3_shh1 w4_shh2 ww3_shh7] \u []
                        GHC.Base.stimes w2_shh0 w3_shh1 w4_shh2 ww3_shh7; } in
              let {
                sat_shh9 [Occ=Once] :: b_s6QI
                [LclId] =
                    [w1_shgZ w3_shh1 w4_shh2 ww2_shh6] \u []
                        GHC.Base.stimes w1_shgZ w3_shh1 w4_shh2 ww2_shh6; } in
              let {
                sat_shh8 [Occ=Once] :: a_s6QH
                [LclId] =
                    [w_shgY w3_shh1 w4_shh2 ww1_shh5] \u []
                        GHC.Base.stimes w_shgY w3_shh1 w4_shh2 ww1_shh5;
              } in  (,,) [sat_shh8 sat_shh9 sat_shha];
        };

GHC.Base.$fSemigroup(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
      GHC.Base.Semigroup c) =>
     GHC.Base.Semigroup (a, b, c)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_shhb $dSemigroup1_shhc $dSemigroup2_shhd]
        let {
          sat_shhg [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> (a_a4Dq, b_a4Dr, c_a4Ds) -> (a_a4Dq, b_a4Dr, c_a4Ds)
          [LclId] =
              [$dSemigroup_shhb $dSemigroup1_shhc $dSemigroup2_shhd] \r [eta_B3
                                                                         eta_B2
                                                                         eta_B1]
                  GHC.Base.$fSemigroup(,,)_$cstimes
                      $dSemigroup_shhb
                      $dSemigroup1_shhc
                      $dSemigroup2_shhd
                      eta_B3
                      eta_B2
                      eta_B1; } in
        let {
          sat_shhf [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4Dq, b_a4Dr, c_a4Ds)
               -> (a_a4Dq, b_a4Dr, c_a4Ds)
          [LclId] =
              [$dSemigroup_shhb $dSemigroup1_shhc $dSemigroup2_shhd] \r [eta_B1]
                  GHC.Base.$fSemigroup(,,)_$csconcat
                      $dSemigroup_shhb $dSemigroup1_shhc $dSemigroup2_shhd eta_B1; } in
        let {
          sat_shhe [Occ=Once]
            :: (a_a4Dq, b_a4Dr, c_a4Ds)
               -> (a_a4Dq, b_a4Dr, c_a4Ds) -> (a_a4Dq, b_a4Dr, c_a4Ds)
          [LclId] =
              [$dSemigroup_shhb $dSemigroup1_shhc $dSemigroup2_shhd] \r [eta_B2
                                                                         eta_B1]
                  GHC.Base.$fMonoid(,,)_$c<>
                      $dSemigroup_shhb $dSemigroup1_shhc $dSemigroup2_shhd eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_shhe sat_shhf sat_shhg];

GHC.Base.$fMonoid(,,)_$cp1Monoid
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     GHC.Base.Semigroup (a, b, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shhh $dMonoid1_shhi $dMonoid2_shhj]
        let {
          sat_shhm [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup c_a4yl
          [LclId] =
              [$dMonoid2_shhj] \u [] GHC.Base.$p1Monoid $dMonoid2_shhj; } in
        let {
          sat_shhl [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_a4yk
          [LclId] =
              [$dMonoid1_shhi] \u [] GHC.Base.$p1Monoid $dMonoid1_shhi; } in
        let {
          sat_shhk [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_a4yj
          [LclId] =
              [$dMonoid_shhh] \u [] GHC.Base.$p1Monoid $dMonoid_shhh;
        } in  GHC.Base.$fSemigroup(,,) sat_shhk sat_shhl sat_shhm;

GHC.Base.$fMonoid(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c.
     (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) =>
     GHC.Base.Monoid (a, b, c)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp]
        let {
          sat_shht [Occ=Once]
            :: [(a_a4yj, b_a4yk, c_a4yl)] -> (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp] \r [eta_B1]
                  GHC.Base.$fMonoid(,,)_$cmconcat
                      $dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp eta_B1; } in
        let {
          sat_shhs [Occ=Once]
            :: (a_a4yj, b_a4yk, c_a4yl)
               -> (a_a4yj, b_a4yk, c_a4yl) -> (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,,)_$cmappend
                      $dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp eta_B2 eta_B1; } in
        let {
          sat_shhr [Occ=Once] :: (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp] \u []
                  GHC.Base.$fMonoid(,,)_$cmempty
                      $dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp; } in
        let {
          sat_shhq [Occ=Once] :: GHC.Base.Semigroup (a_a4yj, b_a4yk, c_a4yl)
          [LclId] =
              [$dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp] \u []
                  GHC.Base.$fMonoid(,,)_$cp1Monoid
                      $dMonoid_shhn $dMonoid1_shho $dMonoid2_shhp;
        } in  GHC.Base.C:Monoid [sat_shhq sat_shhr sat_shhs sat_shht];

GHC.Base.$fSemigroup(,)_$c<>
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     (a, b) -> (a, b) -> (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_shhu $dSemigroup1_shhv ds_shhw ds1_shhx]
        case ds_shhw of {
          (,) a1_shhz [Occ=Once] b1_shhA [Occ=Once] ->
              case ds1_shhx of {
                (,) a'_shhC [Occ=Once] b'_shhD [Occ=Once] ->
                    let {
                      sat_shhF [Occ=Once] :: b_a4E7
                      [LclId] =
                          [$dSemigroup1_shhv b1_shhA b'_shhD] \u []
                              GHC.Base.<> $dSemigroup1_shhv b1_shhA b'_shhD; } in
                    let {
                      sat_shhE [Occ=Once] :: a_a4E6
                      [LclId] =
                          [$dSemigroup_shhu a1_shhz a'_shhC] \u []
                              GHC.Base.<> $dSemigroup_shhu a1_shhz a'_shhC;
                    } in  (,) [sat_shhE sat_shhF];
              };
        };

GHC.Base.$fSemigroup(,)_$cstimes
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     forall b1. GHC.Real.Integral b1 => b1 -> (a, b) -> (a, b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_shhG
           $dSemigroup1_shhH
           $dIntegral_shhI
           n_shhJ
           ds_shhK]
        case ds_shhK of {
          (,) a1_shhM [Occ=Once] b2_shhN [Occ=Once] ->
              let {
                sat_shhP [Occ=Once] :: b_a4E7
                [LclId] =
                    [$dSemigroup1_shhH $dIntegral_shhI n_shhJ b2_shhN] \u []
                        GHC.Base.stimes
                            $dSemigroup1_shhH $dIntegral_shhI n_shhJ b2_shhN; } in
              let {
                sat_shhO [Occ=Once] :: a_a4E6
                [LclId] =
                    [$dSemigroup_shhG $dIntegral_shhI n_shhJ a1_shhM] \u []
                        GHC.Base.stimes $dSemigroup_shhG $dIntegral_shhI n_shhJ a1_shhM;
              } in  (,) [sat_shhO sat_shhP];
        };

GHC.Base.$fSemigroup(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
     GHC.Base.Semigroup (a, b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_shhQ $dSemigroup1_shhR]
        let {
          sat_shhU [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7)
          [LclId] =
              [$dSemigroup_shhQ $dSemigroup1_shhR] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(,)_$cstimes
                      $dSemigroup_shhQ $dSemigroup1_shhR eta_B3 eta_B2 eta_B1; } in
        let {
          sat_shhT [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7)
          [LclId] =
              [$dSemigroup_shhQ $dSemigroup1_shhR] \r [eta_B1]
                  GHC.Base.$fSemigroup(,)_$csconcat
                      $dSemigroup_shhQ $dSemigroup1_shhR eta_B1; } in
        let {
          sat_shhS [Occ=Once]
            :: (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7) -> (a_a4E6, b_a4E7)
          [LclId] =
              [$dSemigroup_shhQ $dSemigroup1_shhR] \r [eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(,)_$c<>
                      $dSemigroup_shhQ $dSemigroup1_shhR eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_shhS sat_shhT sat_shhU];

GHC.Base.$fMonoid(,)_$cp1Monoid
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     GHC.Base.Semigroup (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shhV $dMonoid1_shhW]
        let {
          sat_shhY [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_a4yQ
          [LclId] =
              [$dMonoid1_shhW] \u [] GHC.Base.$p1Monoid $dMonoid1_shhW; } in
        let {
          sat_shhX [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_a4yP
          [LclId] =
              [$dMonoid_shhV] \u [] GHC.Base.$p1Monoid $dMonoid_shhV;
        } in  GHC.Base.$fSemigroup(,) sat_shhX sat_shhY;

GHC.Base.$fMonoid(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b.
     (GHC.Base.Monoid a, GHC.Base.Monoid b) =>
     GHC.Base.Monoid (a, b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_shhZ $dMonoid1_shi0]
        let {
          sat_shi4 [Occ=Once] :: [(a_a4yP, b_a4yQ)] -> (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_shhZ $dMonoid1_shi0] \r [eta_B1]
                  GHC.Base.$fMonoid(,)_$cmconcat
                      $dMonoid_shhZ $dMonoid1_shi0 eta_B1; } in
        let {
          sat_shi3 [Occ=Once]
            :: (a_a4yP, b_a4yQ) -> (a_a4yP, b_a4yQ) -> (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_shhZ $dMonoid1_shi0] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(,)_$cmappend
                      $dMonoid_shhZ $dMonoid1_shi0 eta_B2 eta_B1; } in
        let {
          sat_shi2 [Occ=Once] :: (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_shhZ $dMonoid1_shi0] \u []
                  GHC.Base.$fMonoid(,)_$cmempty $dMonoid_shhZ $dMonoid1_shi0; } in
        let {
          sat_shi1 [Occ=Once] :: GHC.Base.Semigroup (a_a4yP, b_a4yQ)
          [LclId] =
              [$dMonoid_shhZ $dMonoid1_shi0] \u []
                  GHC.Base.$fMonoid(,)_$cp1Monoid $dMonoid_shhZ $dMonoid1_shi0;
        } in  GHC.Base.C:Monoid [sat_shi1 sat_shi2 sat_shi3 sat_shi4];

GHC.Base.$fMonoid()_$c<> :: () -> () -> ()
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_shi5 ds1_shi6] () [];

GHC.Base.$fSemigroup()_$csconcat :: GHC.Base.NonEmpty () -> ()
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_shi7] () [];

GHC.Base.$fSemigroup()_$cstimes
  :: forall b. GHC.Real.Integral b => b -> () -> ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_shi8 ds_shi9 ds1_shia] () [];

GHC.Base.$fSemigroup() [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup ()
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.$fMonoid()_$c<>
                                         GHC.Base.$fSemigroup()_$csconcat
                                         GHC.Base.$fSemigroup()_$cstimes];

GHC.Base.$fMonoid() [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid ()
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [GHC.Base.$fSemigroup()
                                      GHC.Tuple.()
                                      GHC.Base.$fMonoid()_$c<>
                                      GHC.Base.$fMonoid()_$cmconcat];

GHC.Base.$fSemigroup(->)_$c<>
  :: forall b a.
     GHC.Base.Semigroup b =>
     (a -> b) -> (a -> b) -> a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),1*U(1*C1(C1(U)),A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_shib f_shic g_shid x_shie]
        let {
          sat_shig [Occ=Once] :: b_a4EV
          [LclId] =
              [g_shid x_shie] \u [] g_shid x_shie; } in
        let {
          sat_shif [Occ=Once] :: b_a4EV
          [LclId] =
              [f_shic x_shie] \u [] f_shic x_shie;
        } in  GHC.Base.<> $dSemigroup_shib sat_shif sat_shig;

GHC.Base.$fSemigroup(->)_$cstimes
  :: forall b a.
     GHC.Base.Semigroup b =>
     forall b1. GHC.Real.Integral b1 => b1 -> (a -> b) -> a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dSemigroup_shih $dIntegral_shii n_shij f_shik e_shil]
        let {
          sat_shim [Occ=Once] :: b_a4EV
          [LclId] =
              [f_shik e_shil] \u [] f_shik e_shil;
        } in 
          GHC.Base.stimes $dSemigroup_shih $dIntegral_shii n_shij sat_shim;

GHC.Base.$fSemigroup(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall b a. GHC.Base.Semigroup b => GHC.Base.Semigroup (a -> b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_shin]
        let {
          sat_shiq [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b -> (a_a4EW -> b_a4EV) -> a_a4EW -> b_a4EV
          [LclId] =
              [$dSemigroup_shin] \r [eta_B4 eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$cstimes
                      $dSemigroup_shin eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_ship [Occ=Once]
            :: GHC.Base.NonEmpty (a_a4EW -> b_a4EV) -> a_a4EW -> b_a4EV
          [LclId] =
              [$dSemigroup_shin] \r [eta_B1]
                  GHC.Base.$fSemigroup(->)_$csconcat $dSemigroup_shin eta_B1; } in
        let {
          sat_shio [Occ=Once]
            :: (a_a4EW -> b_a4EV) -> (a_a4EW -> b_a4EV) -> a_a4EW -> b_a4EV
          [LclId] =
              [$dSemigroup_shin] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fSemigroup(->)_$c<>
                      $dSemigroup_shin eta_B3 eta_B2 eta_B1;
        } in  GHC.Base.C:Semigroup [sat_shio sat_ship sat_shiq];

GHC.Base.$fMonoid(->)_$cp1Monoid
  :: forall b a. GHC.Base.Monoid b => GHC.Base.Semigroup (a -> b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_shir]
        let {
          sat_shis [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup b_a4zA
          [LclId] =
              [$dMonoid_shir] \u [] GHC.Base.$p1Monoid $dMonoid_shir;
        } in  GHC.Base.$fSemigroup(->) sat_shis;

GHC.Base.$fMonoid(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall b a. GHC.Base.Monoid b => GHC.Base.Monoid (a -> b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_shit]
        let {
          lvl3_shiu [Occ=OnceL] :: b_a4zA
          [LclId] =
              [$dMonoid_shit] \u [] GHC.Base.mempty $dMonoid_shit; } in
        let {
          sat_shiz [Occ=Once] :: [a_a4zB -> b_a4zA] -> a_a4zB -> b_a4zA
          [LclId] =
              [$dMonoid_shit] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmconcat $dMonoid_shit eta_B2 eta_B1; } in
        let {
          sat_shiy [Occ=Once]
            :: (a_a4zB -> b_a4zA) -> (a_a4zB -> b_a4zA) -> a_a4zB -> b_a4zA
          [LclId] =
              [$dMonoid_shit] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fMonoid(->)_$cmappend
                      $dMonoid_shit eta_B3 eta_B2 eta_B1; } in
        let {
          sat_shix [Occ=Once] :: a_a4zB -> b_a4zA
          [LclId] =
              [lvl3_shiu] \r [ds_shiw] lvl3_shiu; } in
        let {
          sat_shiv [Occ=Once] :: GHC.Base.Semigroup (a_a4zB -> b_a4zA)
          [LclId] =
              [$dMonoid_shit] \u []
                  GHC.Base.$fMonoid(->)_$cp1Monoid $dMonoid_shit;
        } in  GHC.Base.C:Monoid [sat_shiv sat_shix sat_shiy sat_shiz];

GHC.Base.$fSemigroup[]_$cstimes
  :: forall a b. GHC.Real.Integral b => b -> [a] -> [a]
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [$dIntegral_shiA]
        Data.Semigroup.Internal.stimesList $dIntegral_shiA;

GHC.Base.$fSemigroup[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup [a]
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base.++
                                         GHC.Base.$fSemigroup[]_$csconcat
                                         GHC.Base.$fSemigroup[]_$cstimes];

GHC.Base.$fMonoid[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid [a]
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [GHC.Base.$fSemigroup[]
                                      GHC.Types.[]
                                      GHC.Base.++
                                      GHC.Base.$fMonoid[]_$cmconcat];

GHC.Base.$fApplicativeNonEmpty_$cpure
  :: forall a. a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [a1_shiB] GHC.Base.:| [a1_shiB GHC.Types.[]];

GHC.Base.$w$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> (# c, [c] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(U,U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_shiC w1_shiD w2_shiE]
        let {
          sat_shiM [Occ=Once] :: a_s6R1 -> GHC.Base.NonEmpty c_s6R3
          [LclId] =
              [w_shiC w2_shiE] \r [x1_shiF]
                  let {
                    sat_shiI [Occ=Once] :: b_s6R2 -> GHC.Base.NonEmpty c_s6R3
                    [LclId] =
                        [w_shiC x1_shiF] \r [x2_shiG]
                            let {
                              sat_shiH [Occ=Once] :: c_s6R3
                              [LclId] =
                                  [w_shiC x1_shiF x2_shiG] \u [] w_shiC x1_shiF x2_shiG;
                            } in  GHC.Base.:| [sat_shiH GHC.Types.[]];
                  } in 
                    case GHC.Base.$w$c>>= w2_shiE sat_shiI of {
                      (#,#) ww1_shiK [Occ=Once] ww2_shiL [Occ=Once] ->
                          GHC.Base.:| [ww1_shiK ww2_shiL];
                    };
        } in  GHC.Base.$w$c>>= w1_shiD sat_shiM;

GHC.Base.$fApplicativeNonEmpty_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.NonEmpty a
     -> GHC.Base.NonEmpty b
     -> GHC.Base.NonEmpty c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shiN w1_shiO w2_shiP]
        case GHC.Base.$w$cliftA2 w_shiN w1_shiO w2_shiP of {
          (#,#) ww1_shiR [Occ=Once] ww2_shiS [Occ=Once] ->
              GHC.Base.:| [ww1_shiR ww2_shiS];
        };

GHC.Base.$w$c<* [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> (# a, [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_shiT w1_shiU]
        let {
          sat_shj2 [Occ=Once] :: a_s6Rb -> GHC.Base.NonEmpty a_s6Rb
          [LclId] =
              [w1_shiU] \r [x1_shiV]
                  let {
                    lvl3_shiW [Occ=OnceL, Dmd=<L,U(U,U)>] :: GHC.Base.NonEmpty a_s6Rb
                    [LclId, Unf=OtherCon []] =
                        CCCS GHC.Base.:|! [x1_shiV GHC.Types.[]]; } in
                  let {
                    sat_shiY [Occ=Once] :: b_s6Rc -> GHC.Base.NonEmpty a_s6Rb
                    [LclId] =
                        [lvl3_shiW] \r [x2_shiX] lvl3_shiW;
                  } in 
                    case GHC.Base.$w$c>>= w1_shiU sat_shiY of {
                      (#,#) ww1_shj0 [Occ=Once] ww2_shj1 [Occ=Once] ->
                          GHC.Base.:| [ww1_shj0 ww2_shj1];
                    };
        } in  GHC.Base.$w$c>>= w_shiT sat_shj2;

GHC.Base.$fApplicativeNonEmpty_$c<* [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shj3 w1_shj4]
        case GHC.Base.$w$c<* w_shj3 w1_shj4 of {
          (#,#) ww1_shj6 [Occ=Once] ww2_shj7 [Occ=Once] ->
              GHC.Base.:| [ww1_shj6 ww2_shj7];
        };

GHC.Base.$w$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a -> b) -> GHC.Base.NonEmpty a -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_shj8 w1_shj9]
        let {
          sat_shjh [Occ=Once]
            :: (a_s6Rj -> b_s6Rk) -> GHC.Base.NonEmpty b_s6Rk
          [LclId] =
              [w1_shj9] \r [x1_shja]
                  let {
                    sat_shjd [Occ=Once] :: a_s6Rj -> GHC.Base.NonEmpty b_s6Rk
                    [LclId] =
                        [x1_shja] \r [x2_shjb]
                            let {
                              sat_shjc [Occ=Once] :: b_s6Rk
                              [LclId] =
                                  [x1_shja x2_shjb] \u [] x1_shja x2_shjb;
                            } in  GHC.Base.:| [sat_shjc GHC.Types.[]];
                  } in 
                    case GHC.Base.$w$c>>= w1_shj9 sat_shjd of {
                      (#,#) ww1_shjf [Occ=Once] ww2_shjg [Occ=Once] ->
                          GHC.Base.:| [ww1_shjf ww2_shjg];
                    };
        } in  GHC.Base.$w$c>>= w_shj8 sat_shjh;

GHC.Base.$fApplicativeNonEmpty_$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty (a -> b)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shji w1_shjj]
        case GHC.Base.$w$c<*> w_shji w1_shjj of {
          (#,#) ww1_shjl [Occ=Once] ww2_shjm [Occ=Once] ->
              GHC.Base.:| [ww1_shjl ww2_shjm];
        };

GHC.Base.$fApplicativeNonEmpty1 :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_shjn eta_shjo] eta_shjo;

GHC.Base.$fApplicativeNonEmpty_$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_shjp w1_shjq]
        let {
          sat_shju [Occ=Once] :: [b_s6Rs -> b_s6Rs]
          [LclId] =
              [w_shjp] \u []
                  case w_shjp of {
                    GHC.Base.:| _ [Occ=Dead] as_shjt [Occ=Once] ->
                        GHC.Base.map GHC.Base.$fApplicativeNonEmpty1 as_shjt;
                  }; } in
        let {
          sat_shjv [Occ=Once] :: GHC.Base.NonEmpty (b_s6Rs -> b_s6Rs)
          [LclId] =
              CCCS GHC.Base.:|! [GHC.Base.breakpoint sat_shju];
        } in 
          case GHC.Base.$w$c<*> sat_shjv w1_shjq of {
            (#,#) ww1_shjx [Occ=Once] ww2_shjy [Occ=Once] ->
                GHC.Base.:| [ww1_shjx ww2_shjy];
          };

GHC.Base.$fApplicativeNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.Base.NonEmpty
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctorNonEmpty
                                           GHC.Base.$fApplicativeNonEmpty_$cpure
                                           GHC.Base.$fApplicativeNonEmpty_$c<*>
                                           GHC.Base.$fApplicativeNonEmpty_$cliftA2
                                           GHC.Base.$fApplicativeNonEmpty_$c*>
                                           GHC.Base.$fApplicativeNonEmpty_$c<*];

lvl_r7PJ :: forall a. [GHC.Types.Char] -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_shjz] GHC.Err.errorWithoutStackTrace eta_shjz;

GHC.Base.$fMonadNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.Base.NonEmpty
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicativeNonEmpty
                                     GHC.Base.$fMonadNonEmpty_$c>>=
                                     GHC.Base.$fMonadNonEmpty_$c>>
                                     GHC.Base.$fApplicativeNonEmpty_$cpure
                                     lvl_r7PJ];

GHC.Base.$fAlternativeIO4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "mzero"#;

GHC.Base.$fAlternativeIO3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.Base.$fAlternativeIO4;

GHC.Base.$fAlternativeIO_$cempty :: forall a. GHC.Types.IO a
[GblId] =
    [] \u [] GHC.IO.failIO GHC.Base.$fAlternativeIO3;

GHC.Base.$fAlternativeIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [GHC.Base.$fApplicativeIO
                                           GHC.Base.$fAlternativeIO_$cempty
                                           GHC.IO.mplusIO
                                           GHC.Base.$fAlternativeIO2
                                           GHC.Base.$fAlternativeIO_$cmany];

GHC.Base.$fMonadPlusIO [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus GHC.Types.IO
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [GHC.Base.$fAlternativeIO
                                         GHC.Base.$fMonadIO
                                         GHC.Base.$fAlternativeIO_$cempty
                                         GHC.IO.mplusIO];

GHC.Base.$fAlternativeMaybe_$c<|>
  :: forall a.
     GHC.Base.Maybe a -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_shjA r_shjB]
        case ds_shjA of wild_shjC {
          GHC.Base.Nothing -> r_shjB;
          GHC.Base.Just _ [Occ=Dead] -> wild_shjC;
        };

GHC.Base.$fApplicativeMaybe_$cliftA2
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_shjE ds_shjF ds1_shjG]
        case ds_shjF of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_shjI [Occ=Once] ->
              case ds1_shjG of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just y_shjK [Occ=Once] ->
                    let {
                      sat_shjL [Occ=Once] :: c_a4L9
                      [LclId] =
                          [f_shjE x_shjI y_shjK] \u [] f_shjE x_shjI y_shjK;
                    } in  GHC.Base.Just [sat_shjL];
              };
        };

GHC.Base.$fApplicativeMaybe_$c*>
  :: forall a b.
     GHC.Base.Maybe a -> GHC.Base.Maybe b -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_shjM m2_shjN]
        case ds_shjM of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just _ [Occ=Dead] -> m2_shjN;
        };

GHC.Base.$fApplicative(->)_$c<*>
  :: forall a1 a2 b. (a1 -> a2 -> b) -> (a1 -> a2) -> a1 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_shjQ g_shjR x_shjS]
        let {
          sat_shjT [Occ=Once] :: a1_a4LL
          [LclId] =
              [g_shjR x_shjS] \u [] g_shjR x_shjS;
        } in  f_shjQ x_shjS sat_shjT;

GHC.Base.$fApplicative(->)_$cliftA2
  :: forall a1 a2 b c.
     (a2 -> b -> c) -> (a1 -> a2) -> (a1 -> b) -> a1 -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [q_shjU f_shjV g_shjW x_shjX]
        let {
          sat_shjZ [Occ=Once] :: b_a4LS
          [LclId] =
              [g_shjW x_shjX] \u [] g_shjW x_shjX; } in
        let {
          sat_shjY [Occ=Once] :: a1_a4LR
          [LclId] =
              [f_shjV x_shjX] \u [] f_shjV x_shjX;
        } in  q_shjU sat_shjY sat_shjZ;

GHC.Base.$fApplicative(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Applicative ((->) a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctor(->)
                                           GHC.Base.const
                                           GHC.Base.$fApplicative(->)_$c<*>
                                           GHC.Base.$fApplicative(->)_$cliftA2
                                           GHC.Base.$fApplicative(->)_$c*>
                                           GHC.Base.$fApplicative(->)_$c<*];

lvl1_r7PK :: forall r a. [GHC.Types.Char] -> r -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_shk0] GHC.Err.errorWithoutStackTrace eta_shk0;

GHC.Base.$fMonad(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall r. GHC.Base.Monad ((->) r)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicative(->)
                                     GHC.Base.$fMonad(->)_$c>>=
                                     GHC.Base.$fMonad(->)_$c>>
                                     GHC.Base.const
                                     lvl1_r7PK];

GHC.Base.$fApplicativeMaybe_$cfmap
  :: forall a b. (a -> b) -> GHC.Base.Maybe a -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_shk1 ds1_shk2]
        case ds1_shk2 of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_shk4 [Occ=Once] ->
              let {
                sat_shk5 [Occ=Once] :: b_a4MF
                [LclId] =
                    [ds_shk1 a1_shk4] \u [] ds_shk1 a1_shk4;
              } in  GHC.Base.Just [sat_shk5];
        };

GHC.Base.$fFunctorMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       GHC.Base.$fFunctorMaybe_$c<$];

GHC.Base.$fApplicativeMaybe_$c<*>
  :: forall a b.
     GHC.Base.Maybe (a -> b) -> GHC.Base.Maybe a -> GHC.Base.Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_shk6 m_shk7]
        case ds_shk6 of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just f_shk9 [Occ=Once] ->
              GHC.Base.$fApplicativeMaybe_$cfmap f_shk9 m_shk7;
        };

GHC.Base.$fApplicativeMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [GHC.Base.$fFunctorMaybe
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           GHC.Base.$fApplicativeMaybe_$c*>
                                           GHC.Base.$fApplicativeMaybe_$c<*];

GHC.Base.$fMonadMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [GHC.Base.$fApplicativeMaybe
                                     GHC.Base.$fMonadMaybe_$c>>=
                                     GHC.Base.$fApplicativeMaybe_$c*>
                                     GHC.Base.Just
                                     GHC.Base.$fMonadMaybe_$cfail];

GHC.Base.$fAlternativeMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Alternative GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Alternative! [GHC.Base.$fApplicativeMaybe
                                           GHC.Base.Nothing
                                           GHC.Base.$fAlternativeMaybe_$c<|>
                                           GHC.Base.$fAlternativeMaybe_$csome
                                           GHC.Base.$fAlternativeMaybe_$cmany];

GHC.Base.$fMonadPlusMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.MonadPlus GHC.Base.Maybe
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:MonadPlus! [GHC.Base.$fAlternativeMaybe
                                         GHC.Base.$fMonadMaybe
                                         GHC.Base.Nothing
                                         GHC.Base.$fAlternativeMaybe_$c<|>];

GHC.Base.liftA3_$sliftA3 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> GHC.Base.Maybe a1
     -> GHC.Base.Maybe a2
     -> GHC.Base.Maybe a3
     -> GHC.Base.Maybe r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_shka a_shkb b_shkc c_shkd]
        case a_shkb of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just x_shkf [Occ=Once] ->
              case b_shkc of {
                GHC.Base.Nothing -> GHC.Base.Nothing [];
                GHC.Base.Just y_shkh [Occ=Once] ->
                    case c_shkd of {
                      GHC.Base.Nothing -> GHC.Base.Nothing [];
                      GHC.Base.Just a4_shkj [Occ=Once] ->
                          let {
                            sat_shkk [Occ=Once] :: r_a4gI
                            [LclId] =
                                [f_shka x_shkf y_shkh a4_shkj] \u [] f_shka x_shkf y_shkh a4_shkj;
                          } in  GHC.Base.Just [sat_shkk];
                    };
              };
        };

GHC.Base.liftA3 [InlPrag=INLINABLE]
  :: forall (f :: * -> *) a b c d.
     GHC.Base.Applicative f =>
     (a -> b -> c -> d) -> f a -> f b -> f c -> f d
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(A,A,1*C1(C1(U)),1*C1(C1(C1(U))),A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_shkl f1_shkm a1_shkn b1_shko c1_shkp]
        let {
          sat_shkq [Occ=Once] :: f_a4f9 (c_a4fc -> d_a4fd)
          [LclId] =
              [$dApplicative_shkl f1_shkm a1_shkn b1_shko] \u []
                  GHC.Base.liftA2 $dApplicative_shkl f1_shkm a1_shkn b1_shko;
        } in  GHC.Base.<*> $dApplicative_shkl sat_shkq c1_shkp;

GHC.Base.liftA_$sliftA [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> GHC.Base.Maybe a1 -> GHC.Base.Maybe r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Base.$fApplicativeMaybe_$cfmap eta_B2 eta_B1;

GHC.Base.liftA [InlPrag=INLINABLE]
  :: forall (f :: * -> *) a b.
     GHC.Base.Applicative f =>
     (a -> b) -> f a -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(A,1*C1(U),1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dApplicative_shkr f1_shks a1_shkt]
        let {
          sat_shku [Occ=Once] :: f_a4gQ (a_a4gR -> b_a4gS)
          [LclId] =
              [$dApplicative_shkr f1_shks] \u []
                  GHC.Base.pure $dApplicative_shkr f1_shks;
        } in  GHC.Base.<*> $dApplicative_shkr sat_shku a1_shkt;

GHC.Base.$fFunctor(,)_$cfmap
  :: forall a1 a2 b. (a2 -> b) -> (a1, a2) -> (a1, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_shkv ds_shkw]
        case ds_shkw of {
          (,) x_shky [Occ=Once] y_shkz [Occ=Once] ->
              let {
                sat_shkA [Occ=Once] :: b_a4N0
                [LclId] =
                    [f_shkv y_shkz] \u [] f_shkv y_shkz;
              } in  (,) [x_shky sat_shkA];
        };

GHC.Base.$fFunctor(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Functor ((,) a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fFunctor(,)_$cfmap
                                       GHC.Base.$fFunctor(,)_$c<$];

GHC.Base.$fApplicative(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid a => GHC.Base.Applicative ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,A),1*U,A,A)>m] =
    [] \r [$dMonoid_shkB]
        let {
          lvl3_shkC [Occ=OnceL] :: a_a4vv
          [LclId] =
              [$dMonoid_shkB] \u [] GHC.Base.mempty $dMonoid_shkB; } in
        let {
          sat_shkI [Occ=Once]
            :: forall a b. (a_a4vv, a) -> (a_a4vv, b) -> (a_a4vv, a)
          [LclId] =
              [$dMonoid_shkB] \r [eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$c<* $dMonoid_shkB eta_B2 eta_B1; } in
        let {
          sat_shkH [Occ=Once]
            :: forall a b. (a_a4vv, a) -> (a_a4vv, b) -> (a_a4vv, b)
          [LclId] =
              [$dMonoid_shkB] \r [eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$c*> $dMonoid_shkB eta_B2 eta_B1; } in
        let {
          sat_shkG [Occ=Once]
            :: forall a b c.
               (a -> b -> c) -> (a_a4vv, a) -> (a_a4vv, b) -> (a_a4vv, c)
          [LclId] =
              [$dMonoid_shkB] \r [eta_B3 eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$cliftA2
                      $dMonoid_shkB eta_B3 eta_B2 eta_B1; } in
        let {
          sat_shkF [Occ=Once]
            :: forall a b. (a_a4vv, a -> b) -> (a_a4vv, a) -> (a_a4vv, b)
          [LclId] =
              [$dMonoid_shkB] \r [eta_B2 eta_B1]
                  GHC.Base.$fApplicative(,)_$c<*> $dMonoid_shkB eta_B2 eta_B1; } in
        let {
          sat_shkE [Occ=Once] :: forall a. a -> (a_a4vv, a)
          [LclId] =
              [lvl3_shkC] \r [x_shkD] (,) [lvl3_shkC x_shkD];
        } in 
          GHC.Base.C:Applicative [GHC.Base.$fFunctor(,)
                                  sat_shkE
                                  sat_shkF
                                  sat_shkG
                                  sat_shkH
                                  sat_shkI];

lvl2_r7PL :: forall a1 a2. [GHC.Types.Char] -> (a1, a2)
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_shkJ] GHC.Err.errorWithoutStackTrace eta_shkJ;

GHC.Base.$fMonad(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid a => GHC.Base.Monad ((,) a)
[GblId[DFunId], Arity=1, Str=<L,U(U(C(C1(U)),A,A),U,A,A)>m] =
    [] \r [$dMonoid_shkK]
        let {
          lvl3_shkL [Occ=OnceL] :: a_a4ul
          [LclId] =
              [$dMonoid_shkK] \u [] GHC.Base.mempty $dMonoid_shkK; } in
        let {
          sat_shkQ [Occ=Once] :: forall a. a -> (a_a4ul, a)
          [LclId] =
              [lvl3_shkL] \r [x_shkP] (,) [lvl3_shkL x_shkP]; } in
        let {
          sat_shkO [Occ=Once]
            :: forall a b. (a_a4ul, a) -> (a_a4ul, b) -> (a_a4ul, b)
          [LclId] =
              [$dMonoid_shkK] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonad(,)_$c>> $dMonoid_shkK eta_B2 eta_B1; } in
        let {
          sat_shkN [Occ=Once]
            :: forall a b. (a_a4ul, a) -> (a -> (a_a4ul, b)) -> (a_a4ul, b)
          [LclId] =
              [$dMonoid_shkK] \r [eta_B2 eta_B1]
                  GHC.Base.$fMonad(,)_$c>>= $dMonoid_shkK eta_B2 eta_B1; } in
        let {
          sat_shkM [Occ=Once] :: GHC.Base.Applicative ((,) a_a4ul)
          [LclId] =
              [$dMonoid_shkK] \u [] GHC.Base.$fApplicative(,) $dMonoid_shkK;
        } in 
          GHC.Base.C:Monad [sat_shkM sat_shkN sat_shkO sat_shkQ lvl2_r7PL];

GHC.Base.C:Monad
  :: forall (m :: * -> *).
     GHC.Base.Applicative m =>
     (forall a b. m a -> (a -> m b) -> m b)
     -> (forall a b. m a -> m b -> m b)
     -> (forall a. a -> m a)
     -> (forall a. GHC.Base.String -> m a)
     -> GHC.Base.Monad m
[GblId[DataCon],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Monad [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.C:Functor
  :: forall (f :: * -> *).
     (forall a b. (a -> b) -> f a -> f b)
     -> (forall a b. a -> f b -> f a) -> GHC.Base.Functor f
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.C:Functor [eta_B2 eta_B1];

GHC.Base.C:Applicative
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     (forall a. a -> f a)
     -> (forall a b. f (a -> b) -> f a -> f b)
     -> (forall a b c. (a -> b -> c) -> f a -> f b -> f c)
     -> (forall a b. f a -> f b -> f b)
     -> (forall a b. f a -> f b -> f a)
     -> GHC.Base.Applicative f
[GblId[DataCon],
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Applicative [eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.C:Semigroup
  :: forall a.
     (a -> a -> a)
     -> (GHC.Base.NonEmpty a -> a)
     -> (forall b. GHC.Real.Integral b => b -> a -> a)
     -> GHC.Base.Semigroup a
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Semigroup [eta_B3 eta_B2 eta_B1];

GHC.Base.C:Monoid
  :: forall a.
     GHC.Base.Semigroup a =>
     a -> (a -> a -> a) -> ([a] -> a) -> GHC.Base.Monoid a
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Monoid [eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.Nothing :: forall a. GHC.Base.Maybe a
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Base.Nothing! [];

GHC.Base.Just :: forall a. a -> GHC.Base.Maybe a
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.Just [eta_B1];

GHC.Base.O :: forall a. a -> GHC.Base.Opaque
[GblId[DataCon],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.O [eta_B1];

GHC.Base.:| :: forall a. a -> [a] -> GHC.Base.NonEmpty a
[GblId[DataCon],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.:| [eta_B2 eta_B1];

GHC.Base.C:MonadPlus
  :: forall (m :: * -> *).
     (GHC.Base.Alternative m, GHC.Base.Monad m) =>
     (forall a. m a)
     -> (forall a. m a -> m a -> m a) -> GHC.Base.MonadPlus m
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:MonadPlus [eta_B4 eta_B3 eta_B2 eta_B1];

GHC.Base.C:Alternative
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     (forall a. f a)
     -> (forall a. f a -> f a -> f a)
     -> (forall a. f a -> f [a])
     -> (forall a. f a -> f [a])
     -> GHC.Base.Alternative f
[GblId[DataCon],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        GHC.Base.C:Alternative [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1];

