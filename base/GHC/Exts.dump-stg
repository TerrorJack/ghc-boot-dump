
==================== Pre unarise: ====================
2018-03-16 16:11:11.010430905 UTC

GHC.Exts.fromList
  :: forall l. GHC.Exts.IsList l => [GHC.Exts.Item l] -> l
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sftgD]
        case v_sftgD of {
          GHC.Exts.C:IsList v_sftgF [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
              v_sftgF;
        };

GHC.Exts.fromListN
  :: forall l.
     GHC.Exts.IsList l =>
     GHC.Types.Int -> [GHC.Exts.Item l] -> l
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sftgI]
        case v_sftgI of {
          GHC.Exts.C:IsList _ [Occ=Dead] v_sftgL [Occ=Once] _ [Occ=Dead] ->
              v_sftgL;
        };

GHC.Exts.toList
  :: forall l. GHC.Exts.IsList l => l -> [GHC.Exts.Item l]
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sftgN]
        case v_sftgN of {
          GHC.Exts.C:IsList _ [Occ=Dead] _ [Occ=Dead] v_sftgR [Occ=Once] ->
              v_sftgR;
        };

GHC.Exts.$fIsListNonEmpty1 :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_sftgS]
        let {
          sat_sfth0 [Occ=Once] :: [a_afsY2]
          [LclId] =
              [ds_sftgS] \u []
                  case ds_sftgS of {
                    GHC.Base.:| _ [Occ=Dead] as_sftgZ [Occ=Once] -> as_sftgZ;
                  }; } in
        let {
          sat_sftgW [Occ=Once] :: a_afsY2
          [LclId] =
              [ds_sftgS] \u []
                  case ds_sftgS of {
                    GHC.Base.:| a1_sftgU [Occ=Once] _ [Occ=Dead] -> a1_sftgU;
                  };
        } in  : [sat_sftgW sat_sfth0];

lvl_rftgk :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty.fromList: empty list"#;

GHC.Exts.$fIsListNonEmpty2 :: forall a. GHC.Base.NonEmpty a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rftgk of sat_sfth1 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfth1;
        };

GHC.Exts.$fIsListNonEmpty_$cfromList
  :: forall a.
     [GHC.Exts.Item (GHC.Base.NonEmpty a)] -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sfth2]
        case ds_sfth2 of {
          [] -> GHC.Exts.$fIsListNonEmpty2;
          : a1_sfth4 [Occ=Once] as_sfth5 [Occ=Once] ->
              GHC.Base.:| [a1_sfth4 as_sfth5];
        };

GHC.Exts.$fEqSpecConstrAnnotation_$c==
  :: GHC.Exts.SpecConstrAnnotation
     -> GHC.Exts.SpecConstrAnnotation -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfth6 ds1_sfth7]
        case ds_sfth6 of {
          GHC.Exts.NoSpecConstr ->
              case ds1_sfth7 of {
                GHC.Exts.NoSpecConstr -> GHC.Types.True [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.False [];
              };
          GHC.Exts.ForceSpecConstr ->
              case ds1_sfth7 of {
                GHC.Exts.NoSpecConstr -> GHC.Types.False [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.True [];
              };
        };

GHC.Exts.$fEqSpecConstrAnnotation_$c/= [InlPrag=INLINE (sat-args=2)]
  :: GHC.Exts.SpecConstrAnnotation
     -> GHC.Exts.SpecConstrAnnotation -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_sfthb eta1_sfthc]
        case eta_sfthb of {
          GHC.Exts.NoSpecConstr ->
              case eta1_sfthc of {
                GHC.Exts.NoSpecConstr -> GHC.Types.False [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.True [];
              };
          GHC.Exts.ForceSpecConstr ->
              case eta1_sfthc of {
                GHC.Exts.NoSpecConstr -> GHC.Types.True [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.False [];
              };
        };

GHC.Exts.$fEqSpecConstrAnnotation [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq GHC.Exts.SpecConstrAnnotation
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Exts.$fEqSpecConstrAnnotation_$c==
                                     GHC.Exts.$fEqSpecConstrAnnotation_$c/=];

GHC.Exts.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r)
     -> Data.Data.ConstrRep
     -> Data.Data.DataType
     -> c GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [w_sfthg ww_sfthh ww1_sfthi]
        case ww_sfthh of {
          __DEFAULT ->
              case ww1_sfthi of {
                Data.Data.DataType ww7_sfthl [Occ=Once] _ [Occ=Dead] ->
                    Data.Data.$wlvl ww7_sfthl;
              };
          Data.Data.AlgConstr idx_sftho [Occ=Once!] ->
              case idx_sftho of {
                GHC.Types.I# ds_sfthq [Occ=Once!] ->
                    case ds_sfthq of {
                      __DEFAULT -> w_sfthg GHC.Exts.ForceSpecConstr;
                      1# -> w_sfthg GHC.Exts.NoSpecConstr;
                    };
              };
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=OtherCon []] =
    [] \r [w_sfths w5_sftht w6_sfthu]
        case w6_sfthu of {
          Data.Data.Constr ww1_sfthw [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           ww5_sfthA [Occ=Once] ->
              GHC.Exts.$w$cgunfold w5_sftht ww1_sfthw ww5_sfthA;
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> GHC.Exts.SpecConstrAnnotation
     -> c GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sfthB z_sfthC ds_sfthD]
        case ds_sfthD of {
          GHC.Exts.NoSpecConstr -> z_sfthC GHC.Exts.NoSpecConstr;
          GHC.Exts.ForceSpecConstr -> z_sfthC GHC.Exts.ForceSpecConstr;
        };

GHC.Exts.$dmfromListN
  :: forall l.
     GHC.Exts.IsList l =>
     GHC.Types.Int -> [GHC.Exts.Item l] -> l
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLL),1*U(1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dIsList_sfthF ds_sfthG] GHC.Exts.fromList $dIsList_sfthF;

GHC.Exts.$fIsListCallStack1
  :: GHC.Types.Int
     -> [([GHC.Types.Char], GHC.Stack.Types.SrcLoc)]
     -> GHC.Stack.Types.CallStack
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfthH eta_B1] GHC.Stack.Types.fromCallSiteList eta_B1;

GHC.Exts.$fIsListCallStack [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Exts.IsList GHC.Stack.Types.CallStack
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [GHC.Stack.Types.fromCallSiteList
                                      GHC.Exts.$fIsListCallStack1
                                      GHC.Stack.Types.getCallStack];

GHC.Exts.$fIsListVersion1
  :: GHC.Types.Int -> [GHC.Types.Int] -> Data.Version.Version
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfthI eta_B1] Data.Version.makeVersion eta_B1;

GHC.Exts.$fIsListVersion [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Exts.IsList Data.Version.Version
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [Data.Version.makeVersion
                                      GHC.Exts.$fIsListVersion1
                                      Data.Version.versionBranch];

GHC.Exts.$fIsListNonEmpty_$cfromListN
  :: forall a.
     GHC.Types.Int
     -> [GHC.Exts.Item (GHC.Base.NonEmpty a)] -> GHC.Base.NonEmpty a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfthJ eta_B1]
        GHC.Exts.$fIsListNonEmpty_$cfromList eta_B1;

GHC.Exts.$fIsListNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Exts.IsList (GHC.Base.NonEmpty a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [GHC.Exts.$fIsListNonEmpty_$cfromList
                                      GHC.Exts.$fIsListNonEmpty_$cfromListN
                                      GHC.Exts.$fIsListNonEmpty1];

GHC.Exts.$fIsList[]1 :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfthK eta_B1] GHC.Base.id eta_B1;

GHC.Exts.$fIsList[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Exts.IsList [a]
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [GHC.Base.id
                                      GHC.Exts.$fIsList[]1
                                      GHC.Base.id];

GHC.Exts.maxTupleSize :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [62#];

lvl1_rftgl :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Exts.the: empty list"#;

GHC.Exts.the2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rftgl of sat_sfthL {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfthL;
        };

lvl2_rftgm :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Exts.the: non-identical elements"#;

GHC.Exts.the1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rftgm of sat_sfthM {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfthM;
        };

GHC.Exts.the :: forall a. GHC.Classes.Eq a => [a] -> a
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfthN ds_sfthO]
        case ds_sfthO of {
          [] -> GHC.Exts.the2;
          : x_sfthQ xs_sfthR [Occ=Once] ->
              let {
                sat_sfthS [Occ=Once, Dmd=<L,C(U)>] :: a_afsTA -> GHC.Types.Bool
                [LclId] =
                    [$dEq_sfthN x_sfthQ] \u [] GHC.Classes.== $dEq_sfthN x_sfthQ;
              } in 
                case GHC.List.all sat_sfthS xs_sfthR of {
                  GHC.Types.False -> GHC.Exts.the1;
                  GHC.Types.True -> x_sfthQ;
                };
        };

GHC.Exts.sortWith
  :: forall b a. GHC.Classes.Ord b => (a -> b) -> [a] -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,A,A,A,A,A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfthU f_sfthV eta_sfthW]
        let {
          sat_sfti1 [Occ=Once] :: a_afsTc -> a_afsTc -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfthU f_sfthV] \r [x_sfthX y_sfthY]
                  let {
                    sat_sfti0 [Occ=Once] :: b_afsTb
                    [LclId] =
                        [f_sfthV y_sfthY] \u [] f_sfthV y_sfthY; } in
                  let {
                    sat_sfthZ [Occ=Once] :: b_afsTb
                    [LclId] =
                        [f_sfthV x_sfthX] \u [] f_sfthV x_sfthX;
                  } in  GHC.Classes.compare $dOrd_sfthU sat_sfthZ sat_sfti0;
        } in  Data.OldList.sortBy sat_sfti1 eta_sfthW;

GHC.Exts.groupByFB [InlPrag=INLINE[0] (sat-args=4)]
  :: forall a lst.
     ([a] -> lst -> lst)
     -> lst -> (a -> a -> GHC.Types.Bool) -> [a] -> lst
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,C(C(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [c_sfti2 n_sfti3 eq_sfti4 xs0_sfti5]
        let {
          groupByFBCore_sfti6 [Occ=LoopBreaker] :: [a_afsSM] -> lst_afsSN
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [c_sfti2
                        n_sfti3
                        eq_sfti4
                        groupByFBCore_sfti6] \r [ds_sfti7]
                  case ds_sfti7 of {
                    [] -> n_sfti3;
                    : x_sfti9 xs_sftia [Occ=Once] ->
                        let {
                          ds1_sftib [Dmd=<L,U(1*U,1*U)>] :: ([a_afsSM], [a_afsSM])
                          [LclId] =
                              [eq_sfti4 x_sfti9 xs_sftia] \u []
                                  let {
                                    sat_sftic [Occ=Once, Dmd=<L,C(U)>] :: a_afsSM -> GHC.Types.Bool
                                    [LclId] =
                                        [eq_sfti4 x_sfti9] \u [] eq_sfti4 x_sfti9;
                                  } in 
                                    case GHC.List.$wspan sat_sftic xs_sftia of {
                                      (#,#) ww1_sftie [Occ=Once] ww2_sftif [Occ=Once] ->
                                          (,) [ww1_sftie ww2_sftif];
                                    }; } in
                        let {
                          sat_sftio [Occ=Once] :: lst_afsSN
                          [LclId] =
                              [groupByFBCore_sfti6 ds1_sftib] \u []
                                  case ds1_sftib of {
                                    (,) _ [Occ=Dead] zs_sftin [Occ=Once] ->
                                        groupByFBCore_sfti6 zs_sftin;
                                  }; } in
                        let {
                          sat_sftij [Occ=Once] :: [a_afsSM]
                          [LclId] =
                              [ds1_sftib] \u []
                                  case ds1_sftib of {
                                    (,) ys_sftih [Occ=Once] _ [Occ=Dead] -> ys_sftih;
                                  }; } in
                        let {
                          sat_sftik [Occ=Once] :: [a_afsSM]
                          [LclId] =
                              CCCS :! [x_sfti9 sat_sftij];
                        } in  c_sfti2 sat_sftik sat_sftio;
                  };
        } in  groupByFBCore_sfti6 xs0_sfti5;

GHC.Exts.groupWith [InlPrag=INLINE (sat-args=2)]
  :: forall b a. GHC.Classes.Ord b => (a -> b) -> [a] -> [[a]]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sftip eta_sftiq eta1_sftir]
        let {
          $dEq_sftis [Occ=OnceL, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq b_afsTj
          [LclId] =
              [$dOrd_sftip] \u [] GHC.Classes.$p1Ord $dOrd_sftip; } in
        let {
          groupByFBCore_sftit [Occ=LoopBreaker] :: [a_afsTk] -> [[a_afsTk]]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [eta_sftiq $dEq_sftis groupByFBCore_sftit] \r [ds_sftiu]
                  case ds_sftiu of {
                    [] -> [] [];
                    : x_sftiw xs_sftix [Occ=Once] ->
                        let {
                          ds1_sftiy [Dmd=<L,U(1*U,1*U)>] :: ([a_afsTk], [a_afsTk])
                          [LclId] =
                              [eta_sftiq $dEq_sftis x_sftiw xs_sftix] \u []
                                  let {
                                    lvl3_sftiz [Occ=OnceL] :: b_afsTj
                                    [LclId] =
                                        [eta_sftiq x_sftiw] \u [] eta_sftiq x_sftiw; } in
                                  let {
                                    sat_sftiC [Occ=Once] :: a_afsTk -> GHC.Types.Bool
                                    [LclId] =
                                        [eta_sftiq $dEq_sftis lvl3_sftiz] \r [y_sftiA]
                                            let {
                                              sat_sftiB [Occ=Once] :: b_afsTj
                                              [LclId] =
                                                  [eta_sftiq y_sftiA] \u [] eta_sftiq y_sftiA;
                                            } in  GHC.Classes.== $dEq_sftis lvl3_sftiz sat_sftiB;
                                  } in 
                                    case GHC.List.$wspan sat_sftiC xs_sftix of {
                                      (#,#) ww1_sftiE [Occ=Once] ww2_sftiF [Occ=Once] ->
                                          (,) [ww1_sftiE ww2_sftiF];
                                    }; } in
                        let {
                          sat_sftiO [Occ=Once] :: [[a_afsTk]]
                          [LclId] =
                              [groupByFBCore_sftit ds1_sftiy] \u []
                                  case ds1_sftiy of {
                                    (,) _ [Occ=Dead] zs_sftiN [Occ=Once] ->
                                        groupByFBCore_sftit zs_sftiN;
                                  }; } in
                        let {
                          sat_sftiJ [Occ=Once] :: [a_afsTk]
                          [LclId] =
                              [ds1_sftiy] \u []
                                  case ds1_sftiy of {
                                    (,) ys_sftiH [Occ=Once] _ [Occ=Dead] -> ys_sftiH;
                                  }; } in
                        let {
                          sat_sftiK [Occ=Once] :: [a_afsTk]
                          [LclId] =
                              CCCS :! [x_sftiw sat_sftiJ];
                        } in  : [sat_sftiK sat_sftiO];
                  };
        } in 
          case
              GHC.Exts.sortWith $dOrd_sftip eta_sftiq eta1_sftir
          of
          sat_sftiP
          { __DEFAULT -> groupByFBCore_sftit sat_sftiP;
          };

GHC.Exts.traceEvent :: GHC.Base.String -> GHC.Types.IO ()
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Debug.Trace.traceEventIO1 eta_B2 eta_B1;

GHC.Exts.$fDataSpecConstrAnnotation7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "SpecConstrAnnotation"#;

$tSpecConstrAnnotation1_rftgn :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# GHC.Exts.$fDataSpecConstrAnnotation7;

w1_rftgo :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ForceSpecConstr"#;

w2_rftgp :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# w1_rftgo;

w3_rftgq :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NoSpecConstr"#;

w4_rftgr :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# w3_rftgq;

go61_rftgs
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sftiQ _ys_sftiR]
        case ds2_sftiQ of {
          [] -> GHC.List.badHead;
          : ipv_sftiT [Occ=Once!] ipv1_sftiU [Occ=Once] ->
              case _ys_sftiR of {
                [] -> GHC.List.badHead;
                : ipv2_sftiW [Occ=Once] ipv3_sftiX [Occ=Once] ->
                    case ipv_sftiT of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sftj0 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sftj0 w2_rftgp of {
                            GHC.Types.False -> go61_rftgs ipv1_sftiU ipv3_sftiX;
                            GHC.Types.True -> ipv2_sftiW;
                          };
                    };
              };
        };

go1_rftgt
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sftj5 _ys_sftj6]
        case ds2_sftj5 of {
          [] -> GHC.List.badHead;
          : ipv_sftj8 [Occ=Once!] ipv1_sftj9 [Occ=Once] ->
              case _ys_sftj6 of {
                [] -> GHC.List.badHead;
                : ipv2_sftjb [Occ=Once] ipv3_sftjc [Occ=Once] ->
                    case ipv_sftj8 of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sftjf [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sftjf w4_rftgr of {
                            GHC.Types.False -> go1_rftgt ipv1_sftj9 ipv3_sftjc;
                            GHC.Types.True -> ipv2_sftjb;
                          };
                    };
              };
        };

$cForceSpecConstr1_rftgu :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cForceSpecConstr2_rftgA];
$cNoSpecConstr1_rftgv :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cNoSpecConstr2_rftgz];
GHC.Exts.$cForceSpecConstr [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cForceSpecConstr1_rftgu
                                     w2_rftgp
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     GHC.Exts.$tSpecConstrAnnotation];
$tSpecConstrAnnotation2_rftgw :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Exts.$cForceSpecConstr GHC.Types.[]];
$tSpecConstrAnnotation3_rftgx :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Exts.$cNoSpecConstr
                      $tSpecConstrAnnotation2_rftgw];
$tSpecConstrAnnotation4_rftgy :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [$tSpecConstrAnnotation3_rftgx];
GHC.Exts.$tSpecConstrAnnotation [Occ=LoopBreaker]
  :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [$tSpecConstrAnnotation1_rftgn
                                       $tSpecConstrAnnotation4_rftgy];
GHC.Exts.$cNoSpecConstr [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cNoSpecConstr1_rftgv
                                     w4_rftgr
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     GHC.Exts.$tSpecConstrAnnotation];
$cNoSpecConstr2_rftgz :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go1_rftgt $tSpecConstrAnnotation3_rftgx Data.Data.mkConstr1;
$cForceSpecConstr2_rftgA :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rftgs $tSpecConstrAnnotation3_rftgx Data.Data.mkConstr1;

GHC.Exts.$fDataSpecConstrAnnotation_$cdataTypeOf
  :: GHC.Exts.SpecConstrAnnotation -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sftjk] GHC.Exts.$tSpecConstrAnnotation;

GHC.Exts.$fDataSpecConstrAnnotation_$ctoConstr
  :: GHC.Exts.SpecConstrAnnotation -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sftjl]
        case ds_sftjl of {
          GHC.Exts.NoSpecConstr -> GHC.Exts.$cNoSpecConstr;
          GHC.Exts.ForceSpecConstr -> GHC.Exts.$cForceSpecConstr;
        };

GHC.Exts.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Exts.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$trModule4];

GHC.Exts.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Exts"#;

GHC.Exts.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$trModule2];

GHC.Exts.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Exts.$trModule3
                                     GHC.Exts.$trModule1];

$krep_rftgB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.Exts.$tcIsList1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$* $krep_rftgB];

GHC.Exts.$fDataSpecConstrAnnotation6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$fDataSpecConstrAnnotation7];

GHC.Exts.$tcSpecConstrAnnotation :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8217012571387563927##
                                    8545973142114271769##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$fDataSpecConstrAnnotation6
                                    0#
                                    GHC.Types.krep$*];

GHC.Exts.$tc'ForceSpecConstr1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Exts.$tcSpecConstrAnnotation
                                              GHC.Types.[]];

GHC.Exts.$tc'NoSpecConstr2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'NoSpecConstr"#;

GHC.Exts.$tc'NoSpecConstr1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$tc'NoSpecConstr2];

GHC.Exts.$tc'NoSpecConstr :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [18402820579108170608##
                                    14598374581444186552##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$tc'NoSpecConstr1
                                    0#
                                    GHC.Exts.$tc'ForceSpecConstr1];

GHC.Exts.$tc'ForceSpecConstr3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'ForceSpecConstr"#;

GHC.Exts.$tc'ForceSpecConstr2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$tc'ForceSpecConstr3];

GHC.Exts.$tc'ForceSpecConstr :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13715005538542947299##
                                    3802030838304098377##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$tc'ForceSpecConstr2
                                    0#
                                    GHC.Exts.$tc'ForceSpecConstr1];

GHC.Exts.$fDataSpecConstrAnnotation5
  :: Data.Typeable.Internal.TypeRep GHC.Exts.SpecConstrAnnotation
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                8217012571387563927##
                8545973142114271769##
                GHC.Exts.$trModule
                GHC.Exts.$fDataSpecConstrAnnotation6
                0#
                GHC.Types.krep$*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sftjo [Occ=Once]
                   ww9_sftjp [Occ=Once]
                   ww10_sftjq [Occ=Once]
                   ww11_sftjr [Occ=Once]
                   ww12_sftjs [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sftjo
                                              ww9_sftjp
                                              ww10_sftjq
                                              ww11_sftjr
                                              ww12_sftjs];
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c GHC.Exts.SpecConstrAnnotation)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sftjt ds_sftju] GHC.Base.Nothing [];

GHC.Exts.$fDataSpecConstrAnnotation2
  :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Exts.NoSpecConstr GHC.Types.False];

GHC.Exts.$fDataSpecConstrAnnotation1
  :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Exts.ForceSpecConstr GHC.Types.False];

GHC.Exts.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sftjv w5_sftjw]
        let {
          lvl3_sftjx [Occ=OnceL] :: m_sftav GHC.Exts.SpecConstrAnnotation
          [LclId] =
              [w_sftjv] \u [] GHC.Base.mzero w_sftjv;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sftjv
          of
          $dMonad_sftjy [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sftjG [Occ=Once]
                    :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                       -> m_sftav GHC.Exts.SpecConstrAnnotation
                  [LclId] =
                      [lvl3_sftjx $dMonad_sftjy] \r [ds_sftjB]
                          case ds_sftjB of {
                            (,) x'_sftjD [Occ=Once] b_sftjE [Occ=Once!] ->
                                case b_sftjE of {
                                  GHC.Types.False -> lvl3_sftjx;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sftjy x'_sftjD;
                                };
                          }; } in
                let {
                  sat_sftjA [Occ=Once]
                    :: m_sftav (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                  [LclId] =
                      [w5_sftjw $dMonad_sftjy] \u []
                          case w5_sftjw of {
                            GHC.Exts.NoSpecConstr ->
                                GHC.Base.return $dMonad_sftjy GHC.Exts.$fDataSpecConstrAnnotation2;
                            GHC.Exts.ForceSpecConstr ->
                                GHC.Base.return $dMonad_sftjy GHC.Exts.$fDataSpecConstrAnnotation1;
                          };
                } in  GHC.Base.>>= $dMonad_sftjy sat_sftjA sat_sftjG;
          };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sftjH w5_sftjI w6_sftjJ]
        GHC.Exts.$w$cgmapMp w_sftjH w6_sftjJ;

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapM
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sftjK ds_sftjL eta_sftjM]
        case eta_sftjM of {
          GHC.Exts.NoSpecConstr ->
              GHC.Base.return $dMonad_sftjK GHC.Exts.NoSpecConstr;
          GHC.Exts.ForceSpecConstr ->
              GHC.Base.return $dMonad_sftjK GHC.Exts.ForceSpecConstr;
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQi
  :: forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> GHC.Exts.SpecConstrAnnotation
     -> u
[GblId, Arity=3, Str=<B,A><B,A><B,1*U>x, Unf=OtherCon []] =
    [] \r [ds_sftjO ds1_sftjP x_sftjQ]
        case x_sftjQ of { __DEFAULT -> Data.Maybe.fromJust1; };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> GHC.Exts.SpecConstrAnnotation
     -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sftjS ds1_sftjT ds2_sftjU x0_sftjV]
        case x0_sftjV of { __DEFAULT -> ds1_sftjT; };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQ
  :: forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> GHC.Exts.SpecConstrAnnotation -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sftjX x0_sftjY] case x0_sftjY of { __DEFAULT -> [] []; };

GHC.Exts.$fDataSpecConstrAnnotation3
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> GHC.Exts.SpecConstrAnnotation
     -> Data.Functor.Const.Const r GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sftk0 ds1_sftk1 ds2_sftk2 eta_sftk3]
        case eta_sftk3 of { __DEFAULT -> ds1_sftk1; };

GHC.Exts.$fDataSpecConstrAnnotation4
  :: (forall b. Data.Data.Data b => b -> b)
     -> GHC.Exts.SpecConstrAnnotation -> GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sftk5 x0_sftk6] x0_sftk6;

GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c GHC.Exts.SpecConstrAnnotation)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sftk7 ds_sftk8] GHC.Base.Nothing [];

GHC.Exts.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sftk9 w5_sftka]
        let {
          lvl3_sftkb [Occ=OnceL] :: m_sftaA GHC.Exts.SpecConstrAnnotation
          [LclId] =
              [w_sftk9] \u [] GHC.Base.mzero w_sftk9;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sftk9
          of
          $dMonad_sftkc [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sftkk [Occ=Once]
                    :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                       -> m_sftaA GHC.Exts.SpecConstrAnnotation
                  [LclId] =
                      [lvl3_sftkb $dMonad_sftkc] \r [ds_sftkf]
                          case ds_sftkf of {
                            (,) x'_sftkh [Occ=Once] b_sftki [Occ=Once!] ->
                                case b_sftki of {
                                  GHC.Types.False -> lvl3_sftkb;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sftkc x'_sftkh;
                                };
                          }; } in
                let {
                  sat_sftke [Occ=Once]
                    :: m_sftaA (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                  [LclId] =
                      [w5_sftka $dMonad_sftkc] \u []
                          case w5_sftka of {
                            GHC.Exts.NoSpecConstr ->
                                GHC.Base.return $dMonad_sftkc GHC.Exts.$fDataSpecConstrAnnotation2;
                            GHC.Exts.ForceSpecConstr ->
                                GHC.Base.return $dMonad_sftkc GHC.Exts.$fDataSpecConstrAnnotation1;
                          };
                } in  GHC.Base.>>= $dMonad_sftkc sat_sftke sat_sftkk;
          };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sftkl w5_sftkm w6_sftkn]
        GHC.Exts.$w$cgmapMo w_sftkl w6_sftkn;

GHC.Exts.$fDataSpecConstrAnnotation [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Data.Data GHC.Exts.SpecConstrAnnotation
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Data.C:Data! [GHC.Exts.$fDataSpecConstrAnnotation5
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgfoldl
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgunfold
                                     GHC.Exts.$fDataSpecConstrAnnotation_$ctoConstr
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cdataTypeOf
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast1
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast2
                                     GHC.Exts.$fDataSpecConstrAnnotation4
                                     GHC.Exts.$fDataSpecConstrAnnotation3
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQr
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQ
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQi
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapM
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMp
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMo];

GHC.Exts.$tcIsList3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "IsList"#;

GHC.Exts.$tcIsList2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$tcIsList3];

GHC.Exts.$tcIsList :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17963880945977000500##
                                    13985778898022155754##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$tcIsList2
                                    0#
                                    GHC.Exts.$tcIsList1];

GHC.Exts.C:IsList
  :: forall l.
     ([GHC.Exts.Item l] -> l)
     -> (GHC.Types.Int -> [GHC.Exts.Item l] -> l)
     -> (l -> [GHC.Exts.Item l])
     -> GHC.Exts.IsList l
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Exts.C:IsList [eta_B3 eta_B2 eta_B1];

GHC.Exts.NoSpecConstr :: GHC.Exts.SpecConstrAnnotation
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Exts.NoSpecConstr! [];

GHC.Exts.ForceSpecConstr :: GHC.Exts.SpecConstrAnnotation
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Exts.ForceSpecConstr! [];


==================== STG syntax: ====================
2018-03-16 16:11:11.025169067 UTC

GHC.Exts.fromList
  :: forall l. GHC.Exts.IsList l => [GHC.Exts.Item l] -> l
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sftgD]
        case v_sftgD of {
          GHC.Exts.C:IsList v_sftgF [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
              v_sftgF;
        };

GHC.Exts.fromListN
  :: forall l.
     GHC.Exts.IsList l =>
     GHC.Types.Int -> [GHC.Exts.Item l] -> l
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sftgI]
        case v_sftgI of {
          GHC.Exts.C:IsList _ [Occ=Dead] v_sftgL [Occ=Once] _ [Occ=Dead] ->
              v_sftgL;
        };

GHC.Exts.toList
  :: forall l. GHC.Exts.IsList l => l -> [GHC.Exts.Item l]
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sftgN]
        case v_sftgN of {
          GHC.Exts.C:IsList _ [Occ=Dead] _ [Occ=Dead] v_sftgR [Occ=Once] ->
              v_sftgR;
        };

GHC.Exts.$fIsListNonEmpty1 :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_sftgS]
        let {
          sat_sfth0 [Occ=Once] :: [a_afsY2]
          [LclId] =
              [ds_sftgS] \u []
                  case ds_sftgS of {
                    GHC.Base.:| _ [Occ=Dead] as_sftgZ [Occ=Once] -> as_sftgZ;
                  }; } in
        let {
          sat_sftgW [Occ=Once] :: a_afsY2
          [LclId] =
              [ds_sftgS] \u []
                  case ds_sftgS of {
                    GHC.Base.:| a1_sftgU [Occ=Once] _ [Occ=Dead] -> a1_sftgU;
                  };
        } in  : [sat_sftgW sat_sfth0];

lvl_rftgk :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty.fromList: empty list"#;

GHC.Exts.$fIsListNonEmpty2 :: forall a. GHC.Base.NonEmpty a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rftgk of sat_sfth1 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfth1;
        };

GHC.Exts.$fIsListNonEmpty_$cfromList
  :: forall a.
     [GHC.Exts.Item (GHC.Base.NonEmpty a)] -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sfth2]
        case ds_sfth2 of {
          [] -> GHC.Exts.$fIsListNonEmpty2;
          : a1_sfth4 [Occ=Once] as_sfth5 [Occ=Once] ->
              GHC.Base.:| [a1_sfth4 as_sfth5];
        };

GHC.Exts.$fEqSpecConstrAnnotation_$c==
  :: GHC.Exts.SpecConstrAnnotation
     -> GHC.Exts.SpecConstrAnnotation -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfth6 ds1_sfth7]
        case ds_sfth6 of {
          GHC.Exts.NoSpecConstr ->
              case ds1_sfth7 of {
                GHC.Exts.NoSpecConstr -> GHC.Types.True [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.False [];
              };
          GHC.Exts.ForceSpecConstr ->
              case ds1_sfth7 of {
                GHC.Exts.NoSpecConstr -> GHC.Types.False [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.True [];
              };
        };

GHC.Exts.$fEqSpecConstrAnnotation_$c/= [InlPrag=INLINE (sat-args=2)]
  :: GHC.Exts.SpecConstrAnnotation
     -> GHC.Exts.SpecConstrAnnotation -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_sfthb eta1_sfthc]
        case eta_sfthb of {
          GHC.Exts.NoSpecConstr ->
              case eta1_sfthc of {
                GHC.Exts.NoSpecConstr -> GHC.Types.False [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.True [];
              };
          GHC.Exts.ForceSpecConstr ->
              case eta1_sfthc of {
                GHC.Exts.NoSpecConstr -> GHC.Types.True [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.False [];
              };
        };

GHC.Exts.$fEqSpecConstrAnnotation [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq GHC.Exts.SpecConstrAnnotation
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Exts.$fEqSpecConstrAnnotation_$c==
                                     GHC.Exts.$fEqSpecConstrAnnotation_$c/=];

GHC.Exts.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r)
     -> Data.Data.ConstrRep
     -> Data.Data.DataType
     -> c GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [w_sfthg ww_sfthh ww1_sfthi]
        case ww_sfthh of {
          __DEFAULT ->
              case ww1_sfthi of {
                Data.Data.DataType ww7_sfthl [Occ=Once] _ [Occ=Dead] ->
                    Data.Data.$wlvl ww7_sfthl;
              };
          Data.Data.AlgConstr idx_sftho [Occ=Once!] ->
              case idx_sftho of {
                GHC.Types.I# ds_sfthq [Occ=Once!] ->
                    case ds_sfthq of {
                      __DEFAULT -> w_sfthg GHC.Exts.ForceSpecConstr;
                      1# -> w_sfthg GHC.Exts.NoSpecConstr;
                    };
              };
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=OtherCon []] =
    [] \r [w_sfths w5_sftht w6_sfthu]
        case w6_sfthu of {
          Data.Data.Constr ww1_sfthw [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           ww5_sfthA [Occ=Once] ->
              GHC.Exts.$w$cgunfold w5_sftht ww1_sfthw ww5_sfthA;
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> GHC.Exts.SpecConstrAnnotation
     -> c GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sfthB z_sfthC ds_sfthD]
        case ds_sfthD of {
          GHC.Exts.NoSpecConstr -> z_sfthC GHC.Exts.NoSpecConstr;
          GHC.Exts.ForceSpecConstr -> z_sfthC GHC.Exts.ForceSpecConstr;
        };

GHC.Exts.$dmfromListN
  :: forall l.
     GHC.Exts.IsList l =>
     GHC.Types.Int -> [GHC.Exts.Item l] -> l
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLL),1*U(1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dIsList_sfthF ds_sfthG] GHC.Exts.fromList $dIsList_sfthF;

GHC.Exts.$fIsListCallStack1
  :: GHC.Types.Int
     -> [([GHC.Types.Char], GHC.Stack.Types.SrcLoc)]
     -> GHC.Stack.Types.CallStack
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfthH eta_B1] GHC.Stack.Types.fromCallSiteList eta_B1;

GHC.Exts.$fIsListCallStack [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Exts.IsList GHC.Stack.Types.CallStack
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [GHC.Stack.Types.fromCallSiteList
                                      GHC.Exts.$fIsListCallStack1
                                      GHC.Stack.Types.getCallStack];

GHC.Exts.$fIsListVersion1
  :: GHC.Types.Int -> [GHC.Types.Int] -> Data.Version.Version
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfthI eta_B1] Data.Version.makeVersion eta_B1;

GHC.Exts.$fIsListVersion [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Exts.IsList Data.Version.Version
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [Data.Version.makeVersion
                                      GHC.Exts.$fIsListVersion1
                                      Data.Version.versionBranch];

GHC.Exts.$fIsListNonEmpty_$cfromListN
  :: forall a.
     GHC.Types.Int
     -> [GHC.Exts.Item (GHC.Base.NonEmpty a)] -> GHC.Base.NonEmpty a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfthJ eta_B1]
        GHC.Exts.$fIsListNonEmpty_$cfromList eta_B1;

GHC.Exts.$fIsListNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Exts.IsList (GHC.Base.NonEmpty a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [GHC.Exts.$fIsListNonEmpty_$cfromList
                                      GHC.Exts.$fIsListNonEmpty_$cfromListN
                                      GHC.Exts.$fIsListNonEmpty1];

GHC.Exts.$fIsList[]1 :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfthK eta_B1] GHC.Base.id eta_B1;

GHC.Exts.$fIsList[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Exts.IsList [a]
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [GHC.Base.id
                                      GHC.Exts.$fIsList[]1
                                      GHC.Base.id];

GHC.Exts.maxTupleSize :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [62#];

lvl1_rftgl :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Exts.the: empty list"#;

GHC.Exts.the2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rftgl of sat_sfthL {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfthL;
        };

lvl2_rftgm :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Exts.the: non-identical elements"#;

GHC.Exts.the1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rftgm of sat_sfthM {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfthM;
        };

GHC.Exts.the :: forall a. GHC.Classes.Eq a => [a] -> a
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfthN ds_sfthO]
        case ds_sfthO of {
          [] -> GHC.Exts.the2;
          : x_sfthQ xs_sfthR [Occ=Once] ->
              let {
                sat_sfthS [Occ=Once, Dmd=<L,C(U)>] :: a_afsTA -> GHC.Types.Bool
                [LclId] =
                    [$dEq_sfthN x_sfthQ] \u [] GHC.Classes.== $dEq_sfthN x_sfthQ;
              } in 
                case GHC.List.all sat_sfthS xs_sfthR of {
                  GHC.Types.False -> GHC.Exts.the1;
                  GHC.Types.True -> x_sfthQ;
                };
        };

GHC.Exts.sortWith
  :: forall b a. GHC.Classes.Ord b => (a -> b) -> [a] -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,A,A,A,A,A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfthU f_sfthV eta_sfthW]
        let {
          sat_sfti1 [Occ=Once] :: a_afsTc -> a_afsTc -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfthU f_sfthV] \r [x_sfthX y_sfthY]
                  let {
                    sat_sfti0 [Occ=Once] :: b_afsTb
                    [LclId] =
                        [f_sfthV y_sfthY] \u [] f_sfthV y_sfthY; } in
                  let {
                    sat_sfthZ [Occ=Once] :: b_afsTb
                    [LclId] =
                        [f_sfthV x_sfthX] \u [] f_sfthV x_sfthX;
                  } in  GHC.Classes.compare $dOrd_sfthU sat_sfthZ sat_sfti0;
        } in  Data.OldList.sortBy sat_sfti1 eta_sfthW;

GHC.Exts.groupByFB [InlPrag=INLINE[0] (sat-args=4)]
  :: forall a lst.
     ([a] -> lst -> lst)
     -> lst -> (a -> a -> GHC.Types.Bool) -> [a] -> lst
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,C(C(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [c_sfti2 n_sfti3 eq_sfti4 xs0_sfti5]
        let {
          groupByFBCore_sfti6 [Occ=LoopBreaker] :: [a_afsSM] -> lst_afsSN
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [c_sfti2
                        n_sfti3
                        eq_sfti4
                        groupByFBCore_sfti6] \r [ds_sfti7]
                  case ds_sfti7 of {
                    [] -> n_sfti3;
                    : x_sfti9 xs_sftia [Occ=Once] ->
                        let {
                          ds1_sftib [Dmd=<L,U(1*U,1*U)>] :: ([a_afsSM], [a_afsSM])
                          [LclId] =
                              [eq_sfti4 x_sfti9 xs_sftia] \u []
                                  let {
                                    sat_sftic [Occ=Once, Dmd=<L,C(U)>] :: a_afsSM -> GHC.Types.Bool
                                    [LclId] =
                                        [eq_sfti4 x_sfti9] \u [] eq_sfti4 x_sfti9;
                                  } in 
                                    case GHC.List.$wspan sat_sftic xs_sftia of {
                                      (#,#) ww1_sftie [Occ=Once] ww2_sftif [Occ=Once] ->
                                          (,) [ww1_sftie ww2_sftif];
                                    }; } in
                        let {
                          sat_sftio [Occ=Once] :: lst_afsSN
                          [LclId] =
                              [groupByFBCore_sfti6 ds1_sftib] \u []
                                  case ds1_sftib of {
                                    (,) _ [Occ=Dead] zs_sftin [Occ=Once] ->
                                        groupByFBCore_sfti6 zs_sftin;
                                  }; } in
                        let {
                          sat_sftij [Occ=Once] :: [a_afsSM]
                          [LclId] =
                              [ds1_sftib] \u []
                                  case ds1_sftib of {
                                    (,) ys_sftih [Occ=Once] _ [Occ=Dead] -> ys_sftih;
                                  }; } in
                        let {
                          sat_sftik [Occ=Once] :: [a_afsSM]
                          [LclId] =
                              CCCS :! [x_sfti9 sat_sftij];
                        } in  c_sfti2 sat_sftik sat_sftio;
                  };
        } in  groupByFBCore_sfti6 xs0_sfti5;

GHC.Exts.groupWith [InlPrag=INLINE (sat-args=2)]
  :: forall b a. GHC.Classes.Ord b => (a -> b) -> [a] -> [[a]]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sftip eta_sftiq eta1_sftir]
        let {
          $dEq_sftis [Occ=OnceL, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq b_afsTj
          [LclId] =
              [$dOrd_sftip] \u [] GHC.Classes.$p1Ord $dOrd_sftip; } in
        let {
          groupByFBCore_sftit [Occ=LoopBreaker] :: [a_afsTk] -> [[a_afsTk]]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [eta_sftiq $dEq_sftis groupByFBCore_sftit] \r [ds_sftiu]
                  case ds_sftiu of {
                    [] -> [] [];
                    : x_sftiw xs_sftix [Occ=Once] ->
                        let {
                          ds1_sftiy [Dmd=<L,U(1*U,1*U)>] :: ([a_afsTk], [a_afsTk])
                          [LclId] =
                              [eta_sftiq $dEq_sftis x_sftiw xs_sftix] \u []
                                  let {
                                    lvl3_sftiz [Occ=OnceL] :: b_afsTj
                                    [LclId] =
                                        [eta_sftiq x_sftiw] \u [] eta_sftiq x_sftiw; } in
                                  let {
                                    sat_sftiC [Occ=Once] :: a_afsTk -> GHC.Types.Bool
                                    [LclId] =
                                        [eta_sftiq $dEq_sftis lvl3_sftiz] \r [y_sftiA]
                                            let {
                                              sat_sftiB [Occ=Once] :: b_afsTj
                                              [LclId] =
                                                  [eta_sftiq y_sftiA] \u [] eta_sftiq y_sftiA;
                                            } in  GHC.Classes.== $dEq_sftis lvl3_sftiz sat_sftiB;
                                  } in 
                                    case GHC.List.$wspan sat_sftiC xs_sftix of {
                                      (#,#) ww1_sftiE [Occ=Once] ww2_sftiF [Occ=Once] ->
                                          (,) [ww1_sftiE ww2_sftiF];
                                    }; } in
                        let {
                          sat_sftiO [Occ=Once] :: [[a_afsTk]]
                          [LclId] =
                              [groupByFBCore_sftit ds1_sftiy] \u []
                                  case ds1_sftiy of {
                                    (,) _ [Occ=Dead] zs_sftiN [Occ=Once] ->
                                        groupByFBCore_sftit zs_sftiN;
                                  }; } in
                        let {
                          sat_sftiJ [Occ=Once] :: [a_afsTk]
                          [LclId] =
                              [ds1_sftiy] \u []
                                  case ds1_sftiy of {
                                    (,) ys_sftiH [Occ=Once] _ [Occ=Dead] -> ys_sftiH;
                                  }; } in
                        let {
                          sat_sftiK [Occ=Once] :: [a_afsTk]
                          [LclId] =
                              CCCS :! [x_sftiw sat_sftiJ];
                        } in  : [sat_sftiK sat_sftiO];
                  };
        } in 
          case
              GHC.Exts.sortWith $dOrd_sftip eta_sftiq eta1_sftir
          of
          sat_sftiP
          { __DEFAULT -> groupByFBCore_sftit sat_sftiP;
          };

GHC.Exts.traceEvent :: GHC.Base.String -> GHC.Types.IO ()
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [eta_B2 void_0E]
        Debug.Trace.traceEventIO1 eta_B2 GHC.Prim.void#;

GHC.Exts.$fDataSpecConstrAnnotation7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "SpecConstrAnnotation"#;

$tSpecConstrAnnotation1_rftgn :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# GHC.Exts.$fDataSpecConstrAnnotation7;

w1_rftgo :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ForceSpecConstr"#;

w2_rftgp :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# w1_rftgo;

w3_rftgq :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NoSpecConstr"#;

w4_rftgr :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# w3_rftgq;

go61_rftgs
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sftiQ _ys_sftiR]
        case ds2_sftiQ of {
          [] -> GHC.List.badHead;
          : ipv_sftiT [Occ=Once!] ipv1_sftiU [Occ=Once] ->
              case _ys_sftiR of {
                [] -> GHC.List.badHead;
                : ipv2_sftiW [Occ=Once] ipv3_sftiX [Occ=Once] ->
                    case ipv_sftiT of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sftj0 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sftj0 w2_rftgp of {
                            GHC.Types.False -> go61_rftgs ipv1_sftiU ipv3_sftiX;
                            GHC.Types.True -> ipv2_sftiW;
                          };
                    };
              };
        };

go1_rftgt
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sftj5 _ys_sftj6]
        case ds2_sftj5 of {
          [] -> GHC.List.badHead;
          : ipv_sftj8 [Occ=Once!] ipv1_sftj9 [Occ=Once] ->
              case _ys_sftj6 of {
                [] -> GHC.List.badHead;
                : ipv2_sftjb [Occ=Once] ipv3_sftjc [Occ=Once] ->
                    case ipv_sftj8 of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sftjf [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sftjf w4_rftgr of {
                            GHC.Types.False -> go1_rftgt ipv1_sftj9 ipv3_sftjc;
                            GHC.Types.True -> ipv2_sftjb;
                          };
                    };
              };
        };

$cForceSpecConstr1_rftgu :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cForceSpecConstr2_rftgA];
$cNoSpecConstr1_rftgv :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cNoSpecConstr2_rftgz];
GHC.Exts.$cForceSpecConstr [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cForceSpecConstr1_rftgu
                                     w2_rftgp
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     GHC.Exts.$tSpecConstrAnnotation];
$tSpecConstrAnnotation2_rftgw :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Exts.$cForceSpecConstr GHC.Types.[]];
$tSpecConstrAnnotation3_rftgx :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Exts.$cNoSpecConstr
                      $tSpecConstrAnnotation2_rftgw];
$tSpecConstrAnnotation4_rftgy :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [$tSpecConstrAnnotation3_rftgx];
GHC.Exts.$tSpecConstrAnnotation [Occ=LoopBreaker]
  :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [$tSpecConstrAnnotation1_rftgn
                                       $tSpecConstrAnnotation4_rftgy];
GHC.Exts.$cNoSpecConstr [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cNoSpecConstr1_rftgv
                                     w4_rftgr
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     GHC.Exts.$tSpecConstrAnnotation];
$cNoSpecConstr2_rftgz :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go1_rftgt $tSpecConstrAnnotation3_rftgx Data.Data.mkConstr1;
$cForceSpecConstr2_rftgA :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rftgs $tSpecConstrAnnotation3_rftgx Data.Data.mkConstr1;

GHC.Exts.$fDataSpecConstrAnnotation_$cdataTypeOf
  :: GHC.Exts.SpecConstrAnnotation -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sftjk] GHC.Exts.$tSpecConstrAnnotation;

GHC.Exts.$fDataSpecConstrAnnotation_$ctoConstr
  :: GHC.Exts.SpecConstrAnnotation -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sftjl]
        case ds_sftjl of {
          GHC.Exts.NoSpecConstr -> GHC.Exts.$cNoSpecConstr;
          GHC.Exts.ForceSpecConstr -> GHC.Exts.$cForceSpecConstr;
        };

GHC.Exts.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Exts.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$trModule4];

GHC.Exts.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Exts"#;

GHC.Exts.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$trModule2];

GHC.Exts.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Exts.$trModule3
                                     GHC.Exts.$trModule1];

$krep_rftgB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.Exts.$tcIsList1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$* $krep_rftgB];

GHC.Exts.$fDataSpecConstrAnnotation6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$fDataSpecConstrAnnotation7];

GHC.Exts.$tcSpecConstrAnnotation :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8217012571387563927##
                                    8545973142114271769##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$fDataSpecConstrAnnotation6
                                    0#
                                    GHC.Types.krep$*];

GHC.Exts.$tc'ForceSpecConstr1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Exts.$tcSpecConstrAnnotation
                                              GHC.Types.[]];

GHC.Exts.$tc'NoSpecConstr2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'NoSpecConstr"#;

GHC.Exts.$tc'NoSpecConstr1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$tc'NoSpecConstr2];

GHC.Exts.$tc'NoSpecConstr :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [18402820579108170608##
                                    14598374581444186552##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$tc'NoSpecConstr1
                                    0#
                                    GHC.Exts.$tc'ForceSpecConstr1];

GHC.Exts.$tc'ForceSpecConstr3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'ForceSpecConstr"#;

GHC.Exts.$tc'ForceSpecConstr2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$tc'ForceSpecConstr3];

GHC.Exts.$tc'ForceSpecConstr :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13715005538542947299##
                                    3802030838304098377##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$tc'ForceSpecConstr2
                                    0#
                                    GHC.Exts.$tc'ForceSpecConstr1];

GHC.Exts.$fDataSpecConstrAnnotation5
  :: Data.Typeable.Internal.TypeRep GHC.Exts.SpecConstrAnnotation
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                8217012571387563927##
                8545973142114271769##
                GHC.Exts.$trModule
                GHC.Exts.$fDataSpecConstrAnnotation6
                0#
                GHC.Types.krep$*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sftjo [Occ=Once]
                   ww9_sftjp [Occ=Once]
                   ww10_sftjq [Occ=Once]
                   ww11_sftjr [Occ=Once]
                   ww12_sftjs [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sftjo
                                              ww9_sftjp
                                              ww10_sftjq
                                              ww11_sftjr
                                              ww12_sftjs];
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c GHC.Exts.SpecConstrAnnotation)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sftjt ds_sftju] GHC.Base.Nothing [];

GHC.Exts.$fDataSpecConstrAnnotation2
  :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Exts.NoSpecConstr GHC.Types.False];

GHC.Exts.$fDataSpecConstrAnnotation1
  :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Exts.ForceSpecConstr GHC.Types.False];

GHC.Exts.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sftjv w5_sftjw]
        let {
          lvl3_sftjx [Occ=OnceL] :: m_sftav GHC.Exts.SpecConstrAnnotation
          [LclId] =
              [w_sftjv] \u [] GHC.Base.mzero w_sftjv;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sftjv
          of
          $dMonad_sftjy [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sftjG [Occ=Once]
                    :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                       -> m_sftav GHC.Exts.SpecConstrAnnotation
                  [LclId] =
                      [lvl3_sftjx $dMonad_sftjy] \r [ds_sftjB]
                          case ds_sftjB of {
                            (,) x'_sftjD [Occ=Once] b_sftjE [Occ=Once!] ->
                                case b_sftjE of {
                                  GHC.Types.False -> lvl3_sftjx;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sftjy x'_sftjD;
                                };
                          }; } in
                let {
                  sat_sftjA [Occ=Once]
                    :: m_sftav (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                  [LclId] =
                      [w5_sftjw $dMonad_sftjy] \u []
                          case w5_sftjw of {
                            GHC.Exts.NoSpecConstr ->
                                GHC.Base.return $dMonad_sftjy GHC.Exts.$fDataSpecConstrAnnotation2;
                            GHC.Exts.ForceSpecConstr ->
                                GHC.Base.return $dMonad_sftjy GHC.Exts.$fDataSpecConstrAnnotation1;
                          };
                } in  GHC.Base.>>= $dMonad_sftjy sat_sftjA sat_sftjG;
          };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sftjH w5_sftjI w6_sftjJ]
        GHC.Exts.$w$cgmapMp w_sftjH w6_sftjJ;

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapM
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sftjK ds_sftjL eta_sftjM]
        case eta_sftjM of {
          GHC.Exts.NoSpecConstr ->
              GHC.Base.return $dMonad_sftjK GHC.Exts.NoSpecConstr;
          GHC.Exts.ForceSpecConstr ->
              GHC.Base.return $dMonad_sftjK GHC.Exts.ForceSpecConstr;
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQi
  :: forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> GHC.Exts.SpecConstrAnnotation
     -> u
[GblId, Arity=3, Str=<B,A><B,A><B,1*U>x, Unf=OtherCon []] =
    [] \r [ds_sftjO ds1_sftjP x_sftjQ]
        case x_sftjQ of { __DEFAULT -> Data.Maybe.fromJust1; };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> GHC.Exts.SpecConstrAnnotation
     -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sftjS ds1_sftjT ds2_sftjU x0_sftjV]
        case x0_sftjV of { __DEFAULT -> ds1_sftjT; };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQ
  :: forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> GHC.Exts.SpecConstrAnnotation -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sftjX x0_sftjY] case x0_sftjY of { __DEFAULT -> [] []; };

GHC.Exts.$fDataSpecConstrAnnotation3
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> GHC.Exts.SpecConstrAnnotation
     -> Data.Functor.Const.Const r GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sftk0 ds1_sftk1 ds2_sftk2 eta_sftk3]
        case eta_sftk3 of { __DEFAULT -> ds1_sftk1; };

GHC.Exts.$fDataSpecConstrAnnotation4
  :: (forall b. Data.Data.Data b => b -> b)
     -> GHC.Exts.SpecConstrAnnotation -> GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sftk5 x0_sftk6] x0_sftk6;

GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c GHC.Exts.SpecConstrAnnotation)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sftk7 ds_sftk8] GHC.Base.Nothing [];

GHC.Exts.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sftk9 w5_sftka]
        let {
          lvl3_sftkb [Occ=OnceL] :: m_sftaA GHC.Exts.SpecConstrAnnotation
          [LclId] =
              [w_sftk9] \u [] GHC.Base.mzero w_sftk9;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sftk9
          of
          $dMonad_sftkc [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sftkk [Occ=Once]
                    :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                       -> m_sftaA GHC.Exts.SpecConstrAnnotation
                  [LclId] =
                      [lvl3_sftkb $dMonad_sftkc] \r [ds_sftkf]
                          case ds_sftkf of {
                            (,) x'_sftkh [Occ=Once] b_sftki [Occ=Once!] ->
                                case b_sftki of {
                                  GHC.Types.False -> lvl3_sftkb;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sftkc x'_sftkh;
                                };
                          }; } in
                let {
                  sat_sftke [Occ=Once]
                    :: m_sftaA (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                  [LclId] =
                      [w5_sftka $dMonad_sftkc] \u []
                          case w5_sftka of {
                            GHC.Exts.NoSpecConstr ->
                                GHC.Base.return $dMonad_sftkc GHC.Exts.$fDataSpecConstrAnnotation2;
                            GHC.Exts.ForceSpecConstr ->
                                GHC.Base.return $dMonad_sftkc GHC.Exts.$fDataSpecConstrAnnotation1;
                          };
                } in  GHC.Base.>>= $dMonad_sftkc sat_sftke sat_sftkk;
          };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sftkl w5_sftkm w6_sftkn]
        GHC.Exts.$w$cgmapMo w_sftkl w6_sftkn;

GHC.Exts.$fDataSpecConstrAnnotation [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Data.Data GHC.Exts.SpecConstrAnnotation
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Data.C:Data! [GHC.Exts.$fDataSpecConstrAnnotation5
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgfoldl
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgunfold
                                     GHC.Exts.$fDataSpecConstrAnnotation_$ctoConstr
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cdataTypeOf
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast1
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast2
                                     GHC.Exts.$fDataSpecConstrAnnotation4
                                     GHC.Exts.$fDataSpecConstrAnnotation3
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQr
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQ
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQi
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapM
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMp
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMo];

GHC.Exts.$tcIsList3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "IsList"#;

GHC.Exts.$tcIsList2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$tcIsList3];

GHC.Exts.$tcIsList :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17963880945977000500##
                                    13985778898022155754##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$tcIsList2
                                    0#
                                    GHC.Exts.$tcIsList1];

GHC.Exts.C:IsList
  :: forall l.
     ([GHC.Exts.Item l] -> l)
     -> (GHC.Types.Int -> [GHC.Exts.Item l] -> l)
     -> (l -> [GHC.Exts.Item l])
     -> GHC.Exts.IsList l
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Exts.C:IsList [eta_B3 eta_B2 eta_B1];

GHC.Exts.NoSpecConstr :: GHC.Exts.SpecConstrAnnotation
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Exts.NoSpecConstr! [];

GHC.Exts.ForceSpecConstr :: GHC.Exts.SpecConstrAnnotation
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Exts.ForceSpecConstr! [];


==================== Pre unarise: ====================
2018-03-16 16:11:12.312598308 UTC

GHC.Exts.fromList
  :: forall l. GHC.Exts.IsList l => [GHC.Exts.Item l] -> l
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sfukp]
        case v_sfukp of {
          GHC.Exts.C:IsList v_sfukr [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
              v_sfukr;
        };

GHC.Exts.fromListN
  :: forall l.
     GHC.Exts.IsList l =>
     GHC.Types.Int -> [GHC.Exts.Item l] -> l
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sfuku]
        case v_sfuku of {
          GHC.Exts.C:IsList _ [Occ=Dead] v_sfukx [Occ=Once] _ [Occ=Dead] ->
              v_sfukx;
        };

GHC.Exts.toList
  :: forall l. GHC.Exts.IsList l => l -> [GHC.Exts.Item l]
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sfukz]
        case v_sfukz of {
          GHC.Exts.C:IsList _ [Occ=Dead] _ [Occ=Dead] v_sfukD [Occ=Once] ->
              v_sfukD;
        };

GHC.Exts.$fIsListNonEmpty1 :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_sfukE]
        let {
          sat_sfukM [Occ=Once] :: [a_afsY2]
          [LclId] =
              [ds_sfukE] \u []
                  case ds_sfukE of {
                    GHC.Base.:| _ [Occ=Dead] as_sfukL [Occ=Once] -> as_sfukL;
                  }; } in
        let {
          sat_sfukI [Occ=Once] :: a_afsY2
          [LclId] =
              [ds_sfukE] \u []
                  case ds_sfukE of {
                    GHC.Base.:| a1_sfukG [Occ=Once] _ [Occ=Dead] -> a1_sfukG;
                  };
        } in  : [sat_sfukI sat_sfukM];

lvl_rftgk :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty.fromList: empty list"#;

GHC.Exts.$fIsListNonEmpty2 :: forall a. GHC.Base.NonEmpty a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rftgk of sat_sfukN {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfukN;
        };

GHC.Exts.$fIsListNonEmpty_$cfromList
  :: forall a.
     [GHC.Exts.Item (GHC.Base.NonEmpty a)] -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sfukO]
        case ds_sfukO of {
          [] -> GHC.Exts.$fIsListNonEmpty2;
          : a1_sfukQ [Occ=Once] as_sfukR [Occ=Once] ->
              GHC.Base.:| [a1_sfukQ as_sfukR];
        };

GHC.Exts.$fEqSpecConstrAnnotation_$c==
  :: GHC.Exts.SpecConstrAnnotation
     -> GHC.Exts.SpecConstrAnnotation -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfukS ds1_sfukT]
        case ds_sfukS of {
          GHC.Exts.NoSpecConstr ->
              case ds1_sfukT of {
                GHC.Exts.NoSpecConstr -> GHC.Types.True [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.False [];
              };
          GHC.Exts.ForceSpecConstr ->
              case ds1_sfukT of {
                GHC.Exts.NoSpecConstr -> GHC.Types.False [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.True [];
              };
        };

GHC.Exts.$fEqSpecConstrAnnotation_$c/= [InlPrag=INLINE (sat-args=2)]
  :: GHC.Exts.SpecConstrAnnotation
     -> GHC.Exts.SpecConstrAnnotation -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_sfukX eta1_sfukY]
        case eta_sfukX of {
          GHC.Exts.NoSpecConstr ->
              case eta1_sfukY of {
                GHC.Exts.NoSpecConstr -> GHC.Types.False [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.True [];
              };
          GHC.Exts.ForceSpecConstr ->
              case eta1_sfukY of {
                GHC.Exts.NoSpecConstr -> GHC.Types.True [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.False [];
              };
        };

GHC.Exts.$fEqSpecConstrAnnotation [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq GHC.Exts.SpecConstrAnnotation
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Exts.$fEqSpecConstrAnnotation_$c==
                                     GHC.Exts.$fEqSpecConstrAnnotation_$c/=];

GHC.Exts.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r)
     -> Data.Data.ConstrRep
     -> Data.Data.DataType
     -> c GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [w_sful2 ww_sful3 ww1_sful4]
        case ww_sful3 of {
          __DEFAULT ->
              case ww1_sful4 of {
                Data.Data.DataType ww7_sful7 [Occ=Once] _ [Occ=Dead] ->
                    Data.Data.$wlvl ww7_sful7;
              };
          Data.Data.AlgConstr idx_sfula [Occ=Once!] ->
              case idx_sfula of {
                GHC.Types.I# ds_sfulc [Occ=Once!] ->
                    case ds_sfulc of {
                      __DEFAULT -> w_sful2 GHC.Exts.ForceSpecConstr;
                      1# -> w_sful2 GHC.Exts.NoSpecConstr;
                    };
              };
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=OtherCon []] =
    [] \r [w_sfule w5_sfulf w6_sfulg]
        case w6_sfulg of {
          Data.Data.Constr ww1_sfuli [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           ww5_sfulm [Occ=Once] ->
              GHC.Exts.$w$cgunfold w5_sfulf ww1_sfuli ww5_sfulm;
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> GHC.Exts.SpecConstrAnnotation
     -> c GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sfuln z_sfulo ds_sfulp]
        case ds_sfulp of {
          GHC.Exts.NoSpecConstr -> z_sfulo GHC.Exts.NoSpecConstr;
          GHC.Exts.ForceSpecConstr -> z_sfulo GHC.Exts.ForceSpecConstr;
        };

GHC.Exts.$dmfromListN
  :: forall l.
     GHC.Exts.IsList l =>
     GHC.Types.Int -> [GHC.Exts.Item l] -> l
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLL),1*U(1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dIsList_sfulr ds_sfuls] GHC.Exts.fromList $dIsList_sfulr;

GHC.Exts.$fIsListCallStack1
  :: GHC.Types.Int
     -> [([GHC.Types.Char], GHC.Stack.Types.SrcLoc)]
     -> GHC.Stack.Types.CallStack
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfult eta_B1] GHC.Stack.Types.fromCallSiteList eta_B1;

GHC.Exts.$fIsListCallStack [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Exts.IsList GHC.Stack.Types.CallStack
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [GHC.Stack.Types.fromCallSiteList
                                      GHC.Exts.$fIsListCallStack1
                                      GHC.Stack.Types.getCallStack];

GHC.Exts.$fIsListVersion1
  :: GHC.Types.Int -> [GHC.Types.Int] -> Data.Version.Version
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfulu eta_B1] Data.Version.makeVersion eta_B1;

GHC.Exts.$fIsListVersion [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Exts.IsList Data.Version.Version
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [Data.Version.makeVersion
                                      GHC.Exts.$fIsListVersion1
                                      Data.Version.versionBranch];

GHC.Exts.$fIsListNonEmpty_$cfromListN
  :: forall a.
     GHC.Types.Int
     -> [GHC.Exts.Item (GHC.Base.NonEmpty a)] -> GHC.Base.NonEmpty a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfulv eta_B1]
        GHC.Exts.$fIsListNonEmpty_$cfromList eta_B1;

GHC.Exts.$fIsListNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Exts.IsList (GHC.Base.NonEmpty a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [GHC.Exts.$fIsListNonEmpty_$cfromList
                                      GHC.Exts.$fIsListNonEmpty_$cfromListN
                                      GHC.Exts.$fIsListNonEmpty1];

GHC.Exts.$fIsList[]1 :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfulw eta_B1] GHC.Base.id eta_B1;

GHC.Exts.$fIsList[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Exts.IsList [a]
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [GHC.Base.id
                                      GHC.Exts.$fIsList[]1
                                      GHC.Base.id];

GHC.Exts.maxTupleSize :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [62#];

lvl1_rftgl :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Exts.the: empty list"#;

GHC.Exts.the2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rftgl of sat_sfulx {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfulx;
        };

lvl2_rftgm :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Exts.the: non-identical elements"#;

GHC.Exts.the1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rftgm of sat_sfuly {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfuly;
        };

GHC.Exts.the :: forall a. GHC.Classes.Eq a => [a] -> a
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfulz ds_sfulA]
        case ds_sfulA of {
          [] -> GHC.Exts.the2;
          : x_sfulC xs_sfulD [Occ=Once] ->
              let {
                sat_sfulE [Occ=Once, Dmd=<L,C(U)>] :: a_afsTA -> GHC.Types.Bool
                [LclId] =
                    [$dEq_sfulz x_sfulC] \u [] GHC.Classes.== $dEq_sfulz x_sfulC;
              } in 
                case GHC.List.all sat_sfulE xs_sfulD of {
                  GHC.Types.False -> GHC.Exts.the1;
                  GHC.Types.True -> x_sfulC;
                };
        };

GHC.Exts.sortWith
  :: forall b a. GHC.Classes.Ord b => (a -> b) -> [a] -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,A,A,A,A,A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfulG f_sfulH eta_sfulI]
        let {
          sat_sfulN [Occ=Once] :: a_afsTc -> a_afsTc -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfulG f_sfulH] \r [x_sfulJ y_sfulK]
                  let {
                    sat_sfulM [Occ=Once] :: b_afsTb
                    [LclId] =
                        [f_sfulH y_sfulK] \u [] f_sfulH y_sfulK; } in
                  let {
                    sat_sfulL [Occ=Once] :: b_afsTb
                    [LclId] =
                        [f_sfulH x_sfulJ] \u [] f_sfulH x_sfulJ;
                  } in  GHC.Classes.compare $dOrd_sfulG sat_sfulL sat_sfulM;
        } in  Data.OldList.sortBy sat_sfulN eta_sfulI;

GHC.Exts.groupByFB [InlPrag=INLINE[0] (sat-args=4)]
  :: forall a lst.
     ([a] -> lst -> lst)
     -> lst -> (a -> a -> GHC.Types.Bool) -> [a] -> lst
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,C(C(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [c_sfulO n_sfulP eq_sfulQ xs0_sfulR]
        let {
          groupByFBCore_sfulS [Occ=LoopBreaker] :: [a_afsSM] -> lst_afsSN
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [c_sfulO
                        n_sfulP
                        eq_sfulQ
                        groupByFBCore_sfulS] \r [ds_sfulT]
                  case ds_sfulT of {
                    [] -> n_sfulP;
                    : x_sfulV xs_sfulW [Occ=Once] ->
                        let {
                          ds1_sfulX [Dmd=<L,U(1*U,1*U)>] :: ([a_afsSM], [a_afsSM])
                          [LclId] =
                              [eq_sfulQ x_sfulV xs_sfulW] \u []
                                  let {
                                    sat_sfulY [Occ=Once, Dmd=<L,C(U)>] :: a_afsSM -> GHC.Types.Bool
                                    [LclId] =
                                        [eq_sfulQ x_sfulV] \u [] eq_sfulQ x_sfulV;
                                  } in 
                                    case GHC.List.$wspan sat_sfulY xs_sfulW of {
                                      (#,#) ww1_sfum0 [Occ=Once] ww2_sfum1 [Occ=Once] ->
                                          (,) [ww1_sfum0 ww2_sfum1];
                                    }; } in
                        let {
                          sat_sfuma [Occ=Once] :: lst_afsSN
                          [LclId] =
                              [groupByFBCore_sfulS ds1_sfulX] \u []
                                  case ds1_sfulX of {
                                    (,) _ [Occ=Dead] zs_sfum9 [Occ=Once] ->
                                        groupByFBCore_sfulS zs_sfum9;
                                  }; } in
                        let {
                          sat_sfum5 [Occ=Once] :: [a_afsSM]
                          [LclId] =
                              [ds1_sfulX] \u []
                                  case ds1_sfulX of {
                                    (,) ys_sfum3 [Occ=Once] _ [Occ=Dead] -> ys_sfum3;
                                  }; } in
                        let {
                          sat_sfum6 [Occ=Once] :: [a_afsSM]
                          [LclId] =
                              CCCS :! [x_sfulV sat_sfum5];
                        } in  c_sfulO sat_sfum6 sat_sfuma;
                  };
        } in  groupByFBCore_sfulS xs0_sfulR;

GHC.Exts.groupWith [InlPrag=INLINE (sat-args=2)]
  :: forall b a. GHC.Classes.Ord b => (a -> b) -> [a] -> [[a]]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfumb eta_sfumc eta1_sfumd]
        let {
          $dEq_sfume [Occ=OnceL, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq b_afsTj
          [LclId] =
              [$dOrd_sfumb] \u [] GHC.Classes.$p1Ord $dOrd_sfumb; } in
        let {
          groupByFBCore_sfumf [Occ=LoopBreaker] :: [a_afsTk] -> [[a_afsTk]]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [eta_sfumc $dEq_sfume groupByFBCore_sfumf] \r [ds_sfumg]
                  case ds_sfumg of {
                    [] -> [] [];
                    : x_sfumi xs_sfumj [Occ=Once] ->
                        let {
                          ds1_sfumk [Dmd=<L,U(1*U,1*U)>] :: ([a_afsTk], [a_afsTk])
                          [LclId] =
                              [eta_sfumc $dEq_sfume x_sfumi xs_sfumj] \u []
                                  let {
                                    lvl3_sfuml [Occ=OnceL] :: b_afsTj
                                    [LclId] =
                                        [eta_sfumc x_sfumi] \u [] eta_sfumc x_sfumi; } in
                                  let {
                                    sat_sfumo [Occ=Once] :: a_afsTk -> GHC.Types.Bool
                                    [LclId] =
                                        [eta_sfumc $dEq_sfume lvl3_sfuml] \r [y_sfumm]
                                            let {
                                              sat_sfumn [Occ=Once] :: b_afsTj
                                              [LclId] =
                                                  [eta_sfumc y_sfumm] \u [] eta_sfumc y_sfumm;
                                            } in  GHC.Classes.== $dEq_sfume lvl3_sfuml sat_sfumn;
                                  } in 
                                    case GHC.List.$wspan sat_sfumo xs_sfumj of {
                                      (#,#) ww1_sfumq [Occ=Once] ww2_sfumr [Occ=Once] ->
                                          (,) [ww1_sfumq ww2_sfumr];
                                    }; } in
                        let {
                          sat_sfumA [Occ=Once] :: [[a_afsTk]]
                          [LclId] =
                              [groupByFBCore_sfumf ds1_sfumk] \u []
                                  case ds1_sfumk of {
                                    (,) _ [Occ=Dead] zs_sfumz [Occ=Once] ->
                                        groupByFBCore_sfumf zs_sfumz;
                                  }; } in
                        let {
                          sat_sfumv [Occ=Once] :: [a_afsTk]
                          [LclId] =
                              [ds1_sfumk] \u []
                                  case ds1_sfumk of {
                                    (,) ys_sfumt [Occ=Once] _ [Occ=Dead] -> ys_sfumt;
                                  }; } in
                        let {
                          sat_sfumw [Occ=Once] :: [a_afsTk]
                          [LclId] =
                              CCCS :! [x_sfumi sat_sfumv];
                        } in  : [sat_sfumw sat_sfumA];
                  };
        } in 
          case
              GHC.Exts.sortWith $dOrd_sfumb eta_sfumc eta1_sfumd
          of
          sat_sfumB
          { __DEFAULT -> groupByFBCore_sfumf sat_sfumB;
          };

GHC.Exts.traceEvent :: GHC.Base.String -> GHC.Types.IO ()
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Debug.Trace.traceEventIO1 eta_B2 eta_B1;

GHC.Exts.$fDataSpecConstrAnnotation7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "SpecConstrAnnotation"#;

$tSpecConstrAnnotation1_rftgn :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# GHC.Exts.$fDataSpecConstrAnnotation7;

w1_rftgo :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ForceSpecConstr"#;

w2_rftgp :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# w1_rftgo;

w3_rftgq :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NoSpecConstr"#;

w4_rftgr :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# w3_rftgq;

go61_rftgs
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfumC _ys_sfumD]
        case ds2_sfumC of {
          [] -> GHC.List.badHead;
          : ipv_sfumF [Occ=Once!] ipv1_sfumG [Occ=Once] ->
              case _ys_sfumD of {
                [] -> GHC.List.badHead;
                : ipv2_sfumI [Occ=Once] ipv3_sfumJ [Occ=Once] ->
                    case ipv_sfumF of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfumM [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfumM w2_rftgp of {
                            GHC.Types.False -> go61_rftgs ipv1_sfumG ipv3_sfumJ;
                            GHC.Types.True -> ipv2_sfumI;
                          };
                    };
              };
        };

go1_rftgt
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfumR _ys_sfumS]
        case ds2_sfumR of {
          [] -> GHC.List.badHead;
          : ipv_sfumU [Occ=Once!] ipv1_sfumV [Occ=Once] ->
              case _ys_sfumS of {
                [] -> GHC.List.badHead;
                : ipv2_sfumX [Occ=Once] ipv3_sfumY [Occ=Once] ->
                    case ipv_sfumU of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfun1 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfun1 w4_rftgr of {
                            GHC.Types.False -> go1_rftgt ipv1_sfumV ipv3_sfumY;
                            GHC.Types.True -> ipv2_sfumX;
                          };
                    };
              };
        };

$cForceSpecConstr1_rftgu :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cForceSpecConstr2_rftgA];
$cNoSpecConstr1_rftgv :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cNoSpecConstr2_rftgz];
GHC.Exts.$cForceSpecConstr [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cForceSpecConstr1_rftgu
                                     w2_rftgp
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     GHC.Exts.$tSpecConstrAnnotation];
$tSpecConstrAnnotation2_rftgw :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Exts.$cForceSpecConstr GHC.Types.[]];
$tSpecConstrAnnotation3_rftgx :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Exts.$cNoSpecConstr
                      $tSpecConstrAnnotation2_rftgw];
$tSpecConstrAnnotation4_rftgy :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [$tSpecConstrAnnotation3_rftgx];
GHC.Exts.$tSpecConstrAnnotation [Occ=LoopBreaker]
  :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [$tSpecConstrAnnotation1_rftgn
                                       $tSpecConstrAnnotation4_rftgy];
GHC.Exts.$cNoSpecConstr [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cNoSpecConstr1_rftgv
                                     w4_rftgr
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     GHC.Exts.$tSpecConstrAnnotation];
$cNoSpecConstr2_rftgz :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go1_rftgt $tSpecConstrAnnotation3_rftgx Data.Data.mkConstr1;
$cForceSpecConstr2_rftgA :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rftgs $tSpecConstrAnnotation3_rftgx Data.Data.mkConstr1;

GHC.Exts.$fDataSpecConstrAnnotation_$cdataTypeOf
  :: GHC.Exts.SpecConstrAnnotation -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfun6] GHC.Exts.$tSpecConstrAnnotation;

GHC.Exts.$fDataSpecConstrAnnotation_$ctoConstr
  :: GHC.Exts.SpecConstrAnnotation -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sfun7]
        case ds_sfun7 of {
          GHC.Exts.NoSpecConstr -> GHC.Exts.$cNoSpecConstr;
          GHC.Exts.ForceSpecConstr -> GHC.Exts.$cForceSpecConstr;
        };

GHC.Exts.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Exts.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$trModule4];

GHC.Exts.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Exts"#;

GHC.Exts.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$trModule2];

GHC.Exts.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Exts.$trModule3
                                     GHC.Exts.$trModule1];

$krep_rftgB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.Exts.$tcIsList1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$* $krep_rftgB];

GHC.Exts.$fDataSpecConstrAnnotation6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$fDataSpecConstrAnnotation7];

GHC.Exts.$tcSpecConstrAnnotation :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8217012571387563927##
                                    8545973142114271769##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$fDataSpecConstrAnnotation6
                                    0#
                                    GHC.Types.krep$*];

GHC.Exts.$tc'ForceSpecConstr1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Exts.$tcSpecConstrAnnotation
                                              GHC.Types.[]];

GHC.Exts.$tc'NoSpecConstr2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'NoSpecConstr"#;

GHC.Exts.$tc'NoSpecConstr1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$tc'NoSpecConstr2];

GHC.Exts.$tc'NoSpecConstr :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [18402820579108170608##
                                    14598374581444186552##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$tc'NoSpecConstr1
                                    0#
                                    GHC.Exts.$tc'ForceSpecConstr1];

GHC.Exts.$tc'ForceSpecConstr3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'ForceSpecConstr"#;

GHC.Exts.$tc'ForceSpecConstr2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$tc'ForceSpecConstr3];

GHC.Exts.$tc'ForceSpecConstr :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13715005538542947299##
                                    3802030838304098377##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$tc'ForceSpecConstr2
                                    0#
                                    GHC.Exts.$tc'ForceSpecConstr1];

GHC.Exts.$fDataSpecConstrAnnotation5
  :: Data.Typeable.Internal.TypeRep GHC.Exts.SpecConstrAnnotation
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                8217012571387563927##
                8545973142114271769##
                GHC.Exts.$trModule
                GHC.Exts.$fDataSpecConstrAnnotation6
                0#
                GHC.Types.krep$*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfuna [Occ=Once]
                   ww9_sfunb [Occ=Once]
                   ww10_sfunc [Occ=Once]
                   ww11_sfund [Occ=Once]
                   ww12_sfune [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfuna
                                              ww9_sfunb
                                              ww10_sfunc
                                              ww11_sfund
                                              ww12_sfune];
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c GHC.Exts.SpecConstrAnnotation)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfunf ds_sfung] GHC.Base.Nothing [];

GHC.Exts.$fDataSpecConstrAnnotation2
  :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Exts.NoSpecConstr GHC.Types.False];

GHC.Exts.$fDataSpecConstrAnnotation1
  :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Exts.ForceSpecConstr GHC.Types.False];

GHC.Exts.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfunh w5_sfuni]
        let {
          lvl3_sfunj [Occ=OnceL] :: m_sftav GHC.Exts.SpecConstrAnnotation
          [LclId] =
              [w_sfunh] \u [] GHC.Base.mzero w_sfunh;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sfunh
          of
          $dMonad_sfunk [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfuns [Occ=Once]
                    :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                       -> m_sftav GHC.Exts.SpecConstrAnnotation
                  [LclId] =
                      [lvl3_sfunj $dMonad_sfunk] \r [ds_sfunn]
                          case ds_sfunn of {
                            (,) x'_sfunp [Occ=Once] b_sfunq [Occ=Once!] ->
                                case b_sfunq of {
                                  GHC.Types.False -> lvl3_sfunj;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfunk x'_sfunp;
                                };
                          }; } in
                let {
                  sat_sfunm [Occ=Once]
                    :: m_sftav (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                  [LclId] =
                      [w5_sfuni $dMonad_sfunk] \u []
                          case w5_sfuni of {
                            GHC.Exts.NoSpecConstr ->
                                GHC.Base.return $dMonad_sfunk GHC.Exts.$fDataSpecConstrAnnotation2;
                            GHC.Exts.ForceSpecConstr ->
                                GHC.Base.return $dMonad_sfunk GHC.Exts.$fDataSpecConstrAnnotation1;
                          };
                } in  GHC.Base.>>= $dMonad_sfunk sat_sfunm sat_sfuns;
          };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfunt w5_sfunu w6_sfunv]
        GHC.Exts.$w$cgmapMp w_sfunt w6_sfunv;

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapM
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfunw ds_sfunx eta_sfuny]
        case eta_sfuny of {
          GHC.Exts.NoSpecConstr ->
              GHC.Base.return $dMonad_sfunw GHC.Exts.NoSpecConstr;
          GHC.Exts.ForceSpecConstr ->
              GHC.Base.return $dMonad_sfunw GHC.Exts.ForceSpecConstr;
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQi
  :: forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> GHC.Exts.SpecConstrAnnotation
     -> u
[GblId, Arity=3, Str=<B,A><B,A><B,1*U>x, Unf=OtherCon []] =
    [] \r [ds_sfunA ds1_sfunB x_sfunC]
        case x_sfunC of { __DEFAULT -> Data.Maybe.fromJust1; };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> GHC.Exts.SpecConstrAnnotation
     -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfunE ds1_sfunF ds2_sfunG x0_sfunH]
        case x0_sfunH of { __DEFAULT -> ds1_sfunF; };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQ
  :: forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> GHC.Exts.SpecConstrAnnotation -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfunJ x0_sfunK] case x0_sfunK of { __DEFAULT -> [] []; };

GHC.Exts.$fDataSpecConstrAnnotation3
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> GHC.Exts.SpecConstrAnnotation
     -> Data.Functor.Const.Const r GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfunM ds1_sfunN ds2_sfunO eta_sfunP]
        case eta_sfunP of { __DEFAULT -> ds1_sfunN; };

GHC.Exts.$fDataSpecConstrAnnotation4
  :: (forall b. Data.Data.Data b => b -> b)
     -> GHC.Exts.SpecConstrAnnotation -> GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfunR x0_sfunS] x0_sfunS;

GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c GHC.Exts.SpecConstrAnnotation)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfunT ds_sfunU] GHC.Base.Nothing [];

GHC.Exts.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfunV w5_sfunW]
        let {
          lvl3_sfunX [Occ=OnceL] :: m_sftaA GHC.Exts.SpecConstrAnnotation
          [LclId] =
              [w_sfunV] \u [] GHC.Base.mzero w_sfunV;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sfunV
          of
          $dMonad_sfunY [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfuo6 [Occ=Once]
                    :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                       -> m_sftaA GHC.Exts.SpecConstrAnnotation
                  [LclId] =
                      [lvl3_sfunX $dMonad_sfunY] \r [ds_sfuo1]
                          case ds_sfuo1 of {
                            (,) x'_sfuo3 [Occ=Once] b_sfuo4 [Occ=Once!] ->
                                case b_sfuo4 of {
                                  GHC.Types.False -> lvl3_sfunX;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfunY x'_sfuo3;
                                };
                          }; } in
                let {
                  sat_sfuo0 [Occ=Once]
                    :: m_sftaA (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                  [LclId] =
                      [w5_sfunW $dMonad_sfunY] \u []
                          case w5_sfunW of {
                            GHC.Exts.NoSpecConstr ->
                                GHC.Base.return $dMonad_sfunY GHC.Exts.$fDataSpecConstrAnnotation2;
                            GHC.Exts.ForceSpecConstr ->
                                GHC.Base.return $dMonad_sfunY GHC.Exts.$fDataSpecConstrAnnotation1;
                          };
                } in  GHC.Base.>>= $dMonad_sfunY sat_sfuo0 sat_sfuo6;
          };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfuo7 w5_sfuo8 w6_sfuo9]
        GHC.Exts.$w$cgmapMo w_sfuo7 w6_sfuo9;

GHC.Exts.$fDataSpecConstrAnnotation [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Data.Data GHC.Exts.SpecConstrAnnotation
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Data.C:Data! [GHC.Exts.$fDataSpecConstrAnnotation5
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgfoldl
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgunfold
                                     GHC.Exts.$fDataSpecConstrAnnotation_$ctoConstr
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cdataTypeOf
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast1
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast2
                                     GHC.Exts.$fDataSpecConstrAnnotation4
                                     GHC.Exts.$fDataSpecConstrAnnotation3
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQr
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQ
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQi
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapM
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMp
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMo];

GHC.Exts.$tcIsList3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "IsList"#;

GHC.Exts.$tcIsList2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$tcIsList3];

GHC.Exts.$tcIsList :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17963880945977000500##
                                    13985778898022155754##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$tcIsList2
                                    0#
                                    GHC.Exts.$tcIsList1];

GHC.Exts.C:IsList
  :: forall l.
     ([GHC.Exts.Item l] -> l)
     -> (GHC.Types.Int -> [GHC.Exts.Item l] -> l)
     -> (l -> [GHC.Exts.Item l])
     -> GHC.Exts.IsList l
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Exts.C:IsList [eta_B3 eta_B2 eta_B1];

GHC.Exts.NoSpecConstr :: GHC.Exts.SpecConstrAnnotation
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Exts.NoSpecConstr! [];

GHC.Exts.ForceSpecConstr :: GHC.Exts.SpecConstrAnnotation
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Exts.ForceSpecConstr! [];


==================== STG syntax: ====================
2018-03-16 16:11:12.327683671 UTC

GHC.Exts.fromList
  :: forall l. GHC.Exts.IsList l => [GHC.Exts.Item l] -> l
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(SLL),U(U,A,A)>] =
    [] \r [v_sfukp]
        case v_sfukp of {
          GHC.Exts.C:IsList v_sfukr [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] ->
              v_sfukr;
        };

GHC.Exts.fromListN
  :: forall l.
     GHC.Exts.IsList l =>
     GHC.Types.Int -> [GHC.Exts.Item l] -> l
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LSL),U(A,U,A)>] =
    [] \r [v_sfuku]
        case v_sfuku of {
          GHC.Exts.C:IsList _ [Occ=Dead] v_sfukx [Occ=Once] _ [Occ=Dead] ->
              v_sfukx;
        };

GHC.Exts.toList
  :: forall l. GHC.Exts.IsList l => l -> [GHC.Exts.Item l]
[GblId[ClassOp], Arity=1, Caf=NoCafRefs, Str=<S(LLS),U(A,A,U)>] =
    [] \r [v_sfukz]
        case v_sfukz of {
          GHC.Exts.C:IsList _ [Occ=Dead] _ [Occ=Dead] v_sfukD [Occ=Once] ->
              v_sfukD;
        };

GHC.Exts.$fIsListNonEmpty1 :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_sfukE]
        let {
          sat_sfukM [Occ=Once] :: [a_afsY2]
          [LclId] =
              [ds_sfukE] \u []
                  case ds_sfukE of {
                    GHC.Base.:| _ [Occ=Dead] as_sfukL [Occ=Once] -> as_sfukL;
                  }; } in
        let {
          sat_sfukI [Occ=Once] :: a_afsY2
          [LclId] =
              [ds_sfukE] \u []
                  case ds_sfukE of {
                    GHC.Base.:| a1_sfukG [Occ=Once] _ [Occ=Dead] -> a1_sfukG;
                  };
        } in  : [sat_sfukI sat_sfukM];

lvl_rftgk :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty.fromList: empty list"#;

GHC.Exts.$fIsListNonEmpty2 :: forall a. GHC.Base.NonEmpty a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rftgk of sat_sfukN {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfukN;
        };

GHC.Exts.$fIsListNonEmpty_$cfromList
  :: forall a.
     [GHC.Exts.Item (GHC.Base.NonEmpty a)] -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sfukO]
        case ds_sfukO of {
          [] -> GHC.Exts.$fIsListNonEmpty2;
          : a1_sfukQ [Occ=Once] as_sfukR [Occ=Once] ->
              GHC.Base.:| [a1_sfukQ as_sfukR];
        };

GHC.Exts.$fEqSpecConstrAnnotation_$c==
  :: GHC.Exts.SpecConstrAnnotation
     -> GHC.Exts.SpecConstrAnnotation -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfukS ds1_sfukT]
        case ds_sfukS of {
          GHC.Exts.NoSpecConstr ->
              case ds1_sfukT of {
                GHC.Exts.NoSpecConstr -> GHC.Types.True [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.False [];
              };
          GHC.Exts.ForceSpecConstr ->
              case ds1_sfukT of {
                GHC.Exts.NoSpecConstr -> GHC.Types.False [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.True [];
              };
        };

GHC.Exts.$fEqSpecConstrAnnotation_$c/= [InlPrag=INLINE (sat-args=2)]
  :: GHC.Exts.SpecConstrAnnotation
     -> GHC.Exts.SpecConstrAnnotation -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_sfukX eta1_sfukY]
        case eta_sfukX of {
          GHC.Exts.NoSpecConstr ->
              case eta1_sfukY of {
                GHC.Exts.NoSpecConstr -> GHC.Types.False [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.True [];
              };
          GHC.Exts.ForceSpecConstr ->
              case eta1_sfukY of {
                GHC.Exts.NoSpecConstr -> GHC.Types.True [];
                GHC.Exts.ForceSpecConstr -> GHC.Types.False [];
              };
        };

GHC.Exts.$fEqSpecConstrAnnotation [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq GHC.Exts.SpecConstrAnnotation
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Exts.$fEqSpecConstrAnnotation_$c==
                                     GHC.Exts.$fEqSpecConstrAnnotation_$c/=];

GHC.Exts.$w$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall r. r -> c r)
     -> Data.Data.ConstrRep
     -> Data.Data.DataType
     -> c GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Str=<C(S),1*C1(U)><S,1*U><L,1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [w_sful2 ww_sful3 ww1_sful4]
        case ww_sful3 of {
          __DEFAULT ->
              case ww1_sful4 of {
                Data.Data.DataType ww7_sful7 [Occ=Once] _ [Occ=Dead] ->
                    Data.Data.$wlvl ww7_sful7;
              };
          Data.Data.AlgConstr idx_sfula [Occ=Once!] ->
              case idx_sfula of {
                GHC.Types.I# ds_sfulc [Occ=Once!] ->
                    case ds_sfulc of {
                      __DEFAULT -> w_sful2 GHC.Exts.ForceSpecConstr;
                      1# -> w_sful2 GHC.Exts.NoSpecConstr;
                    };
              };
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cgunfold [InlPrag=NOUSERINLINE[0]]
  :: forall (c :: * -> *).
     (forall b r. Data.Data.Data b => c (b -> r) -> c r)
     -> (forall r. r -> c r)
     -> Data.Data.Constr
     -> c GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Str=<L,A><C(S),1*C1(U)><S(SLLLL),1*U(1*U,A,A,A,1*U(1*U,A))>,
 Unf=OtherCon []] =
    [] \r [w_sfule w5_sfulf w6_sfulg]
        case w6_sfulg of {
          Data.Data.Constr ww1_sfuli [Occ=Once]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           ww5_sfulm [Occ=Once] ->
              GHC.Exts.$w$cgunfold w5_sfulf ww1_sfuli ww5_sfulm;
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cgfoldl
  :: forall (c :: * -> *).
     (forall d b. Data.Data.Data d => c (d -> b) -> d -> c b)
     -> (forall g. g -> c g)
     -> GHC.Exts.SpecConstrAnnotation
     -> c GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sfuln z_sfulo ds_sfulp]
        case ds_sfulp of {
          GHC.Exts.NoSpecConstr -> z_sfulo GHC.Exts.NoSpecConstr;
          GHC.Exts.ForceSpecConstr -> z_sfulo GHC.Exts.ForceSpecConstr;
        };

GHC.Exts.$dmfromListN
  :: forall l.
     GHC.Exts.IsList l =>
     GHC.Types.Int -> [GHC.Exts.Item l] -> l
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(SLL),1*U(1*U,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dIsList_sfulr ds_sfuls] GHC.Exts.fromList $dIsList_sfulr;

GHC.Exts.$fIsListCallStack1
  :: GHC.Types.Int
     -> [([GHC.Types.Char], GHC.Stack.Types.SrcLoc)]
     -> GHC.Stack.Types.CallStack
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfult eta_B1] GHC.Stack.Types.fromCallSiteList eta_B1;

GHC.Exts.$fIsListCallStack [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Exts.IsList GHC.Stack.Types.CallStack
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [GHC.Stack.Types.fromCallSiteList
                                      GHC.Exts.$fIsListCallStack1
                                      GHC.Stack.Types.getCallStack];

GHC.Exts.$fIsListVersion1
  :: GHC.Types.Int -> [GHC.Types.Int] -> Data.Version.Version
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfulu eta_B1] Data.Version.makeVersion eta_B1;

GHC.Exts.$fIsListVersion [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Exts.IsList Data.Version.Version
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [Data.Version.makeVersion
                                      GHC.Exts.$fIsListVersion1
                                      Data.Version.versionBranch];

GHC.Exts.$fIsListNonEmpty_$cfromListN
  :: forall a.
     GHC.Types.Int
     -> [GHC.Exts.Item (GHC.Base.NonEmpty a)] -> GHC.Base.NonEmpty a
[GblId, Arity=2, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfulv eta_B1]
        GHC.Exts.$fIsListNonEmpty_$cfromList eta_B1;

GHC.Exts.$fIsListNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Exts.IsList (GHC.Base.NonEmpty a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [GHC.Exts.$fIsListNonEmpty_$cfromList
                                      GHC.Exts.$fIsListNonEmpty_$cfromListN
                                      GHC.Exts.$fIsListNonEmpty1];

GHC.Exts.$fIsList[]1 :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A>, Unf=OtherCon []] =
    [] \r [ds_sfulw eta_B1] GHC.Base.id eta_B1;

GHC.Exts.$fIsList[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Exts.IsList [a]
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Exts.C:IsList! [GHC.Base.id
                                      GHC.Exts.$fIsList[]1
                                      GHC.Base.id];

GHC.Exts.maxTupleSize :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [62#];

lvl1_rftgl :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Exts.the: empty list"#;

GHC.Exts.the2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rftgl of sat_sfulx {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfulx;
        };

lvl2_rftgm :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Exts.the: non-identical elements"#;

GHC.Exts.the1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl2_rftgm of sat_sfuly {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sfuly;
        };

GHC.Exts.the :: forall a. GHC.Classes.Eq a => [a] -> a
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sfulz ds_sfulA]
        case ds_sfulA of {
          [] -> GHC.Exts.the2;
          : x_sfulC xs_sfulD [Occ=Once] ->
              let {
                sat_sfulE [Occ=Once, Dmd=<L,C(U)>] :: a_afsTA -> GHC.Types.Bool
                [LclId] =
                    [$dEq_sfulz x_sfulC] \u [] GHC.Classes.== $dEq_sfulz x_sfulC;
              } in 
                case GHC.List.all sat_sfulE xs_sfulD of {
                  GHC.Types.False -> GHC.Exts.the1;
                  GHC.Types.True -> x_sfulC;
                };
        };

GHC.Exts.sortWith
  :: forall b a. GHC.Classes.Ord b => (a -> b) -> [a] -> [a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,A,A,A,A,A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfulG f_sfulH eta_sfulI]
        let {
          sat_sfulN [Occ=Once] :: a_afsTc -> a_afsTc -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_sfulG f_sfulH] \r [x_sfulJ y_sfulK]
                  let {
                    sat_sfulM [Occ=Once] :: b_afsTb
                    [LclId] =
                        [f_sfulH y_sfulK] \u [] f_sfulH y_sfulK; } in
                  let {
                    sat_sfulL [Occ=Once] :: b_afsTb
                    [LclId] =
                        [f_sfulH x_sfulJ] \u [] f_sfulH x_sfulJ;
                  } in  GHC.Classes.compare $dOrd_sfulG sat_sfulL sat_sfulM;
        } in  Data.OldList.sortBy sat_sfulN eta_sfulI;

GHC.Exts.groupByFB [InlPrag=INLINE[0] (sat-args=4)]
  :: forall a lst.
     ([a] -> lst -> lst)
     -> lst -> (a -> a -> GHC.Types.Bool) -> [a] -> lst
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,C(C(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [c_sfulO n_sfulP eq_sfulQ xs0_sfulR]
        let {
          groupByFBCore_sfulS [Occ=LoopBreaker] :: [a_afsSM] -> lst_afsSN
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [c_sfulO
                        n_sfulP
                        eq_sfulQ
                        groupByFBCore_sfulS] \r [ds_sfulT]
                  case ds_sfulT of {
                    [] -> n_sfulP;
                    : x_sfulV xs_sfulW [Occ=Once] ->
                        let {
                          ds1_sfulX [Dmd=<L,U(1*U,1*U)>] :: ([a_afsSM], [a_afsSM])
                          [LclId] =
                              [eq_sfulQ x_sfulV xs_sfulW] \u []
                                  let {
                                    sat_sfulY [Occ=Once, Dmd=<L,C(U)>] :: a_afsSM -> GHC.Types.Bool
                                    [LclId] =
                                        [eq_sfulQ x_sfulV] \u [] eq_sfulQ x_sfulV;
                                  } in 
                                    case GHC.List.$wspan sat_sfulY xs_sfulW of {
                                      (#,#) ww1_sfum0 [Occ=Once] ww2_sfum1 [Occ=Once] ->
                                          (,) [ww1_sfum0 ww2_sfum1];
                                    }; } in
                        let {
                          sat_sfuma [Occ=Once] :: lst_afsSN
                          [LclId] =
                              [groupByFBCore_sfulS ds1_sfulX] \u []
                                  case ds1_sfulX of {
                                    (,) _ [Occ=Dead] zs_sfum9 [Occ=Once] ->
                                        groupByFBCore_sfulS zs_sfum9;
                                  }; } in
                        let {
                          sat_sfum5 [Occ=Once] :: [a_afsSM]
                          [LclId] =
                              [ds1_sfulX] \u []
                                  case ds1_sfulX of {
                                    (,) ys_sfum3 [Occ=Once] _ [Occ=Dead] -> ys_sfum3;
                                  }; } in
                        let {
                          sat_sfum6 [Occ=Once] :: [a_afsSM]
                          [LclId] =
                              CCCS :! [x_sfulV sat_sfum5];
                        } in  c_sfulO sat_sfum6 sat_sfuma;
                  };
        } in  groupByFBCore_sfulS xs0_sfulR;

GHC.Exts.groupWith [InlPrag=INLINE (sat-args=2)]
  :: forall b a. GHC.Classes.Ord b => (a -> b) -> [a] -> [[a]]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sfumb eta_sfumc eta1_sfumd]
        let {
          $dEq_sfume [Occ=OnceL, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq b_afsTj
          [LclId] =
              [$dOrd_sfumb] \u [] GHC.Classes.$p1Ord $dOrd_sfumb; } in
        let {
          groupByFBCore_sfumf [Occ=LoopBreaker] :: [a_afsTk] -> [[a_afsTk]]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [eta_sfumc $dEq_sfume groupByFBCore_sfumf] \r [ds_sfumg]
                  case ds_sfumg of {
                    [] -> [] [];
                    : x_sfumi xs_sfumj [Occ=Once] ->
                        let {
                          ds1_sfumk [Dmd=<L,U(1*U,1*U)>] :: ([a_afsTk], [a_afsTk])
                          [LclId] =
                              [eta_sfumc $dEq_sfume x_sfumi xs_sfumj] \u []
                                  let {
                                    lvl3_sfuml [Occ=OnceL] :: b_afsTj
                                    [LclId] =
                                        [eta_sfumc x_sfumi] \u [] eta_sfumc x_sfumi; } in
                                  let {
                                    sat_sfumo [Occ=Once] :: a_afsTk -> GHC.Types.Bool
                                    [LclId] =
                                        [eta_sfumc $dEq_sfume lvl3_sfuml] \r [y_sfumm]
                                            let {
                                              sat_sfumn [Occ=Once] :: b_afsTj
                                              [LclId] =
                                                  [eta_sfumc y_sfumm] \u [] eta_sfumc y_sfumm;
                                            } in  GHC.Classes.== $dEq_sfume lvl3_sfuml sat_sfumn;
                                  } in 
                                    case GHC.List.$wspan sat_sfumo xs_sfumj of {
                                      (#,#) ww1_sfumq [Occ=Once] ww2_sfumr [Occ=Once] ->
                                          (,) [ww1_sfumq ww2_sfumr];
                                    }; } in
                        let {
                          sat_sfumA [Occ=Once] :: [[a_afsTk]]
                          [LclId] =
                              [groupByFBCore_sfumf ds1_sfumk] \u []
                                  case ds1_sfumk of {
                                    (,) _ [Occ=Dead] zs_sfumz [Occ=Once] ->
                                        groupByFBCore_sfumf zs_sfumz;
                                  }; } in
                        let {
                          sat_sfumv [Occ=Once] :: [a_afsTk]
                          [LclId] =
                              [ds1_sfumk] \u []
                                  case ds1_sfumk of {
                                    (,) ys_sfumt [Occ=Once] _ [Occ=Dead] -> ys_sfumt;
                                  }; } in
                        let {
                          sat_sfumw [Occ=Once] :: [a_afsTk]
                          [LclId] =
                              CCCS :! [x_sfumi sat_sfumv];
                        } in  : [sat_sfumw sat_sfumA];
                  };
        } in 
          case
              GHC.Exts.sortWith $dOrd_sfumb eta_sfumc eta1_sfumd
          of
          sat_sfumB
          { __DEFAULT -> groupByFBCore_sfumf sat_sfumB;
          };

GHC.Exts.traceEvent :: GHC.Base.String -> GHC.Types.IO ()
[GblId, Arity=2, Str=<L,U><S,U>, Unf=OtherCon []] =
    [] \r [eta_B2 void_0E]
        Debug.Trace.traceEventIO1 eta_B2 GHC.Prim.void#;

GHC.Exts.$fDataSpecConstrAnnotation7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "SpecConstrAnnotation"#;

$tSpecConstrAnnotation1_rftgn :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# GHC.Exts.$fDataSpecConstrAnnotation7;

w1_rftgo :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "ForceSpecConstr"#;

w2_rftgp :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# w1_rftgo;

w3_rftgq :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NoSpecConstr"#;

w4_rftgr :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# w3_rftgq;

go61_rftgs
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfumC _ys_sfumD]
        case ds2_sfumC of {
          [] -> GHC.List.badHead;
          : ipv_sfumF [Occ=Once!] ipv1_sfumG [Occ=Once] ->
              case _ys_sfumD of {
                [] -> GHC.List.badHead;
                : ipv2_sfumI [Occ=Once] ipv3_sfumJ [Occ=Once] ->
                    case ipv_sfumF of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfumM [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfumM w2_rftgp of {
                            GHC.Types.False -> go61_rftgs ipv1_sfumG ipv3_sfumJ;
                            GHC.Types.True -> ipv2_sfumI;
                          };
                    };
              };
        };

go1_rftgt
  :: [Data.Data.Constr] -> [GHC.Types.Int] -> Data.Data.ConIndex
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [ds2_sfumR _ys_sfumS]
        case ds2_sfumR of {
          [] -> GHC.List.badHead;
          : ipv_sfumU [Occ=Once!] ipv1_sfumV [Occ=Once] ->
              case _ys_sfumS of {
                [] -> GHC.List.badHead;
                : ipv2_sfumX [Occ=Once] ipv3_sfumY [Occ=Once] ->
                    case ipv_sfumU of {
                      Data.Data.Constr _ [Occ=Dead]
                                       ds4_sfun1 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
                          case GHC.Base.eqString ds4_sfun1 w4_rftgr of {
                            GHC.Types.False -> go1_rftgt ipv1_sfumV ipv3_sfumY;
                            GHC.Types.True -> ipv2_sfumX;
                          };
                    };
              };
        };

$cForceSpecConstr1_rftgu :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cForceSpecConstr2_rftgA];
$cNoSpecConstr1_rftgv :: Data.Data.ConstrRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgConstr! [$cNoSpecConstr2_rftgz];
GHC.Exts.$cForceSpecConstr [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cForceSpecConstr1_rftgu
                                     w2_rftgp
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     GHC.Exts.$tSpecConstrAnnotation];
$tSpecConstrAnnotation2_rftgw :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Exts.$cForceSpecConstr GHC.Types.[]];
$tSpecConstrAnnotation3_rftgx :: [Data.Data.Constr]
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Exts.$cNoSpecConstr
                      $tSpecConstrAnnotation2_rftgw];
$tSpecConstrAnnotation4_rftgy :: Data.Data.DataRep
[GblId, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.AlgRep! [$tSpecConstrAnnotation3_rftgx];
GHC.Exts.$tSpecConstrAnnotation [Occ=LoopBreaker]
  :: Data.Data.DataType
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.DataType! [$tSpecConstrAnnotation1_rftgn
                                       $tSpecConstrAnnotation4_rftgy];
GHC.Exts.$cNoSpecConstr [Occ=LoopBreaker] :: Data.Data.Constr
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE Data.Data.Constr! [$cNoSpecConstr1_rftgv
                                     w4_rftgr
                                     GHC.Types.[]
                                     Data.Data.Prefix
                                     GHC.Exts.$tSpecConstrAnnotation];
$cNoSpecConstr2_rftgz :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go1_rftgt $tSpecConstrAnnotation3_rftgx Data.Data.mkConstr1;
$cForceSpecConstr2_rftgA :: Data.Data.ConIndex
[GblId] =
    [] \u []
        go61_rftgs $tSpecConstrAnnotation3_rftgx Data.Data.mkConstr1;

GHC.Exts.$fDataSpecConstrAnnotation_$cdataTypeOf
  :: GHC.Exts.SpecConstrAnnotation -> Data.Data.DataType
[GblId, Arity=1, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_sfun6] GHC.Exts.$tSpecConstrAnnotation;

GHC.Exts.$fDataSpecConstrAnnotation_$ctoConstr
  :: GHC.Exts.SpecConstrAnnotation -> Data.Data.Constr
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sfun7]
        case ds_sfun7 of {
          GHC.Exts.NoSpecConstr -> GHC.Exts.$cNoSpecConstr;
          GHC.Exts.ForceSpecConstr -> GHC.Exts.$cForceSpecConstr;
        };

GHC.Exts.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.Exts.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$trModule4];

GHC.Exts.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.Exts"#;

GHC.Exts.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$trModule2];

GHC.Exts.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.Exts.$trModule3
                                     GHC.Exts.$trModule1];

$krep_rftgB :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

GHC.Exts.$tcIsList1 [InlPrag=NOUSERINLINE[~]] :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$* $krep_rftgB];

GHC.Exts.$fDataSpecConstrAnnotation6 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$fDataSpecConstrAnnotation7];

GHC.Exts.$tcSpecConstrAnnotation :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [8217012571387563927##
                                    8545973142114271769##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$fDataSpecConstrAnnotation6
                                    0#
                                    GHC.Types.krep$*];

GHC.Exts.$tc'ForceSpecConstr1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Exts.$tcSpecConstrAnnotation
                                              GHC.Types.[]];

GHC.Exts.$tc'NoSpecConstr2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'NoSpecConstr"#;

GHC.Exts.$tc'NoSpecConstr1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$tc'NoSpecConstr2];

GHC.Exts.$tc'NoSpecConstr :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [18402820579108170608##
                                    14598374581444186552##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$tc'NoSpecConstr1
                                    0#
                                    GHC.Exts.$tc'ForceSpecConstr1];

GHC.Exts.$tc'ForceSpecConstr3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'ForceSpecConstr"#;

GHC.Exts.$tc'ForceSpecConstr2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$tc'ForceSpecConstr3];

GHC.Exts.$tc'ForceSpecConstr :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13715005538542947299##
                                    3802030838304098377##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$tc'ForceSpecConstr2
                                    0#
                                    GHC.Exts.$tc'ForceSpecConstr1];

GHC.Exts.$fDataSpecConstrAnnotation5
  :: Data.Typeable.Internal.TypeRep GHC.Exts.SpecConstrAnnotation
[GblId] =
    [] \u []
        case
            Data.Typeable.Internal.$wmkTrCon
                8217012571387563927##
                8545973142114271769##
                GHC.Exts.$trModule
                GHC.Exts.$fDataSpecConstrAnnotation6
                0#
                GHC.Types.krep$*
                GHC.Types.[]
        of
        { (#,,,,#) ww8_sfuna [Occ=Once]
                   ww9_sfunb [Occ=Once]
                   ww10_sfunc [Occ=Once]
                   ww11_sfund [Occ=Once]
                   ww12_sfune [Occ=Once] ->
              Data.Typeable.Internal.TrTyCon [ww8_sfuna
                                              ww9_sfunb
                                              ww10_sfunc
                                              ww11_sfund
                                              ww12_sfune];
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast1
  :: forall (t :: * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d. Data.Data.Data d => c (t d))
     -> GHC.Base.Maybe (c GHC.Exts.SpecConstrAnnotation)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfunf ds_sfung] GHC.Base.Nothing [];

GHC.Exts.$fDataSpecConstrAnnotation2
  :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Exts.NoSpecConstr GHC.Types.False];

GHC.Exts.$fDataSpecConstrAnnotation1
  :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE (,)! [GHC.Exts.ForceSpecConstr GHC.Types.False];

GHC.Exts.$w$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfunh w5_sfuni]
        let {
          lvl3_sfunj [Occ=OnceL] :: m_sftav GHC.Exts.SpecConstrAnnotation
          [LclId] =
              [w_sfunh] \u [] GHC.Base.mzero w_sfunh;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sfunh
          of
          $dMonad_sfunk [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfuns [Occ=Once]
                    :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                       -> m_sftav GHC.Exts.SpecConstrAnnotation
                  [LclId] =
                      [lvl3_sfunj $dMonad_sfunk] \r [ds_sfunn]
                          case ds_sfunn of {
                            (,) x'_sfunp [Occ=Once] b_sfunq [Occ=Once!] ->
                                case b_sfunq of {
                                  GHC.Types.False -> lvl3_sfunj;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfunk x'_sfunp;
                                };
                          }; } in
                let {
                  sat_sfunm [Occ=Once]
                    :: m_sftav (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                  [LclId] =
                      [w5_sfuni $dMonad_sfunk] \u []
                          case w5_sfuni of {
                            GHC.Exts.NoSpecConstr ->
                                GHC.Base.return $dMonad_sfunk GHC.Exts.$fDataSpecConstrAnnotation2;
                            GHC.Exts.ForceSpecConstr ->
                                GHC.Base.return $dMonad_sfunk GHC.Exts.$fDataSpecConstrAnnotation1;
                          };
                } in  GHC.Base.>>= $dMonad_sfunk sat_sfunm sat_sfuns;
          };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMp [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfunt w5_sfunu w6_sfunv]
        GHC.Exts.$w$cgmapMp w_sfunt w6_sfunv;

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapM
  :: forall (m :: * -> *).
     GHC.Base.Monad m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)L),1*U(A,A,A,1*C1(U),A)><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonad_sfunw ds_sfunx eta_sfuny]
        case eta_sfuny of {
          GHC.Exts.NoSpecConstr ->
              GHC.Base.return $dMonad_sfunw GHC.Exts.NoSpecConstr;
          GHC.Exts.ForceSpecConstr ->
              GHC.Base.return $dMonad_sfunw GHC.Exts.ForceSpecConstr;
        };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQi
  :: forall u.
     GHC.Types.Int
     -> (forall d. Data.Data.Data d => d -> u)
     -> GHC.Exts.SpecConstrAnnotation
     -> u
[GblId, Arity=3, Str=<B,A><B,A><B,1*U>x, Unf=OtherCon []] =
    [] \r [ds_sfunA ds1_sfunB x_sfunC]
        case x_sfunC of { __DEFAULT -> Data.Maybe.fromJust1; };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQr
  :: forall r r'.
     (r' -> r -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> GHC.Exts.SpecConstrAnnotation
     -> r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfunE ds1_sfunF ds2_sfunG x0_sfunH]
        case x0_sfunH of { __DEFAULT -> ds1_sfunF; };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQ
  :: forall u.
     (forall d. Data.Data.Data d => d -> u)
     -> GHC.Exts.SpecConstrAnnotation -> [u]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfunJ x0_sfunK] case x0_sfunK of { __DEFAULT -> [] []; };

GHC.Exts.$fDataSpecConstrAnnotation3
  :: forall r r'.
     (r -> r' -> r)
     -> r
     -> (forall d. Data.Data.Data d => d -> r')
     -> GHC.Exts.SpecConstrAnnotation
     -> Data.Functor.Const.Const r GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U><L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfunM ds1_sfunN ds2_sfunO eta_sfunP]
        case eta_sfunP of { __DEFAULT -> ds1_sfunN; };

GHC.Exts.$fDataSpecConstrAnnotation4
  :: (forall b. Data.Data.Data b => b -> b)
     -> GHC.Exts.SpecConstrAnnotation -> GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sfunR x0_sfunS] x0_sfunS;

GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast2
  :: forall (t :: * -> * -> *) (c :: * -> *).
     Data.Typeable.Internal.Typeable t =>
     (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
     -> GHC.Base.Maybe (c GHC.Exts.SpecConstrAnnotation)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [$dTypeable_sfunT ds_sfunU] GHC.Base.Nothing [];

GHC.Exts.$w$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,1*U(A,1*C1(C1(U)),A,C(U),A),1*U,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfunV w5_sfunW]
        let {
          lvl3_sfunX [Occ=OnceL] :: m_sftaA GHC.Exts.SpecConstrAnnotation
          [LclId] =
              [w_sfunV] \u [] GHC.Base.mzero w_sfunV;
        } in 
          case
              GHC.Base.$p2MonadPlus w_sfunV
          of
          $dMonad_sfunY [Dmd=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)>]
          { __DEFAULT ->
                let {
                  sat_sfuo6 [Occ=Once]
                    :: (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                       -> m_sftaA GHC.Exts.SpecConstrAnnotation
                  [LclId] =
                      [lvl3_sfunX $dMonad_sfunY] \r [ds_sfuo1]
                          case ds_sfuo1 of {
                            (,) x'_sfuo3 [Occ=Once] b_sfuo4 [Occ=Once!] ->
                                case b_sfuo4 of {
                                  GHC.Types.False -> lvl3_sfunX;
                                  GHC.Types.True -> GHC.Base.return $dMonad_sfunY x'_sfuo3;
                                };
                          }; } in
                let {
                  sat_sfuo0 [Occ=Once]
                    :: m_sftaA (GHC.Exts.SpecConstrAnnotation, GHC.Types.Bool)
                  [LclId] =
                      [w5_sfunW $dMonad_sfunY] \u []
                          case w5_sfunW of {
                            GHC.Exts.NoSpecConstr ->
                                GHC.Base.return $dMonad_sfunY GHC.Exts.$fDataSpecConstrAnnotation2;
                            GHC.Exts.ForceSpecConstr ->
                                GHC.Base.return $dMonad_sfunY GHC.Exts.$fDataSpecConstrAnnotation1;
                          };
                } in  GHC.Base.>>= $dMonad_sfunY sat_sfuo0 sat_sfuo6;
          };

GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMo [InlPrag=NOUSERINLINE[0]]
  :: forall (m :: * -> *).
     GHC.Base.MonadPlus m =>
     (forall d. Data.Data.Data d => d -> m d)
     -> GHC.Exts.SpecConstrAnnotation -> m GHC.Exts.SpecConstrAnnotation
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LS(LC(C(S))LLL)LL),U(A,U(A,C(C1(U)),A,C(U),A),U,A)><L,A><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sfuo7 w5_sfuo8 w6_sfuo9]
        GHC.Exts.$w$cgmapMo w_sfuo7 w6_sfuo9;

GHC.Exts.$fDataSpecConstrAnnotation [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Data.Data GHC.Exts.SpecConstrAnnotation
[GblId[DFunId]] =
    CCS_DONT_CARE Data.Data.C:Data! [GHC.Exts.$fDataSpecConstrAnnotation5
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgfoldl
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgunfold
                                     GHC.Exts.$fDataSpecConstrAnnotation_$ctoConstr
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cdataTypeOf
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast1
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cdataCast2
                                     GHC.Exts.$fDataSpecConstrAnnotation4
                                     GHC.Exts.$fDataSpecConstrAnnotation3
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQr
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQ
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapQi
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapM
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMp
                                     GHC.Exts.$fDataSpecConstrAnnotation_$cgmapMo];

GHC.Exts.$tcIsList3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "IsList"#;

GHC.Exts.$tcIsList2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.Exts.$tcIsList3];

GHC.Exts.$tcIsList :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [17963880945977000500##
                                    13985778898022155754##
                                    GHC.Exts.$trModule
                                    GHC.Exts.$tcIsList2
                                    0#
                                    GHC.Exts.$tcIsList1];

GHC.Exts.C:IsList
  :: forall l.
     ([GHC.Exts.Item l] -> l)
     -> (GHC.Types.Int -> [GHC.Exts.Item l] -> l)
     -> (l -> [GHC.Exts.Item l])
     -> GHC.Exts.IsList l
[GblId[DataCon],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.Exts.C:IsList [eta_B3 eta_B2 eta_B1];

GHC.Exts.NoSpecConstr :: GHC.Exts.SpecConstrAnnotation
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Exts.NoSpecConstr! [];

GHC.Exts.ForceSpecConstr :: GHC.Exts.SpecConstrAnnotation
[GblId[DataCon], Caf=NoCafRefs, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Exts.ForceSpecConstr! [];

