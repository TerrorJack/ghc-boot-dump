
==================== Output Cmm ====================
2018-03-16 16:06:33.252463294 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:33.253066724 UTC

[section ""cstring" . GHC.Fingerprint.$trModule4_bytes" {
     GHC.Fingerprint.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.253721041 UTC

[section ""data" . GHC.Fingerprint.$trModule3_closure" {
     GHC.Fingerprint.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.254260577 UTC

[section ""cstring" . GHC.Fingerprint.$trModule2_bytes" {
     GHC.Fingerprint.$trModule2_bytes:
         I8[] [71,72,67,46,70,105,110,103,101,114,112,114,105,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.254806678 UTC

[section ""data" . GHC.Fingerprint.$trModule1_closure" {
     GHC.Fingerprint.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.25532999 UTC

[section ""data" . GHC.Fingerprint.$trModule_closure" {
     GHC.Fingerprint.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Fingerprint.$trModule3_closure+1;
         const GHC.Fingerprint.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.255894647 UTC

[section ""cstring" . GHC.Fingerprint.$tcMD5Context2_bytes" {
     GHC.Fingerprint.$tcMD5Context2_bytes:
         I8[] [77,68,53,67,111,110,116,101,120,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.25645875 UTC

[section ""data" . GHC.Fingerprint.$tcMD5Context1_closure" {
     GHC.Fingerprint.$tcMD5Context1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.$tcMD5Context2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.257006067 UTC

[section ""data" . GHC.Fingerprint.$tcMD5Context_closure" {
     GHC.Fingerprint.$tcMD5Context_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Fingerprint.$trModule_closure+1;
         const GHC.Fingerprint.$tcMD5Context1_closure+1;
         const GHC.Types.krep$*_closure;
         const 2786815183060026909;
         const 11852912954819316049;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.257790532 UTC

[section ""data" . GHC.Fingerprint.fingerprint0_closure" {
     GHC.Fingerprint.fingerprint0_closure:
         const GHC.Fingerprint.Type.Fingerprint_con_info;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.258327703 UTC

[section ""cstring" . lvl_rbDDO_bytes" {
     lvl_rbDDO_bytes:
         I8[] [71,72,67,46,70,105,110,103,101,114,112,114,105,110,116,46,103,101,116,70,105,108,101,72,97,115,104,58,32,111,110,108,121,32,114,101,97,100,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.258877932 UTC

[section ""cstring" . lvl1_rbDDP_bytes" {
     lvl1_rbDDP_bytes:
         I8[] [32,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.259710072 UTC

[section ""data" . lvl2_rbDDQ_closure" {
     lvl2_rbDDQ_closure:
         const lvl2_rbDDQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rbDDQ_entry() //  [R1]
         { info_tbl: [(cbDHC,
                       label: lvl2_rbDDQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDHC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbDHD; else goto cbDHE;
       cbDHD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDHE: // global
           (_cbDHz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbDHz::I64 == 0) goto cbDHB; else goto cbDHA;
       cbDHB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbDHA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbDHz::I64;
           R2 = lvl1_rbDDP_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.261133407 UTC

[section ""data" . GHC.Fingerprint.$wlvl_closure" {
     GHC.Fingerprint.$wlvl_closure:
         const GHC.Fingerprint.$wlvl_info;
         const 0;
 },
 sat_sbDDX_entry() //  [R1]
         { info_tbl: [(cbDHQ,
                       label: sat_sbDDX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDHQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbDHR; else goto cbDHS;
       cbDHR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDHS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbDHN_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbDHN() //  [R1, R2]
         { info_tbl: [(cbDHN,
                       label: block_cbDHN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDHN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbDHV; else goto cbDHU;
       cbDHV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbDHU: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl2_rbDDQ_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.$wlvl_entry() //  [R2]
         { info_tbl: [(cbDHY,
                       label: GHC.Fingerprint.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDHY: // global
           _sbDDS::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbDHZ; else goto cbDI0;
       cbDI0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbDI2; else goto cbDI1;
       cbDI2: // global
           HpAlloc = 24;
           goto cbDHZ;
       cbDHZ: // global
           R2 = _sbDDS::I64;
           R1 = GHC.Fingerprint.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbDI1: // global
           I64[Hp - 16] = sat_sbDDX_info;
           I64[Hp] = _sbDDS::I64;
           I64[Sp - 8] = block_cbDHW_info;
           R3 = Hp - 16;
           R2 = lvl_rbDDO_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDHW() //  [R1]
         { info_tbl: [(cbDHW,
                       label: block_cbDHW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDHW: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.264467488 UTC

[section ""data" . GHC.Fingerprint.getFileHash2_closure" {
     GHC.Fingerprint.getFileHash2_closure:
         const GHC.Fingerprint.getFileHash2_info;
         const 0;
 },
 sat_sbDEH_entry() //  [R1]
         { info_tbl: [(cbDIR,
                       label: sat_sbDEH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDIR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbDIS; else goto cbDIT;
       cbDIS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDIT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$WFingerprint_entry(R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.getFileHash2_entry() //  [R2]
         { info_tbl: [(cbDIU,
                       label: GHC.Fingerprint.getFileHash2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDIU: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cbDIV; else goto cbDIW;
       cbDIV: // global
           R2 = R2;
           R1 = GHC.Fingerprint.getFileHash2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbDIW: // global
           I64[Sp - 16] = block_cbDIb_info;
           R1 = 0;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDIb() //  [R1]
         { info_tbl: [(cbDIb,
                       label: block_cbDIb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDIb: // global
           _sbDE7::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint]  result hints:  [] __hsbase_MD5Init(_sbDE7::I64);
           I64[Sp - 16] = block_cbDIi_info;
           _sbDE6::P64 = R1;
           R1 = 4096;
           I64[Sp - 8] = _sbDE7::I64;
           P64[Sp] = _sbDE6::P64;
           Sp = Sp - 16;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDIi() //  [R1]
         { info_tbl: [(cbDIi,
                       label: block_cbDIi_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDIi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDJ0; else goto cbDIZ;
       cbDJ0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDIZ: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           _sbDEh::I64 = R1 + 16;
           I64[Hp] = _sbDEh::I64;
           P64[Sp - 16] = R1;
           I64[Sp - 8] = _sbDEh::I64;
           P64[Sp] = Hp - 7;
           Sp = Sp - 16;
           call _cbDJe() args: 0, res: 0, upd: 0;
     }
 },
 _cbDJe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDJe: // global
           I64[Sp - 8] = block_cbDJg_info;
           R4 = 4096;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 40];
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.$whGetBuf_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDJg() //  [R1]
         { info_tbl: [(cbDJg,
                       label: block_cbDJg_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDJg: // global
           I64[Sp - 8] = block_cbDJi_info;
           R4 = GHC.IO.Handle.hIsEOF2_closure+2;
           R3 = P64[Sp + 48];
           R2 = GHC.IO.Handle.hIsEOF3_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDJi() //  [R1]
         { info_tbl: [(cbDJi,
                       label: block_cbDJi_info
                       rep:StackRep [False, False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDJi: // global
           I64[Sp] = block_cbDJk_info;
           _sbDEP::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbDEP::P64;
           if (R1 & 7 != 0) goto ubDKg; else goto cbDJo;
       ubDKg: // global
           call _cbDJk(R1) args: 0, res: 0, upd: 0;
       cbDJo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDJk() //  [R1]
         { info_tbl: [(cbDJk,
                       label: block_cbDJk_info
                       rep:StackRep [False, False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDJk: // global
           _sbDER::I64 = I64[R1 + 7];
           if (_sbDER::I64 == 4096) goto ubDKc; else goto cbDJW;
       ubDKc: // global
           I64[Sp] = _sbDER::I64;
           call _sbDES() args: 0, res: 0, upd: 0;
       cbDJW: // global
           I64[Sp - 16] = block_cbDJU_info;
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _sbDER::I64;
           I64[Sp] = _sbDER::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubDKh; else goto cbDJX;
       ubDKh: // global
           call _cbDJU(R1) args: 0, res: 0, upd: 0;
       cbDJX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDJU() //  [R1]
         { info_tbl: [(cbDJU,
                       label: block_cbDJU_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDJU: // global
           if (R1 & 7 == 1) goto cbDK3; else goto ubDKd;
       cbDK3: // global
           R2 = I64[Sp + 8];
           Sp = Sp + 80;
           call GHC.Fingerprint.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ubDKd: // global
           Sp = Sp + 16;
           call _sbDES() args: 0, res: 0, upd: 0;
     }
 },
 _sbDES() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbDES: // global
           _sbDEP::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint, PtrHint,
                                     ‘signed’]  result hints:  [] __hsbase_MD5Update(I64[Sp + 40], I64[Sp + 24], %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp])));
           I64[Sp + 8] = block_cbDJG_info;
           R1 = _sbDEP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubDKl; else goto cbDJH;
       ubDKl: // global
           call _cbDJG(R1) args: 0, res: 0, upd: 0;
       cbDJH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDJG() //  [R1]
         { info_tbl: [(cbDJG,
                       label: block_cbDJG_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDJG: // global
           if (R1 & 7 == 1) goto ubDKe; else goto cbDJR;
       ubDKe: // global
           Sp = Sp + 8;
           call _cbDJe() args: 0, res: 0, upd: 0;
       cbDJR: // global
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 24] = block_cbDIu_info;
           R1 = 16;
           Sp = Sp + 24;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDIu() //  [R1]
         { info_tbl: [(cbDIu,
                       label: block_cbDIu_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDIu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDJ4; else goto cbDJ3;
       cbDJ4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDJ3: // global
           _sbDEs::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] __hsbase_MD5Final(_sbDEs::I64, I64[Sp + 8]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sbDEs::I64;
           I64[Sp] = block_cbDID_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           I64[Sp + 8] = _sbDEs::I64;
           P64[Sp + 24] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDID() //  [R1]
         { info_tbl: [(cbDID,
                       label: block_cbDID_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDID: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDJ7; else goto cbDJ6;
       cbDJ7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDJ6: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + 8;
           I64[Sp] = block_cbDIJ_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           P64[Sp + 8] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDIJ() //  [R1]
         { info_tbl: [(cbDIJ,
                       label: block_cbDIJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDIJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbDJa; else goto cbDJ9;
       cbDJa: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDJ9: // global
           _sbDE6::P64 = P64[Sp + 16];
           _sbDEz::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 24]);
           call MO_Touch(_sbDE6::P64);
           I64[Hp - 24] = sat_sbDEH_info;
           P64[Hp - 8] = _sbDEz::P64;
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.268424636 UTC

[section ""data" . GHC.Fingerprint.getFileHash1_closure" {
     GHC.Fingerprint.getFileHash1_closure:
         const GHC.Fingerprint.getFileHash1_info;
         const 0;
 },
 GHC.Fingerprint.getFileHash1_entry() //  [R2]
         { info_tbl: [(cbDKq,
                       label: GHC.Fingerprint.getFileHash1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDKq: // global
           R4 = GHC.Fingerprint.getFileHash2_closure+2;
           R3 = GHC.IO.IOMode.ReadMode_closure+1;
           R2 = R2;
           call System.IO.withBinaryFile1_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.269526762 UTC

[section ""data" . GHC.Fingerprint.getFileHash_closure" {
     GHC.Fingerprint.getFileHash_closure:
         const GHC.Fingerprint.getFileHash_info;
         const 0;
 },
 GHC.Fingerprint.getFileHash_entry() //  [R2]
         { info_tbl: [(cbDKx,
                       label: GHC.Fingerprint.getFileHash_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDKx: // global
           R2 = R2;
           call GHC.Fingerprint.getFileHash1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.271111338 UTC

[section ""data" . GHC.Fingerprint.$wfingerprintData_closure" {
     GHC.Fingerprint.$wfingerprintData_closure:
         const GHC.Fingerprint.$wfingerprintData_info;
 },
 sat_sbDFF_entry() //  [R1]
         { info_tbl: [(cbDLf,
                       label: sat_sbDFF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDLf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbDLg; else goto cbDLh;
       cbDLg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDLh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$WFingerprint_entry(R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.$wfingerprintData_entry() //  [R2, R3]
         { info_tbl: [(cbDLi,
                       label: GHC.Fingerprint.$wfingerprintData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDLi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbDLj; else goto cbDLk;
       cbDLj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.$wfingerprintData_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbDLk: // global
           I64[Sp - 24] = block_cbDKE_info;
           R1 = 0;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDKE() //  [R1]
         { info_tbl: [(cbDKE,
                       label: block_cbDKE_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDKE: // global
           _sbDF3::I64 = I64[Sp + 8];
           _sbDF4::I64 = I64[Sp + 16];
           _sbDFc::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint]  result hints:  [] __hsbase_MD5Init(_sbDFc::I64);
           call "ccall" arg hints:  [PtrHint, PtrHint,
                                     ‘signed’]  result hints:  [] __hsbase_MD5Update(_sbDFc::I64, _sbDF3::I64, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbDF4::I64)));
           I64[Sp] = block_cbDKS_info;
           _sbDFb::P64 = R1;
           R1 = 16;
           I64[Sp + 8] = _sbDFc::I64;
           P64[Sp + 16] = _sbDFb::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDKS() //  [R1]
         { info_tbl: [(cbDKS,
                       label: block_cbDKS_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDKS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDLo; else goto cbDLn;
       cbDLo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDLn: // global
           _sbDFq::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] __hsbase_MD5Final(_sbDFq::I64, I64[Sp + 8]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sbDFq::I64;
           I64[Sp - 8] = block_cbDL1_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           I64[Sp] = _sbDFq::I64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDL1() //  [R1]
         { info_tbl: [(cbDL1,
                       label: block_cbDL1_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDL1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDLr; else goto cbDLq;
       cbDLr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDLq: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + 8;
           I64[Sp] = block_cbDL7_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           P64[Sp + 8] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDL7() //  [R1]
         { info_tbl: [(cbDL7,
                       label: block_cbDL7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDL7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbDLu; else goto cbDLt;
       cbDLu: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDLt: // global
           _sbDFb::P64 = P64[Sp + 24];
           _sbDFx::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 16]);
           call MO_Touch(_sbDFb::P64);
           I64[Hp - 24] = sat_sbDFF_info;
           P64[Hp - 8] = _sbDFx::P64;
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.273563754 UTC

[section ""data" . GHC.Fingerprint.fingerprintData1_closure" {
     GHC.Fingerprint.fingerprintData1_closure:
         const GHC.Fingerprint.fingerprintData1_info;
 },
 GHC.Fingerprint.fingerprintData1_entry() //  [R2, R3]
         { info_tbl: [(cbDLC,
                       label: GHC.Fingerprint.fingerprintData1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDLC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbDLG; else goto cbDLH;
       cbDLG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintData1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbDLH: // global
           I64[Sp - 16] = block_cbDLz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubDLP; else goto cbDLA;
       ubDLP: // global
           call _cbDLz(R1) args: 0, res: 0, upd: 0;
       cbDLA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDLz() //  [R1]
         { info_tbl: [(cbDLz,
                       label: block_cbDLz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDLz: // global
           I64[Sp] = block_cbDLF_info;
           _sbDFK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sbDFK::I64;
           if (R1 & 7 != 0) goto ubDLO; else goto cbDLJ;
       ubDLO: // global
           call _cbDLF(R1) args: 0, res: 0, upd: 0;
       cbDLJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDLF() //  [R1]
         { info_tbl: [(cbDLF,
                       label: block_cbDLF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDLF: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Fingerprint.$wfingerprintData_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.274876302 UTC

[section ""data" . GHC.Fingerprint.fingerprintData_closure" {
     GHC.Fingerprint.fingerprintData_closure:
         const GHC.Fingerprint.fingerprintData_info;
 },
 GHC.Fingerprint.fingerprintData_entry() //  [R2, R3]
         { info_tbl: [(cbDLU,
                       label: GHC.Fingerprint.fingerprintData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDLU: // global
           R3 = R3;
           R2 = R2;
           call GHC.Fingerprint.fingerprintData1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.277373577 UTC

[section ""data" . GHC.Fingerprint.fingerprintString_go_closure" {
     GHC.Fingerprint.fingerprintString_go_closure:
         const GHC.Fingerprint.fingerprintString_go_info;
 },
 w32_sbDFR_entry() //  [R1]
         { info_tbl: [(cbDMe,
                       label: w32_sbDFR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDMe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbDMr; else goto cbDMs;
       cbDMr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDMs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbDMb_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubDMw; else goto cbDMc;
       ubDMw: // global
           call _cbDMb(R1) args: 0, res: 0, upd: 0;
       cbDMc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbDMb() //  [R1]
         { info_tbl: [(cbDMb,
                       label: block_cbDMb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDMb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDMv; else goto cbDMu;
       cbDMv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbDMu: // global
           _sbDFW::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _sbDFW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDGg_entry() //  [R1]
         { info_tbl: [(cbDMB,
                       label: sat_sbDGg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDMB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbDMC; else goto cbDMD;
       cbDMC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDMD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.fingerprintString_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDGf_entry() //  [R1]
         { info_tbl: [(cbDML,
                       label: sat_sbDGf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDML: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbDMS; else goto cbDMT;
       cbDMS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDMT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbDMI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubDMX; else goto cbDMJ;
       ubDMX: // global
           call _cbDMI(R1) args: 0, res: 0, upd: 0;
       cbDMJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbDMI() //  [R1]
         { info_tbl: [(cbDMI,
                       label: block_cbDMI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDMI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDMW; else goto cbDMV;
       cbDMW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbDMV: // global
           _sbDGe::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbDGe::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDGb_entry() //  [R1]
         { info_tbl: [(cbDN6,
                       label: sat_sbDGb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDN6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbDNg; else goto cbDNh;
       cbDNg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDNh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbDN3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubDNl; else goto cbDN4;
       ubDNl: // global
           call _cbDN3(R1) args: 0, res: 0, upd: 0;
       cbDN4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbDN3() //  [R1]
         { info_tbl: [(cbDN3,
                       label: block_cbDN3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDN3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDNk; else goto cbDNj;
       cbDNk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbDNj: // global
           _sbDGa::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7] >> 8));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbDGa::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDG6_entry() //  [R1]
         { info_tbl: [(cbDNu,
                       label: sat_sbDG6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDNu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbDNE; else goto cbDNF;
       cbDNE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDNF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbDNr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubDNJ; else goto cbDNs;
       ubDNJ: // global
           call _cbDNr(R1) args: 0, res: 0, upd: 0;
       cbDNs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbDNr() //  [R1]
         { info_tbl: [(cbDNr,
                       label: block_cbDNr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDNr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDNI; else goto cbDNH;
       cbDNI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbDNH: // global
           _sbDG5::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7] >> 16));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbDG5::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDG1_entry() //  [R1]
         { info_tbl: [(cbDNS,
                       label: sat_sbDG1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDNS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbDO2; else goto cbDO3;
       cbDO2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDO3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbDNP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubDO7; else goto cbDNQ;
       ubDO7: // global
           call _cbDNP(R1) args: 0, res: 0, upd: 0;
       cbDNQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbDNP() //  [R1]
         { info_tbl: [(cbDNP,
                       label: block_cbDNP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDNP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDO6; else goto cbDO5;
       cbDO6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbDO5: // global
           _sbDG0::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7] >> 24));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbDG0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.fingerprintString_go_entry() //  [R2]
         { info_tbl: [(cbDOc,
                       label: GHC.Fingerprint.fingerprintString_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDOc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbDOd; else goto cbDOe;
       cbDOd: // global
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintString_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbDOe: // global
           I64[Sp - 8] = block_cbDM1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubDOl; else goto cbDM2;
       ubDOl: // global
           call _cbDM1(R1) args: 0, res: 0, upd: 0;
       cbDM2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDM1() //  [R1]
         { info_tbl: [(cbDM1,
                       label: block_cbDM1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDM1: // global
           if (R1 & 7 == 1) goto cbDO9; else goto cbDOa;
       cbDO9: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbDOa: // global
           Hp = Hp + 240;
           if (Hp > HpLim) (likely: False) goto cbDOk; else goto cbDOj;
       cbDOk: // global
           HpAlloc = 240;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDOj: // global
           _sbDFP::P64 = P64[R1 + 6];
           _sbDFQ::P64 = P64[R1 + 14];
           I64[Hp - 232] = w32_sbDFR_info;
           P64[Hp - 216] = _sbDFP::P64;
           I64[Hp - 208] = sat_sbDGg_info;
           P64[Hp - 192] = _sbDFQ::P64;
           I64[Hp - 184] = sat_sbDGf_info;
           _cbDM7::P64 = Hp - 232;
           P64[Hp - 168] = _cbDM7::P64;
           I64[Hp - 160] = :_con_info;
           P64[Hp - 152] = Hp - 184;
           P64[Hp - 144] = Hp - 208;
           I64[Hp - 136] = sat_sbDGb_info;
           P64[Hp - 120] = _cbDM7::P64;
           I64[Hp - 112] = :_con_info;
           P64[Hp - 104] = Hp - 136;
           P64[Hp - 96] = Hp - 158;
           I64[Hp - 88] = sat_sbDG6_info;
           P64[Hp - 72] = _cbDM7::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 110;
           I64[Hp - 40] = sat_sbDG1_info;
           P64[Hp - 24] = _cbDM7::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.282414911 UTC

[section ""data" . GHC.Fingerprint.fingerprintString_closure" {
     GHC.Fingerprint.fingerprintString_closure:
         const GHC.Fingerprint.fingerprintString_info;
 },
 GHC.Fingerprint.fingerprintString_entry() //  [R2]
         { info_tbl: [(cbDOs,
                       label: GHC.Fingerprint.fingerprintString_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDOs: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbDOt; else goto cbDOu;
       cbDOt: // global
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbDOu: // global
           I64[Sp - 8] = block_cbDOq_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Fingerprint.fingerprintString_go_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDOq() //  [R1]
         { info_tbl: [(cbDOq,
                       label: block_cbDOq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDOq: // global
           I64[Sp - 8] = block_cbDOx_info;
           R3 = 0;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDOx() //  [R1]
         { info_tbl: [(cbDOx,
                       label: block_cbDOx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDOx: // global
           I64[Sp - 8] = block_cbDOC_info;
           R2 = 1;
           _sbDGm::I64 = R1;
           R1 = R1;
           I64[Sp] = _sbDGm::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDOC() //  [R1]
         { info_tbl: [(cbDOC,
                       label: block_cbDOC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDOC: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _cbDOU() args: 0, res: 0, upd: 0;
     }
 },
 _cbDOU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDOU: // global
           _sbDGB::P64 = P64[Sp];
           I64[Sp] = block_cbDOX_info;
           R1 = _sbDGB::P64;
           if (R1 & 7 != 0) goto ubDPq; else goto cbDOZ;
       ubDPq: // global
           call _cbDOX(R1) args: 0, res: 0, upd: 0;
       cbDOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDOX() //  [R1]
         { info_tbl: [(cbDOX,
                       label: block_cbDOX_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDOX: // global
           if (R1 & 7 == 1) goto cbDP5; else goto cbDPa;
       cbDP5: // global
           _sbDGm::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_cbDOO_info;
           R3 = _sbDGm::I64;
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Fingerprint.$wfingerprintData_entry(R3,
                                                        R2) args: 8, res: 8, upd: 8;
       cbDPa: // global
           I64[Sp - 8] = block_cbDP8_info;
           _sbDGG::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbDGG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubDPr; else goto cbDPb;
       ubDPr: // global
           call _cbDP8(R1) args: 0, res: 0, upd: 0;
       cbDPb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDOO() //  [R1]
         { info_tbl: [(cbDOO,
                       label: block_cbDOO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDOO: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbDP8() //  [R1]
         { info_tbl: [(cbDP8,
                       label: block_cbDP8_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDP8: // global
           _sbDGC::I64 = I64[Sp + 16];
           _sbDGG::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _sbDGC::I64] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _sbDGG::P64;
           I64[Sp + 16] = _sbDGC::I64 + 1;
           Sp = Sp + 8;
           call _cbDOU() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.285529447 UTC

[section ""data" . GHC.Fingerprint.fingerprintFingerprints_closure" {
     GHC.Fingerprint.fingerprintFingerprints_closure:
         const GHC.Fingerprint.fingerprintFingerprints_info;
 },
 GHC.Fingerprint.fingerprintFingerprints_entry() //  [R2]
         { info_tbl: [(cbDPC,
                       label: GHC.Fingerprint.fingerprintFingerprints_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDPC: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbDPD; else goto cbDPE;
       cbDPD: // global
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintFingerprints_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbDPE: // global
           I64[Sp - 16] = block_cbDPx_info;
           R3 = 0;
           _sbDGO::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbDGO::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDPx() //  [R1]
         { info_tbl: [(cbDPx,
                       label: block_cbDPx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDPx: // global
           I64[Sp - 8] = block_cbDPL_info;
           R2 = 8;
           _sbDGP::I64 = R1;
           R1 = R1 << 4;
           I64[Sp] = _sbDGP::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDPL() //  [R1]
         { info_tbl: [(cbDPL,
                       label: block_cbDPL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDPL: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _cbDQ5() args: 0, res: 0, upd: 0;
     }
 },
 _cbDQ5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDQ5: // global
           _sbDH6::P64 = P64[Sp];
           I64[Sp] = block_cbDQ8_info;
           R1 = _sbDH6::P64;
           if (R1 & 7 != 0) goto ubDQV; else goto cbDQa;
       ubDQV: // global
           call _cbDQ8(R1) args: 0, res: 0, upd: 0;
       cbDQa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDQ8() //  [R1]
         { info_tbl: [(cbDQ8,
                       label: block_cbDQ8_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDQ8: // global
           if (R1 & 7 == 1) goto cbDQg; else goto cbDQl;
       cbDQg: // global
           _sbDH0::I64 = I64[Sp + 24] << 4;
           I64[Sp + 24] = block_cbDQ0_info;
           R3 = _sbDH0::I64;
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Fingerprint.$wfingerprintData_entry(R3,
                                                        R2) args: 8, res: 8, upd: 8;
       cbDQl: // global
           I64[Sp - 8] = block_cbDQj_info;
           _sbDHb::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbDHb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubDQW; else goto cbDQm;
       ubDQW: // global
           call _cbDQj(R1) args: 0, res: 0, upd: 0;
       cbDQm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDQ0() //  [R1]
         { info_tbl: [(cbDQ0,
                       label: block_cbDQ0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDQ0: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbDQj() //  [R1]
         { info_tbl: [(cbDQj,
                       label: block_cbDQj_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDQj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbDQs; else goto cbDQr;
       cbDQs: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDQr: // global
           _sbDHd::I64 = I64[R1 + 7];
           _sbDHe::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Word.W64#_con_info;
           I64[Hp - 16] = _sbDHd::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           _sbDHf::I64 = I64[Sp + 24] + (I64[Sp + 16] << 4);
           I64[Hp] = _sbDHf::I64;
           I64[Sp - 16] = block_cbDQB_info;
           R4 = Hp - 23;
           R3 = 8;
           R2 = Hp - 7;
           I64[Sp - 8] = _sbDHf::I64;
           I64[Sp] = _sbDHe::I64;
           Sp = Sp - 16;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDQB() //  [R1]
         { info_tbl: [(cbDQB,
                       label: block_cbDQB_info
                       rep:StackRep [True, True, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDQB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbDQF; else goto cbDQE;
       cbDQF: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDQE: // global
           I64[Hp - 24] = GHC.Word.W64#_con_info;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + 8;
           I64[Sp + 16] = block_cbDQL_info;
           R4 = Hp - 23;
           R3 = 8;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDQL() //  []
         { info_tbl: [(cbDQL,
                       label: block_cbDQL_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDQL: // global
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16] + 1;
           Sp = Sp + 8;
           call _cbDQ5() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.28801803 UTC

[section ""relreadonly" . SbDI6_srt" {
     SbDI6_srt:
         const lvl2_rbDDQ_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Fingerprint.$wlvl_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Text.$whGetBuf_closure;
         const GHC.IO.Handle.hIsEOF3_closure;
         const GHC.Fingerprint.getFileHash2_closure;
         const System.IO.withBinaryFile1_closure;
         const GHC.Fingerprint.getFileHash1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.288660792 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:33.289228225 UTC

[section ""cstring" . GHC.Fingerprint.$trModule4_bytes" {
     GHC.Fingerprint.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.2898992 UTC

[section ""data" . GHC.Fingerprint.$trModule3_closure" {
     GHC.Fingerprint.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.290510062 UTC

[section ""cstring" . GHC.Fingerprint.$trModule2_bytes" {
     GHC.Fingerprint.$trModule2_bytes:
         I8[] [71,72,67,46,70,105,110,103,101,114,112,114,105,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.291102805 UTC

[section ""data" . GHC.Fingerprint.$trModule1_closure" {
     GHC.Fingerprint.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.291770715 UTC

[section ""data" . GHC.Fingerprint.$trModule_closure" {
     GHC.Fingerprint.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Fingerprint.$trModule3_closure+1;
         const GHC.Fingerprint.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.292421507 UTC

[section ""cstring" . GHC.Fingerprint.$tcMD5Context2_bytes" {
     GHC.Fingerprint.$tcMD5Context2_bytes:
         I8[] [77,68,53,67,111,110,116,101,120,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.293095362 UTC

[section ""data" . GHC.Fingerprint.$tcMD5Context1_closure" {
     GHC.Fingerprint.$tcMD5Context1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.$tcMD5Context2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.293826863 UTC

[section ""data" . GHC.Fingerprint.$tcMD5Context_closure" {
     GHC.Fingerprint.$tcMD5Context_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Fingerprint.$trModule_closure+1;
         const GHC.Fingerprint.$tcMD5Context1_closure+1;
         const GHC.Types.krep$*_closure;
         const 2786815183060026909;
         const 11852912954819316049;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.294430407 UTC

[section ""data" . GHC.Fingerprint.fingerprint0_closure" {
     GHC.Fingerprint.fingerprint0_closure:
         const GHC.Fingerprint.Type.Fingerprint_con_info;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.295025074 UTC

[section ""cstring" . lvl_rbDDO_bytes" {
     lvl_rbDDO_bytes:
         I8[] [71,72,67,46,70,105,110,103,101,114,112,114,105,110,116,46,103,101,116,70,105,108,101,72,97,115,104,58,32,111,110,108,121,32,114,101,97,100,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.295596075 UTC

[section ""cstring" . lvl1_rbDDP_bytes" {
     lvl1_rbDDP_bytes:
         I8[] [32,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.296393477 UTC

[section ""data" . lvl2_rbDDQ_closure" {
     lvl2_rbDDQ_closure:
         const lvl2_rbDDQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rbDDQ_entry() //  [R1]
         { info_tbl: [(cbDR4,
                       label: lvl2_rbDDQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDR4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbDR5; else goto cbDR6;
       cbDR5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDR6: // global
           (_cbDR1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbDR1::I64 == 0) goto cbDR3; else goto cbDR2;
       cbDR3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbDR2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbDR1::I64;
           R2 = lvl1_rbDDP_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.297850808 UTC

[section ""data" . GHC.Fingerprint.$wlvl_closure" {
     GHC.Fingerprint.$wlvl_closure:
         const GHC.Fingerprint.$wlvl_info;
         const 0;
 },
 sat_sbDDX_entry() //  [R1]
         { info_tbl: [(cbDRi,
                       label: sat_sbDDX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDRi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbDRj; else goto cbDRk;
       cbDRj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDRk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbDRf_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbDRf() //  [R1, R2]
         { info_tbl: [(cbDRf,
                       label: block_cbDRf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDRf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbDRn; else goto cbDRm;
       cbDRn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbDRm: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl2_rbDDQ_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.$wlvl_entry() //  [R2]
         { info_tbl: [(cbDRq,
                       label: GHC.Fingerprint.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDRq: // global
           _sbDDS::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbDRr; else goto cbDRs;
       cbDRs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbDRu; else goto cbDRt;
       cbDRu: // global
           HpAlloc = 24;
           goto cbDRr;
       cbDRr: // global
           R2 = _sbDDS::I64;
           R1 = GHC.Fingerprint.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbDRt: // global
           I64[Hp - 16] = sat_sbDDX_info;
           I64[Hp] = _sbDDS::I64;
           I64[Sp - 8] = block_cbDRo_info;
           R3 = Hp - 16;
           R2 = lvl_rbDDO_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDRo() //  [R1]
         { info_tbl: [(cbDRo,
                       label: block_cbDRo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDRo: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.301269543 UTC

[section ""data" . GHC.Fingerprint.getFileHash2_closure" {
     GHC.Fingerprint.getFileHash2_closure:
         const GHC.Fingerprint.getFileHash2_info;
         const 0;
 },
 sat_sbDEH_entry() //  [R1]
         { info_tbl: [(cbDSi,
                       label: sat_sbDEH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDSi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbDSj; else goto cbDSk;
       cbDSj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDSk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$WFingerprint_entry(R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.getFileHash2_entry() //  [R2]
         { info_tbl: [(cbDSl,
                       label: GHC.Fingerprint.getFileHash2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDSl: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cbDSm; else goto cbDSn;
       cbDSm: // global
           R2 = R2;
           R1 = GHC.Fingerprint.getFileHash2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbDSn: // global
           I64[Sp - 16] = block_cbDRC_info;
           R1 = 0;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDRC() //  [R1]
         { info_tbl: [(cbDRC,
                       label: block_cbDRC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDRC: // global
           _sbDE7::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint]  result hints:  [] __hsbase_MD5Init(_sbDE7::I64);
           I64[Sp - 16] = block_cbDRJ_info;
           _sbDE6::P64 = R1;
           R1 = 4096;
           I64[Sp - 8] = _sbDE7::I64;
           P64[Sp] = _sbDE6::P64;
           Sp = Sp - 16;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDRJ() //  [R1]
         { info_tbl: [(cbDRJ,
                       label: block_cbDRJ_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDRJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDSr; else goto cbDSq;
       cbDSr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDSq: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           _sbDEh::I64 = R1 + 16;
           I64[Hp] = _sbDEh::I64;
           P64[Sp - 16] = R1;
           I64[Sp - 8] = _sbDEh::I64;
           P64[Sp] = Hp - 7;
           Sp = Sp - 16;
           call _cbDSF() args: 0, res: 0, upd: 0;
     }
 },
 _cbDSF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDSF: // global
           I64[Sp - 8] = block_cbDSH_info;
           R4 = 4096;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 40];
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.$whGetBuf_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDSH() //  [R1]
         { info_tbl: [(cbDSH,
                       label: block_cbDSH_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDSH: // global
           I64[Sp - 8] = block_cbDSJ_info;
           R4 = GHC.IO.Handle.hIsEOF2_closure+2;
           R3 = P64[Sp + 48];
           R2 = GHC.IO.Handle.hIsEOF3_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDSJ() //  [R1]
         { info_tbl: [(cbDSJ,
                       label: block_cbDSJ_info
                       rep:StackRep [False, False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDSJ: // global
           I64[Sp] = block_cbDSL_info;
           _sbDEP::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbDEP::P64;
           if (R1 & 7 != 0) goto ubDTH; else goto cbDSP;
       ubDTH: // global
           call _cbDSL(R1) args: 0, res: 0, upd: 0;
       cbDSP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDSL() //  [R1]
         { info_tbl: [(cbDSL,
                       label: block_cbDSL_info
                       rep:StackRep [False, False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDSL: // global
           _sbDER::I64 = I64[R1 + 7];
           if (_sbDER::I64 == 4096) goto ubDTD; else goto cbDTn;
       ubDTD: // global
           I64[Sp] = _sbDER::I64;
           call _sbDES() args: 0, res: 0, upd: 0;
       cbDTn: // global
           I64[Sp - 16] = block_cbDTl_info;
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _sbDER::I64;
           I64[Sp] = _sbDER::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubDTI; else goto cbDTo;
       ubDTI: // global
           call _cbDTl(R1) args: 0, res: 0, upd: 0;
       cbDTo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDTl() //  [R1]
         { info_tbl: [(cbDTl,
                       label: block_cbDTl_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDTl: // global
           if (R1 & 7 == 1) goto cbDTu; else goto ubDTE;
       cbDTu: // global
           R2 = I64[Sp + 8];
           Sp = Sp + 80;
           call GHC.Fingerprint.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ubDTE: // global
           Sp = Sp + 16;
           call _sbDES() args: 0, res: 0, upd: 0;
     }
 },
 _sbDES() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbDES: // global
           _sbDEP::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint, PtrHint,
                                     ‘signed’]  result hints:  [] __hsbase_MD5Update(I64[Sp + 40], I64[Sp + 24], %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp])));
           I64[Sp + 8] = block_cbDT7_info;
           R1 = _sbDEP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubDTM; else goto cbDT8;
       ubDTM: // global
           call _cbDT7(R1) args: 0, res: 0, upd: 0;
       cbDT8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDT7() //  [R1]
         { info_tbl: [(cbDT7,
                       label: block_cbDT7_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDT7: // global
           if (R1 & 7 == 1) goto ubDTF; else goto cbDTi;
       ubDTF: // global
           Sp = Sp + 8;
           call _cbDSF() args: 0, res: 0, upd: 0;
       cbDTi: // global
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 24] = block_cbDRV_info;
           R1 = 16;
           Sp = Sp + 24;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDRV() //  [R1]
         { info_tbl: [(cbDRV,
                       label: block_cbDRV_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDRV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDSv; else goto cbDSu;
       cbDSv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDSu: // global
           _sbDEs::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] __hsbase_MD5Final(_sbDEs::I64, I64[Sp + 8]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sbDEs::I64;
           I64[Sp] = block_cbDS4_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           I64[Sp + 8] = _sbDEs::I64;
           P64[Sp + 24] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDS4() //  [R1]
         { info_tbl: [(cbDS4,
                       label: block_cbDS4_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDS4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDSy; else goto cbDSx;
       cbDSy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDSx: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + 8;
           I64[Sp] = block_cbDSa_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           P64[Sp + 8] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDSa() //  [R1]
         { info_tbl: [(cbDSa,
                       label: block_cbDSa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDSa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbDSB; else goto cbDSA;
       cbDSB: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDSA: // global
           _sbDE6::P64 = P64[Sp + 16];
           _sbDEz::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 24]);
           call MO_Touch(_sbDE6::P64);
           I64[Hp - 24] = sat_sbDEH_info;
           P64[Hp - 8] = _sbDEz::P64;
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.305628499 UTC

[section ""data" . GHC.Fingerprint.getFileHash1_closure" {
     GHC.Fingerprint.getFileHash1_closure:
         const GHC.Fingerprint.getFileHash1_info;
         const 0;
 },
 GHC.Fingerprint.getFileHash1_entry() //  [R2]
         { info_tbl: [(cbDTR,
                       label: GHC.Fingerprint.getFileHash1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDTR: // global
           R4 = GHC.Fingerprint.getFileHash2_closure+2;
           R3 = GHC.IO.IOMode.ReadMode_closure+1;
           R2 = R2;
           call System.IO.withBinaryFile1_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.308224166 UTC

[section ""data" . GHC.Fingerprint.getFileHash_closure" {
     GHC.Fingerprint.getFileHash_closure:
         const GHC.Fingerprint.getFileHash_info;
         const 0;
 },
 GHC.Fingerprint.getFileHash_entry() //  [R2]
         { info_tbl: [(cbDTY,
                       label: GHC.Fingerprint.getFileHash_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDTY: // global
           R2 = R2;
           call GHC.Fingerprint.getFileHash1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.309774875 UTC

[section ""data" . GHC.Fingerprint.$wfingerprintData_closure" {
     GHC.Fingerprint.$wfingerprintData_closure:
         const GHC.Fingerprint.$wfingerprintData_info;
 },
 sat_sbDFF_entry() //  [R1]
         { info_tbl: [(cbDUG,
                       label: sat_sbDFF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDUG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbDUH; else goto cbDUI;
       cbDUH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDUI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$WFingerprint_entry(R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.$wfingerprintData_entry() //  [R2, R3]
         { info_tbl: [(cbDUJ,
                       label: GHC.Fingerprint.$wfingerprintData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDUJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbDUK; else goto cbDUL;
       cbDUK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.$wfingerprintData_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbDUL: // global
           I64[Sp - 24] = block_cbDU5_info;
           R1 = 0;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDU5() //  [R1]
         { info_tbl: [(cbDU5,
                       label: block_cbDU5_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDU5: // global
           _sbDF3::I64 = I64[Sp + 8];
           _sbDF4::I64 = I64[Sp + 16];
           _sbDFc::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint]  result hints:  [] __hsbase_MD5Init(_sbDFc::I64);
           call "ccall" arg hints:  [PtrHint, PtrHint,
                                     ‘signed’]  result hints:  [] __hsbase_MD5Update(_sbDFc::I64, _sbDF3::I64, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbDF4::I64)));
           I64[Sp] = block_cbDUj_info;
           _sbDFb::P64 = R1;
           R1 = 16;
           I64[Sp + 8] = _sbDFc::I64;
           P64[Sp + 16] = _sbDFb::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDUj() //  [R1]
         { info_tbl: [(cbDUj,
                       label: block_cbDUj_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDUj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDUP; else goto cbDUO;
       cbDUP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDUO: // global
           _sbDFq::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] __hsbase_MD5Final(_sbDFq::I64, I64[Sp + 8]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sbDFq::I64;
           I64[Sp - 8] = block_cbDUs_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           I64[Sp] = _sbDFq::I64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDUs() //  [R1]
         { info_tbl: [(cbDUs,
                       label: block_cbDUs_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDUs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDUS; else goto cbDUR;
       cbDUS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDUR: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + 8;
           I64[Sp] = block_cbDUy_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           P64[Sp + 8] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDUy() //  [R1]
         { info_tbl: [(cbDUy,
                       label: block_cbDUy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDUy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbDUV; else goto cbDUU;
       cbDUV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDUU: // global
           _sbDFb::P64 = P64[Sp + 24];
           _sbDFx::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 16]);
           call MO_Touch(_sbDFb::P64);
           I64[Hp - 24] = sat_sbDFF_info;
           P64[Hp - 8] = _sbDFx::P64;
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.312157659 UTC

[section ""data" . GHC.Fingerprint.fingerprintData1_closure" {
     GHC.Fingerprint.fingerprintData1_closure:
         const GHC.Fingerprint.fingerprintData1_info;
 },
 GHC.Fingerprint.fingerprintData1_entry() //  [R2, R3]
         { info_tbl: [(cbDV3,
                       label: GHC.Fingerprint.fingerprintData1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDV3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbDV7; else goto cbDV8;
       cbDV7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintData1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbDV8: // global
           I64[Sp - 16] = block_cbDV0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubDVg; else goto cbDV1;
       ubDVg: // global
           call _cbDV0(R1) args: 0, res: 0, upd: 0;
       cbDV1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDV0() //  [R1]
         { info_tbl: [(cbDV0,
                       label: block_cbDV0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDV0: // global
           I64[Sp] = block_cbDV6_info;
           _sbDFK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sbDFK::I64;
           if (R1 & 7 != 0) goto ubDVf; else goto cbDVa;
       ubDVf: // global
           call _cbDV6(R1) args: 0, res: 0, upd: 0;
       cbDVa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDV6() //  [R1]
         { info_tbl: [(cbDV6,
                       label: block_cbDV6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDV6: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Fingerprint.$wfingerprintData_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.313464111 UTC

[section ""data" . GHC.Fingerprint.fingerprintData_closure" {
     GHC.Fingerprint.fingerprintData_closure:
         const GHC.Fingerprint.fingerprintData_info;
 },
 GHC.Fingerprint.fingerprintData_entry() //  [R2, R3]
         { info_tbl: [(cbDVl,
                       label: GHC.Fingerprint.fingerprintData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDVl: // global
           R3 = R3;
           R2 = R2;
           call GHC.Fingerprint.fingerprintData1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.315883259 UTC

[section ""data" . GHC.Fingerprint.fingerprintString_go_closure" {
     GHC.Fingerprint.fingerprintString_go_closure:
         const GHC.Fingerprint.fingerprintString_go_info;
 },
 w32_sbDFR_entry() //  [R1]
         { info_tbl: [(cbDVF,
                       label: w32_sbDFR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDVF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbDVS; else goto cbDVT;
       cbDVS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDVT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbDVC_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubDVX; else goto cbDVD;
       ubDVX: // global
           call _cbDVC(R1) args: 0, res: 0, upd: 0;
       cbDVD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbDVC() //  [R1]
         { info_tbl: [(cbDVC,
                       label: block_cbDVC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDVC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDVW; else goto cbDVV;
       cbDVW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbDVV: // global
           _sbDFW::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _sbDFW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDGg_entry() //  [R1]
         { info_tbl: [(cbDW2,
                       label: sat_sbDGg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDW2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbDW3; else goto cbDW4;
       cbDW3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDW4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.fingerprintString_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDGf_entry() //  [R1]
         { info_tbl: [(cbDWc,
                       label: sat_sbDGf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDWc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbDWj; else goto cbDWk;
       cbDWj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDWk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbDW9_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubDWo; else goto cbDWa;
       ubDWo: // global
           call _cbDW9(R1) args: 0, res: 0, upd: 0;
       cbDWa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbDW9() //  [R1]
         { info_tbl: [(cbDW9,
                       label: block_cbDW9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDW9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDWn; else goto cbDWm;
       cbDWn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbDWm: // global
           _sbDGe::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbDGe::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDGb_entry() //  [R1]
         { info_tbl: [(cbDWx,
                       label: sat_sbDGb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDWx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbDWH; else goto cbDWI;
       cbDWH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDWI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbDWu_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubDWM; else goto cbDWv;
       ubDWM: // global
           call _cbDWu(R1) args: 0, res: 0, upd: 0;
       cbDWv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbDWu() //  [R1]
         { info_tbl: [(cbDWu,
                       label: block_cbDWu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDWu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDWL; else goto cbDWK;
       cbDWL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbDWK: // global
           _sbDGa::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7] >> 8));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbDGa::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDG6_entry() //  [R1]
         { info_tbl: [(cbDWV,
                       label: sat_sbDG6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDWV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbDX5; else goto cbDX6;
       cbDX5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDX6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbDWS_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubDXa; else goto cbDWT;
       ubDXa: // global
           call _cbDWS(R1) args: 0, res: 0, upd: 0;
       cbDWT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbDWS() //  [R1]
         { info_tbl: [(cbDWS,
                       label: block_cbDWS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDWS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDX9; else goto cbDX8;
       cbDX9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbDX8: // global
           _sbDG5::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7] >> 16));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbDG5::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDG1_entry() //  [R1]
         { info_tbl: [(cbDXj,
                       label: sat_sbDG1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDXj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbDXt; else goto cbDXu;
       cbDXt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbDXu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbDXg_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubDXy; else goto cbDXh;
       ubDXy: // global
           call _cbDXg(R1) args: 0, res: 0, upd: 0;
       cbDXh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbDXg() //  [R1]
         { info_tbl: [(cbDXg,
                       label: block_cbDXg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDXg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbDXx; else goto cbDXw;
       cbDXx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbDXw: // global
           _sbDG0::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7] >> 24));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbDG0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.fingerprintString_go_entry() //  [R2]
         { info_tbl: [(cbDXD,
                       label: GHC.Fingerprint.fingerprintString_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDXD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbDXE; else goto cbDXF;
       cbDXE: // global
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintString_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbDXF: // global
           I64[Sp - 8] = block_cbDVs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubDXM; else goto cbDVt;
       ubDXM: // global
           call _cbDVs(R1) args: 0, res: 0, upd: 0;
       cbDVt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDVs() //  [R1]
         { info_tbl: [(cbDVs,
                       label: block_cbDVs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDVs: // global
           if (R1 & 7 == 1) goto cbDXA; else goto cbDXB;
       cbDXA: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbDXB: // global
           Hp = Hp + 240;
           if (Hp > HpLim) (likely: False) goto cbDXL; else goto cbDXK;
       cbDXL: // global
           HpAlloc = 240;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDXK: // global
           _sbDFP::P64 = P64[R1 + 6];
           _sbDFQ::P64 = P64[R1 + 14];
           I64[Hp - 232] = w32_sbDFR_info;
           P64[Hp - 216] = _sbDFP::P64;
           I64[Hp - 208] = sat_sbDGg_info;
           P64[Hp - 192] = _sbDFQ::P64;
           I64[Hp - 184] = sat_sbDGf_info;
           _cbDVy::P64 = Hp - 232;
           P64[Hp - 168] = _cbDVy::P64;
           I64[Hp - 160] = :_con_info;
           P64[Hp - 152] = Hp - 184;
           P64[Hp - 144] = Hp - 208;
           I64[Hp - 136] = sat_sbDGb_info;
           P64[Hp - 120] = _cbDVy::P64;
           I64[Hp - 112] = :_con_info;
           P64[Hp - 104] = Hp - 136;
           P64[Hp - 96] = Hp - 158;
           I64[Hp - 88] = sat_sbDG6_info;
           P64[Hp - 72] = _cbDVy::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 110;
           I64[Hp - 40] = sat_sbDG1_info;
           P64[Hp - 24] = _cbDVy::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.320913267 UTC

[section ""data" . GHC.Fingerprint.fingerprintString_closure" {
     GHC.Fingerprint.fingerprintString_closure:
         const GHC.Fingerprint.fingerprintString_info;
 },
 GHC.Fingerprint.fingerprintString_entry() //  [R2]
         { info_tbl: [(cbDXT,
                       label: GHC.Fingerprint.fingerprintString_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDXT: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbDXU; else goto cbDXV;
       cbDXU: // global
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbDXV: // global
           I64[Sp - 8] = block_cbDXR_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Fingerprint.fingerprintString_go_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDXR() //  [R1]
         { info_tbl: [(cbDXR,
                       label: block_cbDXR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDXR: // global
           I64[Sp - 8] = block_cbDXY_info;
           R3 = 0;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDXY() //  [R1]
         { info_tbl: [(cbDXY,
                       label: block_cbDXY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDXY: // global
           I64[Sp - 8] = block_cbDY3_info;
           R2 = 1;
           _sbDGm::I64 = R1;
           R1 = R1;
           I64[Sp] = _sbDGm::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDY3() //  [R1]
         { info_tbl: [(cbDY3,
                       label: block_cbDY3_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDY3: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _cbDYl() args: 0, res: 0, upd: 0;
     }
 },
 _cbDYl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDYl: // global
           _sbDGB::P64 = P64[Sp];
           I64[Sp] = block_cbDYo_info;
           R1 = _sbDGB::P64;
           if (R1 & 7 != 0) goto ubDYR; else goto cbDYq;
       ubDYR: // global
           call _cbDYo(R1) args: 0, res: 0, upd: 0;
       cbDYq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDYo() //  [R1]
         { info_tbl: [(cbDYo,
                       label: block_cbDYo_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDYo: // global
           if (R1 & 7 == 1) goto cbDYw; else goto cbDYB;
       cbDYw: // global
           _sbDGm::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_cbDYf_info;
           R3 = _sbDGm::I64;
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Fingerprint.$wfingerprintData_entry(R3,
                                                        R2) args: 8, res: 8, upd: 8;
       cbDYB: // global
           I64[Sp - 8] = block_cbDYz_info;
           _sbDGG::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbDGG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubDYS; else goto cbDYC;
       ubDYS: // global
           call _cbDYz(R1) args: 0, res: 0, upd: 0;
       cbDYC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDYf() //  [R1]
         { info_tbl: [(cbDYf,
                       label: block_cbDYf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDYf: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbDYz() //  [R1]
         { info_tbl: [(cbDYz,
                       label: block_cbDYz_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDYz: // global
           _sbDGC::I64 = I64[Sp + 16];
           _sbDGG::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _sbDGC::I64] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _sbDGG::P64;
           I64[Sp + 16] = _sbDGC::I64 + 1;
           Sp = Sp + 8;
           call _cbDYl() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.323972941 UTC

[section ""data" . GHC.Fingerprint.fingerprintFingerprints_closure" {
     GHC.Fingerprint.fingerprintFingerprints_closure:
         const GHC.Fingerprint.fingerprintFingerprints_info;
 },
 GHC.Fingerprint.fingerprintFingerprints_entry() //  [R2]
         { info_tbl: [(cbDZ3,
                       label: GHC.Fingerprint.fingerprintFingerprints_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDZ3: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbDZ4; else goto cbDZ5;
       cbDZ4: // global
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintFingerprints_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbDZ5: // global
           I64[Sp - 16] = block_cbDYY_info;
           R3 = 0;
           _sbDGO::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbDGO::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbDYY() //  [R1]
         { info_tbl: [(cbDYY,
                       label: block_cbDYY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDYY: // global
           I64[Sp - 8] = block_cbDZc_info;
           R2 = 8;
           _sbDGP::I64 = R1;
           R1 = R1 << 4;
           I64[Sp] = _sbDGP::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDZc() //  [R1]
         { info_tbl: [(cbDZc,
                       label: block_cbDZc_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDZc: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _cbDZw() args: 0, res: 0, upd: 0;
     }
 },
 _cbDZw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDZw: // global
           _sbDH6::P64 = P64[Sp];
           I64[Sp] = block_cbDZz_info;
           R1 = _sbDH6::P64;
           if (R1 & 7 != 0) goto ubE0m; else goto cbDZB;
       ubE0m: // global
           call _cbDZz(R1) args: 0, res: 0, upd: 0;
       cbDZB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDZz() //  [R1]
         { info_tbl: [(cbDZz,
                       label: block_cbDZz_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDZz: // global
           if (R1 & 7 == 1) goto cbDZH; else goto cbDZM;
       cbDZH: // global
           _sbDH0::I64 = I64[Sp + 24] << 4;
           I64[Sp + 24] = block_cbDZr_info;
           R3 = _sbDH0::I64;
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Fingerprint.$wfingerprintData_entry(R3,
                                                        R2) args: 8, res: 8, upd: 8;
       cbDZM: // global
           I64[Sp - 8] = block_cbDZK_info;
           _sbDHb::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbDHb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubE0n; else goto cbDZN;
       ubE0n: // global
           call _cbDZK(R1) args: 0, res: 0, upd: 0;
       cbDZN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbDZr() //  [R1]
         { info_tbl: [(cbDZr,
                       label: block_cbDZr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDZr: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbDZK() //  [R1]
         { info_tbl: [(cbDZK,
                       label: block_cbDZK_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbDZK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbDZT; else goto cbDZS;
       cbDZT: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbDZS: // global
           _sbDHd::I64 = I64[R1 + 7];
           _sbDHe::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Word.W64#_con_info;
           I64[Hp - 16] = _sbDHd::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           _sbDHf::I64 = I64[Sp + 24] + (I64[Sp + 16] << 4);
           I64[Hp] = _sbDHf::I64;
           I64[Sp - 16] = block_cbE02_info;
           R4 = Hp - 23;
           R3 = 8;
           R2 = Hp - 7;
           I64[Sp - 8] = _sbDHf::I64;
           I64[Sp] = _sbDHe::I64;
           Sp = Sp - 16;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbE02() //  [R1]
         { info_tbl: [(cbE02,
                       label: block_cbE02_info
                       rep:StackRep [True, True, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE02: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbE06; else goto cbE05;
       cbE06: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbE05: // global
           I64[Hp - 24] = GHC.Word.W64#_con_info;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + 8;
           I64[Sp + 16] = block_cbE0c_info;
           R4 = Hp - 23;
           R3 = 8;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbE0c() //  []
         { info_tbl: [(cbE0c,
                       label: block_cbE0c_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE0c: // global
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16] + 1;
           Sp = Sp + 8;
           call _cbDZw() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.326511373 UTC

[section ""relreadonly" . SbDI6_srt" {
     SbDI6_srt:
         const lvl2_rbDDQ_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Fingerprint.$wlvl_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Text.$whGetBuf_closure;
         const GHC.IO.Handle.hIsEOF3_closure;
         const GHC.Fingerprint.getFileHash2_closure;
         const System.IO.withBinaryFile1_closure;
         const GHC.Fingerprint.getFileHash1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.32733869 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:33.328398743 UTC

[section ""cstring" . GHC.Fingerprint.$trModule4_bytes" {
     GHC.Fingerprint.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.330183326 UTC

[section ""data" . GHC.Fingerprint.$trModule3_closure" {
     GHC.Fingerprint.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.331792636 UTC

[section ""cstring" . GHC.Fingerprint.$trModule2_bytes" {
     GHC.Fingerprint.$trModule2_bytes:
         I8[] [71,72,67,46,70,105,110,103,101,114,112,114,105,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.333469579 UTC

[section ""data" . GHC.Fingerprint.$trModule1_closure" {
     GHC.Fingerprint.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.334953153 UTC

[section ""data" . GHC.Fingerprint.$trModule_closure" {
     GHC.Fingerprint.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Fingerprint.$trModule3_closure+1;
         const GHC.Fingerprint.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.336634932 UTC

[section ""cstring" . GHC.Fingerprint.$tcMD5Context2_bytes" {
     GHC.Fingerprint.$tcMD5Context2_bytes:
         I8[] [77,68,53,67,111,110,116,101,120,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.338177991 UTC

[section ""data" . GHC.Fingerprint.$tcMD5Context1_closure" {
     GHC.Fingerprint.$tcMD5Context1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.$tcMD5Context2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.339869328 UTC

[section ""data" . GHC.Fingerprint.$tcMD5Context_closure" {
     GHC.Fingerprint.$tcMD5Context_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Fingerprint.$trModule_closure+1;
         const GHC.Fingerprint.$tcMD5Context1_closure+1;
         const GHC.Types.krep$*_closure;
         const 2786815183060026909;
         const 11852912954819316049;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.341640286 UTC

[section ""data" . GHC.Fingerprint.fingerprint0_closure" {
     GHC.Fingerprint.fingerprint0_closure:
         const GHC.Fingerprint.Type.Fingerprint_con_info;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.343337834 UTC

[section ""cstring" . lvl_rbDDO_bytes" {
     lvl_rbDDO_bytes:
         I8[] [71,72,67,46,70,105,110,103,101,114,112,114,105,110,116,46,103,101,116,70,105,108,101,72,97,115,104,58,32,111,110,108,121,32,114,101,97,100,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.344968473 UTC

[section ""cstring" . lvl1_rbDDP_bytes" {
     lvl1_rbDDP_bytes:
         I8[] [32,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.348331158 UTC

[section ""data" . lvl2_rbDDQ_closure" {
     lvl2_rbDDQ_closure:
         const lvl2_rbDDQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rbDDQ_entry() //  [R1]
         { info_tbl: [(cbE0G,
                       label: lvl2_rbDDQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE0G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbE0H; else goto cbE0I;
       cbE0H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbE0I: // global
           (_cbE0D::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbE0D::I64 == 0) goto cbE0F; else goto cbE0E;
       cbE0F: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbE0E: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbE0D::I64;
           R2 = lvl1_rbDDP_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.35281204 UTC

[section ""data" . GHC.Fingerprint.$wlvl_closure" {
     GHC.Fingerprint.$wlvl_closure:
         const GHC.Fingerprint.$wlvl_info;
         const 0;
 },
 sat_sbDDX_entry() //  [R1]
         { info_tbl: [(cbE11,
                       label: sat_sbDDX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE11: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbE12; else goto cbE13;
       cbE12: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbE13: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbE0Y_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbE0Y() //  [R1, R2]
         { info_tbl: [(cbE0Y,
                       label: block_cbE0Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE0Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbE16; else goto cbE15;
       cbE16: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbE15: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl2_rbDDQ_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.$wlvl_entry() //  [R2]
         { info_tbl: [(cbE19,
                       label: GHC.Fingerprint.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE19: // global
           _sbDDS::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbE1a; else goto cbE1b;
       cbE1b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbE1d; else goto cbE1c;
       cbE1d: // global
           HpAlloc = 24;
           goto cbE1a;
       cbE1a: // global
           R2 = _sbDDS::I64;
           R1 = GHC.Fingerprint.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbE1c: // global
           I64[Hp - 16] = sat_sbDDX_info;
           I64[Hp] = _sbDDS::I64;
           I64[Sp - 8] = block_cbE17_info;
           R3 = Hp - 16;
           R2 = lvl_rbDDO_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbE17() //  [R1]
         { info_tbl: [(cbE17,
                       label: block_cbE17_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE17: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.363507076 UTC

[section ""data" . GHC.Fingerprint.getFileHash2_closure" {
     GHC.Fingerprint.getFileHash2_closure:
         const GHC.Fingerprint.getFileHash2_info;
         const 0;
 },
 sat_sbDEH_entry() //  [R1]
         { info_tbl: [(cbE2g,
                       label: sat_sbDEH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE2g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbE2h; else goto cbE2i;
       cbE2h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbE2i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$WFingerprint_entry(R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.getFileHash2_entry() //  [R2]
         { info_tbl: [(cbE2j,
                       label: GHC.Fingerprint.getFileHash2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE2j: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cbE2k; else goto cbE2l;
       cbE2k: // global
           R2 = R2;
           R1 = GHC.Fingerprint.getFileHash2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbE2l: // global
           I64[Sp - 16] = block_cbE1A_info;
           R1 = 0;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbE1A() //  [R1]
         { info_tbl: [(cbE1A,
                       label: block_cbE1A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE1A: // global
           _sbDE7::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint]  result hints:  [] __hsbase_MD5Init(_sbDE7::I64);
           I64[Sp - 16] = block_cbE1H_info;
           _sbDE6::P64 = R1;
           R1 = 4096;
           I64[Sp - 8] = _sbDE7::I64;
           P64[Sp] = _sbDE6::P64;
           Sp = Sp - 16;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbE1H() //  [R1]
         { info_tbl: [(cbE1H,
                       label: block_cbE1H_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE1H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbE2p; else goto cbE2o;
       cbE2p: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbE2o: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           _sbDEh::I64 = R1 + 16;
           I64[Hp] = _sbDEh::I64;
           P64[Sp - 16] = R1;
           I64[Sp - 8] = _sbDEh::I64;
           P64[Sp] = Hp - 7;
           Sp = Sp - 16;
           call _cbE2D() args: 0, res: 0, upd: 0;
     }
 },
 _cbE2D() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE2D: // global
           I64[Sp - 8] = block_cbE2F_info;
           R4 = 4096;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 40];
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.$whGetBuf_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbE2F() //  [R1]
         { info_tbl: [(cbE2F,
                       label: block_cbE2F_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE2F: // global
           I64[Sp - 8] = block_cbE2H_info;
           R4 = GHC.IO.Handle.hIsEOF2_closure+2;
           R3 = P64[Sp + 48];
           R2 = GHC.IO.Handle.hIsEOF3_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbE2H() //  [R1]
         { info_tbl: [(cbE2H,
                       label: block_cbE2H_info
                       rep:StackRep [False, False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE2H: // global
           I64[Sp] = block_cbE2J_info;
           _sbDEP::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbDEP::P64;
           if (R1 & 7 != 0) goto ubE3F; else goto cbE2N;
       ubE3F: // global
           call _cbE2J(R1) args: 0, res: 0, upd: 0;
       cbE2N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbE2J() //  [R1]
         { info_tbl: [(cbE2J,
                       label: block_cbE2J_info
                       rep:StackRep [False, False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE2J: // global
           _sbDER::I64 = I64[R1 + 7];
           if (_sbDER::I64 == 4096) goto ubE3B; else goto cbE3l;
       ubE3B: // global
           I64[Sp] = _sbDER::I64;
           call _sbDES() args: 0, res: 0, upd: 0;
       cbE3l: // global
           I64[Sp - 16] = block_cbE3j_info;
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _sbDER::I64;
           I64[Sp] = _sbDER::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubE3G; else goto cbE3m;
       ubE3G: // global
           call _cbE3j(R1) args: 0, res: 0, upd: 0;
       cbE3m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbE3j() //  [R1]
         { info_tbl: [(cbE3j,
                       label: block_cbE3j_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE3j: // global
           if (R1 & 7 == 1) goto cbE3s; else goto ubE3C;
       cbE3s: // global
           R2 = I64[Sp + 8];
           Sp = Sp + 80;
           call GHC.Fingerprint.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ubE3C: // global
           Sp = Sp + 16;
           call _sbDES() args: 0, res: 0, upd: 0;
     }
 },
 _sbDES() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbDES: // global
           _sbDEP::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint, PtrHint,
                                     ‘signed’]  result hints:  [] __hsbase_MD5Update(I64[Sp + 40], I64[Sp + 24], %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp])));
           I64[Sp + 8] = block_cbE35_info;
           R1 = _sbDEP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubE3K; else goto cbE36;
       ubE3K: // global
           call _cbE35(R1) args: 0, res: 0, upd: 0;
       cbE36: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbE35() //  [R1]
         { info_tbl: [(cbE35,
                       label: block_cbE35_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE35: // global
           if (R1 & 7 == 1) goto ubE3D; else goto cbE3g;
       ubE3D: // global
           Sp = Sp + 8;
           call _cbE2D() args: 0, res: 0, upd: 0;
       cbE3g: // global
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 24] = block_cbE1T_info;
           R1 = 16;
           Sp = Sp + 24;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbE1T() //  [R1]
         { info_tbl: [(cbE1T,
                       label: block_cbE1T_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE1T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbE2t; else goto cbE2s;
       cbE2t: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbE2s: // global
           _sbDEs::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] __hsbase_MD5Final(_sbDEs::I64, I64[Sp + 8]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sbDEs::I64;
           I64[Sp] = block_cbE22_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           I64[Sp + 8] = _sbDEs::I64;
           P64[Sp + 24] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbE22() //  [R1]
         { info_tbl: [(cbE22,
                       label: block_cbE22_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE22: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbE2w; else goto cbE2v;
       cbE2w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbE2v: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + 8;
           I64[Sp] = block_cbE28_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           P64[Sp + 8] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbE28() //  [R1]
         { info_tbl: [(cbE28,
                       label: block_cbE28_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE28: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbE2z; else goto cbE2y;
       cbE2z: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbE2y: // global
           _sbDE6::P64 = P64[Sp + 16];
           _sbDEz::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 24]);
           call MO_Touch(_sbDE6::P64);
           I64[Hp - 24] = sat_sbDEH_info;
           P64[Hp - 8] = _sbDEz::P64;
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.391043073 UTC

[section ""data" . GHC.Fingerprint.getFileHash1_closure" {
     GHC.Fingerprint.getFileHash1_closure:
         const GHC.Fingerprint.getFileHash1_info;
         const 0;
 },
 GHC.Fingerprint.getFileHash1_entry() //  [R2]
         { info_tbl: [(cbE4I,
                       label: GHC.Fingerprint.getFileHash1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE4I: // global
           R4 = GHC.Fingerprint.getFileHash2_closure+2;
           R3 = GHC.IO.IOMode.ReadMode_closure+1;
           R2 = R2;
           call System.IO.withBinaryFile1_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.394494154 UTC

[section ""data" . GHC.Fingerprint.getFileHash_closure" {
     GHC.Fingerprint.getFileHash_closure:
         const GHC.Fingerprint.getFileHash_info;
         const 0;
 },
 GHC.Fingerprint.getFileHash_entry() //  [R2]
         { info_tbl: [(cbE4T,
                       label: GHC.Fingerprint.getFileHash_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE4T: // global
           R2 = R2;
           call GHC.Fingerprint.getFileHash1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.398858895 UTC

[section ""data" . GHC.Fingerprint.$wfingerprintData_closure" {
     GHC.Fingerprint.$wfingerprintData_closure:
         const GHC.Fingerprint.$wfingerprintData_info;
 },
 sat_sbDFF_entry() //  [R1]
         { info_tbl: [(cbE5F,
                       label: sat_sbDFF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE5F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbE5G; else goto cbE5H;
       cbE5G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbE5H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$WFingerprint_entry(R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.$wfingerprintData_entry() //  [R2, R3]
         { info_tbl: [(cbE5I,
                       label: GHC.Fingerprint.$wfingerprintData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE5I: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbE5J; else goto cbE5K;
       cbE5J: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.$wfingerprintData_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbE5K: // global
           I64[Sp - 24] = block_cbE54_info;
           R1 = 0;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbE54() //  [R1]
         { info_tbl: [(cbE54,
                       label: block_cbE54_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE54: // global
           _sbDF3::I64 = I64[Sp + 8];
           _sbDF4::I64 = I64[Sp + 16];
           _sbDFc::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint]  result hints:  [] __hsbase_MD5Init(_sbDFc::I64);
           call "ccall" arg hints:  [PtrHint, PtrHint,
                                     ‘signed’]  result hints:  [] __hsbase_MD5Update(_sbDFc::I64, _sbDF3::I64, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbDF4::I64)));
           I64[Sp] = block_cbE5i_info;
           _sbDFb::P64 = R1;
           R1 = 16;
           I64[Sp + 8] = _sbDFc::I64;
           P64[Sp + 16] = _sbDFb::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbE5i() //  [R1]
         { info_tbl: [(cbE5i,
                       label: block_cbE5i_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE5i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbE5O; else goto cbE5N;
       cbE5O: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbE5N: // global
           _sbDFq::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] __hsbase_MD5Final(_sbDFq::I64, I64[Sp + 8]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sbDFq::I64;
           I64[Sp - 8] = block_cbE5r_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           I64[Sp] = _sbDFq::I64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbE5r() //  [R1]
         { info_tbl: [(cbE5r,
                       label: block_cbE5r_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE5r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbE5R; else goto cbE5Q;
       cbE5R: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbE5Q: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + 8;
           I64[Sp] = block_cbE5x_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           P64[Sp + 8] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbE5x() //  [R1]
         { info_tbl: [(cbE5x,
                       label: block_cbE5x_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE5x: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbE5U; else goto cbE5T;
       cbE5U: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbE5T: // global
           _sbDFb::P64 = P64[Sp + 24];
           _sbDFx::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 16]);
           call MO_Touch(_sbDFb::P64);
           I64[Hp - 24] = sat_sbDFF_info;
           P64[Hp - 8] = _sbDFx::P64;
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.41288531 UTC

[section ""data" . GHC.Fingerprint.fingerprintData1_closure" {
     GHC.Fingerprint.fingerprintData1_closure:
         const GHC.Fingerprint.fingerprintData1_info;
 },
 GHC.Fingerprint.fingerprintData1_entry() //  [R2, R3]
         { info_tbl: [(cbE6s,
                       label: GHC.Fingerprint.fingerprintData1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE6s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbE6w; else goto cbE6x;
       cbE6w: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintData1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbE6x: // global
           I64[Sp - 16] = block_cbE6p_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubE6F; else goto cbE6q;
       ubE6F: // global
           call _cbE6p(R1) args: 0, res: 0, upd: 0;
       cbE6q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbE6p() //  [R1]
         { info_tbl: [(cbE6p,
                       label: block_cbE6p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE6p: // global
           I64[Sp] = block_cbE6v_info;
           _sbDFK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sbDFK::I64;
           if (R1 & 7 != 0) goto ubE6E; else goto cbE6z;
       ubE6E: // global
           call _cbE6v(R1) args: 0, res: 0, upd: 0;
       cbE6z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbE6v() //  [R1]
         { info_tbl: [(cbE6v,
                       label: block_cbE6v_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE6v: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Fingerprint.$wfingerprintData_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.419958487 UTC

[section ""data" . GHC.Fingerprint.fingerprintData_closure" {
     GHC.Fingerprint.fingerprintData_closure:
         const GHC.Fingerprint.fingerprintData_info;
 },
 GHC.Fingerprint.fingerprintData_entry() //  [R2, R3]
         { info_tbl: [(cbE6X,
                       label: GHC.Fingerprint.fingerprintData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE6X: // global
           R3 = R3;
           R2 = R2;
           call GHC.Fingerprint.fingerprintData1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.425875052 UTC

[section ""data" . GHC.Fingerprint.fingerprintString_go_closure" {
     GHC.Fingerprint.fingerprintString_go_closure:
         const GHC.Fingerprint.fingerprintString_go_info;
 },
 w32_sbDFR_entry() //  [R1]
         { info_tbl: [(cbE7l,
                       label: w32_sbDFR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE7l: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbE7y; else goto cbE7z;
       cbE7y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbE7z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbE7i_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubE7D; else goto cbE7j;
       ubE7D: // global
           call _cbE7i(R1) args: 0, res: 0, upd: 0;
       cbE7j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbE7i() //  [R1]
         { info_tbl: [(cbE7i,
                       label: block_cbE7i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE7i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbE7C; else goto cbE7B;
       cbE7C: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbE7B: // global
           _sbDFW::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _sbDFW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDGg_entry() //  [R1]
         { info_tbl: [(cbE7I,
                       label: sat_sbDGg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE7I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbE7J; else goto cbE7K;
       cbE7J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbE7K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.fingerprintString_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDGf_entry() //  [R1]
         { info_tbl: [(cbE7S,
                       label: sat_sbDGf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE7S: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbE7Z; else goto cbE80;
       cbE7Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbE80: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbE7P_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubE84; else goto cbE7Q;
       ubE84: // global
           call _cbE7P(R1) args: 0, res: 0, upd: 0;
       cbE7Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbE7P() //  [R1]
         { info_tbl: [(cbE7P,
                       label: block_cbE7P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE7P: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbE83; else goto cbE82;
       cbE83: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbE82: // global
           _sbDGe::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbDGe::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDGb_entry() //  [R1]
         { info_tbl: [(cbE8d,
                       label: sat_sbDGb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE8d: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbE8n; else goto cbE8o;
       cbE8n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbE8o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbE8a_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubE8s; else goto cbE8b;
       ubE8s: // global
           call _cbE8a(R1) args: 0, res: 0, upd: 0;
       cbE8b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbE8a() //  [R1]
         { info_tbl: [(cbE8a,
                       label: block_cbE8a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE8a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbE8r; else goto cbE8q;
       cbE8r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbE8q: // global
           _sbDGa::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7] >> 8));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbDGa::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDG6_entry() //  [R1]
         { info_tbl: [(cbE8B,
                       label: sat_sbDG6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE8B: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbE8L; else goto cbE8M;
       cbE8L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbE8M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbE8y_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubE8Q; else goto cbE8z;
       ubE8Q: // global
           call _cbE8y(R1) args: 0, res: 0, upd: 0;
       cbE8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbE8y() //  [R1]
         { info_tbl: [(cbE8y,
                       label: block_cbE8y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE8y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbE8P; else goto cbE8O;
       cbE8P: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbE8O: // global
           _sbDG5::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7] >> 16));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbDG5::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbDG1_entry() //  [R1]
         { info_tbl: [(cbE8Z,
                       label: sat_sbDG1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE8Z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbE99; else goto cbE9a;
       cbE99: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbE9a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbE8W_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubE9e; else goto cbE8X;
       ubE9e: // global
           call _cbE8W(R1) args: 0, res: 0, upd: 0;
       cbE8X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbE8W() //  [R1]
         { info_tbl: [(cbE8W,
                       label: block_cbE8W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE8W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbE9d; else goto cbE9c;
       cbE9d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbE9c: // global
           _sbDG0::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7] >> 24));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbDG0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.fingerprintString_go_entry() //  [R2]
         { info_tbl: [(cbE9j,
                       label: GHC.Fingerprint.fingerprintString_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE9j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbE9k; else goto cbE9l;
       cbE9k: // global
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintString_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbE9l: // global
           I64[Sp - 8] = block_cbE78_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubE9s; else goto cbE79;
       ubE9s: // global
           call _cbE78(R1) args: 0, res: 0, upd: 0;
       cbE79: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbE78() //  [R1]
         { info_tbl: [(cbE78,
                       label: block_cbE78_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbE78: // global
           if (R1 & 7 == 1) goto cbE9g; else goto cbE9h;
       cbE9g: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbE9h: // global
           Hp = Hp + 240;
           if (Hp > HpLim) (likely: False) goto cbE9r; else goto cbE9q;
       cbE9r: // global
           HpAlloc = 240;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbE9q: // global
           _sbDFP::P64 = P64[R1 + 6];
           _sbDFQ::P64 = P64[R1 + 14];
           I64[Hp - 232] = w32_sbDFR_info;
           P64[Hp - 216] = _sbDFP::P64;
           I64[Hp - 208] = sat_sbDGg_info;
           P64[Hp - 192] = _sbDFQ::P64;
           I64[Hp - 184] = sat_sbDGf_info;
           _cbE7e::P64 = Hp - 232;
           P64[Hp - 168] = _cbE7e::P64;
           I64[Hp - 160] = :_con_info;
           P64[Hp - 152] = Hp - 184;
           P64[Hp - 144] = Hp - 208;
           I64[Hp - 136] = sat_sbDGb_info;
           P64[Hp - 120] = _cbE7e::P64;
           I64[Hp - 112] = :_con_info;
           P64[Hp - 104] = Hp - 136;
           P64[Hp - 96] = Hp - 158;
           I64[Hp - 88] = sat_sbDG6_info;
           P64[Hp - 72] = _cbE7e::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 110;
           I64[Hp - 40] = sat_sbDG1_info;
           P64[Hp - 24] = _cbE7e::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.453793754 UTC

[section ""data" . GHC.Fingerprint.fingerprintString_closure" {
     GHC.Fingerprint.fingerprintString_closure:
         const GHC.Fingerprint.fingerprintString_info;
 },
 GHC.Fingerprint.fingerprintString_entry() //  [R2]
         { info_tbl: [(cbEaM,
                       label: GHC.Fingerprint.fingerprintString_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEaM: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbEaN; else goto cbEaO;
       cbEaN: // global
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbEaO: // global
           I64[Sp - 8] = block_cbEaK_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Fingerprint.fingerprintString_go_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEaK() //  [R1]
         { info_tbl: [(cbEaK,
                       label: block_cbEaK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEaK: // global
           I64[Sp - 8] = block_cbEaR_info;
           R3 = 0;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEaR() //  [R1]
         { info_tbl: [(cbEaR,
                       label: block_cbEaR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEaR: // global
           I64[Sp - 8] = block_cbEaW_info;
           R2 = 1;
           _sbDGm::I64 = R1;
           R1 = R1;
           I64[Sp] = _sbDGm::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEaW() //  [R1]
         { info_tbl: [(cbEaW,
                       label: block_cbEaW_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEaW: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _cbEbe() args: 0, res: 0, upd: 0;
     }
 },
 _cbEbe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEbe: // global
           _sbDGB::P64 = P64[Sp];
           I64[Sp] = block_cbEbh_info;
           R1 = _sbDGB::P64;
           if (R1 & 7 != 0) goto ubEbK; else goto cbEbj;
       ubEbK: // global
           call _cbEbh(R1) args: 0, res: 0, upd: 0;
       cbEbj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEbh() //  [R1]
         { info_tbl: [(cbEbh,
                       label: block_cbEbh_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEbh: // global
           if (R1 & 7 == 1) goto cbEbp; else goto cbEbu;
       cbEbp: // global
           _sbDGm::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_cbEb8_info;
           R3 = _sbDGm::I64;
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Fingerprint.$wfingerprintData_entry(R3,
                                                        R2) args: 8, res: 8, upd: 8;
       cbEbu: // global
           I64[Sp - 8] = block_cbEbs_info;
           _sbDGG::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbDGG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubEbL; else goto cbEbv;
       ubEbL: // global
           call _cbEbs(R1) args: 0, res: 0, upd: 0;
       cbEbv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEb8() //  [R1]
         { info_tbl: [(cbEb8,
                       label: block_cbEb8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEb8: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbEbs() //  [R1]
         { info_tbl: [(cbEbs,
                       label: block_cbEbs_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEbs: // global
           _sbDGC::I64 = I64[Sp + 16];
           _sbDGG::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _sbDGC::I64] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _sbDGG::P64;
           I64[Sp + 16] = _sbDGC::I64 + 1;
           Sp = Sp + 8;
           call _cbEbe() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.47059515 UTC

[section ""data" . GHC.Fingerprint.fingerprintFingerprints_closure" {
     GHC.Fingerprint.fingerprintFingerprints_closure:
         const GHC.Fingerprint.fingerprintFingerprints_info;
 },
 GHC.Fingerprint.fingerprintFingerprints_entry() //  [R2]
         { info_tbl: [(cbEcw,
                       label: GHC.Fingerprint.fingerprintFingerprints_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEcw: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbEcx; else goto cbEcy;
       cbEcx: // global
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintFingerprints_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbEcy: // global
           I64[Sp - 16] = block_cbEcr_info;
           R3 = 0;
           _sbDGO::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbDGO::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEcr() //  [R1]
         { info_tbl: [(cbEcr,
                       label: block_cbEcr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEcr: // global
           I64[Sp - 8] = block_cbEcF_info;
           R2 = 8;
           _sbDGP::I64 = R1;
           R1 = R1 << 4;
           I64[Sp] = _sbDGP::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEcF() //  [R1]
         { info_tbl: [(cbEcF,
                       label: block_cbEcF_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEcF: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _cbEcZ() args: 0, res: 0, upd: 0;
     }
 },
 _cbEcZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEcZ: // global
           _sbDH6::P64 = P64[Sp];
           I64[Sp] = block_cbEd2_info;
           R1 = _sbDH6::P64;
           if (R1 & 7 != 0) goto ubEdP; else goto cbEd4;
       ubEdP: // global
           call _cbEd2(R1) args: 0, res: 0, upd: 0;
       cbEd4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEd2() //  [R1]
         { info_tbl: [(cbEd2,
                       label: block_cbEd2_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEd2: // global
           if (R1 & 7 == 1) goto cbEda; else goto cbEdf;
       cbEda: // global
           _sbDH0::I64 = I64[Sp + 24] << 4;
           I64[Sp + 24] = block_cbEcU_info;
           R3 = _sbDH0::I64;
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Fingerprint.$wfingerprintData_entry(R3,
                                                        R2) args: 8, res: 8, upd: 8;
       cbEdf: // global
           I64[Sp - 8] = block_cbEdd_info;
           _sbDHb::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbDHb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubEdQ; else goto cbEdg;
       ubEdQ: // global
           call _cbEdd(R1) args: 0, res: 0, upd: 0;
       cbEdg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEcU() //  [R1]
         { info_tbl: [(cbEcU,
                       label: block_cbEcU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEcU: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbEdd() //  [R1]
         { info_tbl: [(cbEdd,
                       label: block_cbEdd_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEdd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbEdm; else goto cbEdl;
       cbEdm: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbEdl: // global
           _sbDHd::I64 = I64[R1 + 7];
           _sbDHe::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Word.W64#_con_info;
           I64[Hp - 16] = _sbDHd::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           _sbDHf::I64 = I64[Sp + 24] + (I64[Sp + 16] << 4);
           I64[Hp] = _sbDHf::I64;
           I64[Sp - 16] = block_cbEdv_info;
           R4 = Hp - 23;
           R3 = 8;
           R2 = Hp - 7;
           I64[Sp - 8] = _sbDHf::I64;
           I64[Sp] = _sbDHe::I64;
           Sp = Sp - 16;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEdv() //  [R1]
         { info_tbl: [(cbEdv,
                       label: block_cbEdv_info
                       rep:StackRep [True, True, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEdv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbEdz; else goto cbEdy;
       cbEdz: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbEdy: // global
           I64[Hp - 24] = GHC.Word.W64#_con_info;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + 8;
           I64[Sp + 16] = block_cbEdF_info;
           R4 = Hp - 23;
           R3 = 8;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEdF() //  []
         { info_tbl: [(cbEdF,
                       label: block_cbEdF_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEdF: // global
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16] + 1;
           Sp = Sp + 8;
           call _cbEcZ() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.487560733 UTC

[section ""relreadonly" . SbDI6_srt" {
     SbDI6_srt:
         const lvl2_rbDDQ_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Fingerprint.$wlvl_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Text.$whGetBuf_closure;
         const GHC.IO.Handle.hIsEOF3_closure;
         const GHC.Fingerprint.getFileHash2_closure;
         const System.IO.withBinaryFile1_closure;
         const GHC.Fingerprint.getFileHash1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.863732232 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:33.864844198 UTC

[section ""cstring" . GHC.Fingerprint.$trModule4_bytes" {
     GHC.Fingerprint.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.8666042 UTC

[section ""data" . GHC.Fingerprint.$trModule3_closure" {
     GHC.Fingerprint.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.868322558 UTC

[section ""cstring" . GHC.Fingerprint.$trModule2_bytes" {
     GHC.Fingerprint.$trModule2_bytes:
         I8[] [71,72,67,46,70,105,110,103,101,114,112,114,105,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.870118152 UTC

[section ""data" . GHC.Fingerprint.$trModule1_closure" {
     GHC.Fingerprint.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.871733946 UTC

[section ""data" . GHC.Fingerprint.$trModule_closure" {
     GHC.Fingerprint.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Fingerprint.$trModule3_closure+1;
         const GHC.Fingerprint.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.873451558 UTC

[section ""cstring" . GHC.Fingerprint.$tcMD5Context2_bytes" {
     GHC.Fingerprint.$tcMD5Context2_bytes:
         I8[] [77,68,53,67,111,110,116,101,120,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.875099948 UTC

[section ""data" . GHC.Fingerprint.$tcMD5Context1_closure" {
     GHC.Fingerprint.$tcMD5Context1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Fingerprint.$tcMD5Context2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.87674156 UTC

[section ""data" . GHC.Fingerprint.$tcMD5Context_closure" {
     GHC.Fingerprint.$tcMD5Context_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Fingerprint.$trModule_closure+1;
         const GHC.Fingerprint.$tcMD5Context1_closure+1;
         const GHC.Types.krep$*_closure;
         const 2786815183060026909;
         const 11852912954819316049;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.878513101 UTC

[section ""data" . GHC.Fingerprint.fingerprint0_closure" {
     GHC.Fingerprint.fingerprint0_closure:
         const GHC.Fingerprint.Type.Fingerprint_con_info;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.880162901 UTC

[section ""cstring" . lvl_rbDDO_bytes" {
     lvl_rbDDO_bytes:
         I8[] [71,72,67,46,70,105,110,103,101,114,112,114,105,110,116,46,103,101,116,70,105,108,101,72,97,115,104,58,32,111,110,108,121,32,114,101,97,100,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.88189752 UTC

[section ""cstring" . lvl1_rbDDP_bytes" {
     lvl1_rbDDP_bytes:
         I8[] [32,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.883795805 UTC

[section ""data" . lvl2_rbDDQ_closure" {
     lvl2_rbDDQ_closure:
         const lvl2_rbDDQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rbDDQ_entry() //  [R1]
         { info_tbl: [(cbEiu,
                       label: lvl2_rbDDQ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEiu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbEiv; else goto cbEiw;
       cbEiv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbEiw: // global
           (_cbEir::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbEir::I64 == 0) goto cbEit; else goto cbEis;
       cbEit: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbEis: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbEir::I64;
           R2 = lvl1_rbDDP_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.888483498 UTC

[section ""data" . GHC.Fingerprint.$wlvl_closure" {
     GHC.Fingerprint.$wlvl_closure:
         const GHC.Fingerprint.$wlvl_info;
         const 0;
 },
 sat_sbEeE_entry() //  [R1]
         { info_tbl: [(cbEiQ,
                       label: sat_sbEeE_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEiQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbEiR; else goto cbEiS;
       cbEiR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbEiS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbEiN_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbEiN() //  [R1, R2]
         { info_tbl: [(cbEiN,
                       label: block_cbEiN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEiN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbEiV; else goto cbEiU;
       cbEiV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbEiU: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl2_rbDDQ_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.$wlvl_entry() //  [R2]
         { info_tbl: [(cbEiY,
                       label: GHC.Fingerprint.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEiY: // global
           _sbEez::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cbEiZ; else goto cbEj0;
       cbEj0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbEj2; else goto cbEj1;
       cbEj2: // global
           HpAlloc = 24;
           goto cbEiZ;
       cbEiZ: // global
           R2 = _sbEez::I64;
           R1 = GHC.Fingerprint.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbEj1: // global
           I64[Hp - 16] = sat_sbEeE_info;
           I64[Hp] = _sbEez::I64;
           I64[Sp - 8] = block_cbEiW_info;
           R3 = Hp - 16;
           R2 = lvl_rbDDO_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEiW() //  [R1]
         { info_tbl: [(cbEiW,
                       label: block_cbEiW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEiW: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.900788972 UTC

[section ""data" . GHC.Fingerprint.getFileHash2_closure" {
     GHC.Fingerprint.getFileHash2_closure:
         const GHC.Fingerprint.getFileHash2_info;
         const 0;
 },
 sat_sbEfo_entry() //  [R1]
         { info_tbl: [(cbEkc,
                       label: sat_sbEfo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEkc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbEkd; else goto cbEke;
       cbEkd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbEke: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$WFingerprint_entry(R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.getFileHash2_entry() //  [R2]
         { info_tbl: [(cbEkf,
                       label: GHC.Fingerprint.getFileHash2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEkf: // global
           if ((Sp + -80) < SpLim) (likely: False) goto cbEkg; else goto cbEkh;
       cbEkg: // global
           R2 = R2;
           R1 = GHC.Fingerprint.getFileHash2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbEkh: // global
           I64[Sp - 16] = block_cbEjw_info;
           R1 = 0;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEjw() //  [R1]
         { info_tbl: [(cbEjw,
                       label: block_cbEjw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEjw: // global
           _sbEeO::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint]  result hints:  [] __hsbase_MD5Init(_sbEeO::I64);
           I64[Sp - 16] = block_cbEjD_info;
           _sbEeN::P64 = R1;
           R1 = 4096;
           I64[Sp - 8] = _sbEeO::I64;
           P64[Sp] = _sbEeN::P64;
           Sp = Sp - 16;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEjD() //  [R1]
         { info_tbl: [(cbEjD,
                       label: block_cbEjD_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEjD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbEkl; else goto cbEkk;
       cbEkl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbEkk: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           _sbEeY::I64 = R1 + 16;
           I64[Hp] = _sbEeY::I64;
           P64[Sp - 16] = R1;
           I64[Sp - 8] = _sbEeY::I64;
           P64[Sp] = Hp - 7;
           Sp = Sp - 16;
           call _cbEkz() args: 0, res: 0, upd: 0;
     }
 },
 _cbEkz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEkz: // global
           I64[Sp - 8] = block_cbEkB_info;
           R4 = 4096;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 40];
           Sp = Sp - 8;
           call GHC.IO.Handle.Text.$whGetBuf_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEkB() //  [R1]
         { info_tbl: [(cbEkB,
                       label: block_cbEkB_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEkB: // global
           I64[Sp - 8] = block_cbEkD_info;
           R4 = GHC.IO.Handle.hIsEOF2_closure+2;
           R3 = P64[Sp + 48];
           R2 = GHC.IO.Handle.hIsEOF3_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEkD() //  [R1]
         { info_tbl: [(cbEkD,
                       label: block_cbEkD_info
                       rep:StackRep [False, False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEkD: // global
           I64[Sp] = block_cbEkF_info;
           _sbEfw::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sbEfw::P64;
           if (R1 & 7 != 0) goto ubElB; else goto cbEkJ;
       ubElB: // global
           call _cbEkF(R1) args: 0, res: 0, upd: 0;
       cbEkJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEkF() //  [R1]
         { info_tbl: [(cbEkF,
                       label: block_cbEkF_info
                       rep:StackRep [False, False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEkF: // global
           _sbEfy::I64 = I64[R1 + 7];
           if (_sbEfy::I64 == 4096) goto ubElx; else goto cbElh;
       ubElx: // global
           I64[Sp] = _sbEfy::I64;
           call _sbEfz() args: 0, res: 0, upd: 0;
       cbElh: // global
           I64[Sp - 16] = block_cbElf_info;
           R1 = P64[Sp + 8];
           I64[Sp - 8] = _sbEfy::I64;
           I64[Sp] = _sbEfy::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubElC; else goto cbEli;
       ubElC: // global
           call _cbElf(R1) args: 0, res: 0, upd: 0;
       cbEli: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbElf() //  [R1]
         { info_tbl: [(cbElf,
                       label: block_cbElf_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbElf: // global
           if (R1 & 7 == 1) goto cbElo; else goto ubEly;
       cbElo: // global
           R2 = I64[Sp + 8];
           Sp = Sp + 80;
           call GHC.Fingerprint.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ubEly: // global
           Sp = Sp + 16;
           call _sbEfz() args: 0, res: 0, upd: 0;
     }
 },
 _sbEfz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbEfz: // global
           _sbEfw::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint, PtrHint,
                                     ‘signed’]  result hints:  [] __hsbase_MD5Update(I64[Sp + 40], I64[Sp + 24], %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp])));
           I64[Sp + 8] = block_cbEl1_info;
           R1 = _sbEfw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubElG; else goto cbEl2;
       ubElG: // global
           call _cbEl1(R1) args: 0, res: 0, upd: 0;
       cbEl2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEl1() //  [R1]
         { info_tbl: [(cbEl1,
                       label: block_cbEl1_info
                       rep:StackRep [False, True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEl1: // global
           if (R1 & 7 == 1) goto ubElz; else goto cbElc;
       ubElz: // global
           Sp = Sp + 8;
           call _cbEkz() args: 0, res: 0, upd: 0;
       cbElc: // global
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 24] = block_cbEjP_info;
           R1 = 16;
           Sp = Sp + 24;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEjP() //  [R1]
         { info_tbl: [(cbEjP,
                       label: block_cbEjP_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEjP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbEkp; else goto cbEko;
       cbEkp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbEko: // global
           _sbEf9::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] __hsbase_MD5Final(_sbEf9::I64, I64[Sp + 8]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sbEf9::I64;
           I64[Sp] = block_cbEjY_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           I64[Sp + 8] = _sbEf9::I64;
           P64[Sp + 24] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEjY() //  [R1]
         { info_tbl: [(cbEjY,
                       label: block_cbEjY_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEjY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbEks; else goto cbEkr;
       cbEks: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbEkr: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + 8;
           I64[Sp] = block_cbEk4_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           P64[Sp + 8] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEk4() //  [R1]
         { info_tbl: [(cbEk4,
                       label: block_cbEk4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEk4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbEkv; else goto cbEku;
       cbEkv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbEku: // global
           _sbEeN::P64 = P64[Sp + 16];
           _sbEfg::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 24]);
           call MO_Touch(_sbEeN::P64);
           I64[Hp - 24] = sat_sbEfo_info;
           P64[Hp - 8] = _sbEfg::P64;
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.92739481 UTC

[section ""data" . GHC.Fingerprint.getFileHash1_closure" {
     GHC.Fingerprint.getFileHash1_closure:
         const GHC.Fingerprint.getFileHash1_info;
         const 0;
 },
 GHC.Fingerprint.getFileHash1_entry() //  [R2]
         { info_tbl: [(cbEmU,
                       label: GHC.Fingerprint.getFileHash1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEmU: // global
           R4 = GHC.Fingerprint.getFileHash2_closure+2;
           R3 = GHC.IO.IOMode.ReadMode_closure+1;
           R2 = R2;
           call System.IO.withBinaryFile1_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.931434765 UTC

[section ""data" . GHC.Fingerprint.getFileHash_closure" {
     GHC.Fingerprint.getFileHash_closure:
         const GHC.Fingerprint.getFileHash_info;
         const 0;
 },
 GHC.Fingerprint.getFileHash_entry() //  [R2]
         { info_tbl: [(cbEn6,
                       label: GHC.Fingerprint.getFileHash_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEn6: // global
           R2 = R2;
           call GHC.Fingerprint.getFileHash1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.935948328 UTC

[section ""data" . GHC.Fingerprint.$wfingerprintData_closure" {
     GHC.Fingerprint.$wfingerprintData_closure:
         const GHC.Fingerprint.$wfingerprintData_info;
 },
 sat_sbEgm_entry() //  [R1]
         { info_tbl: [(cbEnS,
                       label: sat_sbEgm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEnS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbEnT; else goto cbEnU;
       cbEnT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbEnU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$WFingerprint_entry(R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.$wfingerprintData_entry() //  [R2, R3]
         { info_tbl: [(cbEnV,
                       label: GHC.Fingerprint.$wfingerprintData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEnV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbEnW; else goto cbEnX;
       cbEnW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.$wfingerprintData_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbEnX: // global
           I64[Sp - 24] = block_cbEnh_info;
           R1 = 0;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEnh() //  [R1]
         { info_tbl: [(cbEnh,
                       label: block_cbEnh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEnh: // global
           _sbEfK::I64 = I64[Sp + 8];
           _sbEfL::I64 = I64[Sp + 16];
           _sbEfT::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint]  result hints:  [] __hsbase_MD5Init(_sbEfT::I64);
           call "ccall" arg hints:  [PtrHint, PtrHint,
                                     ‘signed’]  result hints:  [] __hsbase_MD5Update(_sbEfT::I64, _sbEfK::I64, %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbEfL::I64)));
           I64[Sp] = block_cbEnv_info;
           _sbEfS::P64 = R1;
           R1 = 16;
           I64[Sp + 8] = _sbEfT::I64;
           P64[Sp + 16] = _sbEfS::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEnv() //  [R1]
         { info_tbl: [(cbEnv,
                       label: block_cbEnv_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEnv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbEo1; else goto cbEo0;
       cbEo1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbEo0: // global
           _sbEg7::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] __hsbase_MD5Final(_sbEg7::I64, I64[Sp + 8]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _sbEg7::I64;
           I64[Sp - 8] = block_cbEnE_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           I64[Sp] = _sbEg7::I64;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEnE() //  [R1]
         { info_tbl: [(cbEnE,
                       label: block_cbEnE_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEnE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbEo4; else goto cbEo3;
       cbEo4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbEo3: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + 8;
           I64[Sp] = block_cbEnK_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 7;
           P64[Sp + 8] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEnK() //  [R1]
         { info_tbl: [(cbEnK,
                       label: block_cbEnK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEnK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbEo7; else goto cbEo6;
       cbEo7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbEo6: // global
           _sbEfS::P64 = P64[Sp + 24];
           _sbEge::P64 = P64[Sp + 8];
           call MO_Touch(P64[Sp + 16]);
           call MO_Touch(_sbEfS::P64);
           I64[Hp - 24] = sat_sbEgm_info;
           P64[Hp - 8] = _sbEge::P64;
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.950101596 UTC

[section ""data" . GHC.Fingerprint.fingerprintData1_closure" {
     GHC.Fingerprint.fingerprintData1_closure:
         const GHC.Fingerprint.fingerprintData1_info;
 },
 GHC.Fingerprint.fingerprintData1_entry() //  [R2, R3]
         { info_tbl: [(cbEoN,
                       label: GHC.Fingerprint.fingerprintData1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEoN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbEoR; else goto cbEoS;
       cbEoR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintData1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbEoS: // global
           I64[Sp - 16] = block_cbEoK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubEp0; else goto cbEoL;
       ubEp0: // global
           call _cbEoK(R1) args: 0, res: 0, upd: 0;
       cbEoL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEoK() //  [R1]
         { info_tbl: [(cbEoK,
                       label: block_cbEoK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEoK: // global
           I64[Sp] = block_cbEoQ_info;
           _sbEgr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sbEgr::I64;
           if (R1 & 7 != 0) goto ubEoZ; else goto cbEoU;
       ubEoZ: // global
           call _cbEoQ(R1) args: 0, res: 0, upd: 0;
       cbEoU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEoQ() //  [R1]
         { info_tbl: [(cbEoQ,
                       label: block_cbEoQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEoQ: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Fingerprint.$wfingerprintData_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.957117721 UTC

[section ""data" . GHC.Fingerprint.fingerprintData_closure" {
     GHC.Fingerprint.fingerprintData_closure:
         const GHC.Fingerprint.fingerprintData_info;
 },
 GHC.Fingerprint.fingerprintData_entry() //  [R2, R3]
         { info_tbl: [(cbEpk,
                       label: GHC.Fingerprint.fingerprintData_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEpk: // global
           R3 = R3;
           R2 = R2;
           call GHC.Fingerprint.fingerprintData1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.96241054 UTC

[section ""data" . GHC.Fingerprint.fingerprintString_go_closure" {
     GHC.Fingerprint.fingerprintString_go_closure:
         const GHC.Fingerprint.fingerprintString_go_info;
 },
 w32_sbEgy_entry() //  [R1]
         { info_tbl: [(cbEpI,
                       label: w32_sbEgy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEpI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbEpV; else goto cbEpW;
       cbEpV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbEpW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbEpF_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubEq0; else goto cbEpG;
       ubEq0: // global
           call _cbEpF(R1) args: 0, res: 0, upd: 0;
       cbEpG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbEpF() //  [R1]
         { info_tbl: [(cbEpF,
                       label: block_cbEpF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEpF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbEpZ; else goto cbEpY;
       cbEpZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbEpY: // global
           _sbEgD::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _sbEgD::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbEgX_entry() //  [R1]
         { info_tbl: [(cbEq5,
                       label: sat_sbEgX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEq5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbEq6; else goto cbEq7;
       cbEq6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbEq7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.fingerprintString_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbEgW_entry() //  [R1]
         { info_tbl: [(cbEqf,
                       label: sat_sbEgW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEqf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbEqm; else goto cbEqn;
       cbEqm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbEqn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbEqc_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubEqr; else goto cbEqd;
       ubEqr: // global
           call _cbEqc(R1) args: 0, res: 0, upd: 0;
       cbEqd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbEqc() //  [R1]
         { info_tbl: [(cbEqc,
                       label: block_cbEqc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEqc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbEqq; else goto cbEqp;
       cbEqq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbEqp: // global
           _sbEgV::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbEgV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbEgS_entry() //  [R1]
         { info_tbl: [(cbEqA,
                       label: sat_sbEgS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEqA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbEqK; else goto cbEqL;
       cbEqK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbEqL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbEqx_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubEqP; else goto cbEqy;
       ubEqP: // global
           call _cbEqx(R1) args: 0, res: 0, upd: 0;
       cbEqy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbEqx() //  [R1]
         { info_tbl: [(cbEqx,
                       label: block_cbEqx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEqx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbEqO; else goto cbEqN;
       cbEqO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbEqN: // global
           _sbEgR::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7] >> 8));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbEgR::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbEgN_entry() //  [R1]
         { info_tbl: [(cbEqY,
                       label: sat_sbEgN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEqY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbEr8; else goto cbEr9;
       cbEr8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbEr9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbEqV_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubErd; else goto cbEqW;
       ubErd: // global
           call _cbEqV(R1) args: 0, res: 0, upd: 0;
       cbEqW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbEqV() //  [R1]
         { info_tbl: [(cbEqV,
                       label: block_cbEqV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEqV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbErc; else goto cbErb;
       cbErc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbErb: // global
           _sbEgM::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7] >> 16));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbEgM::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbEgI_entry() //  [R1]
         { info_tbl: [(cbErm,
                       label: sat_sbEgI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbErm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbErw; else goto cbErx;
       cbErw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbErx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbErj_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubErB; else goto cbErk;
       ubErB: // global
           call _cbErj(R1) args: 0, res: 0, upd: 0;
       cbErk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbErj() //  [R1]
         { info_tbl: [(cbErj,
                       label: block_cbErj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbErj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbErA; else goto cbErz;
       cbErA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbErz: // global
           _sbEgH::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7] >> 24));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _sbEgH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Fingerprint.fingerprintString_go_entry() //  [R2]
         { info_tbl: [(cbErG,
                       label: GHC.Fingerprint.fingerprintString_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbErG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbErH; else goto cbErI;
       cbErH: // global
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintString_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbErI: // global
           I64[Sp - 8] = block_cbEpv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubErP; else goto cbEpw;
       ubErP: // global
           call _cbEpv(R1) args: 0, res: 0, upd: 0;
       cbEpw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEpv() //  [R1]
         { info_tbl: [(cbEpv,
                       label: block_cbEpv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEpv: // global
           if (R1 & 7 == 1) goto cbErD; else goto cbErE;
       cbErD: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbErE: // global
           Hp = Hp + 240;
           if (Hp > HpLim) (likely: False) goto cbErO; else goto cbErN;
       cbErO: // global
           HpAlloc = 240;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbErN: // global
           _sbEgw::P64 = P64[R1 + 6];
           _sbEgx::P64 = P64[R1 + 14];
           I64[Hp - 232] = w32_sbEgy_info;
           P64[Hp - 216] = _sbEgw::P64;
           I64[Hp - 208] = sat_sbEgX_info;
           P64[Hp - 192] = _sbEgx::P64;
           I64[Hp - 184] = sat_sbEgW_info;
           _cbEpB::P64 = Hp - 232;
           P64[Hp - 168] = _cbEpB::P64;
           I64[Hp - 160] = :_con_info;
           P64[Hp - 152] = Hp - 184;
           P64[Hp - 144] = Hp - 208;
           I64[Hp - 136] = sat_sbEgS_info;
           P64[Hp - 120] = _cbEpB::P64;
           I64[Hp - 112] = :_con_info;
           P64[Hp - 104] = Hp - 136;
           P64[Hp - 96] = Hp - 158;
           I64[Hp - 88] = sat_sbEgN_info;
           P64[Hp - 72] = _cbEpB::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 110;
           I64[Hp - 40] = sat_sbEgI_info;
           P64[Hp - 24] = _cbEpB::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.991816157 UTC

[section ""data" . GHC.Fingerprint.fingerprintString_closure" {
     GHC.Fingerprint.fingerprintString_closure:
         const GHC.Fingerprint.fingerprintString_info;
 },
 GHC.Fingerprint.fingerprintString_entry() //  [R2]
         { info_tbl: [(cbEtB,
                       label: GHC.Fingerprint.fingerprintString_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEtB: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cbEtC; else goto cbEtD;
       cbEtC: // global
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbEtD: // global
           I64[Sp - 8] = block_cbEtz_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Fingerprint.fingerprintString_go_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEtz() //  [R1]
         { info_tbl: [(cbEtz,
                       label: block_cbEtz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEtz: // global
           I64[Sp - 8] = block_cbEtG_info;
           R3 = 0;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEtG() //  [R1]
         { info_tbl: [(cbEtG,
                       label: block_cbEtG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEtG: // global
           I64[Sp - 8] = block_cbEtL_info;
           R2 = 1;
           _sbEh3::I64 = R1;
           R1 = R1;
           I64[Sp] = _sbEh3::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEtL() //  [R1]
         { info_tbl: [(cbEtL,
                       label: block_cbEtL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEtL: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _cbEu3() args: 0, res: 0, upd: 0;
     }
 },
 _cbEu3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEu3: // global
           _sbEhi::P64 = P64[Sp];
           I64[Sp] = block_cbEu6_info;
           R1 = _sbEhi::P64;
           if (R1 & 7 != 0) goto ubEuz; else goto cbEu8;
       ubEuz: // global
           call _cbEu6(R1) args: 0, res: 0, upd: 0;
       cbEu8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEu6() //  [R1]
         { info_tbl: [(cbEu6,
                       label: block_cbEu6_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEu6: // global
           if (R1 & 7 == 1) goto cbEue; else goto cbEuj;
       cbEue: // global
           _sbEh3::I64 = I64[Sp + 24];
           I64[Sp + 24] = block_cbEtX_info;
           R3 = _sbEh3::I64;
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Fingerprint.$wfingerprintData_entry(R3,
                                                        R2) args: 8, res: 8, upd: 8;
       cbEuj: // global
           I64[Sp - 8] = block_cbEuh_info;
           _sbEhn::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbEhn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubEuA; else goto cbEuk;
       ubEuA: // global
           call _cbEuh(R1) args: 0, res: 0, upd: 0;
       cbEuk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEtX() //  [R1]
         { info_tbl: [(cbEtX,
                       label: block_cbEtX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEtX: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbEuh() //  [R1]
         { info_tbl: [(cbEuh,
                       label: block_cbEuh_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEuh: // global
           _sbEhj::I64 = I64[Sp + 16];
           _sbEhn::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _sbEhj::I64] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _sbEhn::P64;
           I64[Sp + 16] = _sbEhj::I64 + 1;
           Sp = Sp + 8;
           call _cbEu3() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.007795609 UTC

[section ""data" . GHC.Fingerprint.fingerprintFingerprints_closure" {
     GHC.Fingerprint.fingerprintFingerprints_closure:
         const GHC.Fingerprint.fingerprintFingerprints_info;
 },
 GHC.Fingerprint.fingerprintFingerprints_entry() //  [R2]
         { info_tbl: [(cbEvr,
                       label: GHC.Fingerprint.fingerprintFingerprints_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEvr: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbEvs; else goto cbEvt;
       cbEvs: // global
           R2 = R2;
           R1 = GHC.Fingerprint.fingerprintFingerprints_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbEvt: // global
           I64[Sp - 16] = block_cbEvm_info;
           R3 = 0;
           _sbEhv::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _sbEhv::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEvm() //  [R1]
         { info_tbl: [(cbEvm,
                       label: block_cbEvm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEvm: // global
           I64[Sp - 8] = block_cbEvA_info;
           R2 = 8;
           _sbEhw::I64 = R1;
           R1 = R1 << 4;
           I64[Sp] = _sbEhw::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEvA() //  [R1]
         { info_tbl: [(cbEvA,
                       label: block_cbEvA_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEvA: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _cbEvU() args: 0, res: 0, upd: 0;
     }
 },
 _cbEvU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEvU: // global
           _sbEhN::P64 = P64[Sp];
           I64[Sp] = block_cbEvX_info;
           R1 = _sbEhN::P64;
           if (R1 & 7 != 0) goto ubEwK; else goto cbEvZ;
       ubEwK: // global
           call _cbEvX(R1) args: 0, res: 0, upd: 0;
       cbEvZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEvX() //  [R1]
         { info_tbl: [(cbEvX,
                       label: block_cbEvX_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEvX: // global
           if (R1 & 7 == 1) goto cbEw5; else goto cbEwa;
       cbEw5: // global
           _sbEhH::I64 = I64[Sp + 24] << 4;
           I64[Sp + 24] = block_cbEvP_info;
           R3 = _sbEhH::I64;
           R2 = I64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Fingerprint.$wfingerprintData_entry(R3,
                                                        R2) args: 8, res: 8, upd: 8;
       cbEwa: // global
           I64[Sp - 8] = block_cbEw8_info;
           _sbEhS::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbEhS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubEwL; else goto cbEwb;
       ubEwL: // global
           call _cbEw8(R1) args: 0, res: 0, upd: 0;
       cbEwb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbEvP() //  [R1]
         { info_tbl: [(cbEvP,
                       label: block_cbEvP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEvP: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbEw8() //  [R1]
         { info_tbl: [(cbEw8,
                       label: block_cbEw8_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEw8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbEwh; else goto cbEwg;
       cbEwh: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbEwg: // global
           _sbEhU::I64 = I64[R1 + 7];
           _sbEhV::I64 = I64[R1 + 15];
           I64[Hp - 24] = GHC.Word.W64#_con_info;
           I64[Hp - 16] = _sbEhU::I64;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           _sbEhW::I64 = I64[Sp + 24] + (I64[Sp + 16] << 4);
           I64[Hp] = _sbEhW::I64;
           I64[Sp - 16] = block_cbEwq_info;
           R4 = Hp - 23;
           R3 = 8;
           R2 = Hp - 7;
           I64[Sp - 8] = _sbEhW::I64;
           I64[Sp] = _sbEhV::I64;
           Sp = Sp - 16;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEwq() //  [R1]
         { info_tbl: [(cbEwq,
                       label: block_cbEwq_info
                       rep:StackRep [True, True, False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEwq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbEwu; else goto cbEwt;
       cbEwu: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbEwt: // global
           I64[Hp - 24] = GHC.Word.W64#_con_info;
           I64[Hp - 16] = I64[Sp + 16];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + 8;
           I64[Sp + 16] = block_cbEwA_info;
           R4 = Hp - 23;
           R3 = 8;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbEwA() //  []
         { info_tbl: [(cbEwA,
                       label: block_cbEwA_info
                       rep:StackRep [False, True, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbEwA: // global
           P64[Sp + 8] = P64[Sp + 8];
           I64[Sp + 16] = I64[Sp + 16] + 1;
           Sp = Sp + 8;
           call _cbEvU() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:34.025460596 UTC

[section ""relreadonly" . SbEj6_srt" {
     SbEj6_srt:
         const lvl2_rbDDQ_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Fingerprint.$wlvl_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Text.$whGetBuf_closure;
         const GHC.IO.Handle.hIsEOF3_closure;
         const GHC.Fingerprint.getFileHash2_closure;
         const System.IO.withBinaryFile1_closure;
         const GHC.Fingerprint.getFileHash1_closure;
 }]

