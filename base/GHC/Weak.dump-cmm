
==================== Output Cmm ====================
2018-03-16 15:57:07.651898315 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:57:07.653147586 UTC

[section ""data" . GHC.Weak.mkWeak1_closure" {
     GHC.Weak.mkWeak1_closure:
         const GHC.Weak.mkWeak1_info;
 },
 GHC.Weak.mkWeak1_entry() //  [R2, R3, R4]
         { info_tbl: [(c2nHG,
                       label: GHC.Weak.mkWeak1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nHG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2nHH; else goto c2nHI;
       c2nHH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Weak.mkWeak1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2nHI: // global
           I64[Sp - 24] = block_c2nHz_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2nI1; else goto c2nHA;
       u2nI1: // global
           call _c2nHz(R1) args: 0, res: 0, upd: 0;
       c2nHA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nHz() //  [R1]
         { info_tbl: [(c2nHz,
                       label: block_c2nHz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nHz: // global
           _s2nGL::P64 = P64[Sp + 8];
           _s2nGM::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c2nHD; else goto c2nHE;
       c2nHD: // global
           I64[Sp + 16] = block_c2nHL_info;
           R2 = _s2nGM::P64;
           R1 = _s2nGL::P64;
           Sp = Sp + 16;
           call stg_mkWeakNoFinalizer#(R2, R1) args: 8, res: 8, upd: 8;
       c2nHE: // global
           I64[Sp + 16] = block_c2nHU_info;
           R3 = P64[R1 + 6];
           R2 = _s2nGM::P64;
           R1 = _s2nGL::P64;
           Sp = Sp + 16;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nHL() //  [R1]
         { info_tbl: [(c2nHL,
                       label: block_c2nHL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nHL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nHR; else goto c2nHQ;
       c2nHR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2nHQ: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2nHU() //  [R1]
         { info_tbl: [(c2nHU,
                       label: block_c2nHU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nHU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nI0; else goto c2nHZ;
       c2nI0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2nHZ: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.655009312 UTC

[section ""data" . GHC.Weak.mkWeak_closure" {
     GHC.Weak.mkWeak_closure:
         const GHC.Weak.mkWeak_info;
 },
 GHC.Weak.mkWeak_entry() //  [R2, R3, R4]
         { info_tbl: [(c2nI6,
                       label: GHC.Weak.mkWeak_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nI6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Weak.mkWeak1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.656376928 UTC

[section ""data" . GHC.Weak.deRefWeak1_closure" {
     GHC.Weak.deRefWeak1_closure:
         const GHC.Weak.deRefWeak1_info;
 },
 GHC.Weak.deRefWeak1_entry() //  [R2]
         { info_tbl: [(c2nIg,
                       label: GHC.Weak.deRefWeak1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nIg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2nIh; else goto c2nIi;
       c2nIh: // global
           R2 = R2;
           R1 = GHC.Weak.deRefWeak1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2nIi: // global
           I64[Sp - 8] = block_c2nId_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2nIA; else goto c2nIe;
       u2nIA: // global
           call _c2nId(R1) args: 0, res: 0, upd: 0;
       c2nIe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nId() //  [R1]
         { info_tbl: [(c2nId,
                       label: block_c2nId_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nId: // global
           I64[Sp] = block_c2nIl_info;
           R1 = P64[R1 + 7];
           call stg_deRefWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nIl() //  [R1, R2]
         { info_tbl: [(c2nIl,
                       label: block_c2nIl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nIl: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c2nIn() args: 0, res: 0, upd: 0;
     }
 },
 _c2nIn() //  []
         { info_tbl: [(c2nIn,
                       label: block_c2nIn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nIn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nIs; else goto c2nIr;
       c2nIs: // global
           HpAlloc = 16;
           I64[Sp] = block_c2nIn_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c2nIr: // global
           if (I64[Sp + 16] == 0) goto c2nIy; else goto c2nIx;
       c2nIy: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2nIx: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.657954508 UTC

[section ""data" . GHC.Weak.deRefWeak_closure" {
     GHC.Weak.deRefWeak_closure:
         const GHC.Weak.deRefWeak_info;
 },
 GHC.Weak.deRefWeak_entry() //  [R2]
         { info_tbl: [(c2nIG,
                       label: GHC.Weak.deRefWeak_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nIG: // global
           R2 = R2;
           call GHC.Weak.deRefWeak1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.658957312 UTC

[section ""data" . GHC.Weak.finalize1_closure" {
     GHC.Weak.finalize1_closure:
         const GHC.Weak.finalize1_info;
 },
 GHC.Weak.finalize1_entry() //  [R2]
         { info_tbl: [(c2nIQ,
                       label: GHC.Weak.finalize1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nIQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2nIR; else goto c2nIS;
       c2nIR: // global
           R2 = R2;
           R1 = GHC.Weak.finalize1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2nIS: // global
           I64[Sp - 8] = block_c2nIN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2nJ5; else goto c2nIO;
       u2nJ5: // global
           call _c2nIN(R1) args: 0, res: 0, upd: 0;
       c2nIO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nIN() //  [R1]
         { info_tbl: [(c2nIN,
                       label: block_c2nIN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nIN: // global
           I64[Sp] = block_c2nIV_info;
           R1 = P64[R1 + 7];
           call stg_finalizeWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nIV() //  [R1, R2]
         { info_tbl: [(c2nIV,
                       label: block_c2nIV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nIV: // global
           if (R1 == 0) goto c2nJ4; else goto c2nJ3;
       c2nJ4: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2nJ3: // global
           R1 = R2;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.660171338 UTC

[section ""data" . GHC.Weak.finalize_closure" {
     GHC.Weak.finalize_closure:
         const GHC.Weak.finalize_info;
 },
 GHC.Weak.finalize_entry() //  [R2]
         { info_tbl: [(c2nJa,
                       label: GHC.Weak.finalize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nJa: // global
           R2 = R2;
           call GHC.Weak.finalize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.661371645 UTC

[section ""data" . GHC.Weak.runFinalizerBatch1_closure" {
     GHC.Weak.runFinalizerBatch1_closure:
         const GHC.Weak.runFinalizerBatch1_info;
 },
 GHC.Weak.runFinalizerBatch1_entry() //  [R2, R3]
         { info_tbl: [(c2nJk,
                       label: GHC.Weak.runFinalizerBatch1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nJk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2nJl; else goto c2nJm;
       c2nJl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Weak.runFinalizerBatch1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2nJm: // global
           I64[Sp - 16] = block_c2nJh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2nJK; else goto c2nJi;
       u2nJK: // global
           call _c2nJh(R1) args: 0, res: 0, upd: 0;
       c2nJi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nJh() //  [R1]
         { info_tbl: [(c2nJh,
                       label: block_c2nJh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nJh: // global
           I64[Sp] = I64[R1 + 7];
           call _c2nJt() args: 0, res: 0, upd: 0;
     }
 },
 _c2nJt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nJt: // global
           _s2nHq::I64 = I64[Sp];
           if (_s2nHq::I64 != 0) goto c2nJD; else goto c2nJG;
       c2nJD: // global
           _s2nHr::I64 = _s2nHq::I64 - 1;
           _s2nHt::P64 = P64[P64[Sp + 8] + ((_s2nHr::I64 << 3) + 24)];
           I64[Sp - 8] = block_c2nJB_info;
           R1 = _s2nHt::P64;
           I64[Sp] = _s2nHr::I64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       c2nJG: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2nJB() //  []
         { info_tbl: [(c2nJB,
                       label: block_c2nJB_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nJB: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c2nJt() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.662837329 UTC

[section ""data" . GHC.Weak.runFinalizerBatch_closure" {
     GHC.Weak.runFinalizerBatch_closure:
         const GHC.Weak.runFinalizerBatch_info;
 },
 GHC.Weak.runFinalizerBatch_entry() //  [R2, R3]
         { info_tbl: [(c2nJQ,
                       label: GHC.Weak.runFinalizerBatch_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nJQ: // global
           R3 = R3;
           R2 = R2;
           call GHC.Weak.runFinalizerBatch1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.663577515 UTC

[section ""cstring" . GHC.Weak.$trModule4_bytes" {
     GHC.Weak.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.664138071 UTC

[section ""data" . GHC.Weak.$trModule3_closure" {
     GHC.Weak.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.664939896 UTC

[section ""cstring" . GHC.Weak.$trModule2_bytes" {
     GHC.Weak.$trModule2_bytes:
         I8[] [71,72,67,46,87,101,97,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.665772894 UTC

[section ""data" . GHC.Weak.$trModule1_closure" {
     GHC.Weak.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.666462725 UTC

[section ""data" . GHC.Weak.$trModule_closure" {
     GHC.Weak.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Weak.$trModule3_closure+1;
         const GHC.Weak.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.667023872 UTC

[section ""data" . $krep_r2nGG_closure" {
     $krep_r2nGG_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.667548579 UTC

[section ""data" . $krep1_r2nGH_closure" {
     $krep1_r2nGH_closure:
         const :_con_info;
         const $krep_r2nGG_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.66814374 UTC

[section ""data" . $krep2_r2nGI_closure" {
     $krep2_r2nGI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWeak#_closure;
         const $krep1_r2nGH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.668768454 UTC

[section ""cstring" . GHC.Weak.$tcWeak2_bytes" {
     GHC.Weak.$tcWeak2_bytes:
         I8[] [87,101,97,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.669695427 UTC

[section ""data" . GHC.Weak.$tcWeak1_closure" {
     GHC.Weak.$tcWeak1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$tcWeak2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.670331316 UTC

[section ""data" . GHC.Weak.$tcWeak_closure" {
     GHC.Weak.$tcWeak_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Weak.$trModule_closure+1;
         const GHC.Weak.$tcWeak1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 16083706323098193819;
         const 16670279643231176950;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.671095266 UTC

[section ""data" . $krep3_r2nGJ_closure" {
     $krep3_r2nGJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Weak.$tcWeak_closure+1;
         const $krep1_r2nGH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.671752273 UTC

[section ""data" . GHC.Weak.$tc'Weak1_closure" {
     GHC.Weak.$tc'Weak1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r2nGI_closure+1;
         const $krep3_r2nGJ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.67244404 UTC

[section ""cstring" . GHC.Weak.$tc'Weak3_bytes" {
     GHC.Weak.$tc'Weak3_bytes:
         I8[] [39,87,101,97,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.673057494 UTC

[section ""data" . GHC.Weak.$tc'Weak2_closure" {
     GHC.Weak.$tc'Weak2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$tc'Weak3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.673732795 UTC

[section ""data" . GHC.Weak.$tc'Weak_closure" {
     GHC.Weak.$tc'Weak_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Weak.$trModule_closure+1;
         const GHC.Weak.$tc'Weak2_closure+1;
         const GHC.Weak.$tc'Weak1_closure+4;
         const 3879909390682789585;
         const 9243676412269356154;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.67559257 UTC

[section ""data" . GHC.Weak.Weak_closure" {
     GHC.Weak.Weak_closure:
         const GHC.Weak.Weak_info;
 },
 GHC.Weak.Weak_entry() //  [R2]
         { info_tbl: [(c2nJY,
                       label: GHC.Weak.Weak_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nJY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nK2; else goto c2nK1;
       c2nK2: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Weak.Weak_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2nK1: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.676571328 UTC

[GHC.Weak.Weak_con_entry() //  [R1]
         { info_tbl: [(c2nK3,
                       label: GHC.Weak.Weak_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,101,97,107,46,87,101,97,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nK3: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.677375552 UTC

[section ""relreadonly" . S2nK4_srt" { S2nK4_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.677891666 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:57:07.678910921 UTC

[section ""data" . GHC.Weak.mkWeak1_closure" {
     GHC.Weak.mkWeak1_closure:
         const GHC.Weak.mkWeak1_info;
 },
 GHC.Weak.mkWeak1_entry() //  [R2, R3, R4]
         { info_tbl: [(c2nKg,
                       label: GHC.Weak.mkWeak1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nKg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2nKh; else goto c2nKi;
       c2nKh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Weak.mkWeak1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2nKi: // global
           I64[Sp - 24] = block_c2nK9_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2nKB; else goto c2nKa;
       u2nKB: // global
           call _c2nK9(R1) args: 0, res: 0, upd: 0;
       c2nKa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nK9() //  [R1]
         { info_tbl: [(c2nK9,
                       label: block_c2nK9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nK9: // global
           _s2nGL::P64 = P64[Sp + 8];
           _s2nGM::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c2nKd; else goto c2nKe;
       c2nKd: // global
           I64[Sp + 16] = block_c2nKl_info;
           R2 = _s2nGM::P64;
           R1 = _s2nGL::P64;
           Sp = Sp + 16;
           call stg_mkWeakNoFinalizer#(R2, R1) args: 8, res: 8, upd: 8;
       c2nKe: // global
           I64[Sp + 16] = block_c2nKu_info;
           R3 = P64[R1 + 6];
           R2 = _s2nGM::P64;
           R1 = _s2nGL::P64;
           Sp = Sp + 16;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nKl() //  [R1]
         { info_tbl: [(c2nKl,
                       label: block_c2nKl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nKl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nKr; else goto c2nKq;
       c2nKr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2nKq: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2nKu() //  [R1]
         { info_tbl: [(c2nKu,
                       label: block_c2nKu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nKu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nKA; else goto c2nKz;
       c2nKA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2nKz: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.680617287 UTC

[section ""data" . GHC.Weak.mkWeak_closure" {
     GHC.Weak.mkWeak_closure:
         const GHC.Weak.mkWeak_info;
 },
 GHC.Weak.mkWeak_entry() //  [R2, R3, R4]
         { info_tbl: [(c2nKG,
                       label: GHC.Weak.mkWeak_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nKG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Weak.mkWeak1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.681839267 UTC

[section ""data" . GHC.Weak.deRefWeak1_closure" {
     GHC.Weak.deRefWeak1_closure:
         const GHC.Weak.deRefWeak1_info;
 },
 GHC.Weak.deRefWeak1_entry() //  [R2]
         { info_tbl: [(c2nKQ,
                       label: GHC.Weak.deRefWeak1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nKQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2nKR; else goto c2nKS;
       c2nKR: // global
           R2 = R2;
           R1 = GHC.Weak.deRefWeak1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2nKS: // global
           I64[Sp - 8] = block_c2nKN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2nLa; else goto c2nKO;
       u2nLa: // global
           call _c2nKN(R1) args: 0, res: 0, upd: 0;
       c2nKO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nKN() //  [R1]
         { info_tbl: [(c2nKN,
                       label: block_c2nKN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nKN: // global
           I64[Sp] = block_c2nKV_info;
           R1 = P64[R1 + 7];
           call stg_deRefWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nKV() //  [R1, R2]
         { info_tbl: [(c2nKV,
                       label: block_c2nKV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nKV: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c2nKX() args: 0, res: 0, upd: 0;
     }
 },
 _c2nKX() //  []
         { info_tbl: [(c2nKX,
                       label: block_c2nKX_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nKX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nL2; else goto c2nL1;
       c2nL2: // global
           HpAlloc = 16;
           I64[Sp] = block_c2nKX_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c2nL1: // global
           if (I64[Sp + 16] == 0) goto c2nL8; else goto c2nL7;
       c2nL8: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2nL7: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.683348488 UTC

[section ""data" . GHC.Weak.deRefWeak_closure" {
     GHC.Weak.deRefWeak_closure:
         const GHC.Weak.deRefWeak_info;
 },
 GHC.Weak.deRefWeak_entry() //  [R2]
         { info_tbl: [(c2nLg,
                       label: GHC.Weak.deRefWeak_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nLg: // global
           R2 = R2;
           call GHC.Weak.deRefWeak1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.684299884 UTC

[section ""data" . GHC.Weak.finalize1_closure" {
     GHC.Weak.finalize1_closure:
         const GHC.Weak.finalize1_info;
 },
 GHC.Weak.finalize1_entry() //  [R2]
         { info_tbl: [(c2nLq,
                       label: GHC.Weak.finalize1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nLq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2nLr; else goto c2nLs;
       c2nLr: // global
           R2 = R2;
           R1 = GHC.Weak.finalize1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2nLs: // global
           I64[Sp - 8] = block_c2nLn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2nLF; else goto c2nLo;
       u2nLF: // global
           call _c2nLn(R1) args: 0, res: 0, upd: 0;
       c2nLo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nLn() //  [R1]
         { info_tbl: [(c2nLn,
                       label: block_c2nLn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nLn: // global
           I64[Sp] = block_c2nLv_info;
           R1 = P64[R1 + 7];
           call stg_finalizeWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nLv() //  [R1, R2]
         { info_tbl: [(c2nLv,
                       label: block_c2nLv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nLv: // global
           if (R1 == 0) goto c2nLE; else goto c2nLD;
       c2nLE: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2nLD: // global
           R1 = R2;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.685997737 UTC

[section ""data" . GHC.Weak.finalize_closure" {
     GHC.Weak.finalize_closure:
         const GHC.Weak.finalize_info;
 },
 GHC.Weak.finalize_entry() //  [R2]
         { info_tbl: [(c2nLK,
                       label: GHC.Weak.finalize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nLK: // global
           R2 = R2;
           call GHC.Weak.finalize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.687137981 UTC

[section ""data" . GHC.Weak.runFinalizerBatch1_closure" {
     GHC.Weak.runFinalizerBatch1_closure:
         const GHC.Weak.runFinalizerBatch1_info;
 },
 GHC.Weak.runFinalizerBatch1_entry() //  [R2, R3]
         { info_tbl: [(c2nLU,
                       label: GHC.Weak.runFinalizerBatch1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nLU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2nLV; else goto c2nLW;
       c2nLV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Weak.runFinalizerBatch1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2nLW: // global
           I64[Sp - 16] = block_c2nLR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2nMk; else goto c2nLS;
       u2nMk: // global
           call _c2nLR(R1) args: 0, res: 0, upd: 0;
       c2nLS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nLR() //  [R1]
         { info_tbl: [(c2nLR,
                       label: block_c2nLR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nLR: // global
           I64[Sp] = I64[R1 + 7];
           call _c2nM3() args: 0, res: 0, upd: 0;
     }
 },
 _c2nM3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nM3: // global
           _s2nHq::I64 = I64[Sp];
           if (_s2nHq::I64 != 0) goto c2nMd; else goto c2nMg;
       c2nMd: // global
           _s2nHr::I64 = _s2nHq::I64 - 1;
           _s2nHt::P64 = P64[P64[Sp + 8] + ((_s2nHr::I64 << 3) + 24)];
           I64[Sp - 8] = block_c2nMb_info;
           R1 = _s2nHt::P64;
           I64[Sp] = _s2nHr::I64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       c2nMg: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2nMb() //  []
         { info_tbl: [(c2nMb,
                       label: block_c2nMb_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nMb: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c2nM3() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.688553 UTC

[section ""data" . GHC.Weak.runFinalizerBatch_closure" {
     GHC.Weak.runFinalizerBatch_closure:
         const GHC.Weak.runFinalizerBatch_info;
 },
 GHC.Weak.runFinalizerBatch_entry() //  [R2, R3]
         { info_tbl: [(c2nMq,
                       label: GHC.Weak.runFinalizerBatch_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nMq: // global
           R3 = R3;
           R2 = R2;
           call GHC.Weak.runFinalizerBatch1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.689295777 UTC

[section ""cstring" . GHC.Weak.$trModule4_bytes" {
     GHC.Weak.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.689877855 UTC

[section ""data" . GHC.Weak.$trModule3_closure" {
     GHC.Weak.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.690422581 UTC

[section ""cstring" . GHC.Weak.$trModule2_bytes" {
     GHC.Weak.$trModule2_bytes:
         I8[] [71,72,67,46,87,101,97,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.691028495 UTC

[section ""data" . GHC.Weak.$trModule1_closure" {
     GHC.Weak.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.691611362 UTC

[section ""data" . GHC.Weak.$trModule_closure" {
     GHC.Weak.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Weak.$trModule3_closure+1;
         const GHC.Weak.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.692181965 UTC

[section ""data" . $krep_r2nGG_closure" {
     $krep_r2nGG_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.692724416 UTC

[section ""data" . $krep1_r2nGH_closure" {
     $krep1_r2nGH_closure:
         const :_con_info;
         const $krep_r2nGG_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.693341373 UTC

[section ""data" . $krep2_r2nGI_closure" {
     $krep2_r2nGI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWeak#_closure;
         const $krep1_r2nGH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.693897005 UTC

[section ""cstring" . GHC.Weak.$tcWeak2_bytes" {
     GHC.Weak.$tcWeak2_bytes:
         I8[] [87,101,97,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.694424259 UTC

[section ""data" . GHC.Weak.$tcWeak1_closure" {
     GHC.Weak.$tcWeak1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$tcWeak2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.695016501 UTC

[section ""data" . GHC.Weak.$tcWeak_closure" {
     GHC.Weak.$tcWeak_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Weak.$trModule_closure+1;
         const GHC.Weak.$tcWeak1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 16083706323098193819;
         const 16670279643231176950;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.695645374 UTC

[section ""data" . $krep3_r2nGJ_closure" {
     $krep3_r2nGJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Weak.$tcWeak_closure+1;
         const $krep1_r2nGH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.696233517 UTC

[section ""data" . GHC.Weak.$tc'Weak1_closure" {
     GHC.Weak.$tc'Weak1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r2nGI_closure+1;
         const $krep3_r2nGJ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.696833698 UTC

[section ""cstring" . GHC.Weak.$tc'Weak3_bytes" {
     GHC.Weak.$tc'Weak3_bytes:
         I8[] [39,87,101,97,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.697425374 UTC

[section ""data" . GHC.Weak.$tc'Weak2_closure" {
     GHC.Weak.$tc'Weak2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$tc'Weak3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.697978792 UTC

[section ""data" . GHC.Weak.$tc'Weak_closure" {
     GHC.Weak.$tc'Weak_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Weak.$trModule_closure+1;
         const GHC.Weak.$tc'Weak2_closure+1;
         const GHC.Weak.$tc'Weak1_closure+4;
         const 3879909390682789585;
         const 9243676412269356154;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.698863244 UTC

[section ""data" . GHC.Weak.Weak_closure" {
     GHC.Weak.Weak_closure:
         const GHC.Weak.Weak_info;
 },
 GHC.Weak.Weak_entry() //  [R2]
         { info_tbl: [(c2nMy,
                       label: GHC.Weak.Weak_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nMy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nMC; else goto c2nMB;
       c2nMC: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Weak.Weak_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2nMB: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.699765974 UTC

[GHC.Weak.Weak_con_entry() //  [R1]
         { info_tbl: [(c2nMD,
                       label: GHC.Weak.Weak_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,101,97,107,46,87,101,97,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nMD: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.700477019 UTC

[section ""relreadonly" . S2nK4_srt" { S2nK4_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.701319745 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:57:07.703054996 UTC

[section ""data" . GHC.Weak.mkWeak1_closure" {
     GHC.Weak.mkWeak1_closure:
         const GHC.Weak.mkWeak1_info;
 },
 GHC.Weak.mkWeak1_entry() //  [R2, R3, R4]
         { info_tbl: [(c2nMQ,
                       label: GHC.Weak.mkWeak1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nMQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2nMR; else goto c2nMS;
       c2nMR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Weak.mkWeak1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2nMS: // global
           I64[Sp - 24] = block_c2nMJ_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2nNb; else goto c2nMK;
       u2nNb: // global
           call _c2nMJ(R1) args: 0, res: 0, upd: 0;
       c2nMK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nMJ() //  [R1]
         { info_tbl: [(c2nMJ,
                       label: block_c2nMJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nMJ: // global
           _s2nGL::P64 = P64[Sp + 8];
           _s2nGM::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c2nMN; else goto c2nMO;
       c2nMN: // global
           I64[Sp + 16] = block_c2nMV_info;
           R2 = _s2nGM::P64;
           R1 = _s2nGL::P64;
           Sp = Sp + 16;
           call stg_mkWeakNoFinalizer#(R2, R1) args: 8, res: 8, upd: 8;
       c2nMO: // global
           I64[Sp + 16] = block_c2nN4_info;
           R3 = P64[R1 + 6];
           R2 = _s2nGM::P64;
           R1 = _s2nGL::P64;
           Sp = Sp + 16;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nMV() //  [R1]
         { info_tbl: [(c2nMV,
                       label: block_c2nMV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nMV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nN1; else goto c2nN0;
       c2nN1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2nN0: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2nN4() //  [R1]
         { info_tbl: [(c2nN4,
                       label: block_c2nN4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nN4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nNa; else goto c2nN9;
       c2nNa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2nN9: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.73435809 UTC

[section ""data" . GHC.Weak.mkWeak_closure" {
     GHC.Weak.mkWeak_closure:
         const GHC.Weak.mkWeak_info;
 },
 GHC.Weak.mkWeak_entry() //  [R2, R3, R4]
         { info_tbl: [(c2nNz,
                       label: GHC.Weak.mkWeak_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nNz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Weak.mkWeak1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.738006493 UTC

[section ""data" . GHC.Weak.deRefWeak1_closure" {
     GHC.Weak.deRefWeak1_closure:
         const GHC.Weak.deRefWeak1_info;
 },
 GHC.Weak.deRefWeak1_entry() //  [R2]
         { info_tbl: [(c2nNN,
                       label: GHC.Weak.deRefWeak1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nNN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2nNO; else goto c2nNP;
       c2nNO: // global
           R2 = R2;
           R1 = GHC.Weak.deRefWeak1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2nNP: // global
           I64[Sp - 8] = block_c2nNK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2nO7; else goto c2nNL;
       u2nO7: // global
           call _c2nNK(R1) args: 0, res: 0, upd: 0;
       c2nNL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nNK() //  [R1]
         { info_tbl: [(c2nNK,
                       label: block_c2nNK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nNK: // global
           I64[Sp] = block_c2nNS_info;
           R1 = P64[R1 + 7];
           call stg_deRefWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nNS() //  [R1, R2]
         { info_tbl: [(c2nNS,
                       label: block_c2nNS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nNS: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c2nNU() args: 0, res: 0, upd: 0;
     }
 },
 _c2nNU() //  []
         { info_tbl: [(c2nNU,
                       label: block_c2nNU_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nNU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nNZ; else goto c2nNY;
       c2nNZ: // global
           HpAlloc = 16;
           I64[Sp] = block_c2nNU_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c2nNY: // global
           if (I64[Sp + 16] == 0) goto c2nO5; else goto c2nO4;
       c2nO5: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2nO4: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.746818678 UTC

[section ""data" . GHC.Weak.deRefWeak_closure" {
     GHC.Weak.deRefWeak_closure:
         const GHC.Weak.deRefWeak_info;
 },
 GHC.Weak.deRefWeak_entry() //  [R2]
         { info_tbl: [(c2nOv,
                       label: GHC.Weak.deRefWeak_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nOv: // global
           R2 = R2;
           call GHC.Weak.deRefWeak1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.750435177 UTC

[section ""data" . GHC.Weak.finalize1_closure" {
     GHC.Weak.finalize1_closure:
         const GHC.Weak.finalize1_info;
 },
 GHC.Weak.finalize1_entry() //  [R2]
         { info_tbl: [(c2nOJ,
                       label: GHC.Weak.finalize1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nOJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2nOK; else goto c2nOL;
       c2nOK: // global
           R2 = R2;
           R1 = GHC.Weak.finalize1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2nOL: // global
           I64[Sp - 8] = block_c2nOG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2nOY; else goto c2nOH;
       u2nOY: // global
           call _c2nOG(R1) args: 0, res: 0, upd: 0;
       c2nOH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nOG() //  [R1]
         { info_tbl: [(c2nOG,
                       label: block_c2nOG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nOG: // global
           I64[Sp] = block_c2nOO_info;
           R1 = P64[R1 + 7];
           call stg_finalizeWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nOO() //  [R1, R2]
         { info_tbl: [(c2nOO,
                       label: block_c2nOO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nOO: // global
           if (R1 == 0) goto c2nOX; else goto c2nOW;
       c2nOX: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2nOW: // global
           R1 = R2;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.75820574 UTC

[section ""data" . GHC.Weak.finalize_closure" {
     GHC.Weak.finalize_closure:
         const GHC.Weak.finalize_info;
 },
 GHC.Weak.finalize_entry() //  [R2]
         { info_tbl: [(c2nPg,
                       label: GHC.Weak.finalize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nPg: // global
           R2 = R2;
           call GHC.Weak.finalize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.761828453 UTC

[section ""data" . GHC.Weak.runFinalizerBatch1_closure" {
     GHC.Weak.runFinalizerBatch1_closure:
         const GHC.Weak.runFinalizerBatch1_info;
 },
 GHC.Weak.runFinalizerBatch1_entry() //  [R2, R3]
         { info_tbl: [(c2nPu,
                       label: GHC.Weak.runFinalizerBatch1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nPu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2nPv; else goto c2nPw;
       c2nPv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Weak.runFinalizerBatch1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2nPw: // global
           I64[Sp - 16] = block_c2nPr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2nPU; else goto c2nPs;
       u2nPU: // global
           call _c2nPr(R1) args: 0, res: 0, upd: 0;
       c2nPs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nPr() //  [R1]
         { info_tbl: [(c2nPr,
                       label: block_c2nPr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nPr: // global
           I64[Sp] = I64[R1 + 7];
           call _c2nPD() args: 0, res: 0, upd: 0;
     }
 },
 _c2nPD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nPD: // global
           _s2nHq::I64 = I64[Sp];
           if (_s2nHq::I64 != 0) goto c2nPN; else goto c2nPQ;
       c2nPN: // global
           _s2nHr::I64 = _s2nHq::I64 - 1;
           _s2nHt::P64 = P64[P64[Sp + 8] + ((_s2nHr::I64 << 3) + 24)];
           I64[Sp - 8] = block_c2nPL_info;
           R1 = _s2nHt::P64;
           I64[Sp] = _s2nHr::I64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       c2nPQ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2nPL() //  []
         { info_tbl: [(c2nPL,
                       label: block_c2nPL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nPL: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c2nPD() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.770394867 UTC

[section ""data" . GHC.Weak.runFinalizerBatch_closure" {
     GHC.Weak.runFinalizerBatch_closure:
         const GHC.Weak.runFinalizerBatch_info;
 },
 GHC.Weak.runFinalizerBatch_entry() //  [R2, R3]
         { info_tbl: [(c2nQi,
                       label: GHC.Weak.runFinalizerBatch_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nQi: // global
           R3 = R3;
           R2 = R2;
           call GHC.Weak.runFinalizerBatch1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.773841542 UTC

[section ""cstring" . GHC.Weak.$trModule4_bytes" {
     GHC.Weak.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.775510378 UTC

[section ""data" . GHC.Weak.$trModule3_closure" {
     GHC.Weak.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.777165122 UTC

[section ""cstring" . GHC.Weak.$trModule2_bytes" {
     GHC.Weak.$trModule2_bytes:
         I8[] [71,72,67,46,87,101,97,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.778846364 UTC

[section ""data" . GHC.Weak.$trModule1_closure" {
     GHC.Weak.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.78051161 UTC

[section ""data" . GHC.Weak.$trModule_closure" {
     GHC.Weak.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Weak.$trModule3_closure+1;
         const GHC.Weak.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.78297412 UTC

[section ""data" . $krep_r2nGG_closure" {
     $krep_r2nGG_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.784681395 UTC

[section ""data" . $krep1_r2nGH_closure" {
     $krep1_r2nGH_closure:
         const :_con_info;
         const $krep_r2nGG_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.786952124 UTC

[section ""data" . $krep2_r2nGI_closure" {
     $krep2_r2nGI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWeak#_closure;
         const $krep1_r2nGH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.788648586 UTC

[section ""cstring" . GHC.Weak.$tcWeak2_bytes" {
     GHC.Weak.$tcWeak2_bytes:
         I8[] [87,101,97,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.79039196 UTC

[section ""data" . GHC.Weak.$tcWeak1_closure" {
     GHC.Weak.$tcWeak1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$tcWeak2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.792070167 UTC

[section ""data" . GHC.Weak.$tcWeak_closure" {
     GHC.Weak.$tcWeak_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Weak.$trModule_closure+1;
         const GHC.Weak.$tcWeak1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 16083706323098193819;
         const 16670279643231176950;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.793923701 UTC

[section ""data" . $krep3_r2nGJ_closure" {
     $krep3_r2nGJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Weak.$tcWeak_closure+1;
         const $krep1_r2nGH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.79560634 UTC

[section ""data" . GHC.Weak.$tc'Weak1_closure" {
     GHC.Weak.$tc'Weak1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r2nGI_closure+1;
         const $krep3_r2nGJ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.797519726 UTC

[section ""cstring" . GHC.Weak.$tc'Weak3_bytes" {
     GHC.Weak.$tc'Weak3_bytes:
         I8[] [39,87,101,97,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.799222304 UTC

[section ""data" . GHC.Weak.$tc'Weak2_closure" {
     GHC.Weak.$tc'Weak2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$tc'Weak3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.800919216 UTC

[section ""data" . GHC.Weak.$tc'Weak_closure" {
     GHC.Weak.$tc'Weak_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Weak.$trModule_closure+1;
         const GHC.Weak.$tc'Weak2_closure+1;
         const GHC.Weak.$tc'Weak1_closure+4;
         const 3879909390682789585;
         const 9243676412269356154;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.80302542 UTC

[section ""data" . GHC.Weak.Weak_closure" {
     GHC.Weak.Weak_closure:
         const GHC.Weak.Weak_info;
 },
 GHC.Weak.Weak_entry() //  [R2]
         { info_tbl: [(c2nQK,
                       label: GHC.Weak.Weak_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nQK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nQO; else goto c2nQN;
       c2nQO: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Weak.Weak_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2nQN: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.806699507 UTC

[GHC.Weak.Weak_con_entry() //  [R1]
         { info_tbl: [(c2nQU,
                       label: GHC.Weak.Weak_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,101,97,107,46,87,101,97,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nQU: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.810412767 UTC

[section ""relreadonly" . S2nK4_srt" { S2nK4_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.929764998 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:57:07.931454268 UTC

[section ""data" . GHC.Weak.mkWeak1_closure" {
     GHC.Weak.mkWeak1_closure:
         const GHC.Weak.mkWeak1_info;
 },
 GHC.Weak.mkWeak1_entry() //  [R2, R3, R4]
         { info_tbl: [(c2nRW,
                       label: GHC.Weak.mkWeak1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nRW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2nRX; else goto c2nRY;
       c2nRX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Weak.mkWeak1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c2nRY: // global
           I64[Sp - 24] = block_c2nRP_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u2nSh; else goto c2nRQ;
       u2nSh: // global
           call _c2nRP(R1) args: 0, res: 0, upd: 0;
       c2nRQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nRP() //  [R1]
         { info_tbl: [(c2nRP,
                       label: block_c2nRP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nRP: // global
           _s2nR1::P64 = P64[Sp + 8];
           _s2nR2::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c2nRT; else goto c2nRU;
       c2nRT: // global
           I64[Sp + 16] = block_c2nS1_info;
           R2 = _s2nR2::P64;
           R1 = _s2nR1::P64;
           Sp = Sp + 16;
           call stg_mkWeakNoFinalizer#(R2, R1) args: 8, res: 8, upd: 8;
       c2nRU: // global
           I64[Sp + 16] = block_c2nSa_info;
           R3 = P64[R1 + 6];
           R2 = _s2nR2::P64;
           R1 = _s2nR1::P64;
           Sp = Sp + 16;
           call stg_mkWeak#(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nS1() //  [R1]
         { info_tbl: [(c2nS1,
                       label: block_c2nS1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nS1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nS7; else goto c2nS6;
       c2nS7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2nS6: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2nSa() //  [R1]
         { info_tbl: [(c2nSa,
                       label: block_c2nSa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nSa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nSg; else goto c2nSf;
       c2nSg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c2nSf: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.941191278 UTC

[section ""data" . GHC.Weak.mkWeak_closure" {
     GHC.Weak.mkWeak_closure:
         const GHC.Weak.mkWeak_info;
 },
 GHC.Weak.mkWeak_entry() //  [R2, R3, R4]
         { info_tbl: [(c2nSK,
                       label: GHC.Weak.mkWeak_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nSK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Weak.mkWeak1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.944919011 UTC

[section ""data" . GHC.Weak.deRefWeak1_closure" {
     GHC.Weak.deRefWeak1_closure:
         const GHC.Weak.deRefWeak1_info;
 },
 GHC.Weak.deRefWeak1_entry() //  [R2]
         { info_tbl: [(c2nSY,
                       label: GHC.Weak.deRefWeak1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nSY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2nSZ; else goto c2nT0;
       c2nSZ: // global
           R2 = R2;
           R1 = GHC.Weak.deRefWeak1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2nT0: // global
           I64[Sp - 8] = block_c2nSV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2nTi; else goto c2nSW;
       u2nTi: // global
           call _c2nSV(R1) args: 0, res: 0, upd: 0;
       c2nSW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nSV() //  [R1]
         { info_tbl: [(c2nSV,
                       label: block_c2nSV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nSV: // global
           I64[Sp] = block_c2nT3_info;
           R1 = P64[R1 + 7];
           call stg_deRefWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nT3() //  [R1, R2]
         { info_tbl: [(c2nT3,
                       label: block_c2nT3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nT3: // global
           P64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _c2nT5() args: 0, res: 0, upd: 0;
     }
 },
 _c2nT5() //  []
         { info_tbl: [(c2nT5,
                       label: block_c2nT5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nT5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nTa; else goto c2nT9;
       c2nTa: // global
           HpAlloc = 16;
           I64[Sp] = block_c2nT5_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c2nT9: // global
           if (I64[Sp + 16] == 0) goto c2nTg; else goto c2nTf;
       c2nTg: // global
           Hp = Hp - 16;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2nTf: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.954066653 UTC

[section ""data" . GHC.Weak.deRefWeak_closure" {
     GHC.Weak.deRefWeak_closure:
         const GHC.Weak.deRefWeak_info;
 },
 GHC.Weak.deRefWeak_entry() //  [R2]
         { info_tbl: [(c2nTL,
                       label: GHC.Weak.deRefWeak_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nTL: // global
           R2 = R2;
           call GHC.Weak.deRefWeak1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.958301075 UTC

[section ""data" . GHC.Weak.finalize1_closure" {
     GHC.Weak.finalize1_closure:
         const GHC.Weak.finalize1_info;
 },
 GHC.Weak.finalize1_entry() //  [R2]
         { info_tbl: [(c2nTZ,
                       label: GHC.Weak.finalize1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nTZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c2nU0; else goto c2nU1;
       c2nU0: // global
           R2 = R2;
           R1 = GHC.Weak.finalize1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2nU1: // global
           I64[Sp - 8] = block_c2nTW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u2nUe; else goto c2nTX;
       u2nUe: // global
           call _c2nTW(R1) args: 0, res: 0, upd: 0;
       c2nTX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nTW() //  [R1]
         { info_tbl: [(c2nTW,
                       label: block_c2nTW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nTW: // global
           I64[Sp] = block_c2nU4_info;
           R1 = P64[R1 + 7];
           call stg_finalizeWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nU4() //  [R1, R2]
         { info_tbl: [(c2nU4,
                       label: block_c2nU4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nU4: // global
           if (R1 == 0) goto c2nUd; else goto c2nUc;
       c2nUd: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c2nUc: // global
           R1 = R2;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.965331449 UTC

[section ""data" . GHC.Weak.finalize_closure" {
     GHC.Weak.finalize_closure:
         const GHC.Weak.finalize_info;
 },
 GHC.Weak.finalize_entry() //  [R2]
         { info_tbl: [(c2nUz,
                       label: GHC.Weak.finalize_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nUz: // global
           R2 = R2;
           call GHC.Weak.finalize1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.96895231 UTC

[section ""data" . GHC.Weak.runFinalizerBatch1_closure" {
     GHC.Weak.runFinalizerBatch1_closure:
         const GHC.Weak.runFinalizerBatch1_info;
 },
 GHC.Weak.runFinalizerBatch1_entry() //  [R2, R3]
         { info_tbl: [(c2nUN,
                       label: GHC.Weak.runFinalizerBatch1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nUN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c2nUO; else goto c2nUP;
       c2nUO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Weak.runFinalizerBatch1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c2nUP: // global
           I64[Sp - 16] = block_c2nUK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u2nVd; else goto c2nUL;
       u2nVd: // global
           call _c2nUK(R1) args: 0, res: 0, upd: 0;
       c2nUL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c2nUK() //  [R1]
         { info_tbl: [(c2nUK,
                       label: block_c2nUK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nUK: // global
           I64[Sp] = I64[R1 + 7];
           call _c2nUW() args: 0, res: 0, upd: 0;
     }
 },
 _c2nUW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nUW: // global
           _s2nRG::I64 = I64[Sp];
           if (_s2nRG::I64 != 0) goto c2nV6; else goto c2nV9;
       c2nV6: // global
           _s2nRH::I64 = _s2nRG::I64 - 1;
           _s2nRJ::P64 = P64[P64[Sp + 8] + ((_s2nRH::I64 << 3) + 24)];
           I64[Sp - 8] = block_c2nV4_info;
           R1 = _s2nRJ::P64;
           I64[Sp] = _s2nRH::I64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       c2nV9: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c2nV4() //  []
         { info_tbl: [(c2nV4,
                       label: block_c2nV4_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nV4: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c2nUW() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.977683531 UTC

[section ""data" . GHC.Weak.runFinalizerBatch_closure" {
     GHC.Weak.runFinalizerBatch_closure:
         const GHC.Weak.runFinalizerBatch_info;
 },
 GHC.Weak.runFinalizerBatch_entry() //  [R2, R3]
         { info_tbl: [(c2nVE,
                       label: GHC.Weak.runFinalizerBatch_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nVE: // global
           R3 = R3;
           R2 = R2;
           call GHC.Weak.runFinalizerBatch1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.980829052 UTC

[section ""cstring" . GHC.Weak.$trModule4_bytes" {
     GHC.Weak.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.982506746 UTC

[section ""data" . GHC.Weak.$trModule3_closure" {
     GHC.Weak.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.984592825 UTC

[section ""cstring" . GHC.Weak.$trModule2_bytes" {
     GHC.Weak.$trModule2_bytes:
         I8[] [71,72,67,46,87,101,97,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.986314825 UTC

[section ""data" . GHC.Weak.$trModule1_closure" {
     GHC.Weak.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.987920684 UTC

[section ""data" . GHC.Weak.$trModule_closure" {
     GHC.Weak.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Weak.$trModule3_closure+1;
         const GHC.Weak.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.989557915 UTC

[section ""data" . $krep_r2nGG_closure" {
     $krep_r2nGG_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.991134791 UTC

[section ""data" . $krep1_r2nGH_closure" {
     $krep1_r2nGH_closure:
         const :_con_info;
         const $krep_r2nGG_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.992800155 UTC

[section ""data" . $krep2_r2nGI_closure" {
     $krep2_r2nGI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcWeak#_closure;
         const $krep1_r2nGH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.994822535 UTC

[section ""cstring" . GHC.Weak.$tcWeak2_bytes" {
     GHC.Weak.$tcWeak2_bytes:
         I8[] [87,101,97,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.996380324 UTC

[section ""data" . GHC.Weak.$tcWeak1_closure" {
     GHC.Weak.$tcWeak1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$tcWeak2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.997974513 UTC

[section ""data" . GHC.Weak.$tcWeak_closure" {
     GHC.Weak.$tcWeak_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Weak.$trModule_closure+1;
         const GHC.Weak.$tcWeak1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 16083706323098193819;
         const 16670279643231176950;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:07.999723259 UTC

[section ""data" . $krep3_r2nGJ_closure" {
     $krep3_r2nGJ_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Weak.$tcWeak_closure+1;
         const $krep1_r2nGH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:08.001326379 UTC

[section ""data" . GHC.Weak.$tc'Weak1_closure" {
     GHC.Weak.$tc'Weak1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r2nGI_closure+1;
         const $krep3_r2nGJ_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:08.002948825 UTC

[section ""cstring" . GHC.Weak.$tc'Weak3_bytes" {
     GHC.Weak.$tc'Weak3_bytes:
         I8[] [39,87,101,97,107]
 }]


==================== Output Cmm ====================
2018-03-16 15:57:08.004472044 UTC

[section ""data" . GHC.Weak.$tc'Weak2_closure" {
     GHC.Weak.$tc'Weak2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Weak.$tc'Weak3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:08.006099994 UTC

[section ""data" . GHC.Weak.$tc'Weak_closure" {
     GHC.Weak.$tc'Weak_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Weak.$trModule_closure+1;
         const GHC.Weak.$tc'Weak2_closure+1;
         const GHC.Weak.$tc'Weak1_closure+4;
         const 3879909390682789585;
         const 9243676412269356154;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:57:08.008571788 UTC

[section ""data" . GHC.Weak.Weak_closure" {
     GHC.Weak.Weak_closure:
         const GHC.Weak.Weak_info;
 },
 GHC.Weak.Weak_entry() //  [R2]
         { info_tbl: [(c2nW6,
                       label: GHC.Weak.Weak_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nW6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c2nWa; else goto c2nW9;
       c2nWa: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Weak.Weak_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c2nW9: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:08.012173318 UTC

[GHC.Weak.Weak_con_entry() //  [R1]
         { info_tbl: [(c2nWh,
                       label: GHC.Weak.Weak_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,87,101,97,107,46,87,101,97,107]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c2nWh: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:57:08.015352454 UTC

[section ""relreadonly" . S2nWo_srt" { S2nWo_srt:
 }]

