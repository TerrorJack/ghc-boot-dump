
==================== Tidy Core ====================
2018-03-16 16:02:47.122998934 UTC

Result size of Tidy Core
  = {terms: 701, types: 1,313, coercions: 452, joins: 0/0}

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$fShowMaskingState6 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.IO.$fShowMaskingState6 = "Unmasked"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$fShowMaskingState5 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.$fShowMaskingState5
  = unpackCString# GHC.IO.$fShowMaskingState6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$fShowMaskingState4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
GHC.IO.$fShowMaskingState4 = "MaskedInterruptible"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$fShowMaskingState3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.$fShowMaskingState3
  = unpackCString# GHC.IO.$fShowMaskingState4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$fShowMaskingState2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
GHC.IO.$fShowMaskingState2 = "MaskedUninterruptible"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$fShowMaskingState1 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.$fShowMaskingState1
  = unpackCString# GHC.IO.$fShowMaskingState2

-- RHS size: {terms: 16, types: 6, coercions: 0, joins: 0/0}
GHC.IO.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: MaskingState -> String -> String
[GblId,
 Arity=2,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [100 0] 120 0}]
GHC.IO.$w$cshowsPrec
  = \ (w_s7DR5 :: MaskingState) (w1_s7DR6 :: String) ->
      case w_s7DR5 of {
        Unmasked -> ++ @ Char GHC.IO.$fShowMaskingState5 w1_s7DR6;
        MaskedInterruptible ->
          ++ @ Char GHC.IO.$fShowMaskingState3 w1_s7DR6;
        MaskedUninterruptible ->
          ++ @ Char GHC.IO.$fShowMaskingState1 w1_s7DR6
      }

-- RHS size: {terms: 6, types: 3, coercions: 0, joins: 0/0}
GHC.IO.$fShowMaskingState_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: Int -> MaskingState -> ShowS
[GblId,
 Arity=3,
 Str=<L,A><S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 (w1_s7DR5 [Occ=Once] :: MaskingState)
                 (w2_s7DR6 [Occ=Once] :: String) ->
                 GHC.IO.$w$cshowsPrec w1_s7DR5 w2_s7DR6}]
GHC.IO.$fShowMaskingState_$cshowsPrec
  = \ _ [Occ=Dead] (w1_s7DR5 :: MaskingState) (w2_s7DR6 :: String) ->
      GHC.IO.$w$cshowsPrec w1_s7DR5 w2_s7DR6

-- RHS size: {terms: 9, types: 2, coercions: 0, joins: 0/0}
GHC.IO.$fShowMaskingState_$cshow :: MaskingState -> String
[GblId,
 Arity=1,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_i7DBD [Occ=Once!] :: MaskingState) ->
                 case x_i7DBD of {
                   Unmasked -> GHC.IO.$fShowMaskingState5;
                   MaskedInterruptible -> GHC.IO.$fShowMaskingState3;
                   MaskedUninterruptible -> GHC.IO.$fShowMaskingState1
                 }}]
GHC.IO.$fShowMaskingState_$cshow
  = \ (x_i7DBD :: MaskingState) ->
      case x_i7DBD of {
        Unmasked -> GHC.IO.$fShowMaskingState5;
        MaskedInterruptible -> GHC.IO.$fShowMaskingState3;
        MaskedUninterruptible -> GHC.IO.$fShowMaskingState1
      }

-- RHS size: {terms: 6, types: 4, coercions: 0, joins: 0/0}
GHC.IO.$fShowMaskingState_$cshowList :: [MaskingState] -> ShowS
[GblId,
 Arity=2,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ls_i7DBG [Occ=Once] :: [MaskingState])
                 (s_i7DBH [Occ=Once] :: String) ->
                 showList__ @ MaskingState GHC.IO.$w$cshowsPrec ls_i7DBG s_i7DBH}]
GHC.IO.$fShowMaskingState_$cshowList
  = \ (ls_i7DBG :: [MaskingState]) (s_i7DBH :: String) ->
      showList__ @ MaskingState GHC.IO.$w$cshowsPrec ls_i7DBG s_i7DBH

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.IO.$fShowMaskingState [InlPrag=NOUSERINLINE CONLIKE]
  :: Show MaskingState
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: MaskingState
                       GHC.IO.$fShowMaskingState_$cshowsPrec
                       GHC.IO.$fShowMaskingState_$cshow
                       GHC.IO.$fShowMaskingState_$cshowList]
GHC.IO.$fShowMaskingState
  = GHC.Show.C:Show
      @ MaskingState
      GHC.IO.$fShowMaskingState_$cshowsPrec
      GHC.IO.$fShowMaskingState_$cshow
      GHC.IO.$fShowMaskingState_$cshowList

-- RHS size: {terms: 25, types: 6, coercions: 0, joins: 0/0}
GHC.IO.$fEqMaskingState_$c==
  :: MaskingState -> MaskingState -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d7DBu [Occ=Once!] :: MaskingState)
                 (ds1_d7DBv [Occ=Once*!] :: MaskingState) ->
                 case ds_d7DBu of {
                   Unmasked ->
                     case ds1_d7DBv of {
                       __DEFAULT -> GHC.Types.False;
                       Unmasked -> GHC.Types.True
                     };
                   MaskedInterruptible ->
                     case ds1_d7DBv of {
                       __DEFAULT -> GHC.Types.False;
                       MaskedInterruptible -> GHC.Types.True
                     };
                   MaskedUninterruptible ->
                     case ds1_d7DBv of {
                       __DEFAULT -> GHC.Types.False;
                       MaskedUninterruptible -> GHC.Types.True
                     }
                 }}]
GHC.IO.$fEqMaskingState_$c==
  = \ (ds_d7DBu :: MaskingState) (ds1_d7DBv :: MaskingState) ->
      case ds_d7DBu of {
        Unmasked ->
          case ds1_d7DBv of {
            __DEFAULT -> GHC.Types.False;
            Unmasked -> GHC.Types.True
          };
        MaskedInterruptible ->
          case ds1_d7DBv of {
            __DEFAULT -> GHC.Types.False;
            MaskedInterruptible -> GHC.Types.True
          };
        MaskedUninterruptible ->
          case ds1_d7DBv of {
            __DEFAULT -> GHC.Types.False;
            MaskedUninterruptible -> GHC.Types.True
          }
      }

-- RHS size: {terms: 25, types: 6, coercions: 0, joins: 0/0}
GHC.IO.$fEqMaskingState_$c/= [InlPrag=INLINE (sat-args=2)]
  :: MaskingState -> MaskingState -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_a22b [Occ=Once!] :: MaskingState)
                 (y_a22c [Occ=Once*!] :: MaskingState) ->
                 case x_a22b of {
                   Unmasked ->
                     case y_a22c of {
                       __DEFAULT -> GHC.Types.True;
                       Unmasked -> GHC.Types.False
                     };
                   MaskedInterruptible ->
                     case y_a22c of {
                       __DEFAULT -> GHC.Types.True;
                       MaskedInterruptible -> GHC.Types.False
                     };
                   MaskedUninterruptible ->
                     case y_a22c of {
                       __DEFAULT -> GHC.Types.True;
                       MaskedUninterruptible -> GHC.Types.False
                     }
                 }}]
GHC.IO.$fEqMaskingState_$c/=
  = \ (eta_B2 :: MaskingState) (eta1_B1 :: MaskingState) ->
      case eta_B2 of {
        Unmasked ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            Unmasked -> GHC.Types.False
          };
        MaskedInterruptible ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            MaskedInterruptible -> GHC.Types.False
          };
        MaskedUninterruptible ->
          case eta1_B1 of {
            __DEFAULT -> GHC.Types.True;
            MaskedUninterruptible -> GHC.Types.False
          }
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.$fEqMaskingState [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq MaskingState
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: MaskingState
                        GHC.IO.$fEqMaskingState_$c==
                        GHC.IO.$fEqMaskingState_$c/=]
GHC.IO.$fEqMaskingState
  = GHC.Classes.C:Eq
      @ MaskingState
      GHC.IO.$fEqMaskingState_$c==
      GHC.IO.$fEqMaskingState_$c/=

-- RHS size: {terms: 10, types: 19, coercions: 2, joins: 0/0}
liftIO :: forall a. IO a -> State# RealWorld -> STret RealWorld a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><S,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a7Dy9)
                 (ds_d7DBk [Occ=Once] :: IO a_a7Dy9)
                 (s_a7Dai [Occ=Once] :: State# RealWorld) ->
                 case (ds_d7DBk
                       `cast` (GHC.Types.N:IO[0] <a_a7Dy9>_R
                               :: (IO a_a7Dy9 :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dy9 #) :: *)))
                        s_a7Dai
                 of
                 { (# ipv_s7DCI [Occ=Once], ipv1_s7DCJ [Occ=Once] #) ->
                 GHC.ST.STret @ RealWorld @ a_a7Dy9 ipv_s7DCI ipv1_s7DCJ
                 }}]
liftIO
  = \ (@ a_a7Dy9)
      (ds_d7DBk :: IO a_a7Dy9)
      (s_a7Dai :: State# RealWorld) ->
      case (ds_d7DBk
            `cast` (GHC.Types.N:IO[0] <a_a7Dy9>_R
                    :: (IO a_a7Dy9 :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dy9 #) :: *)))
             s_a7Dai
      of
      { (# ipv_s7DCI, ipv1_s7DCJ #) ->
      GHC.ST.STret @ RealWorld @ a_a7Dy9 ipv_s7DCI ipv1_s7DCJ
      }

-- RHS size: {terms: 9, types: 8, coercions: 0, joins: 0/0}
GHC.IO.failIO1
  :: forall a.
     String -> State# RealWorld -> (# State# RealWorld, a #)
[GblId, Arity=2, Str=<B,U><B,U>x, Unf=OtherCon []]
GHC.IO.failIO1
  = \ (@ a_a7Dy1) (s_a7Dal :: String) (eta_B1 :: State# RealWorld) ->
      raiseIO#
        @ SomeException
        @ a_a7Dy1
        (toException
           @ IOError
           GHC.IO.Exception.$fxExceptionIOException
           (userError s_a7Dal))
        eta_B1

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
failIO :: forall a. String -> IO a
[GblId,
 Arity=2,
 Str=<B,U><B,U>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.failIO1
               `cast` (forall (a :: <*>_N).
                       <String>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           String -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a. String -> IO a :: *))}]
failIO
  = GHC.IO.failIO1
    `cast` (forall (a :: <*>_N).
            <String>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a.
                String -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a. String -> IO a :: *))

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
GHC.IO.stToIO1 :: forall a. ST RealWorld a -> ST RealWorld a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a7DxY)
                 (ds_d7DBf [Occ=Once] :: ST RealWorld a_a7DxY) ->
                 ds_d7DBf}]
GHC.IO.stToIO1
  = \ (@ a_a7DxY) (ds_d7DBf :: ST RealWorld a_a7DxY) -> ds_d7DBf

-- RHS size: {terms: 1, types: 0, coercions: 14, joins: 0/0}
stToIO :: forall a. ST RealWorld a -> IO a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.stToIO1
               `cast` (forall (a :: <*>_N).
                       <ST RealWorld a>_R
                       ->_R GHC.ST.N:ST[0] <RealWorld>_N <a>_R ; Sym (GHC.Types.N:IO[0]
                                                                          <a>_R)
                       :: (forall a. ST RealWorld a -> ST RealWorld a :: *)
                          ~R# (forall a. ST RealWorld a -> IO a :: *))}]
stToIO
  = GHC.IO.stToIO1
    `cast` (forall (a :: <*>_N).
            <ST RealWorld a>_R
            ->_R GHC.ST.N:ST[0] <RealWorld>_N <a>_R ; Sym (GHC.Types.N:IO[0]
                                                               <a>_R)
            :: (forall a. ST RealWorld a -> ST RealWorld a :: *)
               ~R# (forall a. ST RealWorld a -> IO a :: *))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
GHC.IO.ioToST1 :: forall a. IO a -> IO a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a7DxU) (ds_d7DBb [Occ=Once] :: IO a_a7DxU) ->
                 ds_d7DBb}]
GHC.IO.ioToST1 = \ (@ a_a7DxU) (ds_d7DBb :: IO a_a7DxU) -> ds_d7DBb

-- RHS size: {terms: 1, types: 0, coercions: 13, joins: 0/0}
ioToST :: forall a. IO a -> ST RealWorld a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.ioToST1
               `cast` (forall (a :: <*>_N).
                       <IO a>_R
                       ->_R GHC.Types.N:IO[0] <a>_R ; Sym (GHC.ST.N:ST[0]
                                                               <RealWorld>_N <a>_R)
                       :: (forall a. IO a -> IO a :: *)
                          ~R# (forall a. IO a -> ST RealWorld a :: *))}]
ioToST
  = GHC.IO.ioToST1
    `cast` (forall (a :: <*>_N).
            <IO a>_R
            ->_R GHC.Types.N:IO[0] <a>_R ; Sym (GHC.ST.N:ST[0]
                                                    <RealWorld>_N <a>_R)
            :: (forall a. IO a -> IO a :: *)
               ~R# (forall a. IO a -> ST RealWorld a :: *))

-- RHS size: {terms: 6, types: 8, coercions: 7, joins: 0/0}
GHC.IO.unsafeIOToST1
  :: forall a s. IO a -> State# s -> (# State# RealWorld, a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a7DxF)
                 (@ s_a7DxG)
                 (ds_d7DB6 [Occ=Once] :: IO a_a7DxF)
                 (s1_a7Dap [Occ=Once] :: State# s_a7DxG) ->
                 (ds_d7DB6
                  `cast` (GHC.Types.N:IO[0] <a_a7DxF>_R
                          :: (IO a_a7DxF :: *)
                             ~R# (State# RealWorld -> (# State# RealWorld, a_a7DxF #) :: *)))
                   (s1_a7Dap
                    `cast` ((State# (UnsafeCo nominal s_a7DxG RealWorld))_R
                            :: (State# s_a7DxG :: TYPE ('TupleRep '[]))
                               ~R# (State# RealWorld :: TYPE ('TupleRep '[]))))}]
GHC.IO.unsafeIOToST1
  = \ (@ a_a7DxF)
      (@ s_a7DxG)
      (ds_d7DB6 :: IO a_a7DxF)
      (s1_a7Dap :: State# s_a7DxG) ->
      (ds_d7DB6
       `cast` (GHC.Types.N:IO[0] <a_a7DxF>_R
               :: (IO a_a7DxF :: *)
                  ~R# (State# RealWorld -> (# State# RealWorld, a_a7DxF #) :: *)))
        (s1_a7Dap
         `cast` ((State# (UnsafeCo nominal s_a7DxG RealWorld))_R
                 :: (State# s_a7DxG :: TYPE ('TupleRep '[]))
                    ~R# (State# RealWorld :: TYPE ('TupleRep '[]))))

-- RHS size: {terms: 1, types: 0, coercions: 28, joins: 0/0}
unsafeIOToST :: forall a s. IO a -> ST s a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.unsafeIOToST1
               `cast` (forall (a :: <*>_N) (s :: <*>_N).
                       <IO a>_R
                       ->_R (<State# s>_R
                             ->_R ((#,#)
                                     <'TupleRep '[]>_R
                                     <'LiftedRep>_R
                                     (State# (UnsafeCo nominal RealWorld s))_R
                                     <a>_R)_R) ; Sym (GHC.ST.N:ST[0] <s>_N <a>_R)
                       :: (forall a s. IO a -> State# s -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a s. IO a -> ST s a :: *))}]
unsafeIOToST
  = GHC.IO.unsafeIOToST1
    `cast` (forall (a :: <*>_N) (s :: <*>_N).
            <IO a>_R
            ->_R (<State# s>_R
                  ->_R ((#,#)
                          <'TupleRep '[]>_R
                          <'LiftedRep>_R
                          (State# (UnsafeCo nominal RealWorld s))_R
                          <a>_R)_R) ; Sym (GHC.ST.N:ST[0] <s>_N <a>_R)
            :: (forall a s. IO a -> State# s -> (# State# RealWorld, a #) :: *)
               ~R# (forall a s. IO a -> ST s a :: *))

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
GHC.IO.unsafeSTToIO1 :: forall s a. ST s a -> ST s a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ s_a7Dxt)
                 (@ a_a7Dxu)
                 (ds_d7DB2 [Occ=Once] :: ST s_a7Dxt a_a7Dxu) ->
                 ds_d7DB2}]
GHC.IO.unsafeSTToIO1
  = \ (@ s_a7Dxt) (@ a_a7Dxu) (ds_d7DB2 :: ST s_a7Dxt a_a7Dxu) ->
      ds_d7DB2

-- RHS size: {terms: 1, types: 0, coercions: 20, joins: 0/0}
unsafeSTToIO :: forall s a. ST s a -> IO a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.unsafeSTToIO1
               `cast` (forall (s :: <*>_N) (a :: <*>_N).
                       <ST s a>_R
                       ->_R GHC.ST.N:ST[0]
                                (UnsafeCo nominal s RealWorld) <a>_R ; Sym (GHC.Types.N:IO[0]
                                                                                <a>_R)
                       :: (forall s a. ST s a -> ST s a :: *)
                          ~R# (forall s a. ST s a -> IO a :: *))}]
unsafeSTToIO
  = GHC.IO.unsafeSTToIO1
    `cast` (forall (s :: <*>_N) (a :: <*>_N).
            <ST s a>_R
            ->_R GHC.ST.N:ST[0]
                     (UnsafeCo nominal s RealWorld) <a>_R ; Sym (GHC.Types.N:IO[0]
                                                                     <a>_R)
            :: (forall s a. ST s a -> ST s a :: *)
               ~R# (forall s a. ST s a -> IO a :: *))

-- RHS size: {terms: 20, types: 22, coercions: 4, joins: 0/0}
GHC.IO.catch1
  :: forall e a.
     Exception e =>
     IO a
     -> (e -> IO a) -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U),A)><L,1*C1(U)><L,1*C1(C1(U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ e_a7Dlc)
                 (@ a_a7Dld)
                 ($dException_a7Dlf [Occ=Once] :: Exception e_a7Dlc)
                 (ds_d7DAn [Occ=Once] :: IO a_a7Dld)
                 (handler_a7Dau [Occ=Once!] :: e_a7Dlc -> IO a_a7Dld)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 catch#
                   @ a_a7Dld
                   @ SomeException
                   (ds_d7DAn
                    `cast` (GHC.Types.N:IO[0] <a_a7Dld>_R
                            :: (IO a_a7Dld :: *)
                               ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dld #) :: *)))
                   (\ (e1_a7Daw [OS=OneShot] :: SomeException) ->
                      case fromException @ e_a7Dlc $dException_a7Dlf e1_a7Daw of {
                        Nothing -> raiseIO# @ SomeException @ a_a7Dld e1_a7Daw;
                        Just e'_a7Dax [Occ=Once] ->
                          (handler_a7Dau e'_a7Dax)
                          `cast` (GHC.Types.N:IO[0] <a_a7Dld>_R
                                  :: (IO a_a7Dld :: *)
                                     ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dld #) :: *))
                      })
                   eta_B1}]
GHC.IO.catch1
  = \ (@ e_a7Dlc)
      (@ a_a7Dld)
      ($dException_a7Dlf :: Exception e_a7Dlc)
      (ds_d7DAn :: IO a_a7Dld)
      (handler_a7Dau :: e_a7Dlc -> IO a_a7Dld)
      (eta_B1 :: State# RealWorld) ->
      catch#
        @ a_a7Dld
        @ SomeException
        (ds_d7DAn
         `cast` (GHC.Types.N:IO[0] <a_a7Dld>_R
                 :: (IO a_a7Dld :: *)
                    ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dld #) :: *)))
        (\ (e1_a7Daw [OS=OneShot] :: SomeException) ->
           case fromException @ e_a7Dlc $dException_a7Dlf e1_a7Daw of {
             Nothing -> raiseIO# @ SomeException @ a_a7Dld e1_a7Daw;
             Just e'_a7Dax ->
               (handler_a7Dau e'_a7Dax)
               `cast` (GHC.Types.N:IO[0] <a_a7Dld>_R
                       :: (IO a_a7Dld :: *)
                          ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dld #) :: *))
           })
        eta_B1

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
catch :: forall e a. Exception e => IO a -> (e -> IO a) -> IO a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U),A)><L,1*C1(U)><L,1*C1(C1(U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.catch1
               `cast` (forall (e :: <*>_N) (a :: <*>_N).
                       <Exception e>_R
                       ->_R <IO a>_R
                       ->_R <e -> IO a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall e a.
                           Exception e =>
                           IO a
                           -> (e -> IO a)
                           -> State# RealWorld
                           -> (# State# RealWorld, a #) :: *)
                          ~R# (forall e a.
                               Exception e =>
                               IO a -> (e -> IO a) -> IO a :: *))}]
catch
  = GHC.IO.catch1
    `cast` (forall (e :: <*>_N) (a :: <*>_N).
            <Exception e>_R
            ->_R <IO a>_R
            ->_R <e -> IO a>_R
            ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall e a.
                Exception e =>
                IO a
                -> (e -> IO a)
                -> State# RealWorld
                -> (# State# RealWorld, a #) :: *)
               ~R# (forall e a. Exception e => IO a -> (e -> IO a) -> IO a :: *))

-- RHS size: {terms: 23, types: 32, coercions: 4, joins: 0/0}
GHC.IO.catchException1
  :: forall e a.
     Exception e =>
     IO a
     -> (e -> IO a) -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U),A)><S,1*U><L,1*C1(C1(U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ e_a7Dw6)
                 (@ a_a7Dw7)
                 ($dException_a7Dw9 [Occ=Once] :: Exception e_a7Dw6)
                 (io_a7Dar [Occ=Once] :: IO a_a7Dw7)
                 (handler_a7Das [Occ=Once!] :: e_a7Dw6 -> IO a_a7Dw7)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case io_a7Dar
                      `cast` (GHC.Types.N:IO[0] <a_a7Dw7>_R
                              :: (IO a_a7Dw7 :: *)
                                 ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dw7 #) :: *))
                 of nt_s7DCU
                 { __DEFAULT ->
                 catch#
                   @ a_a7Dw7
                   @ SomeException
                   nt_s7DCU
                   (\ (e1_a7Daw [OS=OneShot] :: SomeException) ->
                      case fromException @ e_a7Dw6 $dException_a7Dw9 e1_a7Daw of {
                        Nothing -> raiseIO# @ SomeException @ a_a7Dw7 e1_a7Daw;
                        Just e'_a7Dax [Occ=Once] ->
                          (handler_a7Das e'_a7Dax)
                          `cast` (GHC.Types.N:IO[0] <a_a7Dw7>_R
                                  :: (IO a_a7Dw7 :: *)
                                     ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dw7 #) :: *))
                      })
                   eta_B1
                 }}]
GHC.IO.catchException1
  = \ (@ e_a7Dw6)
      (@ a_a7Dw7)
      ($dException_a7Dw9 :: Exception e_a7Dw6)
      (io_a7Dar :: IO a_a7Dw7)
      (handler_a7Das :: e_a7Dw6 -> IO a_a7Dw7)
      (eta_B1 :: State# RealWorld) ->
      case io_a7Dar
           `cast` (GHC.Types.N:IO[0] <a_a7Dw7>_R
                   :: (IO a_a7Dw7 :: *)
                      ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dw7 #) :: *))
      of nt_s7DCU
      { __DEFAULT ->
      catch#
        @ a_a7Dw7
        @ SomeException
        nt_s7DCU
        (\ (e1_a7Daw [OS=OneShot] :: SomeException) ->
           case fromException @ e_a7Dw6 $dException_a7Dw9 e1_a7Daw of {
             Nothing -> raiseIO# @ SomeException @ a_a7Dw7 e1_a7Daw;
             Just e'_a7Dax ->
               (handler_a7Das e'_a7Dax)
               `cast` (GHC.Types.N:IO[0] <a_a7Dw7>_R
                       :: (IO a_a7Dw7 :: *)
                          ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dw7 #) :: *))
           })
        eta_B1
      }

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
catchException
  :: forall e a. Exception e => IO a -> (e -> IO a) -> IO a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,1*C1(U),A)><S,1*U><L,1*C1(C1(U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.catchException1
               `cast` (forall (e :: <*>_N) (a :: <*>_N).
                       <Exception e>_R
                       ->_R <IO a>_R
                       ->_R <e -> IO a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall e a.
                           Exception e =>
                           IO a
                           -> (e -> IO a)
                           -> State# RealWorld
                           -> (# State# RealWorld, a #) :: *)
                          ~R# (forall e a.
                               Exception e =>
                               IO a -> (e -> IO a) -> IO a :: *))}]
catchException
  = GHC.IO.catchException1
    `cast` (forall (e :: <*>_N) (a :: <*>_N).
            <Exception e>_R
            ->_R <IO a>_R
            ->_R <e -> IO a>_R
            ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall e a.
                Exception e =>
                IO a
                -> (e -> IO a)
                -> State# RealWorld
                -> (# State# RealWorld, a #) :: *)
               ~R# (forall e a. Exception e => IO a -> (e -> IO a) -> IO a :: *))

-- RHS size: {terms: 20, types: 27, coercions: 4, joins: 0/0}
GHC.IO.mplusIO1
  :: forall a.
     IO a -> IO a -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=3,
 Str=<S,1*U><L,1*C1(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a7Dwe)
                 (m_a7DaC [Occ=Once] :: IO a_a7Dwe)
                 (n_a7DaD [Occ=Once] :: IO a_a7Dwe)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case m_a7DaC
                      `cast` (GHC.Types.N:IO[0] <a_a7Dwe>_R
                              :: (IO a_a7Dwe :: *)
                                 ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dwe #) :: *))
                 of nt_s7DCU
                 { __DEFAULT ->
                 catch#
                   @ a_a7Dwe
                   @ SomeException
                   nt_s7DCU
                   (\ (e_a7Daw [OS=OneShot] :: SomeException) ->
                      case fromException
                             @ IOError GHC.IO.Exception.$fxExceptionIOException e_a7Daw
                      of {
                        Nothing -> raiseIO# @ SomeException @ a_a7Dwe e_a7Daw;
                        Just _ [Occ=Dead] ->
                          n_a7DaD
                          `cast` (GHC.Types.N:IO[0] <a_a7Dwe>_R
                                  :: (IO a_a7Dwe :: *)
                                     ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dwe #) :: *))
                      })
                   eta_B1
                 }}]
GHC.IO.mplusIO1
  = \ (@ a_a7Dwe)
      (m_a7DaC :: IO a_a7Dwe)
      (n_a7DaD :: IO a_a7Dwe)
      (eta_B1 :: State# RealWorld) ->
      case m_a7DaC
           `cast` (GHC.Types.N:IO[0] <a_a7Dwe>_R
                   :: (IO a_a7Dwe :: *)
                      ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dwe #) :: *))
      of nt_s7DCU
      { __DEFAULT ->
      catch#
        @ a_a7Dwe
        @ SomeException
        nt_s7DCU
        (\ (e_a7Daw [OS=OneShot] :: SomeException) ->
           case fromException
                  @ IOError GHC.IO.Exception.$fxExceptionIOException e_a7Daw
           of {
             Nothing -> raiseIO# @ SomeException @ a_a7Dwe e_a7Daw;
             Just e'_a7Dax ->
               n_a7DaD
               `cast` (GHC.Types.N:IO[0] <a_a7Dwe>_R
                       :: (IO a_a7Dwe :: *)
                          ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dwe #) :: *))
           })
        eta_B1
      }

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
mplusIO :: forall a. IO a -> IO a -> IO a
[GblId,
 Arity=3,
 Str=<S,1*U><L,1*C1(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.mplusIO1
               `cast` (forall (a :: <*>_N).
                       <IO a>_R ->_R <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           IO a -> IO a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a. IO a -> IO a -> IO a :: *))}]
mplusIO
  = GHC.IO.mplusIO1
    `cast` (forall (a :: <*>_N).
            <IO a>_R ->_R <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a.
                IO a -> IO a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a. IO a -> IO a -> IO a :: *))

-- RHS size: {terms: 17, types: 33, coercions: 4, joins: 0/0}
GHC.IO.catchAny1
  :: forall a.
     IO a
     -> (forall e. Exception e => e -> IO a)
     -> State# RealWorld
     -> (# State# RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(C1(C1(U)))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a7DkD)
                 (ds_d7DA6 [Occ=Once] :: IO a_a7DkD)
                 (handler_a7Daz [Occ=Once!]
                    :: forall e. Exception e => e -> IO a_a7DkD)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ds_d7DA6
                      `cast` (GHC.Types.N:IO[0] <a_a7DkD>_R
                              :: (IO a_a7DkD :: *)
                                 ~R# (State# RealWorld -> (# State# RealWorld, a_a7DkD #) :: *))
                 of io_a7Day
                 { __DEFAULT ->
                 catch#
                   @ a_a7DkD
                   @ SomeException
                   io_a7Day
                   (\ (ds1_d7DAa [Occ=Once!, OS=OneShot] :: SomeException) ->
                      case ds1_d7DAa of
                      { SomeException @ e_a7DkL $dException_a7DkM [Occ=Once]
                                      e1_a7DaB [Occ=Once] ->
                      (handler_a7Daz @ e_a7DkL $dException_a7DkM e1_a7DaB)
                      `cast` (GHC.Types.N:IO[0] <a_a7DkD>_R
                              :: (IO a_a7DkD :: *)
                                 ~R# (State# RealWorld -> (# State# RealWorld, a_a7DkD #) :: *))
                      })
                   eta_B1
                 }}]
GHC.IO.catchAny1
  = \ (@ a_a7DkD)
      (ds_d7DA6 :: IO a_a7DkD)
      (handler_a7Daz :: forall e. Exception e => e -> IO a_a7DkD)
      (eta_B1 :: State# RealWorld) ->
      case ds_d7DA6
           `cast` (GHC.Types.N:IO[0] <a_a7DkD>_R
                   :: (IO a_a7DkD :: *)
                      ~R# (State# RealWorld -> (# State# RealWorld, a_a7DkD #) :: *))
      of io_a7Day
      { __DEFAULT ->
      catch#
        @ a_a7DkD
        @ SomeException
        io_a7Day
        (\ (ds1_d7DAa [OS=OneShot] :: SomeException) ->
           case ds1_d7DAa of
           { SomeException @ e_a7DkL $dException_a7DkM e1_a7DaB ->
           (handler_a7Daz @ e_a7DkL $dException_a7DkM e1_a7DaB)
           `cast` (GHC.Types.N:IO[0] <a_a7DkD>_R
                   :: (IO a_a7DkD :: *)
                      ~R# (State# RealWorld -> (# State# RealWorld, a_a7DkD #) :: *))
           })
        eta_B1
      }

-- RHS size: {terms: 1, types: 0, coercions: 17, joins: 0/0}
catchAny
  :: forall a. IO a -> (forall e. Exception e => e -> IO a) -> IO a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(C1(C1(U)))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.catchAny1
               `cast` (forall (a :: <*>_N).
                       <IO a>_R
                       ->_R <forall e. Exception e => e -> IO a>_R
                       ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           IO a
                           -> (forall e. Exception e => e -> IO a)
                           -> State# RealWorld
                           -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a.
                               IO a -> (forall e. Exception e => e -> IO a) -> IO a :: *))}]
catchAny
  = GHC.IO.catchAny1
    `cast` (forall (a :: <*>_N).
            <IO a>_R
            ->_R <forall e. Exception e => e -> IO a>_R
            ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a.
                IO a
                -> (forall e. Exception e => e -> IO a)
                -> State# RealWorld
                -> (# State# RealWorld, a #) :: *)
               ~R# (forall a.
                    IO a -> (forall e. Exception e => e -> IO a) -> IO a :: *))

-- RHS size: {terms: 10, types: 12, coercions: 0, joins: 0/0}
GHC.IO.throwIO1
  :: forall e a.
     Exception e =>
     e -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,1*U(A,A,1*C1(U),A,A)><B,U><B,U>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ e_a7Dkt)
                 (@ a_a7Dku)
                 ($dException_a7Dkw [Occ=Once] :: Exception e_a7Dkt)
                 (e1_a7DaE [Occ=Once] :: e_a7Dkt)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 raiseIO#
                   @ SomeException
                   @ a_a7Dku
                   (toException @ e_a7Dkt $dException_a7Dkw e1_a7DaE)
                   eta_B1}]
GHC.IO.throwIO1
  = \ (@ e_a7Dkt)
      (@ a_a7Dku)
      ($dException_a7Dkw :: Exception e_a7Dkt)
      (e1_a7DaE :: e_a7Dkt)
      (eta_B1 :: State# RealWorld) ->
      raiseIO#
        @ SomeException
        @ a_a7Dku
        (toException @ e_a7Dkt $dException_a7Dkw e1_a7DaE)
        eta_B1

-- RHS size: {terms: 1, types: 0, coercions: 14, joins: 0/0}
throwIO :: forall e a. Exception e => e -> IO a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<B,1*U(A,A,1*C1(U),A,A)><B,U><B,U>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.throwIO1
               `cast` (forall (e :: <*>_N) (a :: <*>_N).
                       <Exception e>_R ->_R <e>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall e a.
                           Exception e =>
                           e -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall e a. Exception e => e -> IO a :: *))}]
throwIO
  = GHC.IO.throwIO1
    `cast` (forall (e :: <*>_N) (a :: <*>_N).
            <Exception e>_R ->_R <e>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall e a.
                Exception e =>
                e -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall e a. Exception e => e -> IO a :: *))

-- RHS size: {terms: 20, types: 38, coercions: 4, joins: 0/0}
GHC.IO.onException1
  :: forall a b.
     IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U(U,A))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a7Dwo)
                 (@ b_a7Dwp)
                 (io_a7DaN [Occ=Once] :: IO a_a7Dwo)
                 (what_a7DaO [Occ=Once] :: IO b_a7Dwp)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case io_a7DaN
                      `cast` (GHC.Types.N:IO[0] <a_a7Dwo>_R
                              :: (IO a_a7Dwo :: *)
                                 ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dwo #) :: *))
                 of nt_s7DCU
                 { __DEFAULT ->
                 catch#
                   @ a_a7Dwo
                   @ SomeException
                   nt_s7DCU
                   (\ (e_a7Daw [Occ=Once, OS=OneShot] :: SomeException)
                      (s_i7DDr [Occ=Once, OS=OneShot] :: State# RealWorld) ->
                      case (what_a7DaO
                            `cast` (GHC.Types.N:IO[0] <b_a7Dwp>_R
                                    :: (IO b_a7Dwp :: *)
                                       ~R# (State# RealWorld
                                            -> (# State# RealWorld, b_a7Dwp #) :: *)))
                             s_i7DDr
                      of
                      { (# ipv_i7DDu [Occ=Once], _ [Occ=Dead] #) ->
                      raiseIO# @ SomeException @ a_a7Dwo e_a7Daw ipv_i7DDu
                      })
                   eta_B1
                 }}]
GHC.IO.onException1
  = \ (@ a_a7Dwo)
      (@ b_a7Dwp)
      (io_a7DaN :: IO a_a7Dwo)
      (what_a7DaO :: IO b_a7Dwp)
      (eta_B1 :: State# RealWorld) ->
      case io_a7DaN
           `cast` (GHC.Types.N:IO[0] <a_a7Dwo>_R
                   :: (IO a_a7Dwo :: *)
                      ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dwo #) :: *))
      of nt_s7DCU
      { __DEFAULT ->
      catch#
        @ a_a7Dwo
        @ SomeException
        nt_s7DCU
        (\ (e_a7Daw [OS=OneShot] :: SomeException)
           (s_i7DDr [OS=OneShot] :: State# RealWorld) ->
           case (what_a7DaO
                 `cast` (GHC.Types.N:IO[0] <b_a7Dwp>_R
                         :: (IO b_a7Dwp :: *)
                            ~R# (State# RealWorld -> (# State# RealWorld, b_a7Dwp #) :: *)))
                  s_i7DDr
           of
           { (# ipv_i7DDu, ipv1_i7DDv #) ->
           raiseIO# @ SomeException @ a_a7Dwo e_a7Daw ipv_i7DDu
           })
        eta_B1
      }

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
onException :: forall a b. IO a -> IO b -> IO a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U(U,A))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.onException1
               `cast` (forall (a :: <*>_N) (b :: <*>_N).
                       <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a b.
                           IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a b. IO a -> IO b -> IO a :: *))}]
onException
  = GHC.IO.onException1
    `cast` (forall (a :: <*>_N) (b :: <*>_N).
            <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a b.
                IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a b. IO a -> IO b -> IO a :: *))

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
unsafeUnmask :: forall a. IO a -> IO a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= unmaskAsyncExceptions#
               `cast` (forall (a :: <*>_N).
                       Sym (GHC.Types.N:IO[0] <a>_R) ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           (State# RealWorld -> (# State# RealWorld, a #))
                           -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a. IO a -> IO a :: *))}]
unsafeUnmask
  = unmaskAsyncExceptions#
    `cast` (forall (a :: <*>_N).
            Sym (GHC.Types.N:IO[0] <a>_R) ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a.
                (State# RealWorld -> (# State# RealWorld, a #))
                -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a. IO a -> IO a :: *))

-- RHS size: {terms: 15, types: 21, coercions: 0, joins: 0/0}
GHC.IO.getMaskingState1
  :: State# RealWorld -> (# State# RealWorld, MaskingState #)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (s_a7DaK [Occ=Once] :: State# RealWorld) ->
                 case getMaskingState# s_a7DaK of
                 { (# ipv_s7DDB [Occ=Once], ipv1_s7DDC [Occ=Once!] #) ->
                 (# ipv_s7DDB,
                    case ipv1_s7DDC of {
                      __DEFAULT -> GHC.IO.MaskedInterruptible;
                      0# -> GHC.IO.Unmasked;
                      1# -> GHC.IO.MaskedUninterruptible
                    } #)
                 }}]
GHC.IO.getMaskingState1
  = \ (s_a7DaK :: State# RealWorld) ->
      case getMaskingState# s_a7DaK of { (# ipv_s7DDB, ipv1_s7DDC #) ->
      (# ipv_s7DDB,
         case ipv1_s7DDC of {
           __DEFAULT -> GHC.IO.MaskedInterruptible;
           0# -> GHC.IO.Unmasked;
           1# -> GHC.IO.MaskedUninterruptible
         } #)
      }

-- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
getMaskingState :: IO MaskingState
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.getMaskingState1
               `cast` (Sym (GHC.Types.N:IO[0] <MaskingState>_R)
                       :: (State# RealWorld -> (# State# RealWorld, MaskingState #) :: *)
                          ~R# (IO MaskingState :: *))}]
getMaskingState
  = GHC.IO.getMaskingState1
    `cast` (Sym (GHC.Types.N:IO[0] <MaskingState>_R)
            :: (State# RealWorld -> (# State# RealWorld, MaskingState #) :: *)
               ~R# (IO MaskingState :: *))

-- RHS size: {terms: 19, types: 19, coercions: 6, joins: 0/0}
GHC.IO.interruptible1
  :: forall a. IO a -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a7Dj8)
                 (act_a7DaH [Occ=Once*] :: IO a_a7Dj8)
                 (s_i7DDr [Occ=Once] :: State# RealWorld) ->
                 case getMaskingState# s_i7DDr of
                 { (# ipv_s7DDB [Occ=Once*], ipv1_s7DDC [Occ=Once!] #) ->
                 case ipv1_s7DDC of {
                   __DEFAULT ->
                     unmaskAsyncExceptions#
                       @ a_a7Dj8
                       (act_a7DaH
                        `cast` (GHC.Types.N:IO[0] <a_a7Dj8>_R
                                :: (IO a_a7Dj8 :: *)
                                   ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dj8 #) :: *)))
                       ipv_s7DDB;
                   0# ->
                     (act_a7DaH
                      `cast` (GHC.Types.N:IO[0] <a_a7Dj8>_R
                              :: (IO a_a7Dj8 :: *)
                                 ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dj8 #) :: *)))
                       ipv_s7DDB;
                   1# ->
                     (act_a7DaH
                      `cast` (GHC.Types.N:IO[0] <a_a7Dj8>_R
                              :: (IO a_a7Dj8 :: *)
                                 ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dj8 #) :: *)))
                       ipv_s7DDB
                 }
                 }}]
GHC.IO.interruptible1
  = \ (@ a_a7Dj8)
      (act_a7DaH :: IO a_a7Dj8)
      (s_i7DDr :: State# RealWorld) ->
      case getMaskingState# s_i7DDr of { (# ipv_s7DDB, ipv1_s7DDC #) ->
      case ipv1_s7DDC of {
        __DEFAULT ->
          unmaskAsyncExceptions#
            @ a_a7Dj8
            (act_a7DaH
             `cast` (GHC.Types.N:IO[0] <a_a7Dj8>_R
                     :: (IO a_a7Dj8 :: *)
                        ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dj8 #) :: *)))
            ipv_s7DDB;
        0# ->
          (act_a7DaH
           `cast` (GHC.Types.N:IO[0] <a_a7Dj8>_R
                   :: (IO a_a7Dj8 :: *)
                      ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dj8 #) :: *)))
            ipv_s7DDB;
        1# ->
          (act_a7DaH
           `cast` (GHC.Types.N:IO[0] <a_a7Dj8>_R
                   :: (IO a_a7Dj8 :: *)
                      ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dj8 #) :: *)))
            ipv_s7DDB
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 9, joins: 0/0}
interruptible :: forall a. IO a -> IO a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.interruptible1
               `cast` (forall (a :: <*>_N).
                       <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           IO a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a. IO a -> IO a :: *))}]
interruptible
  = GHC.IO.interruptible1
    `cast` (forall (a :: <*>_N).
            <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a.
                IO a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a. IO a -> IO a :: *))

-- RHS size: {terms: 22, types: 25, coercions: 36, joins: 0/0}
GHC.IO.mask1
  :: forall b.
     ((forall a. IO a -> IO a) -> IO b)
     -> State# RealWorld -> (# State# RealWorld, b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U(U,U)))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 108 0}]
GHC.IO.mask1
  = \ (@ b_a7DjA)
      (io_a7DaR :: (forall a. IO a -> IO a) -> IO b_a7DjA)
      (s_i7DDr :: State# RealWorld) ->
      case getMaskingState# s_i7DDr of { (# ipv_s7DDB, ipv1_s7DDC #) ->
      case ipv1_s7DDC of {
        __DEFAULT ->
          ((io_a7DaR
              (maskAsyncExceptions#
               `cast` (forall (a :: <*>_N).
                       Sym (GHC.Types.N:IO[0] <a>_R) ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           (State# RealWorld -> (# State# RealWorld, a #))
                           -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a. IO a -> IO a :: *))))
           `cast` (GHC.Types.N:IO[0] <b_a7DjA>_R
                   :: (IO b_a7DjA :: *)
                      ~R# (State# RealWorld -> (# State# RealWorld, b_a7DjA #) :: *)))
            ipv_s7DDB;
        0# ->
          maskAsyncExceptions#
            @ b_a7DjA
            ((io_a7DaR
                (unmaskAsyncExceptions#
                 `cast` (forall (a :: <*>_N).
                         Sym (GHC.Types.N:IO[0] <a>_R) ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                         :: (forall a.
                             (State# RealWorld -> (# State# RealWorld, a #))
                             -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                            ~R# (forall a. IO a -> IO a :: *))))
             `cast` (GHC.Types.N:IO[0] <b_a7DjA>_R
                     :: (IO b_a7DjA :: *)
                        ~R# (State# RealWorld -> (# State# RealWorld, b_a7DjA #) :: *)))
            ipv_s7DDB;
        1# ->
          ((io_a7DaR
              (maskUninterruptible#
               `cast` (forall (a :: <*>_N).
                       Sym (GHC.Types.N:IO[0] <a>_R) ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           (State# RealWorld -> (# State# RealWorld, a #))
                           -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a. IO a -> IO a :: *))))
           `cast` (GHC.Types.N:IO[0] <b_a7DjA>_R
                   :: (IO b_a7DjA :: *)
                      ~R# (State# RealWorld -> (# State# RealWorld, b_a7DjA #) :: *)))
            ipv_s7DDB
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
mask :: forall b. ((forall a. IO a -> IO a) -> IO b) -> IO b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U(U,U)))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.mask1
               `cast` (forall (b :: <*>_N).
                       <(forall a. IO a -> IO a) -> IO b>_R
                       ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                       :: (forall b.
                           ((forall a. IO a -> IO a) -> IO b)
                           -> State# RealWorld -> (# State# RealWorld, b #) :: *)
                          ~R# (forall b. ((forall a. IO a -> IO a) -> IO b) -> IO b :: *))}]
mask
  = GHC.IO.mask1
    `cast` (forall (b :: <*>_N).
            <(forall a. IO a -> IO a) -> IO b>_R
            ->_R Sym (GHC.Types.N:IO[0] <b>_R)
            :: (forall b.
                ((forall a. IO a -> IO a) -> IO b)
                -> State# RealWorld -> (# State# RealWorld, b #) :: *)
               ~R# (forall b. ((forall a. IO a -> IO a) -> IO b) -> IO b :: *))

-- RHS size: {terms: 16, types: 19, coercions: 4, joins: 0/0}
GHC.IO.mask_1
  :: forall a. IO a -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a7DjV)
                 (io_a7DaQ [Occ=Once*] :: IO a_a7DjV)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case getMaskingState# eta_B1 of
                 { (# ipv_s7DDB [Occ=Once*], ipv1_s7DDC [Occ=Once!] #) ->
                 case ipv1_s7DDC of {
                   __DEFAULT ->
                     (io_a7DaQ
                      `cast` (GHC.Types.N:IO[0] <a_a7DjV>_R
                              :: (IO a_a7DjV :: *)
                                 ~R# (State# RealWorld -> (# State# RealWorld, a_a7DjV #) :: *)))
                       ipv_s7DDB;
                   0# ->
                     maskAsyncExceptions#
                       @ a_a7DjV
                       (io_a7DaQ
                        `cast` (GHC.Types.N:IO[0] <a_a7DjV>_R
                                :: (IO a_a7DjV :: *)
                                   ~R# (State# RealWorld -> (# State# RealWorld, a_a7DjV #) :: *)))
                       ipv_s7DDB
                 }
                 }}]
GHC.IO.mask_1
  = \ (@ a_a7DjV)
      (io_a7DaQ :: IO a_a7DjV)
      (eta_B1 :: State# RealWorld) ->
      case getMaskingState# eta_B1 of { (# ipv_s7DDB, ipv1_s7DDC #) ->
      case ipv1_s7DDC of {
        __DEFAULT ->
          (io_a7DaQ
           `cast` (GHC.Types.N:IO[0] <a_a7DjV>_R
                   :: (IO a_a7DjV :: *)
                      ~R# (State# RealWorld -> (# State# RealWorld, a_a7DjV #) :: *)))
            ipv_s7DDB;
        0# ->
          maskAsyncExceptions#
            @ a_a7DjV
            (io_a7DaQ
             `cast` (GHC.Types.N:IO[0] <a_a7DjV>_R
                     :: (IO a_a7DjV :: *)
                        ~R# (State# RealWorld -> (# State# RealWorld, a_a7DjV #) :: *)))
            ipv_s7DDB
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 9, joins: 0/0}
mask_ :: forall a. IO a -> IO a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.mask_1
               `cast` (forall (a :: <*>_N).
                       <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           IO a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a. IO a -> IO a :: *))}]
mask_
  = GHC.IO.mask_1
    `cast` (forall (a :: <*>_N).
            <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a.
                IO a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a. IO a -> IO a :: *))

-- RHS size: {terms: 106, types: 208, coercions: 24, joins: 0/0}
GHC.IO.bracket1
  :: forall a b c.
     IO a
     -> (a -> IO b)
     -> (a -> IO c)
     -> State# RealWorld
     -> (# State# RealWorld, c #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,C(C1(U(U,A)))><L,1*C1(C1(U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [180 60 60 0] 432 60}]
GHC.IO.bracket1
  = \ (@ a_a7DwH)
      (@ b_a7DwI)
      (@ c_a7DwJ)
      (before_a7DaW :: IO a_a7DwH)
      (after_a7DaX :: a_a7DwH -> IO b_a7DwI)
      (thing_a7DaY :: a_a7DwH -> IO c_a7DwJ)
      (eta_B1 :: State# RealWorld) ->
      case getMaskingState# eta_B1 of { (# ipv_s7DDB, ipv1_s7DDC #) ->
      case ipv1_s7DDC of {
        __DEFAULT ->
          case (before_a7DaW
                `cast` (GHC.Types.N:IO[0] <a_a7DwH>_R
                        :: (IO a_a7DwH :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, a_a7DwH #) :: *)))
                 ipv_s7DDB
          of
          { (# ipv2_X7DFB, ipv3_X7DFD #) ->
          case catch#
                 @ c_a7DwJ
                 @ SomeException
                 (maskAsyncExceptions#
                    @ c_a7DwJ
                    ((thing_a7DaY ipv3_X7DFD)
                     `cast` (GHC.Types.N:IO[0] <c_a7DwJ>_R
                             :: (IO c_a7DwJ :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, c_a7DwJ #) :: *))))
                 (\ (e_a7Daw [OS=OneShot] :: SomeException)
                    (s_X7DHJ [OS=OneShot] :: State# RealWorld) ->
                    case ((after_a7DaX ipv3_X7DFD)
                          `cast` (GHC.Types.N:IO[0] <b_a7DwI>_R
                                  :: (IO b_a7DwI :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, b_a7DwI #) :: *)))
                           s_X7DHJ
                    of
                    { (# ipv4_X7DHS, ipv5_X7DHV #) ->
                    raiseIO# @ SomeException @ c_a7DwJ e_a7Daw ipv4_X7DHS
                    })
                 ipv2_X7DFB
          of
          { (# ipv4_X7DFw, ipv5_X7DFy #) ->
          case ((after_a7DaX ipv3_X7DFD)
                `cast` (GHC.Types.N:IO[0] <b_a7DwI>_R
                        :: (IO b_a7DwI :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, b_a7DwI #) :: *)))
                 ipv4_X7DFw
          of
          { (# ipv6_X7DFC, ipv7_X7DFE #) ->
          (# ipv6_X7DFC, ipv5_X7DFy #)
          }
          }
          };
        0# ->
          maskAsyncExceptions#
            @ c_a7DwJ
            (\ (s_X7DFv [OS=OneShot] :: State# RealWorld) ->
               case (before_a7DaW
                     `cast` (GHC.Types.N:IO[0] <a_a7DwH>_R
                             :: (IO a_a7DwH :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, a_a7DwH #) :: *)))
                      s_X7DFv
               of
               { (# ipv2_X7DFB, ipv3_X7DFD #) ->
               case catch#
                      @ c_a7DwJ
                      @ SomeException
                      (unmaskAsyncExceptions#
                         @ c_a7DwJ
                         ((thing_a7DaY ipv3_X7DFD)
                          `cast` (GHC.Types.N:IO[0] <c_a7DwJ>_R
                                  :: (IO c_a7DwJ :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, c_a7DwJ #) :: *))))
                      (\ (e_a7Daw [OS=OneShot] :: SomeException)
                         (s1_X7DHJ [OS=OneShot] :: State# RealWorld) ->
                         case ((after_a7DaX ipv3_X7DFD)
                               `cast` (GHC.Types.N:IO[0] <b_a7DwI>_R
                                       :: (IO b_a7DwI :: *)
                                          ~R# (State# RealWorld
                                               -> (# State# RealWorld, b_a7DwI #) :: *)))
                                s1_X7DHJ
                         of
                         { (# ipv4_X7DHS, ipv5_X7DHV #) ->
                         raiseIO# @ SomeException @ c_a7DwJ e_a7Daw ipv4_X7DHS
                         })
                      ipv2_X7DFB
               of
               { (# ipv4_X7DFw, ipv5_X7DFy #) ->
               case ((after_a7DaX ipv3_X7DFD)
                     `cast` (GHC.Types.N:IO[0] <b_a7DwI>_R
                             :: (IO b_a7DwI :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, b_a7DwI #) :: *)))
                      ipv4_X7DFw
               of
               { (# ipv6_X7DFC, ipv7_X7DFE #) ->
               (# ipv6_X7DFC, ipv5_X7DFy #)
               }
               }
               })
            ipv_s7DDB;
        1# ->
          case (before_a7DaW
                `cast` (GHC.Types.N:IO[0] <a_a7DwH>_R
                        :: (IO a_a7DwH :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, a_a7DwH #) :: *)))
                 ipv_s7DDB
          of
          { (# ipv2_X7DFB, ipv3_X7DFD #) ->
          case catch#
                 @ c_a7DwJ
                 @ SomeException
                 (maskUninterruptible#
                    @ c_a7DwJ
                    ((thing_a7DaY ipv3_X7DFD)
                     `cast` (GHC.Types.N:IO[0] <c_a7DwJ>_R
                             :: (IO c_a7DwJ :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, c_a7DwJ #) :: *))))
                 (\ (e_a7Daw [OS=OneShot] :: SomeException)
                    (s_X7DHJ [OS=OneShot] :: State# RealWorld) ->
                    case ((after_a7DaX ipv3_X7DFD)
                          `cast` (GHC.Types.N:IO[0] <b_a7DwI>_R
                                  :: (IO b_a7DwI :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, b_a7DwI #) :: *)))
                           s_X7DHJ
                    of
                    { (# ipv4_X7DHS, ipv5_X7DHV #) ->
                    raiseIO# @ SomeException @ c_a7DwJ e_a7Daw ipv4_X7DHS
                    })
                 ipv2_X7DFB
          of
          { (# ipv4_X7DFw, ipv5_X7DFy #) ->
          case ((after_a7DaX ipv3_X7DFD)
                `cast` (GHC.Types.N:IO[0] <b_a7DwI>_R
                        :: (IO b_a7DwI :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, b_a7DwI #) :: *)))
                 ipv4_X7DFw
          of
          { (# ipv6_X7DFC, ipv7_X7DFE #) ->
          (# ipv6_X7DFC, ipv5_X7DFy #)
          }
          }
          }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 23, joins: 0/0}
bracket :: forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,C(C1(U(U,A)))><L,1*C1(C1(U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.bracket1
               `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                       <IO a>_R
                       ->_R <a -> IO b>_R
                       ->_R <a -> IO c>_R
                       ->_R Sym (GHC.Types.N:IO[0] <c>_R)
                       :: (forall a b c.
                           IO a
                           -> (a -> IO b)
                           -> (a -> IO c)
                           -> State# RealWorld
                           -> (# State# RealWorld, c #) :: *)
                          ~R# (forall a b c.
                               IO a -> (a -> IO b) -> (a -> IO c) -> IO c :: *))}]
bracket
  = GHC.IO.bracket1
    `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
            <IO a>_R
            ->_R <a -> IO b>_R
            ->_R <a -> IO c>_R
            ->_R Sym (GHC.Types.N:IO[0] <c>_R)
            :: (forall a b c.
                IO a
                -> (a -> IO b)
                -> (a -> IO c)
                -> State# RealWorld
                -> (# State# RealWorld, c #) :: *)
               ~R# (forall a b c.
                    IO a -> (a -> IO b) -> (a -> IO c) -> IO c :: *))

-- RHS size: {terms: 83, types: 169, coercions: 18, joins: 0/0}
GHC.IO.finally1
  :: forall a b.
     IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(S(SL)),C(U(U,A))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 360 0] 252 60}]
GHC.IO.finally1
  = \ (@ a_a7Dx8)
      (@ b_a7Dx9)
      (a1_a7Db2 :: IO a_a7Dx8)
      (sequel_a7Db3 :: IO b_a7Dx9)
      (eta_B1 :: State# RealWorld) ->
      case getMaskingState# eta_B1 of { (# ipv_s7DDB, ipv1_s7DDC #) ->
      case ipv1_s7DDC of {
        __DEFAULT ->
          case catch#
                 @ a_a7Dx8
                 @ SomeException
                 (maskAsyncExceptions#
                    @ a_a7Dx8
                    (a1_a7Db2
                     `cast` (GHC.Types.N:IO[0] <a_a7Dx8>_R
                             :: (IO a_a7Dx8 :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dx8 #) :: *))))
                 (\ (e_a7Daw [OS=OneShot] :: SomeException)
                    (s_X7DFo [OS=OneShot] :: State# RealWorld) ->
                    case (sequel_a7Db3
                          `cast` (GHC.Types.N:IO[0] <b_a7Dx9>_R
                                  :: (IO b_a7Dx9 :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, b_a7Dx9 #) :: *)))
                           s_X7DFo
                    of
                    { (# ipv2_X7DFE, ipv3_X7DFG #) ->
                    raiseIO# @ SomeException @ a_a7Dx8 e_a7Daw ipv2_X7DFE
                    })
                 ipv_s7DDB
          of
          { (# ipv2_X7DFC, ipv3_X7DFE #) ->
          case (sequel_a7Db3
                `cast` (GHC.Types.N:IO[0] <b_a7Dx9>_R
                        :: (IO b_a7Dx9 :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, b_a7Dx9 #) :: *)))
                 ipv2_X7DFC
          of
          { (# ipv4_X7DFv, ipv5_X7DFx #) ->
          (# ipv4_X7DFv, ipv3_X7DFE #)
          }
          };
        0# ->
          maskAsyncExceptions#
            @ a_a7Dx8
            (\ (s_X7DFu [OS=OneShot] :: State# RealWorld) ->
               case catch#
                      @ a_a7Dx8
                      @ SomeException
                      (unmaskAsyncExceptions#
                         @ a_a7Dx8
                         (a1_a7Db2
                          `cast` (GHC.Types.N:IO[0] <a_a7Dx8>_R
                                  :: (IO a_a7Dx8 :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, a_a7Dx8 #) :: *))))
                      (\ (e_a7Daw [OS=OneShot] :: SomeException)
                         (s1_X7DFo [OS=OneShot] :: State# RealWorld) ->
                         case (sequel_a7Db3
                               `cast` (GHC.Types.N:IO[0] <b_a7Dx9>_R
                                       :: (IO b_a7Dx9 :: *)
                                          ~R# (State# RealWorld
                                               -> (# State# RealWorld, b_a7Dx9 #) :: *)))
                                s1_X7DFo
                         of
                         { (# ipv2_X7DFE, ipv3_X7DFG #) ->
                         raiseIO# @ SomeException @ a_a7Dx8 e_a7Daw ipv2_X7DFE
                         })
                      s_X7DFu
               of
               { (# ipv2_X7DFC, ipv3_X7DFE #) ->
               case (sequel_a7Db3
                     `cast` (GHC.Types.N:IO[0] <b_a7Dx9>_R
                             :: (IO b_a7Dx9 :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, b_a7Dx9 #) :: *)))
                      ipv2_X7DFC
               of
               { (# ipv4_X7DFv, ipv5_X7DFx #) ->
               (# ipv4_X7DFv, ipv3_X7DFE #)
               }
               })
            ipv_s7DDB;
        1# ->
          case catch#
                 @ a_a7Dx8
                 @ SomeException
                 (maskUninterruptible#
                    @ a_a7Dx8
                    (a1_a7Db2
                     `cast` (GHC.Types.N:IO[0] <a_a7Dx8>_R
                             :: (IO a_a7Dx8 :: *)
                                ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dx8 #) :: *))))
                 (\ (e_a7Daw [OS=OneShot] :: SomeException)
                    (s_X7DFo [OS=OneShot] :: State# RealWorld) ->
                    case (sequel_a7Db3
                          `cast` (GHC.Types.N:IO[0] <b_a7Dx9>_R
                                  :: (IO b_a7Dx9 :: *)
                                     ~R# (State# RealWorld
                                          -> (# State# RealWorld, b_a7Dx9 #) :: *)))
                           s_X7DFo
                    of
                    { (# ipv2_X7DFE, ipv3_X7DFG #) ->
                    raiseIO# @ SomeException @ a_a7Dx8 e_a7Daw ipv2_X7DFE
                    })
                 ipv_s7DDB
          of
          { (# ipv2_X7DFC, ipv3_X7DFE #) ->
          case (sequel_a7Db3
                `cast` (GHC.Types.N:IO[0] <b_a7Dx9>_R
                        :: (IO b_a7Dx9 :: *)
                           ~R# (State# RealWorld -> (# State# RealWorld, b_a7Dx9 #) :: *)))
                 ipv2_X7DFC
          of
          { (# ipv4_X7DFv, ipv5_X7DFx #) ->
          (# ipv4_X7DFv, ipv3_X7DFE #)
          }
          }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
finally :: forall a b. IO a -> IO b -> IO a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(U)><C(S(SL)),C(U(U,A))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.finally1
               `cast` (forall (a :: <*>_N) (b :: <*>_N).
                       <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a b.
                           IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a b. IO a -> IO b -> IO a :: *))}]
finally
  = GHC.IO.finally1
    `cast` (forall (a :: <*>_N) (b :: <*>_N).
            <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a b.
                IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a b. IO a -> IO b -> IO a :: *))

-- RHS size: {terms: 23, types: 26, coercions: 36, joins: 0/0}
GHC.IO.uninterruptibleMask1
  :: forall b.
     ((forall a. IO a -> IO a) -> IO b)
     -> State# RealWorld -> (# State# RealWorld, b #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U(U,U)))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0] 111 0}]
GHC.IO.uninterruptibleMask1
  = \ (@ b_a7Dk0)
      (io_a7DaU :: (forall a. IO a -> IO a) -> IO b_a7Dk0)
      (s_i7DDr :: State# RealWorld) ->
      case getMaskingState# s_i7DDr of { (# ipv_s7DDB, ipv1_s7DDC #) ->
      case ipv1_s7DDC of {
        __DEFAULT ->
          maskUninterruptible#
            @ b_a7Dk0
            ((io_a7DaU
                (maskAsyncExceptions#
                 `cast` (forall (a :: <*>_N).
                         Sym (GHC.Types.N:IO[0] <a>_R) ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                         :: (forall a.
                             (State# RealWorld -> (# State# RealWorld, a #))
                             -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                            ~R# (forall a. IO a -> IO a :: *))))
             `cast` (GHC.Types.N:IO[0] <b_a7Dk0>_R
                     :: (IO b_a7Dk0 :: *)
                        ~R# (State# RealWorld -> (# State# RealWorld, b_a7Dk0 #) :: *)))
            ipv_s7DDB;
        0# ->
          maskUninterruptible#
            @ b_a7Dk0
            ((io_a7DaU
                (unmaskAsyncExceptions#
                 `cast` (forall (a :: <*>_N).
                         Sym (GHC.Types.N:IO[0] <a>_R) ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                         :: (forall a.
                             (State# RealWorld -> (# State# RealWorld, a #))
                             -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                            ~R# (forall a. IO a -> IO a :: *))))
             `cast` (GHC.Types.N:IO[0] <b_a7Dk0>_R
                     :: (IO b_a7Dk0 :: *)
                        ~R# (State# RealWorld -> (# State# RealWorld, b_a7Dk0 #) :: *)))
            ipv_s7DDB;
        1# ->
          ((io_a7DaU
              (maskUninterruptible#
               `cast` (forall (a :: <*>_N).
                       Sym (GHC.Types.N:IO[0] <a>_R) ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           (State# RealWorld -> (# State# RealWorld, a #))
                           -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a. IO a -> IO a :: *))))
           `cast` (GHC.Types.N:IO[0] <b_a7Dk0>_R
                   :: (IO b_a7Dk0 :: *)
                      ~R# (State# RealWorld -> (# State# RealWorld, b_a7Dk0 #) :: *)))
            ipv_s7DDB
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
uninterruptibleMask
  :: forall b. ((forall a. IO a -> IO a) -> IO b) -> IO b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U(U,U)))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.uninterruptibleMask1
               `cast` (forall (b :: <*>_N).
                       <(forall a. IO a -> IO a) -> IO b>_R
                       ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                       :: (forall b.
                           ((forall a. IO a -> IO a) -> IO b)
                           -> State# RealWorld -> (# State# RealWorld, b #) :: *)
                          ~R# (forall b. ((forall a. IO a -> IO a) -> IO b) -> IO b :: *))}]
uninterruptibleMask
  = GHC.IO.uninterruptibleMask1
    `cast` (forall (b :: <*>_N).
            <(forall a. IO a -> IO a) -> IO b>_R
            ->_R Sym (GHC.Types.N:IO[0] <b>_R)
            :: (forall b.
                ((forall a. IO a -> IO a) -> IO b)
                -> State# RealWorld -> (# State# RealWorld, b #) :: *)
               ~R# (forall b. ((forall a. IO a -> IO a) -> IO b) -> IO b :: *))

-- RHS size: {terms: 16, types: 19, coercions: 4, joins: 0/0}
GHC.IO.uninterruptibleMask_1
  :: forall a. IO a -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a7Dko)
                 (io_a7DaT [Occ=Once*] :: IO a_a7Dko)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case getMaskingState# eta_B1 of
                 { (# ipv_s7DDB [Occ=Once*], ipv1_s7DDC [Occ=Once!] #) ->
                 case ipv1_s7DDC of {
                   __DEFAULT ->
                     maskUninterruptible#
                       @ a_a7Dko
                       (io_a7DaT
                        `cast` (GHC.Types.N:IO[0] <a_a7Dko>_R
                                :: (IO a_a7Dko :: *)
                                   ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dko #) :: *)))
                       ipv_s7DDB;
                   1# ->
                     (io_a7DaT
                      `cast` (GHC.Types.N:IO[0] <a_a7Dko>_R
                              :: (IO a_a7Dko :: *)
                                 ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dko #) :: *)))
                       ipv_s7DDB
                 }
                 }}]
GHC.IO.uninterruptibleMask_1
  = \ (@ a_a7Dko)
      (io_a7DaT :: IO a_a7Dko)
      (eta_B1 :: State# RealWorld) ->
      case getMaskingState# eta_B1 of { (# ipv_s7DDB, ipv1_s7DDC #) ->
      case ipv1_s7DDC of {
        __DEFAULT ->
          maskUninterruptible#
            @ a_a7Dko
            (io_a7DaT
             `cast` (GHC.Types.N:IO[0] <a_a7Dko>_R
                     :: (IO a_a7Dko :: *)
                        ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dko #) :: *)))
            ipv_s7DDB;
        1# ->
          (io_a7DaT
           `cast` (GHC.Types.N:IO[0] <a_a7Dko>_R
                   :: (IO a_a7Dko :: *)
                      ~R# (State# RealWorld -> (# State# RealWorld, a_a7Dko #) :: *)))
            ipv_s7DDB
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 9, joins: 0/0}
uninterruptibleMask_ :: forall a. IO a -> IO a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.uninterruptibleMask_1
               `cast` (forall (a :: <*>_N).
                       <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           IO a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a. IO a -> IO a :: *))}]
uninterruptibleMask_
  = GHC.IO.uninterruptibleMask_1
    `cast` (forall (a :: <*>_N).
            <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a.
                IO a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a. IO a -> IO a :: *))

-- RHS size: {terms: 6, types: 7, coercions: 0, joins: 0/0}
GHC.IO.evaluate1
  :: forall a. a -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a7DiD)
                 (a1_a7Db6 [Occ=Once] :: a_a7DiD)
                 (s_a7Db7 [Occ=Once] :: State# RealWorld) ->
                 seq# @ a_a7DiD @ RealWorld a1_a7Db6 s_a7Db7}]
GHC.IO.evaluate1
  = \ (@ a_a7DiD)
      (a1_a7Db6 :: a_a7DiD)
      (s_a7Db7 :: State# RealWorld) ->
      seq# @ a_a7DiD @ RealWorld a1_a7Db6 s_a7Db7

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
evaluate :: forall a. a -> IO a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.IO.evaluate1
               `cast` (forall (a :: <*>_N).
                       <a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a. a -> IO a :: *))}]
evaluate
  = GHC.IO.evaluate1
    `cast` (forall (a :: <*>_N).
            <a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a.
                a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a. a -> IO a :: *))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.IO.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.$trModule3 = GHC.Types.TrNameS GHC.IO.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.IO.$trModule2 = "GHC.IO"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.$trModule1 = GHC.Types.TrNameS GHC.IO.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.IO.$trModule
  = GHC.Types.Module GHC.IO.$trModule3 GHC.IO.$trModule1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$tcMaskingState2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.$tcMaskingState2 = "MaskingState"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$tcMaskingState1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.$tcMaskingState1 = GHC.Types.TrNameS GHC.IO.$tcMaskingState2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$tcMaskingState :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.$tcMaskingState
  = GHC.Types.TyCon
      1377527551354837803##
      7593236071496752895##
      GHC.IO.$trModule
      GHC.IO.$tcMaskingState1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.IO.$tc'MaskedInterruptible1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
GHC.IO.$tc'MaskedInterruptible1
  = GHC.Types.KindRepTyConApp
      GHC.IO.$tcMaskingState (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$tc'Unmasked2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.IO.$tc'Unmasked2 = "'Unmasked"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$tc'Unmasked1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.$tc'Unmasked1 = GHC.Types.TrNameS GHC.IO.$tc'Unmasked2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$tc'Unmasked :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.$tc'Unmasked
  = GHC.Types.TyCon
      16923189221218057084##
      12178290748160137861##
      GHC.IO.$trModule
      GHC.IO.$tc'Unmasked1
      0#
      GHC.IO.$tc'MaskedInterruptible1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$tc'MaskedInterruptible3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 0}]
GHC.IO.$tc'MaskedInterruptible3 = "'MaskedInterruptible"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$tc'MaskedInterruptible2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.$tc'MaskedInterruptible2
  = GHC.Types.TrNameS GHC.IO.$tc'MaskedInterruptible3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$tc'MaskedInterruptible :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.$tc'MaskedInterruptible
  = GHC.Types.TyCon
      8247192854047081576##
      3389631131447074398##
      GHC.IO.$trModule
      GHC.IO.$tc'MaskedInterruptible2
      0#
      GHC.IO.$tc'MaskedInterruptible1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$tc'MaskedUninterruptible2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 70 0}]
GHC.IO.$tc'MaskedUninterruptible2 = "'MaskedUninterruptible"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$tc'MaskedUninterruptible1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.IO.$tc'MaskedUninterruptible1
  = GHC.Types.TrNameS GHC.IO.$tc'MaskedUninterruptible2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.IO.$tc'MaskedUninterruptible :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.IO.$tc'MaskedUninterruptible
  = GHC.Types.TyCon
      10964471758180118067##
      9988357998868476725##
      GHC.IO.$trModule
      GHC.IO.$tc'MaskedUninterruptible1
      0#
      GHC.IO.$tc'MaskedInterruptible1


