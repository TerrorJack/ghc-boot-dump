
==================== Output Cmm ====================
2018-03-16 15:54:59.668881322 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:54:59.669864417 UTC

[section ""data" . GHC.Num.+_closure" {
     GHC.Num.+_closure:
         const GHC.Num.+_info;
 },
 GHC.Num.+_entry() //  [R2]
         { info_tbl: [(clWX,
                       label: GHC.Num.+_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clWX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto clWY; else goto clWZ;
       clWY: // global
           R2 = R2;
           R1 = GHC.Num.+_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clWZ: // global
           I64[Sp - 8] = block_clWU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ulX3; else goto clWV;
       ulX3: // global
           call _clWU(R1) args: 0, res: 0, upd: 0;
       clWV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clWU() //  [R1]
         { info_tbl: [(clWU,
                       label: block_clWU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clWU: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.67107328 UTC

[section ""data" . GHC.Num.-_closure" {
     GHC.Num.-_closure:
         const GHC.Num.-_info;
 },
 GHC.Num.-_entry() //  [R2]
         { info_tbl: [(clXb,
                       label: GHC.Num.-_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clXb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto clXc; else goto clXd;
       clXc: // global
           R2 = R2;
           R1 = GHC.Num.-_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clXd: // global
           I64[Sp - 8] = block_clX8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ulXh; else goto clX9;
       ulXh: // global
           call _clX8(R1) args: 0, res: 0, upd: 0;
       clX9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clX8() //  [R1]
         { info_tbl: [(clX8,
                       label: block_clX8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clX8: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.672136532 UTC

[section ""data" . GHC.Num.*_closure" {
     GHC.Num.*_closure:
         const GHC.Num.*_info;
 },
 GHC.Num.*_entry() //  [R2]
         { info_tbl: [(clXp,
                       label: GHC.Num.*_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clXp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto clXq; else goto clXr;
       clXq: // global
           R2 = R2;
           R1 = GHC.Num.*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clXr: // global
           I64[Sp - 8] = block_clXm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ulXv; else goto clXn;
       ulXv: // global
           call _clXm(R1) args: 0, res: 0, upd: 0;
       clXn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clXm() //  [R1]
         { info_tbl: [(clXm,
                       label: block_clXm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clXm: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.673320938 UTC

[section ""data" . GHC.Num.negate_closure" {
     GHC.Num.negate_closure:
         const GHC.Num.negate_info;
 },
 GHC.Num.negate_entry() //  [R2]
         { info_tbl: [(clXD,
                       label: GHC.Num.negate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clXD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto clXE; else goto clXF;
       clXE: // global
           R2 = R2;
           R1 = GHC.Num.negate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clXF: // global
           I64[Sp - 8] = block_clXA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ulXJ; else goto clXB;
       ulXJ: // global
           call _clXA(R1) args: 0, res: 0, upd: 0;
       clXB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clXA() //  [R1]
         { info_tbl: [(clXA,
                       label: block_clXA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clXA: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.674861957 UTC

[section ""data" . GHC.Num.abs_closure" {
     GHC.Num.abs_closure:
         const GHC.Num.abs_info;
 },
 GHC.Num.abs_entry() //  [R2]
         { info_tbl: [(clXR,
                       label: GHC.Num.abs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clXR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto clXS; else goto clXT;
       clXS: // global
           R2 = R2;
           R1 = GHC.Num.abs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clXT: // global
           I64[Sp - 8] = block_clXO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ulXX; else goto clXP;
       ulXX: // global
           call _clXO(R1) args: 0, res: 0, upd: 0;
       clXP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clXO() //  [R1]
         { info_tbl: [(clXO,
                       label: block_clXO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clXO: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.676102595 UTC

[section ""data" . GHC.Num.signum_closure" {
     GHC.Num.signum_closure:
         const GHC.Num.signum_info;
 },
 GHC.Num.signum_entry() //  [R2]
         { info_tbl: [(clY5,
                       label: GHC.Num.signum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clY5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto clY6; else goto clY7;
       clY6: // global
           R2 = R2;
           R1 = GHC.Num.signum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clY7: // global
           I64[Sp - 8] = block_clY2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ulYb; else goto clY3;
       ulYb: // global
           call _clY2(R1) args: 0, res: 0, upd: 0;
       clY3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clY2() //  [R1]
         { info_tbl: [(clY2,
                       label: block_clY2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clY2: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.677233868 UTC

[section ""data" . GHC.Num.fromInteger_closure" {
     GHC.Num.fromInteger_closure:
         const GHC.Num.fromInteger_info;
 },
 GHC.Num.fromInteger_entry() //  [R2]
         { info_tbl: [(clYj,
                       label: GHC.Num.fromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clYj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto clYk; else goto clYl;
       clYk: // global
           R2 = R2;
           R1 = GHC.Num.fromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clYl: // global
           I64[Sp - 8] = block_clYg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ulYp; else goto clYh;
       ulYp: // global
           call _clYg(R1) args: 0, res: 0, upd: 0;
       clYh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clYg() //  [R1]
         { info_tbl: [(clYg,
                       label: block_clYg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clYg: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.678460006 UTC

[section ""data" . GHC.Num.$fNumInt_$cfromInteger_closure" {
     GHC.Num.$fNumInt_$cfromInteger_closure:
         const GHC.Num.$fNumInt_$cfromInteger_info;
 },
 GHC.Num.$fNumInt_$cfromInteger_entry() //  [R2]
         { info_tbl: [(clYw,
                       label: GHC.Num.$fNumInt_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clYw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto clYA; else goto clYB;
       clYA: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clYB: // global
           I64[Sp - 8] = block_clYu_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _clYu() //  [R1]
         { info_tbl: [(clYu,
                       label: block_clYu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clYu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto clYE; else goto clYD;
       clYE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       clYD: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.679715793 UTC

[section ""data" . GHC.Num.$fNumInt_$cnegate_closure" {
     GHC.Num.$fNumInt_$cnegate_closure:
         const GHC.Num.$fNumInt_$cnegate_info;
 },
 GHC.Num.$fNumInt_$cnegate_entry() //  [R2]
         { info_tbl: [(clYM,
                       label: GHC.Num.$fNumInt_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clYM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto clYT; else goto clYU;
       clYT: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clYU: // global
           I64[Sp - 8] = block_clYJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ulYY; else goto clYK;
       ulYY: // global
           call _clYJ(R1) args: 0, res: 0, upd: 0;
       clYK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clYJ() //  [R1]
         { info_tbl: [(clYJ,
                       label: block_clYJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clYJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto clYX; else goto clYW;
       clYX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       clYW: // global
           _slVu::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _slVu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.681151134 UTC

[section ""data" . GHC.Num.$fNumInt_$c*_closure" {
     GHC.Num.$fNumInt_$c*_closure:
         const GHC.Num.$fNumInt_$c*_info;
 },
 GHC.Num.$fNumInt_$c*_entry() //  [R2, R3]
         { info_tbl: [(clZ6,
                       label: GHC.Num.$fNumInt_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clZ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clZi; else goto clZj;
       clZi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       clZj: // global
           I64[Sp - 16] = block_clZ3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ulZp; else goto clZ4;
       ulZp: // global
           call _clZ3(R1) args: 0, res: 0, upd: 0;
       clZ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clZ3() //  [R1]
         { info_tbl: [(clZ3,
                       label: block_clZ3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clZ3: // global
           I64[Sp] = block_clZ9_info;
           _slVy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slVy::I64;
           if (R1 & 7 != 0) goto ulZo; else goto clZa;
       ulZo: // global
           call _clZ9(R1) args: 0, res: 0, upd: 0;
       clZa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clZ9() //  [R1]
         { info_tbl: [(clZ9,
                       label: block_clZ9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clZ9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto clZn; else goto clZm;
       clZn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       clZm: // global
           _slVB::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _slVB::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.682772727 UTC

[section ""data" . GHC.Num.$fNumInt_$c-_closure" {
     GHC.Num.$fNumInt_$c-_closure:
         const GHC.Num.$fNumInt_$c-_info;
 },
 GHC.Num.$fNumInt_$c-_entry() //  [R2, R3]
         { info_tbl: [(clZx,
                       label: GHC.Num.$fNumInt_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clZx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clZJ; else goto clZK;
       clZJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       clZK: // global
           I64[Sp - 16] = block_clZu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ulZQ; else goto clZv;
       ulZQ: // global
           call _clZu(R1) args: 0, res: 0, upd: 0;
       clZv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clZu() //  [R1]
         { info_tbl: [(clZu,
                       label: block_clZu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clZu: // global
           I64[Sp] = block_clZA_info;
           _slVF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slVF::I64;
           if (R1 & 7 != 0) goto ulZP; else goto clZB;
       ulZP: // global
           call _clZA(R1) args: 0, res: 0, upd: 0;
       clZB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clZA() //  [R1]
         { info_tbl: [(clZA,
                       label: block_clZA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clZA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto clZO; else goto clZN;
       clZO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       clZN: // global
           _slVI::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _slVI::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.684399225 UTC

[section ""data" . GHC.Num.$fNumInt_$c+_closure" {
     GHC.Num.$fNumInt_$c+_closure:
         const GHC.Num.$fNumInt_$c+_info;
 },
 GHC.Num.$fNumInt_$c+_entry() //  [R2, R3]
         { info_tbl: [(clZY,
                       label: GHC.Num.$fNumInt_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clZY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cm0a; else goto cm0b;
       cm0a: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cm0b: // global
           I64[Sp - 16] = block_clZV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto um0h; else goto clZW;
       um0h: // global
           call _clZV(R1) args: 0, res: 0, upd: 0;
       clZW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _clZV() //  [R1]
         { info_tbl: [(clZV,
                       label: block_clZV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       clZV: // global
           I64[Sp] = block_cm01_info;
           _slVM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slVM::I64;
           if (R1 & 7 != 0) goto um0g; else goto cm02;
       um0g: // global
           call _cm01(R1) args: 0, res: 0, upd: 0;
       cm02: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm01() //  [R1]
         { info_tbl: [(cm01,
                       label: block_cm01_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm01: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm0f; else goto cm0e;
       cm0f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cm0e: // global
           _slVP::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _slVP::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.686182238 UTC

[section ""data" . GHC.Num.$fNumInt_$cabs_closure" {
     GHC.Num.$fNumInt_$cabs_closure:
         const GHC.Num.$fNumInt_$cabs_info;
 },
 GHC.Num.$fNumInt_$cabs_entry() //  [R2]
         { info_tbl: [(cm0p,
                       label: GHC.Num.$fNumInt_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm0p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm0q; else goto cm0r;
       cm0q: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm0r: // global
           I64[Sp - 8] = block_cm0m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um0H; else goto cm0n;
       um0H: // global
           call _cm0m(R1) args: 0, res: 0, upd: 0;
       cm0n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm0m() //  [R1]
         { info_tbl: [(cm0m,
                       label: block_cm0m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm0m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm0w; else goto cm0v;
       cm0w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cm0v: // global
           _slVS::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_slVS::I64, 0)) goto cm0F; else goto cm0G;
       cm0F: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_slVS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cm0G: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.687348937 UTC

[section ""data" . GHC.Num.$fNumInt3_closure" {
     GHC.Num.$fNumInt3_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.687894882 UTC

[section ""data" . GHC.Num.$fNumInt2_closure" {
     GHC.Num.$fNumInt2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.688432954 UTC

[section ""data" . GHC.Num.$fNumInt1_closure" {
     GHC.Num.$fNumInt1_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.689278891 UTC

[section ""data" . GHC.Num.$fNumInt_$csignum_closure" {
     GHC.Num.$fNumInt_$csignum_closure:
         const GHC.Num.$fNumInt_$csignum_info;
 },
 GHC.Num.$fNumInt_$csignum_entry() //  [R2]
         { info_tbl: [(cm0P,
                       label: GHC.Num.$fNumInt_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm0P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm0Q; else goto cm0R;
       cm0Q: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm0R: // global
           I64[Sp - 8] = block_cm0M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um15; else goto cm0N;
       um15: // global
           call _cm0M(R1) args: 0, res: 0, upd: 0;
       cm0N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm0M() //  [R1]
         { info_tbl: [(cm0M,
                       label: block_cm0M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm0M: // global
           _slVX::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_slVX::I64, 0)) goto cm13; else goto cm14;
       cm13: // global
           if (_slVX::I64 == 0) goto cm11; else goto cm10;
       cm11: // global
           R1 = GHC.Num.$fNumInt2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cm10: // global
           R1 = GHC.Num.$fNumInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cm14: // global
           R1 = GHC.Num.$fNumInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.690402322 UTC

[section ""data" . GHC.Num.$fNumInt_closure" {
     GHC.Num.$fNumInt_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Num.$fNumInt_$c+_closure+2;
         const GHC.Num.$fNumInt_$c-_closure+2;
         const GHC.Num.$fNumInt_$c*_closure+2;
         const GHC.Num.$fNumInt_$cnegate_closure+1;
         const GHC.Num.$fNumInt_$cabs_closure+1;
         const GHC.Num.$fNumInt_$csignum_closure+1;
         const GHC.Num.$fNumInt_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.691216748 UTC

[section ""data" . GHC.Num.$fNumWord_$cfromInteger_closure" {
     GHC.Num.$fNumWord_$cfromInteger_closure:
         const GHC.Num.$fNumWord_$cfromInteger_info;
 },
 GHC.Num.$fNumWord_$cfromInteger_entry() //  [R2]
         { info_tbl: [(cm1c,
                       label: GHC.Num.$fNumWord_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm1c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm1g; else goto cm1h;
       cm1g: // global
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm1h: // global
           I64[Sp - 8] = block_cm1a_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cm1a() //  [R1]
         { info_tbl: [(cm1a,
                       label: block_cm1a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm1a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm1k; else goto cm1j;
       cm1k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cm1j: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.692212023 UTC

[section ""data" . GHC.Num.$fNumWord2_closure" {
     GHC.Num.$fNumWord2_closure:
         const GHC.Types.W#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.692760721 UTC

[section ""data" . GHC.Num.$fNumWord1_closure" {
     GHC.Num.$fNumWord1_closure:
         const GHC.Types.W#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.693607024 UTC

[section ""data" . GHC.Num.$fNumWord_$csignum_closure" {
     GHC.Num.$fNumWord_$csignum_closure:
         const GHC.Num.$fNumWord_$csignum_info;
 },
 GHC.Num.$fNumWord_$csignum_entry() //  [R2]
         { info_tbl: [(cm1s,
                       label: GHC.Num.$fNumWord_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm1s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm1t; else goto cm1u;
       cm1t: // global
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm1u: // global
           I64[Sp - 8] = block_cm1p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um1C; else goto cm1q;
       um1C: // global
           call _cm1p(R1) args: 0, res: 0, upd: 0;
       cm1q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm1p() //  [R1]
         { info_tbl: [(cm1p,
                       label: block_cm1p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm1p: // global
           if (I64[R1 + 7] == 0) goto cm1B; else goto cm1A;
       cm1B: // global
           R1 = GHC.Num.$fNumWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cm1A: // global
           R1 = GHC.Num.$fNumWord2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.694735096 UTC

[section ""data" . GHC.Num.$fNumWord_$cabs_closure" {
     GHC.Num.$fNumWord_$cabs_closure:
         const GHC.Num.$fNumWord_$cabs_info;
 },
 GHC.Num.$fNumWord_$cabs_entry() //  [R2]
         { info_tbl: [(cm1H,
                       label: GHC.Num.$fNumWord_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm1H: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.695709905 UTC

[section ""data" . GHC.Num.$fNumWord_$cnegate_closure" {
     GHC.Num.$fNumWord_$cnegate_closure:
         const GHC.Num.$fNumWord_$cnegate_info;
 },
 GHC.Num.$fNumWord_$cnegate_entry() //  [R2]
         { info_tbl: [(cm1R,
                       label: GHC.Num.$fNumWord_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm1R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm24; else goto cm25;
       cm24: // global
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm25: // global
           I64[Sp - 8] = block_cm1O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um29; else goto cm1P;
       um29: // global
           call _cm1O(R1) args: 0, res: 0, upd: 0;
       cm1P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm1O() //  [R1]
         { info_tbl: [(cm1O,
                       label: block_cm1O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm1O: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm28; else goto cm27;
       cm28: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cm27: // global
           _slWc::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _slWc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.697142 UTC

[section ""data" . GHC.Num.$fNumWord_$c*_closure" {
     GHC.Num.$fNumWord_$c*_closure:
         const GHC.Num.$fNumWord_$c*_info;
 },
 GHC.Num.$fNumWord_$c*_entry() //  [R2, R3]
         { info_tbl: [(cm2h,
                       label: GHC.Num.$fNumWord_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm2h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cm2t; else goto cm2u;
       cm2t: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cm2u: // global
           I64[Sp - 16] = block_cm2e_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto um2A; else goto cm2f;
       um2A: // global
           call _cm2e(R1) args: 0, res: 0, upd: 0;
       cm2f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm2e() //  [R1]
         { info_tbl: [(cm2e,
                       label: block_cm2e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm2e: // global
           I64[Sp] = block_cm2k_info;
           _slWg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slWg::I64;
           if (R1 & 7 != 0) goto um2z; else goto cm2l;
       um2z: // global
           call _cm2k(R1) args: 0, res: 0, upd: 0;
       cm2l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm2k() //  [R1]
         { info_tbl: [(cm2k,
                       label: block_cm2k_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm2k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm2y; else goto cm2x;
       cm2y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cm2x: // global
           _slWj::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _slWj::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.698756881 UTC

[section ""data" . GHC.Num.$fNumWord_$c-_closure" {
     GHC.Num.$fNumWord_$c-_closure:
         const GHC.Num.$fNumWord_$c-_info;
 },
 GHC.Num.$fNumWord_$c-_entry() //  [R2, R3]
         { info_tbl: [(cm2I,
                       label: GHC.Num.$fNumWord_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm2I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cm2U; else goto cm2V;
       cm2U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cm2V: // global
           I64[Sp - 16] = block_cm2F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto um31; else goto cm2G;
       um31: // global
           call _cm2F(R1) args: 0, res: 0, upd: 0;
       cm2G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm2F() //  [R1]
         { info_tbl: [(cm2F,
                       label: block_cm2F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm2F: // global
           I64[Sp] = block_cm2L_info;
           _slWn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slWn::I64;
           if (R1 & 7 != 0) goto um30; else goto cm2M;
       um30: // global
           call _cm2L(R1) args: 0, res: 0, upd: 0;
       cm2M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm2L() //  [R1]
         { info_tbl: [(cm2L,
                       label: block_cm2L_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm2L: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm2Z; else goto cm2Y;
       cm2Z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cm2Y: // global
           _slWq::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _slWq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.700371184 UTC

[section ""data" . GHC.Num.$fNumWord_$c+_closure" {
     GHC.Num.$fNumWord_$c+_closure:
         const GHC.Num.$fNumWord_$c+_info;
 },
 GHC.Num.$fNumWord_$c+_entry() //  [R2, R3]
         { info_tbl: [(cm39,
                       label: GHC.Num.$fNumWord_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm39: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cm3l; else goto cm3m;
       cm3l: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cm3m: // global
           I64[Sp - 16] = block_cm36_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto um3s; else goto cm37;
       um3s: // global
           call _cm36(R1) args: 0, res: 0, upd: 0;
       cm37: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm36() //  [R1]
         { info_tbl: [(cm36,
                       label: block_cm36_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm36: // global
           I64[Sp] = block_cm3c_info;
           _slWu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slWu::I64;
           if (R1 & 7 != 0) goto um3r; else goto cm3d;
       um3r: // global
           call _cm3c(R1) args: 0, res: 0, upd: 0;
       cm3d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm3c() //  [R1]
         { info_tbl: [(cm3c,
                       label: block_cm3c_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm3c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm3q; else goto cm3p;
       cm3q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cm3p: // global
           _slWx::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _slWx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.701930646 UTC

[section ""data" . GHC.Num.$fNumWord_closure" {
     GHC.Num.$fNumWord_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Num.$fNumWord_$c+_closure+2;
         const GHC.Num.$fNumWord_$c-_closure+2;
         const GHC.Num.$fNumWord_$c*_closure+2;
         const GHC.Num.$fNumWord_$cnegate_closure+1;
         const GHC.Num.$fNumWord_$cabs_closure+1;
         const GHC.Num.$fNumWord_$csignum_closure+1;
         const GHC.Num.$fNumWord_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.70268055 UTC

[section ""data" . GHC.Num.$fNumInteger_$cfromInteger_closure" {
     GHC.Num.$fNumInteger_$cfromInteger_closure:
         const GHC.Num.$fNumInteger_$cfromInteger_info;
 },
 GHC.Num.$fNumInteger_$cfromInteger_entry() //  [R2]
         { info_tbl: [(cm3x,
                       label: GHC.Num.$fNumInteger_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm3x: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.703392723 UTC

[section ""data" . GHC.Num.$fNumInteger_closure" {
     GHC.Num.$fNumInteger_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Integer.Type.plusInteger_closure+2;
         const GHC.Integer.Type.minusInteger_closure+2;
         const GHC.Integer.Type.timesInteger_closure+2;
         const GHC.Integer.Type.negateInteger_closure+1;
         const GHC.Integer.Type.absInteger_closure+1;
         const GHC.Integer.Type.signumInteger_closure+1;
         const GHC.Num.$fNumInteger_$cfromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.705421107 UTC

[section ""data" . lvl_rlU7_closure" {
     lvl_rlU7_closure:
         const lvl_rlU7_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rlU7_entry() //  [R1]
         { info_tbl: [(cm3G,
                       label: lvl_rlU7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm3G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cm3H; else goto cm3I;
       cm3H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cm3I: // global
           (_cm3D::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cm3D::I64 == 0) goto cm3F; else goto cm3E;
       cm3F: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cm3E: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cm3D::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.706666939 UTC

[section ""data" . GHC.Num.$dmnegate_closure" {
     GHC.Num.$dmnegate_closure:
         const GHC.Num.$dmnegate_info;
         const 0;
 },
 sat_slWI_entry() //  [R1]
         { info_tbl: [(cm3R,
                       label: sat_slWI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm3R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cm3S; else goto cm3T;
       cm3S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cm3T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rlU7_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Num.$dmnegate_entry() //  [R2, R3]
         { info_tbl: [(cm3U,
                       label: GHC.Num.$dmnegate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm3U: // global
           _slWH::P64 = R3;
           _slWG::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cm3V; else goto cm3W;
       cm3W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cm3Y; else goto cm3X;
       cm3Y: // global
           HpAlloc = 24;
           goto cm3V;
       cm3V: // global
           R3 = _slWH::P64;
           R2 = _slWG::P64;
           R1 = GHC.Num.$dmnegate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cm3X: // global
           I64[Hp - 16] = sat_slWI_info;
           P64[Hp] = _slWG::P64;
           R2 = _slWG::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _slWH::P64;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.708179753 UTC

[section ""data" . GHC.Num.$dm-_closure" {
     GHC.Num.$dm-_closure:
         const GHC.Num.$dm-_info;
 },
 sat_slWM_entry() //  [R1]
         { info_tbl: [(cm48,
                       label: sat_slWM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm48: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cm49; else goto cm4a;
       cm49: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cm4a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Num.$dm-_entry() //  [R2, R3, R4]
         { info_tbl: [(cm4b,
                       label: GHC.Num.$dm-_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm4b: // global
           _slWL::P64 = R4;
           _slWK::P64 = R3;
           _slWJ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cm4c; else goto cm4d;
       cm4d: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cm4f; else goto cm4e;
       cm4f: // global
           HpAlloc = 32;
           goto cm4c;
       cm4c: // global
           R4 = _slWL::P64;
           R3 = _slWK::P64;
           R2 = _slWJ::P64;
           R1 = GHC.Num.$dm-_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cm4e: // global
           I64[Hp - 24] = sat_slWM_info;
           P64[Hp - 8] = _slWJ::P64;
           P64[Hp] = _slWL::P64;
           R2 = _slWJ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _slWK::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.709539905 UTC

[section ""data" . GHC.Num.subtract_closure" {
     GHC.Num.subtract_closure:
         const GHC.Num.subtract_info;
 },
 GHC.Num.subtract_entry() //  [R2, R3, R4]
         { info_tbl: [(cm4k,
                       label: GHC.Num.subtract_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm4k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cm4l; else goto cm4m;
       cm4l: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.subtract_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cm4m: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.71035871 UTC

[section ""cstring" . GHC.Num.$trModule4_bytes" {
     GHC.Num.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.710875927 UTC

[section ""data" . GHC.Num.$trModule3_closure" {
     GHC.Num.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.711401951 UTC

[section ""cstring" . GHC.Num.$trModule2_bytes" {
     GHC.Num.$trModule2_bytes:
         I8[] [71,72,67,46,78,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.711943746 UTC

[section ""data" . GHC.Num.$trModule1_closure" {
     GHC.Num.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.71251659 UTC

[section ""data" . GHC.Num.$trModule_closure" {
     GHC.Num.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Num.$trModule3_closure+1;
         const GHC.Num.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.713100787 UTC

[section ""data" . $krep_rlU8_closure" {
     $krep_rlU8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.713706523 UTC

[section ""data" . $krep1_rlU9_closure" {
     $krep1_rlU9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.714281051 UTC

[section ""data" . GHC.Num.$tcNum1_closure" {
     GHC.Num.$tcNum1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep1_rlU9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.714803221 UTC

[section ""data" . $krep2_rlUa_closure" {
     $krep2_rlUa_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.715356226 UTC

[section ""data" . $krep3_rlUb_closure" {
     $krep3_rlUb_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rlUa_closure+2;
         const $krep2_rlUa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.715907241 UTC

[section ""data" . $krep4_rlUc_closure" {
     $krep4_rlUc_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rlUa_closure+2;
         const $krep3_rlUb_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.716435312 UTC

[section ""data" . $krep5_rlUd_closure" {
     $krep5_rlUd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rlU8_closure+1;
         const $krep2_rlUa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.717001721 UTC

[section ""cstring" . GHC.Num.$tcNum3_bytes" {
     GHC.Num.$tcNum3_bytes:
         I8[] [78,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.71761349 UTC

[section ""data" . GHC.Num.$tcNum2_closure" {
     GHC.Num.$tcNum2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$tcNum3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.718179767 UTC

[section ""data" . GHC.Num.$tcNum_closure" {
     GHC.Num.$tcNum_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Num.$trModule_closure+1;
         const GHC.Num.$tcNum2_closure+1;
         const GHC.Num.$tcNum1_closure+4;
         const 4789207468288702218;
         const 12287762746798050066;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.71878272 UTC

[section ""data" . $krep6_rlUe_closure" {
     $krep6_rlUe_closure:
         const :_con_info;
         const $krep2_rlUa_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.719307331 UTC

[section ""data" . $krep7_rlUf_closure" {
     $krep7_rlUf_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Num.$tcNum_closure+1;
         const $krep6_rlUe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.719903638 UTC

[section ""data" . $krep8_rlUg_closure" {
     $krep8_rlUg_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_rlUd_closure+4;
         const $krep7_rlUf_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.720454717 UTC

[section ""data" . $krep9_rlUh_closure" {
     $krep9_rlUh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rlUb_closure+4;
         const $krep8_rlUg_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.721007546 UTC

[section ""data" . $krep10_rlUi_closure" {
     $krep10_rlUi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rlUb_closure+4;
         const $krep9_rlUh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.721604308 UTC

[section ""data" . $krep11_rlUj_closure" {
     $krep11_rlUj_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rlUb_closure+4;
         const $krep10_rlUi_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.722167531 UTC

[section ""data" . $krep12_rlUk_closure" {
     $krep12_rlUk_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rlUc_closure+4;
         const $krep11_rlUj_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.722705118 UTC

[section ""data" . $krep13_rlUl_closure" {
     $krep13_rlUl_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rlUc_closure+4;
         const $krep12_rlUk_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.723318346 UTC

[section ""data" . GHC.Num.$tc'C:Num1_closure" {
     GHC.Num.$tc'C:Num1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rlUc_closure+4;
         const $krep13_rlUl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.723890205 UTC

[section ""cstring" . GHC.Num.$tc'C:Num3_bytes" {
     GHC.Num.$tc'C:Num3_bytes:
         I8[] [39,67,58,78,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.724433378 UTC

[section ""data" . GHC.Num.$tc'C:Num2_closure" {
     GHC.Num.$tc'C:Num2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$tc'C:Num3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.725024333 UTC

[section ""data" . GHC.Num.$tc'C:Num_closure" {
     GHC.Num.$tc'C:Num_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Num.$trModule_closure+1;
         const GHC.Num.$tc'C:Num2_closure+1;
         const GHC.Num.$tc'C:Num1_closure+4;
         const 277567704124416124;
         const 17341550453118006986;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.726105698 UTC

[section ""data" . GHC.Num.C:Num_closure" {
     GHC.Num.C:Num_closure:
         const GHC.Num.C:Num_info;
 },
 GHC.Num.C:Num_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm4o: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Num.C:Num_entry(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2,
                                    R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Num.C:Num_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cm4t,
                       label: GHC.Num.C:Num_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm4t: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cm4x; else goto cm4w;
       cm4x: // global
           HpAlloc = 64;
           R1 = GHC.Num.C:Num_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cm4w: // global
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.727309068 UTC

[GHC.Num.C:Num_con_entry() //  [R1]
         { info_tbl: [(cm4y,
                       label: GHC.Num.C:Num_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,78,117,109,46,67,58,78,117,109]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm4y: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.727922504 UTC

[section ""relreadonly" . Sm3Z_srt" {
     Sm3Z_srt:
         const lvl_rlU7_closure;
         const GHC.Num.$dmnegate_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.728470323 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:54:59.729216855 UTC

[section ""data" . GHC.Num.+_closure" {
     GHC.Num.+_closure:
         const GHC.Num.+_info;
 },
 GHC.Num.+_entry() //  [R2]
         { info_tbl: [(cm4G,
                       label: GHC.Num.+_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm4G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm4H; else goto cm4I;
       cm4H: // global
           R2 = R2;
           R1 = GHC.Num.+_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm4I: // global
           I64[Sp - 8] = block_cm4D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um4M; else goto cm4E;
       um4M: // global
           call _cm4D(R1) args: 0, res: 0, upd: 0;
       cm4E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm4D() //  [R1]
         { info_tbl: [(cm4D,
                       label: block_cm4D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm4D: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.730399584 UTC

[section ""data" . GHC.Num.-_closure" {
     GHC.Num.-_closure:
         const GHC.Num.-_info;
 },
 GHC.Num.-_entry() //  [R2]
         { info_tbl: [(cm4U,
                       label: GHC.Num.-_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm4U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm4V; else goto cm4W;
       cm4V: // global
           R2 = R2;
           R1 = GHC.Num.-_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm4W: // global
           I64[Sp - 8] = block_cm4R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um50; else goto cm4S;
       um50: // global
           call _cm4R(R1) args: 0, res: 0, upd: 0;
       cm4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm4R() //  [R1]
         { info_tbl: [(cm4R,
                       label: block_cm4R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm4R: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.731524268 UTC

[section ""data" . GHC.Num.*_closure" {
     GHC.Num.*_closure:
         const GHC.Num.*_info;
 },
 GHC.Num.*_entry() //  [R2]
         { info_tbl: [(cm58,
                       label: GHC.Num.*_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm58: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm59; else goto cm5a;
       cm59: // global
           R2 = R2;
           R1 = GHC.Num.*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm5a: // global
           I64[Sp - 8] = block_cm55_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um5e; else goto cm56;
       um5e: // global
           call _cm55(R1) args: 0, res: 0, upd: 0;
       cm56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm55() //  [R1]
         { info_tbl: [(cm55,
                       label: block_cm55_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm55: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.732653044 UTC

[section ""data" . GHC.Num.negate_closure" {
     GHC.Num.negate_closure:
         const GHC.Num.negate_info;
 },
 GHC.Num.negate_entry() //  [R2]
         { info_tbl: [(cm5m,
                       label: GHC.Num.negate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm5m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm5n; else goto cm5o;
       cm5n: // global
           R2 = R2;
           R1 = GHC.Num.negate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm5o: // global
           I64[Sp - 8] = block_cm5j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um5s; else goto cm5k;
       um5s: // global
           call _cm5j(R1) args: 0, res: 0, upd: 0;
       cm5k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm5j() //  [R1]
         { info_tbl: [(cm5j,
                       label: block_cm5j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm5j: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.734582954 UTC

[section ""data" . GHC.Num.abs_closure" {
     GHC.Num.abs_closure:
         const GHC.Num.abs_info;
 },
 GHC.Num.abs_entry() //  [R2]
         { info_tbl: [(cm5A,
                       label: GHC.Num.abs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm5A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm5B; else goto cm5C;
       cm5B: // global
           R2 = R2;
           R1 = GHC.Num.abs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm5C: // global
           I64[Sp - 8] = block_cm5x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um5G; else goto cm5y;
       um5G: // global
           call _cm5x(R1) args: 0, res: 0, upd: 0;
       cm5y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm5x() //  [R1]
         { info_tbl: [(cm5x,
                       label: block_cm5x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm5x: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.735736484 UTC

[section ""data" . GHC.Num.signum_closure" {
     GHC.Num.signum_closure:
         const GHC.Num.signum_info;
 },
 GHC.Num.signum_entry() //  [R2]
         { info_tbl: [(cm5O,
                       label: GHC.Num.signum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm5O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm5P; else goto cm5Q;
       cm5P: // global
           R2 = R2;
           R1 = GHC.Num.signum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm5Q: // global
           I64[Sp - 8] = block_cm5L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um5U; else goto cm5M;
       um5U: // global
           call _cm5L(R1) args: 0, res: 0, upd: 0;
       cm5M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm5L() //  [R1]
         { info_tbl: [(cm5L,
                       label: block_cm5L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm5L: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.73687598 UTC

[section ""data" . GHC.Num.fromInteger_closure" {
     GHC.Num.fromInteger_closure:
         const GHC.Num.fromInteger_info;
 },
 GHC.Num.fromInteger_entry() //  [R2]
         { info_tbl: [(cm62,
                       label: GHC.Num.fromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm62: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm63; else goto cm64;
       cm63: // global
           R2 = R2;
           R1 = GHC.Num.fromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm64: // global
           I64[Sp - 8] = block_cm5Z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um68; else goto cm60;
       um68: // global
           call _cm5Z(R1) args: 0, res: 0, upd: 0;
       cm60: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm5Z() //  [R1]
         { info_tbl: [(cm5Z,
                       label: block_cm5Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm5Z: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.7390847 UTC

[section ""data" . GHC.Num.$fNumInt_$cfromInteger_closure" {
     GHC.Num.$fNumInt_$cfromInteger_closure:
         const GHC.Num.$fNumInt_$cfromInteger_info;
 },
 GHC.Num.$fNumInt_$cfromInteger_entry() //  [R2]
         { info_tbl: [(cm6f,
                       label: GHC.Num.$fNumInt_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm6f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm6j; else goto cm6k;
       cm6j: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm6k: // global
           I64[Sp - 8] = block_cm6d_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cm6d() //  [R1]
         { info_tbl: [(cm6d,
                       label: block_cm6d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm6d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm6n; else goto cm6m;
       cm6n: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cm6m: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.740384458 UTC

[section ""data" . GHC.Num.$fNumInt_$cnegate_closure" {
     GHC.Num.$fNumInt_$cnegate_closure:
         const GHC.Num.$fNumInt_$cnegate_info;
 },
 GHC.Num.$fNumInt_$cnegate_entry() //  [R2]
         { info_tbl: [(cm6v,
                       label: GHC.Num.$fNumInt_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm6v: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm6C; else goto cm6D;
       cm6C: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm6D: // global
           I64[Sp - 8] = block_cm6s_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um6H; else goto cm6t;
       um6H: // global
           call _cm6s(R1) args: 0, res: 0, upd: 0;
       cm6t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm6s() //  [R1]
         { info_tbl: [(cm6s,
                       label: block_cm6s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm6s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm6G; else goto cm6F;
       cm6G: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cm6F: // global
           _slVu::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _slVu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.741855187 UTC

[section ""data" . GHC.Num.$fNumInt_$c*_closure" {
     GHC.Num.$fNumInt_$c*_closure:
         const GHC.Num.$fNumInt_$c*_info;
 },
 GHC.Num.$fNumInt_$c*_entry() //  [R2, R3]
         { info_tbl: [(cm6P,
                       label: GHC.Num.$fNumInt_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm6P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cm71; else goto cm72;
       cm71: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cm72: // global
           I64[Sp - 16] = block_cm6M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto um78; else goto cm6N;
       um78: // global
           call _cm6M(R1) args: 0, res: 0, upd: 0;
       cm6N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm6M() //  [R1]
         { info_tbl: [(cm6M,
                       label: block_cm6M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm6M: // global
           I64[Sp] = block_cm6S_info;
           _slVy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slVy::I64;
           if (R1 & 7 != 0) goto um77; else goto cm6T;
       um77: // global
           call _cm6S(R1) args: 0, res: 0, upd: 0;
       cm6T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm6S() //  [R1]
         { info_tbl: [(cm6S,
                       label: block_cm6S_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm6S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm76; else goto cm75;
       cm76: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cm75: // global
           _slVB::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _slVB::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.74349466 UTC

[section ""data" . GHC.Num.$fNumInt_$c-_closure" {
     GHC.Num.$fNumInt_$c-_closure:
         const GHC.Num.$fNumInt_$c-_info;
 },
 GHC.Num.$fNumInt_$c-_entry() //  [R2, R3]
         { info_tbl: [(cm7g,
                       label: GHC.Num.$fNumInt_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm7g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cm7s; else goto cm7t;
       cm7s: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cm7t: // global
           I64[Sp - 16] = block_cm7d_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto um7z; else goto cm7e;
       um7z: // global
           call _cm7d(R1) args: 0, res: 0, upd: 0;
       cm7e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm7d() //  [R1]
         { info_tbl: [(cm7d,
                       label: block_cm7d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm7d: // global
           I64[Sp] = block_cm7j_info;
           _slVF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slVF::I64;
           if (R1 & 7 != 0) goto um7y; else goto cm7k;
       um7y: // global
           call _cm7j(R1) args: 0, res: 0, upd: 0;
       cm7k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm7j() //  [R1]
         { info_tbl: [(cm7j,
                       label: block_cm7j_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm7j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm7x; else goto cm7w;
       cm7x: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cm7w: // global
           _slVI::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _slVI::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.745078919 UTC

[section ""data" . GHC.Num.$fNumInt_$c+_closure" {
     GHC.Num.$fNumInt_$c+_closure:
         const GHC.Num.$fNumInt_$c+_info;
 },
 GHC.Num.$fNumInt_$c+_entry() //  [R2, R3]
         { info_tbl: [(cm7H,
                       label: GHC.Num.$fNumInt_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm7H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cm7T; else goto cm7U;
       cm7T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cm7U: // global
           I64[Sp - 16] = block_cm7E_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto um80; else goto cm7F;
       um80: // global
           call _cm7E(R1) args: 0, res: 0, upd: 0;
       cm7F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm7E() //  [R1]
         { info_tbl: [(cm7E,
                       label: block_cm7E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm7E: // global
           I64[Sp] = block_cm7K_info;
           _slVM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slVM::I64;
           if (R1 & 7 != 0) goto um7Z; else goto cm7L;
       um7Z: // global
           call _cm7K(R1) args: 0, res: 0, upd: 0;
       cm7L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm7K() //  [R1]
         { info_tbl: [(cm7K,
                       label: block_cm7K_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm7K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm7Y; else goto cm7X;
       cm7Y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cm7X: // global
           _slVP::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _slVP::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.747025393 UTC

[section ""data" . GHC.Num.$fNumInt_$cabs_closure" {
     GHC.Num.$fNumInt_$cabs_closure:
         const GHC.Num.$fNumInt_$cabs_info;
 },
 GHC.Num.$fNumInt_$cabs_entry() //  [R2]
         { info_tbl: [(cm88,
                       label: GHC.Num.$fNumInt_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm88: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm89; else goto cm8a;
       cm89: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm8a: // global
           I64[Sp - 8] = block_cm85_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um8q; else goto cm86;
       um8q: // global
           call _cm85(R1) args: 0, res: 0, upd: 0;
       cm86: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm85() //  [R1]
         { info_tbl: [(cm85,
                       label: block_cm85_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm85: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm8f; else goto cm8e;
       cm8f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cm8e: // global
           _slVS::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_slVS::I64, 0)) goto cm8o; else goto cm8p;
       cm8o: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_slVS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cm8p: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.748192945 UTC

[section ""data" . GHC.Num.$fNumInt3_closure" {
     GHC.Num.$fNumInt3_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.748747414 UTC

[section ""data" . GHC.Num.$fNumInt2_closure" {
     GHC.Num.$fNumInt2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.749293215 UTC

[section ""data" . GHC.Num.$fNumInt1_closure" {
     GHC.Num.$fNumInt1_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.75011455 UTC

[section ""data" . GHC.Num.$fNumInt_$csignum_closure" {
     GHC.Num.$fNumInt_$csignum_closure:
         const GHC.Num.$fNumInt_$csignum_info;
 },
 GHC.Num.$fNumInt_$csignum_entry() //  [R2]
         { info_tbl: [(cm8y,
                       label: GHC.Num.$fNumInt_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm8y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm8z; else goto cm8A;
       cm8z: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm8A: // global
           I64[Sp - 8] = block_cm8v_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um8O; else goto cm8w;
       um8O: // global
           call _cm8v(R1) args: 0, res: 0, upd: 0;
       cm8w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm8v() //  [R1]
         { info_tbl: [(cm8v,
                       label: block_cm8v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm8v: // global
           _slVX::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_slVX::I64, 0)) goto cm8M; else goto cm8N;
       cm8M: // global
           if (_slVX::I64 == 0) goto cm8K; else goto cm8J;
       cm8K: // global
           R1 = GHC.Num.$fNumInt2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cm8J: // global
           R1 = GHC.Num.$fNumInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cm8N: // global
           R1 = GHC.Num.$fNumInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.75119858 UTC

[section ""data" . GHC.Num.$fNumInt_closure" {
     GHC.Num.$fNumInt_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Num.$fNumInt_$c+_closure+2;
         const GHC.Num.$fNumInt_$c-_closure+2;
         const GHC.Num.$fNumInt_$c*_closure+2;
         const GHC.Num.$fNumInt_$cnegate_closure+1;
         const GHC.Num.$fNumInt_$cabs_closure+1;
         const GHC.Num.$fNumInt_$csignum_closure+1;
         const GHC.Num.$fNumInt_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.75202164 UTC

[section ""data" . GHC.Num.$fNumWord_$cfromInteger_closure" {
     GHC.Num.$fNumWord_$cfromInteger_closure:
         const GHC.Num.$fNumWord_$cfromInteger_info;
 },
 GHC.Num.$fNumWord_$cfromInteger_entry() //  [R2]
         { info_tbl: [(cm8V,
                       label: GHC.Num.$fNumWord_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm8V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm8Z; else goto cm90;
       cm8Z: // global
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm90: // global
           I64[Sp - 8] = block_cm8T_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cm8T() //  [R1]
         { info_tbl: [(cm8T,
                       label: block_cm8T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm8T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm93; else goto cm92;
       cm93: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cm92: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.752967032 UTC

[section ""data" . GHC.Num.$fNumWord2_closure" {
     GHC.Num.$fNumWord2_closure:
         const GHC.Types.W#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.753689393 UTC

[section ""data" . GHC.Num.$fNumWord1_closure" {
     GHC.Num.$fNumWord1_closure:
         const GHC.Types.W#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.754481185 UTC

[section ""data" . GHC.Num.$fNumWord_$csignum_closure" {
     GHC.Num.$fNumWord_$csignum_closure:
         const GHC.Num.$fNumWord_$csignum_info;
 },
 GHC.Num.$fNumWord_$csignum_entry() //  [R2]
         { info_tbl: [(cm9b,
                       label: GHC.Num.$fNumWord_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm9b: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm9c; else goto cm9d;
       cm9c: // global
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm9d: // global
           I64[Sp - 8] = block_cm98_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um9l; else goto cm99;
       um9l: // global
           call _cm98(R1) args: 0, res: 0, upd: 0;
       cm99: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm98() //  [R1]
         { info_tbl: [(cm98,
                       label: block_cm98_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm98: // global
           if (I64[R1 + 7] == 0) goto cm9k; else goto cm9j;
       cm9k: // global
           R1 = GHC.Num.$fNumWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cm9j: // global
           R1 = GHC.Num.$fNumWord2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.755571363 UTC

[section ""data" . GHC.Num.$fNumWord_$cabs_closure" {
     GHC.Num.$fNumWord_$cabs_closure:
         const GHC.Num.$fNumWord_$cabs_info;
 },
 GHC.Num.$fNumWord_$cabs_entry() //  [R2]
         { info_tbl: [(cm9q,
                       label: GHC.Num.$fNumWord_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm9q: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.756536303 UTC

[section ""data" . GHC.Num.$fNumWord_$cnegate_closure" {
     GHC.Num.$fNumWord_$cnegate_closure:
         const GHC.Num.$fNumWord_$cnegate_info;
 },
 GHC.Num.$fNumWord_$cnegate_entry() //  [R2]
         { info_tbl: [(cm9A,
                       label: GHC.Num.$fNumWord_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm9A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cm9N; else goto cm9O;
       cm9N: // global
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cm9O: // global
           I64[Sp - 8] = block_cm9x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto um9S; else goto cm9y;
       um9S: // global
           call _cm9x(R1) args: 0, res: 0, upd: 0;
       cm9y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm9x() //  [R1]
         { info_tbl: [(cm9x,
                       label: block_cm9x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm9x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cm9R; else goto cm9Q;
       cm9R: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cm9Q: // global
           _slWc::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _slWc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.757982225 UTC

[section ""data" . GHC.Num.$fNumWord_$c*_closure" {
     GHC.Num.$fNumWord_$c*_closure:
         const GHC.Num.$fNumWord_$c*_info;
 },
 GHC.Num.$fNumWord_$c*_entry() //  [R2, R3]
         { info_tbl: [(cma0,
                       label: GHC.Num.$fNumWord_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cma0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmac; else goto cmad;
       cmac: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmad: // global
           I64[Sp - 16] = block_cm9X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umaj; else goto cm9Y;
       umaj: // global
           call _cm9X(R1) args: 0, res: 0, upd: 0;
       cm9Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cm9X() //  [R1]
         { info_tbl: [(cm9X,
                       label: block_cm9X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cm9X: // global
           I64[Sp] = block_cma3_info;
           _slWg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slWg::I64;
           if (R1 & 7 != 0) goto umai; else goto cma4;
       umai: // global
           call _cma3(R1) args: 0, res: 0, upd: 0;
       cma4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cma3() //  [R1]
         { info_tbl: [(cma3,
                       label: block_cma3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cma3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmah; else goto cmag;
       cmah: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmag: // global
           _slWj::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _slWj::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.759592326 UTC

[section ""data" . GHC.Num.$fNumWord_$c-_closure" {
     GHC.Num.$fNumWord_$c-_closure:
         const GHC.Num.$fNumWord_$c-_info;
 },
 GHC.Num.$fNumWord_$c-_entry() //  [R2, R3]
         { info_tbl: [(cmar,
                       label: GHC.Num.$fNumWord_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmar: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmaD; else goto cmaE;
       cmaD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmaE: // global
           I64[Sp - 16] = block_cmao_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umaK; else goto cmap;
       umaK: // global
           call _cmao(R1) args: 0, res: 0, upd: 0;
       cmap: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmao() //  [R1]
         { info_tbl: [(cmao,
                       label: block_cmao_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmao: // global
           I64[Sp] = block_cmau_info;
           _slWn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slWn::I64;
           if (R1 & 7 != 0) goto umaJ; else goto cmav;
       umaJ: // global
           call _cmau(R1) args: 0, res: 0, upd: 0;
       cmav: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmau() //  [R1]
         { info_tbl: [(cmau,
                       label: block_cmau_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmau: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmaI; else goto cmaH;
       cmaI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmaH: // global
           _slWq::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _slWq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.7611975 UTC

[section ""data" . GHC.Num.$fNumWord_$c+_closure" {
     GHC.Num.$fNumWord_$c+_closure:
         const GHC.Num.$fNumWord_$c+_info;
 },
 GHC.Num.$fNumWord_$c+_entry() //  [R2, R3]
         { info_tbl: [(cmaS,
                       label: GHC.Num.$fNumWord_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmaS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmb4; else goto cmb5;
       cmb4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmb5: // global
           I64[Sp - 16] = block_cmaP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umbb; else goto cmaQ;
       umbb: // global
           call _cmaP(R1) args: 0, res: 0, upd: 0;
       cmaQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmaP() //  [R1]
         { info_tbl: [(cmaP,
                       label: block_cmaP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmaP: // global
           I64[Sp] = block_cmaV_info;
           _slWu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slWu::I64;
           if (R1 & 7 != 0) goto umba; else goto cmaW;
       umba: // global
           call _cmaV(R1) args: 0, res: 0, upd: 0;
       cmaW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmaV() //  [R1]
         { info_tbl: [(cmaV,
                       label: block_cmaV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmaV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmb9; else goto cmb8;
       cmb9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmb8: // global
           _slWx::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _slWx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.762452944 UTC

[section ""data" . GHC.Num.$fNumWord_closure" {
     GHC.Num.$fNumWord_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Num.$fNumWord_$c+_closure+2;
         const GHC.Num.$fNumWord_$c-_closure+2;
         const GHC.Num.$fNumWord_$c*_closure+2;
         const GHC.Num.$fNumWord_$cnegate_closure+1;
         const GHC.Num.$fNumWord_$cabs_closure+1;
         const GHC.Num.$fNumWord_$csignum_closure+1;
         const GHC.Num.$fNumWord_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.763188334 UTC

[section ""data" . GHC.Num.$fNumInteger_$cfromInteger_closure" {
     GHC.Num.$fNumInteger_$cfromInteger_closure:
         const GHC.Num.$fNumInteger_$cfromInteger_info;
 },
 GHC.Num.$fNumInteger_$cfromInteger_entry() //  [R2]
         { info_tbl: [(cmbg,
                       label: GHC.Num.$fNumInteger_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmbg: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.763874548 UTC

[section ""data" . GHC.Num.$fNumInteger_closure" {
     GHC.Num.$fNumInteger_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Integer.Type.plusInteger_closure+2;
         const GHC.Integer.Type.minusInteger_closure+2;
         const GHC.Integer.Type.timesInteger_closure+2;
         const GHC.Integer.Type.negateInteger_closure+1;
         const GHC.Integer.Type.absInteger_closure+1;
         const GHC.Integer.Type.signumInteger_closure+1;
         const GHC.Num.$fNumInteger_$cfromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.764663591 UTC

[section ""data" . lvl_rlU7_closure" {
     lvl_rlU7_closure:
         const lvl_rlU7_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rlU7_entry() //  [R1]
         { info_tbl: [(cmbp,
                       label: lvl_rlU7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmbp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmbq; else goto cmbr;
       cmbq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cmbr: // global
           (_cmbm::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cmbm::I64 == 0) goto cmbo; else goto cmbn;
       cmbo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cmbn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cmbm::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.765901754 UTC

[section ""data" . GHC.Num.$dmnegate_closure" {
     GHC.Num.$dmnegate_closure:
         const GHC.Num.$dmnegate_info;
         const 0;
 },
 sat_slWI_entry() //  [R1]
         { info_tbl: [(cmbA,
                       label: sat_slWI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmbA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cmbB; else goto cmbC;
       cmbB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cmbC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rlU7_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Num.$dmnegate_entry() //  [R2, R3]
         { info_tbl: [(cmbD,
                       label: GHC.Num.$dmnegate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmbD: // global
           _slWH::P64 = R3;
           _slWG::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cmbE; else goto cmbF;
       cmbF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cmbH; else goto cmbG;
       cmbH: // global
           HpAlloc = 24;
           goto cmbE;
       cmbE: // global
           R3 = _slWH::P64;
           R2 = _slWG::P64;
           R1 = GHC.Num.$dmnegate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmbG: // global
           I64[Hp - 16] = sat_slWI_info;
           P64[Hp] = _slWG::P64;
           R2 = _slWG::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _slWH::P64;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.76739424 UTC

[section ""data" . GHC.Num.$dm-_closure" {
     GHC.Num.$dm-_closure:
         const GHC.Num.$dm-_info;
 },
 sat_slWM_entry() //  [R1]
         { info_tbl: [(cmbQ,
                       label: sat_slWM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmbQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cmbR; else goto cmbS;
       cmbR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cmbS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Num.$dm-_entry() //  [R2, R3, R4]
         { info_tbl: [(cmbT,
                       label: GHC.Num.$dm-_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmbT: // global
           _slWL::P64 = R4;
           _slWK::P64 = R3;
           _slWJ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cmbU; else goto cmbV;
       cmbV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cmbX; else goto cmbW;
       cmbX: // global
           HpAlloc = 32;
           goto cmbU;
       cmbU: // global
           R4 = _slWL::P64;
           R3 = _slWK::P64;
           R2 = _slWJ::P64;
           R1 = GHC.Num.$dm-_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cmbW: // global
           I64[Hp - 24] = sat_slWM_info;
           P64[Hp - 8] = _slWJ::P64;
           P64[Hp] = _slWL::P64;
           R2 = _slWJ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _slWK::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.768669421 UTC

[section ""data" . GHC.Num.subtract_closure" {
     GHC.Num.subtract_closure:
         const GHC.Num.subtract_info;
 },
 GHC.Num.subtract_entry() //  [R2, R3, R4]
         { info_tbl: [(cmc2,
                       label: GHC.Num.subtract_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmc2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cmc3; else goto cmc4;
       cmc3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.subtract_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cmc4: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.769756756 UTC

[section ""cstring" . GHC.Num.$trModule4_bytes" {
     GHC.Num.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.77027685 UTC

[section ""data" . GHC.Num.$trModule3_closure" {
     GHC.Num.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.770803199 UTC

[section ""cstring" . GHC.Num.$trModule2_bytes" {
     GHC.Num.$trModule2_bytes:
         I8[] [71,72,67,46,78,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.771346189 UTC

[section ""data" . GHC.Num.$trModule1_closure" {
     GHC.Num.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.771889949 UTC

[section ""data" . GHC.Num.$trModule_closure" {
     GHC.Num.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Num.$trModule3_closure+1;
         const GHC.Num.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.772447491 UTC

[section ""data" . $krep_rlU8_closure" {
     $krep_rlU8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.773081049 UTC

[section ""data" . $krep1_rlU9_closure" {
     $krep1_rlU9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.773702705 UTC

[section ""data" . GHC.Num.$tcNum1_closure" {
     GHC.Num.$tcNum1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep1_rlU9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.774266845 UTC

[section ""data" . $krep2_rlUa_closure" {
     $krep2_rlUa_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.774788235 UTC

[section ""data" . $krep3_rlUb_closure" {
     $krep3_rlUb_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rlUa_closure+2;
         const $krep2_rlUa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.775323961 UTC

[section ""data" . $krep4_rlUc_closure" {
     $krep4_rlUc_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rlUa_closure+2;
         const $krep3_rlUb_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.775919775 UTC

[section ""data" . $krep5_rlUd_closure" {
     $krep5_rlUd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rlU8_closure+1;
         const $krep2_rlUa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.776418046 UTC

[section ""cstring" . GHC.Num.$tcNum3_bytes" {
     GHC.Num.$tcNum3_bytes:
         I8[] [78,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.77696955 UTC

[section ""data" . GHC.Num.$tcNum2_closure" {
     GHC.Num.$tcNum2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$tcNum3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.777530177 UTC

[section ""data" . GHC.Num.$tcNum_closure" {
     GHC.Num.$tcNum_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Num.$trModule_closure+1;
         const GHC.Num.$tcNum2_closure+1;
         const GHC.Num.$tcNum1_closure+4;
         const 4789207468288702218;
         const 12287762746798050066;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.778102734 UTC

[section ""data" . $krep6_rlUe_closure" {
     $krep6_rlUe_closure:
         const :_con_info;
         const $krep2_rlUa_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.779741815 UTC

[section ""data" . $krep7_rlUf_closure" {
     $krep7_rlUf_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Num.$tcNum_closure+1;
         const $krep6_rlUe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.780388148 UTC

[section ""data" . $krep8_rlUg_closure" {
     $krep8_rlUg_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_rlUd_closure+4;
         const $krep7_rlUf_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.781001047 UTC

[section ""data" . $krep9_rlUh_closure" {
     $krep9_rlUh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rlUb_closure+4;
         const $krep8_rlUg_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.781665864 UTC

[section ""data" . $krep10_rlUi_closure" {
     $krep10_rlUi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rlUb_closure+4;
         const $krep9_rlUh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.782232591 UTC

[section ""data" . $krep11_rlUj_closure" {
     $krep11_rlUj_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rlUb_closure+4;
         const $krep10_rlUi_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.782832931 UTC

[section ""data" . $krep12_rlUk_closure" {
     $krep12_rlUk_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rlUc_closure+4;
         const $krep11_rlUj_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.783402014 UTC

[section ""data" . $krep13_rlUl_closure" {
     $krep13_rlUl_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rlUc_closure+4;
         const $krep12_rlUk_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.783953783 UTC

[section ""data" . GHC.Num.$tc'C:Num1_closure" {
     GHC.Num.$tc'C:Num1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rlUc_closure+4;
         const $krep13_rlUl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.784558309 UTC

[section ""cstring" . GHC.Num.$tc'C:Num3_bytes" {
     GHC.Num.$tc'C:Num3_bytes:
         I8[] [39,67,58,78,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.785118779 UTC

[section ""data" . GHC.Num.$tc'C:Num2_closure" {
     GHC.Num.$tc'C:Num2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$tc'C:Num3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.785749155 UTC

[section ""data" . GHC.Num.$tc'C:Num_closure" {
     GHC.Num.$tc'C:Num_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Num.$trModule_closure+1;
         const GHC.Num.$tc'C:Num2_closure+1;
         const GHC.Num.$tc'C:Num1_closure+4;
         const 277567704124416124;
         const 17341550453118006986;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.786759272 UTC

[section ""data" . GHC.Num.C:Num_closure" {
     GHC.Num.C:Num_closure:
         const GHC.Num.C:Num_info;
 },
 GHC.Num.C:Num_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmc6: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Num.C:Num_entry(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2,
                                    R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Num.C:Num_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cmcb,
                       label: GHC.Num.C:Num_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmcb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cmcf; else goto cmce;
       cmcf: // global
           HpAlloc = 64;
           R1 = GHC.Num.C:Num_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cmce: // global
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.787987469 UTC

[GHC.Num.C:Num_con_entry() //  [R1]
         { info_tbl: [(cmcg,
                       label: GHC.Num.C:Num_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,78,117,109,46,67,58,78,117,109]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmcg: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.788657968 UTC

[section ""relreadonly" . Sm3Z_srt" {
     Sm3Z_srt:
         const lvl_rlU7_closure;
         const GHC.Num.$dmnegate_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.78948095 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:54:59.790804617 UTC

[section ""data" . GHC.Num.+_closure" {
     GHC.Num.+_closure:
         const GHC.Num.+_info;
 },
 GHC.Num.+_entry() //  [R2]
         { info_tbl: [(cmcp,
                       label: GHC.Num.+_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmcp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmcq; else goto cmcr;
       cmcq: // global
           R2 = R2;
           R1 = GHC.Num.+_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmcr: // global
           I64[Sp - 8] = block_cmcm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umcv; else goto cmcn;
       umcv: // global
           call _cmcm(R1) args: 0, res: 0, upd: 0;
       cmcn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmcm() //  [R1]
         { info_tbl: [(cmcm,
                       label: block_cmcm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmcm: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.796490945 UTC

[section ""data" . GHC.Num.-_closure" {
     GHC.Num.-_closure:
         const GHC.Num.-_info;
 },
 GHC.Num.-_entry() //  [R2]
         { info_tbl: [(cmcM,
                       label: GHC.Num.-_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmcM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmcN; else goto cmcO;
       cmcN: // global
           R2 = R2;
           R1 = GHC.Num.-_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmcO: // global
           I64[Sp - 8] = block_cmcJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umcS; else goto cmcK;
       umcS: // global
           call _cmcJ(R1) args: 0, res: 0, upd: 0;
       cmcK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmcJ() //  [R1]
         { info_tbl: [(cmcJ,
                       label: block_cmcJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmcJ: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.801830458 UTC

[section ""data" . GHC.Num.*_closure" {
     GHC.Num.*_closure:
         const GHC.Num.*_info;
 },
 GHC.Num.*_entry() //  [R2]
         { info_tbl: [(cmd9,
                       label: GHC.Num.*_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmd9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmda; else goto cmdb;
       cmda: // global
           R2 = R2;
           R1 = GHC.Num.*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmdb: // global
           I64[Sp - 8] = block_cmd6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umdf; else goto cmd7;
       umdf: // global
           call _cmd6(R1) args: 0, res: 0, upd: 0;
       cmd7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmd6() //  [R1]
         { info_tbl: [(cmd6,
                       label: block_cmd6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmd6: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.807179398 UTC

[section ""data" . GHC.Num.negate_closure" {
     GHC.Num.negate_closure:
         const GHC.Num.negate_info;
 },
 GHC.Num.negate_entry() //  [R2]
         { info_tbl: [(cmdw,
                       label: GHC.Num.negate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmdw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmdx; else goto cmdy;
       cmdx: // global
           R2 = R2;
           R1 = GHC.Num.negate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmdy: // global
           I64[Sp - 8] = block_cmdt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umdC; else goto cmdu;
       umdC: // global
           call _cmdt(R1) args: 0, res: 0, upd: 0;
       cmdu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmdt() //  [R1]
         { info_tbl: [(cmdt,
                       label: block_cmdt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmdt: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.813141769 UTC

[section ""data" . GHC.Num.abs_closure" {
     GHC.Num.abs_closure:
         const GHC.Num.abs_info;
 },
 GHC.Num.abs_entry() //  [R2]
         { info_tbl: [(cmdT,
                       label: GHC.Num.abs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmdT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmdU; else goto cmdV;
       cmdU: // global
           R2 = R2;
           R1 = GHC.Num.abs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmdV: // global
           I64[Sp - 8] = block_cmdQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umdZ; else goto cmdR;
       umdZ: // global
           call _cmdQ(R1) args: 0, res: 0, upd: 0;
       cmdR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmdQ() //  [R1]
         { info_tbl: [(cmdQ,
                       label: block_cmdQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmdQ: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.818965963 UTC

[section ""data" . GHC.Num.signum_closure" {
     GHC.Num.signum_closure:
         const GHC.Num.signum_info;
 },
 GHC.Num.signum_entry() //  [R2]
         { info_tbl: [(cmeg,
                       label: GHC.Num.signum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmeg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmeh; else goto cmei;
       cmeh: // global
           R2 = R2;
           R1 = GHC.Num.signum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmei: // global
           I64[Sp - 8] = block_cmed_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umem; else goto cmee;
       umem: // global
           call _cmed(R1) args: 0, res: 0, upd: 0;
       cmee: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmed() //  [R1]
         { info_tbl: [(cmed,
                       label: block_cmed_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmed: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.824248214 UTC

[section ""data" . GHC.Num.fromInteger_closure" {
     GHC.Num.fromInteger_closure:
         const GHC.Num.fromInteger_info;
 },
 GHC.Num.fromInteger_entry() //  [R2]
         { info_tbl: [(cmeD,
                       label: GHC.Num.fromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmeD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmeE; else goto cmeF;
       cmeE: // global
           R2 = R2;
           R1 = GHC.Num.fromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmeF: // global
           I64[Sp - 8] = block_cmeA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umeJ; else goto cmeB;
       umeJ: // global
           call _cmeA(R1) args: 0, res: 0, upd: 0;
       cmeB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmeA() //  [R1]
         { info_tbl: [(cmeA,
                       label: block_cmeA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmeA: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.829870776 UTC

[section ""data" . GHC.Num.$fNumInt_$cfromInteger_closure" {
     GHC.Num.$fNumInt_$cfromInteger_closure:
         const GHC.Num.$fNumInt_$cfromInteger_info;
 },
 GHC.Num.$fNumInt_$cfromInteger_entry() //  [R2]
         { info_tbl: [(cmeZ,
                       label: GHC.Num.$fNumInt_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmeZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmf3; else goto cmf4;
       cmf3: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmf4: // global
           I64[Sp - 8] = block_cmeX_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cmeX() //  [R1]
         { info_tbl: [(cmeX,
                       label: block_cmeX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmeX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmf7; else goto cmf6;
       cmf7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cmf6: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.835538035 UTC

[section ""data" . GHC.Num.$fNumInt_$cnegate_closure" {
     GHC.Num.$fNumInt_$cnegate_closure:
         const GHC.Num.$fNumInt_$cnegate_info;
 },
 GHC.Num.$fNumInt_$cnegate_entry() //  [R2]
         { info_tbl: [(cmfo,
                       label: GHC.Num.$fNumInt_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmfo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmfv; else goto cmfw;
       cmfv: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmfw: // global
           I64[Sp - 8] = block_cmfl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umfA; else goto cmfm;
       umfA: // global
           call _cmfl(R1) args: 0, res: 0, upd: 0;
       cmfm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmfl() //  [R1]
         { info_tbl: [(cmfl,
                       label: block_cmfl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmfl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmfz; else goto cmfy;
       cmfz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmfy: // global
           _slVu::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _slVu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.841694009 UTC

[section ""data" . GHC.Num.$fNumInt_$c*_closure" {
     GHC.Num.$fNumInt_$c*_closure:
         const GHC.Num.$fNumInt_$c*_info;
 },
 GHC.Num.$fNumInt_$c*_entry() //  [R2, R3]
         { info_tbl: [(cmfS,
                       label: GHC.Num.$fNumInt_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmfS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmg4; else goto cmg5;
       cmg4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmg5: // global
           I64[Sp - 16] = block_cmfP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umgb; else goto cmfQ;
       umgb: // global
           call _cmfP(R1) args: 0, res: 0, upd: 0;
       cmfQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmfP() //  [R1]
         { info_tbl: [(cmfP,
                       label: block_cmfP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmfP: // global
           I64[Sp] = block_cmfV_info;
           _slVy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slVy::I64;
           if (R1 & 7 != 0) goto umga; else goto cmfW;
       umga: // global
           call _cmfV(R1) args: 0, res: 0, upd: 0;
       cmfW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmfV() //  [R1]
         { info_tbl: [(cmfV,
                       label: block_cmfV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmfV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmg9; else goto cmg8;
       cmg9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmg8: // global
           _slVB::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _slVB::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.850712275 UTC

[section ""data" . GHC.Num.$fNumInt_$c-_closure" {
     GHC.Num.$fNumInt_$c-_closure:
         const GHC.Num.$fNumInt_$c-_info;
 },
 GHC.Num.$fNumInt_$c-_entry() //  [R2, R3]
         { info_tbl: [(cmgz,
                       label: GHC.Num.$fNumInt_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmgz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmgL; else goto cmgM;
       cmgL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmgM: // global
           I64[Sp - 16] = block_cmgw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umgS; else goto cmgx;
       umgS: // global
           call _cmgw(R1) args: 0, res: 0, upd: 0;
       cmgx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmgw() //  [R1]
         { info_tbl: [(cmgw,
                       label: block_cmgw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmgw: // global
           I64[Sp] = block_cmgC_info;
           _slVF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slVF::I64;
           if (R1 & 7 != 0) goto umgR; else goto cmgD;
       umgR: // global
           call _cmgC(R1) args: 0, res: 0, upd: 0;
       cmgD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmgC() //  [R1]
         { info_tbl: [(cmgC,
                       label: block_cmgC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmgC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmgQ; else goto cmgP;
       cmgQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmgP: // global
           _slVI::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _slVI::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.858576012 UTC

[section ""data" . GHC.Num.$fNumInt_$c+_closure" {
     GHC.Num.$fNumInt_$c+_closure:
         const GHC.Num.$fNumInt_$c+_info;
 },
 GHC.Num.$fNumInt_$c+_entry() //  [R2, R3]
         { info_tbl: [(cmhg,
                       label: GHC.Num.$fNumInt_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmhg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmhs; else goto cmht;
       cmhs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmht: // global
           I64[Sp - 16] = block_cmhd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umhz; else goto cmhe;
       umhz: // global
           call _cmhd(R1) args: 0, res: 0, upd: 0;
       cmhe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmhd() //  [R1]
         { info_tbl: [(cmhd,
                       label: block_cmhd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmhd: // global
           I64[Sp] = block_cmhj_info;
           _slVM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slVM::I64;
           if (R1 & 7 != 0) goto umhy; else goto cmhk;
       umhy: // global
           call _cmhj(R1) args: 0, res: 0, upd: 0;
       cmhk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmhj() //  [R1]
         { info_tbl: [(cmhj,
                       label: block_cmhj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmhj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmhx; else goto cmhw;
       cmhx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmhw: // global
           _slVP::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _slVP::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.866240227 UTC

[section ""data" . GHC.Num.$fNumInt_$cabs_closure" {
     GHC.Num.$fNumInt_$cabs_closure:
         const GHC.Num.$fNumInt_$cabs_info;
 },
 GHC.Num.$fNumInt_$cabs_entry() //  [R2]
         { info_tbl: [(cmhX,
                       label: GHC.Num.$fNumInt_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmhX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmhY; else goto cmhZ;
       cmhY: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmhZ: // global
           I64[Sp - 8] = block_cmhU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umif; else goto cmhV;
       umif: // global
           call _cmhU(R1) args: 0, res: 0, upd: 0;
       cmhV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmhU() //  [R1]
         { info_tbl: [(cmhU,
                       label: block_cmhU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmhU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmi4; else goto cmi3;
       cmi4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmi3: // global
           _slVS::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_slVS::I64, 0)) goto cmid; else goto cmie;
       cmid: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_slVS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cmie: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.871787931 UTC

[section ""data" . GHC.Num.$fNumInt3_closure" {
     GHC.Num.$fNumInt3_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.873477688 UTC

[section ""data" . GHC.Num.$fNumInt2_closure" {
     GHC.Num.$fNumInt2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.875044556 UTC

[section ""data" . GHC.Num.$fNumInt1_closure" {
     GHC.Num.$fNumInt1_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.877121781 UTC

[section ""data" . GHC.Num.$fNumInt_$csignum_closure" {
     GHC.Num.$fNumInt_$csignum_closure:
         const GHC.Num.$fNumInt_$csignum_info;
 },
 GHC.Num.$fNumInt_$csignum_entry() //  [R2]
         { info_tbl: [(cmiD,
                       label: GHC.Num.$fNumInt_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmiD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmiE; else goto cmiF;
       cmiE: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmiF: // global
           I64[Sp - 8] = block_cmiA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umiT; else goto cmiB;
       umiT: // global
           call _cmiA(R1) args: 0, res: 0, upd: 0;
       cmiB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmiA() //  [R1]
         { info_tbl: [(cmiA,
                       label: block_cmiA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmiA: // global
           _slVX::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_slVX::I64, 0)) goto cmiR; else goto cmiS;
       cmiR: // global
           if (_slVX::I64 == 0) goto cmiP; else goto cmiO;
       cmiP: // global
           R1 = GHC.Num.$fNumInt2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cmiO: // global
           R1 = GHC.Num.$fNumInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cmiS: // global
           R1 = GHC.Num.$fNumInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.883451399 UTC

[section ""data" . GHC.Num.$fNumInt_closure" {
     GHC.Num.$fNumInt_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Num.$fNumInt_$c+_closure+2;
         const GHC.Num.$fNumInt_$c-_closure+2;
         const GHC.Num.$fNumInt_$c*_closure+2;
         const GHC.Num.$fNumInt_$cnegate_closure+1;
         const GHC.Num.$fNumInt_$cabs_closure+1;
         const GHC.Num.$fNumInt_$csignum_closure+1;
         const GHC.Num.$fNumInt_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.886255704 UTC

[section ""data" . GHC.Num.$fNumWord_$cfromInteger_closure" {
     GHC.Num.$fNumWord_$cfromInteger_closure:
         const GHC.Num.$fNumWord_$cfromInteger_info;
 },
 GHC.Num.$fNumWord_$cfromInteger_entry() //  [R2]
         { info_tbl: [(cmjd,
                       label: GHC.Num.$fNumWord_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmjd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmjh; else goto cmji;
       cmjh: // global
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmji: // global
           I64[Sp - 8] = block_cmjb_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cmjb() //  [R1]
         { info_tbl: [(cmjb,
                       label: block_cmjb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmjb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmjl; else goto cmjk;
       cmjl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cmjk: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.891346393 UTC

[section ""data" . GHC.Num.$fNumWord2_closure" {
     GHC.Num.$fNumWord2_closure:
         const GHC.Types.W#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.892918622 UTC

[section ""data" . GHC.Num.$fNumWord1_closure" {
     GHC.Num.$fNumWord1_closure:
         const GHC.Types.W#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.895232693 UTC

[section ""data" . GHC.Num.$fNumWord_$csignum_closure" {
     GHC.Num.$fNumWord_$csignum_closure:
         const GHC.Num.$fNumWord_$csignum_info;
 },
 GHC.Num.$fNumWord_$csignum_entry() //  [R2]
         { info_tbl: [(cmjE,
                       label: GHC.Num.$fNumWord_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmjE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmjF; else goto cmjG;
       cmjF: // global
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmjG: // global
           I64[Sp - 8] = block_cmjB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umjO; else goto cmjC;
       umjO: // global
           call _cmjB(R1) args: 0, res: 0, upd: 0;
       cmjC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmjB() //  [R1]
         { info_tbl: [(cmjB,
                       label: block_cmjB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmjB: // global
           if (I64[R1 + 7] == 0) goto cmjN; else goto cmjM;
       cmjN: // global
           R1 = GHC.Num.$fNumWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cmjM: // global
           R1 = GHC.Num.$fNumWord2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.900689605 UTC

[section ""data" . GHC.Num.$fNumWord_$cabs_closure" {
     GHC.Num.$fNumWord_$cabs_closure:
         const GHC.Num.$fNumWord_$cabs_info;
 },
 GHC.Num.$fNumWord_$cabs_entry() //  [R2]
         { info_tbl: [(cmk4,
                       label: GHC.Num.$fNumWord_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmk4: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.904117867 UTC

[section ""data" . GHC.Num.$fNumWord_$cnegate_closure" {
     GHC.Num.$fNumWord_$cnegate_closure:
         const GHC.Num.$fNumWord_$cnegate_info;
 },
 GHC.Num.$fNumWord_$cnegate_entry() //  [R2]
         { info_tbl: [(cmkk,
                       label: GHC.Num.$fNumWord_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmkk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmkx; else goto cmky;
       cmkx: // global
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmky: // global
           I64[Sp - 8] = block_cmkh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umkC; else goto cmki;
       umkC: // global
           call _cmkh(R1) args: 0, res: 0, upd: 0;
       cmki: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmkh() //  [R1]
         { info_tbl: [(cmkh,
                       label: block_cmkh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmkh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmkB; else goto cmkA;
       cmkB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmkA: // global
           _slWc::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _slWc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.910479337 UTC

[section ""data" . GHC.Num.$fNumWord_$c*_closure" {
     GHC.Num.$fNumWord_$c*_closure:
         const GHC.Num.$fNumWord_$c*_info;
 },
 GHC.Num.$fNumWord_$c*_entry() //  [R2, R3]
         { info_tbl: [(cmkU,
                       label: GHC.Num.$fNumWord_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmkU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cml6; else goto cml7;
       cml6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cml7: // global
           I64[Sp - 16] = block_cmkR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umld; else goto cmkS;
       umld: // global
           call _cmkR(R1) args: 0, res: 0, upd: 0;
       cmkS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmkR() //  [R1]
         { info_tbl: [(cmkR,
                       label: block_cmkR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmkR: // global
           I64[Sp] = block_cmkX_info;
           _slWg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slWg::I64;
           if (R1 & 7 != 0) goto umlc; else goto cmkY;
       umlc: // global
           call _cmkX(R1) args: 0, res: 0, upd: 0;
       cmkY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmkX() //  [R1]
         { info_tbl: [(cmkX,
                       label: block_cmkX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmkX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmlb; else goto cmla;
       cmlb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmla: // global
           _slWj::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _slWj::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.918712577 UTC

[section ""data" . GHC.Num.$fNumWord_$c-_closure" {
     GHC.Num.$fNumWord_$c-_closure:
         const GHC.Num.$fNumWord_$c-_info;
 },
 GHC.Num.$fNumWord_$c-_entry() //  [R2, R3]
         { info_tbl: [(cmlB,
                       label: GHC.Num.$fNumWord_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmlB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmlN; else goto cmlO;
       cmlN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmlO: // global
           I64[Sp - 16] = block_cmly_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umlU; else goto cmlz;
       umlU: // global
           call _cmly(R1) args: 0, res: 0, upd: 0;
       cmlz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmly() //  [R1]
         { info_tbl: [(cmly,
                       label: block_cmly_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmly: // global
           I64[Sp] = block_cmlE_info;
           _slWn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slWn::I64;
           if (R1 & 7 != 0) goto umlT; else goto cmlF;
       umlT: // global
           call _cmlE(R1) args: 0, res: 0, upd: 0;
       cmlF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmlE() //  [R1]
         { info_tbl: [(cmlE,
                       label: block_cmlE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmlE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmlS; else goto cmlR;
       cmlS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmlR: // global
           _slWq::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _slWq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.926121618 UTC

[section ""data" . GHC.Num.$fNumWord_$c+_closure" {
     GHC.Num.$fNumWord_$c+_closure:
         const GHC.Num.$fNumWord_$c+_info;
 },
 GHC.Num.$fNumWord_$c+_entry() //  [R2, R3]
         { info_tbl: [(cmmi,
                       label: GHC.Num.$fNumWord_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmmi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmmu; else goto cmmv;
       cmmu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmmv: // global
           I64[Sp - 16] = block_cmmf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ummB; else goto cmmg;
       ummB: // global
           call _cmmf(R1) args: 0, res: 0, upd: 0;
       cmmg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmmf() //  [R1]
         { info_tbl: [(cmmf,
                       label: block_cmmf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmmf: // global
           I64[Sp] = block_cmml_info;
           _slWu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _slWu::I64;
           if (R1 & 7 != 0) goto ummA; else goto cmmm;
       ummA: // global
           call _cmml(R1) args: 0, res: 0, upd: 0;
       cmmm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmml() //  [R1]
         { info_tbl: [(cmml,
                       label: block_cmml_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmml: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmmz; else goto cmmy;
       cmmz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmmy: // global
           _slWx::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _slWx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.933019754 UTC

[section ""data" . GHC.Num.$fNumWord_closure" {
     GHC.Num.$fNumWord_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Num.$fNumWord_$c+_closure+2;
         const GHC.Num.$fNumWord_$c-_closure+2;
         const GHC.Num.$fNumWord_$c*_closure+2;
         const GHC.Num.$fNumWord_$cnegate_closure+1;
         const GHC.Num.$fNumWord_$cabs_closure+1;
         const GHC.Num.$fNumWord_$csignum_closure+1;
         const GHC.Num.$fNumWord_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.934957839 UTC

[section ""data" . GHC.Num.$fNumInteger_$cfromInteger_closure" {
     GHC.Num.$fNumInteger_$cfromInteger_closure:
         const GHC.Num.$fNumInteger_$cfromInteger_info;
 },
 GHC.Num.$fNumInteger_$cfromInteger_entry() //  [R2]
         { info_tbl: [(cmmX,
                       label: GHC.Num.$fNumInteger_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmmX: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.938014412 UTC

[section ""data" . GHC.Num.$fNumInteger_closure" {
     GHC.Num.$fNumInteger_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Integer.Type.plusInteger_closure+2;
         const GHC.Integer.Type.minusInteger_closure+2;
         const GHC.Integer.Type.timesInteger_closure+2;
         const GHC.Integer.Type.negateInteger_closure+1;
         const GHC.Integer.Type.absInteger_closure+1;
         const GHC.Integer.Type.signumInteger_closure+1;
         const GHC.Num.$fNumInteger_$cfromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.939951251 UTC

[section ""data" . lvl_rlU7_closure" {
     lvl_rlU7_closure:
         const lvl_rlU7_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rlU7_entry() //  [R1]
         { info_tbl: [(cmnd,
                       label: lvl_rlU7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmnd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmne; else goto cmnf;
       cmne: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cmnf: // global
           (_cmna::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cmna::I64 == 0) goto cmnc; else goto cmnb;
       cmnc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cmnb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cmna::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.944077727 UTC

[section ""data" . GHC.Num.$dmnegate_closure" {
     GHC.Num.$dmnegate_closure:
         const GHC.Num.$dmnegate_info;
         const 0;
 },
 sat_slWI_entry() //  [R1]
         { info_tbl: [(cmnv,
                       label: sat_slWI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmnv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cmnw; else goto cmnx;
       cmnw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cmnx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rlU7_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Num.$dmnegate_entry() //  [R2, R3]
         { info_tbl: [(cmny,
                       label: GHC.Num.$dmnegate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmny: // global
           _slWH::P64 = R3;
           _slWG::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cmnz; else goto cmnA;
       cmnA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cmnC; else goto cmnB;
       cmnC: // global
           HpAlloc = 24;
           goto cmnz;
       cmnz: // global
           R3 = _slWH::P64;
           R2 = _slWG::P64;
           R1 = GHC.Num.$dmnegate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmnB: // global
           I64[Hp - 16] = sat_slWI_info;
           P64[Hp] = _slWG::P64;
           R2 = _slWG::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _slWH::P64;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.950651022 UTC

[section ""data" . GHC.Num.$dm-_closure" {
     GHC.Num.$dm-_closure:
         const GHC.Num.$dm-_info;
 },
 sat_slWM_entry() //  [R1]
         { info_tbl: [(cmnV,
                       label: sat_slWM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmnV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cmnW; else goto cmnX;
       cmnW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cmnX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Num.$dm-_entry() //  [R2, R3, R4]
         { info_tbl: [(cmnY,
                       label: GHC.Num.$dm-_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmnY: // global
           _slWL::P64 = R4;
           _slWK::P64 = R3;
           _slWJ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cmnZ; else goto cmo0;
       cmo0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cmo2; else goto cmo1;
       cmo2: // global
           HpAlloc = 32;
           goto cmnZ;
       cmnZ: // global
           R4 = _slWL::P64;
           R3 = _slWK::P64;
           R2 = _slWJ::P64;
           R1 = GHC.Num.$dm-_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cmo1: // global
           I64[Hp - 24] = sat_slWM_info;
           P64[Hp - 8] = _slWJ::P64;
           P64[Hp] = _slWL::P64;
           R2 = _slWJ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _slWK::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.956388146 UTC

[section ""data" . GHC.Num.subtract_closure" {
     GHC.Num.subtract_closure:
         const GHC.Num.subtract_info;
 },
 GHC.Num.subtract_entry() //  [R2, R3, R4]
         { info_tbl: [(cmoi,
                       label: GHC.Num.subtract_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmoi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cmoj; else goto cmok;
       cmoj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.subtract_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cmok: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.959879483 UTC

[section ""cstring" . GHC.Num.$trModule4_bytes" {
     GHC.Num.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.961482825 UTC

[section ""data" . GHC.Num.$trModule3_closure" {
     GHC.Num.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.963018099 UTC

[section ""cstring" . GHC.Num.$trModule2_bytes" {
     GHC.Num.$trModule2_bytes:
         I8[] [71,72,67,46,78,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.964545619 UTC

[section ""data" . GHC.Num.$trModule1_closure" {
     GHC.Num.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.966155728 UTC

[section ""data" . GHC.Num.$trModule_closure" {
     GHC.Num.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Num.$trModule3_closure+1;
         const GHC.Num.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.967704381 UTC

[section ""data" . $krep_rlU8_closure" {
     $krep_rlU8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.969677143 UTC

[section ""data" . $krep1_rlU9_closure" {
     $krep1_rlU9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.971293263 UTC

[section ""data" . GHC.Num.$tcNum1_closure" {
     GHC.Num.$tcNum1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep1_rlU9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.972953482 UTC

[section ""data" . $krep2_rlUa_closure" {
     $krep2_rlUa_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.974499771 UTC

[section ""data" . $krep3_rlUb_closure" {
     $krep3_rlUb_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rlUa_closure+2;
         const $krep2_rlUa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.976555901 UTC

[section ""data" . $krep4_rlUc_closure" {
     $krep4_rlUc_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rlUa_closure+2;
         const $krep3_rlUb_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.979086847 UTC

[section ""data" . $krep5_rlUd_closure" {
     $krep5_rlUd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rlU8_closure+1;
         const $krep2_rlUa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.980632449 UTC

[section ""cstring" . GHC.Num.$tcNum3_bytes" {
     GHC.Num.$tcNum3_bytes:
         I8[] [78,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.982243017 UTC

[section ""data" . GHC.Num.$tcNum2_closure" {
     GHC.Num.$tcNum2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$tcNum3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.983752825 UTC

[section ""data" . GHC.Num.$tcNum_closure" {
     GHC.Num.$tcNum_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Num.$trModule_closure+1;
         const GHC.Num.$tcNum2_closure+1;
         const GHC.Num.$tcNum1_closure+4;
         const 4789207468288702218;
         const 12287762746798050066;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.985417522 UTC

[section ""data" . $krep6_rlUe_closure" {
     $krep6_rlUe_closure:
         const :_con_info;
         const $krep2_rlUa_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.986947966 UTC

[section ""data" . $krep7_rlUf_closure" {
     $krep7_rlUf_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Num.$tcNum_closure+1;
         const $krep6_rlUe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.988490909 UTC

[section ""data" . $krep8_rlUg_closure" {
     $krep8_rlUg_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_rlUd_closure+4;
         const $krep7_rlUf_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.99076738 UTC

[section ""data" . $krep9_rlUh_closure" {
     $krep9_rlUh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rlUb_closure+4;
         const $krep8_rlUg_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.992359997 UTC

[section ""data" . $krep10_rlUi_closure" {
     $krep10_rlUi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rlUb_closure+4;
         const $krep9_rlUh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.993941904 UTC

[section ""data" . $krep11_rlUj_closure" {
     $krep11_rlUj_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rlUb_closure+4;
         const $krep10_rlUi_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.995506909 UTC

[section ""data" . $krep12_rlUk_closure" {
     $krep12_rlUk_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rlUc_closure+4;
         const $krep11_rlUj_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.997043164 UTC

[section ""data" . $krep13_rlUl_closure" {
     $krep13_rlUl_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rlUc_closure+4;
         const $krep12_rlUk_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:54:59.998602935 UTC

[section ""data" . GHC.Num.$tc'C:Num1_closure" {
     GHC.Num.$tc'C:Num1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rlUc_closure+4;
         const $krep13_rlUl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.000543966 UTC

[section ""cstring" . GHC.Num.$tc'C:Num3_bytes" {
     GHC.Num.$tc'C:Num3_bytes:
         I8[] [39,67,58,78,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.002145823 UTC

[section ""data" . GHC.Num.$tc'C:Num2_closure" {
     GHC.Num.$tc'C:Num2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$tc'C:Num3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.003734893 UTC

[section ""data" . GHC.Num.$tc'C:Num_closure" {
     GHC.Num.$tc'C:Num_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Num.$trModule_closure+1;
         const GHC.Num.$tc'C:Num2_closure+1;
         const GHC.Num.$tc'C:Num1_closure+4;
         const 277567704124416124;
         const 17341550453118006986;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.005870297 UTC

[section ""data" . GHC.Num.C:Num_closure" {
     GHC.Num.C:Num_closure:
         const GHC.Num.C:Num_info;
 },
 GHC.Num.C:Num_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmoS: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Num.C:Num_entry(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2,
                                    R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Num.C:Num_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cmoX,
                       label: GHC.Num.C:Num_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmoX: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cmp1; else goto cmp0;
       cmp1: // global
           HpAlloc = 64;
           R1 = GHC.Num.C:Num_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cmp0: // global
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.011164033 UTC

[GHC.Num.C:Num_con_entry() //  [R1]
         { info_tbl: [(cmpb,
                       label: GHC.Num.C:Num_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,78,117,109,46,67,58,78,117,109]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmpb: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.014029625 UTC

[section ""relreadonly" . Sm3Z_srt" {
     Sm3Z_srt:
         const lvl_rlU7_closure;
         const GHC.Num.$dmnegate_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.338127716 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:55:00.339522622 UTC

[section ""data" . GHC.Num.+_closure" {
     GHC.Num.+_closure:
         const GHC.Num.+_info;
 },
 GHC.Num.+_entry() //  [R2]
         { info_tbl: [(cmrK,
                       label: GHC.Num.+_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmrK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmrL; else goto cmrM;
       cmrL: // global
           R2 = R2;
           R1 = GHC.Num.+_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmrM: // global
           I64[Sp - 8] = block_cmrH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umrQ; else goto cmrI;
       umrQ: // global
           call _cmrH(R1) args: 0, res: 0, upd: 0;
       cmrI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmrH() //  [R1]
         { info_tbl: [(cmrH,
                       label: block_cmrH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmrH: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.34507187 UTC

[section ""data" . GHC.Num.-_closure" {
     GHC.Num.-_closure:
         const GHC.Num.-_info;
 },
 GHC.Num.-_entry() //  [R2]
         { info_tbl: [(cms8,
                       label: GHC.Num.-_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cms8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cms9; else goto cmsa;
       cms9: // global
           R2 = R2;
           R1 = GHC.Num.-_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmsa: // global
           I64[Sp - 8] = block_cms5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umse; else goto cms6;
       umse: // global
           call _cms5(R1) args: 0, res: 0, upd: 0;
       cms6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cms5() //  [R1]
         { info_tbl: [(cms5,
                       label: block_cms5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cms5: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.353854388 UTC

[section ""data" . GHC.Num.*_closure" {
     GHC.Num.*_closure:
         const GHC.Num.*_info;
 },
 GHC.Num.*_entry() //  [R2]
         { info_tbl: [(cmsw,
                       label: GHC.Num.*_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmsw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmsx; else goto cmsy;
       cmsx: // global
           R2 = R2;
           R1 = GHC.Num.*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmsy: // global
           I64[Sp - 8] = block_cmst_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umsC; else goto cmsu;
       umsC: // global
           call _cmst(R1) args: 0, res: 0, upd: 0;
       cmsu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmst() //  [R1]
         { info_tbl: [(cmst,
                       label: block_cmst_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmst: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.359018615 UTC

[section ""data" . GHC.Num.negate_closure" {
     GHC.Num.negate_closure:
         const GHC.Num.negate_info;
 },
 GHC.Num.negate_entry() //  [R2]
         { info_tbl: [(cmsU,
                       label: GHC.Num.negate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmsU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmsV; else goto cmsW;
       cmsV: // global
           R2 = R2;
           R1 = GHC.Num.negate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmsW: // global
           I64[Sp - 8] = block_cmsR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umt0; else goto cmsS;
       umt0: // global
           call _cmsR(R1) args: 0, res: 0, upd: 0;
       cmsS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmsR() //  [R1]
         { info_tbl: [(cmsR,
                       label: block_cmsR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmsR: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.364442809 UTC

[section ""data" . GHC.Num.abs_closure" {
     GHC.Num.abs_closure:
         const GHC.Num.abs_info;
 },
 GHC.Num.abs_entry() //  [R2]
         { info_tbl: [(cmti,
                       label: GHC.Num.abs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmti: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmtj; else goto cmtk;
       cmtj: // global
           R2 = R2;
           R1 = GHC.Num.abs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmtk: // global
           I64[Sp - 8] = block_cmtf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umto; else goto cmtg;
       umto: // global
           call _cmtf(R1) args: 0, res: 0, upd: 0;
       cmtg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmtf() //  [R1]
         { info_tbl: [(cmtf,
                       label: block_cmtf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmtf: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.369766272 UTC

[section ""data" . GHC.Num.signum_closure" {
     GHC.Num.signum_closure:
         const GHC.Num.signum_info;
 },
 GHC.Num.signum_entry() //  [R2]
         { info_tbl: [(cmtG,
                       label: GHC.Num.signum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmtG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmtH; else goto cmtI;
       cmtH: // global
           R2 = R2;
           R1 = GHC.Num.signum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmtI: // global
           I64[Sp - 8] = block_cmtD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umtM; else goto cmtE;
       umtM: // global
           call _cmtD(R1) args: 0, res: 0, upd: 0;
       cmtE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmtD() //  [R1]
         { info_tbl: [(cmtD,
                       label: block_cmtD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmtD: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.375230974 UTC

[section ""data" . GHC.Num.fromInteger_closure" {
     GHC.Num.fromInteger_closure:
         const GHC.Num.fromInteger_info;
 },
 GHC.Num.fromInteger_entry() //  [R2]
         { info_tbl: [(cmu4,
                       label: GHC.Num.fromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmu4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmu5; else goto cmu6;
       cmu5: // global
           R2 = R2;
           R1 = GHC.Num.fromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmu6: // global
           I64[Sp - 8] = block_cmu1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umua; else goto cmu2;
       umua: // global
           call _cmu1(R1) args: 0, res: 0, upd: 0;
       cmu2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmu1() //  [R1]
         { info_tbl: [(cmu1,
                       label: block_cmu1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmu1: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.38067782 UTC

[section ""data" . GHC.Num.$fNumInt_$cfromInteger_closure" {
     GHC.Num.$fNumInt_$cfromInteger_closure:
         const GHC.Num.$fNumInt_$cfromInteger_info;
 },
 GHC.Num.$fNumInt_$cfromInteger_entry() //  [R2]
         { info_tbl: [(cmur,
                       label: GHC.Num.$fNumInt_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmur: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmuv; else goto cmuw;
       cmuv: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmuw: // global
           I64[Sp - 8] = block_cmup_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cmup() //  [R1]
         { info_tbl: [(cmup,
                       label: block_cmup_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmup: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmuz; else goto cmuy;
       cmuz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cmuy: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.387144368 UTC

[section ""data" . GHC.Num.$fNumInt_$cnegate_closure" {
     GHC.Num.$fNumInt_$cnegate_closure:
         const GHC.Num.$fNumInt_$cnegate_info;
 },
 GHC.Num.$fNumInt_$cnegate_entry() //  [R2]
         { info_tbl: [(cmuS,
                       label: GHC.Num.$fNumInt_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmuS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmuZ; else goto cmv0;
       cmuZ: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmv0: // global
           I64[Sp - 8] = block_cmuP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umv4; else goto cmuQ;
       umv4: // global
           call _cmuP(R1) args: 0, res: 0, upd: 0;
       cmuQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmuP() //  [R1]
         { info_tbl: [(cmuP,
                       label: block_cmuP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmuP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmv3; else goto cmv2;
       cmv3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmv2: // global
           _smqo::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _smqo::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.393359917 UTC

[section ""data" . GHC.Num.$fNumInt_$c*_closure" {
     GHC.Num.$fNumInt_$c*_closure:
         const GHC.Num.$fNumInt_$c*_info;
 },
 GHC.Num.$fNumInt_$c*_entry() //  [R2, R3]
         { info_tbl: [(cmvo,
                       label: GHC.Num.$fNumInt_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmvo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmvA; else goto cmvB;
       cmvA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmvB: // global
           I64[Sp - 16] = block_cmvl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umvH; else goto cmvm;
       umvH: // global
           call _cmvl(R1) args: 0, res: 0, upd: 0;
       cmvm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmvl() //  [R1]
         { info_tbl: [(cmvl,
                       label: block_cmvl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmvl: // global
           I64[Sp] = block_cmvr_info;
           _smqs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _smqs::I64;
           if (R1 & 7 != 0) goto umvG; else goto cmvs;
       umvG: // global
           call _cmvr(R1) args: 0, res: 0, upd: 0;
       cmvs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmvr() //  [R1]
         { info_tbl: [(cmvr,
                       label: block_cmvr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmvr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmvF; else goto cmvE;
       cmvF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmvE: // global
           _smqv::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _smqv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.40112139 UTC

[section ""data" . GHC.Num.$fNumInt_$c-_closure" {
     GHC.Num.$fNumInt_$c-_closure:
         const GHC.Num.$fNumInt_$c-_info;
 },
 GHC.Num.$fNumInt_$c-_entry() //  [R2, R3]
         { info_tbl: [(cmw8,
                       label: GHC.Num.$fNumInt_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmw8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmwk; else goto cmwl;
       cmwk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmwl: // global
           I64[Sp - 16] = block_cmw5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umwr; else goto cmw6;
       umwr: // global
           call _cmw5(R1) args: 0, res: 0, upd: 0;
       cmw6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmw5() //  [R1]
         { info_tbl: [(cmw5,
                       label: block_cmw5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmw5: // global
           I64[Sp] = block_cmwb_info;
           _smqz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _smqz::I64;
           if (R1 & 7 != 0) goto umwq; else goto cmwc;
       umwq: // global
           call _cmwb(R1) args: 0, res: 0, upd: 0;
       cmwc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmwb() //  [R1]
         { info_tbl: [(cmwb,
                       label: block_cmwb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmwb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmwp; else goto cmwo;
       cmwp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmwo: // global
           _smqC::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _smqC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.409008961 UTC

[section ""data" . GHC.Num.$fNumInt_$c+_closure" {
     GHC.Num.$fNumInt_$c+_closure:
         const GHC.Num.$fNumInt_$c+_info;
 },
 GHC.Num.$fNumInt_$c+_entry() //  [R2, R3]
         { info_tbl: [(cmwS,
                       label: GHC.Num.$fNumInt_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmwS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmx4; else goto cmx5;
       cmx4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmx5: // global
           I64[Sp - 16] = block_cmwP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umxb; else goto cmwQ;
       umxb: // global
           call _cmwP(R1) args: 0, res: 0, upd: 0;
       cmwQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmwP() //  [R1]
         { info_tbl: [(cmwP,
                       label: block_cmwP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmwP: // global
           I64[Sp] = block_cmwV_info;
           _smqG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _smqG::I64;
           if (R1 & 7 != 0) goto umxa; else goto cmwW;
       umxa: // global
           call _cmwV(R1) args: 0, res: 0, upd: 0;
       cmwW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmwV() //  [R1]
         { info_tbl: [(cmwV,
                       label: block_cmwV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmwV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmx9; else goto cmx8;
       cmx9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmx8: // global
           _smqJ::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _smqJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.416857622 UTC

[section ""data" . GHC.Num.$fNumInt_$cabs_closure" {
     GHC.Num.$fNumInt_$cabs_closure:
         const GHC.Num.$fNumInt_$cabs_info;
 },
 GHC.Num.$fNumInt_$cabs_entry() //  [R2]
         { info_tbl: [(cmxC,
                       label: GHC.Num.$fNumInt_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmxC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmxD; else goto cmxE;
       cmxD: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$cabs_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmxE: // global
           I64[Sp - 8] = block_cmxz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umxU; else goto cmxA;
       umxU: // global
           call _cmxz(R1) args: 0, res: 0, upd: 0;
       cmxA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmxz() //  [R1]
         { info_tbl: [(cmxz,
                       label: block_cmxz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmxz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmxJ; else goto cmxI;
       cmxJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmxI: // global
           _smqM::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_smqM::I64, 0)) goto cmxS; else goto cmxT;
       cmxS: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_smqM::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cmxT: // global
           Hp = Hp - 16;
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.423261 UTC

[section ""data" . GHC.Num.$fNumInt3_closure" {
     GHC.Num.$fNumInt3_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.424853863 UTC

[section ""data" . GHC.Num.$fNumInt2_closure" {
     GHC.Num.$fNumInt2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.426483463 UTC

[section ""data" . GHC.Num.$fNumInt1_closure" {
     GHC.Num.$fNumInt1_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.428506223 UTC

[section ""data" . GHC.Num.$fNumInt_$csignum_closure" {
     GHC.Num.$fNumInt_$csignum_closure:
         const GHC.Num.$fNumInt_$csignum_info;
 },
 GHC.Num.$fNumInt_$csignum_entry() //  [R2]
         { info_tbl: [(cmyk,
                       label: GHC.Num.$fNumInt_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmyk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmyl; else goto cmym;
       cmyl: // global
           R2 = R2;
           R1 = GHC.Num.$fNumInt_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmym: // global
           I64[Sp - 8] = block_cmyh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umyA; else goto cmyi;
       umyA: // global
           call _cmyh(R1) args: 0, res: 0, upd: 0;
       cmyi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmyh() //  [R1]
         { info_tbl: [(cmyh,
                       label: block_cmyh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmyh: // global
           _smqR::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_smqR::I64, 0)) goto cmyy; else goto cmyz;
       cmyy: // global
           if (_smqR::I64 == 0) goto cmyw; else goto cmyv;
       cmyw: // global
           R1 = GHC.Num.$fNumInt2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cmyv: // global
           R1 = GHC.Num.$fNumInt3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cmyz: // global
           R1 = GHC.Num.$fNumInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.434517484 UTC

[section ""data" . GHC.Num.$fNumInt_closure" {
     GHC.Num.$fNumInt_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Num.$fNumInt_$c+_closure+2;
         const GHC.Num.$fNumInt_$c-_closure+2;
         const GHC.Num.$fNumInt_$c*_closure+2;
         const GHC.Num.$fNumInt_$cnegate_closure+1;
         const GHC.Num.$fNumInt_$cabs_closure+1;
         const GHC.Num.$fNumInt_$csignum_closure+1;
         const GHC.Num.$fNumInt_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.436673992 UTC

[section ""data" . GHC.Num.$fNumWord_$cfromInteger_closure" {
     GHC.Num.$fNumWord_$cfromInteger_closure:
         const GHC.Num.$fNumWord_$cfromInteger_info;
 },
 GHC.Num.$fNumWord_$cfromInteger_entry() //  [R2]
         { info_tbl: [(cmyV,
                       label: GHC.Num.$fNumWord_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmyV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmyZ; else goto cmz0;
       cmyZ: // global
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$cfromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmz0: // global
           I64[Sp - 8] = block_cmyT_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cmyT() //  [R1]
         { info_tbl: [(cmyT,
                       label: block_cmyT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmyT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmz3; else goto cmz2;
       cmz3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cmz2: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.443362534 UTC

[section ""data" . GHC.Num.$fNumWord2_closure" {
     GHC.Num.$fNumWord2_closure:
         const GHC.Types.W#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.445430712 UTC

[section ""data" . GHC.Num.$fNumWord1_closure" {
     GHC.Num.$fNumWord1_closure:
         const GHC.Types.W#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.447457734 UTC

[section ""data" . GHC.Num.$fNumWord_$csignum_closure" {
     GHC.Num.$fNumWord_$csignum_closure:
         const GHC.Num.$fNumWord_$csignum_info;
 },
 GHC.Num.$fNumWord_$csignum_entry() //  [R2]
         { info_tbl: [(cmzo,
                       label: GHC.Num.$fNumWord_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmzo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmzp; else goto cmzq;
       cmzp: // global
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$csignum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmzq: // global
           I64[Sp - 8] = block_cmzl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umzy; else goto cmzm;
       umzy: // global
           call _cmzl(R1) args: 0, res: 0, upd: 0;
       cmzm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmzl() //  [R1]
         { info_tbl: [(cmzl,
                       label: block_cmzl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmzl: // global
           if (I64[R1 + 7] == 0) goto cmzx; else goto cmzw;
       cmzx: // global
           R1 = GHC.Num.$fNumWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cmzw: // global
           R1 = GHC.Num.$fNumWord2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.453465914 UTC

[section ""data" . GHC.Num.$fNumWord_$cabs_closure" {
     GHC.Num.$fNumWord_$cabs_closure:
         const GHC.Num.$fNumWord_$cabs_info;
 },
 GHC.Num.$fNumWord_$cabs_entry() //  [R2]
         { info_tbl: [(cmzP,
                       label: GHC.Num.$fNumWord_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmzP: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.457555865 UTC

[section ""data" . GHC.Num.$fNumWord_$cnegate_closure" {
     GHC.Num.$fNumWord_$cnegate_closure:
         const GHC.Num.$fNumWord_$cnegate_info;
 },
 GHC.Num.$fNumWord_$cnegate_entry() //  [R2]
         { info_tbl: [(cmA5,
                       label: GHC.Num.$fNumWord_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmA5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cmAi; else goto cmAj;
       cmAi: // global
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cmAj: // global
           I64[Sp - 8] = block_cmA2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto umAn; else goto cmA3;
       umAn: // global
           call _cmA2(R1) args: 0, res: 0, upd: 0;
       cmA3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmA2() //  [R1]
         { info_tbl: [(cmA2,
                       label: block_cmA2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmA2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmAm; else goto cmAl;
       cmAm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmAl: // global
           _smr6::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _smr6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.463904607 UTC

[section ""data" . GHC.Num.$fNumWord_$c*_closure" {
     GHC.Num.$fNumWord_$c*_closure:
         const GHC.Num.$fNumWord_$c*_info;
 },
 GHC.Num.$fNumWord_$c*_entry() //  [R2, R3]
         { info_tbl: [(cmAH,
                       label: GHC.Num.$fNumWord_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmAH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmAT; else goto cmAU;
       cmAT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$c*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmAU: // global
           I64[Sp - 16] = block_cmAE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umB0; else goto cmAF;
       umB0: // global
           call _cmAE(R1) args: 0, res: 0, upd: 0;
       cmAF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmAE() //  [R1]
         { info_tbl: [(cmAE,
                       label: block_cmAE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmAE: // global
           I64[Sp] = block_cmAK_info;
           _smra::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _smra::I64;
           if (R1 & 7 != 0) goto umAZ; else goto cmAL;
       umAZ: // global
           call _cmAK(R1) args: 0, res: 0, upd: 0;
       cmAL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmAK() //  [R1]
         { info_tbl: [(cmAK,
                       label: block_cmAK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmAK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmAY; else goto cmAX;
       cmAY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmAX: // global
           _smrd::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _smrd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.477199863 UTC

[section ""data" . GHC.Num.$fNumWord_$c-_closure" {
     GHC.Num.$fNumWord_$c-_closure:
         const GHC.Num.$fNumWord_$c-_info;
 },
 GHC.Num.$fNumWord_$c-_entry() //  [R2, R3]
         { info_tbl: [(cmBr,
                       label: GHC.Num.$fNumWord_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmBr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmBD; else goto cmBE;
       cmBD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmBE: // global
           I64[Sp - 16] = block_cmBo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umBK; else goto cmBp;
       umBK: // global
           call _cmBo(R1) args: 0, res: 0, upd: 0;
       cmBp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmBo() //  [R1]
         { info_tbl: [(cmBo,
                       label: block_cmBo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmBo: // global
           I64[Sp] = block_cmBu_info;
           _smrh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _smrh::I64;
           if (R1 & 7 != 0) goto umBJ; else goto cmBv;
       umBJ: // global
           call _cmBu(R1) args: 0, res: 0, upd: 0;
       cmBv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmBu() //  [R1]
         { info_tbl: [(cmBu,
                       label: block_cmBu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmBu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmBI; else goto cmBH;
       cmBI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmBH: // global
           _smrk::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _smrk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.489102724 UTC

[section ""data" . GHC.Num.$fNumWord_$c+_closure" {
     GHC.Num.$fNumWord_$c+_closure:
         const GHC.Num.$fNumWord_$c+_info;
 },
 GHC.Num.$fNumWord_$c+_entry() //  [R2, R3]
         { info_tbl: [(cmCb,
                       label: GHC.Num.$fNumWord_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmCb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmCn; else goto cmCo;
       cmCn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.$fNumWord_$c+_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmCo: // global
           I64[Sp - 16] = block_cmC8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto umCu; else goto cmC9;
       umCu: // global
           call _cmC8(R1) args: 0, res: 0, upd: 0;
       cmC9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmC8() //  [R1]
         { info_tbl: [(cmC8,
                       label: block_cmC8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmC8: // global
           I64[Sp] = block_cmCe_info;
           _smro::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _smro::I64;
           if (R1 & 7 != 0) goto umCt; else goto cmCf;
       umCt: // global
           call _cmCe(R1) args: 0, res: 0, upd: 0;
       cmCf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cmCe() //  [R1]
         { info_tbl: [(cmCe,
                       label: block_cmCe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmCe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cmCs; else goto cmCr;
       cmCs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cmCr: // global
           _smrr::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _smrr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.499370753 UTC

[section ""data" . GHC.Num.$fNumWord_closure" {
     GHC.Num.$fNumWord_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Num.$fNumWord_$c+_closure+2;
         const GHC.Num.$fNumWord_$c-_closure+2;
         const GHC.Num.$fNumWord_$c*_closure+2;
         const GHC.Num.$fNumWord_$cnegate_closure+1;
         const GHC.Num.$fNumWord_$cabs_closure+1;
         const GHC.Num.$fNumWord_$csignum_closure+1;
         const GHC.Num.$fNumWord_$cfromInteger_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.502341489 UTC

[section ""data" . GHC.Num.$fNumInteger_$cfromInteger_closure" {
     GHC.Num.$fNumInteger_$cfromInteger_closure:
         const GHC.Num.$fNumInteger_$cfromInteger_info;
 },
 GHC.Num.$fNumInteger_$cfromInteger_entry() //  [R2]
         { info_tbl: [(cmCT,
                       label: GHC.Num.$fNumInteger_$cfromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmCT: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.507861808 UTC

[section ""data" . GHC.Num.$fNumInteger_closure" {
     GHC.Num.$fNumInteger_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Integer.Type.plusInteger_closure+2;
         const GHC.Integer.Type.minusInteger_closure+2;
         const GHC.Integer.Type.timesInteger_closure+2;
         const GHC.Integer.Type.negateInteger_closure+1;
         const GHC.Integer.Type.absInteger_closure+1;
         const GHC.Integer.Type.signumInteger_closure+1;
         const GHC.Num.$fNumInteger_$cfromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.510402291 UTC

[section ""data" . lvl_rlU7_closure" {
     lvl_rlU7_closure:
         const lvl_rlU7_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_rlU7_entry() //  [R1]
         { info_tbl: [(cmD9,
                       label: lvl_rlU7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmD9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cmDa; else goto cmDb;
       cmDa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cmDb: // global
           (_cmD6::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cmD6::I64 == 0) goto cmD8; else goto cmD7;
       cmD8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cmD7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cmD6::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.516308207 UTC

[section ""data" . GHC.Num.$dmnegate_closure" {
     GHC.Num.$dmnegate_closure:
         const GHC.Num.$dmnegate_info;
         const 0;
 },
 sat_smrv_entry() //  [R1]
         { info_tbl: [(cmDu,
                       label: sat_smrv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmDu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cmDv; else goto cmDw;
       cmDv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cmDw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl_rlU7_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Num.$dmnegate_entry() //  [R2, R3]
         { info_tbl: [(cmDx,
                       label: GHC.Num.$dmnegate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmDx: // global
           _smru::P64 = R3;
           _smrt::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cmDy; else goto cmDz;
       cmDz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cmDB; else goto cmDA;
       cmDB: // global
           HpAlloc = 24;
           goto cmDy;
       cmDy: // global
           R3 = _smru::P64;
           R2 = _smrt::P64;
           R1 = GHC.Num.$dmnegate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cmDA: // global
           I64[Hp - 16] = sat_smrv_info;
           P64[Hp] = _smrt::P64;
           R2 = _smrt::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _smru::P64;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.525458556 UTC

[section ""data" . GHC.Num.$dm-_closure" {
     GHC.Num.$dm-_closure:
         const GHC.Num.$dm-_info;
 },
 sat_smrz_entry() //  [R1]
         { info_tbl: [(cmE0,
                       label: sat_smrz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmE0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cmE1; else goto cmE2;
       cmE1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cmE2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Num.$dm-_entry() //  [R2, R3, R4]
         { info_tbl: [(cmE3,
                       label: GHC.Num.$dm-_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmE3: // global
           _smry::P64 = R4;
           _smrx::P64 = R3;
           _smrw::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cmE4; else goto cmE5;
       cmE5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cmE7; else goto cmE6;
       cmE7: // global
           HpAlloc = 32;
           goto cmE4;
       cmE4: // global
           R4 = _smry::P64;
           R3 = _smrx::P64;
           R2 = _smrw::P64;
           R1 = GHC.Num.$dm-_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cmE6: // global
           I64[Hp - 24] = sat_smrz_info;
           P64[Hp - 8] = _smrw::P64;
           P64[Hp] = _smry::P64;
           R2 = _smrw::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _smrx::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.531886537 UTC

[section ""data" . GHC.Num.subtract_closure" {
     GHC.Num.subtract_closure:
         const GHC.Num.subtract_info;
 },
 GHC.Num.subtract_entry() //  [R2, R3, R4]
         { info_tbl: [(cmEr,
                       label: GHC.Num.subtract_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmEr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cmEs; else goto cmEt;
       cmEs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Num.subtract_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cmEt: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Num.-_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.535612943 UTC

[section ""cstring" . GHC.Num.$trModule4_bytes" {
     GHC.Num.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.537178876 UTC

[section ""data" . GHC.Num.$trModule3_closure" {
     GHC.Num.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.53877173 UTC

[section ""cstring" . GHC.Num.$trModule2_bytes" {
     GHC.Num.$trModule2_bytes:
         I8[] [71,72,67,46,78,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.540361692 UTC

[section ""data" . GHC.Num.$trModule1_closure" {
     GHC.Num.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.542892991 UTC

[section ""data" . GHC.Num.$trModule_closure" {
     GHC.Num.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Num.$trModule3_closure+1;
         const GHC.Num.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.544702961 UTC

[section ""data" . $krep_rlU8_closure" {
     $krep_rlU8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.546418681 UTC

[section ""data" . $krep1_rlU9_closure" {
     $krep1_rlU9_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.54807965 UTC

[section ""data" . GHC.Num.$tcNum1_closure" {
     GHC.Num.$tcNum1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep1_rlU9_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.549888278 UTC

[section ""data" . $krep2_rlUa_closure" {
     $krep2_rlUa_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.552090963 UTC

[section ""data" . $krep3_rlUb_closure" {
     $krep3_rlUb_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rlUa_closure+2;
         const $krep2_rlUa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.554286796 UTC

[section ""data" . $krep4_rlUc_closure" {
     $krep4_rlUc_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_rlUa_closure+2;
         const $krep3_rlUb_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.556341471 UTC

[section ""data" . $krep5_rlUd_closure" {
     $krep5_rlUd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rlU8_closure+1;
         const $krep2_rlUa_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.558127911 UTC

[section ""cstring" . GHC.Num.$tcNum3_bytes" {
     GHC.Num.$tcNum3_bytes:
         I8[] [78,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.559773567 UTC

[section ""data" . GHC.Num.$tcNum2_closure" {
     GHC.Num.$tcNum2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$tcNum3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.561656593 UTC

[section ""data" . GHC.Num.$tcNum_closure" {
     GHC.Num.$tcNum_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Num.$trModule_closure+1;
         const GHC.Num.$tcNum2_closure+1;
         const GHC.Num.$tcNum1_closure+4;
         const 4789207468288702218;
         const 12287762746798050066;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.563935347 UTC

[section ""data" . $krep6_rlUe_closure" {
     $krep6_rlUe_closure:
         const :_con_info;
         const $krep2_rlUa_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.566187139 UTC

[section ""data" . $krep7_rlUf_closure" {
     $krep7_rlUf_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Num.$tcNum_closure+1;
         const $krep6_rlUe_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.568221876 UTC

[section ""data" . $krep8_rlUg_closure" {
     $krep8_rlUg_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_rlUd_closure+4;
         const $krep7_rlUf_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.570061187 UTC

[section ""data" . $krep9_rlUh_closure" {
     $krep9_rlUh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rlUb_closure+4;
         const $krep8_rlUg_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.572278424 UTC

[section ""data" . $krep10_rlUi_closure" {
     $krep10_rlUi_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rlUb_closure+4;
         const $krep9_rlUh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.574326892 UTC

[section ""data" . $krep11_rlUj_closure" {
     $krep11_rlUj_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_rlUb_closure+4;
         const $krep10_rlUi_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.576378051 UTC

[section ""data" . $krep12_rlUk_closure" {
     $krep12_rlUk_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rlUc_closure+4;
         const $krep11_rlUj_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.578688817 UTC

[section ""data" . $krep13_rlUl_closure" {
     $krep13_rlUl_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rlUc_closure+4;
         const $krep12_rlUk_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.580471205 UTC

[section ""data" . GHC.Num.$tc'C:Num1_closure" {
     GHC.Num.$tc'C:Num1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_rlUc_closure+4;
         const $krep13_rlUl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.582765324 UTC

[section ""cstring" . GHC.Num.$tc'C:Num3_bytes" {
     GHC.Num.$tc'C:Num3_bytes:
         I8[] [39,67,58,78,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.584517701 UTC

[section ""data" . GHC.Num.$tc'C:Num2_closure" {
     GHC.Num.$tc'C:Num2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Num.$tc'C:Num3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.586630531 UTC

[section ""data" . GHC.Num.$tc'C:Num_closure" {
     GHC.Num.$tc'C:Num_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Num.$trModule_closure+1;
         const GHC.Num.$tc'C:Num2_closure+1;
         const GHC.Num.$tc'C:Num1_closure+4;
         const 277567704124416124;
         const 17341550453118006986;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.589584428 UTC

[section ""data" . GHC.Num.C:Num_closure" {
     GHC.Num.C:Num_closure:
         const GHC.Num.C:Num_info;
 },
 GHC.Num.C:Num_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmF2: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Num.C:Num_entry(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2,
                                    R1) args: 24, res: 0, upd: 8;
     }
 },
 GHC.Num.C:Num_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cmF7,
                       label: GHC.Num.C:Num_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmF7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cmFb; else goto cmFa;
       cmFb: // global
           HpAlloc = 64;
           R1 = GHC.Num.C:Num_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cmFa: // global
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.594785905 UTC

[GHC.Num.C:Num_con_entry() //  [R1]
         { info_tbl: [(cmFm,
                       label: GHC.Num.C:Num_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,78,117,109,46,67,58,78,117,109]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cmFm: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:55:00.597998566 UTC

[section ""relreadonly" . SmDC_srt" {
     SmDC_srt:
         const lvl_rlU7_closure;
         const GHC.Num.$dmnegate_closure;
 }]

