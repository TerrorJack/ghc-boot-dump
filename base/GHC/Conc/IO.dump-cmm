
==================== Output Cmm ====================
2018-03-16 16:05:53.849829427 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:53.850811183 UTC

[section ""data" . GHC.Conc.IO.ensureIOManagerIsRunning_closure" {
     GHC.Conc.IO.ensureIOManagerIsRunning_closure:
         const GHC.Conc.IO.ensureIOManagerIsRunning_info;
         const 0;
 },
 GHC.Conc.IO.ensureIOManagerIsRunning_entry() //  []
         { info_tbl: [(caTDl,
                       label: GHC.Conc.IO.ensureIOManagerIsRunning_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTDl: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.851937314 UTC

[section ""data" . GHC.Conc.IO.ioManagerCapabilitiesChanged_closure" {
     GHC.Conc.IO.ioManagerCapabilitiesChanged_closure:
         const GHC.Conc.IO.ioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Conc.IO.ioManagerCapabilitiesChanged_entry() //  []
         { info_tbl: [(caTDt,
                       label: GHC.Conc.IO.ioManagerCapabilitiesChanged_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTDt: // global
           call GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.852885772 UTC

[section ""cstring" . GHC.Conc.IO.$trModule4_bytes" {
     GHC.Conc.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.853694638 UTC

[section ""data" . GHC.Conc.IO.$trModule3_closure" {
     GHC.Conc.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.IO.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.85445371 UTC

[section ""cstring" . GHC.Conc.IO.$trModule2_bytes" {
     GHC.Conc.IO.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.855191622 UTC

[section ""data" . GHC.Conc.IO.$trModule1_closure" {
     GHC.Conc.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.IO.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.855978439 UTC

[section ""data" . GHC.Conc.IO.$trModule_closure" {
     GHC.Conc.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.IO.$trModule3_closure+1;
         const GHC.Conc.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.856723139 UTC

[section ""cstring" . lvl_raTBq_bytes" {
     lvl_raTBq_bytes:
         I8[] [114,101,103,105,115,116,101,114,68,101,108,97,121,58,32,114,101,113,117,105,114,101,115,32,45,116,104,114,101,97,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.857902339 UTC

[section ""data" . GHC.Conc.IO.registerDelay2_closure" {
     GHC.Conc.IO.registerDelay2_closure:
         const GHC.Conc.IO.registerDelay2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.IO.registerDelay2_entry() //  [R1]
         { info_tbl: [(caTDE,
                       label: GHC.Conc.IO.registerDelay2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTDE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caTDF; else goto caTDG;
       caTDF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caTDG: // global
           (_caTDz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caTDz::I64 == 0) goto caTDB; else goto caTDA;
       caTDB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caTDA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caTDz::I64;
           I64[Sp - 24] = block_caTDC_info;
           R2 = lvl_raTBq_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caTDC() //  [R1]
         { info_tbl: [(caTDC,
                       label: block_caTDC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTDC: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.859624907 UTC

[section ""data" . GHC.Conc.IO.registerDelay1_closure" {
     GHC.Conc.IO.registerDelay1_closure:
         const GHC.Conc.IO.registerDelay1_info;
         const 0;
 },
 GHC.Conc.IO.registerDelay1_entry() //  [R2]
         { info_tbl: [(caTDT,
                       label: GHC.Conc.IO.registerDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTDT: // global
           (_saTBy::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBy::I64 == 0) goto caTDS; else goto caTDR;
       caTDS: // global
           R1 = GHC.Conc.IO.registerDelay2_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       caTDR: // global
           R2 = R2;
           call GHC.Event.Thread.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.860901074 UTC

[section ""data" . GHC.Conc.IO.registerDelay_closure" {
     GHC.Conc.IO.registerDelay_closure:
         const GHC.Conc.IO.registerDelay_info;
         const 0;
 },
 GHC.Conc.IO.registerDelay_entry() //  [R2]
         { info_tbl: [(caTE0,
                       label: GHC.Conc.IO.registerDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTE0: // global
           R2 = R2;
           call GHC.Conc.IO.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.862324505 UTC

[section ""data" . GHC.Conc.IO.threadDelay1_closure" {
     GHC.Conc.IO.threadDelay1_closure:
         const GHC.Conc.IO.threadDelay1_info;
         const 0;
 },
 GHC.Conc.IO.threadDelay1_entry() //  [R2]
         { info_tbl: [(caTEc,
                       label: GHC.Conc.IO.threadDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTEc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTEd; else goto caTEe;
       caTEd: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTEe: // global
           (_saTBG::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBG::I64 == 0) goto caTEb; else goto caTEa;
       caTEb: // global
           I64[Sp - 8] = block_caTEh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaTEq; else goto caTEi;
       uaTEq: // global
           call _caTEh(R1) args: 0, res: 0, upd: 0;
       caTEi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caTEa: // global
           R2 = R2;
           call GHC.Event.Thread.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTEh() //  [R1]
         { info_tbl: [(caTEh,
                       label: block_caTEh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTEh: // global
           I64[Sp] = block_caTEm_info;
           R1 = I64[R1 + 7];
           call stg_delay#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTEm() //  []
         { info_tbl: [(caTEm,
                       label: block_caTEm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTEm: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.864028833 UTC

[section ""data" . GHC.Conc.IO.threadDelay_closure" {
     GHC.Conc.IO.threadDelay_closure:
         const GHC.Conc.IO.threadDelay_info;
         const 0;
 },
 GHC.Conc.IO.threadDelay_entry() //  [R2]
         { info_tbl: [(caTEv,
                       label: GHC.Conc.IO.threadDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTEv: // global
           R2 = R2;
           call GHC.Conc.IO.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.865061019 UTC

[section ""data" . GHC.Conc.IO.closeFdWith1_closure" {
     GHC.Conc.IO.closeFdWith1_closure:
         const GHC.Conc.IO.closeFdWith1_info;
         const 0;
 },
 GHC.Conc.IO.closeFdWith1_entry() //  [R2, R3]
         { info_tbl: [(caTEH,
                       label: GHC.Conc.IO.closeFdWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTEH: // global
           _saTBM::P64 = R3;
           (_saTBR::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBR::I64 == 0) goto caTEG; else goto caTEF;
       caTEG: // global
           _saTBL::P64 = R2;
           R2 = _saTBM::P64;
           R1 = _saTBL::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       caTEF: // global
           R3 = _saTBM::P64;
           R2 = R2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.866141646 UTC

[section ""data" . GHC.Conc.IO.closeFdWith_closure" {
     GHC.Conc.IO.closeFdWith_closure:
         const GHC.Conc.IO.closeFdWith_info;
         const 0;
 },
 GHC.Conc.IO.closeFdWith_entry() //  [R2, R3]
         { info_tbl: [(caTEO,
                       label: GHC.Conc.IO.closeFdWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTEO: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.IO.closeFdWith1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.867184699 UTC

[section ""data" . GHC.Conc.IO.threadWaitWrite1_closure" {
     GHC.Conc.IO.threadWaitWrite1_closure:
         const GHC.Conc.IO.threadWaitWrite1_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWrite1_entry() //  [R2]
         { info_tbl: [(caTF0,
                       label: GHC.Conc.IO.threadWaitWrite1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTF0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTF1; else goto caTF2;
       caTF1: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitWrite1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTF2: // global
           (_saTBY::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBY::I64 == 0) goto caTEZ; else goto caTEY;
       caTEZ: // global
           I64[Sp - 8] = block_caTF5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaTFe; else goto caTF6;
       uaTFe: // global
           call _caTF5(R1) args: 0, res: 0, upd: 0;
       caTF6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caTEY: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTF5() //  [R1]
         { info_tbl: [(caTF5,
                       label: block_caTF5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTF5: // global
           I64[Sp] = block_caTFa_info;
           R1 = I64[R1 + 7];
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTFa() //  []
         { info_tbl: [(caTFa,
                       label: block_caTFa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTFa: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.868524181 UTC

[section ""data" . GHC.Conc.IO.threadWaitWrite_closure" {
     GHC.Conc.IO.threadWaitWrite_closure:
         const GHC.Conc.IO.threadWaitWrite_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWrite_entry() //  [R2]
         { info_tbl: [(caTFj,
                       label: GHC.Conc.IO.threadWaitWrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTFj: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWrite1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.870704222 UTC

[section ""data" . GHC.Conc.IO.threadWaitWriteSTM1_closure" {
     GHC.Conc.IO.threadWaitWriteSTM1_closure:
         const GHC.Conc.IO.threadWaitWriteSTM1_info;
         const 0;
 },
 sat_saTCk_entry() //  [R1]
         { info_tbl: [(caTFU,
                       label: sat_saTCk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTFU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTFV; else goto caTFW;
       caTFV: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTFW: // global
           I64[Sp - 8] = block_caTFS_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTFS() //  []
         { info_tbl: [(caTFS,
                       label: block_caTFS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTFS: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTCl_entry() //  [R1]
         { info_tbl: [(caTFY,
                       label: sat_saTCl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTFY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTFZ; else goto caTG0;
       caTFZ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTG0: // global
           I64[Sp - 16] = block_caTFG_info;
           _saTCc::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saTCc::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaTG5; else goto caTFH;
       uaTG5: // global
           call _caTFG(R1) args: 0, res: 0, upd: 0;
       caTFH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTFG() //  [R1]
         { info_tbl: [(caTFG,
                       label: block_caTFG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTFG: // global
           I64[Sp] = block_caTFL_info;
           R1 = I64[R1 + 7];
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTFL() //  []
         { info_tbl: [(caTFL,
                       label: block_caTFL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTFL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caTG4; else goto caTG3;
       caTG4: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caTG3: // global
           I64[Hp - 8] = sat_saTCk_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTCm_entry() //  [R1]
         { info_tbl: [(caTG6,
                       label: sat_saTCm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTG6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTGa; else goto caTG9;
       caTGa: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTG9: // global
           _saTC3::P64 = P64[R1 + 7];
           _saTCc::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saTCl_info;
           P64[Hp - 8] = _saTC3::P64;
           P64[Hp] = _saTCc::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTCy_entry() //  [R1]
         { info_tbl: [(caTGk,
                       label: sat_saTCy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTGk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTGl; else goto caTGm;
       caTGl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTGm: // global
           I64[Sp - 8] = block_caTGi_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTGi() //  []
         { info_tbl: [(caTGi,
                       label: block_caTGi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTGi: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTCv_entry() //  [R1]
         { info_tbl: [(caTGC,
                       label: sat_saTCv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTGC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTGD; else goto caTGE;
       caTGD: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTGE: // global
           I64[Sp - 8] = block_caTGt_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTGt() //  [R1]
         { info_tbl: [(caTGt,
                       label: block_caTGt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTGt: // global
           I64[Sp] = block_caTGv_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaTGM; else goto caTGw;
       uaTGM: // global
           call _caTGv(R1) args: 0, res: 0, upd: 0;
       caTGw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTGv() //  [R1]
         { info_tbl: [(caTGv,
                       label: block_caTGv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTGv: // global
           if (R1 & 7 == 1) goto caTGz; else goto caTGA;
       caTGz: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caTGA: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.IO.threadWaitWriteSTM1_entry() //  [R2]
         { info_tbl: [(caTGQ,
                       label: GHC.Conc.IO.threadWaitWriteSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTGQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTGR; else goto caTGS;
       caTGR: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitWriteSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTGS: // global
           (_saTC8::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTC8::I64 == 0) goto caTGP; else goto caTGO;
       caTGP: // global
           I64[Sp - 16] = block_caTFu_info;
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
       caTGO: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTFu() //  [R1]
         { info_tbl: [(caTFu,
                       label: block_caTFu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTFu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTGW; else goto caTGV;
       caTGW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTGV: // global
           I64[Hp - 16] = sat_saTCm_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_caTGb_info;
           _saTCc::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _saTCc::P64;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTGb() //  [R1]
         { info_tbl: [(caTGb,
                       label: block_caTGb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTGb: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caTGZ; else goto caTGY;
       caTGZ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTGY: // global
           I64[Hp - 48] = sat_saTCy_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saTCv_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.874821828 UTC

[section ""data" . GHC.Conc.IO.threadWaitWriteSTM_closure" {
     GHC.Conc.IO.threadWaitWriteSTM_closure:
         const GHC.Conc.IO.threadWaitWriteSTM_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWriteSTM_entry() //  [R2]
         { info_tbl: [(caTH4,
                       label: GHC.Conc.IO.threadWaitWriteSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTH4: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWriteSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.875882854 UTC

[section ""data" . GHC.Conc.IO.threadWaitRead1_closure" {
     GHC.Conc.IO.threadWaitRead1_closure:
         const GHC.Conc.IO.threadWaitRead1_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitRead1_entry() //  [R2]
         { info_tbl: [(caTHg,
                       label: GHC.Conc.IO.threadWaitRead1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTHg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTHh; else goto caTHi;
       caTHh: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitRead1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTHi: // global
           (_saTCF::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTCF::I64 == 0) goto caTHf; else goto caTHe;
       caTHf: // global
           I64[Sp - 8] = block_caTHl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaTHu; else goto caTHm;
       uaTHu: // global
           call _caTHl(R1) args: 0, res: 0, upd: 0;
       caTHm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caTHe: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTHl() //  [R1]
         { info_tbl: [(caTHl,
                       label: block_caTHl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTHl: // global
           I64[Sp] = block_caTHq_info;
           R1 = I64[R1 + 7];
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTHq() //  []
         { info_tbl: [(caTHq,
                       label: block_caTHq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTHq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.877226455 UTC

[section ""data" . GHC.Conc.IO.threadWaitRead_closure" {
     GHC.Conc.IO.threadWaitRead_closure:
         const GHC.Conc.IO.threadWaitRead_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitRead_entry() //  [R2]
         { info_tbl: [(caTHz,
                       label: GHC.Conc.IO.threadWaitRead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTHz: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitRead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.880241406 UTC

[section ""data" . GHC.Conc.IO.threadWaitReadSTM1_closure" {
     GHC.Conc.IO.threadWaitReadSTM1_closure:
         const GHC.Conc.IO.threadWaitReadSTM1_info;
         const 0;
 },
 sat_saTD1_entry() //  [R1]
         { info_tbl: [(caTIa,
                       label: sat_saTD1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTIa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTIb; else goto caTIc;
       caTIb: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTIc: // global
           I64[Sp - 8] = block_caTI8_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTI8() //  []
         { info_tbl: [(caTI8,
                       label: block_caTI8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTI8: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTD2_entry() //  [R1]
         { info_tbl: [(caTIe,
                       label: sat_saTD2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTIe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTIf; else goto caTIg;
       caTIf: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTIg: // global
           I64[Sp - 16] = block_caTHW_info;
           _saTCT::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saTCT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaTIl; else goto caTHX;
       uaTIl: // global
           call _caTHW(R1) args: 0, res: 0, upd: 0;
       caTHX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTHW() //  [R1]
         { info_tbl: [(caTHW,
                       label: block_caTHW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTHW: // global
           I64[Sp] = block_caTI1_info;
           R1 = I64[R1 + 7];
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTI1() //  []
         { info_tbl: [(caTI1,
                       label: block_caTI1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTI1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caTIk; else goto caTIj;
       caTIk: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caTIj: // global
           I64[Hp - 8] = sat_saTD1_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTD3_entry() //  [R1]
         { info_tbl: [(caTIm,
                       label: sat_saTD3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTIm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTIq; else goto caTIp;
       caTIq: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTIp: // global
           _saTCK::P64 = P64[R1 + 7];
           _saTCT::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saTD2_info;
           P64[Hp - 8] = _saTCK::P64;
           P64[Hp] = _saTCT::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTDf_entry() //  [R1]
         { info_tbl: [(caTIA,
                       label: sat_saTDf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTIA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTIB; else goto caTIC;
       caTIB: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTIC: // global
           I64[Sp - 8] = block_caTIy_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTIy() //  []
         { info_tbl: [(caTIy,
                       label: block_caTIy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTIy: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTDc_entry() //  [R1]
         { info_tbl: [(caTIS,
                       label: sat_saTDc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTIS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTIT; else goto caTIU;
       caTIT: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTIU: // global
           I64[Sp - 8] = block_caTIJ_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTIJ() //  [R1]
         { info_tbl: [(caTIJ,
                       label: block_caTIJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTIJ: // global
           I64[Sp] = block_caTIL_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaTJ2; else goto caTIM;
       uaTJ2: // global
           call _caTIL(R1) args: 0, res: 0, upd: 0;
       caTIM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTIL() //  [R1]
         { info_tbl: [(caTIL,
                       label: block_caTIL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTIL: // global
           if (R1 & 7 == 1) goto caTIP; else goto caTIQ;
       caTIP: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caTIQ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.IO.threadWaitReadSTM1_entry() //  [R2]
         { info_tbl: [(caTJ6,
                       label: GHC.Conc.IO.threadWaitReadSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTJ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTJ7; else goto caTJ8;
       caTJ7: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitReadSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTJ8: // global
           (_saTCP::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTCP::I64 == 0) goto caTJ5; else goto caTJ4;
       caTJ5: // global
           I64[Sp - 16] = block_caTHK_info;
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
       caTJ4: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTHK() //  [R1]
         { info_tbl: [(caTHK,
                       label: block_caTHK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTHK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTJc; else goto caTJb;
       caTJc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTJb: // global
           I64[Hp - 16] = sat_saTD3_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_caTIr_info;
           _saTCT::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _saTCT::P64;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTIr() //  [R1]
         { info_tbl: [(caTIr,
                       label: block_caTIr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTIr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caTJf; else goto caTJe;
       caTJf: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTJe: // global
           I64[Hp - 48] = sat_saTDf_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saTDc_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.883810741 UTC

[section ""data" . GHC.Conc.IO.threadWaitReadSTM_closure" {
     GHC.Conc.IO.threadWaitReadSTM_closure:
         const GHC.Conc.IO.threadWaitReadSTM_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitReadSTM_entry() //  [R2]
         { info_tbl: [(caTJk,
                       label: GHC.Conc.IO.threadWaitReadSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTJk: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitReadSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.884501825 UTC

[section ""relreadonly" . SaTDo_srt" {
     SaTDo_srt:
         const GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Thread.registerDelay1_closure;
         const GHC.Conc.IO.registerDelay2_closure;
         const GHC.Conc.IO.registerDelay1_closure;
         const GHC.Event.Thread.threadDelay1_closure;
         const GHC.Conc.IO.threadDelay1_closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.Conc.IO.closeFdWith1_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitWrite1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Sync.killThread2_closure;
         const GHC.Event.Thread.threadWaitReadSTM1_closure;
         const GHC.Conc.IO.threadWaitWriteSTM1_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Conc.IO.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitReadSTM1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.885124746 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:53.886006499 UTC

[section ""data" . GHC.Conc.IO.ensureIOManagerIsRunning_closure" {
     GHC.Conc.IO.ensureIOManagerIsRunning_closure:
         const GHC.Conc.IO.ensureIOManagerIsRunning_info;
         const 0;
 },
 GHC.Conc.IO.ensureIOManagerIsRunning_entry() //  []
         { info_tbl: [(caTJr,
                       label: GHC.Conc.IO.ensureIOManagerIsRunning_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTJr: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.886788265 UTC

[section ""data" . GHC.Conc.IO.ioManagerCapabilitiesChanged_closure" {
     GHC.Conc.IO.ioManagerCapabilitiesChanged_closure:
         const GHC.Conc.IO.ioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Conc.IO.ioManagerCapabilitiesChanged_entry() //  []
         { info_tbl: [(caTJy,
                       label: GHC.Conc.IO.ioManagerCapabilitiesChanged_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTJy: // global
           call GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.88744826 UTC

[section ""cstring" . GHC.Conc.IO.$trModule4_bytes" {
     GHC.Conc.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.888022192 UTC

[section ""data" . GHC.Conc.IO.$trModule3_closure" {
     GHC.Conc.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.IO.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.888542883 UTC

[section ""cstring" . GHC.Conc.IO.$trModule2_bytes" {
     GHC.Conc.IO.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.889108734 UTC

[section ""data" . GHC.Conc.IO.$trModule1_closure" {
     GHC.Conc.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.IO.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.889711866 UTC

[section ""data" . GHC.Conc.IO.$trModule_closure" {
     GHC.Conc.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.IO.$trModule3_closure+1;
         const GHC.Conc.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.890279582 UTC

[section ""cstring" . lvl_raTBq_bytes" {
     lvl_raTBq_bytes:
         I8[] [114,101,103,105,115,116,101,114,68,101,108,97,121,58,32,114,101,113,117,105,114,101,115,32,45,116,104,114,101,97,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.89111047 UTC

[section ""data" . GHC.Conc.IO.registerDelay2_closure" {
     GHC.Conc.IO.registerDelay2_closure:
         const GHC.Conc.IO.registerDelay2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.IO.registerDelay2_entry() //  [R1]
         { info_tbl: [(caTJJ,
                       label: GHC.Conc.IO.registerDelay2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTJJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caTJK; else goto caTJL;
       caTJK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caTJL: // global
           (_caTJE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caTJE::I64 == 0) goto caTJG; else goto caTJF;
       caTJG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caTJF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caTJE::I64;
           I64[Sp - 24] = block_caTJH_info;
           R2 = lvl_raTBq_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caTJH() //  [R1]
         { info_tbl: [(caTJH,
                       label: block_caTJH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTJH: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.892297363 UTC

[section ""data" . GHC.Conc.IO.registerDelay1_closure" {
     GHC.Conc.IO.registerDelay1_closure:
         const GHC.Conc.IO.registerDelay1_info;
         const 0;
 },
 GHC.Conc.IO.registerDelay1_entry() //  [R2]
         { info_tbl: [(caTJY,
                       label: GHC.Conc.IO.registerDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTJY: // global
           (_saTBy::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBy::I64 == 0) goto caTJX; else goto caTJW;
       caTJX: // global
           R1 = GHC.Conc.IO.registerDelay2_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       caTJW: // global
           R2 = R2;
           call GHC.Event.Thread.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.893178425 UTC

[section ""data" . GHC.Conc.IO.registerDelay_closure" {
     GHC.Conc.IO.registerDelay_closure:
         const GHC.Conc.IO.registerDelay_info;
         const 0;
 },
 GHC.Conc.IO.registerDelay_entry() //  [R2]
         { info_tbl: [(caTK5,
                       label: GHC.Conc.IO.registerDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTK5: // global
           R2 = R2;
           call GHC.Conc.IO.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.894208153 UTC

[section ""data" . GHC.Conc.IO.threadDelay1_closure" {
     GHC.Conc.IO.threadDelay1_closure:
         const GHC.Conc.IO.threadDelay1_info;
         const 0;
 },
 GHC.Conc.IO.threadDelay1_entry() //  [R2]
         { info_tbl: [(caTKh,
                       label: GHC.Conc.IO.threadDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTKh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTKi; else goto caTKj;
       caTKi: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTKj: // global
           (_saTBG::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBG::I64 == 0) goto caTKg; else goto caTKf;
       caTKg: // global
           I64[Sp - 8] = block_caTKm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaTKv; else goto caTKn;
       uaTKv: // global
           call _caTKm(R1) args: 0, res: 0, upd: 0;
       caTKn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caTKf: // global
           R2 = R2;
           call GHC.Event.Thread.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTKm() //  [R1]
         { info_tbl: [(caTKm,
                       label: block_caTKm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTKm: // global
           I64[Sp] = block_caTKr_info;
           R1 = I64[R1 + 7];
           call stg_delay#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTKr() //  []
         { info_tbl: [(caTKr,
                       label: block_caTKr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTKr: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.895496261 UTC

[section ""data" . GHC.Conc.IO.threadDelay_closure" {
     GHC.Conc.IO.threadDelay_closure:
         const GHC.Conc.IO.threadDelay_info;
         const 0;
 },
 GHC.Conc.IO.threadDelay_entry() //  [R2]
         { info_tbl: [(caTKA,
                       label: GHC.Conc.IO.threadDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTKA: // global
           R2 = R2;
           call GHC.Conc.IO.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.896398639 UTC

[section ""data" . GHC.Conc.IO.closeFdWith1_closure" {
     GHC.Conc.IO.closeFdWith1_closure:
         const GHC.Conc.IO.closeFdWith1_info;
         const 0;
 },
 GHC.Conc.IO.closeFdWith1_entry() //  [R2, R3]
         { info_tbl: [(caTKM,
                       label: GHC.Conc.IO.closeFdWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTKM: // global
           _saTBM::P64 = R3;
           (_saTBR::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBR::I64 == 0) goto caTKL; else goto caTKK;
       caTKL: // global
           _saTBL::P64 = R2;
           R2 = _saTBM::P64;
           R1 = _saTBL::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       caTKK: // global
           R3 = _saTBM::P64;
           R2 = R2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.897587867 UTC

[section ""data" . GHC.Conc.IO.closeFdWith_closure" {
     GHC.Conc.IO.closeFdWith_closure:
         const GHC.Conc.IO.closeFdWith_info;
         const 0;
 },
 GHC.Conc.IO.closeFdWith_entry() //  [R2, R3]
         { info_tbl: [(caTKT,
                       label: GHC.Conc.IO.closeFdWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTKT: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.IO.closeFdWith1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.898623597 UTC

[section ""data" . GHC.Conc.IO.threadWaitWrite1_closure" {
     GHC.Conc.IO.threadWaitWrite1_closure:
         const GHC.Conc.IO.threadWaitWrite1_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWrite1_entry() //  [R2]
         { info_tbl: [(caTL5,
                       label: GHC.Conc.IO.threadWaitWrite1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTL5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTL6; else goto caTL7;
       caTL6: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitWrite1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTL7: // global
           (_saTBY::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBY::I64 == 0) goto caTL4; else goto caTL3;
       caTL4: // global
           I64[Sp - 8] = block_caTLa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaTLj; else goto caTLb;
       uaTLj: // global
           call _caTLa(R1) args: 0, res: 0, upd: 0;
       caTLb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caTL3: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTLa() //  [R1]
         { info_tbl: [(caTLa,
                       label: block_caTLa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTLa: // global
           I64[Sp] = block_caTLf_info;
           R1 = I64[R1 + 7];
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTLf() //  []
         { info_tbl: [(caTLf,
                       label: block_caTLf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTLf: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.899891671 UTC

[section ""data" . GHC.Conc.IO.threadWaitWrite_closure" {
     GHC.Conc.IO.threadWaitWrite_closure:
         const GHC.Conc.IO.threadWaitWrite_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWrite_entry() //  [R2]
         { info_tbl: [(caTLo,
                       label: GHC.Conc.IO.threadWaitWrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTLo: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWrite1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.902039152 UTC

[section ""data" . GHC.Conc.IO.threadWaitWriteSTM1_closure" {
     GHC.Conc.IO.threadWaitWriteSTM1_closure:
         const GHC.Conc.IO.threadWaitWriteSTM1_info;
         const 0;
 },
 sat_saTCk_entry() //  [R1]
         { info_tbl: [(caTLZ,
                       label: sat_saTCk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTLZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTM0; else goto caTM1;
       caTM0: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTM1: // global
           I64[Sp - 8] = block_caTLX_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTLX() //  []
         { info_tbl: [(caTLX,
                       label: block_caTLX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTLX: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTCl_entry() //  [R1]
         { info_tbl: [(caTM3,
                       label: sat_saTCl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTM3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTM4; else goto caTM5;
       caTM4: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTM5: // global
           I64[Sp - 16] = block_caTLL_info;
           _saTCc::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saTCc::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaTMa; else goto caTLM;
       uaTMa: // global
           call _caTLL(R1) args: 0, res: 0, upd: 0;
       caTLM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTLL() //  [R1]
         { info_tbl: [(caTLL,
                       label: block_caTLL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTLL: // global
           I64[Sp] = block_caTLQ_info;
           R1 = I64[R1 + 7];
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTLQ() //  []
         { info_tbl: [(caTLQ,
                       label: block_caTLQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTLQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caTM9; else goto caTM8;
       caTM9: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caTM8: // global
           I64[Hp - 8] = sat_saTCk_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTCm_entry() //  [R1]
         { info_tbl: [(caTMb,
                       label: sat_saTCm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTMb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTMf; else goto caTMe;
       caTMf: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTMe: // global
           _saTC3::P64 = P64[R1 + 7];
           _saTCc::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saTCl_info;
           P64[Hp - 8] = _saTC3::P64;
           P64[Hp] = _saTCc::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTCy_entry() //  [R1]
         { info_tbl: [(caTMp,
                       label: sat_saTCy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTMp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTMq; else goto caTMr;
       caTMq: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTMr: // global
           I64[Sp - 8] = block_caTMn_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTMn() //  []
         { info_tbl: [(caTMn,
                       label: block_caTMn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTMn: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTCv_entry() //  [R1]
         { info_tbl: [(caTMH,
                       label: sat_saTCv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTMH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTMI; else goto caTMJ;
       caTMI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTMJ: // global
           I64[Sp - 8] = block_caTMy_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTMy() //  [R1]
         { info_tbl: [(caTMy,
                       label: block_caTMy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTMy: // global
           I64[Sp] = block_caTMA_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaTMR; else goto caTMB;
       uaTMR: // global
           call _caTMA(R1) args: 0, res: 0, upd: 0;
       caTMB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTMA() //  [R1]
         { info_tbl: [(caTMA,
                       label: block_caTMA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTMA: // global
           if (R1 & 7 == 1) goto caTME; else goto caTMF;
       caTME: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caTMF: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.IO.threadWaitWriteSTM1_entry() //  [R2]
         { info_tbl: [(caTMV,
                       label: GHC.Conc.IO.threadWaitWriteSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTMV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTMW; else goto caTMX;
       caTMW: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitWriteSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTMX: // global
           (_saTC8::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTC8::I64 == 0) goto caTMU; else goto caTMT;
       caTMU: // global
           I64[Sp - 16] = block_caTLz_info;
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
       caTMT: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTLz() //  [R1]
         { info_tbl: [(caTLz,
                       label: block_caTLz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTLz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTN1; else goto caTN0;
       caTN1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTN0: // global
           I64[Hp - 16] = sat_saTCm_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_caTMg_info;
           _saTCc::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _saTCc::P64;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTMg() //  [R1]
         { info_tbl: [(caTMg,
                       label: block_caTMg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTMg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caTN4; else goto caTN3;
       caTN4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTN3: // global
           I64[Hp - 48] = sat_saTCy_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saTCv_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.905694549 UTC

[section ""data" . GHC.Conc.IO.threadWaitWriteSTM_closure" {
     GHC.Conc.IO.threadWaitWriteSTM_closure:
         const GHC.Conc.IO.threadWaitWriteSTM_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWriteSTM_entry() //  [R2]
         { info_tbl: [(caTN9,
                       label: GHC.Conc.IO.threadWaitWriteSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTN9: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWriteSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.906747146 UTC

[section ""data" . GHC.Conc.IO.threadWaitRead1_closure" {
     GHC.Conc.IO.threadWaitRead1_closure:
         const GHC.Conc.IO.threadWaitRead1_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitRead1_entry() //  [R2]
         { info_tbl: [(caTNl,
                       label: GHC.Conc.IO.threadWaitRead1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTNl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTNm; else goto caTNn;
       caTNm: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitRead1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTNn: // global
           (_saTCF::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTCF::I64 == 0) goto caTNk; else goto caTNj;
       caTNk: // global
           I64[Sp - 8] = block_caTNq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaTNz; else goto caTNr;
       uaTNz: // global
           call _caTNq(R1) args: 0, res: 0, upd: 0;
       caTNr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caTNj: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTNq() //  [R1]
         { info_tbl: [(caTNq,
                       label: block_caTNq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTNq: // global
           I64[Sp] = block_caTNv_info;
           R1 = I64[R1 + 7];
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTNv() //  []
         { info_tbl: [(caTNv,
                       label: block_caTNv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTNv: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.908079957 UTC

[section ""data" . GHC.Conc.IO.threadWaitRead_closure" {
     GHC.Conc.IO.threadWaitRead_closure:
         const GHC.Conc.IO.threadWaitRead_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitRead_entry() //  [R2]
         { info_tbl: [(caTNE,
                       label: GHC.Conc.IO.threadWaitRead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTNE: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitRead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.910205665 UTC

[section ""data" . GHC.Conc.IO.threadWaitReadSTM1_closure" {
     GHC.Conc.IO.threadWaitReadSTM1_closure:
         const GHC.Conc.IO.threadWaitReadSTM1_info;
         const 0;
 },
 sat_saTD1_entry() //  [R1]
         { info_tbl: [(caTOf,
                       label: sat_saTD1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTOf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTOg; else goto caTOh;
       caTOg: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTOh: // global
           I64[Sp - 8] = block_caTOd_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTOd() //  []
         { info_tbl: [(caTOd,
                       label: block_caTOd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTOd: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTD2_entry() //  [R1]
         { info_tbl: [(caTOj,
                       label: sat_saTD2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTOj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTOk; else goto caTOl;
       caTOk: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTOl: // global
           I64[Sp - 16] = block_caTO1_info;
           _saTCT::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saTCT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaTOq; else goto caTO2;
       uaTOq: // global
           call _caTO1(R1) args: 0, res: 0, upd: 0;
       caTO2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTO1() //  [R1]
         { info_tbl: [(caTO1,
                       label: block_caTO1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTO1: // global
           I64[Sp] = block_caTO6_info;
           R1 = I64[R1 + 7];
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTO6() //  []
         { info_tbl: [(caTO6,
                       label: block_caTO6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTO6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caTOp; else goto caTOo;
       caTOp: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caTOo: // global
           I64[Hp - 8] = sat_saTD1_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTD3_entry() //  [R1]
         { info_tbl: [(caTOr,
                       label: sat_saTD3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTOr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTOv; else goto caTOu;
       caTOv: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTOu: // global
           _saTCK::P64 = P64[R1 + 7];
           _saTCT::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saTD2_info;
           P64[Hp - 8] = _saTCK::P64;
           P64[Hp] = _saTCT::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTDf_entry() //  [R1]
         { info_tbl: [(caTOF,
                       label: sat_saTDf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTOF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTOG; else goto caTOH;
       caTOG: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTOH: // global
           I64[Sp - 8] = block_caTOD_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTOD() //  []
         { info_tbl: [(caTOD,
                       label: block_caTOD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTOD: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTDc_entry() //  [R1]
         { info_tbl: [(caTOX,
                       label: sat_saTDc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTOX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTOY; else goto caTOZ;
       caTOY: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTOZ: // global
           I64[Sp - 8] = block_caTOO_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTOO() //  [R1]
         { info_tbl: [(caTOO,
                       label: block_caTOO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTOO: // global
           I64[Sp] = block_caTOQ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaTP7; else goto caTOR;
       uaTP7: // global
           call _caTOQ(R1) args: 0, res: 0, upd: 0;
       caTOR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTOQ() //  [R1]
         { info_tbl: [(caTOQ,
                       label: block_caTOQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTOQ: // global
           if (R1 & 7 == 1) goto caTOU; else goto caTOV;
       caTOU: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caTOV: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.IO.threadWaitReadSTM1_entry() //  [R2]
         { info_tbl: [(caTPb,
                       label: GHC.Conc.IO.threadWaitReadSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTPb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTPc; else goto caTPd;
       caTPc: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitReadSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTPd: // global
           (_saTCP::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTCP::I64 == 0) goto caTPa; else goto caTP9;
       caTPa: // global
           I64[Sp - 16] = block_caTNP_info;
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
       caTP9: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTNP() //  [R1]
         { info_tbl: [(caTNP,
                       label: block_caTNP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTNP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTPh; else goto caTPg;
       caTPh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTPg: // global
           I64[Hp - 16] = sat_saTD3_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_caTOw_info;
           _saTCT::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _saTCT::P64;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTOw() //  [R1]
         { info_tbl: [(caTOw,
                       label: block_caTOw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTOw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caTPk; else goto caTPj;
       caTPk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTPj: // global
           I64[Hp - 48] = sat_saTDf_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saTDc_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.913971375 UTC

[section ""data" . GHC.Conc.IO.threadWaitReadSTM_closure" {
     GHC.Conc.IO.threadWaitReadSTM_closure:
         const GHC.Conc.IO.threadWaitReadSTM_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitReadSTM_entry() //  [R2]
         { info_tbl: [(caTPp,
                       label: GHC.Conc.IO.threadWaitReadSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTPp: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitReadSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.914713642 UTC

[section ""relreadonly" . SaTDo_srt" {
     SaTDo_srt:
         const GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Thread.registerDelay1_closure;
         const GHC.Conc.IO.registerDelay2_closure;
         const GHC.Conc.IO.registerDelay1_closure;
         const GHC.Event.Thread.threadDelay1_closure;
         const GHC.Conc.IO.threadDelay1_closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.Conc.IO.closeFdWith1_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitWrite1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Sync.killThread2_closure;
         const GHC.Event.Thread.threadWaitReadSTM1_closure;
         const GHC.Conc.IO.threadWaitWriteSTM1_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Conc.IO.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitReadSTM1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.915679442 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:53.918642672 UTC

[section ""data" . GHC.Conc.IO.ensureIOManagerIsRunning_closure" {
     GHC.Conc.IO.ensureIOManagerIsRunning_closure:
         const GHC.Conc.IO.ensureIOManagerIsRunning_info;
         const 0;
 },
 GHC.Conc.IO.ensureIOManagerIsRunning_entry() //  []
         { info_tbl: [(caTPw,
                       label: GHC.Conc.IO.ensureIOManagerIsRunning_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTPw: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.922017337 UTC

[section ""data" . GHC.Conc.IO.ioManagerCapabilitiesChanged_closure" {
     GHC.Conc.IO.ioManagerCapabilitiesChanged_closure:
         const GHC.Conc.IO.ioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Conc.IO.ioManagerCapabilitiesChanged_entry() //  []
         { info_tbl: [(caTPH,
                       label: GHC.Conc.IO.ioManagerCapabilitiesChanged_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTPH: // global
           call GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.925154605 UTC

[section ""cstring" . GHC.Conc.IO.$trModule4_bytes" {
     GHC.Conc.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.926870241 UTC

[section ""data" . GHC.Conc.IO.$trModule3_closure" {
     GHC.Conc.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.IO.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.928603299 UTC

[section ""cstring" . GHC.Conc.IO.$trModule2_bytes" {
     GHC.Conc.IO.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.930444686 UTC

[section ""data" . GHC.Conc.IO.$trModule1_closure" {
     GHC.Conc.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.IO.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.932156484 UTC

[section ""data" . GHC.Conc.IO.$trModule_closure" {
     GHC.Conc.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.IO.$trModule3_closure+1;
         const GHC.Conc.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.933907735 UTC

[section ""cstring" . lvl_raTBq_bytes" {
     lvl_raTBq_bytes:
         I8[] [114,101,103,105,115,116,101,114,68,101,108,97,121,58,32,114,101,113,117,105,114,101,115,32,45,116,104,114,101,97,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.935879174 UTC

[section ""data" . GHC.Conc.IO.registerDelay2_closure" {
     GHC.Conc.IO.registerDelay2_closure:
         const GHC.Conc.IO.registerDelay2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.IO.registerDelay2_entry() //  [R1]
         { info_tbl: [(caTQ2,
                       label: GHC.Conc.IO.registerDelay2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTQ2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caTQ3; else goto caTQ4;
       caTQ3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caTQ4: // global
           (_caTPX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caTPX::I64 == 0) goto caTPZ; else goto caTPY;
       caTPZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caTPY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caTPX::I64;
           I64[Sp - 24] = block_caTQ0_info;
           R2 = lvl_raTBq_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caTQ0() //  [R1]
         { info_tbl: [(caTQ0,
                       label: block_caTQ0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTQ0: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.942152428 UTC

[section ""data" . GHC.Conc.IO.registerDelay1_closure" {
     GHC.Conc.IO.registerDelay1_closure:
         const GHC.Conc.IO.registerDelay1_info;
         const 0;
 },
 GHC.Conc.IO.registerDelay1_entry() //  [R2]
         { info_tbl: [(caTQr,
                       label: GHC.Conc.IO.registerDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTQr: // global
           (_saTBy::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBy::I64 == 0) goto caTQq; else goto caTQp;
       caTQq: // global
           R1 = GHC.Conc.IO.registerDelay2_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       caTQp: // global
           R2 = R2;
           call GHC.Event.Thread.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.945825713 UTC

[section ""data" . GHC.Conc.IO.registerDelay_closure" {
     GHC.Conc.IO.registerDelay_closure:
         const GHC.Conc.IO.registerDelay_info;
         const 0;
 },
 GHC.Conc.IO.registerDelay_entry() //  [R2]
         { info_tbl: [(caTQC,
                       label: GHC.Conc.IO.registerDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTQC: // global
           R2 = R2;
           call GHC.Conc.IO.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.950058674 UTC

[section ""data" . GHC.Conc.IO.threadDelay1_closure" {
     GHC.Conc.IO.threadDelay1_closure:
         const GHC.Conc.IO.threadDelay1_info;
         const 0;
 },
 GHC.Conc.IO.threadDelay1_entry() //  [R2]
         { info_tbl: [(caTQS,
                       label: GHC.Conc.IO.threadDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTQS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTQT; else goto caTQU;
       caTQT: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTQU: // global
           (_saTBG::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBG::I64 == 0) goto caTQR; else goto caTQQ;
       caTQR: // global
           I64[Sp - 8] = block_caTQX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaTR6; else goto caTQY;
       uaTR6: // global
           call _caTQX(R1) args: 0, res: 0, upd: 0;
       caTQY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caTQQ: // global
           R2 = R2;
           call GHC.Event.Thread.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTQX() //  [R1]
         { info_tbl: [(caTQX,
                       label: block_caTQX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTQX: // global
           I64[Sp] = block_caTR2_info;
           R1 = I64[R1 + 7];
           call stg_delay#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTR2() //  []
         { info_tbl: [(caTR2,
                       label: block_caTR2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTR2: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.957208413 UTC

[section ""data" . GHC.Conc.IO.threadDelay_closure" {
     GHC.Conc.IO.threadDelay_closure:
         const GHC.Conc.IO.threadDelay_info;
         const 0;
 },
 GHC.Conc.IO.threadDelay_entry() //  [R2]
         { info_tbl: [(caTRo,
                       label: GHC.Conc.IO.threadDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTRo: // global
           R2 = R2;
           call GHC.Conc.IO.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.960507697 UTC

[section ""data" . GHC.Conc.IO.closeFdWith1_closure" {
     GHC.Conc.IO.closeFdWith1_closure:
         const GHC.Conc.IO.closeFdWith1_info;
         const 0;
 },
 GHC.Conc.IO.closeFdWith1_entry() //  [R2, R3]
         { info_tbl: [(caTRE,
                       label: GHC.Conc.IO.closeFdWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTRE: // global
           _saTBM::P64 = R3;
           (_saTBR::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBR::I64 == 0) goto caTRD; else goto caTRC;
       caTRD: // global
           _saTBL::P64 = R2;
           R2 = _saTBM::P64;
           R1 = _saTBL::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       caTRC: // global
           R3 = _saTBM::P64;
           R2 = R2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.96412773 UTC

[section ""data" . GHC.Conc.IO.closeFdWith_closure" {
     GHC.Conc.IO.closeFdWith_closure:
         const GHC.Conc.IO.closeFdWith_info;
         const 0;
 },
 GHC.Conc.IO.closeFdWith_entry() //  [R2, R3]
         { info_tbl: [(caTRP,
                       label: GHC.Conc.IO.closeFdWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTRP: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.IO.closeFdWith1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.967971923 UTC

[section ""data" . GHC.Conc.IO.threadWaitWrite1_closure" {
     GHC.Conc.IO.threadWaitWrite1_closure:
         const GHC.Conc.IO.threadWaitWrite1_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWrite1_entry() //  [R2]
         { info_tbl: [(caTS5,
                       label: GHC.Conc.IO.threadWaitWrite1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTS5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTS6; else goto caTS7;
       caTS6: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitWrite1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTS7: // global
           (_saTBY::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBY::I64 == 0) goto caTS4; else goto caTS3;
       caTS4: // global
           I64[Sp - 8] = block_caTSa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaTSj; else goto caTSb;
       uaTSj: // global
           call _caTSa(R1) args: 0, res: 0, upd: 0;
       caTSb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caTS3: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTSa() //  [R1]
         { info_tbl: [(caTSa,
                       label: block_caTSa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTSa: // global
           I64[Sp] = block_caTSf_info;
           R1 = I64[R1 + 7];
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTSf() //  []
         { info_tbl: [(caTSf,
                       label: block_caTSf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTSf: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.975025227 UTC

[section ""data" . GHC.Conc.IO.threadWaitWrite_closure" {
     GHC.Conc.IO.threadWaitWrite_closure:
         const GHC.Conc.IO.threadWaitWrite_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWrite_entry() //  [R2]
         { info_tbl: [(caTSB,
                       label: GHC.Conc.IO.threadWaitWrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTSB: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWrite1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:53.980058589 UTC

[section ""data" . GHC.Conc.IO.threadWaitWriteSTM1_closure" {
     GHC.Conc.IO.threadWaitWriteSTM1_closure:
         const GHC.Conc.IO.threadWaitWriteSTM1_info;
         const 0;
 },
 sat_saTCk_entry() //  [R1]
         { info_tbl: [(caTTg,
                       label: sat_saTCk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTTg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTTh; else goto caTTi;
       caTTh: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTTi: // global
           I64[Sp - 8] = block_caTTe_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTTe() //  []
         { info_tbl: [(caTTe,
                       label: block_caTTe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTTe: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTCl_entry() //  [R1]
         { info_tbl: [(caTTk,
                       label: sat_saTCl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTTk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTTl; else goto caTTm;
       caTTl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTTm: // global
           I64[Sp - 16] = block_caTT2_info;
           _saTCc::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saTCc::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaTTr; else goto caTT3;
       uaTTr: // global
           call _caTT2(R1) args: 0, res: 0, upd: 0;
       caTT3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTT2() //  [R1]
         { info_tbl: [(caTT2,
                       label: block_caTT2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTT2: // global
           I64[Sp] = block_caTT7_info;
           R1 = I64[R1 + 7];
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTT7() //  []
         { info_tbl: [(caTT7,
                       label: block_caTT7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTT7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caTTq; else goto caTTp;
       caTTq: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caTTp: // global
           I64[Hp - 8] = sat_saTCk_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTCm_entry() //  [R1]
         { info_tbl: [(caTTs,
                       label: sat_saTCm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTTs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTTw; else goto caTTv;
       caTTw: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTTv: // global
           _saTC3::P64 = P64[R1 + 7];
           _saTCc::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saTCl_info;
           P64[Hp - 8] = _saTC3::P64;
           P64[Hp] = _saTCc::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTCy_entry() //  [R1]
         { info_tbl: [(caTTG,
                       label: sat_saTCy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTTG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTTH; else goto caTTI;
       caTTH: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTTI: // global
           I64[Sp - 8] = block_caTTE_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTTE() //  []
         { info_tbl: [(caTTE,
                       label: block_caTTE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTTE: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTCv_entry() //  [R1]
         { info_tbl: [(caTTY,
                       label: sat_saTCv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTTY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTTZ; else goto caTU0;
       caTTZ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTU0: // global
           I64[Sp - 8] = block_caTTP_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTTP() //  [R1]
         { info_tbl: [(caTTP,
                       label: block_caTTP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTTP: // global
           I64[Sp] = block_caTTR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaTU8; else goto caTTS;
       uaTU8: // global
           call _caTTR(R1) args: 0, res: 0, upd: 0;
       caTTS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTTR() //  [R1]
         { info_tbl: [(caTTR,
                       label: block_caTTR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTTR: // global
           if (R1 & 7 == 1) goto caTTV; else goto caTTW;
       caTTV: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caTTW: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.IO.threadWaitWriteSTM1_entry() //  [R2]
         { info_tbl: [(caTUc,
                       label: GHC.Conc.IO.threadWaitWriteSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTUc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTUd; else goto caTUe;
       caTUd: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitWriteSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTUe: // global
           (_saTC8::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTC8::I64 == 0) goto caTUb; else goto caTUa;
       caTUb: // global
           I64[Sp - 16] = block_caTSQ_info;
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
       caTUa: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTSQ() //  [R1]
         { info_tbl: [(caTSQ,
                       label: block_caTSQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTSQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTUi; else goto caTUh;
       caTUi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTUh: // global
           I64[Hp - 16] = sat_saTCm_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_caTTx_info;
           _saTCc::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _saTCc::P64;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTTx() //  [R1]
         { info_tbl: [(caTTx,
                       label: block_caTTx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTTx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caTUl; else goto caTUk;
       caTUl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTUk: // global
           I64[Hp - 48] = sat_saTCy_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saTCv_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.006646735 UTC

[section ""data" . GHC.Conc.IO.threadWaitWriteSTM_closure" {
     GHC.Conc.IO.threadWaitWriteSTM_closure:
         const GHC.Conc.IO.threadWaitWriteSTM_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWriteSTM_entry() //  [R2]
         { info_tbl: [(caTVp,
                       label: GHC.Conc.IO.threadWaitWriteSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTVp: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWriteSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.010165257 UTC

[section ""data" . GHC.Conc.IO.threadWaitRead1_closure" {
     GHC.Conc.IO.threadWaitRead1_closure:
         const GHC.Conc.IO.threadWaitRead1_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitRead1_entry() //  [R2]
         { info_tbl: [(caTVF,
                       label: GHC.Conc.IO.threadWaitRead1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTVF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTVG; else goto caTVH;
       caTVG: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitRead1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTVH: // global
           (_saTCF::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTCF::I64 == 0) goto caTVE; else goto caTVD;
       caTVE: // global
           I64[Sp - 8] = block_caTVK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaTVT; else goto caTVL;
       uaTVT: // global
           call _caTVK(R1) args: 0, res: 0, upd: 0;
       caTVL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caTVD: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTVK() //  [R1]
         { info_tbl: [(caTVK,
                       label: block_caTVK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTVK: // global
           I64[Sp] = block_caTVP_info;
           R1 = I64[R1 + 7];
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTVP() //  []
         { info_tbl: [(caTVP,
                       label: block_caTVP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTVP: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.018059252 UTC

[section ""data" . GHC.Conc.IO.threadWaitRead_closure" {
     GHC.Conc.IO.threadWaitRead_closure:
         const GHC.Conc.IO.threadWaitRead_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitRead_entry() //  [R2]
         { info_tbl: [(caTWb,
                       label: GHC.Conc.IO.threadWaitRead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTWb: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitRead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.022479894 UTC

[section ""data" . GHC.Conc.IO.threadWaitReadSTM1_closure" {
     GHC.Conc.IO.threadWaitReadSTM1_closure:
         const GHC.Conc.IO.threadWaitReadSTM1_info;
         const 0;
 },
 sat_saTD1_entry() //  [R1]
         { info_tbl: [(caTWQ,
                       label: sat_saTD1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTWQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTWR; else goto caTWS;
       caTWR: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTWS: // global
           I64[Sp - 8] = block_caTWO_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTWO() //  []
         { info_tbl: [(caTWO,
                       label: block_caTWO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTWO: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTD2_entry() //  [R1]
         { info_tbl: [(caTWU,
                       label: sat_saTD2_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTWU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTWV; else goto caTWW;
       caTWV: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTWW: // global
           I64[Sp - 16] = block_caTWC_info;
           _saTCT::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saTCT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaTX1; else goto caTWD;
       uaTX1: // global
           call _caTWC(R1) args: 0, res: 0, upd: 0;
       caTWD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTWC() //  [R1]
         { info_tbl: [(caTWC,
                       label: block_caTWC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTWC: // global
           I64[Sp] = block_caTWH_info;
           R1 = I64[R1 + 7];
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTWH() //  []
         { info_tbl: [(caTWH,
                       label: block_caTWH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTWH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caTX0; else goto caTWZ;
       caTX0: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caTWZ: // global
           I64[Hp - 8] = sat_saTD1_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTD3_entry() //  [R1]
         { info_tbl: [(caTX2,
                       label: sat_saTD3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTX2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTX6; else goto caTX5;
       caTX6: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTX5: // global
           _saTCK::P64 = P64[R1 + 7];
           _saTCT::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saTD2_info;
           P64[Hp - 8] = _saTCK::P64;
           P64[Hp] = _saTCT::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTDf_entry() //  [R1]
         { info_tbl: [(caTXg,
                       label: sat_saTDf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTXg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTXh; else goto caTXi;
       caTXh: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTXi: // global
           I64[Sp - 8] = block_caTXe_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTXe() //  []
         { info_tbl: [(caTXe,
                       label: block_caTXe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTXe: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saTDc_entry() //  [R1]
         { info_tbl: [(caTXy,
                       label: sat_saTDc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTXy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTXz; else goto caTXA;
       caTXz: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTXA: // global
           I64[Sp - 8] = block_caTXp_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTXp() //  [R1]
         { info_tbl: [(caTXp,
                       label: block_caTXp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTXp: // global
           I64[Sp] = block_caTXr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaTXI; else goto caTXs;
       uaTXI: // global
           call _caTXr(R1) args: 0, res: 0, upd: 0;
       caTXs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTXr() //  [R1]
         { info_tbl: [(caTXr,
                       label: block_caTXr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTXr: // global
           if (R1 & 7 == 1) goto caTXv; else goto caTXw;
       caTXv: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caTXw: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.IO.threadWaitReadSTM1_entry() //  [R2]
         { info_tbl: [(caTXM,
                       label: GHC.Conc.IO.threadWaitReadSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTXM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTXN; else goto caTXO;
       caTXN: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitReadSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTXO: // global
           (_saTCP::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTCP::I64 == 0) goto caTXL; else goto caTXK;
       caTXL: // global
           I64[Sp - 16] = block_caTWq_info;
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
       caTXK: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 _caTWq() //  [R1]
         { info_tbl: [(caTWq,
                       label: block_caTWq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTWq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTXS; else goto caTXR;
       caTXS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTXR: // global
           I64[Hp - 16] = sat_saTD3_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_caTX7_info;
           _saTCT::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _saTCT::P64;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caTX7() //  [R1]
         { info_tbl: [(caTX7,
                       label: block_caTX7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTX7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caTXV; else goto caTXU;
       caTXV: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTXU: // global
           I64[Hp - 48] = sat_saTDf_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saTDc_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.04871191 UTC

[section ""data" . GHC.Conc.IO.threadWaitReadSTM_closure" {
     GHC.Conc.IO.threadWaitReadSTM_closure:
         const GHC.Conc.IO.threadWaitReadSTM_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitReadSTM_entry() //  [R2]
         { info_tbl: [(caTYZ,
                       label: GHC.Conc.IO.threadWaitReadSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caTYZ: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitReadSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.052439823 UTC

[section ""relreadonly" . SaTDo_srt" {
     SaTDo_srt:
         const GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Thread.registerDelay1_closure;
         const GHC.Conc.IO.registerDelay2_closure;
         const GHC.Conc.IO.registerDelay1_closure;
         const GHC.Event.Thread.threadDelay1_closure;
         const GHC.Conc.IO.threadDelay1_closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.Conc.IO.closeFdWith1_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitWrite1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Sync.killThread2_closure;
         const GHC.Event.Thread.threadWaitReadSTM1_closure;
         const GHC.Conc.IO.threadWaitWriteSTM1_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Conc.IO.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitReadSTM1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.334611255 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:54.335825382 UTC

[section ""data" . GHC.Conc.IO.ensureIOManagerIsRunning_closure" {
     GHC.Conc.IO.ensureIOManagerIsRunning_closure:
         const GHC.Conc.IO.ensureIOManagerIsRunning_info;
         const 0;
 },
 GHC.Conc.IO.ensureIOManagerIsRunning_entry() //  []
         { info_tbl: [(caU10,
                       label: GHC.Conc.IO.ensureIOManagerIsRunning_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU10: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.339436267 UTC

[section ""data" . GHC.Conc.IO.ioManagerCapabilitiesChanged_closure" {
     GHC.Conc.IO.ioManagerCapabilitiesChanged_closure:
         const GHC.Conc.IO.ioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Conc.IO.ioManagerCapabilitiesChanged_entry() //  []
         { info_tbl: [(caU1c,
                       label: GHC.Conc.IO.ioManagerCapabilitiesChanged_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU1c: // global
           call GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.344706107 UTC

[section ""cstring" . GHC.Conc.IO.$trModule4_bytes" {
     GHC.Conc.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.346450118 UTC

[section ""data" . GHC.Conc.IO.$trModule3_closure" {
     GHC.Conc.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.IO.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.348101691 UTC

[section ""cstring" . GHC.Conc.IO.$trModule2_bytes" {
     GHC.Conc.IO.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.34979966 UTC

[section ""data" . GHC.Conc.IO.$trModule1_closure" {
     GHC.Conc.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.IO.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.351448407 UTC

[section ""data" . GHC.Conc.IO.$trModule_closure" {
     GHC.Conc.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.IO.$trModule3_closure+1;
         const GHC.Conc.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.353171406 UTC

[section ""cstring" . lvl_raTBq_bytes" {
     lvl_raTBq_bytes:
         I8[] [114,101,103,105,115,116,101,114,68,101,108,97,121,58,32,114,101,113,117,105,114,101,115,32,45,116,104,114,101,97,100,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.355284246 UTC

[section ""data" . GHC.Conc.IO.registerDelay2_closure" {
     GHC.Conc.IO.registerDelay2_closure:
         const GHC.Conc.IO.registerDelay2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.IO.registerDelay2_entry() //  [R1]
         { info_tbl: [(caU1x,
                       label: GHC.Conc.IO.registerDelay2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU1x: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caU1y; else goto caU1z;
       caU1y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caU1z: // global
           (_caU1s::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caU1s::I64 == 0) goto caU1u; else goto caU1t;
       caU1u: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caU1t: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caU1s::I64;
           I64[Sp - 24] = block_caU1v_info;
           R2 = lvl_raTBq_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caU1v() //  [R1]
         { info_tbl: [(caU1v,
                       label: block_caU1v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU1v: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.361596378 UTC

[section ""data" . GHC.Conc.IO.registerDelay1_closure" {
     GHC.Conc.IO.registerDelay1_closure:
         const GHC.Conc.IO.registerDelay1_info;
         const 0;
 },
 GHC.Conc.IO.registerDelay1_entry() //  [R2]
         { info_tbl: [(caU1Y,
                       label: GHC.Conc.IO.registerDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU1Y: // global
           (_saTZd::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTZd::I64 == 0) goto caU1X; else goto caU1W;
       caU1X: // global
           R1 = GHC.Conc.IO.registerDelay2_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       caU1W: // global
           R2 = R2;
           call GHC.Event.Thread.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.365211114 UTC

[section ""data" . GHC.Conc.IO.registerDelay_closure" {
     GHC.Conc.IO.registerDelay_closure:
         const GHC.Conc.IO.registerDelay_info;
         const 0;
 },
 GHC.Conc.IO.registerDelay_entry() //  [R2]
         { info_tbl: [(caU29,
                       label: GHC.Conc.IO.registerDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU29: // global
           R2 = R2;
           call GHC.Conc.IO.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.368990083 UTC

[section ""data" . GHC.Conc.IO.threadDelay1_closure" {
     GHC.Conc.IO.threadDelay1_closure:
         const GHC.Conc.IO.threadDelay1_info;
         const 0;
 },
 GHC.Conc.IO.threadDelay1_entry() //  [R2]
         { info_tbl: [(caU2p,
                       label: GHC.Conc.IO.threadDelay1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU2p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU2q; else goto caU2r;
       caU2q: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caU2r: // global
           (_saTZl::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTZl::I64 == 0) goto caU2o; else goto caU2n;
       caU2o: // global
           I64[Sp - 8] = block_caU2u_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaU2D; else goto caU2v;
       uaU2D: // global
           call _caU2u(R1) args: 0, res: 0, upd: 0;
       caU2v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caU2n: // global
           R2 = R2;
           call GHC.Event.Thread.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _caU2u() //  [R1]
         { info_tbl: [(caU2u,
                       label: block_caU2u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU2u: // global
           I64[Sp] = block_caU2z_info;
           R1 = I64[R1 + 7];
           call stg_delay#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU2z() //  []
         { info_tbl: [(caU2z,
                       label: block_caU2z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU2z: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.377169836 UTC

[section ""data" . GHC.Conc.IO.threadDelay_closure" {
     GHC.Conc.IO.threadDelay_closure:
         const GHC.Conc.IO.threadDelay_info;
         const 0;
 },
 GHC.Conc.IO.threadDelay_entry() //  [R2]
         { info_tbl: [(caU2Y,
                       label: GHC.Conc.IO.threadDelay_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU2Y: // global
           R2 = R2;
           call GHC.Conc.IO.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.380616426 UTC

[section ""data" . GHC.Conc.IO.closeFdWith1_closure" {
     GHC.Conc.IO.closeFdWith1_closure:
         const GHC.Conc.IO.closeFdWith1_info;
         const 0;
 },
 GHC.Conc.IO.closeFdWith1_entry() //  [R2, R3]
         { info_tbl: [(caU3e,
                       label: GHC.Conc.IO.closeFdWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU3e: // global
           _saTZr::P64 = R3;
           (_saTZw::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTZw::I64 == 0) goto caU3d; else goto caU3c;
       caU3d: // global
           _saTZq::P64 = R2;
           R2 = _saTZr::P64;
           R1 = _saTZq::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       caU3c: // global
           R3 = _saTZr::P64;
           R2 = R2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.384757525 UTC

[section ""data" . GHC.Conc.IO.closeFdWith_closure" {
     GHC.Conc.IO.closeFdWith_closure:
         const GHC.Conc.IO.closeFdWith_info;
         const 0;
 },
 GHC.Conc.IO.closeFdWith_entry() //  [R2, R3]
         { info_tbl: [(caU3p,
                       label: GHC.Conc.IO.closeFdWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU3p: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.IO.closeFdWith1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.388366372 UTC

[section ""data" . GHC.Conc.IO.threadWaitWrite1_closure" {
     GHC.Conc.IO.threadWaitWrite1_closure:
         const GHC.Conc.IO.threadWaitWrite1_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWrite1_entry() //  [R2]
         { info_tbl: [(caU3F,
                       label: GHC.Conc.IO.threadWaitWrite1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU3F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU3G; else goto caU3H;
       caU3G: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitWrite1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caU3H: // global
           (_saTZD::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTZD::I64 == 0) goto caU3E; else goto caU3D;
       caU3E: // global
           I64[Sp - 8] = block_caU3K_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaU3T; else goto caU3L;
       uaU3T: // global
           call _caU3K(R1) args: 0, res: 0, upd: 0;
       caU3L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caU3D: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caU3K() //  [R1]
         { info_tbl: [(caU3K,
                       label: block_caU3K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU3K: // global
           I64[Sp] = block_caU3P_info;
           R1 = I64[R1 + 7];
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU3P() //  []
         { info_tbl: [(caU3P,
                       label: block_caU3P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU3P: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.395989399 UTC

[section ""data" . GHC.Conc.IO.threadWaitWrite_closure" {
     GHC.Conc.IO.threadWaitWrite_closure:
         const GHC.Conc.IO.threadWaitWrite_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWrite_entry() //  [R2]
         { info_tbl: [(caU4e,
                       label: GHC.Conc.IO.threadWaitWrite_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU4e: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWrite1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.400950443 UTC

[section ""data" . GHC.Conc.IO.threadWaitWriteSTM1_closure" {
     GHC.Conc.IO.threadWaitWriteSTM1_closure:
         const GHC.Conc.IO.threadWaitWriteSTM1_info;
         const 0;
 },
 sat_saTZZ_entry() //  [R1]
         { info_tbl: [(caU4T,
                       label: sat_saTZZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU4T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU4U; else goto caU4V;
       caU4U: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU4V: // global
           I64[Sp - 8] = block_caU4R_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU4R() //  []
         { info_tbl: [(caU4R,
                       label: block_caU4R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU4R: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saU00_entry() //  [R1]
         { info_tbl: [(caU4X,
                       label: sat_saU00_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU4X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caU4Y; else goto caU4Z;
       caU4Y: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU4Z: // global
           I64[Sp - 16] = block_caU4F_info;
           _saTZR::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saTZR::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaU54; else goto caU4G;
       uaU54: // global
           call _caU4F(R1) args: 0, res: 0, upd: 0;
       caU4G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU4F() //  [R1]
         { info_tbl: [(caU4F,
                       label: block_caU4F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU4F: // global
           I64[Sp] = block_caU4K_info;
           R1 = I64[R1 + 7];
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU4K() //  []
         { info_tbl: [(caU4K,
                       label: block_caU4K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU4K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caU53; else goto caU52;
       caU53: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caU52: // global
           I64[Hp - 8] = sat_saTZZ_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saU01_entry() //  [R1]
         { info_tbl: [(caU55,
                       label: sat_saU01_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU55: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caU59; else goto caU58;
       caU59: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU58: // global
           _saTZI::P64 = P64[R1 + 7];
           _saTZR::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saU00_info;
           P64[Hp - 8] = _saTZI::P64;
           P64[Hp] = _saTZR::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saU0d_entry() //  [R1]
         { info_tbl: [(caU5j,
                       label: sat_saU0d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU5j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU5k; else goto caU5l;
       caU5k: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU5l: // global
           I64[Sp - 8] = block_caU5h_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU5h() //  []
         { info_tbl: [(caU5h,
                       label: block_caU5h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU5h: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saU0a_entry() //  [R1]
         { info_tbl: [(caU5B,
                       label: sat_saU0a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU5B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU5C; else goto caU5D;
       caU5C: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU5D: // global
           I64[Sp - 8] = block_caU5s_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU5s() //  [R1]
         { info_tbl: [(caU5s,
                       label: block_caU5s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU5s: // global
           I64[Sp] = block_caU5u_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaU5L; else goto caU5v;
       uaU5L: // global
           call _caU5u(R1) args: 0, res: 0, upd: 0;
       caU5v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU5u() //  [R1]
         { info_tbl: [(caU5u,
                       label: block_caU5u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU5u: // global
           if (R1 & 7 == 1) goto caU5y; else goto caU5z;
       caU5y: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caU5z: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.IO.threadWaitWriteSTM1_entry() //  [R2]
         { info_tbl: [(caU5P,
                       label: GHC.Conc.IO.threadWaitWriteSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU5P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caU5Q; else goto caU5R;
       caU5Q: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitWriteSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caU5R: // global
           (_saTZN::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTZN::I64 == 0) goto caU5O; else goto caU5N;
       caU5O: // global
           I64[Sp - 16] = block_caU4t_info;
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
       caU5N: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 _caU4t() //  [R1]
         { info_tbl: [(caU4t,
                       label: block_caU4t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU4t: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caU5V; else goto caU5U;
       caU5V: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caU5U: // global
           I64[Hp - 16] = sat_saU01_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_caU5a_info;
           _saTZR::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _saTZR::P64;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU5a() //  [R1]
         { info_tbl: [(caU5a,
                       label: block_caU5a_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU5a: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caU5Y; else goto caU5X;
       caU5Y: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caU5X: // global
           I64[Hp - 48] = sat_saU0d_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saU0a_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.429480804 UTC

[section ""data" . GHC.Conc.IO.threadWaitWriteSTM_closure" {
     GHC.Conc.IO.threadWaitWriteSTM_closure:
         const GHC.Conc.IO.threadWaitWriteSTM_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWriteSTM_entry() //  [R2]
         { info_tbl: [(caU7m,
                       label: GHC.Conc.IO.threadWaitWriteSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU7m: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWriteSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.434229062 UTC

[section ""data" . GHC.Conc.IO.threadWaitRead1_closure" {
     GHC.Conc.IO.threadWaitRead1_closure:
         const GHC.Conc.IO.threadWaitRead1_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitRead1_entry() //  [R2]
         { info_tbl: [(caU7C,
                       label: GHC.Conc.IO.threadWaitRead1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU7C: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU7D; else goto caU7E;
       caU7D: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitRead1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caU7E: // global
           (_saU0k::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saU0k::I64 == 0) goto caU7B; else goto caU7A;
       caU7B: // global
           I64[Sp - 8] = block_caU7H_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaU7Q; else goto caU7I;
       uaU7Q: // global
           call _caU7H(R1) args: 0, res: 0, upd: 0;
       caU7I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caU7A: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _caU7H() //  [R1]
         { info_tbl: [(caU7H,
                       label: block_caU7H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU7H: // global
           I64[Sp] = block_caU7M_info;
           R1 = I64[R1 + 7];
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU7M() //  []
         { info_tbl: [(caU7M,
                       label: block_caU7M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU7M: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.44158422 UTC

[section ""data" . GHC.Conc.IO.threadWaitRead_closure" {
     GHC.Conc.IO.threadWaitRead_closure:
         const GHC.Conc.IO.threadWaitRead_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitRead_entry() //  [R2]
         { info_tbl: [(caU8b,
                       label: GHC.Conc.IO.threadWaitRead_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU8b: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitRead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.446308586 UTC

[section ""data" . GHC.Conc.IO.threadWaitReadSTM1_closure" {
     GHC.Conc.IO.threadWaitReadSTM1_closure:
         const GHC.Conc.IO.threadWaitReadSTM1_info;
         const 0;
 },
 sat_saU0G_entry() //  [R1]
         { info_tbl: [(caU8Q,
                       label: sat_saU0G_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU8Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU8R; else goto caU8S;
       caU8R: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU8S: // global
           I64[Sp - 8] = block_caU8O_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU8O() //  []
         { info_tbl: [(caU8O,
                       label: block_caU8O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU8O: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saU0H_entry() //  [R1]
         { info_tbl: [(caU8U,
                       label: sat_saU0H_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU8U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caU8V; else goto caU8W;
       caU8V: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU8W: // global
           I64[Sp - 16] = block_caU8C_info;
           _saU0y::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saU0y::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaU91; else goto caU8D;
       uaU91: // global
           call _caU8C(R1) args: 0, res: 0, upd: 0;
       caU8D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU8C() //  [R1]
         { info_tbl: [(caU8C,
                       label: block_caU8C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU8C: // global
           I64[Sp] = block_caU8H_info;
           R1 = I64[R1 + 7];
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU8H() //  []
         { info_tbl: [(caU8H,
                       label: block_caU8H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU8H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caU90; else goto caU8Z;
       caU90: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caU8Z: // global
           I64[Hp - 8] = sat_saU0G_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saU0I_entry() //  [R1]
         { info_tbl: [(caU92,
                       label: sat_saU0I_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU92: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caU96; else goto caU95;
       caU96: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU95: // global
           _saU0p::P64 = P64[R1 + 7];
           _saU0y::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saU0H_info;
           P64[Hp - 8] = _saU0p::P64;
           P64[Hp] = _saU0y::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saU0U_entry() //  [R1]
         { info_tbl: [(caU9g,
                       label: sat_saU0U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU9g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU9h; else goto caU9i;
       caU9h: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU9i: // global
           I64[Sp - 8] = block_caU9e_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU9e() //  []
         { info_tbl: [(caU9e,
                       label: block_caU9e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU9e: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saU0R_entry() //  [R1]
         { info_tbl: [(caU9y,
                       label: sat_saU0R_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU9y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU9z; else goto caU9A;
       caU9z: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU9A: // global
           I64[Sp - 8] = block_caU9p_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU9p() //  [R1]
         { info_tbl: [(caU9p,
                       label: block_caU9p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU9p: // global
           I64[Sp] = block_caU9r_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaU9I; else goto caU9s;
       uaU9I: // global
           call _caU9r(R1) args: 0, res: 0, upd: 0;
       caU9s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU9r() //  [R1]
         { info_tbl: [(caU9r,
                       label: block_caU9r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU9r: // global
           if (R1 & 7 == 1) goto caU9v; else goto caU9w;
       caU9v: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caU9w: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.IO.threadWaitReadSTM1_entry() //  [R2]
         { info_tbl: [(caU9M,
                       label: GHC.Conc.IO.threadWaitReadSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU9M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caU9N; else goto caU9O;
       caU9N: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitReadSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caU9O: // global
           (_saU0u::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saU0u::I64 == 0) goto caU9L; else goto caU9K;
       caU9L: // global
           I64[Sp - 16] = block_caU8q_info;
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
       caU9K: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 _caU8q() //  [R1]
         { info_tbl: [(caU8q,
                       label: block_caU8q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU8q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caU9S; else goto caU9R;
       caU9S: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caU9R: // global
           I64[Hp - 16] = sat_saU0I_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_caU97_info;
           _saU0y::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _saU0y::P64;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caU97() //  [R1]
         { info_tbl: [(caU97,
                       label: block_caU97_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caU97: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caU9V; else goto caU9U;
       caU9V: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caU9U: // global
           I64[Hp - 48] = sat_saU0U_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saU0R_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.475124584 UTC

[section ""data" . GHC.Conc.IO.threadWaitReadSTM_closure" {
     GHC.Conc.IO.threadWaitReadSTM_closure:
         const GHC.Conc.IO.threadWaitReadSTM_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitReadSTM_entry() //  [R2]
         { info_tbl: [(caUbj,
                       label: GHC.Conc.IO.threadWaitReadSTM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caUbj: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitReadSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:54.478413676 UTC

[section ""relreadonly" . SaU13_srt" {
     SaU13_srt:
         const GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Thread.registerDelay1_closure;
         const GHC.Conc.IO.registerDelay2_closure;
         const GHC.Conc.IO.registerDelay1_closure;
         const GHC.Event.Thread.threadDelay1_closure;
         const GHC.Conc.IO.threadDelay1_closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.Conc.IO.closeFdWith1_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitWrite1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Sync.killThread2_closure;
         const GHC.Event.Thread.threadWaitReadSTM1_closure;
         const GHC.Conc.IO.threadWaitWriteSTM1_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Conc.IO.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitReadSTM1_closure;
 }]

