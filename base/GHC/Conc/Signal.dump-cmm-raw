
==================== Raw Cmm ====================
2018-03-16 16:05:23.0333168 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:05:23.034347577 UTC

[section ""cstring" . GHC.Conc.Signal.$trModule4_bytes" {
     GHC.Conc.Signal.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.036113463 UTC

[section ""data" . GHC.Conc.Signal.$trModule3_closure" {
     GHC.Conc.Signal.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Signal.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.03772936 UTC

[section ""cstring" . GHC.Conc.Signal.$trModule2_bytes" {
     GHC.Conc.Signal.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,83,105,103,110,97,108]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.039351657 UTC

[section ""data" . GHC.Conc.Signal.$trModule1_closure" {
     GHC.Conc.Signal.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Signal.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.040969501 UTC

[section ""data" . GHC.Conc.Signal.$trModule_closure" {
     GHC.Conc.Signal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.Signal.$trModule3_closure+1;
         const GHC.Conc.Signal.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.042675105 UTC

[section ""data" . lvl_ramSF_closure" {
     lvl_ramSF_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.044287202 UTC

[section ""data" . lvl1_ramSG_closure" {
     lvl1_ramSG_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.049092305 UTC

[section ""data" . lvl2_ramSH_closure" {
     lvl2_ramSH_closure:
         const lvl2_ramSH_info;
 },
 sat_samTm_entry() //  [R1]
         { []
         }
     {offset
       canhj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canhk; else goto canhl;
       canhk: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canhl: // global
           I64[Sp - 16] = block_canha_info;
           _samSX::P64 = P64[R1 + 7];
           R1 = _samSX::P64;
           P64[Sp - 8] = _samSX::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_samTm_info" {
     sat_samTm_info:
         const sat_samTm_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _canha() //  [R1]
         { []
         }
     {offset
       canha: // global
           _samSX::P64 = P64[Sp + 8];
           (_samTh::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetGHCConcSignalSignalHandlerStore(R1);
           if (R1 == _samTh::I64) goto canhi; else goto canhh;
       canhi: // global
           R1 = _samSX::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       canhh: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _samTh::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canha_info" {
     block_canha_info:
         const _canha;
         const 1;
         const 30;
 },
 lvl2_ramSH_entry() //  []
         { []
         }
     {offset
       canht: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canhu; else goto canhv;
       canhu: // global
           R1 = lvl2_ramSH_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canhv: // global
           I64[Sp - 8] = block_cangQ_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl2_ramSH_info" {
     lvl2_ramSH_info:
         const lvl2_ramSH_entry;
         const 0;
         const 14;
         const 4294967299;
 },
 _cangQ() //  []
         { []
         }
     {offset
       cangQ: // global
           I64[Sp] = block_cangS_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = 65;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cangQ_info" {
     block_cangQ_info:
         const _cangQ;
         const 0;
         const 30;
 },
 _cangS() //  [R1]
         { []
         }
     {offset
       cangS: // global
           I64[Sp - 8] = block_cangU_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cangS_info" {
     block_cangS_info:
         const _cangS;
         const 0;
         const 30;
 },
 _cangU() //  [R1]
         { []
         }
     {offset
       cangU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto canhA; else goto canhz;
       canhA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canhz: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl_ramSF_closure+1;
           P64[Hp - 16] = lvl1_ramSG_closure+1;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = 65;
           I64[Sp] = block_cangX_info;
           R2 = Hp - 31;
           _samSR::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _samSR::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cangU_info" {
     block_cangU_info:
         const _cangU;
         const 1;
         const 30;
 },
 _cangX() //  []
         { []
         }
     {offset
       cangX: // global
           I64[Sp] = block_cangZ_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cangX_info" {
     block_cangX_info:
         const _cangX;
         const 1;
         const 30;
 },
 _cangZ() //  [R1]
         { []
         }
     {offset
       cangZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto canhE; else goto canhD;
       canhE: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       canhD: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _canh1::P64 = Hp - 23;
           if (R1 == 0) goto canhs; else goto canhr;
       canhs: // global
           I64[Hp - 8] = sat_samTm_info;
           P64[Hp] = _canh1::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       canhr: // global
           Hp = Hp - 16;
           I64[Sp] = block_canhF_info;
           R1 = _canh1::P64;
           P64[Sp + 8] = _canh1::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cangZ_info" {
     block_cangZ_info:
         const _cangZ;
         const 1;
         const 30;
 },
 _canhF() //  [R1]
         { []
         }
     {offset
       canhF: // global
           _canh1::P64 = P64[Sp + 8];
           (_samT5::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetGHCConcSignalSignalHandlerStore(R1);
           if (R1 == _samT5::I64) goto canhO; else goto canhN;
       canhO: // global
           R1 = _canh1::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       canhN: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _samT5::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canhF_info" {
     block_canhF_info:
         const _canhF;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.067390183 UTC

[section ""data" . GHC.Conc.Signal.signal_handlers_closure" {
     GHC.Conc.Signal.signal_handlers_closure:
         const GHC.Conc.Signal.signal_handlers_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Signal.signal_handlers_entry() //  [R1]
         { []
         }
     {offset
       caniy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caniz; else goto caniA;
       caniz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caniA: // global
           (_canit::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_canit::I64 == 0) goto caniv; else goto caniu;
       caniv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caniu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _canit::I64;
           I64[Sp - 24] = block_caniw_info;
           Sp = Sp - 24;
           call lvl2_ramSH_entry() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.signal_handlers_info" {
     GHC.Conc.Signal.signal_handlers_info:
         const GHC.Conc.Signal.signal_handlers_entry;
         const 0;
         const 21;
 },
 _caniw() //  [R1]
         { []
         }
     {offset
       caniw: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caniw_info" {
     block_caniw_info:
         const _caniw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.072422586 UTC

[section ""cstring" . lvl3_ramSI_bytes" {
     lvl3_ramSI_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,115,101,116,72,97,110,100,108,101,114,58,32,115,105,103,110,97,108,32,111,117,116,32,111,102,32,114,97,110,103,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.074828385 UTC

[section ""data" . GHC.Conc.Signal.setHandler2_closure" {
     GHC.Conc.Signal.setHandler2_closure:
         const GHC.Conc.Signal.setHandler2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Signal.setHandler2_entry() //  [R1]
         { []
         }
     {offset
       caniX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caniY; else goto caniZ;
       caniY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caniZ: // global
           (_caniS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caniS::I64 == 0) goto caniU; else goto caniT;
       caniU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caniT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caniS::I64;
           I64[Sp - 24] = block_caniV_info;
           R2 = lvl3_ramSI_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.setHandler2_info" {
     GHC.Conc.Signal.setHandler2_info:
         const GHC.Conc.Signal.setHandler2_entry;
         const 0;
         const 4294967317;
         const SamXS_srt;
 },
 _caniV() //  [R1]
         { []
         }
     {offset
       caniV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caniV_info" {
     block_caniV_info:
         const _caniV;
         const 0;
         const 4294967326;
         const SamXS_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.089148284 UTC

[section ""data" . GHC.Conc.Signal.setHandler1_closure" {
     GHC.Conc.Signal.setHandler1_closure:
         const GHC.Conc.Signal.setHandler1_info;
         const 0;
 },
 io_samTx_entry() //  [R1, R2]
         { []
         }
     {offset
       canjr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canjF; else goto canjG;
       canjF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canjG: // global
           I64[Sp - 24] = block_canjo_info;
           _samTr::P64 = P64[R1 + 6];
           _samTs::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _samTr::P64;
           P64[Sp - 8] = _samTs::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uank2; else goto canjp;
       uank2: // global
           call _canjo(R1) args: 0, res: 0, upd: 0;
       canjp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_samTx_info" {
     io_samTx_info:
         const io_samTx_entry;
         const 2;
         const 4294967307;
         const 8589934597;
         const SamXS_srt+8;
 },
 _canjo() //  [R1]
         { []
         }
     {offset
       canjo: // global
           I64[Sp - 16] = block_canju_info;
           _samTC::P64 = P64[R1 + 15];
           _samTE::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _samTE::P64;
           P64[Sp] = _samTC::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uank1; else goto canjv;
       uank1: // global
           call _canju(R1) args: 0, res: 0, upd: 0;
       canjv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canjo_info" {
     block_canjo_info:
         const _canjo;
         const 2;
         const 4294967326;
         const SamXS_srt+8;
 },
 _canju() //  [R1]
         { []
         }
     {offset
       canju: // global
           I64[Sp] = block_canjz_info;
           _samTG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _samTG::I64;
           if (R1 & 7 != 0) goto uank3; else goto canjA;
       uank3: // global
           call _canjz(R1) args: 0, res: 0, upd: 0;
       canjA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canju_info" {
     block_canju_info:
         const _canju;
         const 4;
         const 4294967326;
         const SamXS_srt+8;
 },
 _canjz() //  [R1]
         { []
         }
     {offset
       canjz: // global
           I64[Sp] = block_canjE_info;
           _samTI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _samTI::I64;
           if (R1 & 7 != 0) goto uank4; else goto canjK;
       uank4: // global
           call _canjE(R1) args: 0, res: 0, upd: 0;
       canjK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canjz_info" {
     block_canjz_info:
         const _canjz;
         const 132;
         const 4294967326;
         const SamXS_srt+8;
 },
 _canjE() //  [R1]
         { []
         }
     {offset
       canjE: // global
           _samTK::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _samTK::I64)) goto canjY; else goto cank0;
       cank0: // global
           if (%MO_S_Gt_W64(_samTK::I64,
                            I64[Sp + 24])) goto canjY; else goto canjZ;
       canjY: // global
           R1 = GHC.Conc.Signal.setHandler2_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       canjZ: // global
           _samTs::P64 = P64[Sp + 32];
           _samTE::P64 = P64[Sp + 8];
           _samTR::P64 = P64[(_samTE::P64 + 24) + (_samTK::I64 << 3)];
           call MO_WriteBarrier();
           P64[(_samTE::P64 + 24) + (_samTK::I64 << 3)] = _samTs::P64;
           I64[_samTE::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_samTE::P64 + 24) + ((I64[_samTE::P64 + 8] << 3) + (_samTK::I64 >> 7))] = 1 :: W8;
           R1 = _samTR::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canjE_info" {
     block_canjE_info:
         const _canjE;
         const 388;
         const 4294967326;
         const SamXS_srt+8;
 },
 sat_samU4_entry() //  [R1, R2]
         { []
         }
     {offset
       cankl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cankm; else goto cankn;
       cankm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cankn: // global
           I64[Sp - 16] = block_cankj_info;
           _samU1::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samU1::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_samU4_info" {
     sat_samU4_info:
         const sat_samU4_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _cankj() //  []
         { []
         }
     {offset
       cankj: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cankj_info" {
     block_cankj_info:
         const _cankj;
         const 1;
         const 30;
 },
 sat_samTZ_entry() //  [R1]
         { []
         }
     {offset
       canku: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samTx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samTZ_info" {
     sat_samTZ_info:
         const sat_samTZ_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SamXS_srt+8;
 },
 sat_samU0_entry() //  [R1]
         { []
         }
     {offset
       cankC: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samU0_info" {
     sat_samU0_info:
         const sat_samU0_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_samUk_entry() //  [R1, R2]
         { []
         }
     {offset
       cankZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canl0; else goto canl1;
       canl0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canl1: // global
           I64[Sp - 16] = block_cankX_info;
           _samUh::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samUh::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_samUk_info" {
     sat_samUk_info:
         const sat_samUk_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _cankX() //  []
         { []
         }
     {offset
       cankX: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cankX_info" {
     block_cankX_info:
         const _cankX;
         const 1;
         const 30;
 },
 sat_samUf_entry() //  [R1]
         { []
         }
     {offset
       canl8: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samTx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samUf_info" {
     sat_samUf_info:
         const sat_samUf_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SamXS_srt+8;
 },
 sat_samUg_entry() //  [R1]
         { []
         }
     {offset
       canlg: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samUg_info" {
     sat_samUg_info:
         const sat_samUg_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_samUp_entry() //  [R1]
         { []
         }
     {offset
       canlj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canln; else goto canlo;
       canln: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canlo: // global
           I64[Sp - 16] = block_cankL_info;
           _samTx::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp - 8] = _samTx::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanlw; else goto cankM;
       uanlw: // global
           call _cankL(R1) args: 0, res: 0, upd: 0;
       cankM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_samUp_info" {
     sat_samUp_info:
         const sat_samUp_entry;
         const 1;
         const 12884901897;
         const 4294967299;
         const SamXS_srt+8;
 },
 _cankL() //  [R1]
         { []
         }
     {offset
       cankL: // global
           I64[Sp - 8] = block_cankQ_info;
           _samUb::P64 = P64[R1 + 7];
           R1 = _samUb::P64;
           P64[Sp] = _samUb::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cankL_info" {
     block_cankL_info:
         const _cankL;
         const 1;
         const 4294967326;
         const SamXS_srt+8;
 },
 _cankQ() //  [R1]
         { []
         }
     {offset
       cankQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canls; else goto canlr;
       canls: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canlr: // global
           I64[Hp - 56] = sat_samUk_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samUf_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samUg_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canlk_info;
           R2 = Hp - 54;
           _samUe::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samUe::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cankQ_info" {
     block_cankQ_info:
         const _cankQ;
         const 2;
         const 4294967326;
         const SamXS_srt+8;
 },
 _canlk() //  [R1]
         { []
         }
     {offset
       canlk: // global
           _samUb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canlm_info;
           R2 = P64[Sp + 16];
           _samUn::P64 = R1;
           R1 = _samUb::P64;
           P64[Sp + 16] = _samUn::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canlk_info" {
     block_canlk_info:
         const _canlk;
         const 2;
         const 30;
 },
 _canlm() //  []
         { []
         }
     {offset
       canlm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canlm_info" {
     block_canlm_info:
         const _canlm;
         const 1;
         const 30;
 },
 sat_samUA_entry() //  [R1, R2]
         { []
         }
     {offset
       canlM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canlN; else goto canlO;
       canlN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canlO: // global
           I64[Sp - 16] = block_canlK_info;
           _samUx::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samUx::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_samUA_info" {
     sat_samUA_info:
         const sat_samUA_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _canlK() //  []
         { []
         }
     {offset
       canlK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canlK_info" {
     block_canlK_info:
         const _canlK;
         const 1;
         const 30;
 },
 sat_samUv_entry() //  [R1]
         { []
         }
     {offset
       canlV: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samTx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samUv_info" {
     sat_samUv_info:
         const sat_samUv_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SamXS_srt+8;
 },
 sat_samUw_entry() //  [R1]
         { []
         }
     {offset
       canm3: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samUw_info" {
     sat_samUw_info:
         const sat_samUw_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 GHC.Conc.Signal.setHandler1_entry() //  [R2, R3]
         { []
         }
     {offset
       canma: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canmb; else goto canmc;
       canmb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.setHandler1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canmc: // global
           I64[Sp - 24] = block_canjh_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.setHandler1_info" {
     GHC.Conc.Signal.setHandler1_info:
         const GHC.Conc.Signal.setHandler1_entry;
         const 0;
         const 30064771086;
         const 12884901903;
         const SamXS_srt+8;
 },
 _canjh() //  [R1]
         { []
         }
     {offset
       canjh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto canmf; else goto canme;
       canmf: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       canme: // global
           I64[Hp - 32] = io_samTx_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           _canjj::P64 = Hp - 30;
           if (R1 == 0) goto canm8; else goto uanmA;
       canm8: // global
           I64[Hp - 8] = sat_samUp_info;
           P64[Hp] = _canjj::P64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uanmA: // global
           if (R1 == 1) goto canm9; else goto canm7;
       canm9: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_canly_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canjj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanmC; else goto canlz;
       uanmC: // global
           call _canly(R1) args: 0, res: 0, upd: 0;
       canlz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       canm7: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_cank7_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canjj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanmB; else goto cank8;
       uanmB: // global
           call _cank7(R1) args: 0, res: 0, upd: 0;
       cank8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canjh_info" {
     block_canjh_info:
         const _canjh;
         const 2;
         const 12884901918;
         const SamXS_srt+8;
 },
 _canly() //  [R1]
         { []
         }
     {offset
       canly: // global
           I64[Sp - 8] = block_canlD_info;
           _samUr::P64 = P64[R1 + 7];
           R1 = _samUr::P64;
           P64[Sp] = _samUr::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canly_info" {
     block_canly_info:
         const _canly;
         const 1;
         const 4294967326;
         const SamXS_srt+8;
 },
 _canlD() //  [R1]
         { []
         }
     {offset
       canlD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canmw; else goto canmv;
       canmw: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canmv: // global
           I64[Hp - 56] = sat_samUA_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samUv_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samUw_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canmq_info;
           R2 = Hp - 54;
           _samUu::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samUu::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canlD_info" {
     block_canlD_info:
         const _canlD;
         const 2;
         const 4294967326;
         const SamXS_srt+8;
 },
 _canmq() //  [R1]
         { []
         }
     {offset
       canmq: // global
           _samUr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canms_info;
           R2 = P64[Sp + 16];
           _samUD::P64 = R1;
           R1 = _samUr::P64;
           P64[Sp + 16] = _samUD::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canmq_info" {
     block_canmq_info:
         const _canmq;
         const 2;
         const 30;
 },
 _canms() //  []
         { []
         }
     {offset
       canms: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canms_info" {
     block_canms_info:
         const _canms;
         const 1;
         const 30;
 },
 _cank7() //  [R1]
         { []
         }
     {offset
       cank7: // global
           I64[Sp - 8] = block_cankc_info;
           _samTV::P64 = P64[R1 + 7];
           R1 = _samTV::P64;
           P64[Sp] = _samTV::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cank7_info" {
     block_cank7_info:
         const _cank7;
         const 1;
         const 4294967326;
         const SamXS_srt+8;
 },
 _cankc() //  [R1]
         { []
         }
     {offset
       cankc: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canmm; else goto canml;
       canmm: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canml: // global
           I64[Hp - 56] = sat_samU4_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samTZ_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samU0_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canmg_info;
           R2 = Hp - 54;
           _samTY::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samTY::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cankc_info" {
     block_cankc_info:
         const _cankc;
         const 2;
         const 4294967326;
         const SamXS_srt+8;
 },
 _canmg() //  [R1]
         { []
         }
     {offset
       canmg: // global
           _samTV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canmi_info;
           R2 = P64[Sp + 16];
           _samU7::P64 = R1;
           R1 = _samTV::P64;
           P64[Sp + 16] = _samU7::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canmg_info" {
     block_canmg_info:
         const _canmg;
         const 2;
         const 30;
 },
 _canmi() //  []
         { []
         }
     {offset
       canmi: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canmi_info" {
     block_canmi_info:
         const _canmi;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.140836698 UTC

[section ""data" . GHC.Conc.Signal.setHandler_closure" {
     GHC.Conc.Signal.setHandler_closure:
         const GHC.Conc.Signal.setHandler_info;
         const 0;
 },
 GHC.Conc.Signal.setHandler_entry() //  [R2, R3]
         { []
         }
     {offset
       canoM: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.setHandler1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.setHandler_info" {
     GHC.Conc.Signal.setHandler_info:
         const GHC.Conc.Signal.setHandler_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SamXS_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.15557596 UTC

[section ""data" . GHC.Conc.Signal.runHandlers1_closure" {
     GHC.Conc.Signal.runHandlers1_closure:
         const GHC.Conc.Signal.runHandlers1_info;
         const 0;
 },
 sat_samV3_entry() //  [R1]
         { []
         }
     {offset
       canpB: // global
           R2 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samV3_info" {
     sat_samV3_info:
         const sat_samV3_entry;
         const 2;
         const 18;
 },
 sat_samV4_entry() //  [R1]
         { []
         }
     {offset
       canpE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto canpI; else goto canpH;
       canpI: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canpH: // global
           _samUF::P64 = P64[R1 + 7];
           _samV0::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_samV3_info;
           P64[Hp - 8] = _samUF::P64;
           P64[Hp] = _samV0::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samV4_info" {
     sat_samV4_info:
         const sat_samV4_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SamXS_srt+32;
 },
 $wio_samUL_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       canpJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canpK; else goto canpL;
       canpK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       canpL: // global
           I64[Sp - 40] = block_canp4_info;
           _samUF::P64 = P64[R1 + 4];
           R1 = P64[R1 + 12];
           P64[Sp - 32] = _samUF::P64;
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uanqe; else goto canp5;
       uanqe: // global
           call _canp4(R1) args: 0, res: 0, upd: 0;
       canp5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wio_samUL_info" {
     $wio_samUL_info:
         const $wio_samUL_entry;
         const 2;
         const 4294967307;
         const 17179869201;
         const SamXS_srt+32;
 },
 _canp4() //  [R1]
         { []
         }
     {offset
       canp4: // global
           _samUR::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _samUR::I64)) goto uanq6; else goto canq4;
       uanq6: // global
           Sp = Sp + 40;
           goto uanqb;
       canq4: // global
           if (%MO_S_Gt_W64(_samUR::I64,
                            I64[Sp + 24])) goto uanq7; else goto canpR;
       uanq7: // global
           Sp = Sp + 40;
           goto uanqb;
       uanqb: // global
           call _canpV() args: 0, res: 0, upd: 0;
       canpR: // global
           _samUW::P64 = P64[P64[Sp + 32] + ((_samUR::I64 << 3) + 24)];
           I64[Sp] = block_canph_info;
           R1 = _samUW::P64;
           if (R1 & 7 != 0) goto uanq9; else goto canpi;
       uanq9: // global
           call _canph(R1) args: 0, res: 0, upd: 0;
       canpi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canp4_info" {
     block_canp4_info:
         const _canp4;
         const 388;
         const 4294967326;
         const SamXS_srt+32;
 },
 _canph() //  [R1]
         { []
         }
     {offset
       canph: // global
           if (R1 & 7 == 1) goto uanq8; else goto canpY;
       uanq8: // global
           Sp = Sp + 40;
           call _canpV() args: 0, res: 0, upd: 0;
       canpY: // global
           I64[Sp] = block_canpn_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uanqc; else goto canpo;
       uanqc: // global
           call _canpn(R1) args: 0, res: 0, upd: 0;
       canpo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canph_info" {
     block_canph_info:
         const _canph;
         const 900;
         const 4294967326;
         const SamXS_srt+32;
 },
 _canpV() //  []
         { []
         }
     {offset
       canpV: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _canpn() //  [R1]
         { []
         }
     {offset
       canpn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto canq1; else goto canq0;
       canq1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canq0: // global
           _samV0::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_samV4_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _samV0::P64;
           I64[Sp + 32] = block_canpW_info;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canpn_info" {
     block_canpn_info:
         const _canpn;
         const 900;
         const 4294967326;
         const SamXS_srt+32;
 },
 _canpW() //  []
         { []
         }
     {offset
       canpW: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canpW_info" {
     block_canpW_info:
         const _canpW;
         const 0;
         const 30;
 },
 io_samV8_entry() //  [R1, R2]
         { []
         }
     {offset
       canqn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto canqw; else goto canqx;
       canqw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canqx: // global
           I64[Sp - 16] = block_canqk_info;
           _samUL::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _samUL::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanqG; else goto canql;
       uanqG: // global
           call _canqk(R1) args: 0, res: 0, upd: 0;
       canql: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_samV8_info" {
     io_samV8_info:
         const io_samV8_entry;
         const 1;
         const 4294967305;
         const 8589934597;
         const SamXS_srt+32;
 },
 _canqk() //  [R1]
         { []
         }
     {offset
       canqk: // global
           I64[Sp - 16] = block_canqq_info;
           _samVd::P64 = P64[R1 + 15];
           _samVf::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _samVf::P64;
           P64[Sp] = _samVd::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanqF; else goto canqr;
       uanqF: // global
           call _canqq(R1) args: 0, res: 0, upd: 0;
       canqr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canqk_info" {
     block_canqk_info:
         const _canqk;
         const 1;
         const 4294967326;
         const SamXS_srt+32;
 },
 _canqq() //  [R1]
         { []
         }
     {offset
       canqq: // global
           I64[Sp] = block_canqv_info;
           _samVh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _samVh::I64;
           if (R1 & 7 != 0) goto uanqH; else goto canqA;
       uanqH: // global
           call _canqv(R1) args: 0, res: 0, upd: 0;
       canqA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canqq_info" {
     block_canqq_info:
         const _canqq;
         const 3;
         const 4294967326;
         const SamXS_srt+32;
 },
 _canqv() //  [R1]
         { []
         }
     {offset
       canqv: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 16];
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call $wio_samUL_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canqv_info" {
     block_canqv_info:
         const _canqv;
         const 131;
         const 4294967326;
         const SamXS_srt+32;
 },
 sat_samVv_entry() //  [R1, R2]
         { []
         }
     {offset
       canqY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canqZ; else goto canr0;
       canqZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canr0: // global
           I64[Sp - 16] = block_canqW_info;
           _samVs::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samVs::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_samVv_info" {
     sat_samVv_info:
         const sat_samVv_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _canqW() //  []
         { []
         }
     {offset
       canqW: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canqW_info" {
     block_canqW_info:
         const _canqW;
         const 1;
         const 30;
 },
 sat_samVq_entry() //  [R1]
         { []
         }
     {offset
       canr7: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samV8_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samVq_info" {
     sat_samVq_info:
         const sat_samVq_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SamXS_srt+32;
 },
 sat_samVr_entry() //  [R1]
         { []
         }
     {offset
       canrf: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samVr_info" {
     sat_samVr_info:
         const sat_samVr_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_samVL_entry() //  [R1, R2]
         { []
         }
     {offset
       canrC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canrD; else goto canrE;
       canrD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canrE: // global
           I64[Sp - 16] = block_canrA_info;
           _samVI::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samVI::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_samVL_info" {
     sat_samVL_info:
         const sat_samVL_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _canrA() //  []
         { []
         }
     {offset
       canrA: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canrA_info" {
     block_canrA_info:
         const _canrA;
         const 1;
         const 30;
 },
 sat_samVG_entry() //  [R1]
         { []
         }
     {offset
       canrL: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samV8_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samVG_info" {
     sat_samVG_info:
         const sat_samVG_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SamXS_srt+32;
 },
 sat_samVH_entry() //  [R1]
         { []
         }
     {offset
       canrT: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samVH_info" {
     sat_samVH_info:
         const sat_samVH_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_samVQ_entry() //  [R1]
         { []
         }
     {offset
       canrW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cans0; else goto cans1;
       cans0: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cans1: // global
           I64[Sp - 16] = block_canro_info;
           _samV8::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp - 8] = _samV8::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uans9; else goto canrp;
       uans9: // global
           call _canro(R1) args: 0, res: 0, upd: 0;
       canrp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_samVQ_info" {
     sat_samVQ_info:
         const sat_samVQ_entry;
         const 1;
         const 21474836489;
         const 4294967299;
         const SamXS_srt+16;
 },
 _canro() //  [R1]
         { []
         }
     {offset
       canro: // global
           I64[Sp - 8] = block_canrt_info;
           _samVC::P64 = P64[R1 + 7];
           R1 = _samVC::P64;
           P64[Sp] = _samVC::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canro_info" {
     block_canro_info:
         const _canro;
         const 1;
         const 4294967326;
         const SamXS_srt+32;
 },
 _canrt() //  [R1]
         { []
         }
     {offset
       canrt: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cans5; else goto cans4;
       cans5: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cans4: // global
           I64[Hp - 56] = sat_samVL_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samVG_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samVH_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canrX_info;
           R2 = Hp - 54;
           _samVF::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samVF::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canrt_info" {
     block_canrt_info:
         const _canrt;
         const 2;
         const 4294967326;
         const SamXS_srt+32;
 },
 _canrX() //  [R1]
         { []
         }
     {offset
       canrX: // global
           _samVC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canrZ_info;
           R2 = P64[Sp + 16];
           _samVO::P64 = R1;
           R1 = _samVC::P64;
           P64[Sp + 16] = _samVO::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canrX_info" {
     block_canrX_info:
         const _canrX;
         const 2;
         const 30;
 },
 _canrZ() //  []
         { []
         }
     {offset
       canrZ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canrZ_info" {
     block_canrZ_info:
         const _canrZ;
         const 1;
         const 30;
 },
 sat_samW1_entry() //  [R1, R2]
         { []
         }
     {offset
       cansp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cansq; else goto cansr;
       cansq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cansr: // global
           I64[Sp - 16] = block_cansn_info;
           _samVY::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samVY::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_samW1_info" {
     sat_samW1_info:
         const sat_samW1_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _cansn() //  []
         { []
         }
     {offset
       cansn: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cansn_info" {
     block_cansn_info:
         const _cansn;
         const 1;
         const 30;
 },
 sat_samVW_entry() //  [R1]
         { []
         }
     {offset
       cansy: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samV8_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samVW_info" {
     sat_samVW_info:
         const sat_samVW_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SamXS_srt+32;
 },
 sat_samVX_entry() //  [R1]
         { []
         }
     {offset
       cansG: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_samVX_info" {
     sat_samVX_info:
         const sat_samVX_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 GHC.Conc.Signal.runHandlers1_entry() //  [R2, R3]
         { []
         }
     {offset
       cansN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cansO; else goto cansP;
       cansO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.runHandlers1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cansP: // global
           I64[Sp - 24] = block_canoX_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.runHandlers1_info" {
     GHC.Conc.Signal.runHandlers1_info:
         const GHC.Conc.Signal.runHandlers1_entry;
         const 0;
         const 55834574862;
         const 12884901903;
         const SamXS_srt+16;
 },
 _canoX() //  [R1]
         { []
         }
     {offset
       canoX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cansS; else goto cansR;
       cansS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cansR: // global
           I64[Hp - 48] = $wio_samUL_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = io_samV8_info;
           P64[Hp - 16] = Hp - 44;
           _canqf::P64 = Hp - 22;
           if (R1 == 0) goto cansL; else goto uantd;
       cansL: // global
           I64[Hp - 8] = sat_samVQ_info;
           P64[Hp] = _canqf::P64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uantd: // global
           if (R1 == 1) goto cansM; else goto cansK;
       cansM: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_cansb_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canqf::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uantf; else goto cansc;
       uantf: // global
           call _cansb(R1) args: 0, res: 0, upd: 0;
       cansc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cansK: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_canqK_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canqf::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uante; else goto canqL;
       uante: // global
           call _canqK(R1) args: 0, res: 0, upd: 0;
       canqL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canoX_info" {
     block_canoX_info:
         const _canoX;
         const 2;
         const 21474836510;
         const SamXS_srt+16;
 },
 _cansb() //  [R1]
         { []
         }
     {offset
       cansb: // global
           I64[Sp - 8] = block_cansg_info;
           _samVS::P64 = P64[R1 + 7];
           R1 = _samVS::P64;
           P64[Sp] = _samVS::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cansb_info" {
     block_cansb_info:
         const _cansb;
         const 1;
         const 4294967326;
         const SamXS_srt+32;
 },
 _cansg() //  [R1]
         { []
         }
     {offset
       cansg: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cant9; else goto cant8;
       cant9: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cant8: // global
           I64[Hp - 56] = sat_samW1_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samVW_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samVX_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cant3_info;
           R2 = Hp - 54;
           _samVV::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samVV::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cansg_info" {
     block_cansg_info:
         const _cansg;
         const 2;
         const 4294967326;
         const SamXS_srt+32;
 },
 _cant3() //  [R1]
         { []
         }
     {offset
       cant3: // global
           _samVS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cant5_info;
           R2 = P64[Sp + 16];
           _samW4::P64 = R1;
           R1 = _samVS::P64;
           P64[Sp + 16] = _samW4::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cant3_info" {
     block_cant3_info:
         const _cant3;
         const 2;
         const 30;
 },
 _cant5() //  []
         { []
         }
     {offset
       cant5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cant5_info" {
     block_cant5_info:
         const _cant5;
         const 1;
         const 30;
 },
 _canqK() //  [R1]
         { []
         }
     {offset
       canqK: // global
           I64[Sp - 8] = block_canqP_info;
           _samVm::P64 = P64[R1 + 7];
           R1 = _samVm::P64;
           P64[Sp] = _samVm::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canqK_info" {
     block_canqK_info:
         const _canqK;
         const 1;
         const 4294967326;
         const SamXS_srt+32;
 },
 _canqP() //  [R1]
         { []
         }
     {offset
       canqP: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cansZ; else goto cansY;
       cansZ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cansY: // global
           I64[Hp - 56] = sat_samVv_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samVq_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samVr_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cansT_info;
           R2 = Hp - 54;
           _samVp::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samVp::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canqP_info" {
     block_canqP_info:
         const _canqP;
         const 2;
         const 4294967326;
         const SamXS_srt+32;
 },
 _cansT() //  [R1]
         { []
         }
     {offset
       cansT: // global
           _samVm::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cansV_info;
           R2 = P64[Sp + 16];
           _samVy::P64 = R1;
           R1 = _samVm::P64;
           P64[Sp + 16] = _samVy::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cansT_info" {
     block_cansT_info:
         const _cansT;
         const 2;
         const 30;
 },
 _cansV() //  []
         { []
         }
     {offset
       cansV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cansV_info" {
     block_cansV_info:
         const _cansV;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.218468523 UTC

[section ""data" . GHC.Conc.Signal.runHandlers_closure" {
     GHC.Conc.Signal.runHandlers_closure:
         const GHC.Conc.Signal.runHandlers_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlers_entry() //  [R2, R3]
         { []
         }
     {offset
       canvO: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.runHandlers_info" {
     GHC.Conc.Signal.runHandlers_info:
         const GHC.Conc.Signal.runHandlers_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SamXS_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.222590577 UTC

[section ""data" . GHC.Conc.Signal.$wrunHandlersPtr_closure" {
     GHC.Conc.Signal.$wrunHandlersPtr_closure:
         const GHC.Conc.Signal.$wrunHandlersPtr_info;
         const 0;
 },
 GHC.Conc.Signal.$wrunHandlersPtr_entry() //  [R2, R3]
         { []
         }
     {offset
       canw5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canw6; else goto canw7;
       canw6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.$wrunHandlersPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canw7: // global
           I64[Sp - 24] = block_canvZ_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.$wrunHandlersPtr_info" {
     GHC.Conc.Signal.$wrunHandlersPtr_info:
         const GHC.Conc.Signal.$wrunHandlersPtr_entry;
         const 0;
         const 30064771086;
         const 12884901901;
         const SamXS_srt+40;
 },
 _canvZ() //  [R1]
         { []
         }
     {offset
       canvZ: // global
           I64[Sp - 8] = block_canw1_info;
           R6 = I64[Sp + 8];
           R5 = 0;
           R4 = 0;
           R3 = free;
           R2 = R1;
           P64[Sp - 16] = GHC.Tuple.()_closure+1;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canvZ_info" {
     block_canvZ_info:
         const _canvZ;
         const 66;
         const 12884901918;
         const SamXS_srt+40;
 },
 _canw1() //  [R1]
         { []
         }
     {offset
       canw1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto canwb; else goto canwa;
       canwb: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canwa: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R3 = P64[Sp + 24];
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canw1_info" {
     block_canw1_info:
         const _canw1;
         const 131;
         const 4294967326;
         const SamXS_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.230236692 UTC

[section ""data" . GHC.Conc.Signal.runHandlersPtr1_closure" {
     GHC.Conc.Signal.runHandlersPtr1_closure:
         const GHC.Conc.Signal.runHandlersPtr1_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlersPtr1_entry() //  [R2, R3]
         { []
         }
     {offset
       canwx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canwy; else goto canwz;
       canwy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.runHandlersPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canwz: // global
           I64[Sp - 16] = block_canwu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanwD; else goto canwv;
       uanwD: // global
           call _canwu(R1) args: 0, res: 0, upd: 0;
       canwv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.runHandlersPtr1_info" {
     GHC.Conc.Signal.runHandlersPtr1_info:
         const GHC.Conc.Signal.runHandlersPtr1_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const SamXS_srt+56;
 },
 _canwu() //  [R1]
         { []
         }
     {offset
       canwu: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Signal.$wrunHandlersPtr_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canwu_info" {
     block_canwu_info:
         const _canwu;
         const 1;
         const 4294967326;
         const SamXS_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.23523957 UTC

[section ""data" . GHC.Conc.Signal.runHandlersPtr_closure" {
     GHC.Conc.Signal.runHandlersPtr_closure:
         const GHC.Conc.Signal.runHandlersPtr_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlersPtr_entry() //  [R2, R3]
         { []
         }
     {offset
       canwR: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.runHandlersPtr1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.runHandlersPtr_info" {
     GHC.Conc.Signal.runHandlersPtr_info:
         const GHC.Conc.Signal.runHandlersPtr_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SamXS_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.238669809 UTC

[section ""relreadonly" . SamXS_srt" {
     SamXS_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Conc.Signal.setHandler2_closure;
         const GHC.Conc.Signal.signal_handlers_closure;
         const GHC.Conc.Signal.setHandler1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Signal.runHandlers1_closure;
         const GHC.ForeignPtr.$winsertCFinalizer_closure;
         const GHC.Conc.Signal.$wrunHandlersPtr_closure;
         const GHC.Conc.Signal.runHandlersPtr1_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.785361179 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:05:23.786520624 UTC

[section ""cstring" . GHC.Conc.Signal.$trModule4_bytes" {
     GHC.Conc.Signal.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.788226544 UTC

[section ""data" . GHC.Conc.Signal.$trModule3_closure" {
     GHC.Conc.Signal.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Signal.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.78995387 UTC

[section ""cstring" . GHC.Conc.Signal.$trModule2_bytes" {
     GHC.Conc.Signal.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,83,105,103,110,97,108]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.791620182 UTC

[section ""data" . GHC.Conc.Signal.$trModule1_closure" {
     GHC.Conc.Signal.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Signal.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.793500988 UTC

[section ""data" . GHC.Conc.Signal.$trModule_closure" {
     GHC.Conc.Signal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.Signal.$trModule3_closure+1;
         const GHC.Conc.Signal.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.795251779 UTC

[section ""data" . lvl_ramSF_closure" {
     lvl_ramSF_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.797007244 UTC

[section ""data" . lvl1_ramSG_closure" {
     lvl1_ramSG_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.801904622 UTC

[section ""data" . lvl2_ramSH_closure" {
     lvl2_ramSH_closure:
         const lvl2_ramSH_info;
 },
 sat_sanxB_entry() //  [R1]
         { []
         }
     {offset
       canBf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canBg; else goto canBh;
       canBg: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canBh: // global
           I64[Sp - 16] = block_canB6_info;
           _sanxc::P64 = P64[R1 + 7];
           R1 = _sanxc::P64;
           P64[Sp - 8] = _sanxc::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanxB_info" {
     sat_sanxB_info:
         const sat_sanxB_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _canB6() //  [R1]
         { []
         }
     {offset
       canB6: // global
           _sanxc::P64 = P64[Sp + 8];
           (_sanxw::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetGHCConcSignalSignalHandlerStore(R1);
           if (R1 == _sanxw::I64) goto canBe; else goto canBd;
       canBe: // global
           R1 = _sanxc::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       canBd: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _sanxw::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canB6_info" {
     block_canB6_info:
         const _canB6;
         const 1;
         const 30;
 },
 lvl2_ramSH_entry() //  []
         { []
         }
     {offset
       canBp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canBq; else goto canBr;
       canBq: // global
           R1 = lvl2_ramSH_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canBr: // global
           I64[Sp - 8] = block_canAM_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . lvl2_ramSH_info" {
     lvl2_ramSH_info:
         const lvl2_ramSH_entry;
         const 0;
         const 14;
         const 4294967299;
 },
 _canAM() //  []
         { []
         }
     {offset
       canAM: // global
           I64[Sp] = block_canAO_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = 65;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canAM_info" {
     block_canAM_info:
         const _canAM;
         const 0;
         const 30;
 },
 _canAO() //  [R1]
         { []
         }
     {offset
       canAO: // global
           I64[Sp - 8] = block_canAQ_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canAO_info" {
     block_canAO_info:
         const _canAO;
         const 0;
         const 30;
 },
 _canAQ() //  [R1]
         { []
         }
     {offset
       canAQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto canBw; else goto canBv;
       canBw: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canBv: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl_ramSF_closure+1;
           P64[Hp - 16] = lvl1_ramSG_closure+1;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = 65;
           I64[Sp] = block_canAT_info;
           R2 = Hp - 31;
           _sanx6::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sanx6::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canAQ_info" {
     block_canAQ_info:
         const _canAQ;
         const 1;
         const 30;
 },
 _canAT() //  []
         { []
         }
     {offset
       canAT: // global
           I64[Sp] = block_canAV_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canAT_info" {
     block_canAT_info:
         const _canAT;
         const 1;
         const 30;
 },
 _canAV() //  [R1]
         { []
         }
     {offset
       canAV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto canBA; else goto canBz;
       canBA: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       canBz: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _canAX::P64 = Hp - 23;
           if (R1 == 0) goto canBo; else goto canBn;
       canBo: // global
           I64[Hp - 8] = sat_sanxB_info;
           P64[Hp] = _canAX::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       canBn: // global
           Hp = Hp - 16;
           I64[Sp] = block_canBB_info;
           R1 = _canAX::P64;
           P64[Sp + 8] = _canAX::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canAV_info" {
     block_canAV_info:
         const _canAV;
         const 1;
         const 30;
 },
 _canBB() //  [R1]
         { []
         }
     {offset
       canBB: // global
           _canAX::P64 = P64[Sp + 8];
           (_sanxk::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetGHCConcSignalSignalHandlerStore(R1);
           if (R1 == _sanxk::I64) goto canBK; else goto canBJ;
       canBK: // global
           R1 = _canAX::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       canBJ: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _sanxk::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canBB_info" {
     block_canBB_info:
         const _canBB;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.822560779 UTC

[section ""data" . GHC.Conc.Signal.signal_handlers_closure" {
     GHC.Conc.Signal.signal_handlers_closure:
         const GHC.Conc.Signal.signal_handlers_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Signal.signal_handlers_entry() //  [R1]
         { []
         }
     {offset
       canCH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canCI; else goto canCJ;
       canCI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       canCJ: // global
           (_canCC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_canCC::I64 == 0) goto canCE; else goto canCD;
       canCE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       canCD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _canCC::I64;
           I64[Sp - 24] = block_canCF_info;
           Sp = Sp - 24;
           call lvl2_ramSH_entry() args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.signal_handlers_info" {
     GHC.Conc.Signal.signal_handlers_info:
         const GHC.Conc.Signal.signal_handlers_entry;
         const 0;
         const 21;
 },
 _canCF() //  [R1]
         { []
         }
     {offset
       canCF: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_canCF_info" {
     block_canCF_info:
         const _canCF;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.827677944 UTC

[section ""cstring" . lvl3_ramSI_bytes" {
     lvl3_ramSI_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,115,101,116,72,97,110,100,108,101,114,58,32,115,105,103,110,97,108,32,111,117,116,32,111,102,32,114,97,110,103,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.830080992 UTC

[section ""data" . GHC.Conc.Signal.setHandler2_closure" {
     GHC.Conc.Signal.setHandler2_closure:
         const GHC.Conc.Signal.setHandler2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Signal.setHandler2_entry() //  [R1]
         { []
         }
     {offset
       canD8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canD9; else goto canDa;
       canD9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       canDa: // global
           (_canD3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_canD3::I64 == 0) goto canD5; else goto canD4;
       canD5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       canD4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _canD3::I64;
           I64[Sp - 24] = block_canD6_info;
           R2 = lvl3_ramSI_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.setHandler2_info" {
     GHC.Conc.Signal.setHandler2_info:
         const GHC.Conc.Signal.setHandler2_entry;
         const 0;
         const 4294967317;
         const SanDe_srt;
 },
 _canD6() //  [R1]
         { []
         }
     {offset
       canD6: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_canD6_info" {
     block_canD6_info:
         const _canD6;
         const 0;
         const 4294967326;
         const SanDe_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.844428037 UTC

[section ""data" . GHC.Conc.Signal.setHandler1_closure" {
     GHC.Conc.Signal.setHandler1_closure:
         const GHC.Conc.Signal.setHandler1_info;
         const 0;
 },
 io_sanxM_entry() //  [R1, R2]
         { []
         }
     {offset
       canDF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canDT; else goto canDU;
       canDT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canDU: // global
           I64[Sp - 24] = block_canDC_info;
           _sanxG::P64 = P64[R1 + 6];
           _sanxH::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sanxG::P64;
           P64[Sp - 8] = _sanxH::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uanEg; else goto canDD;
       uanEg: // global
           call _canDC(R1) args: 0, res: 0, upd: 0;
       canDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sanxM_info" {
     io_sanxM_info:
         const io_sanxM_entry;
         const 2;
         const 4294967307;
         const 8589934597;
         const SanDe_srt+8;
 },
 _canDC() //  [R1]
         { []
         }
     {offset
       canDC: // global
           I64[Sp - 16] = block_canDI_info;
           _sanxR::P64 = P64[R1 + 15];
           _sanxT::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sanxT::P64;
           P64[Sp] = _sanxR::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanEf; else goto canDJ;
       uanEf: // global
           call _canDI(R1) args: 0, res: 0, upd: 0;
       canDJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canDC_info" {
     block_canDC_info:
         const _canDC;
         const 2;
         const 4294967326;
         const SanDe_srt+8;
 },
 _canDI() //  [R1]
         { []
         }
     {offset
       canDI: // global
           I64[Sp] = block_canDN_info;
           _sanxV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sanxV::I64;
           if (R1 & 7 != 0) goto uanEh; else goto canDO;
       uanEh: // global
           call _canDN(R1) args: 0, res: 0, upd: 0;
       canDO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canDI_info" {
     block_canDI_info:
         const _canDI;
         const 4;
         const 4294967326;
         const SanDe_srt+8;
 },
 _canDN() //  [R1]
         { []
         }
     {offset
       canDN: // global
           I64[Sp] = block_canDS_info;
           _sanxX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sanxX::I64;
           if (R1 & 7 != 0) goto uanEi; else goto canDY;
       uanEi: // global
           call _canDS(R1) args: 0, res: 0, upd: 0;
       canDY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canDN_info" {
     block_canDN_info:
         const _canDN;
         const 132;
         const 4294967326;
         const SanDe_srt+8;
 },
 _canDS() //  [R1]
         { []
         }
     {offset
       canDS: // global
           _sanxZ::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _sanxZ::I64)) goto canEc; else goto canEe;
       canEe: // global
           if (%MO_S_Gt_W64(_sanxZ::I64,
                            I64[Sp + 24])) goto canEc; else goto canEd;
       canEc: // global
           R1 = GHC.Conc.Signal.setHandler2_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       canEd: // global
           _sanxH::P64 = P64[Sp + 32];
           _sanxT::P64 = P64[Sp + 8];
           _sany6::P64 = P64[(_sanxT::P64 + 24) + (_sanxZ::I64 << 3)];
           call MO_WriteBarrier();
           P64[(_sanxT::P64 + 24) + (_sanxZ::I64 << 3)] = _sanxH::P64;
           I64[_sanxT::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_sanxT::P64 + 24) + ((I64[_sanxT::P64 + 8] << 3) + (_sanxZ::I64 >> 7))] = 1 :: W8;
           R1 = _sany6::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canDS_info" {
     block_canDS_info:
         const _canDS;
         const 388;
         const 4294967326;
         const SanDe_srt+8;
 },
 sat_sanyj_entry() //  [R1, R2]
         { []
         }
     {offset
       canEz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canEA; else goto canEB;
       canEA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canEB: // global
           I64[Sp - 16] = block_canEx_info;
           _sanyg::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sanyg::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanyj_info" {
     sat_sanyj_info:
         const sat_sanyj_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _canEx() //  []
         { []
         }
     {offset
       canEx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canEx_info" {
     block_canEx_info:
         const _canEx;
         const 1;
         const 30;
 },
 sat_sanye_entry() //  [R1]
         { []
         }
     {offset
       canEI: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_sanxM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanye_info" {
     sat_sanye_info:
         const sat_sanye_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SanDe_srt+8;
 },
 sat_sanyf_entry() //  [R1]
         { []
         }
     {offset
       canEQ: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanyf_info" {
     sat_sanyf_info:
         const sat_sanyf_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_sanyz_entry() //  [R1, R2]
         { []
         }
     {offset
       canFd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canFe; else goto canFf;
       canFe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canFf: // global
           I64[Sp - 16] = block_canFb_info;
           _sanyw::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sanyw::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanyz_info" {
     sat_sanyz_info:
         const sat_sanyz_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _canFb() //  []
         { []
         }
     {offset
       canFb: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canFb_info" {
     block_canFb_info:
         const _canFb;
         const 1;
         const 30;
 },
 sat_sanyu_entry() //  [R1]
         { []
         }
     {offset
       canFm: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_sanxM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanyu_info" {
     sat_sanyu_info:
         const sat_sanyu_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SanDe_srt+8;
 },
 sat_sanyv_entry() //  [R1]
         { []
         }
     {offset
       canFu: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanyv_info" {
     sat_sanyv_info:
         const sat_sanyv_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_sanyE_entry() //  [R1]
         { []
         }
     {offset
       canFx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canFB; else goto canFC;
       canFB: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canFC: // global
           I64[Sp - 16] = block_canEZ_info;
           _sanxM::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp - 8] = _sanxM::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanFK; else goto canF0;
       uanFK: // global
           call _canEZ(R1) args: 0, res: 0, upd: 0;
       canF0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanyE_info" {
     sat_sanyE_info:
         const sat_sanyE_entry;
         const 1;
         const 12884901897;
         const 4294967299;
         const SanDe_srt+8;
 },
 _canEZ() //  [R1]
         { []
         }
     {offset
       canEZ: // global
           I64[Sp - 8] = block_canF4_info;
           _sanyq::P64 = P64[R1 + 7];
           R1 = _sanyq::P64;
           P64[Sp] = _sanyq::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canEZ_info" {
     block_canEZ_info:
         const _canEZ;
         const 1;
         const 4294967326;
         const SanDe_srt+8;
 },
 _canF4() //  [R1]
         { []
         }
     {offset
       canF4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canFG; else goto canFF;
       canFG: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canFF: // global
           I64[Hp - 56] = sat_sanyz_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sanyu_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sanyv_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canFy_info;
           R2 = Hp - 54;
           _sanyt::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sanyt::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canF4_info" {
     block_canF4_info:
         const _canF4;
         const 2;
         const 4294967326;
         const SanDe_srt+8;
 },
 _canFy() //  [R1]
         { []
         }
     {offset
       canFy: // global
           _sanyq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canFA_info;
           R2 = P64[Sp + 16];
           _sanyC::P64 = R1;
           R1 = _sanyq::P64;
           P64[Sp + 16] = _sanyC::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canFy_info" {
     block_canFy_info:
         const _canFy;
         const 2;
         const 30;
 },
 _canFA() //  []
         { []
         }
     {offset
       canFA: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canFA_info" {
     block_canFA_info:
         const _canFA;
         const 1;
         const 30;
 },
 sat_sanyP_entry() //  [R1, R2]
         { []
         }
     {offset
       canG0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canG1; else goto canG2;
       canG1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canG2: // global
           I64[Sp - 16] = block_canFY_info;
           _sanyM::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sanyM::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanyP_info" {
     sat_sanyP_info:
         const sat_sanyP_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _canFY() //  []
         { []
         }
     {offset
       canFY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canFY_info" {
     block_canFY_info:
         const _canFY;
         const 1;
         const 30;
 },
 sat_sanyK_entry() //  [R1]
         { []
         }
     {offset
       canG9: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_sanxM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanyK_info" {
     sat_sanyK_info:
         const sat_sanyK_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SanDe_srt+8;
 },
 sat_sanyL_entry() //  [R1]
         { []
         }
     {offset
       canGh: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanyL_info" {
     sat_sanyL_info:
         const sat_sanyL_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 GHC.Conc.Signal.setHandler1_entry() //  [R2, R3]
         { []
         }
     {offset
       canGo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canGp; else goto canGq;
       canGp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.setHandler1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canGq: // global
           I64[Sp - 24] = block_canDv_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.setHandler1_info" {
     GHC.Conc.Signal.setHandler1_info:
         const GHC.Conc.Signal.setHandler1_entry;
         const 0;
         const 30064771086;
         const 12884901903;
         const SanDe_srt+8;
 },
 _canDv() //  [R1]
         { []
         }
     {offset
       canDv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto canGt; else goto canGs;
       canGt: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       canGs: // global
           I64[Hp - 32] = io_sanxM_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           _canDx::P64 = Hp - 30;
           if (R1 == 0) goto canGm; else goto uanGO;
       canGm: // global
           I64[Hp - 8] = sat_sanyE_info;
           P64[Hp] = _canDx::P64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uanGO: // global
           if (R1 == 1) goto canGn; else goto canGl;
       canGn: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_canFM_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canDx::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanGQ; else goto canFN;
       uanGQ: // global
           call _canFM(R1) args: 0, res: 0, upd: 0;
       canFN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       canGl: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_canEl_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canDx::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanGP; else goto canEm;
       uanGP: // global
           call _canEl(R1) args: 0, res: 0, upd: 0;
       canEm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canDv_info" {
     block_canDv_info:
         const _canDv;
         const 2;
         const 12884901918;
         const SanDe_srt+8;
 },
 _canFM() //  [R1]
         { []
         }
     {offset
       canFM: // global
           I64[Sp - 8] = block_canFR_info;
           _sanyG::P64 = P64[R1 + 7];
           R1 = _sanyG::P64;
           P64[Sp] = _sanyG::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canFM_info" {
     block_canFM_info:
         const _canFM;
         const 1;
         const 4294967326;
         const SanDe_srt+8;
 },
 _canFR() //  [R1]
         { []
         }
     {offset
       canFR: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canGK; else goto canGJ;
       canGK: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canGJ: // global
           I64[Hp - 56] = sat_sanyP_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sanyK_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sanyL_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canGE_info;
           R2 = Hp - 54;
           _sanyJ::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sanyJ::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canFR_info" {
     block_canFR_info:
         const _canFR;
         const 2;
         const 4294967326;
         const SanDe_srt+8;
 },
 _canGE() //  [R1]
         { []
         }
     {offset
       canGE: // global
           _sanyG::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canGG_info;
           R2 = P64[Sp + 16];
           _sanyS::P64 = R1;
           R1 = _sanyG::P64;
           P64[Sp + 16] = _sanyS::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canGE_info" {
     block_canGE_info:
         const _canGE;
         const 2;
         const 30;
 },
 _canGG() //  []
         { []
         }
     {offset
       canGG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canGG_info" {
     block_canGG_info:
         const _canGG;
         const 1;
         const 30;
 },
 _canEl() //  [R1]
         { []
         }
     {offset
       canEl: // global
           I64[Sp - 8] = block_canEq_info;
           _sanya::P64 = P64[R1 + 7];
           R1 = _sanya::P64;
           P64[Sp] = _sanya::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canEl_info" {
     block_canEl_info:
         const _canEl;
         const 1;
         const 4294967326;
         const SanDe_srt+8;
 },
 _canEq() //  [R1]
         { []
         }
     {offset
       canEq: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canGA; else goto canGz;
       canGA: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canGz: // global
           I64[Hp - 56] = sat_sanyj_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sanye_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sanyf_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canGu_info;
           R2 = Hp - 54;
           _sanyd::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sanyd::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canEq_info" {
     block_canEq_info:
         const _canEq;
         const 2;
         const 4294967326;
         const SanDe_srt+8;
 },
 _canGu() //  [R1]
         { []
         }
     {offset
       canGu: // global
           _sanya::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canGw_info;
           R2 = P64[Sp + 16];
           _sanym::P64 = R1;
           R1 = _sanya::P64;
           P64[Sp + 16] = _sanym::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canGu_info" {
     block_canGu_info:
         const _canGu;
         const 2;
         const 30;
 },
 _canGw() //  []
         { []
         }
     {offset
       canGw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canGw_info" {
     block_canGw_info:
         const _canGw;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.904837437 UTC

[section ""data" . GHC.Conc.Signal.setHandler_closure" {
     GHC.Conc.Signal.setHandler_closure:
         const GHC.Conc.Signal.setHandler_info;
         const 0;
 },
 GHC.Conc.Signal.setHandler_entry() //  [R2, R3]
         { []
         }
     {offset
       canJw: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.setHandler1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.setHandler_info" {
     GHC.Conc.Signal.setHandler_info:
         const GHC.Conc.Signal.setHandler_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SanDe_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.91939516 UTC

[section ""data" . GHC.Conc.Signal.runHandlers1_closure" {
     GHC.Conc.Signal.runHandlers1_closure:
         const GHC.Conc.Signal.runHandlers1_info;
         const 0;
 },
 sat_sanzi_entry() //  [R1]
         { []
         }
     {offset
       canKl: // global
           R2 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanzi_info" {
     sat_sanzi_info:
         const sat_sanzi_entry;
         const 2;
         const 18;
 },
 sat_sanzj_entry() //  [R1]
         { []
         }
     {offset
       canKo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto canKs; else goto canKr;
       canKs: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canKr: // global
           _sanyU::P64 = P64[R1 + 7];
           _sanzf::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sanzi_info;
           P64[Hp - 8] = _sanyU::P64;
           P64[Hp] = _sanzf::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanzj_info" {
     sat_sanzj_info:
         const sat_sanzj_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SanDe_srt+32;
 },
 $wio_sanz0_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       canKt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canKu; else goto canKv;
       canKu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       canKv: // global
           I64[Sp - 40] = block_canJO_info;
           _sanyU::P64 = P64[R1 + 4];
           R1 = P64[R1 + 12];
           P64[Sp - 32] = _sanyU::P64;
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uanKY; else goto canJP;
       uanKY: // global
           call _canJO(R1) args: 0, res: 0, upd: 0;
       canJP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wio_sanz0_info" {
     $wio_sanz0_info:
         const $wio_sanz0_entry;
         const 2;
         const 4294967307;
         const 17179869201;
         const SanDe_srt+32;
 },
 _canJO() //  [R1]
         { []
         }
     {offset
       canJO: // global
           _sanz6::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _sanz6::I64)) goto uanKQ; else goto canKO;
       uanKQ: // global
           Sp = Sp + 40;
           goto uanKV;
       canKO: // global
           if (%MO_S_Gt_W64(_sanz6::I64,
                            I64[Sp + 24])) goto uanKR; else goto canKB;
       uanKR: // global
           Sp = Sp + 40;
           goto uanKV;
       uanKV: // global
           call _canKF() args: 0, res: 0, upd: 0;
       canKB: // global
           _sanzb::P64 = P64[P64[Sp + 32] + ((_sanz6::I64 << 3) + 24)];
           I64[Sp] = block_canK1_info;
           R1 = _sanzb::P64;
           if (R1 & 7 != 0) goto uanKT; else goto canK2;
       uanKT: // global
           call _canK1(R1) args: 0, res: 0, upd: 0;
       canK2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canJO_info" {
     block_canJO_info:
         const _canJO;
         const 388;
         const 4294967326;
         const SanDe_srt+32;
 },
 _canK1() //  [R1]
         { []
         }
     {offset
       canK1: // global
           if (R1 & 7 == 1) goto uanKS; else goto canKI;
       uanKS: // global
           Sp = Sp + 40;
           call _canKF() args: 0, res: 0, upd: 0;
       canKI: // global
           I64[Sp] = block_canK7_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uanKW; else goto canK8;
       uanKW: // global
           call _canK7(R1) args: 0, res: 0, upd: 0;
       canK8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canK1_info" {
     block_canK1_info:
         const _canK1;
         const 900;
         const 4294967326;
         const SanDe_srt+32;
 },
 _canKF() //  []
         { []
         }
     {offset
       canKF: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _canK7() //  [R1]
         { []
         }
     {offset
       canK7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto canKL; else goto canKK;
       canKL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canKK: // global
           _sanzf::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sanzj_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sanzf::P64;
           I64[Sp + 32] = block_canKG_info;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canK7_info" {
     block_canK7_info:
         const _canK7;
         const 900;
         const 4294967326;
         const SanDe_srt+32;
 },
 _canKG() //  []
         { []
         }
     {offset
       canKG: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canKG_info" {
     block_canKG_info:
         const _canKG;
         const 0;
         const 30;
 },
 io_sanzn_entry() //  [R1, R2]
         { []
         }
     {offset
       canL7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto canLg; else goto canLh;
       canLg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canLh: // global
           I64[Sp - 16] = block_canL4_info;
           _sanz0::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sanz0::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanLq; else goto canL5;
       uanLq: // global
           call _canL4(R1) args: 0, res: 0, upd: 0;
       canL5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . io_sanzn_info" {
     io_sanzn_info:
         const io_sanzn_entry;
         const 1;
         const 4294967305;
         const 8589934597;
         const SanDe_srt+32;
 },
 _canL4() //  [R1]
         { []
         }
     {offset
       canL4: // global
           I64[Sp - 16] = block_canLa_info;
           _sanzs::P64 = P64[R1 + 15];
           _sanzu::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sanzu::P64;
           P64[Sp] = _sanzs::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanLp; else goto canLb;
       uanLp: // global
           call _canLa(R1) args: 0, res: 0, upd: 0;
       canLb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canL4_info" {
     block_canL4_info:
         const _canL4;
         const 1;
         const 4294967326;
         const SanDe_srt+32;
 },
 _canLa() //  [R1]
         { []
         }
     {offset
       canLa: // global
           I64[Sp] = block_canLf_info;
           _sanzw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sanzw::I64;
           if (R1 & 7 != 0) goto uanLr; else goto canLk;
       uanLr: // global
           call _canLf(R1) args: 0, res: 0, upd: 0;
       canLk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canLa_info" {
     block_canLa_info:
         const _canLa;
         const 3;
         const 4294967326;
         const SanDe_srt+32;
 },
 _canLf() //  [R1]
         { []
         }
     {offset
       canLf: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 16];
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call $wio_sanz0_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canLf_info" {
     block_canLf_info:
         const _canLf;
         const 131;
         const 4294967326;
         const SanDe_srt+32;
 },
 sat_sanzK_entry() //  [R1, R2]
         { []
         }
     {offset
       canLI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canLJ; else goto canLK;
       canLJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canLK: // global
           I64[Sp - 16] = block_canLG_info;
           _sanzH::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sanzH::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanzK_info" {
     sat_sanzK_info:
         const sat_sanzK_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _canLG() //  []
         { []
         }
     {offset
       canLG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canLG_info" {
     block_canLG_info:
         const _canLG;
         const 1;
         const 30;
 },
 sat_sanzF_entry() //  [R1]
         { []
         }
     {offset
       canLR: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_sanzn_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanzF_info" {
     sat_sanzF_info:
         const sat_sanzF_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SanDe_srt+32;
 },
 sat_sanzG_entry() //  [R1]
         { []
         }
     {offset
       canLZ: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanzG_info" {
     sat_sanzG_info:
         const sat_sanzG_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_sanA0_entry() //  [R1, R2]
         { []
         }
     {offset
       canMm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canMn; else goto canMo;
       canMn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canMo: // global
           I64[Sp - 16] = block_canMk_info;
           _sanzX::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sanzX::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanA0_info" {
     sat_sanA0_info:
         const sat_sanA0_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _canMk() //  []
         { []
         }
     {offset
       canMk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canMk_info" {
     block_canMk_info:
         const _canMk;
         const 1;
         const 30;
 },
 sat_sanzV_entry() //  [R1]
         { []
         }
     {offset
       canMv: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_sanzn_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanzV_info" {
     sat_sanzV_info:
         const sat_sanzV_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SanDe_srt+32;
 },
 sat_sanzW_entry() //  [R1]
         { []
         }
     {offset
       canMD: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanzW_info" {
     sat_sanzW_info:
         const sat_sanzW_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_sanA5_entry() //  [R1]
         { []
         }
     {offset
       canMG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canMK; else goto canML;
       canMK: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canML: // global
           I64[Sp - 16] = block_canM8_info;
           _sanzn::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp - 8] = _sanzn::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanMT; else goto canM9;
       uanMT: // global
           call _canM8(R1) args: 0, res: 0, upd: 0;
       canM9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanA5_info" {
     sat_sanA5_info:
         const sat_sanA5_entry;
         const 1;
         const 21474836489;
         const 4294967299;
         const SanDe_srt+16;
 },
 _canM8() //  [R1]
         { []
         }
     {offset
       canM8: // global
           I64[Sp - 8] = block_canMd_info;
           _sanzR::P64 = P64[R1 + 7];
           R1 = _sanzR::P64;
           P64[Sp] = _sanzR::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canM8_info" {
     block_canM8_info:
         const _canM8;
         const 1;
         const 4294967326;
         const SanDe_srt+32;
 },
 _canMd() //  [R1]
         { []
         }
     {offset
       canMd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canMP; else goto canMO;
       canMP: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canMO: // global
           I64[Hp - 56] = sat_sanA0_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sanzV_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sanzW_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canMH_info;
           R2 = Hp - 54;
           _sanzU::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sanzU::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canMd_info" {
     block_canMd_info:
         const _canMd;
         const 2;
         const 4294967326;
         const SanDe_srt+32;
 },
 _canMH() //  [R1]
         { []
         }
     {offset
       canMH: // global
           _sanzR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canMJ_info;
           R2 = P64[Sp + 16];
           _sanA3::P64 = R1;
           R1 = _sanzR::P64;
           P64[Sp + 16] = _sanA3::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canMH_info" {
     block_canMH_info:
         const _canMH;
         const 2;
         const 30;
 },
 _canMJ() //  []
         { []
         }
     {offset
       canMJ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canMJ_info" {
     block_canMJ_info:
         const _canMJ;
         const 1;
         const 30;
 },
 sat_sanAg_entry() //  [R1, R2]
         { []
         }
     {offset
       canN9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canNa; else goto canNb;
       canNa: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canNb: // global
           I64[Sp - 16] = block_canN7_info;
           _sanAd::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sanAd::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanAg_info" {
     sat_sanAg_info:
         const sat_sanAg_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _canN7() //  []
         { []
         }
     {offset
       canN7: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canN7_info" {
     block_canN7_info:
         const _canN7;
         const 1;
         const 30;
 },
 sat_sanAb_entry() //  [R1]
         { []
         }
     {offset
       canNi: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_sanzn_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanAb_info" {
     sat_sanAb_info:
         const sat_sanAb_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SanDe_srt+32;
 },
 sat_sanAc_entry() //  [R1]
         { []
         }
     {offset
       canNq: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sanAc_info" {
     sat_sanAc_info:
         const sat_sanAc_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 GHC.Conc.Signal.runHandlers1_entry() //  [R2, R3]
         { []
         }
     {offset
       canNx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canNy; else goto canNz;
       canNy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.runHandlers1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canNz: // global
           I64[Sp - 24] = block_canJH_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.runHandlers1_info" {
     GHC.Conc.Signal.runHandlers1_info:
         const GHC.Conc.Signal.runHandlers1_entry;
         const 0;
         const 55834574862;
         const 12884901903;
         const SanDe_srt+16;
 },
 _canJH() //  [R1]
         { []
         }
     {offset
       canJH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto canNC; else goto canNB;
       canNC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       canNB: // global
           I64[Hp - 48] = $wio_sanz0_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = io_sanzn_info;
           P64[Hp - 16] = Hp - 44;
           _canKZ::P64 = Hp - 22;
           if (R1 == 0) goto canNv; else goto uanNX;
       canNv: // global
           I64[Hp - 8] = sat_sanA5_info;
           P64[Hp] = _canKZ::P64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uanNX: // global
           if (R1 == 1) goto canNw; else goto canNu;
       canNw: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_canMV_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canKZ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanNZ; else goto canMW;
       uanNZ: // global
           call _canMV(R1) args: 0, res: 0, upd: 0;
       canMW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       canNu: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_canLu_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canKZ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanNY; else goto canLv;
       uanNY: // global
           call _canLu(R1) args: 0, res: 0, upd: 0;
       canLv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canJH_info" {
     block_canJH_info:
         const _canJH;
         const 2;
         const 21474836510;
         const SanDe_srt+16;
 },
 _canMV() //  [R1]
         { []
         }
     {offset
       canMV: // global
           I64[Sp - 8] = block_canN0_info;
           _sanA7::P64 = P64[R1 + 7];
           R1 = _sanA7::P64;
           P64[Sp] = _sanA7::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canMV_info" {
     block_canMV_info:
         const _canMV;
         const 1;
         const 4294967326;
         const SanDe_srt+32;
 },
 _canN0() //  [R1]
         { []
         }
     {offset
       canN0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canNT; else goto canNS;
       canNT: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canNS: // global
           I64[Hp - 56] = sat_sanAg_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sanAb_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sanAc_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canNN_info;
           R2 = Hp - 54;
           _sanAa::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sanAa::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canN0_info" {
     block_canN0_info:
         const _canN0;
         const 2;
         const 4294967326;
         const SanDe_srt+32;
 },
 _canNN() //  [R1]
         { []
         }
     {offset
       canNN: // global
           _sanA7::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canNP_info;
           R2 = P64[Sp + 16];
           _sanAj::P64 = R1;
           R1 = _sanA7::P64;
           P64[Sp + 16] = _sanAj::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canNN_info" {
     block_canNN_info:
         const _canNN;
         const 2;
         const 30;
 },
 _canNP() //  []
         { []
         }
     {offset
       canNP: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canNP_info" {
     block_canNP_info:
         const _canNP;
         const 1;
         const 30;
 },
 _canLu() //  [R1]
         { []
         }
     {offset
       canLu: // global
           I64[Sp - 8] = block_canLz_info;
           _sanzB::P64 = P64[R1 + 7];
           R1 = _sanzB::P64;
           P64[Sp] = _sanzB::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canLu_info" {
     block_canLu_info:
         const _canLu;
         const 1;
         const 4294967326;
         const SanDe_srt+32;
 },
 _canLz() //  [R1]
         { []
         }
     {offset
       canLz: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canNJ; else goto canNI;
       canNJ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canNI: // global
           I64[Hp - 56] = sat_sanzK_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sanzF_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sanzG_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canND_info;
           R2 = Hp - 54;
           _sanzE::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sanzE::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canLz_info" {
     block_canLz_info:
         const _canLz;
         const 2;
         const 4294967326;
         const SanDe_srt+32;
 },
 _canND() //  [R1]
         { []
         }
     {offset
       canND: // global
           _sanzB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canNF_info;
           R2 = P64[Sp + 16];
           _sanzN::P64 = R1;
           R1 = _sanzB::P64;
           P64[Sp + 16] = _sanzN::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canND_info" {
     block_canND_info:
         const _canND;
         const 2;
         const 30;
 },
 _canNF() //  []
         { []
         }
     {offset
       canNF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canNF_info" {
     block_canNF_info:
         const _canNF;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.990030863 UTC

[section ""data" . GHC.Conc.Signal.runHandlers_closure" {
     GHC.Conc.Signal.runHandlers_closure:
         const GHC.Conc.Signal.runHandlers_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlers_entry() //  [R2, R3]
         { []
         }
     {offset
       canRc: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.runHandlers_info" {
     GHC.Conc.Signal.runHandlers_info:
         const GHC.Conc.Signal.runHandlers_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SanDe_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:23.994130636 UTC

[section ""data" . GHC.Conc.Signal.$wrunHandlersPtr_closure" {
     GHC.Conc.Signal.$wrunHandlersPtr_closure:
         const GHC.Conc.Signal.$wrunHandlersPtr_info;
         const 0;
 },
 GHC.Conc.Signal.$wrunHandlersPtr_entry() //  [R2, R3]
         { []
         }
     {offset
       canRt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canRu; else goto canRv;
       canRu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.$wrunHandlersPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canRv: // global
           I64[Sp - 24] = block_canRn_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.$wrunHandlersPtr_info" {
     GHC.Conc.Signal.$wrunHandlersPtr_info:
         const GHC.Conc.Signal.$wrunHandlersPtr_entry;
         const 0;
         const 30064771086;
         const 12884901901;
         const SanDe_srt+40;
 },
 _canRn() //  [R1]
         { []
         }
     {offset
       canRn: // global
           I64[Sp - 8] = block_canRp_info;
           R6 = I64[Sp + 8];
           R5 = 0;
           R4 = 0;
           R3 = free;
           R2 = R1;
           P64[Sp - 16] = GHC.Tuple.()_closure+1;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_canRn_info" {
     block_canRn_info:
         const _canRn;
         const 66;
         const 12884901918;
         const SanDe_srt+40;
 },
 _canRp() //  [R1]
         { []
         }
     {offset
       canRp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto canRz; else goto canRy;
       canRz: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canRy: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R3 = P64[Sp + 24];
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canRp_info" {
     block_canRp_info:
         const _canRp;
         const 131;
         const 4294967326;
         const SanDe_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:24.001651989 UTC

[section ""data" . GHC.Conc.Signal.runHandlersPtr1_closure" {
     GHC.Conc.Signal.runHandlersPtr1_closure:
         const GHC.Conc.Signal.runHandlersPtr1_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlersPtr1_entry() //  [R2, R3]
         { []
         }
     {offset
       canS2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canS3; else goto canS4;
       canS3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.runHandlersPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canS4: // global
           I64[Sp - 16] = block_canRZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanS8; else goto canS0;
       uanS8: // global
           call _canRZ(R1) args: 0, res: 0, upd: 0;
       canS0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.runHandlersPtr1_info" {
     GHC.Conc.Signal.runHandlersPtr1_info:
         const GHC.Conc.Signal.runHandlersPtr1_entry;
         const 0;
         const 12884901902;
         const 12884901903;
         const SanDe_srt+56;
 },
 _canRZ() //  [R1]
         { []
         }
     {offset
       canRZ: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Signal.$wrunHandlersPtr_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_canRZ_info" {
     block_canRZ_info:
         const _canRZ;
         const 1;
         const 4294967326;
         const SanDe_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:24.006770759 UTC

[section ""data" . GHC.Conc.Signal.runHandlersPtr_closure" {
     GHC.Conc.Signal.runHandlersPtr_closure:
         const GHC.Conc.Signal.runHandlersPtr_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlersPtr_entry() //  [R2, R3]
         { []
         }
     {offset
       canSn: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.runHandlersPtr1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.Signal.runHandlersPtr_info" {
     GHC.Conc.Signal.runHandlersPtr_info:
         const GHC.Conc.Signal.runHandlersPtr_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SanDe_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:24.009868485 UTC

[section ""relreadonly" . SanDe_srt" {
     SanDe_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Conc.Signal.setHandler2_closure;
         const GHC.Conc.Signal.signal_handlers_closure;
         const GHC.Conc.Signal.setHandler1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Signal.runHandlers1_closure;
         const GHC.ForeignPtr.$winsertCFinalizer_closure;
         const GHC.Conc.Signal.$wrunHandlersPtr_closure;
         const GHC.Conc.Signal.runHandlersPtr1_closure;
 }]

