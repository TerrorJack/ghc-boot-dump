
==================== Output Cmm ====================
2018-03-16 16:04:45.460768432 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:45.461873952 UTC

[section ""data" . GHC.Conc.Sync.$fEqTVar_$c==_closure" {
     GHC.Conc.Sync.$fEqTVar_$c==_closure:
         const GHC.Conc.Sync.$fEqTVar_$c==_info;
 },
 GHC.Conc.Sync.$fEqTVar_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9FMq,
                       label: GHC.Conc.Sync.$fEqTVar_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FMq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9FMu; else goto c9FMv;
       c9FMu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqTVar_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9FMv: // global
           I64[Sp - 16] = block_c9FMn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9FME; else goto c9FMo;
       u9FME: // global
           call _c9FMn(R1) args: 0, res: 0, upd: 0;
       c9FMo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FMn() //  [R1]
         { info_tbl: [(c9FMn,
                       label: block_c9FMn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FMn: // global
           I64[Sp] = block_c9FMt_info;
           _s9Fvt::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9Fvt::P64;
           if (R1 & 7 != 0) goto u9FMD; else goto c9FMx;
       u9FMD: // global
           call _c9FMt(R1) args: 0, res: 0, upd: 0;
       c9FMx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FMt() //  [R1]
         { info_tbl: [(c9FMt,
                       label: block_c9FMt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FMt: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.463478063 UTC

[section ""data" . GHC.Conc.Sync.$fEqTVar_$c/=_closure" {
     GHC.Conc.Sync.$fEqTVar_$c/=_closure:
         const GHC.Conc.Sync.$fEqTVar_$c/=_info;
 },
 GHC.Conc.Sync.$fEqTVar_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9FMM,
                       label: GHC.Conc.Sync.$fEqTVar_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FMM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9FMQ; else goto c9FMR;
       c9FMQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqTVar_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9FMR: // global
           I64[Sp - 16] = block_c9FMJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9FNe; else goto c9FMK;
       u9FNe: // global
           call _c9FMJ(R1) args: 0, res: 0, upd: 0;
       c9FMK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FMJ() //  [R1]
         { info_tbl: [(c9FMJ,
                       label: block_c9FMJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FMJ: // global
           I64[Sp] = block_c9FMP_info;
           _s9FvA::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FvA::P64;
           if (R1 & 7 != 0) goto u9FNd; else goto c9FMT;
       u9FNd: // global
           call _c9FMP(R1) args: 0, res: 0, upd: 0;
       c9FMT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FMP() //  [R1]
         { info_tbl: [(c9FMP,
                       label: block_c9FMP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FMP: // global
           if (P64[Sp + 8] == P64[R1 + 7]) goto c9FN9; else goto c9FN3;
       c9FN9: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9FN3: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.464718912 UTC

[section ""data" . GHC.Conc.Sync.$fEqTVar_closure" {
     GHC.Conc.Sync.$fEqTVar_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqTVar_$c==_closure+2;
         const GHC.Conc.Sync.$fEqTVar_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.465280348 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason12_bytes" {
     GHC.Conc.Sync.$fShowBlockReason12_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.466027316 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason11_closure" {
     GHC.Conc.Sync.$fShowBlockReason11_closure:
         const GHC.Conc.Sync.$fShowBlockReason11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason11_entry() //  [R1]
         { info_tbl: [(c9FNl,
                       label: GHC.Conc.Sync.$fShowBlockReason11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FNl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9FNm; else goto c9FNn;
       c9FNm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9FNn: // global
           (_c9FNi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9FNi::I64 == 0) goto c9FNk; else goto c9FNj;
       c9FNk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9FNj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9FNi::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason12_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.466887442 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason10_bytes" {
     GHC.Conc.Sync.$fShowBlockReason10_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,66,108,97,99,107,72,111,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.467570483 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason9_closure" {
     GHC.Conc.Sync.$fShowBlockReason9_closure:
         const GHC.Conc.Sync.$fShowBlockReason9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason9_entry() //  [R1]
         { info_tbl: [(c9FNu,
                       label: GHC.Conc.Sync.$fShowBlockReason9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FNu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9FNv; else goto c9FNw;
       c9FNv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9FNw: // global
           (_c9FNr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9FNr::I64 == 0) goto c9FNt; else goto c9FNs;
       c9FNt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9FNs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9FNr::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.468441341 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason8_bytes" {
     GHC.Conc.Sync.$fShowBlockReason8_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.469166887 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason7_closure" {
     GHC.Conc.Sync.$fShowBlockReason7_closure:
         const GHC.Conc.Sync.$fShowBlockReason7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason7_entry() //  [R1]
         { info_tbl: [(c9FND,
                       label: GHC.Conc.Sync.$fShowBlockReason7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FND: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9FNE; else goto c9FNF;
       c9FNE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9FNF: // global
           (_c9FNA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9FNA::I64 == 0) goto c9FNC; else goto c9FNB;
       c9FNC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9FNB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9FNA::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.470065768 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason6_bytes" {
     GHC.Conc.Sync.$fShowBlockReason6_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.470750672 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason5_closure" {
     GHC.Conc.Sync.$fShowBlockReason5_closure:
         const GHC.Conc.Sync.$fShowBlockReason5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason5_entry() //  [R1]
         { info_tbl: [(c9FNM,
                       label: GHC.Conc.Sync.$fShowBlockReason5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FNM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9FNN; else goto c9FNO;
       c9FNN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9FNO: // global
           (_c9FNJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9FNJ::I64 == 0) goto c9FNL; else goto c9FNK;
       c9FNL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9FNK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9FNJ::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.471563425 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason4_bytes" {
     GHC.Conc.Sync.$fShowBlockReason4_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,70,111,114,101,105,103,110,67,97,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.472256248 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason3_closure" {
     GHC.Conc.Sync.$fShowBlockReason3_closure:
         const GHC.Conc.Sync.$fShowBlockReason3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason3_entry() //  [R1]
         { info_tbl: [(c9FNV,
                       label: GHC.Conc.Sync.$fShowBlockReason3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FNV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9FNW; else goto c9FNX;
       c9FNW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9FNX: // global
           (_c9FNS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9FNS::I64 == 0) goto c9FNU; else goto c9FNT;
       c9FNU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9FNT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9FNS::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.473127297 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason2_bytes" {
     GHC.Conc.Sync.$fShowBlockReason2_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,79,116,104,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.473909711 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason1_closure" {
     GHC.Conc.Sync.$fShowBlockReason1_closure:
         const GHC.Conc.Sync.$fShowBlockReason1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason1_entry() //  [R1]
         { info_tbl: [(c9FO4,
                       label: GHC.Conc.Sync.$fShowBlockReason1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FO4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9FO5; else goto c9FO6;
       c9FO5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9FO6: // global
           (_c9FO1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9FO1::I64 == 0) goto c9FO3; else goto c9FO2;
       c9FO3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9FO2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9FO1::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.475191523 UTC

[section ""data" . GHC.Conc.Sync.$w$cshowsPrec_closure" {
     GHC.Conc.Sync.$w$cshowsPrec_closure:
         const GHC.Conc.Sync.$w$cshowsPrec_info;
         const 0;
 },
 GHC.Conc.Sync.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c9FOm,
                       label: GHC.Conc.Sync.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FOm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9FOn; else goto c9FOo;
       c9FOn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9FOo: // global
           I64[Sp - 16] = block_c9FOb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9FOH; else goto c9FOc;
       u9FOH: // global
           call _c9FOb(R1) args: 0, res: 0, upd: 0;
       c9FOc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FOb() //  [R1]
         { info_tbl: [(c9FOb,
                       label: block_c9FOb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FOb: // global
           _s9FvF::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9FOf;
               case 2 : goto c9FOg;
               case 3 : goto c9FOh;
               case 4 : goto c9FOi;
               case 5 : goto c9FOj;
               case 6 : goto c9FOk;
           }
       c9FOk: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9FOj: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9FOi: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9FOh: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9FOg: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason9_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9FOf: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason11_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.476724532 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_closure" {
     GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_closure:
         const GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c9FON,
                       label: GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FON: // global
           _s9FvI::P64 = R3;
           R3 = R4;
           R2 = _s9FvI::P64;
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.477787732 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_$cshow_closure" {
     GHC.Conc.Sync.$fShowBlockReason_$cshow_closure:
         const GHC.Conc.Sync.$fShowBlockReason_$cshow_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason_$cshow_entry() //  [R2]
         { info_tbl: [(c9FP5,
                       label: GHC.Conc.Sync.$fShowBlockReason_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FP5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9FP6; else goto c9FP7;
       c9FP6: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowBlockReason_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9FP7: // global
           I64[Sp - 8] = block_c9FOU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9FPq; else goto c9FOV;
       u9FPq: // global
           call _c9FOU(R1) args: 0, res: 0, upd: 0;
       c9FOV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FOU() //  [R1]
         { info_tbl: [(c9FOU,
                       label: block_c9FOU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FOU: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9FOY;
               case 2 : goto c9FOZ;
               case 3 : goto c9FP0;
               case 4 : goto c9FP1;
               case 5 : goto c9FP2;
               case 6 : goto c9FP3;
           }
       c9FP3: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9FP2: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9FP1: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9FP0: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9FOZ: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9FOY: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.479159357 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_$cshowList_closure" {
     GHC.Conc.Sync.$fShowBlockReason_$cshowList_closure:
         const GHC.Conc.Sync.$fShowBlockReason_$cshowList_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c9FPv,
                       label: GHC.Conc.Sync.$fShowBlockReason_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FPv: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.479907739 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_closure" {
     GHC.Conc.Sync.$fShowBlockReason_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_closure+3;
         const GHC.Conc.Sync.$fShowBlockReason_$cshow_closure+1;
         const GHC.Conc.Sync.$fShowBlockReason_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.481494615 UTC

[section ""data" . GHC.Conc.Sync.$fEqBlockReason_$c==_closure" {
     GHC.Conc.Sync.$fEqBlockReason_$c==_closure:
         const GHC.Conc.Sync.$fEqBlockReason_$c==_info;
 },
 GHC.Conc.Sync.$fEqBlockReason_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9FPN,
                       label: GHC.Conc.Sync.$fEqBlockReason_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FPN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9FPO; else goto c9FPP;
       c9FPO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqBlockReason_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9FPP: // global
           I64[Sp - 16] = block_c9FPC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9FRG; else goto c9FPD;
       u9FRG: // global
           call _c9FPC(R1) args: 0, res: 0, upd: 0;
       c9FPD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FPC() //  [R1]
         { info_tbl: [(c9FPC,
                       label: block_c9FPC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FPC: // global
           _s9FvP::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9FPG;
               case 2 : goto c9FPH;
               case 3 : goto c9FPI;
               case 4 : goto c9FPJ;
               case 5 : goto c9FPK;
               case 6 : goto c9FPL;
           }
       c9FPL: // global
           I64[Sp + 8] = block_c9FR5_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FRF; else goto c9FR7;
       u9FRF: // global
           call _c9FR5(R1) args: 0, res: 0, upd: 0;
       c9FR7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FPK: // global
           I64[Sp + 8] = block_c9FQQ_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FRE; else goto c9FQS;
       u9FRE: // global
           call _c9FQQ(R1) args: 0, res: 0, upd: 0;
       c9FQS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FPJ: // global
           I64[Sp + 8] = block_c9FQB_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FRD; else goto c9FQD;
       u9FRD: // global
           call _c9FQB(R1) args: 0, res: 0, upd: 0;
       c9FQD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FPI: // global
           I64[Sp + 8] = block_c9FQm_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FRC; else goto c9FQo;
       u9FRC: // global
           call _c9FQm(R1) args: 0, res: 0, upd: 0;
       c9FQo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FPH: // global
           I64[Sp + 8] = block_c9FQ7_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FRB; else goto c9FQ9;
       u9FRB: // global
           call _c9FQ7(R1) args: 0, res: 0, upd: 0;
       c9FQ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FPG: // global
           I64[Sp + 8] = block_c9FPS_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FRA; else goto c9FPU;
       u9FRA: // global
           call _c9FPS(R1) args: 0, res: 0, upd: 0;
       c9FPU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FR5() //  [R1]
         { info_tbl: [(c9FR5,
                       label: block_c9FR5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FR5: // global
           if (R1 & 7 == 6) goto u9FRo; else goto u9FRp;
       u9FRo: // global
           Sp = Sp + 8;
           call _c9FRh() args: 0, res: 0, upd: 0;
       u9FRp: // global
           Sp = Sp + 8;
           call _c9FRd() args: 0, res: 0, upd: 0;
     }
 },
 _c9FQQ() //  [R1]
         { info_tbl: [(c9FQQ,
                       label: block_c9FQQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FQQ: // global
           if (R1 & 7 == 5) goto u9FRq; else goto u9FRr;
       u9FRq: // global
           Sp = Sp + 8;
           call _c9FRh() args: 0, res: 0, upd: 0;
       u9FRr: // global
           Sp = Sp + 8;
           call _c9FRd() args: 0, res: 0, upd: 0;
     }
 },
 _c9FQB() //  [R1]
         { info_tbl: [(c9FQB,
                       label: block_c9FQB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FQB: // global
           if (R1 & 7 == 4) goto u9FRs; else goto u9FRt;
       u9FRs: // global
           Sp = Sp + 8;
           call _c9FRh() args: 0, res: 0, upd: 0;
       u9FRt: // global
           Sp = Sp + 8;
           call _c9FRd() args: 0, res: 0, upd: 0;
     }
 },
 _c9FQm() //  [R1]
         { info_tbl: [(c9FQm,
                       label: block_c9FQm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FQm: // global
           if (R1 & 7 == 3) goto u9FRu; else goto u9FRv;
       u9FRu: // global
           Sp = Sp + 8;
           call _c9FRh() args: 0, res: 0, upd: 0;
       u9FRv: // global
           Sp = Sp + 8;
           call _c9FRd() args: 0, res: 0, upd: 0;
     }
 },
 _c9FQ7() //  [R1]
         { info_tbl: [(c9FQ7,
                       label: block_c9FQ7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FQ7: // global
           if (R1 & 7 == 2) goto u9FRw; else goto u9FRx;
       u9FRw: // global
           Sp = Sp + 8;
           call _c9FRh() args: 0, res: 0, upd: 0;
       u9FRx: // global
           Sp = Sp + 8;
           call _c9FRd() args: 0, res: 0, upd: 0;
     }
 },
 _c9FPS() //  [R1]
         { info_tbl: [(c9FPS,
                       label: block_c9FPS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FPS: // global
           if (R1 & 7 == 1) goto u9FRy; else goto u9FRz;
       u9FRy: // global
           Sp = Sp + 8;
           call _c9FRh() args: 0, res: 0, upd: 0;
       u9FRz: // global
           Sp = Sp + 8;
           call _c9FRd() args: 0, res: 0, upd: 0;
     }
 },
 _c9FRh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FRh: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9FRd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FRd: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.484997284 UTC

[section ""data" . GHC.Conc.Sync.$fEqBlockReason_$c/=_closure" {
     GHC.Conc.Sync.$fEqBlockReason_$c/=_closure:
         const GHC.Conc.Sync.$fEqBlockReason_$c/=_info;
 },
 GHC.Conc.Sync.$fEqBlockReason_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9FS8,
                       label: GHC.Conc.Sync.$fEqBlockReason_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FS8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9FS9; else goto c9FSa;
       c9FS9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqBlockReason_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9FSa: // global
           I64[Sp - 16] = block_c9FRX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9FU1; else goto c9FRY;
       u9FU1: // global
           call _c9FRX(R1) args: 0, res: 0, upd: 0;
       c9FRY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FRX() //  [R1]
         { info_tbl: [(c9FRX,
                       label: block_c9FRX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FRX: // global
           _s9FvY::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9FS1;
               case 2 : goto c9FS2;
               case 3 : goto c9FS3;
               case 4 : goto c9FS4;
               case 5 : goto c9FS5;
               case 6 : goto c9FS6;
           }
       c9FS6: // global
           I64[Sp + 8] = block_c9FTq_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FU0; else goto c9FTs;
       u9FU0: // global
           call _c9FTq(R1) args: 0, res: 0, upd: 0;
       c9FTs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FS5: // global
           I64[Sp + 8] = block_c9FTb_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FTZ; else goto c9FTd;
       u9FTZ: // global
           call _c9FTb(R1) args: 0, res: 0, upd: 0;
       c9FTd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FS4: // global
           I64[Sp + 8] = block_c9FSW_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FTY; else goto c9FSY;
       u9FTY: // global
           call _c9FSW(R1) args: 0, res: 0, upd: 0;
       c9FSY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FS3: // global
           I64[Sp + 8] = block_c9FSH_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FTX; else goto c9FSJ;
       u9FTX: // global
           call _c9FSH(R1) args: 0, res: 0, upd: 0;
       c9FSJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FS2: // global
           I64[Sp + 8] = block_c9FSs_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FTW; else goto c9FSu;
       u9FTW: // global
           call _c9FSs(R1) args: 0, res: 0, upd: 0;
       c9FSu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FS1: // global
           I64[Sp + 8] = block_c9FSd_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FTV; else goto c9FSf;
       u9FTV: // global
           call _c9FSd(R1) args: 0, res: 0, upd: 0;
       c9FSf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FTq() //  [R1]
         { info_tbl: [(c9FTq,
                       label: block_c9FTq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FTq: // global
           if (R1 & 7 == 6) goto u9FTJ; else goto u9FTK;
       u9FTJ: // global
           Sp = Sp + 8;
           call _c9FTC() args: 0, res: 0, upd: 0;
       u9FTK: // global
           Sp = Sp + 8;
           call _c9FTy() args: 0, res: 0, upd: 0;
     }
 },
 _c9FTb() //  [R1]
         { info_tbl: [(c9FTb,
                       label: block_c9FTb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FTb: // global
           if (R1 & 7 == 5) goto u9FTL; else goto u9FTM;
       u9FTL: // global
           Sp = Sp + 8;
           call _c9FTC() args: 0, res: 0, upd: 0;
       u9FTM: // global
           Sp = Sp + 8;
           call _c9FTy() args: 0, res: 0, upd: 0;
     }
 },
 _c9FSW() //  [R1]
         { info_tbl: [(c9FSW,
                       label: block_c9FSW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FSW: // global
           if (R1 & 7 == 4) goto u9FTN; else goto u9FTO;
       u9FTN: // global
           Sp = Sp + 8;
           call _c9FTC() args: 0, res: 0, upd: 0;
       u9FTO: // global
           Sp = Sp + 8;
           call _c9FTy() args: 0, res: 0, upd: 0;
     }
 },
 _c9FSH() //  [R1]
         { info_tbl: [(c9FSH,
                       label: block_c9FSH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FSH: // global
           if (R1 & 7 == 3) goto u9FTP; else goto u9FTQ;
       u9FTP: // global
           Sp = Sp + 8;
           call _c9FTC() args: 0, res: 0, upd: 0;
       u9FTQ: // global
           Sp = Sp + 8;
           call _c9FTy() args: 0, res: 0, upd: 0;
     }
 },
 _c9FSs() //  [R1]
         { info_tbl: [(c9FSs,
                       label: block_c9FSs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FSs: // global
           if (R1 & 7 == 2) goto u9FTR; else goto u9FTS;
       u9FTR: // global
           Sp = Sp + 8;
           call _c9FTC() args: 0, res: 0, upd: 0;
       u9FTS: // global
           Sp = Sp + 8;
           call _c9FTy() args: 0, res: 0, upd: 0;
     }
 },
 _c9FSd() //  [R1]
         { info_tbl: [(c9FSd,
                       label: block_c9FSd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FSd: // global
           if (R1 & 7 == 1) goto u9FTT; else goto u9FTU;
       u9FTT: // global
           Sp = Sp + 8;
           call _c9FTC() args: 0, res: 0, upd: 0;
       u9FTU: // global
           Sp = Sp + 8;
           call _c9FTy() args: 0, res: 0, upd: 0;
     }
 },
 _c9FTC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FTC: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9FTy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FTy: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.487922533 UTC

[section ""data" . GHC.Conc.Sync.$fEqBlockReason_closure" {
     GHC.Conc.Sync.$fEqBlockReason_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqBlockReason_$c==_closure+2;
         const GHC.Conc.Sync.$fEqBlockReason_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.489322977 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadStatus_$c==_closure" {
     GHC.Conc.Sync.$fEqThreadStatus_$c==_closure:
         const GHC.Conc.Sync.$fEqThreadStatus_$c==_info;
 },
 GHC.Conc.Sync.$fEqThreadStatus_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9FUr,
                       label: GHC.Conc.Sync.$fEqThreadStatus_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FUr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9FUs; else goto c9FUt;
       c9FUs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadStatus_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9FUt: // global
           I64[Sp - 16] = block_c9FUi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9FVJ; else goto c9FUj;
       u9FVJ: // global
           call _c9FUi(R1) args: 0, res: 0, upd: 0;
       c9FUj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FUi() //  [R1]
         { info_tbl: [(c9FUi,
                       label: block_c9FUi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FUi: // global
           _s9Fw7::P64 = P64[Sp + 8];
           _c9FUq::P64 = R1 & 7;
           if (_c9FUq::P64 < 3) goto u9FVw; else goto u9FVx;
       u9FVw: // global
           if (_c9FUq::P64 < 2) goto c9FUm; else goto c9FUn;
       c9FUm: // global
           I64[Sp + 8] = block_c9FUw_info;
           R1 = _s9Fw7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FVF; else goto c9FUy;
       u9FVF: // global
           call _c9FUw(R1) args: 0, res: 0, upd: 0;
       c9FUy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FUn: // global
           I64[Sp + 8] = block_c9FUL_info;
           R1 = _s9Fw7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FVG; else goto c9FUN;
       u9FVG: // global
           call _c9FUL(R1) args: 0, res: 0, upd: 0;
       c9FUN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9FVx: // global
           if (_c9FUq::P64 < 4) goto c9FUo; else goto c9FUp;
       c9FUo: // global
           I64[Sp] = block_c9FV0_info;
           _s9Fwb::P64 = P64[R1 + 5];
           R1 = _s9Fw7::P64;
           P64[Sp + 8] = _s9Fwb::P64;
           if (R1 & 7 != 0) goto u9FVH; else goto c9FV2;
       u9FVH: // global
           call _c9FV0(R1) args: 0, res: 0, upd: 0;
       c9FV2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FUp: // global
           I64[Sp + 8] = block_c9FVf_info;
           R1 = _s9Fw7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FVI; else goto c9FVh;
       u9FVI: // global
           call _c9FVf(R1) args: 0, res: 0, upd: 0;
       c9FVh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FUw() //  [R1]
         { info_tbl: [(c9FUw,
                       label: block_c9FUw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FUw: // global
           if (R1 & 7 == 1) goto u9FVy; else goto u9FVz;
       u9FVy: // global
           Sp = Sp + 8;
           call _c9FVr() args: 0, res: 0, upd: 0;
       u9FVz: // global
           Sp = Sp + 8;
           call _c9FVn() args: 0, res: 0, upd: 0;
     }
 },
 _c9FUL() //  [R1]
         { info_tbl: [(c9FUL,
                       label: block_c9FUL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FUL: // global
           if (R1 & 7 == 2) goto u9FVA; else goto u9FVB;
       u9FVA: // global
           Sp = Sp + 8;
           call _c9FVr() args: 0, res: 0, upd: 0;
       u9FVB: // global
           Sp = Sp + 8;
           call _c9FVn() args: 0, res: 0, upd: 0;
     }
 },
 _c9FV0() //  [R1]
         { info_tbl: [(c9FV0,
                       label: block_c9FV0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FV0: // global
           if (R1 & 7 == 3) goto c9FVc; else goto u9FVC;
       c9FVc: // global
           R3 = P64[R1 + 5];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$fEqBlockReason_$c==_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
       u9FVC: // global
           Sp = Sp + 16;
           call _c9FVn() args: 0, res: 0, upd: 0;
     }
 },
 _c9FVf() //  [R1]
         { info_tbl: [(c9FVf,
                       label: block_c9FVf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FVf: // global
           if (R1 & 7 == 4) goto u9FVD; else goto u9FVE;
       u9FVD: // global
           Sp = Sp + 8;
           call _c9FVr() args: 0, res: 0, upd: 0;
       u9FVE: // global
           Sp = Sp + 8;
           call _c9FVn() args: 0, res: 0, upd: 0;
     }
 },
 _c9FVr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FVr: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9FVn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FVn: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.493077924 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure" {
     GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure:
         const GHC.Conc.Sync.$fEqThreadStatus_$c/=_info;
 },
 GHC.Conc.Sync.$fEqThreadStatus_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9FW4,
                       label: GHC.Conc.Sync.$fEqThreadStatus_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FW4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9FW5; else goto c9FW6;
       c9FW5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9FW6: // global
           I64[Sp - 16] = block_c9FVV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9FZh; else goto c9FVW;
       u9FZh: // global
           call _c9FVV(R1) args: 0, res: 0, upd: 0;
       c9FVW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FVV() //  [R1]
         { info_tbl: [(c9FVV,
                       label: block_c9FVV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FVV: // global
           _s9Fwg::P64 = P64[Sp + 8];
           _c9FW3::P64 = R1 & 7;
           if (_c9FW3::P64 < 3) goto u9FYS; else goto u9FYT;
       u9FYS: // global
           if (_c9FW3::P64 < 2) goto c9FVZ; else goto c9FW0;
       c9FVZ: // global
           I64[Sp + 8] = block_c9FW9_info;
           R1 = _s9Fwg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FZd; else goto c9FWb;
       u9FZd: // global
           call _c9FW9(R1) args: 0, res: 0, upd: 0;
       c9FWb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FW0: // global
           I64[Sp + 8] = block_c9FWo_info;
           R1 = _s9Fwg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FZe; else goto c9FWq;
       u9FZe: // global
           call _c9FWo(R1) args: 0, res: 0, upd: 0;
       c9FWq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9FYT: // global
           if (_c9FW3::P64 < 4) goto c9FW1; else goto c9FW2;
       c9FW1: // global
           I64[Sp] = block_c9FWD_info;
           _s9Fwk::P64 = P64[R1 + 5];
           R1 = _s9Fwg::P64;
           P64[Sp + 8] = _s9Fwk::P64;
           if (R1 & 7 != 0) goto u9FZf; else goto c9FWF;
       u9FZf: // global
           call _c9FWD(R1) args: 0, res: 0, upd: 0;
       c9FWF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FW2: // global
           I64[Sp + 8] = block_c9FYu_info;
           R1 = _s9Fwg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FZg; else goto c9FYw;
       u9FZg: // global
           call _c9FYu(R1) args: 0, res: 0, upd: 0;
       c9FYw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FW9() //  [R1]
         { info_tbl: [(c9FW9,
                       label: block_c9FW9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FW9: // global
           if (R1 & 7 == 1) goto u9FYU; else goto u9FYV;
       u9FYU: // global
           Sp = Sp + 8;
           call _c9FYG() args: 0, res: 0, upd: 0;
       u9FYV: // global
           Sp = Sp + 8;
           call _c9FYC() args: 0, res: 0, upd: 0;
     }
 },
 _c9FWo() //  [R1]
         { info_tbl: [(c9FWo,
                       label: block_c9FWo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FWo: // global
           if (R1 & 7 == 2) goto u9FYW; else goto u9FYX;
       u9FYW: // global
           Sp = Sp + 8;
           call _c9FYG() args: 0, res: 0, upd: 0;
       u9FYX: // global
           Sp = Sp + 8;
           call _c9FYC() args: 0, res: 0, upd: 0;
     }
 },
 _c9FWD() //  [R1]
         { info_tbl: [(c9FWD,
                       label: block_c9FWD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FWD: // global
           if (R1 & 7 == 3) goto c9FWQ; else goto u9FYY;
       c9FWQ: // global
           I64[Sp] = block_c9FWO_info;
           _s9Fwm::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9Fwm::P64;
           if (R1 & 7 != 0) goto u9FZm; else goto c9FWR;
       u9FZm: // global
           call _c9FWO(R1) args: 0, res: 0, upd: 0;
       c9FWR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9FYY: // global
           Sp = Sp + 16;
           call _c9FYC() args: 0, res: 0, upd: 0;
     }
 },
 _c9FWO() //  [R1]
         { info_tbl: [(c9FWO,
                       label: block_c9FWO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FWO: // global
           _s9Fwm::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9FWY;
               case 2 : goto c9FXe;
               case 3 : goto c9FXu;
               case 4 : goto c9FXK;
               case 5 : goto c9FY0;
               case 6 : goto c9FYg;
           }
       c9FYg: // global
           I64[Sp + 8] = block_c9FYe_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FZt; else goto c9FYh;
       u9FZt: // global
           call _c9FYe(R1) args: 0, res: 0, upd: 0;
       c9FYh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FY0: // global
           I64[Sp + 8] = block_c9FXY_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FZs; else goto c9FY1;
       u9FZs: // global
           call _c9FXY(R1) args: 0, res: 0, upd: 0;
       c9FY1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FXK: // global
           I64[Sp + 8] = block_c9FXI_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FZr; else goto c9FXL;
       u9FZr: // global
           call _c9FXI(R1) args: 0, res: 0, upd: 0;
       c9FXL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FXu: // global
           I64[Sp + 8] = block_c9FXs_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FZq; else goto c9FXv;
       u9FZq: // global
           call _c9FXs(R1) args: 0, res: 0, upd: 0;
       c9FXv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FXe: // global
           I64[Sp + 8] = block_c9FXc_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FZp; else goto c9FXf;
       u9FZp: // global
           call _c9FXc(R1) args: 0, res: 0, upd: 0;
       c9FXf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9FWY: // global
           I64[Sp + 8] = block_c9FWV_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9FZo; else goto c9FWZ;
       u9FZo: // global
           call _c9FWV(R1) args: 0, res: 0, upd: 0;
       c9FWZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9FYe() //  [R1]
         { info_tbl: [(c9FYe,
                       label: block_c9FYe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FYe: // global
           if (R1 & 7 == 6) goto u9FYZ; else goto u9FZ0;
       u9FYZ: // global
           Sp = Sp + 8;
           call _c9FYG() args: 0, res: 0, upd: 0;
       u9FZ0: // global
           Sp = Sp + 8;
           call _c9FYC() args: 0, res: 0, upd: 0;
     }
 },
 _c9FXY() //  [R1]
         { info_tbl: [(c9FXY,
                       label: block_c9FXY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FXY: // global
           if (R1 & 7 == 5) goto u9FZ1; else goto u9FZ2;
       u9FZ1: // global
           Sp = Sp + 8;
           call _c9FYG() args: 0, res: 0, upd: 0;
       u9FZ2: // global
           Sp = Sp + 8;
           call _c9FYC() args: 0, res: 0, upd: 0;
     }
 },
 _c9FXI() //  [R1]
         { info_tbl: [(c9FXI,
                       label: block_c9FXI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FXI: // global
           if (R1 & 7 == 4) goto u9FZ3; else goto u9FZ4;
       u9FZ3: // global
           Sp = Sp + 8;
           call _c9FYG() args: 0, res: 0, upd: 0;
       u9FZ4: // global
           Sp = Sp + 8;
           call _c9FYC() args: 0, res: 0, upd: 0;
     }
 },
 _c9FXs() //  [R1]
         { info_tbl: [(c9FXs,
                       label: block_c9FXs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FXs: // global
           if (R1 & 7 == 3) goto u9FZ5; else goto u9FZ6;
       u9FZ5: // global
           Sp = Sp + 8;
           call _c9FYG() args: 0, res: 0, upd: 0;
       u9FZ6: // global
           Sp = Sp + 8;
           call _c9FYC() args: 0, res: 0, upd: 0;
     }
 },
 _c9FXc() //  [R1]
         { info_tbl: [(c9FXc,
                       label: block_c9FXc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FXc: // global
           if (R1 & 7 == 2) goto u9FZ7; else goto u9FZ8;
       u9FZ7: // global
           Sp = Sp + 8;
           call _c9FYG() args: 0, res: 0, upd: 0;
       u9FZ8: // global
           Sp = Sp + 8;
           call _c9FYC() args: 0, res: 0, upd: 0;
     }
 },
 _c9FWV() //  [R1]
         { info_tbl: [(c9FWV,
                       label: block_c9FWV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FWV: // global
           if (R1 & 7 == 1) goto u9FZ9; else goto u9FZa;
       u9FZ9: // global
           Sp = Sp + 8;
           call _c9FYG() args: 0, res: 0, upd: 0;
       u9FZa: // global
           Sp = Sp + 8;
           call _c9FYC() args: 0, res: 0, upd: 0;
     }
 },
 _c9FYu() //  [R1]
         { info_tbl: [(c9FYu,
                       label: block_c9FYu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FYu: // global
           if (R1 & 7 == 4) goto u9FZb; else goto u9FZc;
       u9FZb: // global
           Sp = Sp + 8;
           call _c9FYG() args: 0, res: 0, upd: 0;
       u9FZc: // global
           Sp = Sp + 8;
           call _c9FYC() args: 0, res: 0, upd: 0;
     }
 },
 _c9FYG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FYG: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9FYC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FYC: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.496950449 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadStatus_closure" {
     GHC.Conc.Sync.$fEqThreadStatus_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqThreadStatus_$c==_closure+2;
         const GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.498007733 UTC

[section ""data" . GHC.Conc.Sync.numSparks1_closure" {
     GHC.Conc.Sync.numSparks1_closure:
         const GHC.Conc.Sync.numSparks1_info;
 },
 GHC.Conc.Sync.numSparks1_entry() //  []
         { info_tbl: [(c9FZP,
                       label: GHC.Conc.Sync.numSparks1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FZP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9FZQ; else goto c9FZR;
       c9FZQ: // global
           R1 = GHC.Conc.Sync.numSparks1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9FZR: // global
           I64[Sp - 8] = block_c9FZM_info;
           Sp = Sp - 8;
           call stg_numSparks#() args: 8, res: 8, upd: 8;
     }
 },
 _c9FZM() //  [R1]
         { info_tbl: [(c9FZM,
                       label: block_c9FZM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FZM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9FZU; else goto c9FZT;
       c9FZU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9FZT: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.499050506 UTC

[section ""data" . GHC.Conc.Sync.numSparks_closure" {
     GHC.Conc.Sync.numSparks_closure:
         const GHC.Conc.Sync.numSparks_info;
 },
 GHC.Conc.Sync.numSparks_entry() //  []
         { info_tbl: [(c9FZZ,
                       label: GHC.Conc.Sync.numSparks_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9FZZ: // global
           call GHC.Conc.Sync.numSparks1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.500223494 UTC

[section ""data" . GHC.Conc.Sync.throwTo1_closure" {
     GHC.Conc.Sync.throwTo1_closure:
         const GHC.Conc.Sync.throwTo1_info;
 },
 sat_s9FwG_entry() //  [R1]
         { info_tbl: [(c9G0f,
                       label: sat_s9FwG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G0f: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9G0g; else goto c9G0h;
       c9G0g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9G0h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.throwTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c9G0i,
                       label: GHC.Conc.Sync.throwTo1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G0i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9G0k; else goto c9G0l;
       c9G0k: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.throwTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9G0l: // global
           I64[Sp - 24] = block_c9G06_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9G0r; else goto c9G07;
       u9G0r: // global
           call _c9G06(R1) args: 0, res: 0, upd: 0;
       c9G07: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G06() //  [R1]
         { info_tbl: [(c9G06,
                       label: block_c9G06_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G06: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9G0o; else goto c9G0n;
       c9G0o: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9G0n: // global
           _s9FwF::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s9FwG_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c9G0j_info;
           R2 = Hp - 24;
           R1 = _s9FwF::P64;
           Sp = Sp + 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G0j() //  []
         { info_tbl: [(c9G0j,
                       label: block_c9G0j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G0j: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.501875741 UTC

[section ""data" . GHC.Conc.Sync.throwTo_closure" {
     GHC.Conc.Sync.throwTo_closure:
         const GHC.Conc.Sync.throwTo_info;
 },
 GHC.Conc.Sync.throwTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c9G0w,
                       label: GHC.Conc.Sync.throwTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G0w: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.throwTo1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.50276888 UTC

[section ""data" . GHC.Conc.Sync.myThreadId1_closure" {
     GHC.Conc.Sync.myThreadId1_closure:
         const GHC.Conc.Sync.myThreadId1_info;
 },
 GHC.Conc.Sync.myThreadId1_entry() //  []
         { info_tbl: [(c9G0E,
                       label: GHC.Conc.Sync.myThreadId1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G0E: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9G0I; else goto c9G0H;
       c9G0I: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.myThreadId1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9G0H: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           I64[Hp] = CurrentTSO;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.503628334 UTC

[section ""data" . GHC.Conc.Sync.myThreadId_closure" {
     GHC.Conc.Sync.myThreadId_closure:
         const GHC.Conc.Sync.myThreadId_info;
 },
 GHC.Conc.Sync.myThreadId_entry() //  []
         { info_tbl: [(c9G0N,
                       label: GHC.Conc.Sync.myThreadId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G0N: // global
           call GHC.Conc.Sync.myThreadId1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.504448005 UTC

[section ""data" . GHC.Conc.Sync.yield1_closure" {
     GHC.Conc.Sync.yield1_closure:
         const GHC.Conc.Sync.yield1_info;
 },
 GHC.Conc.Sync.yield1_entry() //  []
         { info_tbl: [(c9G0W,
                       label: GHC.Conc.Sync.yield1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G0W: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9G0X; else goto c9G0Y;
       c9G0X: // global
           R1 = GHC.Conc.Sync.yield1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9G0Y: // global
           I64[Sp - 8] = block_c9G0U_info;
           Sp = Sp - 8;
           call stg_yield#() args: 8, res: 8, upd: 8;
     }
 },
 _c9G0U() //  []
         { info_tbl: [(c9G0U,
                       label: block_c9G0U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G0U: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.505468377 UTC

[section ""data" . GHC.Conc.Sync.yield_closure" {
     GHC.Conc.Sync.yield_closure:
         const GHC.Conc.Sync.yield_info;
 },
 GHC.Conc.Sync.yield_entry() //  []
         { info_tbl: [(c9G14,
                       label: GHC.Conc.Sync.yield_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G14: // global
           call GHC.Conc.Sync.yield1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.506698486 UTC

[section ""data" . GHC.Conc.Sync.labelThread1_closure" {
     GHC.Conc.Sync.labelThread1_closure:
         const GHC.Conc.Sync.labelThread1_info;
         const 0;
 },
 sat_s9FwZ_entry() //  [R1, R2]
         { info_tbl: [(c9G1o,
                       label: sat_s9FwZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G1o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9G1s; else goto c9G1t;
       c9G1s: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9G1t: // global
           I64[Sp - 16] = block_c9G1l_info;
           _s9FwT::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s9FwT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9G1x; else goto c9G1m;
       u9G1x: // global
           call _c9G1l(R1) args: 0, res: 0, upd: 0;
       c9G1m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G1l() //  [R1]
         { info_tbl: [(c9G1l,
                       label: block_c9G1l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G1l: // global
           _s9FwT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9G1r_info;
           R2 = I64[R1 + 7];
           R1 = _s9FwT::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G1r() //  []
         { info_tbl: [(c9G1r,
                       label: block_c9G1r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G1r: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.labelThread1_entry() //  [R2, R3]
         { info_tbl: [(c9G1y,
                       label: GHC.Conc.Sync.labelThread1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G1y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9G1z; else goto c9G1A;
       c9G1z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.labelThread1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9G1A: // global
           I64[Sp - 16] = block_c9G1b_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9G1E; else goto c9G1c;
       u9G1E: // global
           call _c9G1b(R1) args: 0, res: 0, upd: 0;
       c9G1c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G1b() //  [R1]
         { info_tbl: [(c9G1b,
                       label: block_c9G1b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G1b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9G1D; else goto c9G1C;
       c9G1D: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9G1C: // global
           _s9FwT::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s9FwZ_info;
           P64[Hp] = _s9FwT::P64;
           R4 = Hp - 6;
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.508668133 UTC

[section ""data" . GHC.Conc.Sync.labelThread_closure" {
     GHC.Conc.Sync.labelThread_closure:
         const GHC.Conc.Sync.labelThread_info;
         const 0;
 },
 GHC.Conc.Sync.labelThread_entry() //  [R2, R3]
         { info_tbl: [(c9G1J,
                       label: GHC.Conc.Sync.labelThread_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G1J: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.labelThread1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.509656259 UTC

[section ""data" . GHC.Conc.Sync.pseq_closure" {
     GHC.Conc.Sync.pseq_closure:
         const GHC.Conc.Sync.pseq_info;
 },
 GHC.Conc.Sync.pseq_entry() //  [R2, R3]
         { info_tbl: [(c9G1S,
                       label: GHC.Conc.Sync.pseq_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G1S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9G1T; else goto c9G1U;
       c9G1T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.pseq_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9G1U: // global
           I64[Sp - 16] = block_c9G1Q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G1Q() //  []
         { info_tbl: [(c9G1Q,
                       label: block_c9G1Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G1Q: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.510791699 UTC

[section ""data" . GHC.Conc.Sync.par_closure" {
     GHC.Conc.Sync.par_closure:
         const GHC.Conc.Sync.par_info;
 },
 GHC.Conc.Sync.par_entry() //  [R2, R3]
         { info_tbl: [(c9G25,
                       label: GHC.Conc.Sync.par_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G25: // global
           _s9Fx4::P64 = R3;
           (_c9G20::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [] newSpark(BaseReg, R2);
           R1 = _s9Fx4::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.511862552 UTC

[section ""data" . GHC.Conc.Sync.runSparks_loop_closure" {
     GHC.Conc.Sync.runSparks_loop_closure:
         const GHC.Conc.Sync.runSparks_loop_info;
 },
 GHC.Conc.Sync.runSparks_loop_entry() //  []
         { info_tbl: [(c9G2k,
                       label: GHC.Conc.Sync.runSparks_loop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G2k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9G2l; else goto u9G2t;
       c9G2l: // global
           R1 = GHC.Conc.Sync.runSparks_loop_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       u9G2t: // global
           call _c9G29() args: 0, res: 0, upd: 0;
     }
 },
 _c9G29() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G29: // global
           I64[Sp - 8] = block_c9G2c_info;
           Sp = Sp - 8;
           call stg_getSpark#() args: 8, res: 8, upd: 8;
     }
 },
 _c9G2c() //  [R1, R2]
         { info_tbl: [(c9G2c,
                       label: block_c9G2c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G2c: // global
           if (R1 == 0) goto c9G2j; else goto c9G2i;
       c9G2j: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9G2i: // global
           I64[Sp] = block_c9G2p_info;
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G2p() //  []
         { info_tbl: [(c9G2p,
                       label: block_c9G2p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G2p: // global
           Sp = Sp + 8;
           call _c9G29() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.515792968 UTC

[section ""data" . GHC.Conc.Sync.runSparks_closure" {
     GHC.Conc.Sync.runSparks_closure:
         const GHC.Conc.Sync.runSparks_info;
 },
 GHC.Conc.Sync.runSparks_entry() //  []
         { info_tbl: [(c9G2z,
                       label: GHC.Conc.Sync.runSparks_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G2z: // global
           call GHC.Conc.Sync.runSparks_loop_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.516965078 UTC

[section ""data" . GHC.Conc.Sync.threadCapability1_closure" {
     GHC.Conc.Sync.threadCapability1_closure:
         const GHC.Conc.Sync.threadCapability1_info;
 },
 sat_s9Fxo_entry() //  [R1]
         { info_tbl: [(c9G2X,
                       label: sat_s9Fxo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G2X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9G2Y; else goto c9G2Z;
       c9G2Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9G2Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c9G2W; else goto c9G2V;
       c9G2W: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9G2V: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.threadCapability1_entry() //  [R2]
         { info_tbl: [(c9G30,
                       label: GHC.Conc.Sync.threadCapability1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G30: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9G33; else goto c9G34;
       c9G33: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.threadCapability1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9G34: // global
           I64[Sp - 8] = block_c9G2G_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9G3b; else goto c9G2H;
       u9G3b: // global
           call _c9G2G(R1) args: 0, res: 0, upd: 0;
       c9G2H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G2G() //  [R1]
         { info_tbl: [(c9G2G,
                       label: block_c9G2G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G2G: // global
           I64[Sp] = block_c9G2L_info;
           R1 = P64[R1 + 7];
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G2L() //  [R2, R3]
         { info_tbl: [(c9G2L,
                       label: block_c9G2L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G2L: // global
           I64[Sp - 8] = R3;
           I64[Sp] = R2;
           Sp = Sp - 16;
           call _c9G2M() args: 0, res: 0, upd: 0;
     }
 },
 _c9G2M() //  []
         { info_tbl: [(c9G2M,
                       label: block_c9G2M_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G2M: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c9G38; else goto c9G37;
       c9G38: // global
           HpAlloc = 64;
           I64[Sp] = block_c9G2M_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c9G37: // global
           I64[Hp - 56] = sat_s9Fxo_info;
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.518652213 UTC

[section ""data" . GHC.Conc.Sync.threadCapability_closure" {
     GHC.Conc.Sync.threadCapability_closure:
         const GHC.Conc.Sync.threadCapability_info;
 },
 GHC.Conc.Sync.threadCapability_entry() //  [R2]
         { info_tbl: [(c9G3g,
                       label: GHC.Conc.Sync.threadCapability_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G3g: // global
           R2 = R2;
           call GHC.Conc.Sync.threadCapability1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.519596732 UTC

[section ""data" . GHC.Conc.Sync.mkWeakThreadId1_closure" {
     GHC.Conc.Sync.mkWeakThreadId1_closure:
         const GHC.Conc.Sync.mkWeakThreadId1_info;
 },
 GHC.Conc.Sync.mkWeakThreadId1_entry() //  [R2]
         { info_tbl: [(c9G3q,
                       label: GHC.Conc.Sync.mkWeakThreadId1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G3q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9G3w; else goto c9G3x;
       c9G3w: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.mkWeakThreadId1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9G3x: // global
           I64[Sp - 8] = block_c9G3n_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9G3C; else goto c9G3o;
       u9G3C: // global
           call _c9G3n(R1) args: 0, res: 0, upd: 0;
       c9G3o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G3n() //  [R1]
         { info_tbl: [(c9G3n,
                       label: block_c9G3n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G3n: // global
           I64[Sp] = block_c9G3t_info;
           R2 = R1;
           R1 = P64[R1 + 7];
           call stg_mkWeakNoFinalizer#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G3t() //  [R1]
         { info_tbl: [(c9G3t,
                       label: block_c9G3t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G3t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9G3B; else goto c9G3A;
       c9G3B: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9G3A: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.520850821 UTC

[section ""data" . GHC.Conc.Sync.mkWeakThreadId_closure" {
     GHC.Conc.Sync.mkWeakThreadId_closure:
         const GHC.Conc.Sync.mkWeakThreadId_info;
 },
 GHC.Conc.Sync.mkWeakThreadId_entry() //  [R2]
         { info_tbl: [(c9G3H,
                       label: GHC.Conc.Sync.mkWeakThreadId_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G3H: // global
           R2 = R2;
           call GHC.Conc.Sync.mkWeakThreadId1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.521841725 UTC

[section ""data" . GHC.Conc.Sync.newStablePtrPrimMVar1_closure" {
     GHC.Conc.Sync.newStablePtrPrimMVar1_closure:
         const GHC.Conc.Sync.newStablePtrPrimMVar1_info;
 },
 GHC.Conc.Sync.newStablePtrPrimMVar1_entry() //  [R2]
         { info_tbl: [(c9G3R,
                       label: GHC.Conc.Sync.newStablePtrPrimMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G3R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9G3X; else goto c9G3Y;
       c9G3X: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.newStablePtrPrimMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9G3Y: // global
           I64[Sp - 8] = block_c9G3O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9G43; else goto c9G3P;
       u9G43: // global
           call _c9G3O(R1) args: 0, res: 0, upd: 0;
       c9G3P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G3O() //  [R1]
         { info_tbl: [(c9G3O,
                       label: block_c9G3O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G3O: // global
           I64[Sp] = block_c9G3U_info;
           R1 = P64[R1 + 7];
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G3U() //  [R1]
         { info_tbl: [(c9G3U,
                       label: block_c9G3U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G3U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9G42; else goto c9G41;
       c9G42: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9G41: // global
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.52306989 UTC

[section ""data" . GHC.Conc.Sync.newStablePtrPrimMVar_closure" {
     GHC.Conc.Sync.newStablePtrPrimMVar_closure:
         const GHC.Conc.Sync.newStablePtrPrimMVar_info;
 },
 GHC.Conc.Sync.newStablePtrPrimMVar_entry() //  [R2]
         { info_tbl: [(c9G48,
                       label: GHC.Conc.Sync.newStablePtrPrimMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G48: // global
           R2 = R2;
           call GHC.Conc.Sync.newStablePtrPrimMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.523939656 UTC

[section ""data" . $c>>=_r9FuK_closure" {
     $c>>=_r9FuK_closure:
         const $c>>=_r9FuK_info;
 },
 $c>>=_r9FuK_entry() //  [R2, R3]
         { info_tbl: [(c9G4h,
                       label: $c>>=_r9FuK_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G4h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9G4i; else goto c9G4j;
       c9G4i: // global
           R3 = R3;
           R2 = R2;
           R1 = $c>>=_r9FuK_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9G4j: // global
           I64[Sp - 16] = block_c9G4f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G4f() //  [R1]
         { info_tbl: [(c9G4f,
                       label: block_c9G4f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G4f: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.524959982 UTC

[section ""data" . GHC.Conc.Sync.$fMonadSTM_$c>>=_closure" {
     GHC.Conc.Sync.$fMonadSTM_$c>>=_closure:
         const GHC.Conc.Sync.$fMonadSTM_$c>>=_info;
 },
 GHC.Conc.Sync.$fMonadSTM_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c9G4p,
                       label: GHC.Conc.Sync.$fMonadSTM_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G4p: // global
           R3 = R3;
           R2 = R2;
           call $c>>=_r9FuK_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.525845467 UTC

[section ""data" . $c*>_r9FuL_closure" {
     $c*>_r9FuL_closure:
         const $c*>_r9FuL_info;
 },
 $c*>_r9FuL_entry() //  [R2, R3]
         { info_tbl: [(c9G4y,
                       label: $c*>_r9FuL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G4y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9G4z; else goto c9G4A;
       c9G4z: // global
           R3 = R3;
           R2 = R2;
           R1 = $c*>_r9FuL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9G4A: // global
           I64[Sp - 16] = block_c9G4w_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G4w() //  []
         { info_tbl: [(c9G4w,
                       label: block_c9G4w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G4w: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.526863099 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure:
         const GHC.Conc.Sync.$fApplicativeSTM_$c*>_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM_$c*>_entry() //  [R2, R3]
         { info_tbl: [(c9G4G,
                       label: GHC.Conc.Sync.$fApplicativeSTM_$c*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G4G: // global
           R3 = R3;
           R2 = R2;
           call $c*>_r9FuL_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.5276711 UTC

[section ""data" . GHC.Conc.Sync.orElse_closure" {
     GHC.Conc.Sync.orElse_closure:
         const GHC.Conc.Sync.orElse_info;
 },
 GHC.Conc.Sync.orElse_entry() //  [R2, R3]
         { info_tbl: [(c9G4N,
                       label: GHC.Conc.Sync.orElse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G4N: // global
           _B3::P64 = R2;
           R2 = R3;
           R1 = _B3::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.528971391 UTC

[section ""data" . GHC.Conc.Sync.catchSTM1_closure" {
     GHC.Conc.Sync.catchSTM1_closure:
         const GHC.Conc.Sync.catchSTM1_info;
 },
 sat_s9FxY_entry() //  [R1]
         { info_tbl: [(c9G58,
                       label: sat_s9FxY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G58: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9Fy0_entry() //  [R1, R2]
         { info_tbl: [(c9G5f,
                       label: sat_s9Fy0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G5f: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9G5g; else goto c9G5h;
       c9G5g: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9G5h: // global
           I64[Sp - 24] = block_c9G4Z_info;
           _s9FxW::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s9FxW::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _s9FxW::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c9G4Z() //  [R1]
         { info_tbl: [(c9G4Z,
                       label: block_c9G4Z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G4Z: // global
           if (R1 & 7 == 1) goto c9G5c; else goto c9G5d;
       c9G5c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9G5k; else goto c9G5j;
       c9G5k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9G5j: // global
           I64[Hp - 8] = sat_s9FxY_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9G5d: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.catchSTM1_entry() //  [R2, R3, R4]
         { info_tbl: [(c9G5o,
                       label: GHC.Conc.Sync.catchSTM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G5o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9G5s; else goto c9G5r;
       c9G5s: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.catchSTM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9G5r: // global
           I64[Hp - 16] = sat_s9Fy0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 15;
           R1 = R3;
           call stg_catchSTM#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.53096775 UTC

[section ""data" . GHC.Conc.Sync.catchSTM_closure" {
     GHC.Conc.Sync.catchSTM_closure:
         const GHC.Conc.Sync.catchSTM_info;
 },
 GHC.Conc.Sync.catchSTM_entry() //  [R2, R3, R4]
         { info_tbl: [(c9G5x,
                       label: GHC.Conc.Sync.catchSTM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G5x: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.catchSTM1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.531739737 UTC

[section ""data" . $cpure_r9FuM_closure" {
     $cpure_r9FuM_closure:
         const $cpure_r9FuM_info;
 },
 $cpure_r9FuM_entry() //  [R2]
         { info_tbl: [(c9G5E,
                       label: $cpure_r9FuM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G5E: // global
           R1 = R2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.532509518 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure:
         const GHC.Conc.Sync.$fApplicativeSTM_$cpure_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM_$cpure_entry() //  [R2]
         { info_tbl: [(c9G5L,
                       label: GHC.Conc.Sync.$fApplicativeSTM_$cpure_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G5L: // global
           R2 = R2;
           call $cpure_r9FuM_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.533315417 UTC

[section ""data" . GHC.Conc.Sync.unsafeIOToSTM1_closure" {
     GHC.Conc.Sync.unsafeIOToSTM1_closure:
         const GHC.Conc.Sync.unsafeIOToSTM1_info;
 },
 GHC.Conc.Sync.unsafeIOToSTM1_entry() //  [R2]
         { info_tbl: [(c9G5S,
                       label: GHC.Conc.Sync.unsafeIOToSTM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G5S: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.534106228 UTC

[section ""data" . GHC.Conc.Sync.unsafeIOToSTM_closure" {
     GHC.Conc.Sync.unsafeIOToSTM_closure:
         const GHC.Conc.Sync.unsafeIOToSTM_info;
 },
 GHC.Conc.Sync.unsafeIOToSTM_entry() //  [R2]
         { info_tbl: [(c9G5Z,
                       label: GHC.Conc.Sync.unsafeIOToSTM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G5Z: // global
           R2 = R2;
           call GHC.Conc.Sync.unsafeIOToSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.534880869 UTC

[section ""data" . GHC.Conc.Sync.atomically_closure" {
     GHC.Conc.Sync.atomically_closure:
         const GHC.Conc.Sync.atomically_info;
 },
 GHC.Conc.Sync.atomically_entry() //  [R2]
         { info_tbl: [(c9G66,
                       label: GHC.Conc.Sync.atomically_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G66: // global
           R1 = R2;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.535635288 UTC

[section ""data" . GHC.Conc.Sync.retry_closure" {
     GHC.Conc.Sync.retry_closure:
         const GHC.Conc.Sync.retry_info;
 },
 GHC.Conc.Sync.retry_entry() //  []
         { info_tbl: [(c9G6d,
                       label: GHC.Conc.Sync.retry_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G6d: // global
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.536599898 UTC

[section ""data" . GHC.Conc.Sync.throwSTM1_closure" {
     GHC.Conc.Sync.throwSTM1_closure:
         const GHC.Conc.Sync.throwSTM1_info;
 },
 sat_s9Fy7_entry() //  [R1]
         { info_tbl: [(c9G6o,
                       label: sat_s9Fy7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G6o: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9G6p; else goto c9G6q;
       c9G6p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9G6q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.throwSTM1_entry() //  [R2, R3]
         { info_tbl: [(c9G6r,
                       label: GHC.Conc.Sync.throwSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G6r: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9G6v; else goto c9G6u;
       c9G6v: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.throwSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9G6u: // global
           I64[Hp - 24] = sat_s9Fy7_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.537811002 UTC

[section ""data" . GHC.Conc.Sync.throwSTM_closure" {
     GHC.Conc.Sync.throwSTM_closure:
         const GHC.Conc.Sync.throwSTM_info;
 },
 GHC.Conc.Sync.throwSTM_entry() //  [R2, R3]
         { info_tbl: [(c9G6A,
                       label: GHC.Conc.Sync.throwSTM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G6A: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.throwSTM1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.538739266 UTC

[section ""data" . GHC.Conc.Sync.newTVar1_closure" {
     GHC.Conc.Sync.newTVar1_closure:
         const GHC.Conc.Sync.newTVar1_info;
 },
 GHC.Conc.Sync.newTVar1_entry() //  [R2]
         { info_tbl: [(c9G6K,
                       label: GHC.Conc.Sync.newTVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G6K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9G6L; else goto c9G6M;
       c9G6L: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.newTVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9G6M: // global
           I64[Sp - 8] = block_c9G6H_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G6H() //  [R1]
         { info_tbl: [(c9G6H,
                       label: block_c9G6H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G6H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9G6P; else goto c9G6O;
       c9G6P: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9G6O: // global
           I64[Hp - 8] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.539816159 UTC

[section ""data" . GHC.Conc.Sync.newTVar_closure" {
     GHC.Conc.Sync.newTVar_closure:
         const GHC.Conc.Sync.newTVar_info;
 },
 GHC.Conc.Sync.newTVar_entry() //  [R2]
         { info_tbl: [(c9G6U,
                       label: GHC.Conc.Sync.newTVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G6U: // global
           R2 = R2;
           call GHC.Conc.Sync.newTVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.540601107 UTC

[section ""data" . GHC.Conc.Sync.newTVarIO_closure" {
     GHC.Conc.Sync.newTVarIO_closure:
         const GHC.Conc.Sync.newTVarIO_info;
 },
 GHC.Conc.Sync.newTVarIO_entry() //  [R2]
         { info_tbl: [(c9G71,
                       label: GHC.Conc.Sync.newTVarIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G71: // global
           R2 = R2;
           call GHC.Conc.Sync.newTVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.541791747 UTC

[section ""data" . GHC.Conc.Sync.readTVarIO1_closure" {
     GHC.Conc.Sync.readTVarIO1_closure:
         const GHC.Conc.Sync.readTVarIO1_info;
 },
 GHC.Conc.Sync.readTVarIO1_entry() //  [R2]
         { info_tbl: [(c9G7b,
                       label: GHC.Conc.Sync.readTVarIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G7b: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9G7c; else goto c9G7d;
       c9G7c: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.readTVarIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9G7d: // global
           I64[Sp - 8] = block_c9G78_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9G7h; else goto c9G79;
       u9G7h: // global
           call _c9G78(R1) args: 0, res: 0, upd: 0;
       c9G79: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G78() //  [R1]
         { info_tbl: [(c9G78,
                       label: block_c9G78_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G78: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readTVarIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.54287863 UTC

[section ""data" . GHC.Conc.Sync.readTVarIO_closure" {
     GHC.Conc.Sync.readTVarIO_closure:
         const GHC.Conc.Sync.readTVarIO_info;
 },
 GHC.Conc.Sync.readTVarIO_entry() //  [R2]
         { info_tbl: [(c9G7m,
                       label: GHC.Conc.Sync.readTVarIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G7m: // global
           R2 = R2;
           call GHC.Conc.Sync.readTVarIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.543753067 UTC

[section ""data" . GHC.Conc.Sync.readTVar1_closure" {
     GHC.Conc.Sync.readTVar1_closure:
         const GHC.Conc.Sync.readTVar1_info;
 },
 GHC.Conc.Sync.readTVar1_entry() //  [R2]
         { info_tbl: [(c9G7w,
                       label: GHC.Conc.Sync.readTVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G7w: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9G7x; else goto c9G7y;
       c9G7x: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.readTVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9G7y: // global
           I64[Sp - 8] = block_c9G7t_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9G7C; else goto c9G7u;
       u9G7C: // global
           call _c9G7t(R1) args: 0, res: 0, upd: 0;
       c9G7u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G7t() //  [R1]
         { info_tbl: [(c9G7t,
                       label: block_c9G7t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G7t: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readTVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.544827109 UTC

[section ""data" . GHC.Conc.Sync.readTVar_closure" {
     GHC.Conc.Sync.readTVar_closure:
         const GHC.Conc.Sync.readTVar_info;
 },
 GHC.Conc.Sync.readTVar_entry() //  [R2]
         { info_tbl: [(c9G7H,
                       label: GHC.Conc.Sync.readTVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G7H: // global
           R2 = R2;
           call GHC.Conc.Sync.readTVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.545784941 UTC

[section ""data" . GHC.Conc.Sync.writeTVar1_closure" {
     GHC.Conc.Sync.writeTVar1_closure:
         const GHC.Conc.Sync.writeTVar1_info;
 },
 GHC.Conc.Sync.writeTVar1_entry() //  [R2, R3]
         { info_tbl: [(c9G7R,
                       label: GHC.Conc.Sync.writeTVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G7R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9G7V; else goto c9G7W;
       c9G7V: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.writeTVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9G7W: // global
           I64[Sp - 16] = block_c9G7O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9G80; else goto c9G7P;
       u9G80: // global
           call _c9G7O(R1) args: 0, res: 0, upd: 0;
       c9G7P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G7O() //  [R1]
         { info_tbl: [(c9G7O,
                       label: block_c9G7O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G7O: // global
           _s9Fyn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9G7U_info;
           R2 = _s9Fyn::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G7U() //  []
         { info_tbl: [(c9G7U,
                       label: block_c9G7U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G7U: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.547033228 UTC

[section ""data" . GHC.Conc.Sync.writeTVar_closure" {
     GHC.Conc.Sync.writeTVar_closure:
         const GHC.Conc.Sync.writeTVar_info;
 },
 GHC.Conc.Sync.writeTVar_entry() //  [R2, R3]
         { info_tbl: [(c9G85,
                       label: GHC.Conc.Sync.writeTVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G85: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.writeTVar1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.549055534 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$ccompare_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c9G8n,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G8n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9G8o; else goto c9G8p;
       c9G8o: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9G8p: // global
           I64[Sp - 16] = block_c9G8c_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Gbs; else goto c9G8d;
       u9Gbs: // global
           call _c9G8c(R1) args: 0, res: 0, upd: 0;
       c9G8d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9G8c() //  [R1]
         { info_tbl: [(c9G8c,
                       label: block_c9G8c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G8c: // global
           _s9Fyt::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9G8g;
               case 2 : goto c9G8h;
               case 3 : goto c9G8i;
               case 4 : goto c9G8j;
               case 5 : goto c9G8k;
               case 6 : goto c9G8l;
           }
       c9G8l: // global
           I64[Sp + 8] = block_c9Gaz_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gbr; else goto c9GaB;
       u9Gbr: // global
           call _c9Gaz(R1) args: 0, res: 0, upd: 0;
       c9GaB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9G8k: // global
           I64[Sp + 8] = block_c9Gag_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gbq; else goto c9Gai;
       u9Gbq: // global
           call _c9Gag(R1) args: 0, res: 0, upd: 0;
       c9Gai: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9G8j: // global
           I64[Sp + 8] = block_c9G9T_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gbp; else goto c9G9V;
       u9Gbp: // global
           call _c9G9T(R1) args: 0, res: 0, upd: 0;
       c9G9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9G8i: // global
           I64[Sp + 8] = block_c9G9s_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gbo; else goto c9G9u;
       u9Gbo: // global
           call _c9G9s(R1) args: 0, res: 0, upd: 0;
       c9G9u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9G8h: // global
           I64[Sp + 8] = block_c9G8X_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gbn; else goto c9G8Z;
       u9Gbn: // global
           call _c9G8X(R1) args: 0, res: 0, upd: 0;
       c9G8Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9G8g: // global
           I64[Sp + 8] = block_c9G8s_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gbm; else goto c9G8u;
       u9Gbm: // global
           call _c9G8s(R1) args: 0, res: 0, upd: 0;
       c9G8u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Gaz() //  [R1]
         { info_tbl: [(c9Gaz,
                       label: block_c9Gaz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gaz: // global
           if (R1 & 7 == 6) goto u9GaX; else goto u9GaY;
       u9GaX: // global
           Sp = Sp + 8;
           call _c9GaL() args: 0, res: 0, upd: 0;
       u9GaY: // global
           Sp = Sp + 8;
           call _c9GaH() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gag() //  [R1]
         { info_tbl: [(c9Gag,
                       label: block_c9Gag_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gag: // global
           _c9GaN::P64 = R1 & 7;
           if (_c9GaN::P64 != 5) goto u9GaW; else goto u9GaZ;
       u9GaW: // global
           if (_c9GaN::P64 != 6) goto u9Gb1; else goto u9Gb0;
       u9Gb1: // global
           Sp = Sp + 8;
           call _c9GaH() args: 0, res: 0, upd: 0;
       u9Gb0: // global
           Sp = Sp + 8;
           call _c9Gaw() args: 0, res: 0, upd: 0;
       u9GaZ: // global
           Sp = Sp + 8;
           call _c9GaL() args: 0, res: 0, upd: 0;
     }
 },
 _c9G9T() //  [R1]
         { info_tbl: [(c9G9T,
                       label: block_c9G9T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G9T: // global
           _c9GaO::P64 = R1 & 7;
           if (_c9GaO::P64 < 5) goto u9GaU; else goto u9GaV;
       u9GaU: // global
           if (_c9GaO::P64 < 4) goto u9Gb3; else goto u9Gb2;
       u9Gb3: // global
           Sp = Sp + 8;
           call _c9GaH() args: 0, res: 0, upd: 0;
       u9Gb2: // global
           Sp = Sp + 8;
           call _c9GaL() args: 0, res: 0, upd: 0;
       u9GaV: // global
           if (_c9GaO::P64 < 6) goto u9Gb5; else goto u9Gb5;
       u9Gb5: // global
           Sp = Sp + 8;
           call _c9Gaw() args: 0, res: 0, upd: 0;
     }
 },
 _c9G9s() //  [R1]
         { info_tbl: [(c9G9s,
                       label: block_c9G9s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G9s: // global
           _c9GaP::P64 = R1 & 7;
           if (_c9GaP::P64 < 4) goto u9GaS; else goto u9GaT;
       u9GaS: // global
           if (_c9GaP::P64 < 3) goto u9Gb7; else goto u9Gb6;
       u9Gb7: // global
           Sp = Sp + 8;
           call _c9GaH() args: 0, res: 0, upd: 0;
       u9Gb6: // global
           Sp = Sp + 8;
           call _c9GaL() args: 0, res: 0, upd: 0;
       u9GaT: // global
           if (_c9GaP::P64 != 5) goto u9Gb9; else goto u9Gb9;
       u9Gb9: // global
           Sp = Sp + 8;
           call _c9Gaw() args: 0, res: 0, upd: 0;
     }
 },
 _c9G8X() //  [R1]
         { info_tbl: [(c9G8X,
                       label: block_c9G8X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G8X: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9Gba;
               case 2 : goto u9Gbb;
               case 3, 4, 5, 6 : goto u9Gbf;
           }
       u9Gbf: // global
           Sp = Sp + 8;
           call _c9Gaw() args: 0, res: 0, upd: 0;
       u9Gbb: // global
           Sp = Sp + 8;
           call _c9GaL() args: 0, res: 0, upd: 0;
       u9Gba: // global
           Sp = Sp + 8;
           call _c9GaH() args: 0, res: 0, upd: 0;
     }
 },
 _c9GaH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GaH: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9G8s() //  [R1]
         { info_tbl: [(c9G8s,
                       label: block_c9G8s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9G8s: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9Gbg;
               case 2, 3, 4, 5, 6 : goto u9Gbl;
           }
       u9Gbl: // global
           Sp = Sp + 8;
           call _c9Gaw() args: 0, res: 0, upd: 0;
       u9Gbg: // global
           Sp = Sp + 8;
           call _c9GaL() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gaw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gaw: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GaL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GaL: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.553213583 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c<_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c<_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c<_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c<_entry() //  [R2, R3]
         { info_tbl: [(c9GbY,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GbY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9GbZ; else goto c9Gc0;
       c9GbZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Gc0: // global
           I64[Sp - 16] = block_c9GbN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Gey; else goto c9GbO;
       u9Gey: // global
           call _c9GbN(R1) args: 0, res: 0, upd: 0;
       c9GbO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GbN() //  [R1]
         { info_tbl: [(c9GbN,
                       label: block_c9GbN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GbN: // global
           _s9FyC::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9GbR;
               case 2 : goto c9GbS;
               case 3 : goto c9GbT;
               case 4 : goto c9GbU;
               case 5 : goto c9GbV;
               case 6 : goto c9GbW;
           }
       c9GbW: // global
           I64[Sp + 8] = block_c9GdU_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gex; else goto c9GdW;
       u9Gex: // global
           call _c9GdU() args: 0, res: 0, upd: 0;
       c9GdW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GbV: // global
           I64[Sp + 8] = block_c9GdF_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gew; else goto c9GdH;
       u9Gew: // global
           call _c9GdF(R1) args: 0, res: 0, upd: 0;
       c9GdH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GbU: // global
           I64[Sp + 8] = block_c9Gdm_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gev; else goto c9Gdo;
       u9Gev: // global
           call _c9Gdm(R1) args: 0, res: 0, upd: 0;
       c9Gdo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GbT: // global
           I64[Sp + 8] = block_c9GcZ_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Geu; else goto c9Gd1;
       u9Geu: // global
           call _c9GcZ(R1) args: 0, res: 0, upd: 0;
       c9Gd1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GbS: // global
           I64[Sp + 8] = block_c9Gcy_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Get; else goto c9GcA;
       u9Get: // global
           call _c9Gcy(R1) args: 0, res: 0, upd: 0;
       c9GcA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GbR: // global
           I64[Sp + 8] = block_c9Gc3_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ges; else goto c9Gc5;
       u9Ges: // global
           call _c9Gc3(R1) args: 0, res: 0, upd: 0;
       c9Gc5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GdU() //  []
         { info_tbl: [(c9GdU,
                       label: block_c9GdU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GdU: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GdF() //  [R1]
         { info_tbl: [(c9GdF,
                       label: block_c9GdF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GdF: // global
           if (R1 & 7 == 6) goto u9Gea; else goto u9Geb;
       u9Gea: // global
           Sp = Sp + 8;
           call _c9GdR() args: 0, res: 0, upd: 0;
       u9Geb: // global
           Sp = Sp + 8;
           call _c9GdN() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gdm() //  [R1]
         { info_tbl: [(c9Gdm,
                       label: block_c9Gdm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gdm: // global
           _c9Ge2::P64 = R1 & 7;
           if (_c9Ge2::P64 != 5) goto u9Ge9; else goto u9Gec;
       u9Ge9: // global
           if (_c9Ge2::P64 != 6) goto u9Gee; else goto u9Ged;
       u9Gee: // global
           Sp = Sp + 8;
           call _c9GdN() args: 0, res: 0, upd: 0;
       u9Ged: // global
           Sp = Sp + 8;
           goto u9GeH;
       u9Gec: // global
           Sp = Sp + 8;
           goto u9GeH;
       u9GeH: // global
           call _c9GdR() args: 0, res: 0, upd: 0;
     }
 },
 _c9GcZ() //  [R1]
         { info_tbl: [(c9GcZ,
                       label: block_c9GcZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GcZ: // global
           _c9Ge3::P64 = R1 & 7;
           if (_c9Ge3::P64 < 4) goto u9Gef; else goto u9Ge8;
       u9Gef: // global
           Sp = Sp + 8;
           call _c9GdN() args: 0, res: 0, upd: 0;
       u9Ge8: // global
           if (_c9Ge3::P64 != 5) goto u9Geh; else goto u9Geh;
       u9Geh: // global
           Sp = Sp + 8;
           call _c9GdR() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gcy() //  [R1]
         { info_tbl: [(c9Gcy,
                       label: block_c9Gcy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gcy: // global
           _c9Ge4::P64 = R1 & 7;
           if (_c9Ge4::P64 < 6) goto u9Ge6; else goto u9Gei;
       u9Ge6: // global
           if (_c9Ge4::P64 < 3) goto u9Gej; else goto u9Ge7;
       u9Gej: // global
           Sp = Sp + 8;
           call _c9GdN() args: 0, res: 0, upd: 0;
       u9Ge7: // global
           if (_c9Ge4::P64 != 4) goto u9Gel; else goto u9Gel;
       u9Gel: // global
           Sp = Sp + 8;
           goto u9GeD;
       u9Gei: // global
           Sp = Sp + 8;
           goto u9GeD;
       u9GeD: // global
           call _c9GdR() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gc3() //  [R1]
         { info_tbl: [(c9Gc3,
                       label: block_c9Gc3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gc3: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9Gem;
               case 2, 3, 4, 5, 6 : goto u9Ger;
           }
       u9Ger: // global
           Sp = Sp + 8;
           call _c9GdR() args: 0, res: 0, upd: 0;
       u9Gem: // global
           Sp = Sp + 8;
           call _c9GdN() args: 0, res: 0, upd: 0;
     }
 },
 _c9GdR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GdR: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GdN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GdN: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.557411293 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c<=_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c9Gf0,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gf0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Gf1; else goto c9Gf2;
       c9Gf1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Gf2: // global
           I64[Sp - 16] = block_c9GeP_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9GhA; else goto c9GeQ;
       u9GhA: // global
           call _c9GeP(R1) args: 0, res: 0, upd: 0;
       c9GeQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GeP() //  [R1]
         { info_tbl: [(c9GeP,
                       label: block_c9GeP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GeP: // global
           _s9FyK::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9GeT;
               case 2 : goto c9GeU;
               case 3 : goto c9GeV;
               case 4 : goto c9GeW;
               case 5 : goto c9GeX;
               case 6 : goto c9GeY;
           }
       c9GeY: // global
           I64[Sp + 8] = block_c9GgW_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ghz; else goto c9GgY;
       u9Ghz: // global
           call _c9GgW() args: 0, res: 0, upd: 0;
       c9GgY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GeX: // global
           I64[Sp + 8] = block_c9GgH_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ghy; else goto c9GgJ;
       u9Ghy: // global
           call _c9GgH(R1) args: 0, res: 0, upd: 0;
       c9GgJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GeW: // global
           I64[Sp + 8] = block_c9Ggo_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ghx; else goto c9Ggq;
       u9Ghx: // global
           call _c9Ggo(R1) args: 0, res: 0, upd: 0;
       c9Ggq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GeV: // global
           I64[Sp + 8] = block_c9Gg1_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ghw; else goto c9Gg3;
       u9Ghw: // global
           call _c9Gg1(R1) args: 0, res: 0, upd: 0;
       c9Gg3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GeU: // global
           I64[Sp + 8] = block_c9GfA_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ghv; else goto c9GfC;
       u9Ghv: // global
           call _c9GfA(R1) args: 0, res: 0, upd: 0;
       c9GfC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GeT: // global
           I64[Sp + 8] = block_c9Gf5_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ghu; else goto c9Gf7;
       u9Ghu: // global
           call _c9Gf5(R1) args: 0, res: 0, upd: 0;
       c9Gf7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GgW() //  []
         { info_tbl: [(c9GgW,
                       label: block_c9GgW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GgW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GgH() //  [R1]
         { info_tbl: [(c9GgH,
                       label: block_c9GgH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GgH: // global
           if (R1 & 7 == 6) goto u9Ghc; else goto u9Ghd;
       u9Ghc: // global
           Sp = Sp + 8;
           call _c9GgT() args: 0, res: 0, upd: 0;
       u9Ghd: // global
           Sp = Sp + 8;
           call _c9GgP() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ggo() //  [R1]
         { info_tbl: [(c9Ggo,
                       label: block_c9Ggo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ggo: // global
           _c9Gh4::P64 = R1 & 7;
           if (_c9Gh4::P64 != 5) goto u9Ghb; else goto u9Ghe;
       u9Ghb: // global
           if (_c9Gh4::P64 != 6) goto u9Ghg; else goto u9Ghf;
       u9Ghg: // global
           Sp = Sp + 8;
           call _c9GgP() args: 0, res: 0, upd: 0;
       u9Ghf: // global
           Sp = Sp + 8;
           goto u9GhJ;
       u9Ghe: // global
           Sp = Sp + 8;
           goto u9GhJ;
       u9GhJ: // global
           call _c9GgT() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gg1() //  [R1]
         { info_tbl: [(c9Gg1,
                       label: block_c9Gg1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gg1: // global
           _c9Gh5::P64 = R1 & 7;
           if (_c9Gh5::P64 < 4) goto u9Ghh; else goto u9Gha;
       u9Ghh: // global
           Sp = Sp + 8;
           call _c9GgP() args: 0, res: 0, upd: 0;
       u9Gha: // global
           if (_c9Gh5::P64 != 5) goto u9Ghj; else goto u9Ghj;
       u9Ghj: // global
           Sp = Sp + 8;
           call _c9GgT() args: 0, res: 0, upd: 0;
     }
 },
 _c9GfA() //  [R1]
         { info_tbl: [(c9GfA,
                       label: block_c9GfA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GfA: // global
           _c9Gh6::P64 = R1 & 7;
           if (_c9Gh6::P64 < 6) goto u9Gh8; else goto u9Ghk;
       u9Gh8: // global
           if (_c9Gh6::P64 < 3) goto u9Ghl; else goto u9Gh9;
       u9Ghl: // global
           Sp = Sp + 8;
           call _c9GgP() args: 0, res: 0, upd: 0;
       u9Gh9: // global
           if (_c9Gh6::P64 != 4) goto u9Ghn; else goto u9Ghn;
       u9Ghn: // global
           Sp = Sp + 8;
           goto u9GhF;
       u9Ghk: // global
           Sp = Sp + 8;
           goto u9GhF;
       u9GhF: // global
           call _c9GgT() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gf5() //  [R1]
         { info_tbl: [(c9Gf5,
                       label: block_c9Gf5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gf5: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9Gho;
               case 2, 3, 4, 5, 6 : goto u9Ght;
           }
       u9Ght: // global
           Sp = Sp + 8;
           call _c9GgT() args: 0, res: 0, upd: 0;
       u9Gho: // global
           Sp = Sp + 8;
           call _c9GgP() args: 0, res: 0, upd: 0;
     }
 },
 _c9GgT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GgT: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GgP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GgP: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.561319163 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$cmax_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c9Gi2,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gi2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Gi3; else goto c9Gi4;
       c9Gi3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Gi4: // global
           I64[Sp - 16] = block_c9GhR_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Gk5; else goto c9GhS;
       u9Gk5: // global
           call _c9GhR(R1) args: 0, res: 0, upd: 0;
       c9GhS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GhR() //  [R1]
         { info_tbl: [(c9GhR,
                       label: block_c9GhR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GhR: // global
           _s9FyT::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9GhV;
               case 2 : goto c9GhW;
               case 3 : goto c9GhX;
               case 4 : goto c9GhY;
               case 5 : goto c9GhZ;
               case 6 : goto c9Gi0;
           }
       c9Gi0: // global
           I64[Sp + 8] = block_c9Gjw_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gk4; else goto c9Gjy;
       u9Gk4: // global
           call _c9Gjw() args: 0, res: 0, upd: 0;
       c9Gjy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GhZ: // global
           I64[Sp + 8] = block_c9Gjh_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gk3; else goto c9Gjj;
       u9Gk3: // global
           call _c9Gjh(R1) args: 0, res: 0, upd: 0;
       c9Gjj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GhY: // global
           I64[Sp + 8] = block_c9GiY_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gk2; else goto c9Gj0;
       u9Gk2: // global
           call _c9GiY(R1) args: 0, res: 0, upd: 0;
       c9Gj0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GhX: // global
           I64[Sp + 8] = block_c9GiB_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gk1; else goto c9GiD;
       u9Gk1: // global
           call _c9GiB(R1) args: 0, res: 0, upd: 0;
       c9GiD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GhW: // global
           I64[Sp + 8] = block_c9Gia_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gk0; else goto c9Gic;
       u9Gk0: // global
           call _c9Gia(R1) args: 0, res: 0, upd: 0;
       c9Gic: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GhV: // global
           R1 = _s9FyT::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Gjw() //  []
         { info_tbl: [(c9Gjw,
                       label: block_c9Gjw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gjw: // global
           R1 = GHC.Conc.Sync.BlockedOnOther_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Gjh() //  [R1]
         { info_tbl: [(c9Gjh,
                       label: block_c9Gjh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gjh: // global
           if (R1 & 7 == 6) goto u9GjN; else goto u9GjO;
       u9GjN: // global
           Sp = Sp + 8;
           call _c9Gjt() args: 0, res: 0, upd: 0;
       u9GjO: // global
           Sp = Sp + 8;
           call _c9Gjp() args: 0, res: 0, upd: 0;
     }
 },
 _c9GiY() //  [R1]
         { info_tbl: [(c9GiY,
                       label: block_c9GiY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GiY: // global
           _c9GjE::P64 = R1 & 7;
           if (_c9GjE::P64 != 5) goto u9GjM; else goto u9GjP;
       u9GjM: // global
           if (_c9GjE::P64 != 6) goto u9GjR; else goto u9GjQ;
       u9GjR: // global
           Sp = Sp + 8;
           call _c9Gj6() args: 0, res: 0, upd: 0;
       u9GjQ: // global
           Sp = Sp + 8;
           call _c9Gjt() args: 0, res: 0, upd: 0;
       u9GjP: // global
           Sp = Sp + 8;
           call _c9Gjp() args: 0, res: 0, upd: 0;
     }
 },
 _c9GiB() //  [R1]
         { info_tbl: [(c9GiB,
                       label: block_c9GiB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GiB: // global
           _c9GjF::P64 = R1 & 7;
           if (_c9GjF::P64 < 5) goto u9GjK; else goto u9GjL;
       u9GjK: // global
           if (_c9GjF::P64 < 4) goto u9GjT; else goto u9GjS;
       u9GjT: // global
           Sp = Sp + 8;
           call _c9GiJ() args: 0, res: 0, upd: 0;
       u9GjS: // global
           Sp = Sp + 8;
           call _c9Gj6() args: 0, res: 0, upd: 0;
       u9GjL: // global
           if (_c9GjF::P64 < 6) goto u9GjV; else goto u9GjU;
       u9GjV: // global
           Sp = Sp + 8;
           call _c9Gjp() args: 0, res: 0, upd: 0;
       u9GjU: // global
           Sp = Sp + 8;
           call _c9Gjt() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gia() //  [R1]
         { info_tbl: [(c9Gia,
                       label: block_c9Gia_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gia: // global
           _c9GjG::P64 = R1 & 7;
           if (_c9GjG::P64 < 5) goto u9GjH; else goto u9GjJ;
       u9GjH: // global
           if (_c9GjG::P64 < 4) goto u9GjI; else goto u9GjW;
       u9GjI: // global
           if (_c9GjG::P64 < 3) goto c9Gii; else goto u9GjX;
       c9Gii: // global
           R1 = GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9GjX: // global
           Sp = Sp + 8;
           call _c9GiJ() args: 0, res: 0, upd: 0;
       u9GjW: // global
           Sp = Sp + 8;
           call _c9Gj6() args: 0, res: 0, upd: 0;
       u9GjJ: // global
           if (_c9GjG::P64 < 6) goto u9GjZ; else goto u9GjY;
       u9GjZ: // global
           Sp = Sp + 8;
           call _c9Gjp() args: 0, res: 0, upd: 0;
       u9GjY: // global
           Sp = Sp + 8;
           call _c9Gjt() args: 0, res: 0, upd: 0;
     }
 },
 _c9GiJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GiJ: // global
           R1 = GHC.Conc.Sync.BlockedOnException_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Gj6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gj6: // global
           R1 = GHC.Conc.Sync.BlockedOnSTM_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Gjp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gjp: // global
           R1 = GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Gjt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gjt: // global
           R1 = GHC.Conc.Sync.BlockedOnOther_closure+6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.565532466 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c>=_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c9Gky,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gky: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Gkz; else goto c9GkA;
       c9Gkz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GkA: // global
           I64[Sp - 16] = block_c9Gkn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Gn8; else goto c9Gko;
       u9Gn8: // global
           call _c9Gkn(R1) args: 0, res: 0, upd: 0;
       c9Gko: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Gkn() //  [R1]
         { info_tbl: [(c9Gkn,
                       label: block_c9Gkn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gkn: // global
           _s9Fz2::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Gkr;
               case 2 : goto c9Gks;
               case 3 : goto c9Gkt;
               case 4 : goto c9Gku;
               case 5 : goto c9Gkv;
               case 6 : goto c9Gkw;
           }
       c9Gkw: // global
           I64[Sp + 8] = block_c9Gmu_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gn7; else goto c9Gmw;
       u9Gn7: // global
           call _c9Gmu() args: 0, res: 0, upd: 0;
       c9Gmw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Gkv: // global
           I64[Sp + 8] = block_c9Gmf_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gn6; else goto c9Gmh;
       u9Gn6: // global
           call _c9Gmf(R1) args: 0, res: 0, upd: 0;
       c9Gmh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Gku: // global
           I64[Sp + 8] = block_c9GlW_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gn5; else goto c9GlY;
       u9Gn5: // global
           call _c9GlW(R1) args: 0, res: 0, upd: 0;
       c9GlY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Gkt: // global
           I64[Sp + 8] = block_c9Glz_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gn4; else goto c9GlB;
       u9Gn4: // global
           call _c9Glz(R1) args: 0, res: 0, upd: 0;
       c9GlB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Gks: // global
           I64[Sp + 8] = block_c9Gl8_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gn3; else goto c9Gla;
       u9Gn3: // global
           call _c9Gl8(R1) args: 0, res: 0, upd: 0;
       c9Gla: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Gkr: // global
           I64[Sp + 8] = block_c9GkD_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gn2; else goto c9GkF;
       u9Gn2: // global
           call _c9GkD(R1) args: 0, res: 0, upd: 0;
       c9GkF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Gmu() //  []
         { info_tbl: [(c9Gmu,
                       label: block_c9Gmu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gmu: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Gmf() //  [R1]
         { info_tbl: [(c9Gmf,
                       label: block_c9Gmf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gmf: // global
           if (R1 & 7 == 6) goto u9GmK; else goto u9GmL;
       u9GmK: // global
           Sp = Sp + 8;
           call _c9Gmr() args: 0, res: 0, upd: 0;
       u9GmL: // global
           Sp = Sp + 8;
           call _c9Gmn() args: 0, res: 0, upd: 0;
     }
 },
 _c9GlW() //  [R1]
         { info_tbl: [(c9GlW,
                       label: block_c9GlW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GlW: // global
           _c9GmC::P64 = R1 & 7;
           if (_c9GmC::P64 != 5) goto u9GmJ; else goto u9GmM;
       u9GmJ: // global
           if (_c9GmC::P64 != 6) goto u9GmO; else goto u9GmN;
       u9GmO: // global
           Sp = Sp + 8;
           call _c9Gmn() args: 0, res: 0, upd: 0;
       u9GmN: // global
           Sp = Sp + 8;
           goto u9Gnh;
       u9GmM: // global
           Sp = Sp + 8;
           goto u9Gnh;
       u9Gnh: // global
           call _c9Gmr() args: 0, res: 0, upd: 0;
     }
 },
 _c9Glz() //  [R1]
         { info_tbl: [(c9Glz,
                       label: block_c9Glz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Glz: // global
           _c9GmD::P64 = R1 & 7;
           if (_c9GmD::P64 < 4) goto u9GmP; else goto u9GmI;
       u9GmP: // global
           Sp = Sp + 8;
           call _c9Gmn() args: 0, res: 0, upd: 0;
       u9GmI: // global
           if (_c9GmD::P64 != 5) goto u9GmR; else goto u9GmR;
       u9GmR: // global
           Sp = Sp + 8;
           call _c9Gmr() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gl8() //  [R1]
         { info_tbl: [(c9Gl8,
                       label: block_c9Gl8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gl8: // global
           _c9GmE::P64 = R1 & 7;
           if (_c9GmE::P64 < 6) goto u9GmG; else goto u9GmS;
       u9GmG: // global
           if (_c9GmE::P64 < 3) goto u9GmT; else goto u9GmH;
       u9GmT: // global
           Sp = Sp + 8;
           call _c9Gmn() args: 0, res: 0, upd: 0;
       u9GmH: // global
           if (_c9GmE::P64 != 4) goto u9GmV; else goto u9GmV;
       u9GmV: // global
           Sp = Sp + 8;
           goto u9Gnd;
       u9GmS: // global
           Sp = Sp + 8;
           goto u9Gnd;
       u9Gnd: // global
           call _c9Gmr() args: 0, res: 0, upd: 0;
     }
 },
 _c9GkD() //  [R1]
         { info_tbl: [(c9GkD,
                       label: block_c9GkD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GkD: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9GmW;
               case 2, 3, 4, 5, 6 : goto u9Gn1;
           }
       u9Gn1: // global
           Sp = Sp + 8;
           call _c9Gmr() args: 0, res: 0, upd: 0;
       u9GmW: // global
           Sp = Sp + 8;
           call _c9Gmn() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gmr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gmr: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Gmn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gmn: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.568435373 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c>_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c>_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c>_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c>_entry() //  [R2, R3]
         { info_tbl: [(c9Gnp,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gnp: // global
           _s9Fzb::P64 = R3;
           R3 = R2;
           R2 = _s9Fzb::P64;
           call GHC.Conc.Sync.$fOrdBlockReason_$c<_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.570123134 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$cmin_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c9GnH,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GnH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9GnI; else goto c9GnJ;
       c9GnI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GnJ: // global
           I64[Sp - 16] = block_c9Gnw_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Gpv; else goto c9Gnx;
       u9Gpv: // global
           call _c9Gnw(R1) args: 0, res: 0, upd: 0;
       c9Gnx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Gnw() //  [R1]
         { info_tbl: [(c9Gnw,
                       label: block_c9Gnw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gnw: // global
           _s9Fzc::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9GnA;
               case 2 : goto c9GnB;
               case 3 : goto c9GnC;
               case 4 : goto c9GnD;
               case 5 : goto c9GnE;
               case 6 : goto c9GnF;
           }
       c9GnF: // global
           R1 = _s9Fzc::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9GnE: // global
           I64[Sp + 8] = block_c9Gp2_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gpu; else goto c9Gp4;
       u9Gpu: // global
           call _c9Gp2(R1) args: 0, res: 0, upd: 0;
       c9Gp4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GnD: // global
           I64[Sp + 8] = block_c9GoJ_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gpt; else goto c9GoL;
       u9Gpt: // global
           call _c9GoJ(R1) args: 0, res: 0, upd: 0;
       c9GoL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GnC: // global
           I64[Sp + 8] = block_c9Gom_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gps; else goto c9Goo;
       u9Gps: // global
           call _c9Gom(R1) args: 0, res: 0, upd: 0;
       c9Goo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GnB: // global
           I64[Sp + 8] = block_c9GnV_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gpr; else goto c9GnX;
       u9Gpr: // global
           call _c9GnV(R1) args: 0, res: 0, upd: 0;
       c9GnX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GnA: // global
           I64[Sp + 8] = block_c9GnM_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gpq; else goto c9GnO;
       u9Gpq: // global
           call _c9GnM() args: 0, res: 0, upd: 0;
       c9GnO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Gp2() //  [R1]
         { info_tbl: [(c9Gp2,
                       label: block_c9Gp2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gp2: // global
           if (R1 & 7 == 6) goto c9Gpe; else goto c9Gpa;
       c9Gpe: // global
           R1 = GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Gpa: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GoJ() //  [R1]
         { info_tbl: [(c9GoJ,
                       label: block_c9GoJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GoJ: // global
           _c9Gpj::P64 = R1 & 7;
           if (_c9Gpj::P64 == 5) goto c9GoZ; else goto u9Gpp;
       u9Gpp: // global
           if (_c9Gpj::P64 == 6) goto c9GoZ; else goto c9GoR;
       c9GoZ: // global
           R1 = GHC.Conc.Sync.BlockedOnSTM_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9GoR: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Gom() //  [R1]
         { info_tbl: [(c9Gom,
                       label: block_c9Gom_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gom: // global
           _c9Gpk::P64 = R1 & 7;
           if (_c9Gpk::P64 < 4) goto c9Gou; else goto u9Gpo;
       c9Gou: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9Gpo: // global
           if (_c9Gpk::P64 != 5) goto c9GoG; else goto c9GoG;
       c9GoG: // global
           R1 = GHC.Conc.Sync.BlockedOnException_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GnV() //  [R1]
         { info_tbl: [(c9GnV,
                       label: block_c9GnV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GnV: // global
           _c9Gpl::P64 = R1 & 7;
           if (_c9Gpl::P64 >= 6) goto c9Goj; else goto u9Gpm;
       u9Gpm: // global
           if (_c9Gpl::P64 < 3) goto c9Go3; else goto u9Gpn;
       c9Go3: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9Gpn: // global
           if (_c9Gpl::P64 != 4) goto c9Goj; else goto c9Goj;
       c9Goj: // global
           R1 = GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GnM() //  []
         { info_tbl: [(c9GnM,
                       label: block_c9GnM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GnM: // global
           R1 = GHC.Conc.Sync.BlockedOnMVar_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.57262792 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Conc.Sync.$fEqBlockReason_closure+1;
         const GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c<_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c>_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.574212806 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c9GpJ,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GpJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9GpK; else goto c9GpL;
       c9GpK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GpL: // global
           I64[Sp - 16] = block_c9GpA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Grt; else goto c9GpB;
       u9Grt: // global
           call _c9GpA(R1) args: 0, res: 0, upd: 0;
       c9GpB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GpA() //  [R1]
         { info_tbl: [(c9GpA,
                       label: block_c9GpA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GpA: // global
           _s9Fzl::P64 = P64[Sp + 8];
           _c9GpI::P64 = R1 & 7;
           if (_c9GpI::P64 < 3) goto u9Gr8; else goto u9Gr9;
       u9Gr8: // global
           if (_c9GpI::P64 < 2) goto c9GpE; else goto c9GpF;
       c9GpE: // global
           I64[Sp + 8] = block_c9GpO_info;
           R1 = _s9Fzl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Grp; else goto c9GpQ;
       u9Grp: // global
           call _c9GpO(R1) args: 0, res: 0, upd: 0;
       c9GpQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GpF: // global
           I64[Sp + 8] = block_c9Gqb_info;
           R1 = _s9Fzl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Grq; else goto c9Gqd;
       u9Grq: // global
           call _c9Gqb(R1) args: 0, res: 0, upd: 0;
       c9Gqd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Gr9: // global
           if (_c9GpI::P64 < 4) goto c9GpG; else goto c9GpH;
       c9GpG: // global
           I64[Sp] = block_c9Gqy_info;
           _s9Fzr::P64 = P64[R1 + 5];
           R1 = _s9Fzl::P64;
           P64[Sp + 8] = _s9Fzr::P64;
           if (R1 & 7 != 0) goto u9Grr; else goto c9GqA;
       u9Grr: // global
           call _c9Gqy(R1) args: 0, res: 0, upd: 0;
       c9GqA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GpH: // global
           I64[Sp + 8] = block_c9GqR_info;
           R1 = _s9Fzl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Grs; else goto c9GqT;
       u9Grs: // global
           call _c9GqR(R1) args: 0, res: 0, upd: 0;
       c9GqT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GpO() //  [R1]
         { info_tbl: [(c9GpO,
                       label: block_c9GpO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GpO: // global
           _c9Gr7::P64 = R1 & 7;
           if (_c9Gr7::P64 < 2) goto u9Gre; else goto u9Gra;
       u9Gre: // global
           Sp = Sp + 8;
           call _c9Gr3() args: 0, res: 0, upd: 0;
       u9Gra: // global
           if (_c9Gr7::P64 != 3) goto u9Grg; else goto u9Grg;
       u9Grg: // global
           Sp = Sp + 8;
           call _c9GqO() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gqb() //  [R1]
         { info_tbl: [(c9Gqb,
                       label: block_c9Gqb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gqb: // global
           _c9Gr6::P64 = R1 & 7;
           if (_c9Gr6::P64 < 3) goto u9Grb; else goto u9Grc;
       u9Grb: // global
           if (_c9Gr6::P64 < 2) goto u9Gri; else goto u9Grh;
       u9Gri: // global
           Sp = Sp + 8;
           call _c9GqZ() args: 0, res: 0, upd: 0;
       u9Grh: // global
           Sp = Sp + 8;
           call _c9Gr3() args: 0, res: 0, upd: 0;
       u9Grc: // global
           if (_c9Gr6::P64 < 4) goto u9Grk; else goto u9Grk;
       u9Grk: // global
           Sp = Sp + 8;
           call _c9GqO() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gqy() //  [R1]
         { info_tbl: [(c9Gqy,
                       label: block_c9Gqy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gqy: // global
           _c9Gr5::P64 = R1 & 7;
           if (_c9Gr5::P64 == 3) goto c9GqK; else goto u9Grd;
       c9GqK: // global
           R3 = P64[R1 + 5];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$fOrdBlockReason_$ccompare_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
       u9Grd: // global
           if (_c9Gr5::P64 != 4) goto u9Grm; else goto u9Grl;
       u9Grm: // global
           Sp = Sp + 16;
           call _c9GqZ() args: 0, res: 0, upd: 0;
       u9Grl: // global
           Sp = Sp + 16;
           call _c9GqO() args: 0, res: 0, upd: 0;
     }
 },
 _c9GqO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GqO: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GqR() //  [R1]
         { info_tbl: [(c9GqR,
                       label: block_c9GqR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GqR: // global
           if (R1 & 7 == 4) goto u9Grn; else goto u9Gro;
       u9Grn: // global
           Sp = Sp + 8;
           call _c9Gr3() args: 0, res: 0, upd: 0;
       u9Gro: // global
           Sp = Sp + 8;
           call _c9GqZ() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gr3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gr3: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GqZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GqZ: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.578576516 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c<_entry() //  [R2, R3]
         { info_tbl: [(c9GrQ,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GrQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9GrR; else goto c9GrS;
       c9GrR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GrS: // global
           I64[Sp - 16] = block_c9GrH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9GvX; else goto c9GrI;
       u9GvX: // global
           call _c9GrH(R1) args: 0, res: 0, upd: 0;
       c9GrI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GrH() //  [R1]
         { info_tbl: [(c9GrH,
                       label: block_c9GrH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GrH: // global
           _s9Fzw::P64 = P64[Sp + 8];
           _c9GrP::P64 = R1 & 7;
           if (_c9GrP::P64 < 3) goto u9Gvk; else goto u9Gvl;
       u9Gvk: // global
           if (_c9GrP::P64 < 2) goto c9GrL; else goto c9GrM;
       c9GrL: // global
           I64[Sp + 8] = block_c9GrV_info;
           R1 = _s9Fzw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GvT; else goto c9GrX;
       u9GvT: // global
           call _c9GrV(R1) args: 0, res: 0, upd: 0;
       c9GrX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GrM: // global
           I64[Sp + 8] = block_c9Gsi_info;
           R1 = _s9Fzw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GvU; else goto c9Gsk;
       u9GvU: // global
           call _c9Gsi(R1) args: 0, res: 0, upd: 0;
       c9Gsk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Gvl: // global
           if (_c9GrP::P64 < 4) goto c9GrN; else goto c9GrO;
       c9GrN: // global
           I64[Sp] = block_c9GsB_info;
           _s9FzC::P64 = P64[R1 + 5];
           R1 = _s9Fzw::P64;
           P64[Sp + 8] = _s9FzC::P64;
           if (R1 & 7 != 0) goto u9GvV; else goto c9GsD;
       u9GvV: // global
           call _c9GsB(R1) args: 0, res: 0, upd: 0;
       c9GsD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GrO: // global
           I64[Sp + 8] = block_c9Gv4_info;
           R1 = _s9Fzw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GvW; else goto c9Gv6;
       u9GvW: // global
           call _c9Gv4() args: 0, res: 0, upd: 0;
       c9Gv6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GrV() //  [R1]
         { info_tbl: [(c9GrV,
                       label: block_c9GrV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GrV: // global
           _c9Gvj::P64 = R1 & 7;
           if (_c9Gvj::P64 < 2) goto u9Gvt; else goto u9Gvm;
       u9Gvt: // global
           Sp = Sp + 8;
           call _c9GuJ() args: 0, res: 0, upd: 0;
       u9Gvm: // global
           if (_c9Gvj::P64 != 3) goto u9Gvv; else goto u9Gvv;
       u9Gvv: // global
           Sp = Sp + 8;
           call _c9Gv1() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gsi() //  [R1]
         { info_tbl: [(c9Gsi,
                       label: block_c9Gsi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gsi: // global
           _c9Gvi::P64 = R1 & 7;
           if (_c9Gvi::P64 != 3) goto u9Gvn; else goto u9Gvw;
       u9Gvn: // global
           if (_c9Gvi::P64 != 4) goto u9Gvy; else goto u9Gvx;
       u9Gvy: // global
           Sp = Sp + 8;
           call _c9GuJ() args: 0, res: 0, upd: 0;
       u9Gvx: // global
           Sp = Sp + 8;
           goto u9Gw1;
       u9Gvw: // global
           Sp = Sp + 8;
           goto u9Gw1;
       u9Gw1: // global
           call _c9Gv1() args: 0, res: 0, upd: 0;
     }
 },
 _c9GsB() //  [R1]
         { info_tbl: [(c9GsB,
                       label: block_c9GsB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GsB: // global
           _c9Gvb::P64 = R1 & 7;
           if (_c9Gvb::P64 == 3) goto c9GsO; else goto u9Gvo;
       c9GsO: // global
           I64[Sp] = block_c9GsM_info;
           _s9FzE::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FzE::P64;
           if (R1 & 7 != 0) goto u9Gw3; else goto c9GsP;
       u9Gw3: // global
           call _c9GsM(R1) args: 0, res: 0, upd: 0;
       c9GsP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Gvo: // global
           if (_c9Gvb::P64 != 4) goto u9GvA; else goto u9Gvz;
       u9GvA: // global
           Sp = Sp + 16;
           call _c9GuJ() args: 0, res: 0, upd: 0;
       u9Gvz: // global
           Sp = Sp + 16;
           call _c9Gv1() args: 0, res: 0, upd: 0;
     }
 },
 _c9GsM() //  [R1]
         { info_tbl: [(c9GsM,
                       label: block_c9GsM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GsM: // global
           _s9FzE::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9GsW;
               case 2 : goto c9Gts;
               case 3 : goto c9GtU;
               case 4 : goto c9Gui;
               case 5 : goto c9GuC;
               case 6 : goto c9GuS;
           }
       c9GuS: // global
           I64[Sp + 8] = block_c9GuQ_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gwb; else goto c9GuT;
       u9Gwb: // global
           call _c9GuQ() args: 0, res: 0, upd: 0;
       c9GuT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GuC: // global
           I64[Sp + 8] = block_c9GuA_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gwa; else goto c9GuD;
       u9Gwa: // global
           call _c9GuA(R1) args: 0, res: 0, upd: 0;
       c9GuD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Gui: // global
           I64[Sp + 8] = block_c9Gug_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gw9; else goto c9Guj;
       u9Gw9: // global
           call _c9Gug(R1) args: 0, res: 0, upd: 0;
       c9Guj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GtU: // global
           I64[Sp + 8] = block_c9GtS_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gw8; else goto c9GtV;
       u9Gw8: // global
           call _c9GtS(R1) args: 0, res: 0, upd: 0;
       c9GtV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Gts: // global
           I64[Sp + 8] = block_c9Gtq_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gw7; else goto c9Gtt;
       u9Gw7: // global
           call _c9Gtq(R1) args: 0, res: 0, upd: 0;
       c9Gtt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GsW: // global
           I64[Sp + 8] = block_c9GsT_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Gw6; else goto c9GsX;
       u9Gw6: // global
           call _c9GsT(R1) args: 0, res: 0, upd: 0;
       c9GsX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GuQ() //  []
         { info_tbl: [(c9GuQ,
                       label: block_c9GuQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GuQ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GuA() //  [R1]
         { info_tbl: [(c9GuA,
                       label: block_c9GuA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GuA: // global
           if (R1 & 7 == 6) goto u9GvB; else goto u9GvC;
       u9GvB: // global
           Sp = Sp + 8;
           call _c9Gv1() args: 0, res: 0, upd: 0;
       u9GvC: // global
           Sp = Sp + 8;
           call _c9GuJ() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gug() //  [R1]
         { info_tbl: [(c9Gug,
                       label: block_c9Gug_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gug: // global
           _c9Gve::P64 = R1 & 7;
           if (_c9Gve::P64 != 5) goto u9Gvs; else goto u9GvD;
       u9Gvs: // global
           if (_c9Gve::P64 != 6) goto u9GvF; else goto u9GvE;
       u9GvF: // global
           Sp = Sp + 8;
           call _c9GuJ() args: 0, res: 0, upd: 0;
       u9GvE: // global
           Sp = Sp + 8;
           goto u9Gwk;
       u9GvD: // global
           Sp = Sp + 8;
           goto u9Gwk;
       u9Gwk: // global
           call _c9Gv1() args: 0, res: 0, upd: 0;
     }
 },
 _c9GtS() //  [R1]
         { info_tbl: [(c9GtS,
                       label: block_c9GtS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GtS: // global
           _c9Gvf::P64 = R1 & 7;
           if (_c9Gvf::P64 < 4) goto u9GvG; else goto u9Gvr;
       u9GvG: // global
           Sp = Sp + 8;
           call _c9GuJ() args: 0, res: 0, upd: 0;
       u9Gvr: // global
           if (_c9Gvf::P64 != 5) goto u9GvI; else goto u9GvI;
       u9GvI: // global
           Sp = Sp + 8;
           call _c9Gv1() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gtq() //  [R1]
         { info_tbl: [(c9Gtq,
                       label: block_c9Gtq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gtq: // global
           _c9Gvg::P64 = R1 & 7;
           if (_c9Gvg::P64 < 6) goto u9Gvp; else goto u9GvJ;
       u9Gvp: // global
           if (_c9Gvg::P64 < 3) goto u9GvK; else goto u9Gvq;
       u9GvK: // global
           Sp = Sp + 8;
           call _c9GuJ() args: 0, res: 0, upd: 0;
       u9Gvq: // global
           if (_c9Gvg::P64 != 4) goto u9GvM; else goto u9GvM;
       u9GvM: // global
           Sp = Sp + 8;
           goto u9Gwg;
       u9GvJ: // global
           Sp = Sp + 8;
           goto u9Gwg;
       u9Gwg: // global
           call _c9Gv1() args: 0, res: 0, upd: 0;
     }
 },
 _c9GsT() //  [R1]
         { info_tbl: [(c9GsT,
                       label: block_c9GsT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GsT: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9GvN;
               case 2, 3, 4, 5, 6 : goto u9GvS;
           }
       u9GvS: // global
           Sp = Sp + 8;
           call _c9Gv1() args: 0, res: 0, upd: 0;
       u9GvN: // global
           Sp = Sp + 8;
           call _c9GuJ() args: 0, res: 0, upd: 0;
     }
 },
 _c9GuJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GuJ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Gv1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gv1: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Gv4() //  []
         { info_tbl: [(c9Gv4,
                       label: block_c9Gv4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gv4: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.584601628 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>=_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c9GwB,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GwB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9GwC; else goto c9GwD;
       c9GwC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GwD: // global
           I64[Sp - 16] = block_c9Gws_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9GAI; else goto c9Gwt;
       u9GAI: // global
           call _c9Gws(R1) args: 0, res: 0, upd: 0;
       c9Gwt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Gws() //  [R1]
         { info_tbl: [(c9Gws,
                       label: block_c9Gws_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gws: // global
           _s9FzO::P64 = P64[Sp + 8];
           _c9GwA::P64 = R1 & 7;
           if (_c9GwA::P64 < 3) goto u9GA5; else goto u9GA6;
       u9GA5: // global
           if (_c9GwA::P64 < 2) goto c9Gww; else goto c9Gwx;
       c9Gww: // global
           I64[Sp + 8] = block_c9GwG_info;
           R1 = _s9FzO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GAE; else goto c9GwI;
       u9GAE: // global
           call _c9GwG(R1) args: 0, res: 0, upd: 0;
       c9GwI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Gwx: // global
           I64[Sp + 8] = block_c9Gx3_info;
           R1 = _s9FzO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GAF; else goto c9Gx5;
       u9GAF: // global
           call _c9Gx3(R1) args: 0, res: 0, upd: 0;
       c9Gx5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9GA6: // global
           if (_c9GwA::P64 < 4) goto c9Gwy; else goto c9Gwz;
       c9Gwy: // global
           I64[Sp] = block_c9Gxm_info;
           _s9FzU::P64 = P64[R1 + 5];
           R1 = _s9FzO::P64;
           P64[Sp + 8] = _s9FzU::P64;
           if (R1 & 7 != 0) goto u9GAG; else goto c9Gxo;
       u9GAG: // global
           call _c9Gxm(R1) args: 0, res: 0, upd: 0;
       c9Gxo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Gwz: // global
           I64[Sp + 8] = block_c9GzP_info;
           R1 = _s9FzO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GAH; else goto c9GzR;
       u9GAH: // global
           call _c9GzP() args: 0, res: 0, upd: 0;
       c9GzR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GwG() //  [R1]
         { info_tbl: [(c9GwG,
                       label: block_c9GwG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GwG: // global
           _c9GA4::P64 = R1 & 7;
           if (_c9GA4::P64 < 2) goto u9GAe; else goto u9GA7;
       u9GAe: // global
           Sp = Sp + 8;
           call _c9Gzu() args: 0, res: 0, upd: 0;
       u9GA7: // global
           if (_c9GA4::P64 != 3) goto u9GAg; else goto u9GAg;
       u9GAg: // global
           Sp = Sp + 8;
           call _c9GzM() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gx3() //  [R1]
         { info_tbl: [(c9Gx3,
                       label: block_c9Gx3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gx3: // global
           _c9GA3::P64 = R1 & 7;
           if (_c9GA3::P64 != 3) goto u9GA8; else goto u9GAh;
       u9GA8: // global
           if (_c9GA3::P64 != 4) goto u9GAj; else goto u9GAi;
       u9GAj: // global
           Sp = Sp + 8;
           call _c9Gzu() args: 0, res: 0, upd: 0;
       u9GAi: // global
           Sp = Sp + 8;
           goto u9GAM;
       u9GAh: // global
           Sp = Sp + 8;
           goto u9GAM;
       u9GAM: // global
           call _c9GzM() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gxm() //  [R1]
         { info_tbl: [(c9Gxm,
                       label: block_c9Gxm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gxm: // global
           _c9GzW::P64 = R1 & 7;
           if (_c9GzW::P64 == 3) goto c9Gxz; else goto u9GA9;
       c9Gxz: // global
           I64[Sp] = block_c9Gxx_info;
           _s9FzW::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FzW::P64;
           if (R1 & 7 != 0) goto u9GAO; else goto c9GxA;
       u9GAO: // global
           call _c9Gxx(R1) args: 0, res: 0, upd: 0;
       c9GxA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9GA9: // global
           if (_c9GzW::P64 != 4) goto u9GAl; else goto u9GAk;
       u9GAl: // global
           Sp = Sp + 16;
           call _c9Gzu() args: 0, res: 0, upd: 0;
       u9GAk: // global
           Sp = Sp + 16;
           call _c9GzM() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gxx() //  [R1]
         { info_tbl: [(c9Gxx,
                       label: block_c9Gxx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gxx: // global
           _s9FzW::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9GxH;
               case 2 : goto c9Gyd;
               case 3 : goto c9GyF;
               case 4 : goto c9Gz3;
               case 5 : goto c9Gzn;
               case 6 : goto c9GzD;
           }
       c9GzD: // global
           I64[Sp + 8] = block_c9GzB_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GAW; else goto c9GzE;
       u9GAW: // global
           call _c9GzB() args: 0, res: 0, upd: 0;
       c9GzE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Gzn: // global
           I64[Sp + 8] = block_c9Gzl_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GAV; else goto c9Gzo;
       u9GAV: // global
           call _c9Gzl(R1) args: 0, res: 0, upd: 0;
       c9Gzo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Gz3: // global
           I64[Sp + 8] = block_c9Gz1_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GAU; else goto c9Gz4;
       u9GAU: // global
           call _c9Gz1(R1) args: 0, res: 0, upd: 0;
       c9Gz4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GyF: // global
           I64[Sp + 8] = block_c9GyD_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GAT; else goto c9GyG;
       u9GAT: // global
           call _c9GyD(R1) args: 0, res: 0, upd: 0;
       c9GyG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Gyd: // global
           I64[Sp + 8] = block_c9Gyb_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GAS; else goto c9Gye;
       u9GAS: // global
           call _c9Gyb(R1) args: 0, res: 0, upd: 0;
       c9Gye: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GxH: // global
           I64[Sp + 8] = block_c9GxE_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GAR; else goto c9GxI;
       u9GAR: // global
           call _c9GxE(R1) args: 0, res: 0, upd: 0;
       c9GxI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GzB() //  []
         { info_tbl: [(c9GzB,
                       label: block_c9GzB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GzB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Gzl() //  [R1]
         { info_tbl: [(c9Gzl,
                       label: block_c9Gzl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gzl: // global
           if (R1 & 7 == 6) goto u9GAm; else goto u9GAn;
       u9GAm: // global
           Sp = Sp + 8;
           call _c9GzM() args: 0, res: 0, upd: 0;
       u9GAn: // global
           Sp = Sp + 8;
           call _c9Gzu() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gz1() //  [R1]
         { info_tbl: [(c9Gz1,
                       label: block_c9Gz1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gz1: // global
           _c9GzZ::P64 = R1 & 7;
           if (_c9GzZ::P64 != 5) goto u9GAd; else goto u9GAo;
       u9GAd: // global
           if (_c9GzZ::P64 != 6) goto u9GAq; else goto u9GAp;
       u9GAq: // global
           Sp = Sp + 8;
           call _c9Gzu() args: 0, res: 0, upd: 0;
       u9GAp: // global
           Sp = Sp + 8;
           goto u9GB5;
       u9GAo: // global
           Sp = Sp + 8;
           goto u9GB5;
       u9GB5: // global
           call _c9GzM() args: 0, res: 0, upd: 0;
     }
 },
 _c9GyD() //  [R1]
         { info_tbl: [(c9GyD,
                       label: block_c9GyD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GyD: // global
           _c9GA0::P64 = R1 & 7;
           if (_c9GA0::P64 < 4) goto u9GAr; else goto u9GAc;
       u9GAr: // global
           Sp = Sp + 8;
           call _c9Gzu() args: 0, res: 0, upd: 0;
       u9GAc: // global
           if (_c9GA0::P64 != 5) goto u9GAt; else goto u9GAt;
       u9GAt: // global
           Sp = Sp + 8;
           call _c9GzM() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gyb() //  [R1]
         { info_tbl: [(c9Gyb,
                       label: block_c9Gyb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gyb: // global
           _c9GA1::P64 = R1 & 7;
           if (_c9GA1::P64 < 6) goto u9GAa; else goto u9GAu;
       u9GAa: // global
           if (_c9GA1::P64 < 3) goto u9GAv; else goto u9GAb;
       u9GAv: // global
           Sp = Sp + 8;
           call _c9Gzu() args: 0, res: 0, upd: 0;
       u9GAb: // global
           if (_c9GA1::P64 != 4) goto u9GAx; else goto u9GAx;
       u9GAx: // global
           Sp = Sp + 8;
           goto u9GB1;
       u9GAu: // global
           Sp = Sp + 8;
           goto u9GB1;
       u9GB1: // global
           call _c9GzM() args: 0, res: 0, upd: 0;
     }
 },
 _c9GxE() //  [R1]
         { info_tbl: [(c9GxE,
                       label: block_c9GxE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GxE: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9GAy;
               case 2, 3, 4, 5, 6 : goto u9GAD;
           }
       u9GAD: // global
           Sp = Sp + 8;
           call _c9GzM() args: 0, res: 0, upd: 0;
       u9GAy: // global
           Sp = Sp + 8;
           call _c9Gzu() args: 0, res: 0, upd: 0;
     }
 },
 _c9Gzu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Gzu: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GzM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GzM: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GzP() //  []
         { info_tbl: [(c9GzP,
                       label: block_c9GzP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GzP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.593352862 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c>_entry() //  [R2, R3]
         { info_tbl: [(c9GBm,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GBm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9GBn; else goto c9GBo;
       c9GBn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GBo: // global
           I64[Sp - 16] = block_c9GBd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9GFn; else goto c9GBe;
       u9GFn: // global
           call _c9GBd(R1) args: 0, res: 0, upd: 0;
       c9GBe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GBd() //  [R1]
         { info_tbl: [(c9GBd,
                       label: block_c9GBd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GBd: // global
           _s9FA6::P64 = P64[Sp + 8];
           _c9GBl::P64 = R1 & 7;
           if (_c9GBl::P64 < 3) goto u9GEM; else goto u9GEN;
       u9GEM: // global
           if (_c9GBl::P64 < 2) goto c9GBh; else goto c9GBi;
       c9GBh: // global
           I64[Sp + 8] = block_c9GBr_info;
           R1 = _s9FA6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GFj; else goto c9GBt;
       u9GFj: // global
           call _c9GBr() args: 0, res: 0, upd: 0;
       c9GBt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GBi: // global
           I64[Sp + 8] = block_c9GBA_info;
           R1 = _s9FA6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GFk; else goto c9GBC;
       u9GFk: // global
           call _c9GBA(R1) args: 0, res: 0, upd: 0;
       c9GBC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9GEN: // global
           if (_c9GBl::P64 < 4) goto c9GBj; else goto c9GBk;
       c9GBj: // global
           I64[Sp] = block_c9GBX_info;
           _s9FAb::P64 = P64[R1 + 5];
           R1 = _s9FA6::P64;
           P64[Sp + 8] = _s9FAb::P64;
           if (R1 & 7 != 0) goto u9GFl; else goto c9GBZ;
       u9GFl: // global
           call _c9GBX(R1) args: 0, res: 0, upd: 0;
       c9GBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GBk: // global
           I64[Sp + 8] = block_c9GEq_info;
           R1 = _s9FA6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GFm; else goto c9GEs;
       u9GFm: // global
           call _c9GEq(R1) args: 0, res: 0, upd: 0;
       c9GEs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GBr() //  []
         { info_tbl: [(c9GBr,
                       label: block_c9GBr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GBr: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GBA() //  [R1]
         { info_tbl: [(c9GBA,
                       label: block_c9GBA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GBA: // global
           _c9GEL::P64 = R1 & 7;
           if (_c9GEL::P64 < 2) goto u9GEU; else goto u9GEO;
       u9GEU: // global
           Sp = Sp + 8;
           call _c9GEy() args: 0, res: 0, upd: 0;
       u9GEO: // global
           if (_c9GEL::P64 != 3) goto u9GEW; else goto u9GEW;
       u9GEW: // global
           Sp = Sp + 8;
           call _c9GEC() args: 0, res: 0, upd: 0;
     }
 },
 _c9GBX() //  [R1]
         { info_tbl: [(c9GBX,
                       label: block_c9GBX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GBX: // global
           _c9GEE::P64 = R1 & 7;
           if (_c9GEE::P64 == 3) goto c9GCa; else goto u9GEP;
       c9GCa: // global
           I64[Sp] = block_c9GC8_info;
           _s9FAd::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FAd::P64;
           if (R1 & 7 != 0) goto u9GFq; else goto c9GCb;
       u9GFq: // global
           call _c9GC8(R1) args: 0, res: 0, upd: 0;
       c9GCb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9GEP: // global
           if (_c9GEE::P64 != 4) goto u9GEY; else goto u9GEX;
       u9GEY: // global
           Sp = Sp + 16;
           call _c9GEy() args: 0, res: 0, upd: 0;
       u9GEX: // global
           Sp = Sp + 16;
           call _c9GEC() args: 0, res: 0, upd: 0;
     }
 },
 _c9GC8() //  [R1]
         { info_tbl: [(c9GC8,
                       label: block_c9GC8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GC8: // global
           _s9FAd::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9GCi;
               case 2 : goto c9GCs;
               case 3 : goto c9GCY;
               case 4 : goto c9GDq;
               case 5 : goto c9GDO;
               case 6 : goto c9GE8;
           }
       c9GE8: // global
           I64[Sp + 8] = block_c9GE6_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GFy; else goto c9GE9;
       u9GFy: // global
           call _c9GE6(R1) args: 0, res: 0, upd: 0;
       c9GE9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GDO: // global
           I64[Sp + 8] = block_c9GDM_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GFx; else goto c9GDP;
       u9GFx: // global
           call _c9GDM(R1) args: 0, res: 0, upd: 0;
       c9GDP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GDq: // global
           I64[Sp + 8] = block_c9GDo_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GFw; else goto c9GDr;
       u9GFw: // global
           call _c9GDo(R1) args: 0, res: 0, upd: 0;
       c9GDr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GCY: // global
           I64[Sp + 8] = block_c9GCW_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GFv; else goto c9GCZ;
       u9GFv: // global
           call _c9GCW(R1) args: 0, res: 0, upd: 0;
       c9GCZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GCs: // global
           I64[Sp + 8] = block_c9GCq_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GFu; else goto c9GCt;
       u9GFu: // global
           call _c9GCq(R1) args: 0, res: 0, upd: 0;
       c9GCt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GCi: // global
           I64[Sp + 8] = block_c9GCf_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GFt; else goto c9GCj;
       u9GFt: // global
           call _c9GCf() args: 0, res: 0, upd: 0;
       c9GCj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GE6() //  [R1]
         { info_tbl: [(c9GE6,
                       label: block_c9GE6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GE6: // global
           if (R1 & 7 == 6) goto u9GEZ; else goto u9GF0;
       u9GEZ: // global
           Sp = Sp + 8;
           call _c9GEC() args: 0, res: 0, upd: 0;
       u9GF0: // global
           Sp = Sp + 8;
           call _c9GEy() args: 0, res: 0, upd: 0;
     }
 },
 _c9GDM() //  [R1]
         { info_tbl: [(c9GDM,
                       label: block_c9GDM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GDM: // global
           _c9GEH::P64 = R1 & 7;
           if (_c9GEH::P64 != 5) goto u9GET; else goto u9GF1;
       u9GET: // global
           if (_c9GEH::P64 != 6) goto u9GF3; else goto u9GF2;
       u9GF3: // global
           Sp = Sp + 8;
           call _c9GEy() args: 0, res: 0, upd: 0;
       u9GF2: // global
           Sp = Sp + 8;
           goto u9GFH;
       u9GF1: // global
           Sp = Sp + 8;
           goto u9GFH;
       u9GFH: // global
           call _c9GEC() args: 0, res: 0, upd: 0;
     }
 },
 _c9GDo() //  [R1]
         { info_tbl: [(c9GDo,
                       label: block_c9GDo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GDo: // global
           _c9GEI::P64 = R1 & 7;
           if (_c9GEI::P64 < 4) goto u9GF4; else goto u9GES;
       u9GF4: // global
           Sp = Sp + 8;
           call _c9GEy() args: 0, res: 0, upd: 0;
       u9GES: // global
           if (_c9GEI::P64 != 5) goto u9GF6; else goto u9GF6;
       u9GF6: // global
           Sp = Sp + 8;
           call _c9GEC() args: 0, res: 0, upd: 0;
     }
 },
 _c9GCW() //  [R1]
         { info_tbl: [(c9GCW,
                       label: block_c9GCW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GCW: // global
           _c9GEJ::P64 = R1 & 7;
           if (_c9GEJ::P64 < 6) goto u9GEQ; else goto u9GF7;
       u9GEQ: // global
           if (_c9GEJ::P64 < 3) goto u9GF8; else goto u9GER;
       u9GF8: // global
           Sp = Sp + 8;
           call _c9GEy() args: 0, res: 0, upd: 0;
       u9GER: // global
           if (_c9GEJ::P64 != 4) goto u9GFa; else goto u9GFa;
       u9GFa: // global
           Sp = Sp + 8;
           goto u9GFD;
       u9GF7: // global
           Sp = Sp + 8;
           goto u9GFD;
       u9GFD: // global
           call _c9GEC() args: 0, res: 0, upd: 0;
     }
 },
 _c9GCq() //  [R1]
         { info_tbl: [(c9GCq,
                       label: block_c9GCq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GCq: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9GFb;
               case 2, 3, 4, 5, 6 : goto u9GFg;
           }
       u9GFg: // global
           Sp = Sp + 8;
           call _c9GEC() args: 0, res: 0, upd: 0;
       u9GFb: // global
           Sp = Sp + 8;
           call _c9GEy() args: 0, res: 0, upd: 0;
     }
 },
 _c9GCf() //  []
         { info_tbl: [(c9GCf,
                       label: block_c9GCf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GCf: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GEq() //  [R1]
         { info_tbl: [(c9GEq,
                       label: block_c9GEq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GEq: // global
           if (R1 & 7 == 4) goto u9GFh; else goto u9GFi;
       u9GFh: // global
           Sp = Sp + 8;
           call _c9GEC() args: 0, res: 0, upd: 0;
       u9GFi: // global
           Sp = Sp + 8;
           call _c9GEy() args: 0, res: 0, upd: 0;
     }
 },
 _c9GEC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GEC: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GEy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GEy: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.599170824 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<=_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c9GG0,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GG0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9GG1; else goto c9GG2;
       c9GG1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GG2: // global
           I64[Sp - 16] = block_c9GFR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9GK1; else goto c9GFS;
       u9GK1: // global
           call _c9GFR(R1) args: 0, res: 0, upd: 0;
       c9GFS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GFR() //  [R1]
         { info_tbl: [(c9GFR,
                       label: block_c9GFR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GFR: // global
           _s9FAn::P64 = P64[Sp + 8];
           _c9GFZ::P64 = R1 & 7;
           if (_c9GFZ::P64 < 3) goto u9GJq; else goto u9GJr;
       u9GJq: // global
           if (_c9GFZ::P64 < 2) goto c9GFV; else goto c9GFW;
       c9GFV: // global
           I64[Sp + 8] = block_c9GG5_info;
           R1 = _s9FAn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GJX; else goto c9GG7;
       u9GJX: // global
           call _c9GG5() args: 0, res: 0, upd: 0;
       c9GG7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GFW: // global
           I64[Sp + 8] = block_c9GGe_info;
           R1 = _s9FAn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GJY; else goto c9GGg;
       u9GJY: // global
           call _c9GGe(R1) args: 0, res: 0, upd: 0;
       c9GGg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9GJr: // global
           if (_c9GFZ::P64 < 4) goto c9GFX; else goto c9GFY;
       c9GFX: // global
           I64[Sp] = block_c9GGB_info;
           _s9FAs::P64 = P64[R1 + 5];
           R1 = _s9FAn::P64;
           P64[Sp + 8] = _s9FAs::P64;
           if (R1 & 7 != 0) goto u9GJZ; else goto c9GGD;
       u9GJZ: // global
           call _c9GGB(R1) args: 0, res: 0, upd: 0;
       c9GGD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GFY: // global
           I64[Sp + 8] = block_c9GJ4_info;
           R1 = _s9FAn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GK0; else goto c9GJ6;
       u9GK0: // global
           call _c9GJ4(R1) args: 0, res: 0, upd: 0;
       c9GJ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GG5() //  []
         { info_tbl: [(c9GG5,
                       label: block_c9GG5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GG5: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GGe() //  [R1]
         { info_tbl: [(c9GGe,
                       label: block_c9GGe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GGe: // global
           _c9GJp::P64 = R1 & 7;
           if (_c9GJp::P64 < 2) goto u9GJy; else goto u9GJs;
       u9GJy: // global
           Sp = Sp + 8;
           call _c9GJc() args: 0, res: 0, upd: 0;
       u9GJs: // global
           if (_c9GJp::P64 != 3) goto u9GJA; else goto u9GJA;
       u9GJA: // global
           Sp = Sp + 8;
           call _c9GJg() args: 0, res: 0, upd: 0;
     }
 },
 _c9GGB() //  [R1]
         { info_tbl: [(c9GGB,
                       label: block_c9GGB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GGB: // global
           _c9GJi::P64 = R1 & 7;
           if (_c9GJi::P64 == 3) goto c9GGO; else goto u9GJt;
       c9GGO: // global
           I64[Sp] = block_c9GGM_info;
           _s9FAu::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FAu::P64;
           if (R1 & 7 != 0) goto u9GK4; else goto c9GGP;
       u9GK4: // global
           call _c9GGM(R1) args: 0, res: 0, upd: 0;
       c9GGP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9GJt: // global
           if (_c9GJi::P64 != 4) goto u9GJC; else goto u9GJB;
       u9GJC: // global
           Sp = Sp + 16;
           call _c9GJc() args: 0, res: 0, upd: 0;
       u9GJB: // global
           Sp = Sp + 16;
           call _c9GJg() args: 0, res: 0, upd: 0;
     }
 },
 _c9GGM() //  [R1]
         { info_tbl: [(c9GGM,
                       label: block_c9GGM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GGM: // global
           _s9FAu::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9GGW;
               case 2 : goto c9GH6;
               case 3 : goto c9GHC;
               case 4 : goto c9GI4;
               case 5 : goto c9GIs;
               case 6 : goto c9GIM;
           }
       c9GIM: // global
           I64[Sp + 8] = block_c9GIK_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GKc; else goto c9GIN;
       u9GKc: // global
           call _c9GIK(R1) args: 0, res: 0, upd: 0;
       c9GIN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GIs: // global
           I64[Sp + 8] = block_c9GIq_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GKb; else goto c9GIt;
       u9GKb: // global
           call _c9GIq(R1) args: 0, res: 0, upd: 0;
       c9GIt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GI4: // global
           I64[Sp + 8] = block_c9GI2_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GKa; else goto c9GI5;
       u9GKa: // global
           call _c9GI2(R1) args: 0, res: 0, upd: 0;
       c9GI5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GHC: // global
           I64[Sp + 8] = block_c9GHA_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GK9; else goto c9GHD;
       u9GK9: // global
           call _c9GHA(R1) args: 0, res: 0, upd: 0;
       c9GHD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GH6: // global
           I64[Sp + 8] = block_c9GH4_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GK8; else goto c9GH7;
       u9GK8: // global
           call _c9GH4(R1) args: 0, res: 0, upd: 0;
       c9GH7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GGW: // global
           I64[Sp + 8] = block_c9GGT_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GK7; else goto c9GGX;
       u9GK7: // global
           call _c9GGT() args: 0, res: 0, upd: 0;
       c9GGX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GIK() //  [R1]
         { info_tbl: [(c9GIK,
                       label: block_c9GIK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GIK: // global
           if (R1 & 7 == 6) goto u9GJD; else goto u9GJE;
       u9GJD: // global
           Sp = Sp + 8;
           call _c9GJg() args: 0, res: 0, upd: 0;
       u9GJE: // global
           Sp = Sp + 8;
           call _c9GJc() args: 0, res: 0, upd: 0;
     }
 },
 _c9GIq() //  [R1]
         { info_tbl: [(c9GIq,
                       label: block_c9GIq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GIq: // global
           _c9GJl::P64 = R1 & 7;
           if (_c9GJl::P64 != 5) goto u9GJx; else goto u9GJF;
       u9GJx: // global
           if (_c9GJl::P64 != 6) goto u9GJH; else goto u9GJG;
       u9GJH: // global
           Sp = Sp + 8;
           call _c9GJc() args: 0, res: 0, upd: 0;
       u9GJG: // global
           Sp = Sp + 8;
           goto u9GKl;
       u9GJF: // global
           Sp = Sp + 8;
           goto u9GKl;
       u9GKl: // global
           call _c9GJg() args: 0, res: 0, upd: 0;
     }
 },
 _c9GI2() //  [R1]
         { info_tbl: [(c9GI2,
                       label: block_c9GI2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GI2: // global
           _c9GJm::P64 = R1 & 7;
           if (_c9GJm::P64 < 4) goto u9GJI; else goto u9GJw;
       u9GJI: // global
           Sp = Sp + 8;
           call _c9GJc() args: 0, res: 0, upd: 0;
       u9GJw: // global
           if (_c9GJm::P64 != 5) goto u9GJK; else goto u9GJK;
       u9GJK: // global
           Sp = Sp + 8;
           call _c9GJg() args: 0, res: 0, upd: 0;
     }
 },
 _c9GHA() //  [R1]
         { info_tbl: [(c9GHA,
                       label: block_c9GHA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GHA: // global
           _c9GJn::P64 = R1 & 7;
           if (_c9GJn::P64 < 6) goto u9GJu; else goto u9GJL;
       u9GJu: // global
           if (_c9GJn::P64 < 3) goto u9GJM; else goto u9GJv;
       u9GJM: // global
           Sp = Sp + 8;
           call _c9GJc() args: 0, res: 0, upd: 0;
       u9GJv: // global
           if (_c9GJn::P64 != 4) goto u9GJO; else goto u9GJO;
       u9GJO: // global
           Sp = Sp + 8;
           goto u9GKh;
       u9GJL: // global
           Sp = Sp + 8;
           goto u9GKh;
       u9GKh: // global
           call _c9GJg() args: 0, res: 0, upd: 0;
     }
 },
 _c9GH4() //  [R1]
         { info_tbl: [(c9GH4,
                       label: block_c9GH4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GH4: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9GJP;
               case 2, 3, 4, 5, 6 : goto u9GJU;
           }
       u9GJU: // global
           Sp = Sp + 8;
           call _c9GJg() args: 0, res: 0, upd: 0;
       u9GJP: // global
           Sp = Sp + 8;
           call _c9GJc() args: 0, res: 0, upd: 0;
     }
 },
 _c9GGT() //  []
         { info_tbl: [(c9GGT,
                       label: block_c9GGT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GGT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GJ4() //  [R1]
         { info_tbl: [(c9GJ4,
                       label: block_c9GJ4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GJ4: // global
           if (R1 & 7 == 4) goto u9GJV; else goto u9GJW;
       u9GJV: // global
           Sp = Sp + 8;
           call _c9GJg() args: 0, res: 0, upd: 0;
       u9GJW: // global
           Sp = Sp + 8;
           call _c9GJc() args: 0, res: 0, upd: 0;
     }
 },
 _c9GJg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GJg: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GJc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GJc: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.605094788 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmax_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c9GKE,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GKE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9GKF; else goto c9GKG;
       c9GKF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GKG: // global
           I64[Sp - 16] = block_c9GKv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9GOj; else goto c9GKw;
       u9GOj: // global
           call _c9GKv(R1) args: 0, res: 0, upd: 0;
       c9GKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GKv() //  [R1]
         { info_tbl: [(c9GKv,
                       label: block_c9GKv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GKv: // global
           _s9FAE::P64 = P64[Sp + 8];
           _c9GKD::P64 = R1 & 7;
           if (_c9GKD::P64 < 3) goto u9GNN; else goto u9GNO;
       u9GNN: // global
           if (_c9GKD::P64 < 2) goto c9GKz; else goto c9GKA;
       c9GKz: // global
           R1 = _s9FAE::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9GKA: // global
           I64[Sp + 8] = block_c9GKM_info;
           R1 = _s9FAE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GOg; else goto c9GKO;
       u9GOg: // global
           call _c9GKM(R1) args: 0, res: 0, upd: 0;
       c9GKO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9GNO: // global
           if (_c9GKD::P64 < 4) goto c9GKB; else goto c9GKC;
       c9GKB: // global
           I64[Sp - 8] = block_c9GL5_info;
           _s9FAF::P64 = R1;
           _s9FAI::P64 = P64[R1 + 5];
           R1 = _s9FAE::P64;
           P64[Sp] = _s9FAI::P64;
           P64[Sp + 8] = _s9FAF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9GOh; else goto c9GL7;
       u9GOh: // global
           call _c9GL5(R1) args: 0, res: 0, upd: 0;
       c9GL7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GKC: // global
           I64[Sp + 8] = block_c9GNy_info;
           R1 = _s9FAE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GOi; else goto c9GNA;
       u9GOi: // global
           call _c9GNy() args: 0, res: 0, upd: 0;
       c9GNA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GKM() //  [R1]
         { info_tbl: [(c9GKM,
                       label: block_c9GKM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GKM: // global
           _c9GNM::P64 = R1 & 7;
           if (_c9GNM::P64 == 3) goto c9GKY; else goto u9GNP;
       c9GKY: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9GNP: // global
           if (_c9GNM::P64 != 4) goto c9GKU; else goto u9GNV;
       c9GKU: // global
           R1 = GHC.Conc.Sync.ThreadFinished_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9GNV: // global
           Sp = Sp + 8;
           call _c9GNv() args: 0, res: 0, upd: 0;
     }
 },
 _c9GL5() //  [R1]
         { info_tbl: [(c9GL5,
                       label: block_c9GL5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GL5: // global
           _c9GNF::P64 = R1 & 7;
           if (_c9GNF::P64 == 3) goto c9GLi; else goto u9GNQ;
       c9GLi: // global
           I64[Sp - 8] = block_c9GLg_info;
           _s9FAJ::P64 = R1;
           _s9FAK::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9FAK::P64;
           P64[Sp + 8] = _s9FAJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9GOl; else goto c9GLj;
       u9GOl: // global
           call _c9GLg(R1) args: 0, res: 0, upd: 0;
       c9GLj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9GNQ: // global
           if (_c9GNF::P64 != 4) goto u9GNX; else goto u9GNW;
       u9GNX: // global
           Sp = Sp + 16;
           call _c9GNn() args: 0, res: 0, upd: 0;
       u9GNW: // global
           Sp = Sp + 24;
           call _c9GNv() args: 0, res: 0, upd: 0;
     }
 },
 _c9GLg() //  [R1]
         { info_tbl: [(c9GLg,
                       label: block_c9GLg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GLg: // global
           _s9FAK::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9GLq;
               case 2 : goto c9GLA;
               case 3 : goto c9GM6;
               case 4 : goto c9GMy;
               case 5 : goto c9GMW;
               case 6 : goto c9GNg;
           }
       c9GNg: // global
           I64[Sp + 8] = block_c9GNe_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GOt; else goto c9GNh;
       u9GOt: // global
           call _c9GNe(R1) args: 0, res: 0, upd: 0;
       c9GNh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GMW: // global
           I64[Sp + 8] = block_c9GMU_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GOs; else goto c9GMX;
       u9GOs: // global
           call _c9GMU(R1) args: 0, res: 0, upd: 0;
       c9GMX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GMy: // global
           I64[Sp + 8] = block_c9GMw_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GOr; else goto c9GMz;
       u9GOr: // global
           call _c9GMw(R1) args: 0, res: 0, upd: 0;
       c9GMz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GM6: // global
           I64[Sp + 8] = block_c9GM4_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GOq; else goto c9GM7;
       u9GOq: // global
           call _c9GM4(R1) args: 0, res: 0, upd: 0;
       c9GM7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GLA: // global
           I64[Sp + 8] = block_c9GLy_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GOp; else goto c9GLB;
       u9GOp: // global
           call _c9GLy(R1) args: 0, res: 0, upd: 0;
       c9GLB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GLq: // global
           I64[Sp + 8] = block_c9GLn_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GOo; else goto c9GLr;
       u9GOo: // global
           call _c9GLn() args: 0, res: 0, upd: 0;
       c9GLr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GNe() //  [R1]
         { info_tbl: [(c9GNe,
                       label: block_c9GNe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GNe: // global
           if (R1 & 7 == 6) goto u9GNY; else goto u9GNZ;
       u9GNY: // global
           Sp = Sp + 8;
           call _c9GNr() args: 0, res: 0, upd: 0;
       u9GNZ: // global
           Sp = Sp + 16;
           call _c9GNn() args: 0, res: 0, upd: 0;
     }
 },
 _c9GMU() //  [R1]
         { info_tbl: [(c9GMU,
                       label: block_c9GMU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GMU: // global
           _c9GNI::P64 = R1 & 7;
           if (_c9GNI::P64 != 5) goto u9GNU; else goto u9GO0;
       u9GNU: // global
           if (_c9GNI::P64 != 6) goto u9GO2; else goto u9GO1;
       u9GO2: // global
           Sp = Sp + 16;
           call _c9GNn() args: 0, res: 0, upd: 0;
       u9GO1: // global
           Sp = Sp + 8;
           goto u9GOC;
       u9GO0: // global
           Sp = Sp + 8;
           goto u9GOC;
       u9GOC: // global
           call _c9GNr() args: 0, res: 0, upd: 0;
     }
 },
 _c9GMw() //  [R1]
         { info_tbl: [(c9GMw,
                       label: block_c9GMw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GMw: // global
           _c9GNJ::P64 = R1 & 7;
           if (_c9GNJ::P64 < 4) goto u9GO3; else goto u9GNT;
       u9GO3: // global
           Sp = Sp + 16;
           call _c9GNn() args: 0, res: 0, upd: 0;
       u9GNT: // global
           if (_c9GNJ::P64 != 5) goto u9GO5; else goto u9GO5;
       u9GO5: // global
           Sp = Sp + 8;
           call _c9GNr() args: 0, res: 0, upd: 0;
     }
 },
 _c9GM4() //  [R1]
         { info_tbl: [(c9GM4,
                       label: block_c9GM4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GM4: // global
           _c9GNK::P64 = R1 & 7;
           if (_c9GNK::P64 < 6) goto u9GNR; else goto u9GO6;
       u9GNR: // global
           if (_c9GNK::P64 < 3) goto u9GO7; else goto u9GNS;
       u9GO7: // global
           Sp = Sp + 16;
           call _c9GNn() args: 0, res: 0, upd: 0;
       u9GNS: // global
           if (_c9GNK::P64 != 4) goto u9GO9; else goto u9GO9;
       u9GO9: // global
           Sp = Sp + 8;
           goto u9GOy;
       u9GO6: // global
           Sp = Sp + 8;
           goto u9GOy;
       u9GOy: // global
           call _c9GNr() args: 0, res: 0, upd: 0;
     }
 },
 _c9GLy() //  [R1]
         { info_tbl: [(c9GLy,
                       label: block_c9GLy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GLy: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9GOa;
               case 2, 3, 4, 5, 6 : goto u9GOf;
           }
       u9GOf: // global
           Sp = Sp + 8;
           call _c9GNr() args: 0, res: 0, upd: 0;
       u9GOa: // global
           Sp = Sp + 16;
           call _c9GNn() args: 0, res: 0, upd: 0;
     }
 },
 _c9GNr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GNr: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GLn() //  []
         { info_tbl: [(c9GLn,
                       label: block_c9GLn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GLn: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GNn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GNn: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GNv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GNv: // global
           R1 = GHC.Conc.Sync.ThreadDied_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GNy() //  []
         { info_tbl: [(c9GNy,
                       label: block_c9GNy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GNy: // global
           R1 = GHC.Conc.Sync.ThreadDied_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.610933464 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmin_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c9GOT,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GOT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9GOU; else goto c9GOV;
       c9GOU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GOV: // global
           I64[Sp - 16] = block_c9GOK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9GSB; else goto c9GOL;
       u9GSB: // global
           call _c9GOK(R1) args: 0, res: 0, upd: 0;
       c9GOL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GOK() //  [R1]
         { info_tbl: [(c9GOK,
                       label: block_c9GOK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GOK: // global
           _s9FAU::P64 = P64[Sp + 8];
           _c9GOS::P64 = R1 & 7;
           if (_c9GOS::P64 < 3) goto u9GS6; else goto u9GS7;
       u9GS6: // global
           if (_c9GOS::P64 < 2) goto c9GOO; else goto c9GOP;
       c9GOO: // global
           I64[Sp + 8] = block_c9GOY_info;
           R1 = _s9FAU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GSy; else goto c9GP0;
       u9GSy: // global
           call _c9GOY() args: 0, res: 0, upd: 0;
       c9GP0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GOP: // global
           I64[Sp + 8] = block_c9GP7_info;
           R1 = _s9FAU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GSz; else goto c9GP9;
       u9GSz: // global
           call _c9GP7(R1) args: 0, res: 0, upd: 0;
       c9GP9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9GS7: // global
           if (_c9GOS::P64 < 4) goto c9GOQ; else goto c9GOR;
       c9GOQ: // global
           I64[Sp - 8] = block_c9GPu_info;
           _s9FAV::P64 = R1;
           _s9FAZ::P64 = P64[R1 + 5];
           R1 = _s9FAU::P64;
           P64[Sp] = _s9FAZ::P64;
           P64[Sp + 8] = _s9FAV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9GSA; else goto c9GPw;
       u9GSA: // global
           call _c9GPu(R1) args: 0, res: 0, upd: 0;
       c9GPw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GOR: // global
           R1 = _s9FAU::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GOY() //  []
         { info_tbl: [(c9GOY,
                       label: block_c9GOY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GOY: // global
           R1 = GHC.Conc.Sync.ThreadRunning_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GP7() //  [R1]
         { info_tbl: [(c9GP7,
                       label: block_c9GP7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GP7: // global
           _c9GS5::P64 = R1 & 7;
           if (_c9GS5::P64 < 2) goto c9GPf; else goto u9GS8;
       c9GPf: // global
           R1 = GHC.Conc.Sync.ThreadRunning_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9GS8: // global
           if (_c9GS5::P64 != 3) goto c9GPr; else goto c9GPr;
       c9GPr: // global
           R1 = GHC.Conc.Sync.ThreadFinished_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GPu() //  [R1]
         { info_tbl: [(c9GPu,
                       label: block_c9GPu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GPu: // global
           _c9GRY::P64 = R1 & 7;
           if (_c9GRY::P64 == 3) goto c9GPH; else goto u9GS9;
       c9GPH: // global
           I64[Sp - 8] = block_c9GPF_info;
           _s9FB0::P64 = R1;
           _s9FB1::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9FB1::P64;
           P64[Sp + 8] = _s9FB0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9GSC; else goto c9GPI;
       u9GSC: // global
           call _c9GPF(R1) args: 0, res: 0, upd: 0;
       c9GPI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9GS9: // global
           if (_c9GRY::P64 == 4) goto u9GSe; else goto u9GSf;
       u9GSe: // global
           Sp = Sp + 16;
           call _c9GRU() args: 0, res: 0, upd: 0;
       u9GSf: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c9GRM() args: 0, res: 0, upd: 0;
     }
 },
 _c9GPF() //  [R1]
         { info_tbl: [(c9GPF,
                       label: block_c9GPF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GPF: // global
           _s9FB1::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9GPP;
               case 2 : goto c9GPZ;
               case 3 : goto c9GQv;
               case 4 : goto c9GQX;
               case 5 : goto c9GRl;
               case 6 : goto c9GRF;
           }
       c9GRF: // global
           I64[Sp + 8] = block_c9GRD_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GSK; else goto c9GRG;
       u9GSK: // global
           call _c9GRD(R1) args: 0, res: 0, upd: 0;
       c9GRG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GRl: // global
           I64[Sp + 8] = block_c9GRj_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GSJ; else goto c9GRm;
       u9GSJ: // global
           call _c9GRj(R1) args: 0, res: 0, upd: 0;
       c9GRm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GQX: // global
           I64[Sp + 8] = block_c9GQV_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GSI; else goto c9GQY;
       u9GSI: // global
           call _c9GQV(R1) args: 0, res: 0, upd: 0;
       c9GQY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GQv: // global
           I64[Sp + 8] = block_c9GQt_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GSH; else goto c9GQw;
       u9GSH: // global
           call _c9GQt(R1) args: 0, res: 0, upd: 0;
       c9GQw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GPZ: // global
           I64[Sp + 8] = block_c9GPX_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9GSG; else goto c9GQ0;
       u9GSG: // global
           call _c9GPX(R1) args: 0, res: 0, upd: 0;
       c9GQ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9GPP: // global
           I64[Sp + 16] = block_c9GPM_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u9GSF; else goto c9GPQ;
       u9GSF: // global
           call _c9GPM() args: 0, res: 0, upd: 0;
       c9GPQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GRD() //  [R1]
         { info_tbl: [(c9GRD,
                       label: block_c9GRD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GRD: // global
           if (R1 & 7 == 6) goto u9GSg; else goto u9GSh;
       u9GSg: // global
           Sp = Sp + 16;
           call _c9GRU() args: 0, res: 0, upd: 0;
       u9GSh: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9GRM() args: 0, res: 0, upd: 0;
     }
 },
 _c9GRj() //  [R1]
         { info_tbl: [(c9GRj,
                       label: block_c9GRj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GRj: // global
           _c9GS1::P64 = R1 & 7;
           if (_c9GS1::P64 != 5) goto u9GSd; else goto u9GSi;
       u9GSd: // global
           if (_c9GS1::P64 != 6) goto u9GSk; else goto u9GSj;
       u9GSk: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9GRM() args: 0, res: 0, upd: 0;
       u9GSj: // global
           Sp = Sp + 16;
           goto u9GST;
       u9GSi: // global
           Sp = Sp + 16;
           goto u9GST;
       u9GST: // global
           call _c9GRU() args: 0, res: 0, upd: 0;
     }
 },
 _c9GQV() //  [R1]
         { info_tbl: [(c9GQV,
                       label: block_c9GQV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GQV: // global
           _c9GS2::P64 = R1 & 7;
           if (_c9GS2::P64 < 4) goto u9GSl; else goto u9GSc;
       u9GSl: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9GRM() args: 0, res: 0, upd: 0;
       u9GSc: // global
           if (_c9GS2::P64 != 5) goto u9GSn; else goto u9GSn;
       u9GSn: // global
           Sp = Sp + 16;
           call _c9GRU() args: 0, res: 0, upd: 0;
     }
 },
 _c9GQt() //  [R1]
         { info_tbl: [(c9GQt,
                       label: block_c9GQt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GQt: // global
           _c9GS3::P64 = R1 & 7;
           if (_c9GS3::P64 < 6) goto u9GSa; else goto u9GSo;
       u9GSa: // global
           if (_c9GS3::P64 < 3) goto u9GSp; else goto u9GSb;
       u9GSp: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9GRM() args: 0, res: 0, upd: 0;
       u9GSb: // global
           if (_c9GS3::P64 != 4) goto u9GSr; else goto u9GSr;
       u9GSr: // global
           Sp = Sp + 16;
           goto u9GSP;
       u9GSo: // global
           Sp = Sp + 16;
           goto u9GSP;
       u9GSP: // global
           call _c9GRU() args: 0, res: 0, upd: 0;
     }
 },
 _c9GPX() //  [R1]
         { info_tbl: [(c9GPX,
                       label: block_c9GPX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GPX: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9GSs;
               case 2, 3, 4, 5, 6 : goto u9GSx;
           }
       u9GSx: // global
           Sp = Sp + 16;
           call _c9GRU() args: 0, res: 0, upd: 0;
       u9GSs: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9GRM() args: 0, res: 0, upd: 0;
     }
 },
 _c9GPM() //  []
         { info_tbl: [(c9GPM,
                       label: block_c9GPM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GPM: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GRU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GRU: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9GRM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GRM: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.615008711 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Conc.Sync.$fEqThreadStatus_closure+1;
         const GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.615634259 UTC

[section ""cstring" . GHC.Conc.Sync.$trModule4_bytes" {
     GHC.Conc.Sync.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.616183796 UTC

[section ""data" . GHC.Conc.Sync.$trModule3_closure" {
     GHC.Conc.Sync.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.616764545 UTC

[section ""cstring" . GHC.Conc.Sync.$trModule2_bytes" {
     GHC.Conc.Sync.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,83,121,110,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.61738404 UTC

[section ""data" . GHC.Conc.Sync.$trModule1_closure" {
     GHC.Conc.Sync.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.61795742 UTC

[section ""data" . GHC.Conc.Sync.$trModule_closure" {
     GHC.Conc.Sync.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.Sync.$trModule3_closure+1;
         const GHC.Conc.Sync.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.618547181 UTC

[section ""data" . $krep_r9FuN_closure" {
     $krep_r9FuN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc'LiftedRep_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.619156606 UTC

[section ""data" . $krep1_r9FuO_closure" {
     $krep1_r9FuO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRuntimeRep_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.619748872 UTC

[section ""data" . $krep2_r9FuP_closure" {
     $krep2_r9FuP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRealWorld_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.62033315 UTC

[section ""data" . $krep3_r9FuQ_closure" {
     $krep3_r9FuQ_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.620900672 UTC

[section ""data" . $krep4_r9FuR_closure" {
     $krep4_r9FuR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcThreadId#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.621486485 UTC

[section ""data" . $krep5_r9FuS_closure" {
     $krep5_r9FuS_closure:
         const :_con_info;
         const $krep3_r9FuQ_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.622063306 UTC

[section ""data" . $krep6_r9FuT_closure" {
     $krep6_r9FuT_closure:
         const :_con_info;
         const $krep2_r9FuP_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.622621163 UTC

[section ""data" . $krep7_r9FuU_closure" {
     $krep7_r9FuU_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcTVar#_closure;
         const $krep6_r9FuT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.623228768 UTC

[section ""data" . $krep8_r9FuV_closure" {
     $krep8_r9FuV_closure:
         const :_con_info;
         const $krep2_r9FuP_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.623775005 UTC

[section ""data" . $krep9_r9FuW_closure" {
     $krep9_r9FuW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcState#_closure;
         const $krep8_r9FuV_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.624350971 UTC

[section ""data" . $krep10_r9FuX_closure" {
     $krep10_r9FuX_closure:
         const :_con_info;
         const $krep1_r9FuO_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.62496015 UTC

[section ""data" . $krep11_r9FuY_closure" {
     $krep11_r9FuY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc'[]_closure;
         const $krep10_r9FuX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.625497118 UTC

[section ""data" . $krep12_r9FuZ_closure" {
     $krep12_r9FuZ_closure:
         const :_con_info;
         const $krep11_r9FuY_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.626047012 UTC

[section ""data" . $krep13_r9Fv0_closure" {
     $krep13_r9Fv0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc'TupleRep_closure;
         const $krep12_r9FuZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.626620079 UTC

[section ""data" . $krep14_r9Fv1_closure" {
     $krep14_r9Fv1_closure:
         const :_con_info;
         const $krep9_r9FuW_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.627231051 UTC

[section ""data" . $krep15_r9Fv2_closure" {
     $krep15_r9Fv2_closure:
         const :_con_info;
         const $krep_r9FuN_closure+1;
         const $krep14_r9Fv1_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.627828421 UTC

[section ""data" . $krep16_r9Fv3_closure" {
     $krep16_r9Fv3_closure:
         const :_con_info;
         const $krep13_r9Fv0_closure+1;
         const $krep15_r9Fv2_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.628415257 UTC

[section ""data" . $krep17_r9Fv4_closure" {
     $krep17_r9Fv4_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc(#,#)_closure;
         const $krep16_r9Fv3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.628982568 UTC

[section ""data" . $krep18_r9Fv5_closure" {
     $krep18_r9Fv5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r9FuW_closure+1;
         const $krep17_r9Fv4_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.629563014 UTC

[section ""cstring" . GHC.Conc.Sync.$tcThreadId2_bytes" {
     GHC.Conc.Sync.$tcThreadId2_bytes:
         I8[] [84,104,114,101,97,100,73,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.630126837 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadId1_closure" {
     GHC.Conc.Sync.$tcThreadId1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcThreadId2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.630710436 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadId_closure" {
     GHC.Conc.Sync.$tcThreadId_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcThreadId1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16775948407395805744;
         const 12520674293648100702;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.631313789 UTC

[section ""data" . $krep19_r9Fv6_closure" {
     $krep19_r9Fv6_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcThreadId_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.631906314 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadId1_closure" {
     GHC.Conc.Sync.$tc'ThreadId1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r9FuR_closure+1;
         const $krep19_r9Fv6_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.632477918 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadId3_bytes" {
     GHC.Conc.Sync.$tc'ThreadId3_bytes:
         I8[] [39,84,104,114,101,97,100,73,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.633041011 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadId2_closure" {
     GHC.Conc.Sync.$tc'ThreadId2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadId3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.633642204 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadId_closure" {
     GHC.Conc.Sync.$tc'ThreadId_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadId2_closure+1;
         const GHC.Conc.Sync.$tc'ThreadId1_closure+4;
         const 18342150043682338300;
         const 5104860271509165481;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.634217472 UTC

[section ""cstring" . GHC.Conc.Sync.$tcBlockReason2_bytes" {
     GHC.Conc.Sync.$tcBlockReason2_bytes:
         I8[] [66,108,111,99,107,82,101,97,115,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.634705152 UTC

[section ""data" . GHC.Conc.Sync.$tcBlockReason1_closure" {
     GHC.Conc.Sync.$tcBlockReason1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcBlockReason2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.635259808 UTC

[section ""data" . GHC.Conc.Sync.$tcBlockReason_closure" {
     GHC.Conc.Sync.$tcBlockReason_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcBlockReason1_closure+1;
         const GHC.Types.krep$*_closure;
         const 13301038780413995570;
         const 11021250300446969031;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.635848185 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcBlockReason_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.636405346 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnMVar2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnMVar2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.636944715 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnMVar1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnMVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.639151355 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnMVar_closure" {
     GHC.Conc.Sync.$tc'BlockedOnMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnMVar1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 6633002816895506850;
         const 13520604374172074732;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.639774458 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnBlackHole3_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole3_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,66,108,97,99,107,72,111,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.640366517 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnBlackHole2_closure" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.64093305 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnBlackHole_closure" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole2_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 9499731398899925739;
         const 7296688042620961692;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.641555205 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnException2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnException2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.642096141 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnException1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnException1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnException2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.642637689 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnException_closure" {
     GHC.Conc.Sync.$tc'BlockedOnException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnException1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 16834505563200403543;
         const 10899729493106152581;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.643246525 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnSTM2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnSTM2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.643777828 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnSTM1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnSTM1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnSTM2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.644312324 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnSTM_closure" {
     GHC.Conc.Sync.$tc'BlockedOnSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnSTM1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 1161208048218837616;
         const 14246412223428266787;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.644903604 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnForeignCall2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnForeignCall2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,70,111,114,101,105,103,110,67,97,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.646059367 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnForeignCall1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnForeignCall1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnForeignCall2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.646627264 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnForeignCall_closure" {
     GHC.Conc.Sync.$tc'BlockedOnForeignCall_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnForeignCall1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 7408412473094687054;
         const 5512662453084487661;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.64716535 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnOther2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnOther2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,79,116,104,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.647666386 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnOther1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnOther1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnOther2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.648257247 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnOther_closure" {
     GHC.Conc.Sync.$tc'BlockedOnOther_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnOther1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 12822899422417308746;
         const 1265626399802742388;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.648866825 UTC

[section ""cstring" . GHC.Conc.Sync.$tcThreadStatus2_bytes" {
     GHC.Conc.Sync.$tcThreadStatus2_bytes:
         I8[] [84,104,114,101,97,100,83,116,97,116,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.649405873 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadStatus1_closure" {
     GHC.Conc.Sync.$tcThreadStatus1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcThreadStatus2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.650009347 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadStatus_closure" {
     GHC.Conc.Sync.$tcThreadStatus_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcThreadStatus1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16437204929171641638;
         const 3495092226815585861;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.650614954 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadDied1_closure" {
     GHC.Conc.Sync.$tc'ThreadDied1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcThreadStatus_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.651185833 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadRunning2_bytes" {
     GHC.Conc.Sync.$tc'ThreadRunning2_bytes:
         I8[] [39,84,104,114,101,97,100,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.651721715 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadRunning1_closure" {
     GHC.Conc.Sync.$tc'ThreadRunning1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadRunning2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.652266924 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadRunning_closure" {
     GHC.Conc.Sync.$tc'ThreadRunning_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadRunning1_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 1667122312602609882;
         const 13647871799576313560;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.652805964 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadFinished2_bytes" {
     GHC.Conc.Sync.$tc'ThreadFinished2_bytes:
         I8[] [39,84,104,114,101,97,100,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.65388408 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadFinished1_closure" {
     GHC.Conc.Sync.$tc'ThreadFinished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadFinished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.654388185 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadFinished_closure" {
     GHC.Conc.Sync.$tc'ThreadFinished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadFinished1_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 2441107603776884109;
         const 12730966154693836607;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.654953905 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadDied3_bytes" {
     GHC.Conc.Sync.$tc'ThreadDied3_bytes:
         I8[] [39,84,104,114,101,97,100,68,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.655489794 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadDied2_closure" {
     GHC.Conc.Sync.$tc'ThreadDied2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadDied3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.656043755 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadDied_closure" {
     GHC.Conc.Sync.$tc'ThreadDied_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied2_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 9513974555658789847;
         const 4757719484357493227;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.656647925 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadBlocked1_closure" {
     GHC.Conc.Sync.$tc'ThreadBlocked1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.657201994 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadBlocked3_bytes" {
     GHC.Conc.Sync.$tc'ThreadBlocked3_bytes:
         I8[] [39,84,104,114,101,97,100,66,108,111,99,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.657775524 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadBlocked2_closure" {
     GHC.Conc.Sync.$tc'ThreadBlocked2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadBlocked3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.658334726 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadBlocked_closure" {
     GHC.Conc.Sync.$tc'ThreadBlocked_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadBlocked2_closure+1;
         const GHC.Conc.Sync.$tc'ThreadBlocked1_closure+4;
         const 1896650886570328403;
         const 13390928353603149841;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.65891719 UTC

[section ""cstring" . GHC.Conc.Sync.$tcPrimMVar2_bytes" {
     GHC.Conc.Sync.$tcPrimMVar2_bytes:
         I8[] [80,114,105,109,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.659429481 UTC

[section ""data" . GHC.Conc.Sync.$tcPrimMVar1_closure" {
     GHC.Conc.Sync.$tcPrimMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcPrimMVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.659993801 UTC

[section ""data" . GHC.Conc.Sync.$tcPrimMVar_closure" {
     GHC.Conc.Sync.$tcPrimMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcPrimMVar1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9965391380168186507;
         const 18322737771689556223;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.660597697 UTC

[section ""cstring" . GHC.Conc.Sync.$tcSTM2_bytes" {
     GHC.Conc.Sync.$tcSTM2_bytes:
         I8[] [83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.661176036 UTC

[section ""data" . GHC.Conc.Sync.$tcSTM1_closure" {
     GHC.Conc.Sync.$tcSTM1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcSTM2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.662001415 UTC

[section ""data" . GHC.Conc.Sync.$tcSTM_closure" {
     GHC.Conc.Sync.$tcSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcSTM1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 2004856025729794332;
         const 14974623362753764267;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.662558475 UTC

[section ""data" . $krep20_r9Fv7_closure" {
     $krep20_r9Fv7_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcSTM_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.663134387 UTC

[section ""data" . GHC.Conc.Sync.$tc'STM1_closure" {
     GHC.Conc.Sync.$tc'STM1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep18_r9Fv5_closure+4;
         const $krep20_r9Fv7_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.663735199 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'STM3_bytes" {
     GHC.Conc.Sync.$tc'STM3_bytes:
         I8[] [39,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.664267127 UTC

[section ""data" . GHC.Conc.Sync.$tc'STM2_closure" {
     GHC.Conc.Sync.$tc'STM2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'STM3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.665690918 UTC

[section ""data" . GHC.Conc.Sync.$tc'STM_closure" {
     GHC.Conc.Sync.$tc'STM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'STM2_closure+1;
         const GHC.Conc.Sync.$tc'STM1_closure+4;
         const 11288073744523536973;
         const 9767688212531311940;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.66629421 UTC

[section ""cstring" . GHC.Conc.Sync.$tcTVar2_bytes" {
     GHC.Conc.Sync.$tcTVar2_bytes:
         I8[] [84,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.666825447 UTC

[section ""data" . GHC.Conc.Sync.$tcTVar1_closure" {
     GHC.Conc.Sync.$tcTVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcTVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.667456658 UTC

[section ""data" . GHC.Conc.Sync.$tcTVar_closure" {
     GHC.Conc.Sync.$tcTVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcTVar1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13084572405727191592;
         const 5232564955606145236;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.668054625 UTC

[section ""data" . $krep21_r9Fv8_closure" {
     $krep21_r9Fv8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcTVar_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.668620669 UTC

[section ""data" . GHC.Conc.Sync.$tc'TVar1_closure" {
     GHC.Conc.Sync.$tc'TVar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r9FuU_closure+1;
         const $krep21_r9Fv8_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.669205073 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'TVar3_bytes" {
     GHC.Conc.Sync.$tc'TVar3_bytes:
         I8[] [39,84,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.669812946 UTC

[section ""data" . GHC.Conc.Sync.$tc'TVar2_closure" {
     GHC.Conc.Sync.$tc'TVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'TVar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.670363402 UTC

[section ""data" . GHC.Conc.Sync.$tc'TVar_closure" {
     GHC.Conc.Sync.$tc'TVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'TVar2_closure+1;
         const GHC.Conc.Sync.$tc'TVar1_closure+4;
         const 9463269625853265574;
         const 3517068532143837766;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.670938888 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadId2_bytes" {
     GHC.Conc.Sync.$fShowThreadId2_bytes:
         I8[] [84,104,114,101,97,100,73,100,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.6726795 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure" {
     GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure:
         const GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_info;
 },
 x_s9FBb_entry() //  [R1]
         { info_tbl: [(c9GT8,
                       label: x_s9FBb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GT8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9GTh; else goto c9GTi;
       c9GTh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9GTi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9GT5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9GTm; else goto c9GT6;
       u9GTm: // global
           call _c9GT5(R1) args: 0, res: 0, upd: 0;
       c9GT6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9GT5() //  [R1]
         { info_tbl: [(c9GT5,
                       label: block_c9GT5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GT5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9GTl; else goto c9GTk;
       c9GTl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9GTk: // global
           (_s9FBh::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadId(P64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FBh::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FBr_entry() //  [R1]
         { info_tbl: [(c9GTz,
                       label: sat_s9FBr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GTz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9GTK; else goto c9GTL;
       c9GTK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9GTL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9GTw_info;
           _s9FB9::P64 = P64[R1 + 16];
           _s9FBj::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s9FB9::P64;
           P64[Sp - 24] = _s9FBj::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9GTS; else goto c9GTx;
       u9GTS: // global
           call _c9GTw(R1) args: 0, res: 0, upd: 0;
       c9GTx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9GTw() //  [R1]
         { info_tbl: [(c9GTw,
                       label: block_c9GTw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GTw: // global
           I64[Sp] = block_c9GTC_info;
           _s9FBl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s9FBl::I64;
           if (R1 & 7 != 0) goto u9GTR; else goto c9GTD;
       u9GTR: // global
           call _c9GTC(R1) args: 0, res: 0, upd: 0;
       c9GTD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9GTC() //  [R1]
         { info_tbl: [(c9GTC,
                       label: block_c9GTC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GTC: // global
           _s9FBj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9GTH_info;
           R4 = _s9FBj::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9GTH() //  [R1, R2]
         { info_tbl: [(c9GTH,
                       label: block_c9GTH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GTH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9GTQ; else goto c9GTP;
       c9GTQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9GTP: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FBs_entry() //  [R1, R2]
         { info_tbl: [(c9GTT,
                       label: sat_s9FBs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GTT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9GTX; else goto c9GTW;
       c9GTX: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9GTW: // global
           _s9FB9::P64 = P64[R1 + 7];
           _s9FBb::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FBr_info;
           P64[Hp - 16] = _s9FB9::P64;
           P64[Hp - 8] = _s9FBb::P64;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = GHC.Conc.Sync.$fShowThreadId2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c9GTY,
                       label: GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GTY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c9GU2; else goto c9GU1;
       c9GU2: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GU1: // global
           I64[Hp - 40] = x_s9FBb_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s9FBs_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.676104401 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_$cshow_closure" {
     GHC.Conc.Sync.$fShowThreadId_$cshow_closure:
         const GHC.Conc.Sync.$fShowThreadId_$cshow_info;
 },
 sat_s9FBE_entry() //  [R1]
         { info_tbl: [(c9GUe,
                       label: sat_s9FBE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GUe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9GUp; else goto c9GUq;
       c9GUp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9GUq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9GUb_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9GUv; else goto c9GUc;
       u9GUv: // global
           call _c9GUb(R1) args: 0, res: 0, upd: 0;
       c9GUc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9GUb() //  [R1]
         { info_tbl: [(c9GUb,
                       label: block_c9GUb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GUb: // global
           (_s9FBz::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadId(P64[R1 + 7]);
           I64[Sp] = block_c9GUm_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FBz::I64));
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9GUm() //  [R1, R2]
         { info_tbl: [(c9GUm,
                       label: block_c9GUm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GUm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9GUu; else goto c9GUt;
       c9GUu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9GUt: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$fShowThreadId_$cshow_entry() //  [R2]
         { info_tbl: [(c9GUw,
                       label: GHC.Conc.Sync.$fShowThreadId_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GUw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9GUA; else goto c9GUz;
       c9GUA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadId_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9GUz: // global
           I64[Hp - 16] = sat_s9FBE_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = GHC.Conc.Sync.$fShowThreadId2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.678536254 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId1_closure" {
     GHC.Conc.Sync.$fShowThreadId1_closure:
         const GHC.Conc.Sync.$fShowThreadId1_info;
 },
 x_s9FBG_entry() //  [R1]
         { info_tbl: [(c9GUM,
                       label: x_s9FBG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GUM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9GUV; else goto c9GUW;
       c9GUV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9GUW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9GUJ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9GV0; else goto c9GUK;
       u9GV0: // global
           call _c9GUJ(R1) args: 0, res: 0, upd: 0;
       c9GUK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9GUJ() //  [R1]
         { info_tbl: [(c9GUJ,
                       label: block_c9GUJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GUJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9GUZ; else goto c9GUY;
       c9GUZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9GUY: // global
           (_s9FBM::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadId(P64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FBM::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FBU_entry() //  [R1]
         { info_tbl: [(c9GVd,
                       label: sat_s9FBU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GVd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9GVj; else goto c9GVk;
       c9GVj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9GVk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c9GVa_info;
           _s9FBO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s9FBO::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9GVp; else goto c9GVb;
       u9GVp: // global
           call _c9GVa(R1) args: 0, res: 0, upd: 0;
       c9GVb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9GVa() //  [R1]
         { info_tbl: [(c9GVa,
                       label: block_c9GVa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GVa: // global
           _s9FBO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9GVg_info;
           R4 = _s9FBO::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9GVg() //  [R1, R2]
         { info_tbl: [(c9GVg,
                       label: block_c9GVg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GVg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9GVo; else goto c9GVn;
       c9GVo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9GVn: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FBV_entry() //  [R1, R2]
         { info_tbl: [(c9GVq,
                       label: sat_s9FBV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GVq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9GVu; else goto c9GVt;
       c9GVu: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9GVt: // global
           _s9FBG::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s9FBU_info;
           P64[Hp - 8] = _s9FBG::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = GHC.Conc.Sync.$fShowThreadId2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fShowThreadId1_entry() //  [R2]
         { info_tbl: [(c9GVv,
                       label: GHC.Conc.Sync.$fShowThreadId1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GVv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9GVz; else goto c9GVy;
       c9GVz: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadId1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9GVy: // global
           I64[Hp - 32] = x_s9FBG_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s9FBV_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.680916966 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_$cshowList_closure" {
     GHC.Conc.Sync.$fShowThreadId_$cshowList_closure:
         const GHC.Conc.Sync.$fShowThreadId_$cshowList_info;
 },
 GHC.Conc.Sync.$fShowThreadId_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c9GVE,
                       label: GHC.Conc.Sync.$fShowThreadId_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GVE: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$fShowThreadId1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.681626752 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_closure" {
     GHC.Conc.Sync.$fShowThreadId_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure+2;
         const GHC.Conc.Sync.$fShowThreadId_$cshow_closure+1;
         const GHC.Conc.Sync.$fShowThreadId_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.682272223 UTC

[section ""data" . reportHeapOverflow1_r9Fv9_closure" {
     reportHeapOverflow1_r9Fv9_closure:
         const reportHeapOverflow1_r9Fv9_info;
 },
 reportHeapOverflow1_r9Fv9_entry() //  []
         { info_tbl: [(c9GVM,
                       label: reportHeapOverflow1_r9Fv9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GVM: // global
           call "ccall" arg hints:  []  result hints:  [] reportHeapOverflow();
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.683065053 UTC

[section ""data" . GHC.Conc.Sync.reportHeapOverflow_closure" {
     GHC.Conc.Sync.reportHeapOverflow_closure:
         const GHC.Conc.Sync.reportHeapOverflow_info;
 },
 GHC.Conc.Sync.reportHeapOverflow_entry() //  []
         { info_tbl: [(c9GVT,
                       label: GHC.Conc.Sync.reportHeapOverflow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GVT: // global
           call reportHeapOverflow1_r9Fv9_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.684151574 UTC

[section ""data" . GHC.Conc.Sync.cmpThread_closure" {
     GHC.Conc.Sync.cmpThread_closure:
         const GHC.Conc.Sync.cmpThread_info;
 },
 GHC.Conc.Sync.cmpThread_entry() //  [R2, R3]
         { info_tbl: [(c9GW3,
                       label: GHC.Conc.Sync.cmpThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GW3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9GW7; else goto c9GW8;
       c9GW7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.cmpThread_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GW8: // global
           I64[Sp - 16] = block_c9GW0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9GWF; else goto c9GW1;
       u9GWF: // global
           call _c9GW0(R1) args: 0, res: 0, upd: 0;
       c9GW1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GW0() //  [R1]
         { info_tbl: [(c9GW0,
                       label: block_c9GW0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GW0: // global
           I64[Sp] = block_c9GW6_info;
           _s9FC5::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FC5::P64;
           if (R1 & 7 != 0) goto u9GWE; else goto c9GWa;
       u9GWE: // global
           call _c9GW6(R1) args: 0, res: 0, upd: 0;
       c9GWa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GW6() //  [R1]
         { info_tbl: [(c9GW6,
                       label: block_c9GW6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GW6: // global
           (_s9FCb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FCc::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FCb::I64));
           if (_s9FCc::I64 != (-1)) goto u9GWD; else goto c9GWt;
       u9GWD: // global
           if (_s9FCc::I64 != 0) goto c9GWn; else goto c9GWz;
       c9GWn: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9GWz: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9GWt: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.685923683 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadId_$c==_closure" {
     GHC.Conc.Sync.$fEqThreadId_$c==_closure:
         const GHC.Conc.Sync.$fEqThreadId_$c==_info;
 },
 GHC.Conc.Sync.$fEqThreadId_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9GWN,
                       label: GHC.Conc.Sync.$fEqThreadId_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GWN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9GWR; else goto c9GWS;
       c9GWR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadId_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GWS: // global
           I64[Sp - 16] = block_c9GWK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9GXi; else goto c9GWL;
       u9GXi: // global
           call _c9GWK(R1) args: 0, res: 0, upd: 0;
       c9GWL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GWK() //  [R1]
         { info_tbl: [(c9GWK,
                       label: block_c9GWK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GWK: // global
           I64[Sp] = block_c9GWQ_info;
           _s9FCg::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCg::P64;
           if (R1 & 7 != 0) goto u9GXh; else goto c9GWU;
       u9GXh: // global
           call _c9GWQ(R1) args: 0, res: 0, upd: 0;
       c9GWU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GWQ() //  [R1]
         { info_tbl: [(c9GWQ,
                       label: block_c9GWQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GWQ: // global
           (_s9FCm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9FCm::I64) == 0 :: W32) goto c9GXd; else goto c9GX7;
       c9GXd: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9GX7: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.687550753 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadId_$c/=_closure" {
     GHC.Conc.Sync.$fEqThreadId_$c/=_closure:
         const GHC.Conc.Sync.$fEqThreadId_$c/=_info;
 },
 GHC.Conc.Sync.$fEqThreadId_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9GXq,
                       label: GHC.Conc.Sync.$fEqThreadId_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GXq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9GXu; else goto c9GXv;
       c9GXu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadId_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GXv: // global
           I64[Sp - 16] = block_c9GXn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9GXV; else goto c9GXo;
       u9GXV: // global
           call _c9GXn(R1) args: 0, res: 0, upd: 0;
       c9GXo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GXn() //  [R1]
         { info_tbl: [(c9GXn,
                       label: block_c9GXn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GXn: // global
           I64[Sp] = block_c9GXt_info;
           _s9FCr::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCr::P64;
           if (R1 & 7 != 0) goto u9GXU; else goto c9GXx;
       u9GXU: // global
           call _c9GXt(R1) args: 0, res: 0, upd: 0;
       c9GXx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GXt() //  [R1]
         { info_tbl: [(c9GXt,
                       label: block_c9GXt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GXt: // global
           (_s9FCx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9FCx::I64) == 0 :: W32) goto c9GXQ; else goto c9GXK;
       c9GXQ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9GXK: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.688841551 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadId_closure" {
     GHC.Conc.Sync.$fEqThreadId_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqThreadId_$c==_closure+2;
         const GHC.Conc.Sync.$fEqThreadId_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.690171745 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c<_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c<_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c<_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c<_entry() //  [R2, R3]
         { info_tbl: [(c9GY3,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GY3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9GY7; else goto c9GY8;
       c9GY7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GY8: // global
           I64[Sp - 16] = block_c9GY0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9GYy; else goto c9GY1;
       u9GYy: // global
           call _c9GY0(R1) args: 0, res: 0, upd: 0;
       c9GY1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GY0() //  [R1]
         { info_tbl: [(c9GY0,
                       label: block_c9GY0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GY0: // global
           I64[Sp] = block_c9GY6_info;
           _s9FCC::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCC::P64;
           if (R1 & 7 != 0) goto u9GYx; else goto c9GYa;
       u9GYx: // global
           call _c9GY6(R1) args: 0, res: 0, upd: 0;
       c9GYa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GY6() //  [R1]
         { info_tbl: [(c9GY6,
                       label: block_c9GY6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GY6: // global
           (_s9FCI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9FCI::I64) == (-1) :: W32) goto c9GYt; else goto c9GYn;
       c9GYt: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9GYn: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.691842322 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c>=_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c>=_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c>=_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c9GYG,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GYG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9GYK; else goto c9GYL;
       c9GYK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GYL: // global
           I64[Sp - 16] = block_c9GYD_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9GZb; else goto c9GYE;
       u9GZb: // global
           call _c9GYD(R1) args: 0, res: 0, upd: 0;
       c9GYE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GYD() //  [R1]
         { info_tbl: [(c9GYD,
                       label: block_c9GYD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GYD: // global
           I64[Sp] = block_c9GYJ_info;
           _s9FCN::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCN::P64;
           if (R1 & 7 != 0) goto u9GZa; else goto c9GYN;
       u9GZa: // global
           call _c9GYJ(R1) args: 0, res: 0, upd: 0;
       c9GYN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GYJ() //  [R1]
         { info_tbl: [(c9GYJ,
                       label: block_c9GYJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GYJ: // global
           (_s9FCT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9FCT::I64) == (-1) :: W32) goto c9GZ6; else goto c9GZ0;
       c9GZ6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9GZ0: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.693599678 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c>_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c>_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c>_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c>_entry() //  [R2, R3]
         { info_tbl: [(c9GZj,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GZj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9GZn; else goto c9GZo;
       c9GZn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9GZo: // global
           I64[Sp - 16] = block_c9GZg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9GZV; else goto c9GZh;
       u9GZV: // global
           call _c9GZg(R1) args: 0, res: 0, upd: 0;
       c9GZh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GZg() //  [R1]
         { info_tbl: [(c9GZg,
                       label: block_c9GZg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GZg: // global
           I64[Sp] = block_c9GZm_info;
           _s9FCY::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCY::P64;
           if (R1 & 7 != 0) goto u9GZU; else goto c9GZq;
       u9GZU: // global
           call _c9GZm(R1) args: 0, res: 0, upd: 0;
       c9GZq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9GZm() //  [R1]
         { info_tbl: [(c9GZm,
                       label: block_c9GZm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9GZm: // global
           (_s9FD4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FD5::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FD4::I64));
           if (_s9FD5::I64 == (-1)) goto c9GZP; else goto u9GZT;
       u9GZT: // global
           if (_s9FD5::I64 == 0) goto c9GZP; else goto c9GZD;
       c9GZP: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9GZD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.695435785 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c<=_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c<=_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c<=_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c9H03,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H03: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H07; else goto c9H08;
       c9H07: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9H08: // global
           I64[Sp - 16] = block_c9H00_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9H0F; else goto c9H01;
       u9H0F: // global
           call _c9H00(R1) args: 0, res: 0, upd: 0;
       c9H01: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H00() //  [R1]
         { info_tbl: [(c9H00,
                       label: block_c9H00_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H00: // global
           I64[Sp] = block_c9H06_info;
           _s9FD9::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FD9::P64;
           if (R1 & 7 != 0) goto u9H0E; else goto c9H0a;
       u9H0E: // global
           call _c9H06(R1) args: 0, res: 0, upd: 0;
       c9H0a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H06() //  [R1]
         { info_tbl: [(c9H06,
                       label: block_c9H06_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H06: // global
           (_s9FDf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FDg::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FDf::I64));
           if (_s9FDg::I64 == (-1)) goto c9H0z; else goto u9H0D;
       u9H0D: // global
           if (_s9FDg::I64 == 0) goto c9H0z; else goto c9H0n;
       c9H0z: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9H0n: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.697218226 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$cmax_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$cmax_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$cmax_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c9H0N,
                       label: GHC.Conc.Sync.$fOrdThreadId_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H0N: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9H0R; else goto c9H0S;
       c9H0R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9H0S: // global
           I64[Sp - 16] = block_c9H0K_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9H1p; else goto c9H0L;
       u9H1p: // global
           call _c9H0K(R1) args: 0, res: 0, upd: 0;
       c9H0L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H0K() //  [R1]
         { info_tbl: [(c9H0K,
                       label: block_c9H0K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H0K: // global
           I64[Sp - 8] = block_c9H0Q_info;
           _s9FDj::P64 = R1;
           _s9FDk::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9FDk::P64;
           P64[Sp + 8] = _s9FDj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9H1o; else goto c9H0U;
       u9H1o: // global
           call _c9H0Q(R1) args: 0, res: 0, upd: 0;
       c9H0U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H0Q() //  [R1]
         { info_tbl: [(c9H0Q,
                       label: block_c9H0Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H0Q: // global
           _s9FDj::P64 = P64[Sp + 16];
           (_s9FDq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FDr::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FDq::I64));
           if (_s9FDr::I64 == (-1)) goto c9H1j; else goto u9H1n;
       u9H1n: // global
           if (_s9FDr::I64 == 0) goto c9H1j; else goto c9H17;
       c9H1j: // global
           R1 = _s9FDj::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9H17: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.699107576 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$cmin_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$cmin_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$cmin_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c9H1x,
                       label: GHC.Conc.Sync.$fOrdThreadId_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H1x: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9H1B; else goto c9H1C;
       c9H1B: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9H1C: // global
           I64[Sp - 16] = block_c9H1u_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9H29; else goto c9H1v;
       u9H29: // global
           call _c9H1u(R1) args: 0, res: 0, upd: 0;
       c9H1v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H1u() //  [R1]
         { info_tbl: [(c9H1u,
                       label: block_c9H1u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H1u: // global
           I64[Sp - 8] = block_c9H1A_info;
           _s9FDu::P64 = R1;
           _s9FDv::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9FDv::P64;
           P64[Sp + 8] = _s9FDu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9H28; else goto c9H1E;
       u9H28: // global
           call _c9H1A(R1) args: 0, res: 0, upd: 0;
       c9H1E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H1A() //  [R1]
         { info_tbl: [(c9H1A,
                       label: block_c9H1A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H1A: // global
           _s9FDu::P64 = P64[Sp + 16];
           (_s9FDB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FDw::P64 = R1;
           _s9FDC::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FDB::I64));
           if (_s9FDC::I64 == (-1)) goto c9H23; else goto u9H27;
       u9H27: // global
           if (_s9FDC::I64 == 0) goto c9H23; else goto c9H1R;
       c9H23: // global
           R1 = _s9FDw::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9H1R: // global
           R1 = _s9FDu::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.700486424 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_closure" {
     GHC.Conc.Sync.$fOrdThreadId_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Conc.Sync.$fEqThreadId_closure+1;
         const GHC.Conc.Sync.cmpThread_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c<_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c<=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c>_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c>=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$cmax_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.701054607 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus10_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus10_bytes:
         I8[] [84,104,114,101,97,100,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.701797582 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus9_closure" {
     GHC.Conc.Sync.$fShowThreadStatus9_closure:
         const GHC.Conc.Sync.$fShowThreadStatus9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus9_entry() //  [R1]
         { info_tbl: [(c9H2g,
                       label: GHC.Conc.Sync.$fShowThreadStatus9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H2g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H2h; else goto c9H2i;
       c9H2h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9H2i: // global
           (_c9H2d::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9H2d::I64 == 0) goto c9H2f; else goto c9H2e;
       c9H2f: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9H2e: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9H2d::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.702670953 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus8_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus8_bytes:
         I8[] [84,104,114,101,97,100,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.703372319 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus7_closure" {
     GHC.Conc.Sync.$fShowThreadStatus7_closure:
         const GHC.Conc.Sync.$fShowThreadStatus7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus7_entry() //  [R1]
         { info_tbl: [(c9H2p,
                       label: GHC.Conc.Sync.$fShowThreadStatus7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H2p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H2q; else goto c9H2r;
       c9H2q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9H2r: // global
           (_c9H2m::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9H2m::I64 == 0) goto c9H2o; else goto c9H2n;
       c9H2o: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9H2n: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9H2m::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.704266886 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus6_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus6_bytes:
         I8[] [84,104,114,101,97,100,66,108,111,99,107,101,100,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.704996451 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus5_closure" {
     GHC.Conc.Sync.$fShowThreadStatus5_closure:
         const GHC.Conc.Sync.$fShowThreadStatus5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus5_entry() //  [R1]
         { info_tbl: [(c9H2y,
                       label: GHC.Conc.Sync.$fShowThreadStatus5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H2y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H2z; else goto c9H2A;
       c9H2z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9H2A: // global
           (_c9H2v::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9H2v::I64 == 0) goto c9H2x; else goto c9H2w;
       c9H2x: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9H2w: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9H2v::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.705882039 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus4_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus4_bytes:
         I8[] [84,104,114,101,97,100,68,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.70652896 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus3_closure" {
     GHC.Conc.Sync.$fShowThreadStatus3_closure:
         const GHC.Conc.Sync.$fShowThreadStatus3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus3_entry() //  [R1]
         { info_tbl: [(c9H2H,
                       label: GHC.Conc.Sync.$fShowThreadStatus3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H2H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H2I; else goto c9H2J;
       c9H2I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9H2J: // global
           (_c9H2E::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9H2E::I64 == 0) goto c9H2G; else goto c9H2F;
       c9H2G: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9H2F: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9H2E::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.70842711 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure:
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_info;
         const 0;
 },
 sat_s9FDL_entry() //  [R1]
         { info_tbl: [(c9H37,
                       label: sat_s9FDL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H37: // global
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FDN_entry() //  [R1]
         { info_tbl: [(c9H3k,
                       label: sat_s9FDN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H3k: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9H3o; else goto c9H3n;
       c9H3o: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9H3n: // global
           _s9FDF::P64 = P64[R1 + 16];
           _s9FDH::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s9FDF::P64;
           R3 = Hp - 14;
           R2 = _s9FDH::P64;
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FDO_entry() //  [R1]
         { info_tbl: [(c9H3p,
                       label: sat_s9FDO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H3p: // global
           _s9FDO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9H3q; else goto c9H3r;
       c9H3r: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9H3t; else goto c9H3s;
       c9H3t: // global
           HpAlloc = 32;
           goto c9H3q;
       c9H3q: // global
           R1 = _s9FDO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9H3s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9FDO::P64;
           _s9FDF::P64 = P64[_s9FDO::P64 + 16];
           _s9FDH::P64 = P64[_s9FDO::P64 + 24];
           I64[Hp - 24] = sat_s9FDN_info;
           P64[Hp - 8] = _s9FDF::P64;
           P64[Hp] = _s9FDH::P64;
           R3 = Hp - 24;
           R2 = GHC.Conc.Sync.$fShowThreadStatus5_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c9H3A,
                       label: GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H3A: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9H3B; else goto c9H3C;
       c9H3B: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9H3C: // global
           I64[Sp - 24] = block_c9H2O_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9H3V; else goto c9H2P;
       u9H3V: // global
           call _c9H2O(R1) args: 0, res: 0, upd: 0;
       c9H2P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H2O() //  [R1]
         { info_tbl: [(c9H2O,
                       label: block_c9H2O_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H2O: // global
           _s9FDF::P64 = P64[Sp + 16];
           _c9H3z::P64 = R1 & 7;
           if (_c9H3z::P64 < 3) goto u9H3S; else goto u9H3T;
       u9H3S: // global
           if (_c9H3z::P64 < 2) goto c9H3v; else goto c9H3w;
       c9H3v: // global
           R3 = _s9FDF::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus9_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9H3w: // global
           R3 = _s9FDF::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus7_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u9H3T: // global
           if (_c9H3z::P64 < 4) goto c9H3x; else goto c9H3y;
       c9H3x: // global
           I64[Sp] = block_c9H2V_info;
           _s9FDH::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FDH::P64;
           if (R1 & 7 != 0) goto u9H3U; else goto c9H2W;
       u9H3U: // global
           call _c9H2V(R1) args: 0, res: 0, upd: 0;
       c9H2W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9H3y: // global
           R3 = _s9FDF::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus3_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c9H2V() //  [R1]
         { info_tbl: [(c9H2V,
                       label: block_c9H2V_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H2V: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9H3K; else goto c9H3J;
       c9H3K: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9H3J: // global
           _s9FDF::P64 = P64[Sp + 16];
           _s9FDH::P64 = P64[Sp + 8];
           if (%MO_S_Lt_W64(I64[R1 + 7], 11)) goto c9H3M; else goto c9H3O;
       c9H3M: // global
           I64[Hp - 48] = sat_s9FDL_info;
           P64[Hp - 32] = _s9FDF::P64;
           P64[Hp - 24] = _s9FDH::P64;
           _c9H33::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c9H33::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus5_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9H3O: // global
           I64[Hp - 48] = sat_s9FDO_info;
           P64[Hp - 32] = _s9FDF::P64;
           P64[Hp - 24] = _s9FDH::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.711721207 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure:
         const GHC.Conc.Sync.$fShowThreadStatus_$cshow_info;
         const 0;
 },
 sat_s9FDS_entry() //  [R1]
         { info_tbl: [(c9H4b,
                       label: sat_s9FDS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H4b: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fShowThreadStatus_$cshow_entry() //  [R2]
         { info_tbl: [(c9H4k,
                       label: GHC.Conc.Sync.$fShowThreadStatus_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H4k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9H4l; else goto c9H4m;
       c9H4l: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9H4m: // global
           I64[Sp - 8] = block_c9H40_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9H4z; else goto c9H41;
       u9H4z: // global
           call _c9H40(R1) args: 0, res: 0, upd: 0;
       c9H41: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H40() //  [R1]
         { info_tbl: [(c9H40,
                       label: block_c9H40_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H40: // global
           _c9H4j::P64 = R1 & 7;
           if (_c9H4j::P64 < 3) goto u9H4x; else goto u9H4y;
       u9H4x: // global
           if (_c9H4j::P64 < 2) goto c9H4f; else goto c9H4g;
       c9H4f: // global
           R1 = GHC.Conc.Sync.$fShowThreadStatus9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9H4g: // global
           R1 = GHC.Conc.Sync.$fShowThreadStatus7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9H4y: // global
           if (_c9H4j::P64 < 4) goto c9H4h; else goto c9H4i;
       c9H4h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9H4t; else goto c9H4s;
       c9H4t: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9H4s: // global
           _s9FDR::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_s9FDS_info;
           P64[Hp] = _s9FDR::P64;
           R3 = Hp - 16;
           R2 = GHC.Conc.Sync.$fShowThreadStatus5_closure;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9H4i: // global
           R1 = GHC.Conc.Sync.$fShowThreadStatus3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.713171066 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus2_closure" {
     GHC.Conc.Sync.$fShowThreadStatus2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.713880782 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus1_closure" {
     GHC.Conc.Sync.$fShowThreadStatus1_closure:
         const GHC.Conc.Sync.$fShowThreadStatus1_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus1_entry() //  [R2, R3]
         { info_tbl: [(c9H4E,
                       label: GHC.Conc.Sync.$fShowThreadStatus1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H4E: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$fShowThreadStatus2_closure+1;
           call GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.714716338 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_$cshowList_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_$cshowList_closure:
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowList_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c9H4L,
                       label: GHC.Conc.Sync.$fShowThreadStatus_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H4L: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$fShowThreadStatus1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.715465453 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure+3;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure+1;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.717920429 UTC

[section ""data" . GHC.Conc.Sync.killThread2_closure" {
     GHC.Conc.Sync.killThread2_closure:
         const GHC.Conc.Sync.killThread2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.killThread2_entry() //  [R1]
         { info_tbl: [(c9H4U,
                       label: GHC.Conc.Sync.killThread2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H4U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H4V; else goto c9H4W;
       c9H4V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9H4W: // global
           (_c9H4R::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9H4R::I64 == 0) goto c9H4T; else goto c9H4S;
       c9H4T: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9H4S: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9H4R::I64;
           R2 = GHC.IO.Exception.ThreadKilled_closure+3;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.719092467 UTC

[section ""data" . GHC.Conc.Sync.killThread1_closure" {
     GHC.Conc.Sync.killThread1_closure:
         const GHC.Conc.Sync.killThread1_info;
         const 0;
 },
 GHC.Conc.Sync.killThread1_entry() //  [R2]
         { info_tbl: [(c9H54,
                       label: GHC.Conc.Sync.killThread1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H54: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9H58; else goto c9H59;
       c9H58: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.killThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9H59: // global
           I64[Sp - 8] = block_c9H51_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9H5d; else goto c9H52;
       u9H5d: // global
           call _c9H51(R1) args: 0, res: 0, upd: 0;
       c9H52: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H51() //  [R1]
         { info_tbl: [(c9H51,
                       label: block_c9H51_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H51: // global
           I64[Sp] = block_c9H57_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H57() //  []
         { info_tbl: [(c9H57,
                       label: block_c9H57_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H57: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.720234855 UTC

[section ""data" . GHC.Conc.Sync.killThread_closure" {
     GHC.Conc.Sync.killThread_closure:
         const GHC.Conc.Sync.killThread_info;
         const 0;
 },
 GHC.Conc.Sync.killThread_entry() //  [R2]
         { info_tbl: [(c9H5i,
                       label: GHC.Conc.Sync.killThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H5i: // global
           R2 = R2;
           call GHC.Conc.Sync.killThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.721059082 UTC

[section ""data" . GHC.Conc.Sync.getNumProcessors1_closure" {
     GHC.Conc.Sync.getNumProcessors1_closure:
         const GHC.Conc.Sync.getNumProcessors1_info;
 },
 GHC.Conc.Sync.getNumProcessors1_entry() //  []
         { info_tbl: [(c9H5s,
                       label: GHC.Conc.Sync.getNumProcessors1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H5s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9H5B; else goto c9H5A;
       c9H5B: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.getNumProcessors1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9H5A: // global
           (_s9FE4::I64) = call "ccall" arg hints:  []  result hints:  [] getNumberOfProcessors();
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s9FE4::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.722030431 UTC

[section ""data" . GHC.Conc.Sync.getNumProcessors_closure" {
     GHC.Conc.Sync.getNumProcessors_closure:
         const GHC.Conc.Sync.getNumProcessors_info;
 },
 GHC.Conc.Sync.getNumProcessors_entry() //  []
         { info_tbl: [(c9H5G,
                       label: GHC.Conc.Sync.getNumProcessors_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H5G: // global
           call GHC.Conc.Sync.getNumProcessors1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.722732232 UTC

[section ""data" . GHC.Conc.Sync.threadStatus7_closure" {
     GHC.Conc.Sync.threadStatus7_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnOther_closure+6;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.723294114 UTC

[section ""data" . GHC.Conc.Sync.threadStatus6_closure" {
     GHC.Conc.Sync.threadStatus6_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnMVar_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.723850898 UTC

[section ""data" . GHC.Conc.Sync.threadStatus2_closure" {
     GHC.Conc.Sync.threadStatus2_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnException_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.724439678 UTC

[section ""data" . GHC.Conc.Sync.threadStatus3_closure" {
     GHC.Conc.Sync.threadStatus3_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.725030831 UTC

[section ""data" . GHC.Conc.Sync.threadStatus4_closure" {
     GHC.Conc.Sync.threadStatus4_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnSTM_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.725798896 UTC

[section ""data" . GHC.Conc.Sync.threadStatus5_closure" {
     GHC.Conc.Sync.threadStatus5_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.726966033 UTC

[section ""data" . GHC.Conc.Sync.$wthreadStatus_closure" {
     GHC.Conc.Sync.$wthreadStatus_closure:
         const GHC.Conc.Sync.$wthreadStatus_info;
 },
 sat_s9FEg_entry() //  [R1]
         { info_tbl: [(c9H68,
                       label: sat_s9FEg_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H68: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H69; else goto c9H6a;
       c9H69: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9H6a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s9FEf::I64 = I64[R1 + 16];
           if (%MO_S_Ge_W64(_s9FEf::I64, 18)) goto c9H5X; else goto u9H6b;
       u9H6b: // global
           if (%MO_S_Lt_W64(_s9FEf::I64, 0)) goto c9H5X; else goto u9H6c;
       u9H6c: // global
           switch [0 .. 17] _s9FEf::I64 {
               case 0 : goto c9H5Y;
               case 1 : goto c9H65;
               case 2 : goto c9H60;
               case 6 : goto c9H61;
               case 10, 11 : goto c9H63;
               case 12 : goto c9H64;
               case 14 : goto c9H65;
               case 16 : goto c9H66;
               case 17 : goto c9H67;
               default: {goto c9H5X;}
           }
       c9H67: // global
           R1 = GHC.Conc.Sync.ThreadDied_closure+4;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9H66: // global
           R1 = GHC.Conc.Sync.ThreadFinished_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9H64: // global
           R1 = GHC.Conc.Sync.threadStatus2_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9H63: // global
           R1 = GHC.Conc.Sync.threadStatus3_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9H61: // global
           R1 = GHC.Conc.Sync.threadStatus4_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9H60: // global
           R1 = GHC.Conc.Sync.threadStatus5_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9H65: // global
           R1 = GHC.Conc.Sync.threadStatus6_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9H5Y: // global
           R1 = GHC.Conc.Sync.ThreadRunning_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9H5X: // global
           R1 = GHC.Conc.Sync.threadStatus7_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$wthreadStatus_entry() //  [R2]
         { info_tbl: [(c9H6d,
                       label: GHC.Conc.Sync.$wthreadStatus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H6d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H6e; else goto c9H6f;
       c9H6e: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.$wthreadStatus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9H6f: // global
           I64[Sp - 8] = block_c9H5N_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H5N() //  [R1]
         { info_tbl: [(c9H5N,
                       label: block_c9H5N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H5N: // global
           I64[Sp] = R1;
           Sp = Sp - 8;
           call _c9H5O() args: 0, res: 0, upd: 0;
     }
 },
 _c9H5O() //  []
         { info_tbl: [(c9H5O,
                       label: block_c9H5O_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H5O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9H6i; else goto c9H6h;
       c9H6i: // global
           HpAlloc = 24;
           I64[Sp] = block_c9H5O_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c9H6h: // global
           I64[Hp - 16] = sat_s9FEg_info;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.728954957 UTC

[section ""data" . GHC.Conc.Sync.threadStatus1_closure" {
     GHC.Conc.Sync.threadStatus1_closure:
         const GHC.Conc.Sync.threadStatus1_info;
 },
 GHC.Conc.Sync.threadStatus1_entry() //  [R2]
         { info_tbl: [(c9H6s,
                       label: GHC.Conc.Sync.threadStatus1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H6s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9H6t; else goto c9H6u;
       c9H6t: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.threadStatus1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9H6u: // global
           I64[Sp - 8] = block_c9H6p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9H6y; else goto c9H6q;
       u9H6y: // global
           call _c9H6p(R1) args: 0, res: 0, upd: 0;
       c9H6q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H6p() //  [R1]
         { info_tbl: [(c9H6p,
                       label: block_c9H6p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H6p: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wthreadStatus_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.730051737 UTC

[section ""data" . GHC.Conc.Sync.threadStatus_closure" {
     GHC.Conc.Sync.threadStatus_closure:
         const GHC.Conc.Sync.threadStatus_info;
 },
 GHC.Conc.Sync.threadStatus_entry() //  [R2]
         { info_tbl: [(c9H6D,
                       label: GHC.Conc.Sync.threadStatus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H6D: // global
           R2 = R2;
           call GHC.Conc.Sync.threadStatus1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.731049485 UTC

[section ""data" . GHC.Conc.Sync.$fFunctorSTM2_closure" {
     GHC.Conc.Sync.$fFunctorSTM2_closure:
         const GHC.Conc.Sync.$fFunctorSTM2_info;
 },
 GHC.Conc.Sync.$fFunctorSTM2_entry() //  [R2, R3]
         { info_tbl: [(c9H6N,
                       label: GHC.Conc.Sync.$fFunctorSTM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H6N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H6O; else goto c9H6P;
       c9H6O: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fFunctorSTM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9H6P: // global
           I64[Sp - 16] = block_c9H6K_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H6K() //  [R1]
         { info_tbl: [(c9H6K,
                       label: block_c9H6K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H6K: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9H6S; else goto c9H6R;
       c9H6S: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9H6R: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.732217097 UTC

[section ""data" . GHC.Conc.Sync.$fFunctorSTM1_closure" {
     GHC.Conc.Sync.$fFunctorSTM1_closure:
         const GHC.Conc.Sync.$fFunctorSTM1_info;
 },
 GHC.Conc.Sync.$fFunctorSTM1_entry() //  [R2, R3]
         { info_tbl: [(c9H6Z,
                       label: GHC.Conc.Sync.$fFunctorSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H6Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H70; else goto c9H71;
       c9H70: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fFunctorSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9H71: // global
           I64[Sp - 16] = block_c9H6X_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H6X() //  []
         { info_tbl: [(c9H6X,
                       label: block_c9H6X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H6X: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.733418391 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM2_closure" {
     GHC.Conc.Sync.$fApplicativeSTM2_closure:
         const GHC.Conc.Sync.$fApplicativeSTM2_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM2_entry() //  [R2, R3]
         { info_tbl: [(c9H7c,
                       label: GHC.Conc.Sync.$fApplicativeSTM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H7c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H7d; else goto c9H7e;
       c9H7d: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fApplicativeSTM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9H7e: // global
           I64[Sp - 16] = block_c9H77_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H77() //  [R1]
         { info_tbl: [(c9H77,
                       label: block_c9H77_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H77: // global
           I64[Sp] = block_c9H79_info;
           _s9FED::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FED::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H79() //  [R1]
         { info_tbl: [(c9H79,
                       label: block_c9H79_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H79: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9H7i; else goto c9H7h;
       c9H7i: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9H7h: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.734849785 UTC

[section ""data" . $cliftA2_r9Fva_closure" {
     $cliftA2_r9Fva_closure:
         const $cliftA2_r9Fva_info;
 },
 $cliftA2_r9Fva_entry() //  [R2, R3, R4]
         { info_tbl: [(c9H7s,
                       label: $cliftA2_r9Fva_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H7s: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9H7t; else goto c9H7u;
       c9H7t: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cliftA2_r9Fva_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9H7u: // global
           I64[Sp - 24] = block_c9H7n_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H7n() //  [R1]
         { info_tbl: [(c9H7n,
                       label: block_c9H7n_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H7n: // global
           I64[Sp] = block_c9H7p_info;
           _s9FEO::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s9FEO::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H7p() //  [R1]
         { info_tbl: [(c9H7p,
                       label: block_c9H7p_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H7p: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9H7y; else goto c9H7x;
       c9H7y: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9H7x: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.73613905 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_closure:
         const GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(c9H7D,
                       label: GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H7D: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cliftA2_r9Fva_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.737084495 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM1_closure" {
     GHC.Conc.Sync.$fApplicativeSTM1_closure:
         const GHC.Conc.Sync.$fApplicativeSTM1_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM1_entry() //  [R2, R3]
         { info_tbl: [(c9H7O,
                       label: GHC.Conc.Sync.$fApplicativeSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H7O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H7P; else goto c9H7Q;
       c9H7P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fApplicativeSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9H7Q: // global
           I64[Sp - 16] = block_c9H7K_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H7K() //  [R1]
         { info_tbl: [(c9H7K,
                       label: block_c9H7K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H7K: // global
           I64[Sp] = block_c9H7M_info;
           _s9FEY::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FEY::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H7M() //  []
         { info_tbl: [(c9H7M,
                       label: block_c9H7M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H7M: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.738165449 UTC

[section ""data" . GHC.Conc.Sync.$fFunctorSTM_closure" {
     GHC.Conc.Sync.$fFunctorSTM_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Conc.Sync.$fFunctorSTM2_closure+3;
         const GHC.Conc.Sync.$fFunctorSTM1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.738749875 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Conc.Sync.$fFunctorSTM_closure+1;
         const GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure+2;
         const GHC.Conc.Sync.$fApplicativeSTM2_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_closure+4;
         const GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.739421562 UTC

[section ""data" . lvl_r9Fvb_closure" {
     lvl_r9Fvb_closure:
         const lvl_r9Fvb_info;
         const 0;
 },
 lvl_r9Fvb_entry() //  [R2]
         { info_tbl: [(c9H7X,
                       label: lvl_r9Fvb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H7X: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.740151786 UTC

[section ""data" . GHC.Conc.Sync.$fMonadSTM_closure" {
     GHC.Conc.Sync.$fMonadSTM_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Conc.Sync.$fApplicativeSTM_closure+1;
         const GHC.Conc.Sync.$fMonadSTM_$c>>=_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure+2;
         const lvl_r9Fvb_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.74081519 UTC

[section ""data" . GHC.Conc.Sync.always2_closure" {
     GHC.Conc.Sync.always2_closure:
         const GHC.Conc.Sync.always2_info;
 },
 GHC.Conc.Sync.always2_entry() //  []
         { info_tbl: [(c9H84,
                       label: GHC.Conc.Sync.always2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H84: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.741947672 UTC

[section ""data" . GHC.Conc.Sync.alwaysSucceeds1_closure" {
     GHC.Conc.Sync.alwaysSucceeds1_closure:
         const GHC.Conc.Sync.alwaysSucceeds1_info;
 },
 sat_s9FFa_entry() //  [R1]
         { info_tbl: [(c9H8i,
                       label: sat_s9FFa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H8i: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9H8j; else goto c9H8k;
       c9H8j: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9H8k: // global
           I64[Sp - 8] = block_c9H8g_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H8g() //  []
         { info_tbl: [(c9H8g,
                       label: block_c9H8g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H8g: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.alwaysSucceeds1_entry() //  [R2]
         { info_tbl: [(c9H8q,
                       label: GHC.Conc.Sync.alwaysSucceeds1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H8q: // global
           _s9FF4::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9H8r; else goto c9H8s;
       c9H8s: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9H8u; else goto c9H8t;
       c9H8u: // global
           HpAlloc = 16;
           goto c9H8r;
       c9H8r: // global
           R2 = _s9FF4::P64;
           R1 = GHC.Conc.Sync.alwaysSucceeds1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9H8t: // global
           I64[Hp - 8] = sat_s9FFa_info;
           P64[Hp] = _s9FF4::P64;
           I64[Sp - 16] = block_c9H8m_info;
           R2 = GHC.Conc.Sync.always2_closure+1;
           R1 = Hp - 7;
           P64[Sp - 8] = _s9FF4::P64;
           Sp = Sp - 16;
           call stg_catchRetry#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H8m() //  []
         { info_tbl: [(c9H8m,
                       label: block_c9H8m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H8m: // global
           _s9FF4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9H8o_info;
           R1 = _s9FF4::P64;
           Sp = Sp + 8;
           call stg_check#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H8o() //  []
         { info_tbl: [(c9H8o,
                       label: block_c9H8o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H8o: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.743425957 UTC

[section ""data" . GHC.Conc.Sync.alwaysSucceeds_closure" {
     GHC.Conc.Sync.alwaysSucceeds_closure:
         const GHC.Conc.Sync.alwaysSucceeds_info;
 },
 GHC.Conc.Sync.alwaysSucceeds_entry() //  [R2]
         { info_tbl: [(c9H8B,
                       label: GHC.Conc.Sync.alwaysSucceeds_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H8B: // global
           R2 = R2;
           call GHC.Conc.Sync.alwaysSucceeds1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.744229726 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM2_closure" {
     GHC.Conc.Sync.$fAlternativeSTM2_closure:
         const GHC.Conc.Sync.$fAlternativeSTM2_info;
 },
 GHC.Conc.Sync.$fAlternativeSTM2_entry() //  []
         { info_tbl: [(c9H8I,
                       label: GHC.Conc.Sync.$fAlternativeSTM2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H8I: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.745401903 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM3_closure" {
     GHC.Conc.Sync.$fAlternativeSTM3_closure:
         const GHC.Conc.Sync.$fAlternativeSTM3_info;
 },
 some_v_s9FFi_entry() //  [R1]
         { info_tbl: [(c9H8Z,
                       label: some_v_s9FFi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H8Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H90; else goto c9H91;
       c9H90: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9H91: // global
           I64[Sp - 16] = block_c9H8U_info;
           _s9FFi::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s9FFi::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H8U() //  [R1]
         { info_tbl: [(c9H8U,
                       label: block_c9H8U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H8U: // global
           I64[Sp] = block_c9H8W_info;
           R2 = GHC.Conc.Sync.$fAlternativeSTM2_closure+1;
           _s9FFm::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FFm::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H8W() //  [R1]
         { info_tbl: [(c9H8W,
                       label: block_c9H8W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H8W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9H95; else goto c9H94;
       c9H95: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9H94: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fAlternativeSTM3_entry() //  [R2]
         { info_tbl: [(c9H96,
                       label: GHC.Conc.Sync.$fAlternativeSTM3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H96: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9H9a; else goto c9H99;
       c9H9a: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fAlternativeSTM3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9H99: // global
           I64[Hp - 8] = some_v_s9FFi_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call some_v_s9FFi_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.747317501 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM1_closure" {
     GHC.Conc.Sync.$fAlternativeSTM1_closure:
         const GHC.Conc.Sync.$fAlternativeSTM1_info;
 },
 many_v_s9FFt_entry() //  [R1]
         { info_tbl: [(c9H9q,
                       label: many_v_s9FFt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H9q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9H9r; else goto c9H9s;
       c9H9r: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9H9s: // global
           I64[Sp - 16] = block_c9H9l_info;
           _s9FFu::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s9FFu::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H9l() //  [R1]
         { info_tbl: [(c9H9l,
                       label: block_c9H9l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H9l: // global
           I64[Sp] = block_c9H9n_info;
           _s9FFy::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FFy::P64;
           call many_v1_s9FFu_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9H9n() //  [R1]
         { info_tbl: [(c9H9n,
                       label: block_c9H9n_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H9n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9H9w; else goto c9H9v;
       c9H9w: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9H9v: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 many_v1_s9FFu_entry() //  [R1]
         { info_tbl: [(c9H9B,
                       label: many_v1_s9FFu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H9B: // global
           R2 = GHC.Conc.Sync.$fAlternativeSTM2_closure+1;
           R1 = P64[R1 + 7];
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fAlternativeSTM1_entry() //  [R2]
         { info_tbl: [(c9H9E,
                       label: GHC.Conc.Sync.$fAlternativeSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H9E: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9H9I; else goto c9H9H;
       c9H9I: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fAlternativeSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9H9H: // global
           I64[Hp - 32] = many_v_s9FFt_info;
           P64[Hp - 24] = R2;
           _c9H9g::P64 = Hp - 7;
           P64[Hp - 16] = _c9H9g::P64;
           I64[Hp - 8] = many_v1_s9FFu_info;
           P64[Hp] = Hp - 31;
           R1 = _c9H9g::P64;
           call many_v1_s9FFu_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.748994071 UTC

[section ""data" . sat_s9FFE_closure" {
     sat_s9FFE_closure:
         const sat_s9FFE_info;
         const 0;
 },
 sat_s9FFE_entry() //  [R2, R3]
         { info_tbl: [(c9H9N,
                       label: sat_s9FFE_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H9N: // global
           _B3::P64 = R2;
           R2 = R3;
           R1 = _B3::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.749839597 UTC

[section ""data" . sat_s9FFD_closure" {
     sat_s9FFD_closure:
         const sat_s9FFD_info;
         const 0;
 },
 sat_s9FFD_entry() //  []
         { info_tbl: [(c9H9U,
                       label: sat_s9FFD_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9H9U: // global
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.750543812 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM_closure" {
     GHC.Conc.Sync.$fAlternativeSTM_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Conc.Sync.$fApplicativeSTM_closure+1;
         const sat_s9FFD_closure+1;
         const sat_s9FFE_closure+3;
         const GHC.Conc.Sync.$fAlternativeSTM3_closure+2;
         const GHC.Conc.Sync.$fAlternativeSTM1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.751214975 UTC

[section ""data" . sat_s9FFG_closure" {
     sat_s9FFG_closure:
         const sat_s9FFG_info;
         const 0;
 },
 sat_s9FFG_entry() //  [R2, R3]
         { info_tbl: [(c9Ha1,
                       label: sat_s9FFG_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ha1: // global
           _B3::P64 = R2;
           R2 = R3;
           R1 = _B3::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.751960647 UTC

[section ""data" . sat_s9FFF_closure" {
     sat_s9FFF_closure:
         const sat_s9FFF_info;
         const 0;
 },
 sat_s9FFF_entry() //  []
         { info_tbl: [(c9Ha8,
                       label: sat_s9FFF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ha8: // global
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.752653736 UTC

[section ""data" . GHC.Conc.Sync.$fMonadPlusSTM_closure" {
     GHC.Conc.Sync.$fMonadPlusSTM_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Conc.Sync.$fAlternativeSTM_closure+1;
         const GHC.Conc.Sync.$fMonadSTM_closure+1;
         const sat_s9FFF_closure+1;
         const sat_s9FFG_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.753728021 UTC

[section ""cstring" . lvl1_r9Fvc_bytes" {
     lvl1_r9Fvc_bytes:
         I8[] [84,114,97,110,115,97,99,116,105,111,110,97,108,32,105,110,118,97,114,105,97,110,116,32,118,105,111,108,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.754499561 UTC

[section ""data" . GHC.Conc.Sync.always3_closure" {
     GHC.Conc.Sync.always3_closure:
         const GHC.Conc.Sync.always3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.always3_entry() //  [R1]
         { info_tbl: [(c9Haj,
                       label: GHC.Conc.Sync.always3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Haj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Hak; else goto c9Hal;
       c9Hak: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Hal: // global
           (_c9Hae::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Hae::I64 == 0) goto c9Hag; else goto c9Haf;
       c9Hag: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Haf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Hae::I64;
           I64[Sp - 24] = block_c9Hah_info;
           R2 = lvl1_r9Fvc_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9Hah() //  [R1]
         { info_tbl: [(c9Hah,
                       label: block_c9Hah_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hah: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.756304947 UTC

[section ""data" . GHC.Conc.Sync.always1_closure" {
     GHC.Conc.Sync.always1_closure:
         const GHC.Conc.Sync.always1_info;
         const 0;
 },
 sat_s9FFQ_entry() //  [R1]
         { info_tbl: [(c9HaH,
                       label: sat_s9FFQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HaH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9HaI; else goto c9HaJ;
       c9HaI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9HaJ: // global
           I64[Sp - 8] = block_c9Hay_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hay() //  [R1]
         { info_tbl: [(c9Hay,
                       label: block_c9Hay_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hay: // global
           I64[Sp] = block_c9HaA_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u9HaR; else goto c9HaB;
       u9HaR: // global
           call _c9HaA(R1) args: 0, res: 0, upd: 0;
       c9HaB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HaA() //  [R1]
         { info_tbl: [(c9HaA,
                       label: block_c9HaA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HaA: // global
           if (R1 & 7 == 1) goto c9HaE; else goto c9HaF;
       c9HaE: // global
           R1 = GHC.Conc.Sync.always3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9HaF: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FG0_entry() //  [R1]
         { info_tbl: [(c9Hb8,
                       label: sat_s9FG0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hb8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Hb9; else goto c9Hba;
       c9Hb9: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Hba: // global
           I64[Sp - 8] = block_c9HaZ_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HaZ() //  [R1]
         { info_tbl: [(c9HaZ,
                       label: block_c9HaZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HaZ: // global
           I64[Sp] = block_c9Hb1_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u9Hbi; else goto c9Hb2;
       u9Hbi: // global
           call _c9Hb1(R1) args: 0, res: 0, upd: 0;
       c9Hb2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hb1() //  [R1]
         { info_tbl: [(c9Hb1,
                       label: block_c9Hb1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hb1: // global
           if (R1 & 7 == 1) goto c9Hb5; else goto c9Hb6;
       c9Hb5: // global
           R1 = GHC.Conc.Sync.always3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9Hb6: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.always1_entry() //  [R2]
         { info_tbl: [(c9Hbl,
                       label: GHC.Conc.Sync.always1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hbl: // global
           _s9FFI::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Hbm; else goto c9Hbn;
       c9Hbn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hbp; else goto c9Hbo;
       c9Hbp: // global
           HpAlloc = 16;
           goto c9Hbm;
       c9Hbm: // global
           R2 = _s9FFI::P64;
           R1 = GHC.Conc.Sync.always1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Hbo: // global
           I64[Hp - 8] = sat_s9FFQ_info;
           P64[Hp] = _s9FFI::P64;
           I64[Sp - 16] = block_c9HaS_info;
           R2 = GHC.Conc.Sync.always2_closure+1;
           R1 = Hp - 7;
           P64[Sp - 8] = _s9FFI::P64;
           Sp = Sp - 16;
           call stg_catchRetry#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HaS() //  [R1]
         { info_tbl: [(c9HaS,
                       label: block_c9HaS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HaS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hbs; else goto c9Hbr;
       c9Hbs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Hbr: // global
           I64[Hp - 8] = sat_s9FG0_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c9Hbj_info;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call stg_check#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hbj() //  []
         { info_tbl: [(c9Hbj,
                       label: block_c9Hbj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hbj: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.758665354 UTC

[section ""data" . GHC.Conc.Sync.always_closure" {
     GHC.Conc.Sync.always_closure:
         const GHC.Conc.Sync.always_info;
         const 0;
 },
 GHC.Conc.Sync.always_entry() //  [R2]
         { info_tbl: [(c9Hby,
                       label: GHC.Conc.Sync.always_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hby: // global
           R2 = R2;
           call GHC.Conc.Sync.always1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.759360671 UTC

[section ""cstring" . lvl2_r9Fvd_bytes" {
     lvl2_r9Fvd_bytes:
         I8[] [110,111,32,116,104,114,101,97,100,115,32,116,111,32,114,117,110,58,32,32,105,110,102,105,110,105,116,101,32,108,111,111,112,32,111,114,32,100,101,97,100,108,111,99,107,63]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.760097169 UTC

[section ""data" . lvl3_r9Fve_closure" {
     lvl3_r9Fve_closure:
         const lvl3_r9Fve_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r9Fve_entry() //  [R1]
         { info_tbl: [(c9HbH,
                       label: lvl3_r9Fve_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HbH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HbI; else goto c9HbJ;
       c9HbI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9HbJ: // global
           (_c9HbE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9HbE::I64 == 0) goto c9HbG; else goto c9HbF;
       c9HbG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9HbF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9HbE::I64;
           R2 = lvl2_r9Fvd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.761433107 UTC

[section ""data" . lvl4_r9Fvf_closure" {
     lvl4_r9Fvf_closure:
         const lvl4_r9Fvf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r9Fvf_entry() //  [R1]
         { info_tbl: [(c9HbV,
                       label: lvl4_r9Fvf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HbV: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9HbW; else goto c9HbX;
       c9HbW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9HbX: // global
           (_c9HbN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9HbN::I64 == 0) goto c9HbP; else goto c9HbO;
       c9HbP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9HbO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9HbN::I64;
           I64[Sp - 24] = block_c9HbQ_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionDeadlock4_closure;
           R4 = GHC.IO.Exception.$trModule_closure;
           R3 = 11186984538024031318;
           R2 = 18363794241794644491;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c9HbQ() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c9HbQ,
                       label: block_c9HbQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HbQ: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c9HbR() args: 0, res: 0, upd: 0;
     }
 },
 _c9HbR() //  []
         { info_tbl: [(c9HbR,
                       label: block_c9HbR_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HbR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c9Hc0; else goto c9HbZ;
       c9Hc0: // global
           HpAlloc = 48;
           I64[Sp] = block_c9HbR_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c9HbZ: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.764209209 UTC

[section ""cstring" . lvl5_r9Fvg_bytes" {
     lvl5_r9Fvg_bytes:
         I8[] [37,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.764977218 UTC

[section ""data" . lvl6_r9Fvh_closure" {
     lvl6_r9Fvh_closure:
         const lvl6_r9Fvh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r9Fvh_entry() //  [R1]
         { info_tbl: [(c9Hc9,
                       label: lvl6_r9Fvh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hc9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Hca; else goto c9Hcb;
       c9Hca: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Hcb: // global
           (_c9Hc6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Hc6::I64 == 0) goto c9Hc8; else goto c9Hc7;
       c9Hc8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Hc7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Hc6::I64;
           R2 = lvl5_r9Fvg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.766039083 UTC

[section ""data" . lvl7_r9Fvi_closure" {
     lvl7_r9Fvi_closure:
         const lvl7_r9Fvi_info;
 },
 lvl7_r9Fvi_entry() //  [R2]
         { info_tbl: [(c9Hcj,
                       label: lvl7_r9Fvi_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hcj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Hck; else goto c9Hcl;
       c9Hck: // global
           R2 = R2;
           R1 = lvl7_r9Fvi_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Hcl: // global
           I64[Sp - 8] = block_c9Hcg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Hcp; else goto c9Hch;
       u9Hcp: // global
           call _c9Hcg() args: 0, res: 0, upd: 0;
       c9Hch: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hcg() //  []
         { info_tbl: [(c9Hcg,
                       label: block_c9Hcg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hcg: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.767135097 UTC

[section ""data" . lvl8_r9Fvj_closure" {
     lvl8_r9Fvj_closure:
         const lvl8_r9Fvj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_r9Fvj_entry() //  [R1]
         { info_tbl: [(c9Hcw,
                       label: lvl8_r9Fvj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hcw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Hcx; else goto c9Hcy;
       c9Hcx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Hcy: // global
           (_c9Hct::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Hct::I64 == 0) goto c9Hcv; else goto c9Hcu;
       c9Hcv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Hcu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Hct::I64;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           R1 = GHC.IO.Handle.hFlush_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.76973634 UTC

[section ""data" . lvl9_r9Fvk_closure" {
     lvl9_r9Fvk_closure:
         const lvl9_r9Fvk_info;
         const 0;
 },
 msg_s9FGp_entry() //  [R1]
         { info_tbl: [(c9HcU,
                       label: msg_s9FGp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HcU: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c9HcV; else goto c9HcW;
       c9HcV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9HcW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9HcS_info;
           _s9FGg::P64 = P64[R1 + 16];
           R2 = _s9FGg::P64;
           P64[Sp - 32] = _s9FGg::P64;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9HcS() //  [R1]
         { info_tbl: [(c9HcS,
                       label: block_c9HcS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HcS: // global
           I64[Sp] = block_c9HcZ_info;
           R3 = lvl4_r9Fvf_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9HcZ() //  [R1]
         { info_tbl: [(c9HcZ,
                       label: block_c9HcZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HcZ: // global
           if (R1 & 7 == 1) goto c9Hd7; else goto c9Hdg;
       c9Hd7: // global
           _s9FGg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9Hd4_info;
           R2 = _s9FGg::P64;
           Sp = Sp + 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 24;
       c9Hdg: // global
           _s9FGh::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9Hde_info;
           R1 = _s9FGh::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9Hd4() //  [R1]
         { info_tbl: [(c9Hd4,
                       label: block_c9Hd4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hd4: // global
           R2 = R1;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = GHC.Conc.Sync.$fShowThreadStatus2_closure+1;
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 _c9Hde() //  []
         { info_tbl: [(c9Hde,
                       label: block_c9Hde_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hde: // global
           R1 = lvl3_r9Fve_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FGI_entry() //  [R1, R2]
         { info_tbl: [(c9HdB,
                       label: sat_s9FGI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HdB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HdF; else goto c9HdG;
       c9HdF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HdG: // global
           I64[Sp - 16] = block_c9Hdy_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HdR; else goto c9Hdz;
       u9HdR: // global
           call _c9Hdy(R1) args: 0, res: 0, upd: 0;
       c9Hdz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hdy() //  [R1]
         { info_tbl: [(c9Hdy,
                       label: block_c9Hdy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hdy: // global
           I64[Sp] = block_c9HdE_info;
           _s9FGC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s9FGC::I64;
           if (R1 & 7 != 0) goto u9HdQ; else goto c9HdI;
       u9HdQ: // global
           call _c9HdE(R1) args: 0, res: 0, upd: 0;
       c9HdI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HdE() //  [R1]
         { info_tbl: [(c9HdE,
                       label: block_c9HdE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HdE: // global
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] errorBelch2(I64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FGJ_entry() //  [R1, R2]
         { info_tbl: [(c9HdS,
                       label: sat_s9FGJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HdS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HdT; else goto c9HdU;
       c9HdT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HdU: // global
           I64[Sp - 24] = block_c9Hdr_info;
           _s9FGp::P64 = P64[R1 + 6];
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 16] = _s9FGp::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hdr() //  [R1]
         { info_tbl: [(c9Hdr,
                       label: block_c9Hdr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hdr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9HdX; else goto c9HdW;
       c9HdX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HdW: // global
           I64[Hp - 8] = sat_s9FGI_info;
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 6;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 lvl9_r9Fvk_entry() //  [R2]
         { info_tbl: [(c9HdY,
                       label: lvl9_r9Fvk_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HdY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HdZ; else goto c9He0;
       c9HdZ: // global
           R2 = R2;
           R1 = lvl9_r9Fvk_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9He0: // global
           I64[Sp - 8] = block_c9HcD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9He7; else goto c9HcE;
       u9He7: // global
           call _c9HcD(R1) args: 0, res: 0, upd: 0;
       c9HcE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HcD() //  [R1]
         { info_tbl: [(c9HcD,
                       label: block_c9HcD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HcD: // global
           I64[Sp - 16] = block_c9HcI_info;
           _s9FGg::P64 = P64[R1 + 7];
           _s9FGh::P64 = P64[R1 + 15];
           R1 = lvl8_r9Fvj_closure;
           P64[Sp - 8] = _s9FGh::P64;
           P64[Sp] = _s9FGg::P64;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HcI() //  [R1]
         { info_tbl: [(c9HcI,
                       label: block_c9HcI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HcI: // global
           I64[Sp] = block_c9HcK_info;
           R2 = lvl7_r9Fvi_closure+2;
           R1 = R1;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HcK() //  []
         { info_tbl: [(c9HcK,
                       label: block_c9HcK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HcK: // global
           I64[Sp] = block_c9HcM_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HcM() //  [R1]
         { info_tbl: [(c9HcM,
                       label: block_c9HcM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HcM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c9He6; else goto c9He5;
       c9He6: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9He5: // global
           I64[Hp - 40] = msg_s9FGp_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_s9FGJ_info;
           P64[Hp] = Hp - 40;
           R4 = Hp - 6;
           R3 = lvl6_r9Fvh_closure;
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.773437888 UTC

[section ""data" . lvl10_r9Fvl_closure" {
     lvl10_r9Fvl_closure:
         const lvl10_r9Fvl_info;
         const 0;
 },
 lvl10_r9Fvl_entry() //  []
         { info_tbl: [(c9Heh,
                       label: lvl10_r9Fvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Heh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Hei; else goto c9Hej;
       c9Hei: // global
           R1 = lvl10_r9Fvl_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Hej: // global
           I64[Sp - 8] = block_c9Hec_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _c9Hec() //  []
         { info_tbl: [(c9Hec,
                       label: block_c9Hec_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hec: // global
           I64[Sp] = block_c9Hee_info;
           R1 = lvl9_r9Fvk_closure+2;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hee() //  [R1]
         { info_tbl: [(c9Hee,
                       label: block_c9Hee_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hee: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hen; else goto c9Hem;
       c9Hen: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Hem: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.774702241 UTC

[section ""data" . GHC.Conc.Sync.uncaughtExceptionHandler_closure" {
     GHC.Conc.Sync.uncaughtExceptionHandler_closure:
         const GHC.Conc.Sync.uncaughtExceptionHandler_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.uncaughtExceptionHandler_entry() //  [R1]
         { info_tbl: [(c9Hew,
                       label: GHC.Conc.Sync.uncaughtExceptionHandler_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hew: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Hex; else goto c9Hey;
       c9Hex: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Hey: // global
           (_c9Her::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Her::I64 == 0) goto c9Het; else goto c9Hes;
       c9Het: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Hes: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Her::I64;
           I64[Sp - 24] = block_c9Heu_info;
           Sp = Sp - 24;
           call lvl10_r9Fvl_entry() args: 8, res: 8, upd: 24;
     }
 },
 _c9Heu() //  [R1]
         { info_tbl: [(c9Heu,
                       label: block_c9Heu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Heu: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.775812838 UTC

[section ""data" . GHC.Conc.Sync.setUncaughtExceptionHandler1_closure" {
     GHC.Conc.Sync.setUncaughtExceptionHandler1_closure:
         const GHC.Conc.Sync.setUncaughtExceptionHandler1_info;
         const 0;
 },
 GHC.Conc.Sync.setUncaughtExceptionHandler1_entry() //  [R2]
         { info_tbl: [(c9HeE,
                       label: GHC.Conc.Sync.setUncaughtExceptionHandler1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HeE: // global
           R3 = R2;
           R2 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           call GHC.STRef.writeSTRef1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.776599485 UTC

[section ""data" . GHC.Conc.Sync.setUncaughtExceptionHandler_closure" {
     GHC.Conc.Sync.setUncaughtExceptionHandler_closure:
         const GHC.Conc.Sync.setUncaughtExceptionHandler_info;
         const 0;
 },
 GHC.Conc.Sync.setUncaughtExceptionHandler_entry() //  [R2]
         { info_tbl: [(c9HeL,
                       label: GHC.Conc.Sync.setUncaughtExceptionHandler_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HeL: // global
           R2 = R2;
           call GHC.Conc.Sync.setUncaughtExceptionHandler1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.777400961 UTC

[section ""data" . GHC.Conc.Sync.getUncaughtExceptionHandler1_closure" {
     GHC.Conc.Sync.getUncaughtExceptionHandler1_closure:
         const GHC.Conc.Sync.getUncaughtExceptionHandler1_info;
         const 0;
 },
 GHC.Conc.Sync.getUncaughtExceptionHandler1_entry() //  []
         { info_tbl: [(c9HeS,
                       label: GHC.Conc.Sync.getUncaughtExceptionHandler1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HeS: // global
           R2 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           call GHC.STRef.readSTRef1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.778196273 UTC

[section ""data" . GHC.Conc.Sync.getUncaughtExceptionHandler_closure" {
     GHC.Conc.Sync.getUncaughtExceptionHandler_closure:
         const GHC.Conc.Sync.getUncaughtExceptionHandler_info;
         const 0;
 },
 GHC.Conc.Sync.getUncaughtExceptionHandler_entry() //  []
         { info_tbl: [(c9HeZ,
                       label: GHC.Conc.Sync.getUncaughtExceptionHandler_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HeZ: // global
           call GHC.Conc.Sync.getUncaughtExceptionHandler1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.779112603 UTC

[section ""data" . GHC.Conc.Sync.reportError1_closure" {
     GHC.Conc.Sync.reportError1_closure:
         const GHC.Conc.Sync.reportError1_info;
         const 0;
 },
 GHC.Conc.Sync.reportError1_entry() //  [R2]
         { info_tbl: [(c9Hf9,
                       label: GHC.Conc.Sync.reportError1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hf9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Hfa; else goto c9Hfb;
       c9Hfa: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.reportError1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Hfb: // global
           I64[Sp - 16] = block_c9Hf6_info;
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Hff; else goto c9Hf7;
       u9Hff: // global
           call _c9Hf6(R1) args: 0, res: 0, upd: 0;
       c9Hf7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hf6() //  [R1]
         { info_tbl: [(c9Hf6,
                       label: block_c9Hf6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hf6: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.780220798 UTC

[section ""data" . GHC.Conc.Sync.reportError_closure" {
     GHC.Conc.Sync.reportError_closure:
         const GHC.Conc.Sync.reportError_info;
         const 0;
 },
 GHC.Conc.Sync.reportError_entry() //  [R2]
         { info_tbl: [(c9Hfk,
                       label: GHC.Conc.Sync.reportError_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hfk: // global
           R2 = R2;
           call GHC.Conc.Sync.reportError1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.781897446 UTC

[section ""data" . GHC.Conc.Sync.sharedCAF1_closure" {
     GHC.Conc.Sync.sharedCAF1_closure:
         const GHC.Conc.Sync.sharedCAF1_info;
 },
 io_s9FH6_entry() //  [R1]
         { info_tbl: [(c9HfG,
                       label: io_s9FH6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HfG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HfH; else goto c9HfI;
       c9HfH: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9HfI: // global
           I64[Sp - 24] = block_c9Hfy_info;
           _s9FH0::P64 = P64[R1 + 7];
           _s9FH1::P64 = P64[R1 + 15];
           R1 = _s9FH0::P64;
           P64[Sp - 16] = _s9FH0::P64;
           P64[Sp - 8] = _s9FH1::P64;
           Sp = Sp - 24;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hfy() //  [R1]
         { info_tbl: [(c9Hfy,
                       label: block_c9Hfy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hfy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9HfL; else goto c9HfK;
       c9HfL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9HfK: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = R1;
           I64[Sp] = block_c9HfB_info;
           R2 = Hp - 7;
           _s9FHa::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s9FHa::I64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HfB() //  [R1]
         { info_tbl: [(c9HfB,
                       label: block_c9HfB_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HfB: // global
           I64[Sp] = block_c9HfD_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u9HfY; else goto c9HfE;
       u9HfY: // global
           call _c9HfD(R1) args: 0, res: 0, upd: 0;
       c9HfE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HfD() //  [R1]
         { info_tbl: [(c9HfD,
                       label: block_c9HfD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HfD: // global
           _s9FHa::I64 = I64[Sp + 16];
           _s9FHg::I64 = I64[R1 + 7];
           if (_s9FHa::I64 == _s9FHg::I64) goto c9HfU; else goto c9HfT;
       c9HfU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9HfT: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(_s9FHa::I64);
           R1 = _s9FHg::I64;
           Sp = Sp + 24;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.sharedCAF1_entry() //  [R2, R3]
         { info_tbl: [(c9Hg3,
                       label: GHC.Conc.Sync.sharedCAF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hg3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Hg4; else goto c9Hg5;
       c9Hg4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.sharedCAF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Hg5: // global
           I64[Sp - 24] = block_c9Hfr_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c9Hfr() //  [R1]
         { info_tbl: [(c9Hfr,
                       label: block_c9Hfr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hfr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Hg8; else goto c9Hg7;
       c9Hg8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9Hg7: // global
           I64[Hp - 16] = io_s9FH6_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _c9Hft::P64 = Hp - 15;
           if (R1 == 0) goto c9Hg2; else goto c9Hg1;
       c9Hg2: // global
           R1 = _c9Hft::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       c9Hg1: // global
           R1 = _c9Hft::P64;
           Sp = Sp + 24;
           call io_s9FH6_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.784004348 UTC

[section ""data" . GHC.Conc.Sync.sharedCAF_closure" {
     GHC.Conc.Sync.sharedCAF_closure:
         const GHC.Conc.Sync.sharedCAF_info;
 },
 GHC.Conc.Sync.sharedCAF_entry() //  [R2, R3]
         { info_tbl: [(c9Hgd,
                       label: GHC.Conc.Sync.sharedCAF_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hgd: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.sharedCAF1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.787374432 UTC

[section ""data" . GHC.Conc.Sync.$wmodifyMVar__closure" {
     GHC.Conc.Sync.$wmodifyMVar__closure:
         const GHC.Conc.Sync.$wmodifyMVar__info;
 },
 sat_s9FHF_entry() //  [R1]
         { info_tbl: [(c9HgH,
                       label: sat_s9FHF_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HgH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HgI; else goto c9HgJ;
       c9HgI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9HgJ: // global
           I64[Sp - 24] = block_c9HgF_info;
           R2 = P64[R1 + 15];
           _s9FHA::P64 = P64[R1 + 23];
           _s9FHB::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FHA::P64;
           P64[Sp - 8] = _s9FHB::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HgF() //  []
         { info_tbl: [(c9HgF,
                       label: block_c9HgF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HgF: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHG_entry() //  [R1, R2]
         { info_tbl: [(c9HgL,
                       label: sat_s9FHG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HgL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HgM; else goto c9HgN;
       c9HgM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HgN: // global
           I64[Sp - 24] = block_c9Hgv_info;
           _s9FHm::P64 = P64[R1 + 7];
           _s9FHv::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FHm::P64;
           P64[Sp - 8] = _s9FHv::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9HgR; else goto c9Hgw;
       u9HgR: // global
           call _c9Hgv(R1) args: 0, res: 0, upd: 0;
       c9Hgw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hgv() //  [R1]
         { info_tbl: [(c9Hgv,
                       label: block_c9Hgv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hgv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9HgQ; else goto c9HgP;
       c9HgQ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HgP: // global
           _s9FHA::P64 = P64[R1 + 7];
           _s9FHB::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FHF_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FHA::P64;
           P64[Hp] = _s9FHB::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHx_entry() //  [R1]
         { info_tbl: [(c9HgY,
                       label: sat_s9FHx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HgY: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHY_entry() //  [R1]
         { info_tbl: [(c9Hhq,
                       label: sat_s9FHY_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hhq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Hhr; else goto c9Hhs;
       c9Hhr: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Hhs: // global
           I64[Sp - 24] = block_c9Hho_info;
           R2 = P64[R1 + 15];
           _s9FHT::P64 = P64[R1 + 23];
           _s9FHU::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FHT::P64;
           P64[Sp - 8] = _s9FHU::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hho() //  []
         { info_tbl: [(c9Hho,
                       label: block_c9Hho_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hho: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHZ_entry() //  [R1, R2]
         { info_tbl: [(c9Hhu,
                       label: sat_s9FHZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hhu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Hhv; else goto c9Hhw;
       c9Hhv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Hhw: // global
           I64[Sp - 24] = block_c9Hhe_info;
           _s9FHm::P64 = P64[R1 + 7];
           _s9FHO::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FHm::P64;
           P64[Sp - 8] = _s9FHO::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9HhA; else goto c9Hhf;
       u9HhA: // global
           call _c9Hhe(R1) args: 0, res: 0, upd: 0;
       c9Hhf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hhe() //  [R1]
         { info_tbl: [(c9Hhe,
                       label: block_c9Hhe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hhe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9Hhz; else goto c9Hhy;
       c9Hhz: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Hhy: // global
           _s9FHT::P64 = P64[R1 + 7];
           _s9FHU::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FHY_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FHT::P64;
           P64[Hp] = _s9FHU::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHQ_entry() //  [R1]
         { info_tbl: [(c9HhH,
                       label: sat_s9FHQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HhH: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FI4_entry() //  [R1]
         { info_tbl: [(c9HhO,
                       label: sat_s9FI4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HhO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HhP; else goto c9HhQ;
       c9HhP: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9HhQ: // global
           I64[Sp - 24] = block_c9Hh7_info;
           _s9FHm::P64 = P64[R1 + 7];
           _s9FHn::P64 = P64[R1 + 15];
           R1 = _s9FHm::P64;
           P64[Sp - 16] = _s9FHm::P64;
           P64[Sp - 8] = _s9FHn::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hh7() //  [R1]
         { info_tbl: [(c9Hh7,
                       label: block_c9Hh7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hh7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9HhT; else goto c9HhS;
       c9HhT: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HhS: // global
           I64[Hp - 64] = sat_s9FHZ_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FHQ_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9HhK_info;
           R2 = Hp - 63;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HhK() //  [R1]
         { info_tbl: [(c9HhK,
                       label: block_c9HhK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HhK: // global
           I64[Sp + 16] = block_c9HhM_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HhM() //  []
         { info_tbl: [(c9HhM,
                       label: block_c9HhM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HhM: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FIh_entry() //  [R1]
         { info_tbl: [(c9Hig,
                       label: sat_s9FIh_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hig: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Hih; else goto c9Hii;
       c9Hih: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Hii: // global
           I64[Sp - 24] = block_c9Hie_info;
           R2 = P64[R1 + 15];
           _s9FIc::P64 = P64[R1 + 23];
           _s9FId::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FIc::P64;
           P64[Sp - 8] = _s9FId::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hie() //  []
         { info_tbl: [(c9Hie,
                       label: block_c9Hie_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hie: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FIi_entry() //  [R1, R2]
         { info_tbl: [(c9Hik,
                       label: sat_s9FIi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hik: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Hil; else goto c9Him;
       c9Hil: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Him: // global
           I64[Sp - 24] = block_c9Hi4_info;
           _s9FHm::P64 = P64[R1 + 7];
           _s9FI7::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FHm::P64;
           P64[Sp - 8] = _s9FI7::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Hiq; else goto c9Hi5;
       u9Hiq: // global
           call _c9Hi4(R1) args: 0, res: 0, upd: 0;
       c9Hi5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hi4() //  [R1]
         { info_tbl: [(c9Hi4,
                       label: block_c9Hi4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hi4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9Hip; else goto c9Hio;
       c9Hip: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Hio: // global
           _s9FIc::P64 = P64[R1 + 7];
           _s9FId::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FIh_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FIc::P64;
           P64[Hp] = _s9FId::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FI9_entry() //  [R1]
         { info_tbl: [(c9Hix,
                       label: sat_s9FI9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hix: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$wmodifyMVar__entry() //  [R2, R3]
         { info_tbl: [(c9HiE,
                       label: GHC.Conc.Sync.$wmodifyMVar__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HiE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HiF; else goto c9HiG;
       c9HiF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$wmodifyMVar__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HiG: // global
           I64[Sp - 24] = block_c9Hgk_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c9Hgk() //  [R1]
         { info_tbl: [(c9Hgk,
                       label: block_c9Hgk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hgk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9HiJ; else goto c9HiI;
       c9HiJ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9HiI: // global
           _s9FHm::P64 = P64[Sp + 8];
           if (R1 == 0) goto c9HiC; else goto u9Hj2;
       c9HiC: // global
           I64[Hp - 16] = sat_s9FI4_info;
           P64[Hp - 8] = _s9FHm::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u9Hj2: // global
           if (R1 == 1) goto c9HiD; else goto c9HiB;
       c9HiD: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9HhX_info;
           R1 = _s9FHm::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       c9HiB: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9Hgo_info;
           R1 = _s9FHm::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HhX() //  [R1]
         { info_tbl: [(c9HhX,
                       label: block_c9HhX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HhX: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9HiY; else goto c9HiX;
       c9HiY: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HiX: // global
           I64[Hp - 64] = sat_s9FIi_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FI9_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9HiT_info;
           R2 = Hp - 63;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HiT() //  [R1]
         { info_tbl: [(c9HiT,
                       label: block_c9HiT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HiT: // global
           I64[Sp + 16] = block_c9HiV_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hgo() //  [R1]
         { info_tbl: [(c9Hgo,
                       label: block_c9Hgo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hgo: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9HiP; else goto c9HiO;
       c9HiP: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HiO: // global
           I64[Hp - 64] = sat_s9FHG_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FHx_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9HiK_info;
           R2 = Hp - 63;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HiK() //  [R1]
         { info_tbl: [(c9HiK,
                       label: block_c9HiK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HiK: // global
           I64[Sp + 16] = block_c9HiV_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HiV() //  []
         { info_tbl: [(c9HiV,
                       label: block_c9HiV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HiV: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.793889023 UTC

[section ""data" . GHC.Conc.Sync.modifyMVar_1_closure" {
     GHC.Conc.Sync.modifyMVar_1_closure:
         const GHC.Conc.Sync.modifyMVar_1_info;
 },
 GHC.Conc.Sync.modifyMVar_1_entry() //  [R2, R3]
         { info_tbl: [(c9Hja,
                       label: GHC.Conc.Sync.modifyMVar_1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hja: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Hjb; else goto c9Hjc;
       c9Hjb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.modifyMVar_1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Hjc: // global
           I64[Sp - 16] = block_c9Hj7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Hjg; else goto c9Hj8;
       u9Hjg: // global
           call _c9Hj7(R1) args: 0, res: 0, upd: 0;
       c9Hj8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hj7() //  [R1]
         { info_tbl: [(c9Hj7,
                       label: block_c9Hj7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hj7: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$wmodifyMVar__entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.795027685 UTC

[section ""data" . GHC.Conc.Sync.modifyMVar__closure" {
     GHC.Conc.Sync.modifyMVar__closure:
         const GHC.Conc.Sync.modifyMVar__info;
 },
 GHC.Conc.Sync.modifyMVar__entry() //  [R2, R3]
         { info_tbl: [(c9Hjl,
                       label: GHC.Conc.Sync.modifyMVar__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hjl: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.modifyMVar_1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.798350477 UTC

[section ""data" . GHC.Conc.Sync.$wwithMVar_closure" {
     GHC.Conc.Sync.$wwithMVar_closure:
         const GHC.Conc.Sync.$wwithMVar_info;
 },
 sat_s9FIL_entry() //  [R1]
         { info_tbl: [(c9HjP,
                       label: sat_s9FIL_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HjP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HjQ; else goto c9HjR;
       c9HjQ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9HjR: // global
           I64[Sp - 24] = block_c9HjN_info;
           R2 = P64[R1 + 15];
           _s9FIG::P64 = P64[R1 + 23];
           _s9FIH::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FIG::P64;
           P64[Sp - 8] = _s9FIH::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HjN() //  []
         { info_tbl: [(c9HjN,
                       label: block_c9HjN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HjN: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FIM_entry() //  [R1, R2]
         { info_tbl: [(c9HjT,
                       label: sat_s9FIM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HjT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HjU; else goto c9HjV;
       c9HjU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HjV: // global
           I64[Sp - 24] = block_c9HjD_info;
           _s9FIs::P64 = P64[R1 + 7];
           _s9FIB::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FIs::P64;
           P64[Sp - 8] = _s9FIB::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9HjZ; else goto c9HjE;
       u9HjZ: // global
           call _c9HjD(R1) args: 0, res: 0, upd: 0;
       c9HjE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HjD() //  [R1]
         { info_tbl: [(c9HjD,
                       label: block_c9HjD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HjD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9HjY; else goto c9HjX;
       c9HjY: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HjX: // global
           _s9FIG::P64 = P64[R1 + 7];
           _s9FIH::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FIL_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FIG::P64;
           P64[Hp] = _s9FIH::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FID_entry() //  [R1]
         { info_tbl: [(c9Hk6,
                       label: sat_s9FID_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hk6: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJ4_entry() //  [R1]
         { info_tbl: [(c9Hky,
                       label: sat_s9FJ4_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hky: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Hkz; else goto c9HkA;
       c9Hkz: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9HkA: // global
           I64[Sp - 24] = block_c9Hkw_info;
           R2 = P64[R1 + 15];
           _s9FIZ::P64 = P64[R1 + 23];
           _s9FJ0::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FIZ::P64;
           P64[Sp - 8] = _s9FJ0::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hkw() //  []
         { info_tbl: [(c9Hkw,
                       label: block_c9Hkw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hkw: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJ5_entry() //  [R1, R2]
         { info_tbl: [(c9HkC,
                       label: sat_s9FJ5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HkC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HkD; else goto c9HkE;
       c9HkD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HkE: // global
           I64[Sp - 24] = block_c9Hkm_info;
           _s9FIs::P64 = P64[R1 + 7];
           _s9FIU::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FIs::P64;
           P64[Sp - 8] = _s9FIU::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9HkI; else goto c9Hkn;
       u9HkI: // global
           call _c9Hkm(R1) args: 0, res: 0, upd: 0;
       c9Hkn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hkm() //  [R1]
         { info_tbl: [(c9Hkm,
                       label: block_c9Hkm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hkm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9HkH; else goto c9HkG;
       c9HkH: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HkG: // global
           _s9FIZ::P64 = P64[R1 + 7];
           _s9FJ0::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FJ4_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FIZ::P64;
           P64[Hp] = _s9FJ0::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FIW_entry() //  [R1]
         { info_tbl: [(c9HkP,
                       label: sat_s9FIW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HkP: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJa_entry() //  [R1]
         { info_tbl: [(c9HkW,
                       label: sat_s9FJa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HkW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HkX; else goto c9HkY;
       c9HkX: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9HkY: // global
           I64[Sp - 24] = block_c9Hkf_info;
           _s9FIs::P64 = P64[R1 + 7];
           _s9FIt::P64 = P64[R1 + 15];
           R1 = _s9FIs::P64;
           P64[Sp - 16] = _s9FIs::P64;
           P64[Sp - 8] = _s9FIt::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hkf() //  [R1]
         { info_tbl: [(c9Hkf,
                       label: block_c9Hkf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hkf: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9Hl1; else goto c9Hl0;
       c9Hl1: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Hl0: // global
           I64[Hp - 64] = sat_s9FJ5_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FIW_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9HkS_info;
           R2 = Hp - 63;
           _s9FIU::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s9FIU::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HkS() //  [R1]
         { info_tbl: [(c9HkS,
                       label: block_c9HkS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HkS: // global
           _s9FIs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9HkU_info;
           R2 = P64[Sp + 16];
           _s9FJ8::P64 = R1;
           R1 = _s9FIs::P64;
           P64[Sp + 16] = _s9FJ8::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HkU() //  []
         { info_tbl: [(c9HkU,
                       label: block_c9HkU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HkU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJn_entry() //  [R1]
         { info_tbl: [(c9Hlo,
                       label: sat_s9FJn_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hlo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Hlp; else goto c9Hlq;
       c9Hlp: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Hlq: // global
           I64[Sp - 24] = block_c9Hlm_info;
           R2 = P64[R1 + 15];
           _s9FJi::P64 = P64[R1 + 23];
           _s9FJj::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FJi::P64;
           P64[Sp - 8] = _s9FJj::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hlm() //  []
         { info_tbl: [(c9Hlm,
                       label: block_c9Hlm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hlm: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJo_entry() //  [R1, R2]
         { info_tbl: [(c9Hls,
                       label: sat_s9FJo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hls: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Hlt; else goto c9Hlu;
       c9Hlt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Hlu: // global
           I64[Sp - 24] = block_c9Hlc_info;
           _s9FIs::P64 = P64[R1 + 7];
           _s9FJd::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FIs::P64;
           P64[Sp - 8] = _s9FJd::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Hly; else goto c9Hld;
       u9Hly: // global
           call _c9Hlc(R1) args: 0, res: 0, upd: 0;
       c9Hld: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hlc() //  [R1]
         { info_tbl: [(c9Hlc,
                       label: block_c9Hlc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hlc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9Hlx; else goto c9Hlw;
       c9Hlx: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Hlw: // global
           _s9FJi::P64 = P64[R1 + 7];
           _s9FJj::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FJn_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FJi::P64;
           P64[Hp] = _s9FJj::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJf_entry() //  [R1]
         { info_tbl: [(c9HlF,
                       label: sat_s9FJf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HlF: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$wwithMVar_entry() //  [R2, R3]
         { info_tbl: [(c9HlM,
                       label: GHC.Conc.Sync.$wwithMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HlM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HlN; else goto c9HlO;
       c9HlN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$wwithMVar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HlO: // global
           I64[Sp - 24] = block_c9Hjs_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c9Hjs() //  [R1]
         { info_tbl: [(c9Hjs,
                       label: block_c9Hjs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hjs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9HlR; else goto c9HlQ;
       c9HlR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9HlQ: // global
           _s9FIs::P64 = P64[Sp + 8];
           if (R1 == 0) goto c9HlK; else goto u9Hma;
       c9HlK: // global
           I64[Hp - 16] = sat_s9FJa_info;
           P64[Hp - 8] = _s9FIs::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u9Hma: // global
           if (R1 == 1) goto c9HlL; else goto c9HlJ;
       c9HlL: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9Hl5_info;
           R1 = _s9FIs::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       c9HlJ: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9Hjw_info;
           R1 = _s9FIs::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hl5() //  [R1]
         { info_tbl: [(c9Hl5,
                       label: block_c9Hl5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hl5: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9Hm6; else goto c9Hm5;
       c9Hm6: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Hm5: // global
           I64[Hp - 64] = sat_s9FJo_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FJf_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9Hm1_info;
           R2 = Hp - 63;
           _s9FJd::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s9FJd::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hm1() //  [R1]
         { info_tbl: [(c9Hm1,
                       label: block_c9Hm1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hm1: // global
           _s9FIs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9Hm3_info;
           R2 = P64[Sp + 16];
           _s9FJr::P64 = R1;
           R1 = _s9FIs::P64;
           P64[Sp + 16] = _s9FJr::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hm3() //  []
         { info_tbl: [(c9Hm3,
                       label: block_c9Hm3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hm3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Hjw() //  [R1]
         { info_tbl: [(c9Hjw,
                       label: block_c9Hjw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hjw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9HlX; else goto c9HlW;
       c9HlX: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HlW: // global
           I64[Hp - 64] = sat_s9FIM_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FID_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9HlS_info;
           R2 = Hp - 63;
           _s9FIB::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s9FIB::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HlS() //  [R1]
         { info_tbl: [(c9HlS,
                       label: block_c9HlS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HlS: // global
           _s9FIs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9HlU_info;
           R2 = P64[Sp + 16];
           _s9FIP::P64 = R1;
           R1 = _s9FIs::P64;
           P64[Sp + 16] = _s9FIP::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HlU() //  []
         { info_tbl: [(c9HlU,
                       label: block_c9HlU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HlU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.804995082 UTC

[section ""data" . GHC.Conc.Sync.withMVar1_closure" {
     GHC.Conc.Sync.withMVar1_closure:
         const GHC.Conc.Sync.withMVar1_info;
 },
 GHC.Conc.Sync.withMVar1_entry() //  [R2, R3]
         { info_tbl: [(c9Hmi,
                       label: GHC.Conc.Sync.withMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hmi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Hmj; else goto c9Hmk;
       c9Hmj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.withMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Hmk: // global
           I64[Sp - 16] = block_c9Hmf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Hmo; else goto c9Hmg;
       u9Hmo: // global
           call _c9Hmf(R1) args: 0, res: 0, upd: 0;
       c9Hmg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hmf() //  [R1]
         { info_tbl: [(c9Hmf,
                       label: block_c9Hmf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hmf: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.806136239 UTC

[section ""data" . GHC.Conc.Sync.withMVar_closure" {
     GHC.Conc.Sync.withMVar_closure:
         const GHC.Conc.Sync.withMVar_info;
 },
 GHC.Conc.Sync.withMVar_entry() //  [R2, R3]
         { info_tbl: [(c9Hmt,
                       label: GHC.Conc.Sync.withMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hmt: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.withMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.806960315 UTC

[section ""data" . GHC.Conc.Sync.reportStackOverflow1_closure" {
     GHC.Conc.Sync.reportStackOverflow1_closure:
         const GHC.Conc.Sync.reportStackOverflow1_info;
 },
 GHC.Conc.Sync.reportStackOverflow1_entry() //  []
         { info_tbl: [(c9HmC,
                       label: GHC.Conc.Sync.reportStackOverflow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HmC: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] reportStackOverflow(CurrentTSO);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.807758187 UTC

[section ""data" . GHC.Conc.Sync.reportStackOverflow_closure" {
     GHC.Conc.Sync.reportStackOverflow_closure:
         const GHC.Conc.Sync.reportStackOverflow_info;
 },
 GHC.Conc.Sync.reportStackOverflow_entry() //  []
         { info_tbl: [(c9HmJ,
                       label: GHC.Conc.Sync.reportStackOverflow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HmJ: // global
           call GHC.Conc.Sync.reportStackOverflow1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.81086957 UTC

[section ""data" . GHC.Conc.Sync.forkIO2_closure" {
     GHC.Conc.Sync.forkIO2_closure:
         const GHC.Conc.Sync.forkIO2_info;
         const 0;
 },
 GHC.Conc.Sync.forkIO2_entry() //  [R2]
         { info_tbl: [(c9HmQ,
                       label: GHC.Conc.Sync.forkIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HmQ: // global
           R2 = R2;
           call GHC.Conc.Sync.childHandler1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Conc.Sync.childHandler1_closure" {
     GHC.Conc.Sync.childHandler1_closure:
         const GHC.Conc.Sync.childHandler1_info;
         const 0;
 },
 sat_s9FK0_entry() //  [R1]
         { info_tbl: [(c9HnL,
                       label: sat_s9FK0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HnL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HnM; else goto c9HnN;
       c9HnM: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9HnN: // global
           I64[Sp - 16] = block_c9HnI_info;
           _s9FJJ::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = _s9FJJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HnR; else goto c9HnJ;
       u9HnR: // global
           call _c9HnI(R1) args: 0, res: 0, upd: 0;
       c9HnJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HnI() //  [R1]
         { info_tbl: [(c9HnI,
                       label: block_c9HnI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HnI: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKc_entry() //  [R1]
         { info_tbl: [(c9Hoe,
                       label: sat_s9FKc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hoe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Hof; else goto c9Hog;
       c9Hof: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Hog: // global
           I64[Sp - 16] = block_c9Hob_info;
           _s9FJJ::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = _s9FJJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Hok; else goto c9Hoc;
       u9Hok: // global
           call _c9Hob(R1) args: 0, res: 0, upd: 0;
       c9Hoc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hob() //  [R1]
         { info_tbl: [(c9Hob,
                       label: block_c9Hob_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hob: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKk_entry() //  [R1]
         { info_tbl: [(c9Hoz,
                       label: sat_s9FKk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hoz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HoA; else goto c9HoB;
       c9HoA: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9HoB: // global
           I64[Sp - 16] = block_c9How_info;
           _s9FJJ::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = _s9FJJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HoF; else goto c9Hox;
       u9HoF: // global
           call _c9How(R1) args: 0, res: 0, upd: 0;
       c9Hox: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9How() //  [R1]
         { info_tbl: [(c9How,
                       label: block_c9How_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9How: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKv_entry() //  [R1]
         { info_tbl: [(c9HoG,
                       label: sat_s9FKv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HoG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9HoH; else goto c9HoI;
       c9HoH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9HoI: // global
           I64[Sp - 8] = block_c9Hn1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Hqu; else goto c9Hn2;
       u9Hqu: // global
           call _c9Hn1(R1) args: 0, res: 0, upd: 0;
       c9Hn2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hn1() //  [R1]
         { info_tbl: [(c9Hn1,
                       label: block_c9Hn1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hn1: // global
           I64[Sp - 24] = block_c9Hn6_info;
           _s9FJK::P64 = P64[R1 + 7];
           R2 = _s9FJK::P64;
           P64[Sp - 16] = _s9FJK::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 24;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hn6() //  [R1]
         { info_tbl: [(c9Hn6,
                       label: block_c9Hn6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hn6: // global
           I64[Sp] = block_c9Hna_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hna() //  [R1]
         { info_tbl: [(c9Hna,
                       label: block_c9Hna_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hna: // global
           if (R1 & 7 == 1) goto c9HoN; else goto c9Hqe;
       c9HoN: // global
           I64[Sp] = block_c9Hne_info;
           R2 = P64[Sp + 8];
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       c9Hqe: // global
           I64[Sp + 24] = block_c9Hqc_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hne() //  [R1]
         { info_tbl: [(c9Hne,
                       label: block_c9Hne_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hne: // global
           I64[Sp] = block_c9Hni_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hni() //  [R1]
         { info_tbl: [(c9Hni,
                       label: block_c9Hni_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hni: // global
           if (R1 & 7 == 1) goto c9HoR; else goto c9Hq5;
       c9HoR: // global
           I64[Sp] = block_c9Hnm_info;
           R2 = P64[Sp + 8];
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       c9Hq5: // global
           I64[Sp + 24] = block_c9Hq3_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hnm() //  [R1]
         { info_tbl: [(c9Hnm,
                       label: block_c9Hnm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hnm: // global
           I64[Sp] = block_c9HoS_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9HoS() //  [R1]
         { info_tbl: [(c9HoS,
                       label: block_c9HoS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HoS: // global
           if (R1 & 7 == 1) goto u9Hqr; else goto c9Hpz;
       u9Hqr: // global
           Sp = Sp + 8;
           call _s9FJQ() args: 0, res: 0, upd: 0;
       c9Hpz: // global
           I64[Sp] = block_c9Hpt_info;
           R1 = P64[Sp + 16];
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hpt() //  [R1]
         { info_tbl: [(c9Hpt,
                       label: block_c9Hpt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hpt: // global
           I64[Sp - 8] = block_c9Hpx_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hpx() //  [R1]
         { info_tbl: [(c9Hpx,
                       label: block_c9Hpx_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hpx: // global
           I64[Sp] = block_c9HpE_info;
           R3 = GHC.IO.Exception.$fExceptionAsyncException9_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9HpE() //  [R1]
         { info_tbl: [(c9HpE,
                       label: block_c9HpE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HpE: // global
           if (R1 & 7 == 1) goto u9Hqs; else goto c9HpQ;
       u9Hqs: // global
           Sp = Sp + 16;
           call _s9FJQ() args: 0, res: 0, upd: 0;
       c9HpQ: // global
           _s9FKp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9HpO_info;
           R1 = _s9FKp::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HpO() //  [R1]
         { info_tbl: [(c9HpO,
                       label: block_c9HpO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HpO: // global
           if (R1 & 7 == 3) goto c9Hq0; else goto u9Hqt;
       c9Hq0: // global
           R1 = GHC.Conc.Sync.always2_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9Hqt: // global
           Sp = Sp + 8;
           call _s9FJQ() args: 0, res: 0, upd: 0;
     }
 },
 _s9FJQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s9FJQ: // global
           _s9FJK::P64 = P64[Sp];
           I64[Sp] = block_c9Hnv_info;
           R2 = _s9FJK::P64;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hnv() //  [R1]
         { info_tbl: [(c9Hnv,
                       label: block_c9Hnv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hnv: // global
           I64[Sp] = block_c9Hnz_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hnz() //  [R1]
         { info_tbl: [(c9Hnz,
                       label: block_c9Hnz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hnz: // global
           if (R1 & 7 == 1) goto c9HoX; else goto c9Hp2;
       c9HoX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hp0; else goto c9HoZ;
       c9Hp0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HoZ: // global
           I64[Hp - 8] = sat_s9FK0_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Hp2: // global
           _s9FJL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9HnU_info;
           R1 = _s9FJL::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HnU() //  [R1]
         { info_tbl: [(c9HnU,
                       label: block_c9HnU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HnU: // global
           I64[Sp - 8] = block_c9HnY_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9HnY() //  [R1]
         { info_tbl: [(c9HnY,
                       label: block_c9HnY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HnY: // global
           I64[Sp] = block_c9Ho2_info;
           R3 = GHC.IO.Exception.$fExceptionAsyncException9_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ho2() //  [R1]
         { info_tbl: [(c9Ho2,
                       label: block_c9Ho2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ho2: // global
           if (R1 & 7 == 1) goto c9Hp6; else goto c9Hpb;
       c9Hp6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hp9; else goto c9Hp8;
       c9Hp9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Hp8: // global
           I64[Hp - 8] = sat_s9FKc_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Hpb: // global
           _s9FK3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9Hon_info;
           R1 = _s9FK3::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hon() //  [R1]
         { info_tbl: [(c9Hon,
                       label: block_c9Hon_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hon: // global
           if (R1 & 7 == 1) goto c9Hpk; else goto c9Hpd;
       c9Hpk: // global
           R1 = GHC.Conc.Sync.reportStackOverflow1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Hpd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hpg; else goto c9Hpf;
       c9Hpg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Hpf: // global
           I64[Hp - 8] = sat_s9FKk_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Hq3() //  []
         { info_tbl: [(c9Hq3,
                       label: block_c9Hq3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hq3: // global
           R1 = GHC.Conc.Sync.always2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Hqc() //  []
         { info_tbl: [(c9Hqc,
                       label: block_c9Hqc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hqc: // global
           R1 = GHC.Conc.Sync.always2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.childHandler1_entry() //  [R2]
         { info_tbl: [(c9Hqy,
                       label: GHC.Conc.Sync.childHandler1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hqy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9HqC; else goto c9HqB;
       c9HqC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Conc.Sync.childHandler1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HqB: // global
           I64[Hp - 16] = sat_s9FKv_info;
           P64[Hp] = R2;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.816711762 UTC

[section ""data" . GHC.Conc.Sync.childHandler_closure" {
     GHC.Conc.Sync.childHandler_closure:
         const GHC.Conc.Sync.childHandler_info;
         const 0;
 },
 GHC.Conc.Sync.childHandler_entry() //  [R2]
         { info_tbl: [(c9HqH,
                       label: GHC.Conc.Sync.childHandler_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HqH: // global
           R2 = R2;
           call GHC.Conc.Sync.childHandler1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.817894514 UTC

[section ""data" . GHC.Conc.Sync.forkOn1_closure" {
     GHC.Conc.Sync.forkOn1_closure:
         const GHC.Conc.Sync.forkOn1_info;
         const 0;
 },
 sat_s9FKC_entry() //  [R1]
         { info_tbl: [(c9HqY,
                       label: sat_s9FKC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HqY: // global
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = P64[R1 + 7];
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkOn1_entry() //  [R2, R3]
         { info_tbl: [(c9Hr1,
                       label: GHC.Conc.Sync.forkOn1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hr1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Hr5; else goto c9Hr6;
       c9Hr5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.forkOn1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Hr6: // global
           I64[Sp - 16] = block_c9HqO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Hrd; else goto c9HqP;
       u9Hrd: // global
           call _c9HqO(R1) args: 0, res: 0, upd: 0;
       c9HqP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HqO() //  [R1]
         { info_tbl: [(c9HqO,
                       label: block_c9HqO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HqO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hr9; else goto c9Hr8;
       c9Hr9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Hr8: // global
           _s9FKA::I64 = I64[R1 + 7];
           I64[Hp - 8] = sat_s9FKC_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c9Hr2_info;
           R2 = Hp - 7;
           R1 = _s9FKA::I64;
           Sp = Sp + 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hr2() //  [R1]
         { info_tbl: [(c9Hr2,
                       label: block_c9Hr2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hr2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hrc; else goto c9Hrb;
       c9Hrc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Hrb: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.819468315 UTC

[section ""data" . GHC.Conc.Sync.forkOn_closure" {
     GHC.Conc.Sync.forkOn_closure:
         const GHC.Conc.Sync.forkOn_info;
         const 0;
 },
 GHC.Conc.Sync.forkOn_entry() //  [R2, R3]
         { info_tbl: [(c9Hri,
                       label: GHC.Conc.Sync.forkOn_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hri: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.forkOn1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.820902916 UTC

[section ""data" . GHC.Conc.Sync.forkOnWithUnmask1_closure" {
     GHC.Conc.Sync.forkOnWithUnmask1_closure:
         const GHC.Conc.Sync.forkOnWithUnmask1_info;
         const 0;
 },
 sat_s9FKN_entry() //  [R2]
         { info_tbl: [(c9HrI,
                       label: sat_s9FKN_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HrI: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKO_entry() //  [R1]
         { info_tbl: [(c9HrL,
                       label: sat_s9FKO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HrL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9HrP; else goto c9HrO;
       c9HrP: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9HrO: // global
           _s9FKI::P64 = P64[R1 + 16];
           I64[Hp - 8] = sat_s9FKN_info;
           R2 = Hp - 6;
           R1 = _s9FKI::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKP_entry() //  [R1]
         { info_tbl: [(c9HrQ,
                       label: sat_s9FKP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HrQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9HrU; else goto c9HrT;
       c9HrU: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9HrT: // global
           _s9FKI::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_s9FKO_info;
           P64[Hp] = _s9FKI::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkOnWithUnmask1_entry() //  [R2, R3]
         { info_tbl: [(c9HrV,
                       label: GHC.Conc.Sync.forkOnWithUnmask1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HrV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HrZ; else goto c9Hs0;
       c9HrZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.forkOnWithUnmask1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Hs0: // global
           I64[Sp - 16] = block_c9Hrp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Hs7; else goto c9Hrq;
       u9Hs7: // global
           call _c9Hrp(R1) args: 0, res: 0, upd: 0;
       c9Hrq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hrp() //  [R1]
         { info_tbl: [(c9Hrp,
                       label: block_c9Hrp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hrp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hs3; else goto c9Hs2;
       c9Hs3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Hs2: // global
           _s9FKL::I64 = I64[R1 + 7];
           I64[Hp - 8] = sat_s9FKP_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c9HrW_info;
           R2 = Hp - 7;
           R1 = _s9FKL::I64;
           Sp = Sp + 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HrW() //  [R1]
         { info_tbl: [(c9HrW,
                       label: block_c9HrW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HrW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hs6; else goto c9Hs5;
       c9Hs6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Hs5: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.823012552 UTC

[section ""data" . GHC.Conc.Sync.forkOnWithUnmask_closure" {
     GHC.Conc.Sync.forkOnWithUnmask_closure:
         const GHC.Conc.Sync.forkOnWithUnmask_info;
         const 0;
 },
 GHC.Conc.Sync.forkOnWithUnmask_entry() //  [R2, R3]
         { info_tbl: [(c9Hsc,
                       label: GHC.Conc.Sync.forkOnWithUnmask_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hsc: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.forkOnWithUnmask1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.82405349 UTC

[section ""data" . GHC.Conc.Sync.forkIO1_closure" {
     GHC.Conc.Sync.forkIO1_closure:
         const GHC.Conc.Sync.forkIO1_info;
         const 0;
 },
 sat_s9FKX_entry() //  [R1]
         { info_tbl: [(c9Hso,
                       label: sat_s9FKX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hso: // global
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = P64[R1 + 7];
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkIO1_entry() //  [R2]
         { info_tbl: [(c9Hsu,
                       label: GHC.Conc.Sync.forkIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hsu: // global
           _s9FKU::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c9Hsv; else goto c9Hsw;
       c9Hsw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hsy; else goto c9Hsx;
       c9Hsy: // global
           HpAlloc = 16;
           goto c9Hsv;
       c9Hsv: // global
           R2 = _s9FKU::P64;
           R1 = GHC.Conc.Sync.forkIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Hsx: // global
           I64[Hp - 8] = sat_s9FKX_info;
           P64[Hp] = _s9FKU::P64;
           I64[Sp - 8] = block_c9Hsr_info;
           R1 = Hp - 7;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hsr() //  [R1]
         { info_tbl: [(c9Hsr,
                       label: block_c9Hsr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hsr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9HsB; else goto c9HsA;
       c9HsB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HsA: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.825363131 UTC

[section ""data" . GHC.Conc.Sync.forkIO_closure" {
     GHC.Conc.Sync.forkIO_closure:
         const GHC.Conc.Sync.forkIO_info;
         const 0;
 },
 GHC.Conc.Sync.forkIO_entry() //  [R2]
         { info_tbl: [(c9HsG,
                       label: GHC.Conc.Sync.forkIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HsG: // global
           R2 = R2;
           call GHC.Conc.Sync.forkIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.826685356 UTC

[section ""data" . GHC.Conc.Sync.forkIOWithUnmask1_closure" {
     GHC.Conc.Sync.forkIOWithUnmask1_closure:
         const GHC.Conc.Sync.forkIOWithUnmask1_info;
         const 0;
 },
 sat_s9FL5_entry() //  [R2]
         { info_tbl: [(c9Ht1,
                       label: sat_s9FL5_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ht1: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FL6_entry() //  [R1]
         { info_tbl: [(c9Ht4,
                       label: sat_s9FL6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ht4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Ht8; else goto c9Ht7;
       c9Ht8: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Ht7: // global
           _s9FL2::P64 = P64[R1 + 16];
           I64[Hp - 8] = sat_s9FL5_info;
           R2 = Hp - 6;
           R1 = _s9FL2::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FL7_entry() //  [R1]
         { info_tbl: [(c9Ht9,
                       label: sat_s9FL7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ht9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Htd; else goto c9Htc;
       c9Htd: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Htc: // global
           _s9FL2::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_s9FL6_info;
           P64[Hp] = _s9FL2::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkIOWithUnmask1_entry() //  [R2]
         { info_tbl: [(c9Hth,
                       label: GHC.Conc.Sync.forkIOWithUnmask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hth: // global
           _s9FL2::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c9Hti; else goto c9Htj;
       c9Htj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Htl; else goto c9Htk;
       c9Htl: // global
           HpAlloc = 16;
           goto c9Hti;
       c9Hti: // global
           R2 = _s9FL2::P64;
           R1 = GHC.Conc.Sync.forkIOWithUnmask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Htk: // global
           I64[Hp - 8] = sat_s9FL7_info;
           P64[Hp] = _s9FL2::P64;
           I64[Sp - 8] = block_c9Hte_info;
           R1 = Hp - 7;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hte() //  [R1]
         { info_tbl: [(c9Hte,
                       label: block_c9Hte_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hte: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hto; else goto c9Htn;
       c9Hto: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Htn: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.828459339 UTC

[section ""data" . GHC.Conc.Sync.forkIOWithUnmask_closure" {
     GHC.Conc.Sync.forkIOWithUnmask_closure:
         const GHC.Conc.Sync.forkIOWithUnmask_info;
         const 0;
 },
 GHC.Conc.Sync.forkIOWithUnmask_entry() //  [R2]
         { info_tbl: [(c9Htt,
                       label: GHC.Conc.Sync.forkIOWithUnmask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Htt: // global
           R2 = R2;
           call GHC.Conc.Sync.forkIOWithUnmask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.82919174 UTC

[section ""cstring" . lvl11_r9Fvm_bytes" {
     lvl11_r9Fvm_bytes:
         I8[] [115,101,116,78,117,109,67,97,112,97,98,105,108,105,116,105,101,115,58,32,67,97,112,97,98,105,108,105,116,121,32,99,111,117,110,116,32,40]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.829960234 UTC

[section ""cstring" . lvl12_r9Fvn_bytes" {
     lvl12_r9Fvn_bytes:
         I8[] [41,32,109,117,115,116,32,98,101,32,112,111,115,105,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.830665333 UTC

[section ""data" . lvl13_r9Fvo_closure" {
     lvl13_r9Fvo_closure:
         const lvl13_r9Fvo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_r9Fvo_entry() //  [R1]
         { info_tbl: [(c9HtC,
                       label: lvl13_r9Fvo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HtC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HtD; else goto c9HtE;
       c9HtD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9HtE: // global
           (_c9Htz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Htz::I64 == 0) goto c9HtB; else goto c9HtA;
       c9HtB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9HtA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Htz::I64;
           R2 = lvl12_r9Fvn_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.832013965 UTC

[section ""data" . GHC.Conc.Sync.$wlvl_closure" {
     GHC.Conc.Sync.$wlvl_closure:
         const GHC.Conc.Sync.$wlvl_info;
         const 0;
 },
 sat_s9FLi_entry() //  [R1]
         { info_tbl: [(c9HtQ,
                       label: sat_s9FLi_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HtQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HtR; else goto c9HtS;
       c9HtR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9HtS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9HtN_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9HtN() //  [R1, R2]
         { info_tbl: [(c9HtN,
                       label: block_c9HtN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HtN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9HtV; else goto c9HtU;
       c9HtV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9HtU: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl13_r9Fvo_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$wlvl_entry() //  [R2]
         { info_tbl: [(c9HtY,
                       label: GHC.Conc.Sync.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HtY: // global
           _s9FLc::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c9HtZ; else goto c9Hu0;
       c9Hu0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Hu2; else goto c9Hu1;
       c9Hu2: // global
           HpAlloc = 24;
           goto c9HtZ;
       c9HtZ: // global
           R2 = _s9FLc::I64;
           R1 = GHC.Conc.Sync.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Hu1: // global
           I64[Hp - 16] = sat_s9FLi_info;
           I64[Hp] = _s9FLc::I64;
           I64[Sp - 8] = block_c9HtW_info;
           R3 = Hp - 16;
           R2 = lvl11_r9Fvm_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9HtW() //  [R1]
         { info_tbl: [(c9HtW,
                       label: block_c9HtW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HtW: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.833679867 UTC

[section ""data" . GHC.Conc.Sync.setNumCapabilities2_closure" {
     GHC.Conc.Sync.setNumCapabilities2_closure:
         const GHC.Conc.Sync.setNumCapabilities2_info;
         const 0;
 },
 GHC.Conc.Sync.setNumCapabilities2_entry() //  [R2]
         { info_tbl: [(c9Hud,
                       label: GHC.Conc.Sync.setNumCapabilities2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hud: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Hue; else goto c9Huf;
       c9Hue: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.setNumCapabilities2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Huf: // global
           I64[Sp - 8] = block_c9Hua_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Huj; else goto c9Hub;
       u9Huj: // global
           call _c9Hua(R1) args: 0, res: 0, upd: 0;
       c9Hub: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hua() //  [R1]
         { info_tbl: [(c9Hua,
                       label: block_c9Hua_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hua: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.835080289 UTC

[section ""data" . GHC.Conc.Sync.setNumCapabilities1_closure" {
     GHC.Conc.Sync.setNumCapabilities1_closure:
         const GHC.Conc.Sync.setNumCapabilities1_info;
         const 0;
 },
 GHC.Conc.Sync.setNumCapabilities1_entry() //  [R2]
         { info_tbl: [(c9Hur,
                       label: GHC.Conc.Sync.setNumCapabilities1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hur: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Hus; else goto c9Hut;
       c9Hus: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.setNumCapabilities1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Hut: // global
           I64[Sp - 8] = block_c9Huo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9HuY; else goto c9Hup;
       u9HuY: // global
           call _c9Huo(R1) args: 0, res: 0, upd: 0;
       c9Hup: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Huo() //  [R1]
         { info_tbl: [(c9Huo,
                       label: block_c9Huo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Huo: // global
           _s9FLr::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s9FLr::I64, 0)) goto c9HuA; else goto c9HuN;
       c9HuA: // global
           I64[Sp] = block_c9HuK_info;
           _u9HuQ::P64 = CurrentTSO;
           I64[I64[_u9HuQ::P64 + 24] + 16] = Sp;
           _u9HuR::I64 = CurrentNursery;
           P64[_u9HuR::I64 + 8] = Hp + 8;
           I64[_u9HuQ::P64 + 104] = I64[_u9HuQ::P64 + 104] - ((Hp + 8) - I64[_u9HuR::I64]);
           (_u9HuO::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  []  result hints:  [] setNumCapabilities(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s9FLr::I64)));
           (_u9HuP::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_u9HuO::I64);
           BaseReg = _u9HuP::I64;
           _u9HuS::P64 = CurrentTSO;
           _u9HuT::P64 = I64[_u9HuS::P64 + 24];
           Sp = I64[_u9HuT::P64 + 16];
           SpLim = _u9HuT::P64 + 192;
           HpAlloc = 0;
           _u9HuU::I64 = CurrentNursery;
           _u9HuV::I64 = I64[_u9HuU::I64 + 8];
           Hp = _u9HuV::I64 - 8;
           _u9HuW::I64 = I64[_u9HuU::I64];
           HpLim = _u9HuW::I64 + ((%MO_SS_Conv_W32_W64(I32[_u9HuU::I64 + 48]) << 12) - 1);
           I64[_u9HuS::P64 + 104] = I64[_u9HuS::P64 + 104] + (_u9HuV::I64 - _u9HuW::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
       c9HuN: // global
           R2 = _s9FLr::I64;
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c9HuK() //  []
         { info_tbl: [(c9HuK,
                       label: block_c9HuK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HuK: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.836751164 UTC

[section ""data" . GHC.Conc.Sync.setNumCapabilities_closure" {
     GHC.Conc.Sync.setNumCapabilities_closure:
         const GHC.Conc.Sync.setNumCapabilities_info;
         const 0;
 },
 GHC.Conc.Sync.setNumCapabilities_entry() //  [R2]
         { info_tbl: [(c9Hv3,
                       label: GHC.Conc.Sync.setNumCapabilities_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hv3: // global
           R2 = R2;
           call GHC.Conc.Sync.setNumCapabilities1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.837672957 UTC

[section ""data" . GHC.Conc.Sync.getNumCapabilities1_closure" {
     GHC.Conc.Sync.getNumCapabilities1_closure:
         const GHC.Conc.Sync.getNumCapabilities1_info;
 },
 GHC.Conc.Sync.getNumCapabilities1_entry() //  []
         { info_tbl: [(c9Hvb,
                       label: GHC.Conc.Sync.getNumCapabilities1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hvb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hvf; else goto c9Hve;
       c9Hvf: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.getNumCapabilities1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Hve: // global
           _s9FLB::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s9FLB::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.83860472 UTC

[section ""data" . GHC.Conc.Sync.getNumCapabilities_closure" {
     GHC.Conc.Sync.getNumCapabilities_closure:
         const GHC.Conc.Sync.getNumCapabilities_info;
 },
 GHC.Conc.Sync.getNumCapabilities_entry() //  []
         { info_tbl: [(c9Hvk,
                       label: GHC.Conc.Sync.getNumCapabilities_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hvk: // global
           call GHC.Conc.Sync.getNumCapabilities1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.839476072 UTC

[section ""data" . GHC.Conc.Sync.numCapabilities1_closure" {
     GHC.Conc.Sync.numCapabilities1_closure:
         const GHC.Conc.Sync.numCapabilities1_info;
 },
 GHC.Conc.Sync.numCapabilities1_entry() //  []
         { info_tbl: [(c9Hvu,
                       label: GHC.Conc.Sync.numCapabilities1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hvu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Hvv; else goto c9Hvw;
       c9Hvv: // global
           R1 = GHC.Conc.Sync.numCapabilities1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Hvw: // global
           I64[Sp - 8] = block_c9Hvr_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _c9Hvr() //  []
         { info_tbl: [(c9Hvr,
                       label: block_c9Hvr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hvr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hvz; else goto c9Hvy;
       c9Hvz: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c9Hvy: // global
           _s9FLH::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s9FLH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.843231348 UTC

[section ""data" . GHC.Conc.Sync.numCapabilities_closure" {
     GHC.Conc.Sync.numCapabilities_closure:
         const GHC.Conc.Sync.numCapabilities_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.numCapabilities_entry() //  [R1]
         { info_tbl: [(c9HvI,
                       label: GHC.Conc.Sync.numCapabilities_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HvI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HvJ; else goto c9HvK;
       c9HvJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9HvK: // global
           (_c9HvD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9HvD::I64 == 0) goto c9HvF; else goto c9HvE;
       c9HvF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9HvE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9HvD::I64;
           I64[Sp - 24] = block_c9HvG_info;
           Sp = Sp - 24;
           call GHC.Conc.Sync.numCapabilities1_entry() args: 8, res: 8, upd: 24;
     }
 },
 _c9HvG() //  [R1]
         { info_tbl: [(c9HvG,
                       label: block_c9HvG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HvG: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.844327456 UTC

[section ""data" . GHC.Conc.Sync.disableAllocationLimit1_closure" {
     GHC.Conc.Sync.disableAllocationLimit1_closure:
         const GHC.Conc.Sync.disableAllocationLimit1_info;
 },
 GHC.Conc.Sync.disableAllocationLimit1_entry() //  []
         { info_tbl: [(c9HvS,
                       label: GHC.Conc.Sync.disableAllocationLimit1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HvS: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] rts_disableThreadAllocationLimit(CurrentTSO);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.845116621 UTC

[section ""data" . GHC.Conc.Sync.disableAllocationLimit_closure" {
     GHC.Conc.Sync.disableAllocationLimit_closure:
         const GHC.Conc.Sync.disableAllocationLimit_info;
 },
 GHC.Conc.Sync.disableAllocationLimit_entry() //  []
         { info_tbl: [(c9HvZ,
                       label: GHC.Conc.Sync.disableAllocationLimit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HvZ: // global
           call GHC.Conc.Sync.disableAllocationLimit1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.845940046 UTC

[section ""data" . GHC.Conc.Sync.enableAllocationLimit1_closure" {
     GHC.Conc.Sync.enableAllocationLimit1_closure:
         const GHC.Conc.Sync.enableAllocationLimit1_info;
 },
 GHC.Conc.Sync.enableAllocationLimit1_entry() //  []
         { info_tbl: [(c9Hw8,
                       label: GHC.Conc.Sync.enableAllocationLimit1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hw8: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] rts_enableThreadAllocationLimit(CurrentTSO);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.846736588 UTC

[section ""data" . GHC.Conc.Sync.enableAllocationLimit_closure" {
     GHC.Conc.Sync.enableAllocationLimit_closure:
         const GHC.Conc.Sync.enableAllocationLimit_info;
 },
 GHC.Conc.Sync.enableAllocationLimit_entry() //  []
         { info_tbl: [(c9Hwf,
                       label: GHC.Conc.Sync.enableAllocationLimit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hwf: // global
           call GHC.Conc.Sync.enableAllocationLimit1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.847562637 UTC

[section ""data" . GHC.Conc.Sync.getAllocationCounter1_closure" {
     GHC.Conc.Sync.getAllocationCounter1_closure:
         const GHC.Conc.Sync.getAllocationCounter1_info;
 },
 GHC.Conc.Sync.getAllocationCounter1_entry() //  []
         { info_tbl: [(c9Hwp,
                       label: GHC.Conc.Sync.getAllocationCounter1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hwp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hwt; else goto c9Hws;
       c9Hwt: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.getAllocationCounter1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Hws: // global
           (_s9FM7::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadAllocationCounter(CurrentTSO);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s9FM7::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.848530563 UTC

[section ""data" . GHC.Conc.Sync.getAllocationCounter_closure" {
     GHC.Conc.Sync.getAllocationCounter_closure:
         const GHC.Conc.Sync.getAllocationCounter_info;
 },
 GHC.Conc.Sync.getAllocationCounter_entry() //  []
         { info_tbl: [(c9Hwy,
                       label: GHC.Conc.Sync.getAllocationCounter_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hwy: // global
           call GHC.Conc.Sync.getAllocationCounter1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.849487 UTC

[section ""data" . GHC.Conc.Sync.setAllocationCounter1_closure" {
     GHC.Conc.Sync.setAllocationCounter1_closure:
         const GHC.Conc.Sync.setAllocationCounter1_info;
 },
 GHC.Conc.Sync.setAllocationCounter1_entry() //  [R2]
         { info_tbl: [(c9HwI,
                       label: GHC.Conc.Sync.setAllocationCounter1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HwI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HwJ; else goto c9HwK;
       c9HwJ: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.setAllocationCounter1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HwK: // global
           I64[Sp - 16] = block_c9HwF_info;
           R1 = R2;
           I64[Sp - 8] = CurrentTSO;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HwR; else goto c9HwG;
       u9HwR: // global
           call _c9HwF(R1) args: 0, res: 0, upd: 0;
       c9HwG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HwF() //  [R1]
         { info_tbl: [(c9HwF,
                       label: block_c9HwF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HwF: // global
           call "ccall" arg hints:  [PtrHint,
                                     signed]  result hints:  [] rts_setThreadAllocationCounter(P64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.850540243 UTC

[section ""data" . GHC.Conc.Sync.setAllocationCounter_closure" {
     GHC.Conc.Sync.setAllocationCounter_closure:
         const GHC.Conc.Sync.setAllocationCounter_info;
 },
 GHC.Conc.Sync.setAllocationCounter_entry() //  [R2]
         { info_tbl: [(c9HwW,
                       label: GHC.Conc.Sync.setAllocationCounter_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HwW: // global
           R2 = R2;
           call GHC.Conc.Sync.setAllocationCounter1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.851416732 UTC

[section ""data" . GHC.Conc.Sync.TVar_closure" {
     GHC.Conc.Sync.TVar_closure:
         const GHC.Conc.Sync.TVar_info;
 },
 GHC.Conc.Sync.TVar_entry() //  [R2]
         { info_tbl: [(c9Hx4,
                       label: GHC.Conc.Sync.TVar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hx4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hx8; else goto c9Hx7;
       c9Hx8: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.TVar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Hx7: // global
           I64[Hp - 8] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.852207469 UTC

[section ""data" . GHC.Conc.Sync.ThreadRunning_closure" {
     GHC.Conc.Sync.ThreadRunning_closure:
         const GHC.Conc.Sync.ThreadRunning_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.852780365 UTC

[section ""data" . GHC.Conc.Sync.ThreadFinished_closure" {
     GHC.Conc.Sync.ThreadFinished_closure:
         const GHC.Conc.Sync.ThreadFinished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.853711387 UTC

[section ""data" . GHC.Conc.Sync.ThreadBlocked_closure" {
     GHC.Conc.Sync.ThreadBlocked_closure:
         const GHC.Conc.Sync.ThreadBlocked_info;
 },
 GHC.Conc.Sync.ThreadBlocked_entry() //  [R2]
         { info_tbl: [(c9Hxe,
                       label: GHC.Conc.Sync.ThreadBlocked_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hxe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hxi; else goto c9Hxh;
       c9Hxi: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.ThreadBlocked_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Hxh: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadBlocked_con_info;
           P64[Hp] = R2;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.854480237 UTC

[section ""data" . GHC.Conc.Sync.ThreadDied_closure" {
     GHC.Conc.Sync.ThreadDied_closure:
         const GHC.Conc.Sync.ThreadDied_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.85501137 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnMVar_closure" {
     GHC.Conc.Sync.BlockedOnMVar_closure:
         const GHC.Conc.Sync.BlockedOnMVar_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.855534883 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnBlackHole_closure" {
     GHC.Conc.Sync.BlockedOnBlackHole_closure:
         const GHC.Conc.Sync.BlockedOnBlackHole_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.856052008 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnException_closure" {
     GHC.Conc.Sync.BlockedOnException_closure:
         const GHC.Conc.Sync.BlockedOnException_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.856585894 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnSTM_closure" {
     GHC.Conc.Sync.BlockedOnSTM_closure:
         const GHC.Conc.Sync.BlockedOnSTM_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.857166566 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnForeignCall_closure" {
     GHC.Conc.Sync.BlockedOnForeignCall_closure:
         const GHC.Conc.Sync.BlockedOnForeignCall_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.857693838 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnOther_closure" {
     GHC.Conc.Sync.BlockedOnOther_closure:
         const GHC.Conc.Sync.BlockedOnOther_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.858373405 UTC

[section ""data" . GHC.Conc.Sync.ThreadId_closure" {
     GHC.Conc.Sync.ThreadId_closure:
         const GHC.Conc.Sync.ThreadId_info;
 },
 GHC.Conc.Sync.ThreadId_entry() //  [R2]
         { info_tbl: [(c9Hxo,
                       label: GHC.Conc.Sync.ThreadId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hxo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Hxs; else goto c9Hxr;
       c9Hxs: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.ThreadId_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Hxr: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.859238574 UTC

[GHC.Conc.Sync.TVar_con_entry() //  [R1]
         { info_tbl: [(c9Hxt,
                       label: GHC.Conc.Sync.TVar_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hxt: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.859935306 UTC

[GHC.Conc.Sync.ThreadRunning_con_entry() //  [R1]
         { info_tbl: [(c9Hxu,
                       label: GHC.Conc.Sync.ThreadRunning_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,82,117,110,110,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hxu: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.860611806 UTC

[GHC.Conc.Sync.ThreadFinished_con_entry() //  [R1]
         { info_tbl: [(c9Hxv,
                       label: GHC.Conc.Sync.ThreadFinished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,70,105,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hxv: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.861345683 UTC

[GHC.Conc.Sync.ThreadBlocked_con_entry() //  [R1]
         { info_tbl: [(c9Hxw,
                       label: GHC.Conc.Sync.ThreadBlocked_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,66,108,111,99,107,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hxw: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.86203506 UTC

[GHC.Conc.Sync.ThreadDied_con_entry() //  [R1]
         { info_tbl: [(c9Hxx,
                       label: GHC.Conc.Sync.ThreadDied_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,68,105,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hxx: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.862650164 UTC

[section ""relreadonly" . GHC.Conc.Sync.BlockReason_closure_tbl" {
     GHC.Conc.Sync.BlockReason_closure_tbl:
         const GHC.Conc.Sync.BlockedOnMVar_closure+1;
         const GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
         const GHC.Conc.Sync.BlockedOnException_closure+3;
         const GHC.Conc.Sync.BlockedOnSTM_closure+4;
         const GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
         const GHC.Conc.Sync.BlockedOnOther_closure+6;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.86324658 UTC

[GHC.Conc.Sync.BlockedOnMVar_con_entry() //  [R1]
         { info_tbl: [(c9Hxy,
                       label: GHC.Conc.Sync.BlockedOnMVar_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,77,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hxy: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.863917328 UTC

[GHC.Conc.Sync.BlockedOnBlackHole_con_entry() //  [R1]
         { info_tbl: [(c9Hxz,
                       label: GHC.Conc.Sync.BlockedOnBlackHole_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,66,108,97,99,107,72,111,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hxz: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.864563759 UTC

[GHC.Conc.Sync.BlockedOnException_con_entry() //  [R1]
         { info_tbl: [(c9HxA,
                       label: GHC.Conc.Sync.BlockedOnException_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,69,120,99,101,112,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HxA: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.86527327 UTC

[GHC.Conc.Sync.BlockedOnSTM_con_entry() //  [R1]
         { info_tbl: [(c9HxB,
                       label: GHC.Conc.Sync.BlockedOnSTM_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,83,84,77]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HxB: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.865989678 UTC

[GHC.Conc.Sync.BlockedOnForeignCall_con_entry() //  [R1]
         { info_tbl: [(c9HxC,
                       label: GHC.Conc.Sync.BlockedOnForeignCall_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,70,111,114,101,105,103,110,67,97,108,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HxC: // global
           R1 = R1 + 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.866684191 UTC

[GHC.Conc.Sync.BlockedOnOther_con_entry() //  [R1]
         { info_tbl: [(c9HxD,
                       label: GHC.Conc.Sync.BlockedOnOther_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 5
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,79,116,104,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HxD: // global
           R1 = R1 + 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.867341776 UTC

[GHC.Conc.Sync.ThreadId_con_entry() //  [R1]
         { info_tbl: [(c9HxE,
                       label: GHC.Conc.Sync.ThreadId_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,73,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HxE: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.86796393 UTC

[section ""relreadonly" . S9FOI_srt" {
     S9FOI_srt:
         const GHC.Conc.Sync.$w$cshowsPrec_closure;
         const GHC.Conc.Sync.$fShowBlockReason1_closure;
         const GHC.Conc.Sync.$fShowBlockReason3_closure;
         const GHC.Conc.Sync.$fShowBlockReason5_closure;
         const GHC.Conc.Sync.$fShowBlockReason7_closure;
         const GHC.Conc.Sync.$fShowBlockReason9_closure;
         const GHC.Conc.Sync.$fShowBlockReason11_closure;
         const GHC.Conc.Sync.$fShowBlockReason_$cshow_closure;
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const GHC.Conc.Sync.labelThread1_closure;
         const GHC.Conc.Sync.$fShowThreadStatus5_closure;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure;
         const GHC.Conc.Sync.$fShowThreadStatus3_closure;
         const GHC.Conc.Sync.$fShowThreadStatus7_closure;
         const GHC.Conc.Sync.$fShowThreadStatus9_closure;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure;
         const GHC.Conc.Sync.$fShowThreadStatus1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
         const GHC.Conc.Sync.killThread1_closure;
         const GHC.Conc.Sync.killThread2_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Conc.Sync.always3_closure;
         const GHC.Conc.Sync.always1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.hFlush_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const lvl3_r9Fve_closure;
         const lvl4_r9Fvf_closure;
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const lvl6_r9Fvh_closure;
         const lvl8_r9Fvj_closure;
         const lvl9_r9Fvk_closure;
         const lvl10_r9Fvl_closure;
         const GHC.Conc.Sync.uncaughtExceptionHandler_closure;
         const GHC.Conc.Sync.setUncaughtExceptionHandler1_closure;
         const GHC.Conc.Sync.getUncaughtExceptionHandler1_closure;
         const GHC.Conc.Sync.reportError1_closure;
         const GHC.Conc.Sync.childHandler1_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionAsyncException9_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Sync.forkOn1_closure;
         const GHC.Conc.Sync.forkOnWithUnmask1_closure;
         const GHC.Conc.Sync.forkIO1_closure;
         const GHC.Conc.Sync.forkIOWithUnmask1_closure;
         const lvl13_r9Fvo_closure;
         const GHC.IO.failIO1_closure;
         const GHC.Conc.Sync.$wlvl_closure;
         const GHC.Conc.Sync.setNumCapabilities2_closure;
         const GHC.Conc.Sync.setNumCapabilities1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.868837042 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:45.869758808 UTC

[section ""data" . GHC.Conc.Sync.$fEqTVar_$c==_closure" {
     GHC.Conc.Sync.$fEqTVar_$c==_closure:
         const GHC.Conc.Sync.$fEqTVar_$c==_info;
 },
 GHC.Conc.Sync.$fEqTVar_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9HxM,
                       label: GHC.Conc.Sync.$fEqTVar_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HxM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HxQ; else goto c9HxR;
       c9HxQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqTVar_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HxR: // global
           I64[Sp - 16] = block_c9HxJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Hy0; else goto c9HxK;
       u9Hy0: // global
           call _c9HxJ(R1) args: 0, res: 0, upd: 0;
       c9HxK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HxJ() //  [R1]
         { info_tbl: [(c9HxJ,
                       label: block_c9HxJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HxJ: // global
           I64[Sp] = block_c9HxP_info;
           _s9Fvt::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9Fvt::P64;
           if (R1 & 7 != 0) goto u9HxZ; else goto c9HxT;
       u9HxZ: // global
           call _c9HxP(R1) args: 0, res: 0, upd: 0;
       c9HxT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HxP() //  [R1]
         { info_tbl: [(c9HxP,
                       label: block_c9HxP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HxP: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.871257553 UTC

[section ""data" . GHC.Conc.Sync.$fEqTVar_$c/=_closure" {
     GHC.Conc.Sync.$fEqTVar_$c/=_closure:
         const GHC.Conc.Sync.$fEqTVar_$c/=_info;
 },
 GHC.Conc.Sync.$fEqTVar_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9Hy8,
                       label: GHC.Conc.Sync.$fEqTVar_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hy8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Hyc; else goto c9Hyd;
       c9Hyc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqTVar_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Hyd: // global
           I64[Sp - 16] = block_c9Hy5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HyA; else goto c9Hy6;
       u9HyA: // global
           call _c9Hy5(R1) args: 0, res: 0, upd: 0;
       c9Hy6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hy5() //  [R1]
         { info_tbl: [(c9Hy5,
                       label: block_c9Hy5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hy5: // global
           I64[Sp] = block_c9Hyb_info;
           _s9FvA::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FvA::P64;
           if (R1 & 7 != 0) goto u9Hyz; else goto c9Hyf;
       u9Hyz: // global
           call _c9Hyb(R1) args: 0, res: 0, upd: 0;
       c9Hyf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hyb() //  [R1]
         { info_tbl: [(c9Hyb,
                       label: block_c9Hyb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hyb: // global
           if (P64[Sp + 8] == P64[R1 + 7]) goto c9Hyv; else goto c9Hyp;
       c9Hyv: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Hyp: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.872480821 UTC

[section ""data" . GHC.Conc.Sync.$fEqTVar_closure" {
     GHC.Conc.Sync.$fEqTVar_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqTVar_$c==_closure+2;
         const GHC.Conc.Sync.$fEqTVar_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.873056344 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason12_bytes" {
     GHC.Conc.Sync.$fShowBlockReason12_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.874060482 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason11_closure" {
     GHC.Conc.Sync.$fShowBlockReason11_closure:
         const GHC.Conc.Sync.$fShowBlockReason11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason11_entry() //  [R1]
         { info_tbl: [(c9HyH,
                       label: GHC.Conc.Sync.$fShowBlockReason11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HyH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HyI; else goto c9HyJ;
       c9HyI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9HyJ: // global
           (_c9HyE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9HyE::I64 == 0) goto c9HyG; else goto c9HyF;
       c9HyG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9HyF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9HyE::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason12_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.874900871 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason10_bytes" {
     GHC.Conc.Sync.$fShowBlockReason10_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,66,108,97,99,107,72,111,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.876962064 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason9_closure" {
     GHC.Conc.Sync.$fShowBlockReason9_closure:
         const GHC.Conc.Sync.$fShowBlockReason9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason9_entry() //  [R1]
         { info_tbl: [(c9HyQ,
                       label: GHC.Conc.Sync.$fShowBlockReason9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HyQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HyR; else goto c9HyS;
       c9HyR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9HyS: // global
           (_c9HyN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9HyN::I64 == 0) goto c9HyP; else goto c9HyO;
       c9HyP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9HyO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9HyN::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.87785286 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason8_bytes" {
     GHC.Conc.Sync.$fShowBlockReason8_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.878514548 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason7_closure" {
     GHC.Conc.Sync.$fShowBlockReason7_closure:
         const GHC.Conc.Sync.$fShowBlockReason7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason7_entry() //  [R1]
         { info_tbl: [(c9HyZ,
                       label: GHC.Conc.Sync.$fShowBlockReason7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HyZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Hz0; else goto c9Hz1;
       c9Hz0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Hz1: // global
           (_c9HyW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9HyW::I64 == 0) goto c9HyY; else goto c9HyX;
       c9HyY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9HyX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9HyW::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.879369913 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason6_bytes" {
     GHC.Conc.Sync.$fShowBlockReason6_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.880088772 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason5_closure" {
     GHC.Conc.Sync.$fShowBlockReason5_closure:
         const GHC.Conc.Sync.$fShowBlockReason5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason5_entry() //  [R1]
         { info_tbl: [(c9Hz8,
                       label: GHC.Conc.Sync.$fShowBlockReason5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hz8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Hz9; else goto c9Hza;
       c9Hz9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Hza: // global
           (_c9Hz5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Hz5::I64 == 0) goto c9Hz7; else goto c9Hz6;
       c9Hz7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Hz6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Hz5::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.880912136 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason4_bytes" {
     GHC.Conc.Sync.$fShowBlockReason4_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,70,111,114,101,105,103,110,67,97,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.882223234 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason3_closure" {
     GHC.Conc.Sync.$fShowBlockReason3_closure:
         const GHC.Conc.Sync.$fShowBlockReason3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason3_entry() //  [R1]
         { info_tbl: [(c9Hzh,
                       label: GHC.Conc.Sync.$fShowBlockReason3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hzh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Hzi; else goto c9Hzj;
       c9Hzi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Hzj: // global
           (_c9Hze::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Hze::I64 == 0) goto c9Hzg; else goto c9Hzf;
       c9Hzg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Hzf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Hze::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.883064116 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason2_bytes" {
     GHC.Conc.Sync.$fShowBlockReason2_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,79,116,104,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.883728457 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason1_closure" {
     GHC.Conc.Sync.$fShowBlockReason1_closure:
         const GHC.Conc.Sync.$fShowBlockReason1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason1_entry() //  [R1]
         { info_tbl: [(c9Hzq,
                       label: GHC.Conc.Sync.$fShowBlockReason1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hzq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Hzr; else goto c9Hzs;
       c9Hzr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Hzs: // global
           (_c9Hzn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Hzn::I64 == 0) goto c9Hzp; else goto c9Hzo;
       c9Hzp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Hzo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Hzn::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.884947133 UTC

[section ""data" . GHC.Conc.Sync.$w$cshowsPrec_closure" {
     GHC.Conc.Sync.$w$cshowsPrec_closure:
         const GHC.Conc.Sync.$w$cshowsPrec_info;
         const 0;
 },
 GHC.Conc.Sync.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c9HzI,
                       label: GHC.Conc.Sync.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HzI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HzJ; else goto c9HzK;
       c9HzJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HzK: // global
           I64[Sp - 16] = block_c9Hzx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HA3; else goto c9Hzy;
       u9HA3: // global
           call _c9Hzx(R1) args: 0, res: 0, upd: 0;
       c9Hzy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Hzx() //  [R1]
         { info_tbl: [(c9Hzx,
                       label: block_c9Hzx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Hzx: // global
           _s9FvF::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9HzB;
               case 2 : goto c9HzC;
               case 3 : goto c9HzD;
               case 4 : goto c9HzE;
               case 5 : goto c9HzF;
               case 6 : goto c9HzG;
           }
       c9HzG: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9HzF: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9HzE: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9HzD: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9HzC: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason9_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9HzB: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason11_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.886410312 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_closure" {
     GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_closure:
         const GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c9HA8,
                       label: GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HA8: // global
           _s9FvI::P64 = R3;
           R3 = R4;
           R2 = _s9FvI::P64;
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.887410173 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_$cshow_closure" {
     GHC.Conc.Sync.$fShowBlockReason_$cshow_closure:
         const GHC.Conc.Sync.$fShowBlockReason_$cshow_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason_$cshow_entry() //  [R2]
         { info_tbl: [(c9HAq,
                       label: GHC.Conc.Sync.$fShowBlockReason_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HAq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9HAr; else goto c9HAs;
       c9HAr: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowBlockReason_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HAs: // global
           I64[Sp - 8] = block_c9HAf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9HAL; else goto c9HAg;
       u9HAL: // global
           call _c9HAf(R1) args: 0, res: 0, upd: 0;
       c9HAg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HAf() //  [R1]
         { info_tbl: [(c9HAf,
                       label: block_c9HAf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HAf: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9HAj;
               case 2 : goto c9HAk;
               case 3 : goto c9HAl;
               case 4 : goto c9HAm;
               case 5 : goto c9HAn;
               case 6 : goto c9HAo;
           }
       c9HAo: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9HAn: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9HAm: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9HAl: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9HAk: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9HAj: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.888766324 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_$cshowList_closure" {
     GHC.Conc.Sync.$fShowBlockReason_$cshowList_closure:
         const GHC.Conc.Sync.$fShowBlockReason_$cshowList_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c9HAQ,
                       label: GHC.Conc.Sync.$fShowBlockReason_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HAQ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.8895039 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_closure" {
     GHC.Conc.Sync.$fShowBlockReason_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_closure+3;
         const GHC.Conc.Sync.$fShowBlockReason_$cshow_closure+1;
         const GHC.Conc.Sync.$fShowBlockReason_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.891016098 UTC

[section ""data" . GHC.Conc.Sync.$fEqBlockReason_$c==_closure" {
     GHC.Conc.Sync.$fEqBlockReason_$c==_closure:
         const GHC.Conc.Sync.$fEqBlockReason_$c==_info;
 },
 GHC.Conc.Sync.$fEqBlockReason_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9HB8,
                       label: GHC.Conc.Sync.$fEqBlockReason_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HB8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HB9; else goto c9HBa;
       c9HB9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqBlockReason_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HBa: // global
           I64[Sp - 16] = block_c9HAX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HD1; else goto c9HAY;
       u9HD1: // global
           call _c9HAX(R1) args: 0, res: 0, upd: 0;
       c9HAY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HAX() //  [R1]
         { info_tbl: [(c9HAX,
                       label: block_c9HAX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HAX: // global
           _s9FvP::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9HB1;
               case 2 : goto c9HB2;
               case 3 : goto c9HB3;
               case 4 : goto c9HB4;
               case 5 : goto c9HB5;
               case 6 : goto c9HB6;
           }
       c9HB6: // global
           I64[Sp + 8] = block_c9HCq_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HD0; else goto c9HCs;
       u9HD0: // global
           call _c9HCq(R1) args: 0, res: 0, upd: 0;
       c9HCs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HB5: // global
           I64[Sp + 8] = block_c9HCb_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HCZ; else goto c9HCd;
       u9HCZ: // global
           call _c9HCb(R1) args: 0, res: 0, upd: 0;
       c9HCd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HB4: // global
           I64[Sp + 8] = block_c9HBW_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HCY; else goto c9HBY;
       u9HCY: // global
           call _c9HBW(R1) args: 0, res: 0, upd: 0;
       c9HBY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HB3: // global
           I64[Sp + 8] = block_c9HBH_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HCX; else goto c9HBJ;
       u9HCX: // global
           call _c9HBH(R1) args: 0, res: 0, upd: 0;
       c9HBJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HB2: // global
           I64[Sp + 8] = block_c9HBs_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HCW; else goto c9HBu;
       u9HCW: // global
           call _c9HBs(R1) args: 0, res: 0, upd: 0;
       c9HBu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HB1: // global
           I64[Sp + 8] = block_c9HBd_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HCV; else goto c9HBf;
       u9HCV: // global
           call _c9HBd(R1) args: 0, res: 0, upd: 0;
       c9HBf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HCq() //  [R1]
         { info_tbl: [(c9HCq,
                       label: block_c9HCq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HCq: // global
           if (R1 & 7 == 6) goto u9HCJ; else goto u9HCK;
       u9HCJ: // global
           Sp = Sp + 8;
           call _c9HCC() args: 0, res: 0, upd: 0;
       u9HCK: // global
           Sp = Sp + 8;
           call _c9HCy() args: 0, res: 0, upd: 0;
     }
 },
 _c9HCb() //  [R1]
         { info_tbl: [(c9HCb,
                       label: block_c9HCb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HCb: // global
           if (R1 & 7 == 5) goto u9HCL; else goto u9HCM;
       u9HCL: // global
           Sp = Sp + 8;
           call _c9HCC() args: 0, res: 0, upd: 0;
       u9HCM: // global
           Sp = Sp + 8;
           call _c9HCy() args: 0, res: 0, upd: 0;
     }
 },
 _c9HBW() //  [R1]
         { info_tbl: [(c9HBW,
                       label: block_c9HBW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HBW: // global
           if (R1 & 7 == 4) goto u9HCN; else goto u9HCO;
       u9HCN: // global
           Sp = Sp + 8;
           call _c9HCC() args: 0, res: 0, upd: 0;
       u9HCO: // global
           Sp = Sp + 8;
           call _c9HCy() args: 0, res: 0, upd: 0;
     }
 },
 _c9HBH() //  [R1]
         { info_tbl: [(c9HBH,
                       label: block_c9HBH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HBH: // global
           if (R1 & 7 == 3) goto u9HCP; else goto u9HCQ;
       u9HCP: // global
           Sp = Sp + 8;
           call _c9HCC() args: 0, res: 0, upd: 0;
       u9HCQ: // global
           Sp = Sp + 8;
           call _c9HCy() args: 0, res: 0, upd: 0;
     }
 },
 _c9HBs() //  [R1]
         { info_tbl: [(c9HBs,
                       label: block_c9HBs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HBs: // global
           if (R1 & 7 == 2) goto u9HCR; else goto u9HCS;
       u9HCR: // global
           Sp = Sp + 8;
           call _c9HCC() args: 0, res: 0, upd: 0;
       u9HCS: // global
           Sp = Sp + 8;
           call _c9HCy() args: 0, res: 0, upd: 0;
     }
 },
 _c9HBd() //  [R1]
         { info_tbl: [(c9HBd,
                       label: block_c9HBd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HBd: // global
           if (R1 & 7 == 1) goto u9HCT; else goto u9HCU;
       u9HCT: // global
           Sp = Sp + 8;
           call _c9HCC() args: 0, res: 0, upd: 0;
       u9HCU: // global
           Sp = Sp + 8;
           call _c9HCy() args: 0, res: 0, upd: 0;
     }
 },
 _c9HCC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HCC: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9HCy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HCy: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.894498496 UTC

[section ""data" . GHC.Conc.Sync.$fEqBlockReason_$c/=_closure" {
     GHC.Conc.Sync.$fEqBlockReason_$c/=_closure:
         const GHC.Conc.Sync.$fEqBlockReason_$c/=_info;
 },
 GHC.Conc.Sync.$fEqBlockReason_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9HDt,
                       label: GHC.Conc.Sync.$fEqBlockReason_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HDt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HDu; else goto c9HDv;
       c9HDu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqBlockReason_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HDv: // global
           I64[Sp - 16] = block_c9HDi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HFm; else goto c9HDj;
       u9HFm: // global
           call _c9HDi(R1) args: 0, res: 0, upd: 0;
       c9HDj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HDi() //  [R1]
         { info_tbl: [(c9HDi,
                       label: block_c9HDi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HDi: // global
           _s9FvY::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9HDm;
               case 2 : goto c9HDn;
               case 3 : goto c9HDo;
               case 4 : goto c9HDp;
               case 5 : goto c9HDq;
               case 6 : goto c9HDr;
           }
       c9HDr: // global
           I64[Sp + 8] = block_c9HEL_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HFl; else goto c9HEN;
       u9HFl: // global
           call _c9HEL(R1) args: 0, res: 0, upd: 0;
       c9HEN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HDq: // global
           I64[Sp + 8] = block_c9HEw_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HFk; else goto c9HEy;
       u9HFk: // global
           call _c9HEw(R1) args: 0, res: 0, upd: 0;
       c9HEy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HDp: // global
           I64[Sp + 8] = block_c9HEh_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HFj; else goto c9HEj;
       u9HFj: // global
           call _c9HEh(R1) args: 0, res: 0, upd: 0;
       c9HEj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HDo: // global
           I64[Sp + 8] = block_c9HE2_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HFi; else goto c9HE4;
       u9HFi: // global
           call _c9HE2(R1) args: 0, res: 0, upd: 0;
       c9HE4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HDn: // global
           I64[Sp + 8] = block_c9HDN_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HFh; else goto c9HDP;
       u9HFh: // global
           call _c9HDN(R1) args: 0, res: 0, upd: 0;
       c9HDP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HDm: // global
           I64[Sp + 8] = block_c9HDy_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HFg; else goto c9HDA;
       u9HFg: // global
           call _c9HDy(R1) args: 0, res: 0, upd: 0;
       c9HDA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HEL() //  [R1]
         { info_tbl: [(c9HEL,
                       label: block_c9HEL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HEL: // global
           if (R1 & 7 == 6) goto u9HF4; else goto u9HF5;
       u9HF4: // global
           Sp = Sp + 8;
           call _c9HEX() args: 0, res: 0, upd: 0;
       u9HF5: // global
           Sp = Sp + 8;
           call _c9HET() args: 0, res: 0, upd: 0;
     }
 },
 _c9HEw() //  [R1]
         { info_tbl: [(c9HEw,
                       label: block_c9HEw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HEw: // global
           if (R1 & 7 == 5) goto u9HF6; else goto u9HF7;
       u9HF6: // global
           Sp = Sp + 8;
           call _c9HEX() args: 0, res: 0, upd: 0;
       u9HF7: // global
           Sp = Sp + 8;
           call _c9HET() args: 0, res: 0, upd: 0;
     }
 },
 _c9HEh() //  [R1]
         { info_tbl: [(c9HEh,
                       label: block_c9HEh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HEh: // global
           if (R1 & 7 == 4) goto u9HF8; else goto u9HF9;
       u9HF8: // global
           Sp = Sp + 8;
           call _c9HEX() args: 0, res: 0, upd: 0;
       u9HF9: // global
           Sp = Sp + 8;
           call _c9HET() args: 0, res: 0, upd: 0;
     }
 },
 _c9HE2() //  [R1]
         { info_tbl: [(c9HE2,
                       label: block_c9HE2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HE2: // global
           if (R1 & 7 == 3) goto u9HFa; else goto u9HFb;
       u9HFa: // global
           Sp = Sp + 8;
           call _c9HEX() args: 0, res: 0, upd: 0;
       u9HFb: // global
           Sp = Sp + 8;
           call _c9HET() args: 0, res: 0, upd: 0;
     }
 },
 _c9HDN() //  [R1]
         { info_tbl: [(c9HDN,
                       label: block_c9HDN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HDN: // global
           if (R1 & 7 == 2) goto u9HFc; else goto u9HFd;
       u9HFc: // global
           Sp = Sp + 8;
           call _c9HEX() args: 0, res: 0, upd: 0;
       u9HFd: // global
           Sp = Sp + 8;
           call _c9HET() args: 0, res: 0, upd: 0;
     }
 },
 _c9HDy() //  [R1]
         { info_tbl: [(c9HDy,
                       label: block_c9HDy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HDy: // global
           if (R1 & 7 == 1) goto u9HFe; else goto u9HFf;
       u9HFe: // global
           Sp = Sp + 8;
           call _c9HEX() args: 0, res: 0, upd: 0;
       u9HFf: // global
           Sp = Sp + 8;
           call _c9HET() args: 0, res: 0, upd: 0;
     }
 },
 _c9HEX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HEX: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9HET() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HET: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.8970078 UTC

[section ""data" . GHC.Conc.Sync.$fEqBlockReason_closure" {
     GHC.Conc.Sync.$fEqBlockReason_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqBlockReason_$c==_closure+2;
         const GHC.Conc.Sync.$fEqBlockReason_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.898417987 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadStatus_$c==_closure" {
     GHC.Conc.Sync.$fEqThreadStatus_$c==_closure:
         const GHC.Conc.Sync.$fEqThreadStatus_$c==_info;
 },
 GHC.Conc.Sync.$fEqThreadStatus_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9HFM,
                       label: GHC.Conc.Sync.$fEqThreadStatus_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HFM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HFN; else goto c9HFO;
       c9HFN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadStatus_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HFO: // global
           I64[Sp - 16] = block_c9HFD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HH4; else goto c9HFE;
       u9HH4: // global
           call _c9HFD(R1) args: 0, res: 0, upd: 0;
       c9HFE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HFD() //  [R1]
         { info_tbl: [(c9HFD,
                       label: block_c9HFD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HFD: // global
           _s9Fw7::P64 = P64[Sp + 8];
           _c9HFL::P64 = R1 & 7;
           if (_c9HFL::P64 < 3) goto u9HGR; else goto u9HGS;
       u9HGR: // global
           if (_c9HFL::P64 < 2) goto c9HFH; else goto c9HFI;
       c9HFH: // global
           I64[Sp + 8] = block_c9HFR_info;
           R1 = _s9Fw7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HH0; else goto c9HFT;
       u9HH0: // global
           call _c9HFR(R1) args: 0, res: 0, upd: 0;
       c9HFT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HFI: // global
           I64[Sp + 8] = block_c9HG6_info;
           R1 = _s9Fw7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HH1; else goto c9HG8;
       u9HH1: // global
           call _c9HG6(R1) args: 0, res: 0, upd: 0;
       c9HG8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9HGS: // global
           if (_c9HFL::P64 < 4) goto c9HFJ; else goto c9HFK;
       c9HFJ: // global
           I64[Sp] = block_c9HGl_info;
           _s9Fwb::P64 = P64[R1 + 5];
           R1 = _s9Fw7::P64;
           P64[Sp + 8] = _s9Fwb::P64;
           if (R1 & 7 != 0) goto u9HH2; else goto c9HGn;
       u9HH2: // global
           call _c9HGl(R1) args: 0, res: 0, upd: 0;
       c9HGn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HFK: // global
           I64[Sp + 8] = block_c9HGA_info;
           R1 = _s9Fw7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HH3; else goto c9HGC;
       u9HH3: // global
           call _c9HGA(R1) args: 0, res: 0, upd: 0;
       c9HGC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HFR() //  [R1]
         { info_tbl: [(c9HFR,
                       label: block_c9HFR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HFR: // global
           if (R1 & 7 == 1) goto u9HGT; else goto u9HGU;
       u9HGT: // global
           Sp = Sp + 8;
           call _c9HGM() args: 0, res: 0, upd: 0;
       u9HGU: // global
           Sp = Sp + 8;
           call _c9HGI() args: 0, res: 0, upd: 0;
     }
 },
 _c9HG6() //  [R1]
         { info_tbl: [(c9HG6,
                       label: block_c9HG6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HG6: // global
           if (R1 & 7 == 2) goto u9HGV; else goto u9HGW;
       u9HGV: // global
           Sp = Sp + 8;
           call _c9HGM() args: 0, res: 0, upd: 0;
       u9HGW: // global
           Sp = Sp + 8;
           call _c9HGI() args: 0, res: 0, upd: 0;
     }
 },
 _c9HGl() //  [R1]
         { info_tbl: [(c9HGl,
                       label: block_c9HGl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HGl: // global
           if (R1 & 7 == 3) goto c9HGx; else goto u9HGX;
       c9HGx: // global
           R3 = P64[R1 + 5];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$fEqBlockReason_$c==_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
       u9HGX: // global
           Sp = Sp + 16;
           call _c9HGI() args: 0, res: 0, upd: 0;
     }
 },
 _c9HGA() //  [R1]
         { info_tbl: [(c9HGA,
                       label: block_c9HGA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HGA: // global
           if (R1 & 7 == 4) goto u9HGY; else goto u9HGZ;
       u9HGY: // global
           Sp = Sp + 8;
           call _c9HGM() args: 0, res: 0, upd: 0;
       u9HGZ: // global
           Sp = Sp + 8;
           call _c9HGI() args: 0, res: 0, upd: 0;
     }
 },
 _c9HGM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HGM: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9HGI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HGI: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.902125128 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure" {
     GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure:
         const GHC.Conc.Sync.$fEqThreadStatus_$c/=_info;
 },
 GHC.Conc.Sync.$fEqThreadStatus_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9HHp,
                       label: GHC.Conc.Sync.$fEqThreadStatus_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HHp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HHq; else goto c9HHr;
       c9HHq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HHr: // global
           I64[Sp - 16] = block_c9HHg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HKC; else goto c9HHh;
       u9HKC: // global
           call _c9HHg(R1) args: 0, res: 0, upd: 0;
       c9HHh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HHg() //  [R1]
         { info_tbl: [(c9HHg,
                       label: block_c9HHg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HHg: // global
           _s9Fwg::P64 = P64[Sp + 8];
           _c9HHo::P64 = R1 & 7;
           if (_c9HHo::P64 < 3) goto u9HKd; else goto u9HKe;
       u9HKd: // global
           if (_c9HHo::P64 < 2) goto c9HHk; else goto c9HHl;
       c9HHk: // global
           I64[Sp + 8] = block_c9HHu_info;
           R1 = _s9Fwg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HKy; else goto c9HHw;
       u9HKy: // global
           call _c9HHu(R1) args: 0, res: 0, upd: 0;
       c9HHw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HHl: // global
           I64[Sp + 8] = block_c9HHJ_info;
           R1 = _s9Fwg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HKz; else goto c9HHL;
       u9HKz: // global
           call _c9HHJ(R1) args: 0, res: 0, upd: 0;
       c9HHL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9HKe: // global
           if (_c9HHo::P64 < 4) goto c9HHm; else goto c9HHn;
       c9HHm: // global
           I64[Sp] = block_c9HHY_info;
           _s9Fwk::P64 = P64[R1 + 5];
           R1 = _s9Fwg::P64;
           P64[Sp + 8] = _s9Fwk::P64;
           if (R1 & 7 != 0) goto u9HKA; else goto c9HI0;
       u9HKA: // global
           call _c9HHY(R1) args: 0, res: 0, upd: 0;
       c9HI0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HHn: // global
           I64[Sp + 8] = block_c9HJP_info;
           R1 = _s9Fwg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HKB; else goto c9HJR;
       u9HKB: // global
           call _c9HJP(R1) args: 0, res: 0, upd: 0;
       c9HJR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HHu() //  [R1]
         { info_tbl: [(c9HHu,
                       label: block_c9HHu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HHu: // global
           if (R1 & 7 == 1) goto u9HKf; else goto u9HKg;
       u9HKf: // global
           Sp = Sp + 8;
           call _c9HK1() args: 0, res: 0, upd: 0;
       u9HKg: // global
           Sp = Sp + 8;
           call _c9HJX() args: 0, res: 0, upd: 0;
     }
 },
 _c9HHJ() //  [R1]
         { info_tbl: [(c9HHJ,
                       label: block_c9HHJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HHJ: // global
           if (R1 & 7 == 2) goto u9HKh; else goto u9HKi;
       u9HKh: // global
           Sp = Sp + 8;
           call _c9HK1() args: 0, res: 0, upd: 0;
       u9HKi: // global
           Sp = Sp + 8;
           call _c9HJX() args: 0, res: 0, upd: 0;
     }
 },
 _c9HHY() //  [R1]
         { info_tbl: [(c9HHY,
                       label: block_c9HHY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HHY: // global
           if (R1 & 7 == 3) goto c9HIb; else goto u9HKj;
       c9HIb: // global
           I64[Sp] = block_c9HI9_info;
           _s9Fwm::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9Fwm::P64;
           if (R1 & 7 != 0) goto u9HKH; else goto c9HIc;
       u9HKH: // global
           call _c9HI9(R1) args: 0, res: 0, upd: 0;
       c9HIc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9HKj: // global
           Sp = Sp + 16;
           call _c9HJX() args: 0, res: 0, upd: 0;
     }
 },
 _c9HI9() //  [R1]
         { info_tbl: [(c9HI9,
                       label: block_c9HI9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HI9: // global
           _s9Fwm::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9HIj;
               case 2 : goto c9HIz;
               case 3 : goto c9HIP;
               case 4 : goto c9HJ5;
               case 5 : goto c9HJl;
               case 6 : goto c9HJB;
           }
       c9HJB: // global
           I64[Sp + 8] = block_c9HJz_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HKO; else goto c9HJC;
       u9HKO: // global
           call _c9HJz(R1) args: 0, res: 0, upd: 0;
       c9HJC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HJl: // global
           I64[Sp + 8] = block_c9HJj_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HKN; else goto c9HJm;
       u9HKN: // global
           call _c9HJj(R1) args: 0, res: 0, upd: 0;
       c9HJm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HJ5: // global
           I64[Sp + 8] = block_c9HJ3_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HKM; else goto c9HJ6;
       u9HKM: // global
           call _c9HJ3(R1) args: 0, res: 0, upd: 0;
       c9HJ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HIP: // global
           I64[Sp + 8] = block_c9HIN_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HKL; else goto c9HIQ;
       u9HKL: // global
           call _c9HIN(R1) args: 0, res: 0, upd: 0;
       c9HIQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HIz: // global
           I64[Sp + 8] = block_c9HIx_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HKK; else goto c9HIA;
       u9HKK: // global
           call _c9HIx(R1) args: 0, res: 0, upd: 0;
       c9HIA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HIj: // global
           I64[Sp + 8] = block_c9HIg_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HKJ; else goto c9HIk;
       u9HKJ: // global
           call _c9HIg(R1) args: 0, res: 0, upd: 0;
       c9HIk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HJz() //  [R1]
         { info_tbl: [(c9HJz,
                       label: block_c9HJz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HJz: // global
           if (R1 & 7 == 6) goto u9HKk; else goto u9HKl;
       u9HKk: // global
           Sp = Sp + 8;
           call _c9HK1() args: 0, res: 0, upd: 0;
       u9HKl: // global
           Sp = Sp + 8;
           call _c9HJX() args: 0, res: 0, upd: 0;
     }
 },
 _c9HJj() //  [R1]
         { info_tbl: [(c9HJj,
                       label: block_c9HJj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HJj: // global
           if (R1 & 7 == 5) goto u9HKm; else goto u9HKn;
       u9HKm: // global
           Sp = Sp + 8;
           call _c9HK1() args: 0, res: 0, upd: 0;
       u9HKn: // global
           Sp = Sp + 8;
           call _c9HJX() args: 0, res: 0, upd: 0;
     }
 },
 _c9HJ3() //  [R1]
         { info_tbl: [(c9HJ3,
                       label: block_c9HJ3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HJ3: // global
           if (R1 & 7 == 4) goto u9HKo; else goto u9HKp;
       u9HKo: // global
           Sp = Sp + 8;
           call _c9HK1() args: 0, res: 0, upd: 0;
       u9HKp: // global
           Sp = Sp + 8;
           call _c9HJX() args: 0, res: 0, upd: 0;
     }
 },
 _c9HIN() //  [R1]
         { info_tbl: [(c9HIN,
                       label: block_c9HIN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HIN: // global
           if (R1 & 7 == 3) goto u9HKq; else goto u9HKr;
       u9HKq: // global
           Sp = Sp + 8;
           call _c9HK1() args: 0, res: 0, upd: 0;
       u9HKr: // global
           Sp = Sp + 8;
           call _c9HJX() args: 0, res: 0, upd: 0;
     }
 },
 _c9HIx() //  [R1]
         { info_tbl: [(c9HIx,
                       label: block_c9HIx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HIx: // global
           if (R1 & 7 == 2) goto u9HKs; else goto u9HKt;
       u9HKs: // global
           Sp = Sp + 8;
           call _c9HK1() args: 0, res: 0, upd: 0;
       u9HKt: // global
           Sp = Sp + 8;
           call _c9HJX() args: 0, res: 0, upd: 0;
     }
 },
 _c9HIg() //  [R1]
         { info_tbl: [(c9HIg,
                       label: block_c9HIg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HIg: // global
           if (R1 & 7 == 1) goto u9HKu; else goto u9HKv;
       u9HKu: // global
           Sp = Sp + 8;
           call _c9HK1() args: 0, res: 0, upd: 0;
       u9HKv: // global
           Sp = Sp + 8;
           call _c9HJX() args: 0, res: 0, upd: 0;
     }
 },
 _c9HJP() //  [R1]
         { info_tbl: [(c9HJP,
                       label: block_c9HJP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HJP: // global
           if (R1 & 7 == 4) goto u9HKw; else goto u9HKx;
       u9HKw: // global
           Sp = Sp + 8;
           call _c9HK1() args: 0, res: 0, upd: 0;
       u9HKx: // global
           Sp = Sp + 8;
           call _c9HJX() args: 0, res: 0, upd: 0;
     }
 },
 _c9HK1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HK1: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9HJX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HJX: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.906295817 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadStatus_closure" {
     GHC.Conc.Sync.$fEqThreadStatus_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqThreadStatus_$c==_closure+2;
         const GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.907104094 UTC

[section ""data" . GHC.Conc.Sync.numSparks1_closure" {
     GHC.Conc.Sync.numSparks1_closure:
         const GHC.Conc.Sync.numSparks1_info;
 },
 GHC.Conc.Sync.numSparks1_entry() //  []
         { info_tbl: [(c9HLa,
                       label: GHC.Conc.Sync.numSparks1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HLa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9HLb; else goto c9HLc;
       c9HLb: // global
           R1 = GHC.Conc.Sync.numSparks1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9HLc: // global
           I64[Sp - 8] = block_c9HL7_info;
           Sp = Sp - 8;
           call stg_numSparks#() args: 8, res: 8, upd: 8;
     }
 },
 _c9HL7() //  [R1]
         { info_tbl: [(c9HL7,
                       label: block_c9HL7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HL7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9HLf; else goto c9HLe;
       c9HLf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9HLe: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.908149026 UTC

[section ""data" . GHC.Conc.Sync.numSparks_closure" {
     GHC.Conc.Sync.numSparks_closure:
         const GHC.Conc.Sync.numSparks_info;
 },
 GHC.Conc.Sync.numSparks_entry() //  []
         { info_tbl: [(c9HLk,
                       label: GHC.Conc.Sync.numSparks_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HLk: // global
           call GHC.Conc.Sync.numSparks1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.909332988 UTC

[section ""data" . GHC.Conc.Sync.throwTo1_closure" {
     GHC.Conc.Sync.throwTo1_closure:
         const GHC.Conc.Sync.throwTo1_info;
 },
 sat_s9FwG_entry() //  [R1]
         { info_tbl: [(c9HLA,
                       label: sat_s9FwG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HLA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9HLB; else goto c9HLC;
       c9HLB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9HLC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.throwTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c9HLD,
                       label: GHC.Conc.Sync.throwTo1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HLD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HLF; else goto c9HLG;
       c9HLF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.throwTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HLG: // global
           I64[Sp - 24] = block_c9HLr_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9HLM; else goto c9HLs;
       u9HLM: // global
           call _c9HLr(R1) args: 0, res: 0, upd: 0;
       c9HLs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HLr() //  [R1]
         { info_tbl: [(c9HLr,
                       label: block_c9HLr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HLr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9HLJ; else goto c9HLI;
       c9HLJ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HLI: // global
           _s9FwF::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s9FwG_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c9HLE_info;
           R2 = Hp - 24;
           R1 = _s9FwF::P64;
           Sp = Sp + 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HLE() //  []
         { info_tbl: [(c9HLE,
                       label: block_c9HLE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HLE: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.910942843 UTC

[section ""data" . GHC.Conc.Sync.throwTo_closure" {
     GHC.Conc.Sync.throwTo_closure:
         const GHC.Conc.Sync.throwTo_info;
 },
 GHC.Conc.Sync.throwTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c9HLR,
                       label: GHC.Conc.Sync.throwTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HLR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.throwTo1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.911808632 UTC

[section ""data" . GHC.Conc.Sync.myThreadId1_closure" {
     GHC.Conc.Sync.myThreadId1_closure:
         const GHC.Conc.Sync.myThreadId1_info;
 },
 GHC.Conc.Sync.myThreadId1_entry() //  []
         { info_tbl: [(c9HLZ,
                       label: GHC.Conc.Sync.myThreadId1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HLZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9HM3; else goto c9HM2;
       c9HM3: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.myThreadId1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9HM2: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           I64[Hp] = CurrentTSO;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.912652551 UTC

[section ""data" . GHC.Conc.Sync.myThreadId_closure" {
     GHC.Conc.Sync.myThreadId_closure:
         const GHC.Conc.Sync.myThreadId_info;
 },
 GHC.Conc.Sync.myThreadId_entry() //  []
         { info_tbl: [(c9HM8,
                       label: GHC.Conc.Sync.myThreadId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HM8: // global
           call GHC.Conc.Sync.myThreadId1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.913497962 UTC

[section ""data" . GHC.Conc.Sync.yield1_closure" {
     GHC.Conc.Sync.yield1_closure:
         const GHC.Conc.Sync.yield1_info;
 },
 GHC.Conc.Sync.yield1_entry() //  []
         { info_tbl: [(c9HMh,
                       label: GHC.Conc.Sync.yield1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HMh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9HMi; else goto c9HMj;
       c9HMi: // global
           R1 = GHC.Conc.Sync.yield1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9HMj: // global
           I64[Sp - 8] = block_c9HMf_info;
           Sp = Sp - 8;
           call stg_yield#() args: 8, res: 8, upd: 8;
     }
 },
 _c9HMf() //  []
         { info_tbl: [(c9HMf,
                       label: block_c9HMf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HMf: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.914452731 UTC

[section ""data" . GHC.Conc.Sync.yield_closure" {
     GHC.Conc.Sync.yield_closure:
         const GHC.Conc.Sync.yield_info;
 },
 GHC.Conc.Sync.yield_entry() //  []
         { info_tbl: [(c9HMp,
                       label: GHC.Conc.Sync.yield_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HMp: // global
           call GHC.Conc.Sync.yield1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.915680542 UTC

[section ""data" . GHC.Conc.Sync.labelThread1_closure" {
     GHC.Conc.Sync.labelThread1_closure:
         const GHC.Conc.Sync.labelThread1_info;
         const 0;
 },
 sat_s9FwZ_entry() //  [R1, R2]
         { info_tbl: [(c9HMJ,
                       label: sat_s9FwZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HMJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HMN; else goto c9HMO;
       c9HMN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HMO: // global
           I64[Sp - 16] = block_c9HMG_info;
           _s9FwT::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s9FwT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HMS; else goto c9HMH;
       u9HMS: // global
           call _c9HMG(R1) args: 0, res: 0, upd: 0;
       c9HMH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HMG() //  [R1]
         { info_tbl: [(c9HMG,
                       label: block_c9HMG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HMG: // global
           _s9FwT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9HMM_info;
           R2 = I64[R1 + 7];
           R1 = _s9FwT::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HMM() //  []
         { info_tbl: [(c9HMM,
                       label: block_c9HMM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HMM: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.labelThread1_entry() //  [R2, R3]
         { info_tbl: [(c9HMT,
                       label: GHC.Conc.Sync.labelThread1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HMT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HMU; else goto c9HMV;
       c9HMU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.labelThread1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HMV: // global
           I64[Sp - 16] = block_c9HMw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HMZ; else goto c9HMx;
       u9HMZ: // global
           call _c9HMw(R1) args: 0, res: 0, upd: 0;
       c9HMx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HMw() //  [R1]
         { info_tbl: [(c9HMw,
                       label: block_c9HMw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HMw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9HMY; else goto c9HMX;
       c9HMY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HMX: // global
           _s9FwT::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s9FwZ_info;
           P64[Hp] = _s9FwT::P64;
           R4 = Hp - 6;
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.917634467 UTC

[section ""data" . GHC.Conc.Sync.labelThread_closure" {
     GHC.Conc.Sync.labelThread_closure:
         const GHC.Conc.Sync.labelThread_info;
         const 0;
 },
 GHC.Conc.Sync.labelThread_entry() //  [R2, R3]
         { info_tbl: [(c9HN4,
                       label: GHC.Conc.Sync.labelThread_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HN4: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.labelThread1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.918526931 UTC

[section ""data" . GHC.Conc.Sync.pseq_closure" {
     GHC.Conc.Sync.pseq_closure:
         const GHC.Conc.Sync.pseq_info;
 },
 GHC.Conc.Sync.pseq_entry() //  [R2, R3]
         { info_tbl: [(c9HNd,
                       label: GHC.Conc.Sync.pseq_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HNd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HNe; else goto c9HNf;
       c9HNe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.pseq_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HNf: // global
           I64[Sp - 16] = block_c9HNb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HNb() //  []
         { info_tbl: [(c9HNb,
                       label: block_c9HNb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HNb: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.919591965 UTC

[section ""data" . GHC.Conc.Sync.par_closure" {
     GHC.Conc.Sync.par_closure:
         const GHC.Conc.Sync.par_info;
 },
 GHC.Conc.Sync.par_entry() //  [R2, R3]
         { info_tbl: [(c9HNq,
                       label: GHC.Conc.Sync.par_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HNq: // global
           _s9Fx4::P64 = R3;
           (_c9HNl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [] newSpark(BaseReg, R2);
           R1 = _s9Fx4::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.920627601 UTC

[section ""data" . GHC.Conc.Sync.runSparks_loop_closure" {
     GHC.Conc.Sync.runSparks_loop_closure:
         const GHC.Conc.Sync.runSparks_loop_info;
 },
 GHC.Conc.Sync.runSparks_loop_entry() //  []
         { info_tbl: [(c9HNF,
                       label: GHC.Conc.Sync.runSparks_loop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HNF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9HNG; else goto u9HNO;
       c9HNG: // global
           R1 = GHC.Conc.Sync.runSparks_loop_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       u9HNO: // global
           call _c9HNu() args: 0, res: 0, upd: 0;
     }
 },
 _c9HNu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HNu: // global
           I64[Sp - 8] = block_c9HNx_info;
           Sp = Sp - 8;
           call stg_getSpark#() args: 8, res: 8, upd: 8;
     }
 },
 _c9HNx() //  [R1, R2]
         { info_tbl: [(c9HNx,
                       label: block_c9HNx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HNx: // global
           if (R1 == 0) goto c9HNE; else goto c9HND;
       c9HNE: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9HND: // global
           I64[Sp] = block_c9HNK_info;
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HNK() //  []
         { info_tbl: [(c9HNK,
                       label: block_c9HNK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HNK: // global
           Sp = Sp + 8;
           call _c9HNu() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.921798207 UTC

[section ""data" . GHC.Conc.Sync.runSparks_closure" {
     GHC.Conc.Sync.runSparks_closure:
         const GHC.Conc.Sync.runSparks_info;
 },
 GHC.Conc.Sync.runSparks_entry() //  []
         { info_tbl: [(c9HNU,
                       label: GHC.Conc.Sync.runSparks_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HNU: // global
           call GHC.Conc.Sync.runSparks_loop_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.92299583 UTC

[section ""data" . GHC.Conc.Sync.threadCapability1_closure" {
     GHC.Conc.Sync.threadCapability1_closure:
         const GHC.Conc.Sync.threadCapability1_info;
 },
 sat_s9Fxo_entry() //  [R1]
         { info_tbl: [(c9HOi,
                       label: sat_s9Fxo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HOi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HOj; else goto c9HOk;
       c9HOj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9HOk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c9HOh; else goto c9HOg;
       c9HOh: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9HOg: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.threadCapability1_entry() //  [R2]
         { info_tbl: [(c9HOl,
                       label: GHC.Conc.Sync.threadCapability1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HOl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9HOo; else goto c9HOp;
       c9HOo: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.threadCapability1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HOp: // global
           I64[Sp - 8] = block_c9HO1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9HOw; else goto c9HO2;
       u9HOw: // global
           call _c9HO1(R1) args: 0, res: 0, upd: 0;
       c9HO2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HO1() //  [R1]
         { info_tbl: [(c9HO1,
                       label: block_c9HO1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HO1: // global
           I64[Sp] = block_c9HO6_info;
           R1 = P64[R1 + 7];
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HO6() //  [R2, R3]
         { info_tbl: [(c9HO6,
                       label: block_c9HO6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HO6: // global
           I64[Sp - 8] = R3;
           I64[Sp] = R2;
           Sp = Sp - 16;
           call _c9HO7() args: 0, res: 0, upd: 0;
     }
 },
 _c9HO7() //  []
         { info_tbl: [(c9HO7,
                       label: block_c9HO7_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HO7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c9HOt; else goto c9HOs;
       c9HOt: // global
           HpAlloc = 64;
           I64[Sp] = block_c9HO7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c9HOs: // global
           I64[Hp - 56] = sat_s9Fxo_info;
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.924708046 UTC

[section ""data" . GHC.Conc.Sync.threadCapability_closure" {
     GHC.Conc.Sync.threadCapability_closure:
         const GHC.Conc.Sync.threadCapability_info;
 },
 GHC.Conc.Sync.threadCapability_entry() //  [R2]
         { info_tbl: [(c9HOB,
                       label: GHC.Conc.Sync.threadCapability_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HOB: // global
           R2 = R2;
           call GHC.Conc.Sync.threadCapability1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.925738796 UTC

[section ""data" . GHC.Conc.Sync.mkWeakThreadId1_closure" {
     GHC.Conc.Sync.mkWeakThreadId1_closure:
         const GHC.Conc.Sync.mkWeakThreadId1_info;
 },
 GHC.Conc.Sync.mkWeakThreadId1_entry() //  [R2]
         { info_tbl: [(c9HOL,
                       label: GHC.Conc.Sync.mkWeakThreadId1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HOL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9HOR; else goto c9HOS;
       c9HOR: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.mkWeakThreadId1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HOS: // global
           I64[Sp - 8] = block_c9HOI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9HOX; else goto c9HOJ;
       u9HOX: // global
           call _c9HOI(R1) args: 0, res: 0, upd: 0;
       c9HOJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HOI() //  [R1]
         { info_tbl: [(c9HOI,
                       label: block_c9HOI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HOI: // global
           I64[Sp] = block_c9HOO_info;
           R2 = R1;
           R1 = P64[R1 + 7];
           call stg_mkWeakNoFinalizer#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HOO() //  [R1]
         { info_tbl: [(c9HOO,
                       label: block_c9HOO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HOO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9HOW; else goto c9HOV;
       c9HOW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HOV: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.927003837 UTC

[section ""data" . GHC.Conc.Sync.mkWeakThreadId_closure" {
     GHC.Conc.Sync.mkWeakThreadId_closure:
         const GHC.Conc.Sync.mkWeakThreadId_info;
 },
 GHC.Conc.Sync.mkWeakThreadId_entry() //  [R2]
         { info_tbl: [(c9HP2,
                       label: GHC.Conc.Sync.mkWeakThreadId_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HP2: // global
           R2 = R2;
           call GHC.Conc.Sync.mkWeakThreadId1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.927932769 UTC

[section ""data" . GHC.Conc.Sync.newStablePtrPrimMVar1_closure" {
     GHC.Conc.Sync.newStablePtrPrimMVar1_closure:
         const GHC.Conc.Sync.newStablePtrPrimMVar1_info;
 },
 GHC.Conc.Sync.newStablePtrPrimMVar1_entry() //  [R2]
         { info_tbl: [(c9HPc,
                       label: GHC.Conc.Sync.newStablePtrPrimMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HPc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9HPi; else goto c9HPj;
       c9HPi: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.newStablePtrPrimMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HPj: // global
           I64[Sp - 8] = block_c9HP9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9HPo; else goto c9HPa;
       u9HPo: // global
           call _c9HP9(R1) args: 0, res: 0, upd: 0;
       c9HPa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HP9() //  [R1]
         { info_tbl: [(c9HP9,
                       label: block_c9HP9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HP9: // global
           I64[Sp] = block_c9HPf_info;
           R1 = P64[R1 + 7];
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HPf() //  [R1]
         { info_tbl: [(c9HPf,
                       label: block_c9HPf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HPf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9HPn; else goto c9HPm;
       c9HPn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9HPm: // global
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.929210431 UTC

[section ""data" . GHC.Conc.Sync.newStablePtrPrimMVar_closure" {
     GHC.Conc.Sync.newStablePtrPrimMVar_closure:
         const GHC.Conc.Sync.newStablePtrPrimMVar_info;
 },
 GHC.Conc.Sync.newStablePtrPrimMVar_entry() //  [R2]
         { info_tbl: [(c9HPt,
                       label: GHC.Conc.Sync.newStablePtrPrimMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HPt: // global
           R2 = R2;
           call GHC.Conc.Sync.newStablePtrPrimMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.930140223 UTC

[section ""data" . $c>>=_r9FuK_closure" {
     $c>>=_r9FuK_closure:
         const $c>>=_r9FuK_info;
 },
 $c>>=_r9FuK_entry() //  [R2, R3]
         { info_tbl: [(c9HPC,
                       label: $c>>=_r9FuK_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HPC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HPD; else goto c9HPE;
       c9HPD: // global
           R3 = R3;
           R2 = R2;
           R1 = $c>>=_r9FuK_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HPE: // global
           I64[Sp - 16] = block_c9HPA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HPA() //  [R1]
         { info_tbl: [(c9HPA,
                       label: block_c9HPA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HPA: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.93120418 UTC

[section ""data" . GHC.Conc.Sync.$fMonadSTM_$c>>=_closure" {
     GHC.Conc.Sync.$fMonadSTM_$c>>=_closure:
         const GHC.Conc.Sync.$fMonadSTM_$c>>=_info;
 },
 GHC.Conc.Sync.$fMonadSTM_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c9HPK,
                       label: GHC.Conc.Sync.$fMonadSTM_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HPK: // global
           R3 = R3;
           R2 = R2;
           call $c>>=_r9FuK_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.932047502 UTC

[section ""data" . $c*>_r9FuL_closure" {
     $c*>_r9FuL_closure:
         const $c*>_r9FuL_info;
 },
 $c*>_r9FuL_entry() //  [R2, R3]
         { info_tbl: [(c9HPT,
                       label: $c*>_r9FuL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HPT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HPU; else goto c9HPV;
       c9HPU: // global
           R3 = R3;
           R2 = R2;
           R1 = $c*>_r9FuL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HPV: // global
           I64[Sp - 16] = block_c9HPR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HPR() //  []
         { info_tbl: [(c9HPR,
                       label: block_c9HPR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HPR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.936532629 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure:
         const GHC.Conc.Sync.$fApplicativeSTM_$c*>_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM_$c*>_entry() //  [R2, R3]
         { info_tbl: [(c9HQ1,
                       label: GHC.Conc.Sync.$fApplicativeSTM_$c*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HQ1: // global
           R3 = R3;
           R2 = R2;
           call $c*>_r9FuL_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.93738815 UTC

[section ""data" . GHC.Conc.Sync.orElse_closure" {
     GHC.Conc.Sync.orElse_closure:
         const GHC.Conc.Sync.orElse_info;
 },
 GHC.Conc.Sync.orElse_entry() //  [R2, R3]
         { info_tbl: [(c9HQ8,
                       label: GHC.Conc.Sync.orElse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HQ8: // global
           _B3::P64 = R2;
           R2 = R3;
           R1 = _B3::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.938681485 UTC

[section ""data" . GHC.Conc.Sync.catchSTM1_closure" {
     GHC.Conc.Sync.catchSTM1_closure:
         const GHC.Conc.Sync.catchSTM1_info;
 },
 sat_s9FxY_entry() //  [R1]
         { info_tbl: [(c9HQt,
                       label: sat_s9FxY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HQt: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9Fy0_entry() //  [R1, R2]
         { info_tbl: [(c9HQA,
                       label: sat_s9Fy0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HQA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9HQB; else goto c9HQC;
       c9HQB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HQC: // global
           I64[Sp - 24] = block_c9HQk_info;
           _s9FxW::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s9FxW::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _s9FxW::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c9HQk() //  [R1]
         { info_tbl: [(c9HQk,
                       label: block_c9HQk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HQk: // global
           if (R1 & 7 == 1) goto c9HQx; else goto c9HQy;
       c9HQx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9HQF; else goto c9HQE;
       c9HQF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HQE: // global
           I64[Hp - 8] = sat_s9FxY_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9HQy: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.catchSTM1_entry() //  [R2, R3, R4]
         { info_tbl: [(c9HQJ,
                       label: GHC.Conc.Sync.catchSTM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HQJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9HQN; else goto c9HQM;
       c9HQN: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.catchSTM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HQM: // global
           I64[Hp - 16] = sat_s9Fy0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 15;
           R1 = R3;
           call stg_catchSTM#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.940427102 UTC

[section ""data" . GHC.Conc.Sync.catchSTM_closure" {
     GHC.Conc.Sync.catchSTM_closure:
         const GHC.Conc.Sync.catchSTM_info;
 },
 GHC.Conc.Sync.catchSTM_entry() //  [R2, R3, R4]
         { info_tbl: [(c9HQS,
                       label: GHC.Conc.Sync.catchSTM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HQS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.catchSTM1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.941298595 UTC

[section ""data" . $cpure_r9FuM_closure" {
     $cpure_r9FuM_closure:
         const $cpure_r9FuM_info;
 },
 $cpure_r9FuM_entry() //  [R2]
         { info_tbl: [(c9HQZ,
                       label: $cpure_r9FuM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HQZ: // global
           R1 = R2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.942090932 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure:
         const GHC.Conc.Sync.$fApplicativeSTM_$cpure_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM_$cpure_entry() //  [R2]
         { info_tbl: [(c9HR6,
                       label: GHC.Conc.Sync.$fApplicativeSTM_$cpure_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HR6: // global
           R2 = R2;
           call $cpure_r9FuM_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.942903441 UTC

[section ""data" . GHC.Conc.Sync.unsafeIOToSTM1_closure" {
     GHC.Conc.Sync.unsafeIOToSTM1_closure:
         const GHC.Conc.Sync.unsafeIOToSTM1_info;
 },
 GHC.Conc.Sync.unsafeIOToSTM1_entry() //  [R2]
         { info_tbl: [(c9HRd,
                       label: GHC.Conc.Sync.unsafeIOToSTM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HRd: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.94369116 UTC

[section ""data" . GHC.Conc.Sync.unsafeIOToSTM_closure" {
     GHC.Conc.Sync.unsafeIOToSTM_closure:
         const GHC.Conc.Sync.unsafeIOToSTM_info;
 },
 GHC.Conc.Sync.unsafeIOToSTM_entry() //  [R2]
         { info_tbl: [(c9HRk,
                       label: GHC.Conc.Sync.unsafeIOToSTM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HRk: // global
           R2 = R2;
           call GHC.Conc.Sync.unsafeIOToSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.944476099 UTC

[section ""data" . GHC.Conc.Sync.atomically_closure" {
     GHC.Conc.Sync.atomically_closure:
         const GHC.Conc.Sync.atomically_info;
 },
 GHC.Conc.Sync.atomically_entry() //  [R2]
         { info_tbl: [(c9HRr,
                       label: GHC.Conc.Sync.atomically_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HRr: // global
           R1 = R2;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.945291703 UTC

[section ""data" . GHC.Conc.Sync.retry_closure" {
     GHC.Conc.Sync.retry_closure:
         const GHC.Conc.Sync.retry_info;
 },
 GHC.Conc.Sync.retry_entry() //  []
         { info_tbl: [(c9HRy,
                       label: GHC.Conc.Sync.retry_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HRy: // global
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.946261598 UTC

[section ""data" . GHC.Conc.Sync.throwSTM1_closure" {
     GHC.Conc.Sync.throwSTM1_closure:
         const GHC.Conc.Sync.throwSTM1_info;
 },
 sat_s9Fy7_entry() //  [R1]
         { info_tbl: [(c9HRJ,
                       label: sat_s9Fy7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HRJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9HRK; else goto c9HRL;
       c9HRK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9HRL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.throwSTM1_entry() //  [R2, R3]
         { info_tbl: [(c9HRM,
                       label: GHC.Conc.Sync.throwSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HRM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9HRQ; else goto c9HRP;
       c9HRQ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.throwSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HRP: // global
           I64[Hp - 24] = sat_s9Fy7_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.94743622 UTC

[section ""data" . GHC.Conc.Sync.throwSTM_closure" {
     GHC.Conc.Sync.throwSTM_closure:
         const GHC.Conc.Sync.throwSTM_info;
 },
 GHC.Conc.Sync.throwSTM_entry() //  [R2, R3]
         { info_tbl: [(c9HRV,
                       label: GHC.Conc.Sync.throwSTM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HRV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.throwSTM1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.94834621 UTC

[section ""data" . GHC.Conc.Sync.newTVar1_closure" {
     GHC.Conc.Sync.newTVar1_closure:
         const GHC.Conc.Sync.newTVar1_info;
 },
 GHC.Conc.Sync.newTVar1_entry() //  [R2]
         { info_tbl: [(c9HS5,
                       label: GHC.Conc.Sync.newTVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HS5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9HS6; else goto c9HS7;
       c9HS6: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.newTVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HS7: // global
           I64[Sp - 8] = block_c9HS2_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HS2() //  [R1]
         { info_tbl: [(c9HS2,
                       label: block_c9HS2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HS2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9HSa; else goto c9HS9;
       c9HSa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9HS9: // global
           I64[Hp - 8] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.949458693 UTC

[section ""data" . GHC.Conc.Sync.newTVar_closure" {
     GHC.Conc.Sync.newTVar_closure:
         const GHC.Conc.Sync.newTVar_info;
 },
 GHC.Conc.Sync.newTVar_entry() //  [R2]
         { info_tbl: [(c9HSf,
                       label: GHC.Conc.Sync.newTVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HSf: // global
           R2 = R2;
           call GHC.Conc.Sync.newTVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.950228311 UTC

[section ""data" . GHC.Conc.Sync.newTVarIO_closure" {
     GHC.Conc.Sync.newTVarIO_closure:
         const GHC.Conc.Sync.newTVarIO_info;
 },
 GHC.Conc.Sync.newTVarIO_entry() //  [R2]
         { info_tbl: [(c9HSm,
                       label: GHC.Conc.Sync.newTVarIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HSm: // global
           R2 = R2;
           call GHC.Conc.Sync.newTVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.951081594 UTC

[section ""data" . GHC.Conc.Sync.readTVarIO1_closure" {
     GHC.Conc.Sync.readTVarIO1_closure:
         const GHC.Conc.Sync.readTVarIO1_info;
 },
 GHC.Conc.Sync.readTVarIO1_entry() //  [R2]
         { info_tbl: [(c9HSw,
                       label: GHC.Conc.Sync.readTVarIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HSw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9HSx; else goto c9HSy;
       c9HSx: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.readTVarIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HSy: // global
           I64[Sp - 8] = block_c9HSt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9HSC; else goto c9HSu;
       u9HSC: // global
           call _c9HSt(R1) args: 0, res: 0, upd: 0;
       c9HSu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HSt() //  [R1]
         { info_tbl: [(c9HSt,
                       label: block_c9HSt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HSt: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readTVarIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.952206067 UTC

[section ""data" . GHC.Conc.Sync.readTVarIO_closure" {
     GHC.Conc.Sync.readTVarIO_closure:
         const GHC.Conc.Sync.readTVarIO_info;
 },
 GHC.Conc.Sync.readTVarIO_entry() //  [R2]
         { info_tbl: [(c9HSH,
                       label: GHC.Conc.Sync.readTVarIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HSH: // global
           R2 = R2;
           call GHC.Conc.Sync.readTVarIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.953061214 UTC

[section ""data" . GHC.Conc.Sync.readTVar1_closure" {
     GHC.Conc.Sync.readTVar1_closure:
         const GHC.Conc.Sync.readTVar1_info;
 },
 GHC.Conc.Sync.readTVar1_entry() //  [R2]
         { info_tbl: [(c9HSR,
                       label: GHC.Conc.Sync.readTVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HSR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9HSS; else goto c9HST;
       c9HSS: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.readTVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9HST: // global
           I64[Sp - 8] = block_c9HSO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9HSX; else goto c9HSP;
       u9HSX: // global
           call _c9HSO(R1) args: 0, res: 0, upd: 0;
       c9HSP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HSO() //  [R1]
         { info_tbl: [(c9HSO,
                       label: block_c9HSO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HSO: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readTVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.9544932 UTC

[section ""data" . GHC.Conc.Sync.readTVar_closure" {
     GHC.Conc.Sync.readTVar_closure:
         const GHC.Conc.Sync.readTVar_info;
 },
 GHC.Conc.Sync.readTVar_entry() //  [R2]
         { info_tbl: [(c9HT2,
                       label: GHC.Conc.Sync.readTVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HT2: // global
           R2 = R2;
           call GHC.Conc.Sync.readTVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.955361056 UTC

[section ""data" . GHC.Conc.Sync.writeTVar1_closure" {
     GHC.Conc.Sync.writeTVar1_closure:
         const GHC.Conc.Sync.writeTVar1_info;
 },
 GHC.Conc.Sync.writeTVar1_entry() //  [R2, R3]
         { info_tbl: [(c9HTc,
                       label: GHC.Conc.Sync.writeTVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HTc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HTg; else goto c9HTh;
       c9HTg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.writeTVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HTh: // global
           I64[Sp - 16] = block_c9HT9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HTl; else goto c9HTa;
       u9HTl: // global
           call _c9HT9(R1) args: 0, res: 0, upd: 0;
       c9HTa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HT9() //  [R1]
         { info_tbl: [(c9HT9,
                       label: block_c9HT9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HT9: // global
           _s9Fyn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9HTf_info;
           R2 = _s9Fyn::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HTf() //  []
         { info_tbl: [(c9HTf,
                       label: block_c9HTf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HTf: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.956542067 UTC

[section ""data" . GHC.Conc.Sync.writeTVar_closure" {
     GHC.Conc.Sync.writeTVar_closure:
         const GHC.Conc.Sync.writeTVar_info;
 },
 GHC.Conc.Sync.writeTVar_entry() //  [R2, R3]
         { info_tbl: [(c9HTq,
                       label: GHC.Conc.Sync.writeTVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HTq: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.writeTVar1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.958632651 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$ccompare_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c9HTI,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HTI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HTJ; else goto c9HTK;
       c9HTJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HTK: // global
           I64[Sp - 16] = block_c9HTx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HWN; else goto c9HTy;
       u9HWN: // global
           call _c9HTx(R1) args: 0, res: 0, upd: 0;
       c9HTy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HTx() //  [R1]
         { info_tbl: [(c9HTx,
                       label: block_c9HTx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HTx: // global
           _s9Fyt::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9HTB;
               case 2 : goto c9HTC;
               case 3 : goto c9HTD;
               case 4 : goto c9HTE;
               case 5 : goto c9HTF;
               case 6 : goto c9HTG;
           }
       c9HTG: // global
           I64[Sp + 8] = block_c9HVU_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HWM; else goto c9HVW;
       u9HWM: // global
           call _c9HVU(R1) args: 0, res: 0, upd: 0;
       c9HVW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HTF: // global
           I64[Sp + 8] = block_c9HVB_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HWL; else goto c9HVD;
       u9HWL: // global
           call _c9HVB(R1) args: 0, res: 0, upd: 0;
       c9HVD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HTE: // global
           I64[Sp + 8] = block_c9HVe_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HWK; else goto c9HVg;
       u9HWK: // global
           call _c9HVe(R1) args: 0, res: 0, upd: 0;
       c9HVg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HTD: // global
           I64[Sp + 8] = block_c9HUN_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HWJ; else goto c9HUP;
       u9HWJ: // global
           call _c9HUN(R1) args: 0, res: 0, upd: 0;
       c9HUP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HTC: // global
           I64[Sp + 8] = block_c9HUi_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HWI; else goto c9HUk;
       u9HWI: // global
           call _c9HUi(R1) args: 0, res: 0, upd: 0;
       c9HUk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HTB: // global
           I64[Sp + 8] = block_c9HTN_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HWH; else goto c9HTP;
       u9HWH: // global
           call _c9HTN(R1) args: 0, res: 0, upd: 0;
       c9HTP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HVU() //  [R1]
         { info_tbl: [(c9HVU,
                       label: block_c9HVU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HVU: // global
           if (R1 & 7 == 6) goto u9HWi; else goto u9HWj;
       u9HWi: // global
           Sp = Sp + 8;
           call _c9HW6() args: 0, res: 0, upd: 0;
       u9HWj: // global
           Sp = Sp + 8;
           call _c9HW2() args: 0, res: 0, upd: 0;
     }
 },
 _c9HVB() //  [R1]
         { info_tbl: [(c9HVB,
                       label: block_c9HVB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HVB: // global
           _c9HW8::P64 = R1 & 7;
           if (_c9HW8::P64 != 5) goto u9HWh; else goto u9HWk;
       u9HWh: // global
           if (_c9HW8::P64 != 6) goto u9HWm; else goto u9HWl;
       u9HWm: // global
           Sp = Sp + 8;
           call _c9HW2() args: 0, res: 0, upd: 0;
       u9HWl: // global
           Sp = Sp + 8;
           call _c9HVR() args: 0, res: 0, upd: 0;
       u9HWk: // global
           Sp = Sp + 8;
           call _c9HW6() args: 0, res: 0, upd: 0;
     }
 },
 _c9HVe() //  [R1]
         { info_tbl: [(c9HVe,
                       label: block_c9HVe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HVe: // global
           _c9HW9::P64 = R1 & 7;
           if (_c9HW9::P64 < 5) goto u9HWf; else goto u9HWg;
       u9HWf: // global
           if (_c9HW9::P64 < 4) goto u9HWo; else goto u9HWn;
       u9HWo: // global
           Sp = Sp + 8;
           call _c9HW2() args: 0, res: 0, upd: 0;
       u9HWn: // global
           Sp = Sp + 8;
           call _c9HW6() args: 0, res: 0, upd: 0;
       u9HWg: // global
           if (_c9HW9::P64 < 6) goto u9HWq; else goto u9HWq;
       u9HWq: // global
           Sp = Sp + 8;
           call _c9HVR() args: 0, res: 0, upd: 0;
     }
 },
 _c9HUN() //  [R1]
         { info_tbl: [(c9HUN,
                       label: block_c9HUN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HUN: // global
           _c9HWa::P64 = R1 & 7;
           if (_c9HWa::P64 < 4) goto u9HWd; else goto u9HWe;
       u9HWd: // global
           if (_c9HWa::P64 < 3) goto u9HWs; else goto u9HWr;
       u9HWs: // global
           Sp = Sp + 8;
           call _c9HW2() args: 0, res: 0, upd: 0;
       u9HWr: // global
           Sp = Sp + 8;
           call _c9HW6() args: 0, res: 0, upd: 0;
       u9HWe: // global
           if (_c9HWa::P64 != 5) goto u9HWu; else goto u9HWu;
       u9HWu: // global
           Sp = Sp + 8;
           call _c9HVR() args: 0, res: 0, upd: 0;
     }
 },
 _c9HUi() //  [R1]
         { info_tbl: [(c9HUi,
                       label: block_c9HUi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HUi: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9HWv;
               case 2 : goto u9HWw;
               case 3, 4, 5, 6 : goto u9HWA;
           }
       u9HWA: // global
           Sp = Sp + 8;
           call _c9HVR() args: 0, res: 0, upd: 0;
       u9HWw: // global
           Sp = Sp + 8;
           call _c9HW6() args: 0, res: 0, upd: 0;
       u9HWv: // global
           Sp = Sp + 8;
           call _c9HW2() args: 0, res: 0, upd: 0;
     }
 },
 _c9HW2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HW2: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9HTN() //  [R1]
         { info_tbl: [(c9HTN,
                       label: block_c9HTN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HTN: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9HWB;
               case 2, 3, 4, 5, 6 : goto u9HWG;
           }
       u9HWG: // global
           Sp = Sp + 8;
           call _c9HVR() args: 0, res: 0, upd: 0;
       u9HWB: // global
           Sp = Sp + 8;
           call _c9HW6() args: 0, res: 0, upd: 0;
     }
 },
 _c9HVR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HVR: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9HW6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HW6: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.962897764 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c<_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c<_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c<_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c<_entry() //  [R2, R3]
         { info_tbl: [(c9HXj,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HXj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9HXk; else goto c9HXl;
       c9HXk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9HXl: // global
           I64[Sp - 16] = block_c9HX8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9HZT; else goto c9HX9;
       u9HZT: // global
           call _c9HX8(R1) args: 0, res: 0, upd: 0;
       c9HX9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HX8() //  [R1]
         { info_tbl: [(c9HX8,
                       label: block_c9HX8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HX8: // global
           _s9FyC::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9HXc;
               case 2 : goto c9HXd;
               case 3 : goto c9HXe;
               case 4 : goto c9HXf;
               case 5 : goto c9HXg;
               case 6 : goto c9HXh;
           }
       c9HXh: // global
           I64[Sp + 8] = block_c9HZf_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HZS; else goto c9HZh;
       u9HZS: // global
           call _c9HZf() args: 0, res: 0, upd: 0;
       c9HZh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HXg: // global
           I64[Sp + 8] = block_c9HZ0_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HZR; else goto c9HZ2;
       u9HZR: // global
           call _c9HZ0(R1) args: 0, res: 0, upd: 0;
       c9HZ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HXf: // global
           I64[Sp + 8] = block_c9HYH_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HZQ; else goto c9HYJ;
       u9HZQ: // global
           call _c9HYH(R1) args: 0, res: 0, upd: 0;
       c9HYJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HXe: // global
           I64[Sp + 8] = block_c9HYk_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HZP; else goto c9HYm;
       u9HZP: // global
           call _c9HYk(R1) args: 0, res: 0, upd: 0;
       c9HYm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HXd: // global
           I64[Sp + 8] = block_c9HXT_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HZO; else goto c9HXV;
       u9HZO: // global
           call _c9HXT(R1) args: 0, res: 0, upd: 0;
       c9HXV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9HXc: // global
           I64[Sp + 8] = block_c9HXo_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9HZN; else goto c9HXq;
       u9HZN: // global
           call _c9HXo(R1) args: 0, res: 0, upd: 0;
       c9HXq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9HZf() //  []
         { info_tbl: [(c9HZf,
                       label: block_c9HZf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HZf: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9HZ0() //  [R1]
         { info_tbl: [(c9HZ0,
                       label: block_c9HZ0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HZ0: // global
           if (R1 & 7 == 6) goto u9HZv; else goto u9HZw;
       u9HZv: // global
           Sp = Sp + 8;
           call _c9HZc() args: 0, res: 0, upd: 0;
       u9HZw: // global
           Sp = Sp + 8;
           call _c9HZ8() args: 0, res: 0, upd: 0;
     }
 },
 _c9HYH() //  [R1]
         { info_tbl: [(c9HYH,
                       label: block_c9HYH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HYH: // global
           _c9HZn::P64 = R1 & 7;
           if (_c9HZn::P64 != 5) goto u9HZu; else goto u9HZx;
       u9HZu: // global
           if (_c9HZn::P64 != 6) goto u9HZz; else goto u9HZy;
       u9HZz: // global
           Sp = Sp + 8;
           call _c9HZ8() args: 0, res: 0, upd: 0;
       u9HZy: // global
           Sp = Sp + 8;
           goto u9I02;
       u9HZx: // global
           Sp = Sp + 8;
           goto u9I02;
       u9I02: // global
           call _c9HZc() args: 0, res: 0, upd: 0;
     }
 },
 _c9HYk() //  [R1]
         { info_tbl: [(c9HYk,
                       label: block_c9HYk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HYk: // global
           _c9HZo::P64 = R1 & 7;
           if (_c9HZo::P64 < 4) goto u9HZA; else goto u9HZt;
       u9HZA: // global
           Sp = Sp + 8;
           call _c9HZ8() args: 0, res: 0, upd: 0;
       u9HZt: // global
           if (_c9HZo::P64 != 5) goto u9HZC; else goto u9HZC;
       u9HZC: // global
           Sp = Sp + 8;
           call _c9HZc() args: 0, res: 0, upd: 0;
     }
 },
 _c9HXT() //  [R1]
         { info_tbl: [(c9HXT,
                       label: block_c9HXT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HXT: // global
           _c9HZp::P64 = R1 & 7;
           if (_c9HZp::P64 < 6) goto u9HZr; else goto u9HZD;
       u9HZr: // global
           if (_c9HZp::P64 < 3) goto u9HZE; else goto u9HZs;
       u9HZE: // global
           Sp = Sp + 8;
           call _c9HZ8() args: 0, res: 0, upd: 0;
       u9HZs: // global
           if (_c9HZp::P64 != 4) goto u9HZG; else goto u9HZG;
       u9HZG: // global
           Sp = Sp + 8;
           goto u9HZY;
       u9HZD: // global
           Sp = Sp + 8;
           goto u9HZY;
       u9HZY: // global
           call _c9HZc() args: 0, res: 0, upd: 0;
     }
 },
 _c9HXo() //  [R1]
         { info_tbl: [(c9HXo,
                       label: block_c9HXo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HXo: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9HZH;
               case 2, 3, 4, 5, 6 : goto u9HZM;
           }
       u9HZM: // global
           Sp = Sp + 8;
           call _c9HZc() args: 0, res: 0, upd: 0;
       u9HZH: // global
           Sp = Sp + 8;
           call _c9HZ8() args: 0, res: 0, upd: 0;
     }
 },
 _c9HZc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HZc: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9HZ8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9HZ8: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.966889764 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c<=_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c9I0l,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I0l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9I0m; else goto c9I0n;
       c9I0m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9I0n: // global
           I64[Sp - 16] = block_c9I0a_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9I2V; else goto c9I0b;
       u9I2V: // global
           call _c9I0a(R1) args: 0, res: 0, upd: 0;
       c9I0b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9I0a() //  [R1]
         { info_tbl: [(c9I0a,
                       label: block_c9I0a_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I0a: // global
           _s9FyK::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9I0e;
               case 2 : goto c9I0f;
               case 3 : goto c9I0g;
               case 4 : goto c9I0h;
               case 5 : goto c9I0i;
               case 6 : goto c9I0j;
           }
       c9I0j: // global
           I64[Sp + 8] = block_c9I2h_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I2U; else goto c9I2j;
       u9I2U: // global
           call _c9I2h() args: 0, res: 0, upd: 0;
       c9I2j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I0i: // global
           I64[Sp + 8] = block_c9I22_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I2T; else goto c9I24;
       u9I2T: // global
           call _c9I22(R1) args: 0, res: 0, upd: 0;
       c9I24: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I0h: // global
           I64[Sp + 8] = block_c9I1J_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I2S; else goto c9I1L;
       u9I2S: // global
           call _c9I1J(R1) args: 0, res: 0, upd: 0;
       c9I1L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I0g: // global
           I64[Sp + 8] = block_c9I1m_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I2R; else goto c9I1o;
       u9I2R: // global
           call _c9I1m(R1) args: 0, res: 0, upd: 0;
       c9I1o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I0f: // global
           I64[Sp + 8] = block_c9I0V_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I2Q; else goto c9I0X;
       u9I2Q: // global
           call _c9I0V(R1) args: 0, res: 0, upd: 0;
       c9I0X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I0e: // global
           I64[Sp + 8] = block_c9I0q_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I2P; else goto c9I0s;
       u9I2P: // global
           call _c9I0q(R1) args: 0, res: 0, upd: 0;
       c9I0s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9I2h() //  []
         { info_tbl: [(c9I2h,
                       label: block_c9I2h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I2h: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9I22() //  [R1]
         { info_tbl: [(c9I22,
                       label: block_c9I22_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I22: // global
           if (R1 & 7 == 6) goto u9I2x; else goto u9I2y;
       u9I2x: // global
           Sp = Sp + 8;
           call _c9I2e() args: 0, res: 0, upd: 0;
       u9I2y: // global
           Sp = Sp + 8;
           call _c9I2a() args: 0, res: 0, upd: 0;
     }
 },
 _c9I1J() //  [R1]
         { info_tbl: [(c9I1J,
                       label: block_c9I1J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I1J: // global
           _c9I2p::P64 = R1 & 7;
           if (_c9I2p::P64 != 5) goto u9I2w; else goto u9I2z;
       u9I2w: // global
           if (_c9I2p::P64 != 6) goto u9I2B; else goto u9I2A;
       u9I2B: // global
           Sp = Sp + 8;
           call _c9I2a() args: 0, res: 0, upd: 0;
       u9I2A: // global
           Sp = Sp + 8;
           goto u9I34;
       u9I2z: // global
           Sp = Sp + 8;
           goto u9I34;
       u9I34: // global
           call _c9I2e() args: 0, res: 0, upd: 0;
     }
 },
 _c9I1m() //  [R1]
         { info_tbl: [(c9I1m,
                       label: block_c9I1m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I1m: // global
           _c9I2q::P64 = R1 & 7;
           if (_c9I2q::P64 < 4) goto u9I2C; else goto u9I2v;
       u9I2C: // global
           Sp = Sp + 8;
           call _c9I2a() args: 0, res: 0, upd: 0;
       u9I2v: // global
           if (_c9I2q::P64 != 5) goto u9I2E; else goto u9I2E;
       u9I2E: // global
           Sp = Sp + 8;
           call _c9I2e() args: 0, res: 0, upd: 0;
     }
 },
 _c9I0V() //  [R1]
         { info_tbl: [(c9I0V,
                       label: block_c9I0V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I0V: // global
           _c9I2r::P64 = R1 & 7;
           if (_c9I2r::P64 < 6) goto u9I2t; else goto u9I2F;
       u9I2t: // global
           if (_c9I2r::P64 < 3) goto u9I2G; else goto u9I2u;
       u9I2G: // global
           Sp = Sp + 8;
           call _c9I2a() args: 0, res: 0, upd: 0;
       u9I2u: // global
           if (_c9I2r::P64 != 4) goto u9I2I; else goto u9I2I;
       u9I2I: // global
           Sp = Sp + 8;
           goto u9I30;
       u9I2F: // global
           Sp = Sp + 8;
           goto u9I30;
       u9I30: // global
           call _c9I2e() args: 0, res: 0, upd: 0;
     }
 },
 _c9I0q() //  [R1]
         { info_tbl: [(c9I0q,
                       label: block_c9I0q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I0q: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9I2J;
               case 2, 3, 4, 5, 6 : goto u9I2O;
           }
       u9I2O: // global
           Sp = Sp + 8;
           call _c9I2e() args: 0, res: 0, upd: 0;
       u9I2J: // global
           Sp = Sp + 8;
           call _c9I2a() args: 0, res: 0, upd: 0;
     }
 },
 _c9I2e() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I2e: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9I2a() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I2a: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.97083593 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$cmax_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c9I3n,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I3n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9I3o; else goto c9I3p;
       c9I3o: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9I3p: // global
           I64[Sp - 16] = block_c9I3c_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9I5q; else goto c9I3d;
       u9I5q: // global
           call _c9I3c(R1) args: 0, res: 0, upd: 0;
       c9I3d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9I3c() //  [R1]
         { info_tbl: [(c9I3c,
                       label: block_c9I3c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I3c: // global
           _s9FyT::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9I3g;
               case 2 : goto c9I3h;
               case 3 : goto c9I3i;
               case 4 : goto c9I3j;
               case 5 : goto c9I3k;
               case 6 : goto c9I3l;
           }
       c9I3l: // global
           I64[Sp + 8] = block_c9I4R_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I5p; else goto c9I4T;
       u9I5p: // global
           call _c9I4R() args: 0, res: 0, upd: 0;
       c9I4T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I3k: // global
           I64[Sp + 8] = block_c9I4C_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I5o; else goto c9I4E;
       u9I5o: // global
           call _c9I4C(R1) args: 0, res: 0, upd: 0;
       c9I4E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I3j: // global
           I64[Sp + 8] = block_c9I4j_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I5n; else goto c9I4l;
       u9I5n: // global
           call _c9I4j(R1) args: 0, res: 0, upd: 0;
       c9I4l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I3i: // global
           I64[Sp + 8] = block_c9I3W_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I5m; else goto c9I3Y;
       u9I5m: // global
           call _c9I3W(R1) args: 0, res: 0, upd: 0;
       c9I3Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I3h: // global
           I64[Sp + 8] = block_c9I3v_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I5l; else goto c9I3x;
       u9I5l: // global
           call _c9I3v(R1) args: 0, res: 0, upd: 0;
       c9I3x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I3g: // global
           R1 = _s9FyT::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9I4R() //  []
         { info_tbl: [(c9I4R,
                       label: block_c9I4R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I4R: // global
           R1 = GHC.Conc.Sync.BlockedOnOther_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9I4C() //  [R1]
         { info_tbl: [(c9I4C,
                       label: block_c9I4C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I4C: // global
           if (R1 & 7 == 6) goto u9I58; else goto u9I59;
       u9I58: // global
           Sp = Sp + 8;
           call _c9I4O() args: 0, res: 0, upd: 0;
       u9I59: // global
           Sp = Sp + 8;
           call _c9I4K() args: 0, res: 0, upd: 0;
     }
 },
 _c9I4j() //  [R1]
         { info_tbl: [(c9I4j,
                       label: block_c9I4j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I4j: // global
           _c9I4Z::P64 = R1 & 7;
           if (_c9I4Z::P64 != 5) goto u9I57; else goto u9I5a;
       u9I57: // global
           if (_c9I4Z::P64 != 6) goto u9I5c; else goto u9I5b;
       u9I5c: // global
           Sp = Sp + 8;
           call _c9I4r() args: 0, res: 0, upd: 0;
       u9I5b: // global
           Sp = Sp + 8;
           call _c9I4O() args: 0, res: 0, upd: 0;
       u9I5a: // global
           Sp = Sp + 8;
           call _c9I4K() args: 0, res: 0, upd: 0;
     }
 },
 _c9I3W() //  [R1]
         { info_tbl: [(c9I3W,
                       label: block_c9I3W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I3W: // global
           _c9I50::P64 = R1 & 7;
           if (_c9I50::P64 < 5) goto u9I55; else goto u9I56;
       u9I55: // global
           if (_c9I50::P64 < 4) goto u9I5e; else goto u9I5d;
       u9I5e: // global
           Sp = Sp + 8;
           call _c9I44() args: 0, res: 0, upd: 0;
       u9I5d: // global
           Sp = Sp + 8;
           call _c9I4r() args: 0, res: 0, upd: 0;
       u9I56: // global
           if (_c9I50::P64 < 6) goto u9I5g; else goto u9I5f;
       u9I5g: // global
           Sp = Sp + 8;
           call _c9I4K() args: 0, res: 0, upd: 0;
       u9I5f: // global
           Sp = Sp + 8;
           call _c9I4O() args: 0, res: 0, upd: 0;
     }
 },
 _c9I3v() //  [R1]
         { info_tbl: [(c9I3v,
                       label: block_c9I3v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I3v: // global
           _c9I51::P64 = R1 & 7;
           if (_c9I51::P64 < 5) goto u9I52; else goto u9I54;
       u9I52: // global
           if (_c9I51::P64 < 4) goto u9I53; else goto u9I5h;
       u9I53: // global
           if (_c9I51::P64 < 3) goto c9I3D; else goto u9I5i;
       c9I3D: // global
           R1 = GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9I5i: // global
           Sp = Sp + 8;
           call _c9I44() args: 0, res: 0, upd: 0;
       u9I5h: // global
           Sp = Sp + 8;
           call _c9I4r() args: 0, res: 0, upd: 0;
       u9I54: // global
           if (_c9I51::P64 < 6) goto u9I5k; else goto u9I5j;
       u9I5k: // global
           Sp = Sp + 8;
           call _c9I4K() args: 0, res: 0, upd: 0;
       u9I5j: // global
           Sp = Sp + 8;
           call _c9I4O() args: 0, res: 0, upd: 0;
     }
 },
 _c9I44() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I44: // global
           R1 = GHC.Conc.Sync.BlockedOnException_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9I4r() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I4r: // global
           R1 = GHC.Conc.Sync.BlockedOnSTM_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9I4K() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I4K: // global
           R1 = GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9I4O() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I4O: // global
           R1 = GHC.Conc.Sync.BlockedOnOther_closure+6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.97486417 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c>=_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c9I5T,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I5T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9I5U; else goto c9I5V;
       c9I5U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9I5V: // global
           I64[Sp - 16] = block_c9I5I_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9I8t; else goto c9I5J;
       u9I8t: // global
           call _c9I5I(R1) args: 0, res: 0, upd: 0;
       c9I5J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9I5I() //  [R1]
         { info_tbl: [(c9I5I,
                       label: block_c9I5I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I5I: // global
           _s9Fz2::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9I5M;
               case 2 : goto c9I5N;
               case 3 : goto c9I5O;
               case 4 : goto c9I5P;
               case 5 : goto c9I5Q;
               case 6 : goto c9I5R;
           }
       c9I5R: // global
           I64[Sp + 8] = block_c9I7P_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I8s; else goto c9I7R;
       u9I8s: // global
           call _c9I7P() args: 0, res: 0, upd: 0;
       c9I7R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I5Q: // global
           I64[Sp + 8] = block_c9I7A_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I8r; else goto c9I7C;
       u9I8r: // global
           call _c9I7A(R1) args: 0, res: 0, upd: 0;
       c9I7C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I5P: // global
           I64[Sp + 8] = block_c9I7h_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I8q; else goto c9I7j;
       u9I8q: // global
           call _c9I7h(R1) args: 0, res: 0, upd: 0;
       c9I7j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I5O: // global
           I64[Sp + 8] = block_c9I6U_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I8p; else goto c9I6W;
       u9I8p: // global
           call _c9I6U(R1) args: 0, res: 0, upd: 0;
       c9I6W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I5N: // global
           I64[Sp + 8] = block_c9I6t_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I8o; else goto c9I6v;
       u9I8o: // global
           call _c9I6t(R1) args: 0, res: 0, upd: 0;
       c9I6v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I5M: // global
           I64[Sp + 8] = block_c9I5Y_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9I8n; else goto c9I60;
       u9I8n: // global
           call _c9I5Y(R1) args: 0, res: 0, upd: 0;
       c9I60: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9I7P() //  []
         { info_tbl: [(c9I7P,
                       label: block_c9I7P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I7P: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9I7A() //  [R1]
         { info_tbl: [(c9I7A,
                       label: block_c9I7A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I7A: // global
           if (R1 & 7 == 6) goto u9I85; else goto u9I86;
       u9I85: // global
           Sp = Sp + 8;
           call _c9I7M() args: 0, res: 0, upd: 0;
       u9I86: // global
           Sp = Sp + 8;
           call _c9I7I() args: 0, res: 0, upd: 0;
     }
 },
 _c9I7h() //  [R1]
         { info_tbl: [(c9I7h,
                       label: block_c9I7h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I7h: // global
           _c9I7X::P64 = R1 & 7;
           if (_c9I7X::P64 != 5) goto u9I84; else goto u9I87;
       u9I84: // global
           if (_c9I7X::P64 != 6) goto u9I89; else goto u9I88;
       u9I89: // global
           Sp = Sp + 8;
           call _c9I7I() args: 0, res: 0, upd: 0;
       u9I88: // global
           Sp = Sp + 8;
           goto u9I8C;
       u9I87: // global
           Sp = Sp + 8;
           goto u9I8C;
       u9I8C: // global
           call _c9I7M() args: 0, res: 0, upd: 0;
     }
 },
 _c9I6U() //  [R1]
         { info_tbl: [(c9I6U,
                       label: block_c9I6U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I6U: // global
           _c9I7Y::P64 = R1 & 7;
           if (_c9I7Y::P64 < 4) goto u9I8a; else goto u9I83;
       u9I8a: // global
           Sp = Sp + 8;
           call _c9I7I() args: 0, res: 0, upd: 0;
       u9I83: // global
           if (_c9I7Y::P64 != 5) goto u9I8c; else goto u9I8c;
       u9I8c: // global
           Sp = Sp + 8;
           call _c9I7M() args: 0, res: 0, upd: 0;
     }
 },
 _c9I6t() //  [R1]
         { info_tbl: [(c9I6t,
                       label: block_c9I6t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I6t: // global
           _c9I7Z::P64 = R1 & 7;
           if (_c9I7Z::P64 < 6) goto u9I81; else goto u9I8d;
       u9I81: // global
           if (_c9I7Z::P64 < 3) goto u9I8e; else goto u9I82;
       u9I8e: // global
           Sp = Sp + 8;
           call _c9I7I() args: 0, res: 0, upd: 0;
       u9I82: // global
           if (_c9I7Z::P64 != 4) goto u9I8g; else goto u9I8g;
       u9I8g: // global
           Sp = Sp + 8;
           goto u9I8y;
       u9I8d: // global
           Sp = Sp + 8;
           goto u9I8y;
       u9I8y: // global
           call _c9I7M() args: 0, res: 0, upd: 0;
     }
 },
 _c9I5Y() //  [R1]
         { info_tbl: [(c9I5Y,
                       label: block_c9I5Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I5Y: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9I8h;
               case 2, 3, 4, 5, 6 : goto u9I8m;
           }
       u9I8m: // global
           Sp = Sp + 8;
           call _c9I7M() args: 0, res: 0, upd: 0;
       u9I8h: // global
           Sp = Sp + 8;
           call _c9I7I() args: 0, res: 0, upd: 0;
     }
 },
 _c9I7M() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I7M: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9I7I() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I7I: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.978190256 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c>_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c>_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c>_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c>_entry() //  [R2, R3]
         { info_tbl: [(c9I8K,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I8K: // global
           _s9Fzb::P64 = R3;
           R3 = R2;
           R2 = _s9Fzb::P64;
           call GHC.Conc.Sync.$fOrdBlockReason_$c<_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.979822523 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$cmin_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c9I92,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I92: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9I93; else goto c9I94;
       c9I93: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9I94: // global
           I64[Sp - 16] = block_c9I8R_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9IaQ; else goto c9I8S;
       u9IaQ: // global
           call _c9I8R(R1) args: 0, res: 0, upd: 0;
       c9I8S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9I8R() //  [R1]
         { info_tbl: [(c9I8R,
                       label: block_c9I8R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I8R: // global
           _s9Fzc::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9I8V;
               case 2 : goto c9I8W;
               case 3 : goto c9I8X;
               case 4 : goto c9I8Y;
               case 5 : goto c9I8Z;
               case 6 : goto c9I90;
           }
       c9I90: // global
           R1 = _s9Fzc::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9I8Z: // global
           I64[Sp + 8] = block_c9Ian_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IaP; else goto c9Iap;
       u9IaP: // global
           call _c9Ian(R1) args: 0, res: 0, upd: 0;
       c9Iap: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I8Y: // global
           I64[Sp + 8] = block_c9Ia4_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IaO; else goto c9Ia6;
       u9IaO: // global
           call _c9Ia4(R1) args: 0, res: 0, upd: 0;
       c9Ia6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I8X: // global
           I64[Sp + 8] = block_c9I9H_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IaN; else goto c9I9J;
       u9IaN: // global
           call _c9I9H(R1) args: 0, res: 0, upd: 0;
       c9I9J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I8W: // global
           I64[Sp + 8] = block_c9I9g_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IaM; else goto c9I9i;
       u9IaM: // global
           call _c9I9g(R1) args: 0, res: 0, upd: 0;
       c9I9i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9I8V: // global
           I64[Sp + 8] = block_c9I97_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IaL; else goto c9I99;
       u9IaL: // global
           call _c9I97() args: 0, res: 0, upd: 0;
       c9I99: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ian() //  [R1]
         { info_tbl: [(c9Ian,
                       label: block_c9Ian_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ian: // global
           if (R1 & 7 == 6) goto c9Iaz; else goto c9Iav;
       c9Iaz: // global
           R1 = GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Iav: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Ia4() //  [R1]
         { info_tbl: [(c9Ia4,
                       label: block_c9Ia4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ia4: // global
           _c9IaE::P64 = R1 & 7;
           if (_c9IaE::P64 == 5) goto c9Iak; else goto u9IaK;
       u9IaK: // global
           if (_c9IaE::P64 == 6) goto c9Iak; else goto c9Iac;
       c9Iak: // global
           R1 = GHC.Conc.Sync.BlockedOnSTM_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Iac: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9I9H() //  [R1]
         { info_tbl: [(c9I9H,
                       label: block_c9I9H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I9H: // global
           _c9IaF::P64 = R1 & 7;
           if (_c9IaF::P64 < 4) goto c9I9P; else goto u9IaJ;
       c9I9P: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9IaJ: // global
           if (_c9IaF::P64 != 5) goto c9Ia1; else goto c9Ia1;
       c9Ia1: // global
           R1 = GHC.Conc.Sync.BlockedOnException_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9I9g() //  [R1]
         { info_tbl: [(c9I9g,
                       label: block_c9I9g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I9g: // global
           _c9IaG::P64 = R1 & 7;
           if (_c9IaG::P64 >= 6) goto c9I9E; else goto u9IaH;
       u9IaH: // global
           if (_c9IaG::P64 < 3) goto c9I9o; else goto u9IaI;
       c9I9o: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9IaI: // global
           if (_c9IaG::P64 != 4) goto c9I9E; else goto c9I9E;
       c9I9E: // global
           R1 = GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9I97() //  []
         { info_tbl: [(c9I97,
                       label: block_c9I97_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9I97: // global
           R1 = GHC.Conc.Sync.BlockedOnMVar_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.982369163 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Conc.Sync.$fEqBlockReason_closure+1;
         const GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c<_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c>_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.983982679 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c9Ib4,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ib4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Ib5; else goto c9Ib6;
       c9Ib5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Ib6: // global
           I64[Sp - 16] = block_c9IaV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9IcO; else goto c9IaW;
       u9IcO: // global
           call _c9IaV(R1) args: 0, res: 0, upd: 0;
       c9IaW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IaV() //  [R1]
         { info_tbl: [(c9IaV,
                       label: block_c9IaV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IaV: // global
           _s9Fzl::P64 = P64[Sp + 8];
           _c9Ib3::P64 = R1 & 7;
           if (_c9Ib3::P64 < 3) goto u9Ict; else goto u9Icu;
       u9Ict: // global
           if (_c9Ib3::P64 < 2) goto c9IaZ; else goto c9Ib0;
       c9IaZ: // global
           I64[Sp + 8] = block_c9Ib9_info;
           R1 = _s9Fzl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IcK; else goto c9Ibb;
       u9IcK: // global
           call _c9Ib9(R1) args: 0, res: 0, upd: 0;
       c9Ibb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Ib0: // global
           I64[Sp + 8] = block_c9Ibw_info;
           R1 = _s9Fzl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IcL; else goto c9Iby;
       u9IcL: // global
           call _c9Ibw(R1) args: 0, res: 0, upd: 0;
       c9Iby: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Icu: // global
           if (_c9Ib3::P64 < 4) goto c9Ib1; else goto c9Ib2;
       c9Ib1: // global
           I64[Sp] = block_c9IbT_info;
           _s9Fzr::P64 = P64[R1 + 5];
           R1 = _s9Fzl::P64;
           P64[Sp + 8] = _s9Fzr::P64;
           if (R1 & 7 != 0) goto u9IcM; else goto c9IbV;
       u9IcM: // global
           call _c9IbT(R1) args: 0, res: 0, upd: 0;
       c9IbV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Ib2: // global
           I64[Sp + 8] = block_c9Icc_info;
           R1 = _s9Fzl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IcN; else goto c9Ice;
       u9IcN: // global
           call _c9Icc(R1) args: 0, res: 0, upd: 0;
       c9Ice: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ib9() //  [R1]
         { info_tbl: [(c9Ib9,
                       label: block_c9Ib9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ib9: // global
           _c9Ics::P64 = R1 & 7;
           if (_c9Ics::P64 < 2) goto u9Icz; else goto u9Icv;
       u9Icz: // global
           Sp = Sp + 8;
           call _c9Ico() args: 0, res: 0, upd: 0;
       u9Icv: // global
           if (_c9Ics::P64 != 3) goto u9IcB; else goto u9IcB;
       u9IcB: // global
           Sp = Sp + 8;
           call _c9Ic9() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ibw() //  [R1]
         { info_tbl: [(c9Ibw,
                       label: block_c9Ibw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ibw: // global
           _c9Icr::P64 = R1 & 7;
           if (_c9Icr::P64 < 3) goto u9Icw; else goto u9Icx;
       u9Icw: // global
           if (_c9Icr::P64 < 2) goto u9IcD; else goto u9IcC;
       u9IcD: // global
           Sp = Sp + 8;
           call _c9Ick() args: 0, res: 0, upd: 0;
       u9IcC: // global
           Sp = Sp + 8;
           call _c9Ico() args: 0, res: 0, upd: 0;
       u9Icx: // global
           if (_c9Icr::P64 < 4) goto u9IcF; else goto u9IcF;
       u9IcF: // global
           Sp = Sp + 8;
           call _c9Ic9() args: 0, res: 0, upd: 0;
     }
 },
 _c9IbT() //  [R1]
         { info_tbl: [(c9IbT,
                       label: block_c9IbT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IbT: // global
           _c9Icq::P64 = R1 & 7;
           if (_c9Icq::P64 == 3) goto c9Ic5; else goto u9Icy;
       c9Ic5: // global
           R3 = P64[R1 + 5];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$fOrdBlockReason_$ccompare_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
       u9Icy: // global
           if (_c9Icq::P64 != 4) goto u9IcH; else goto u9IcG;
       u9IcH: // global
           Sp = Sp + 16;
           call _c9Ick() args: 0, res: 0, upd: 0;
       u9IcG: // global
           Sp = Sp + 16;
           call _c9Ic9() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ic9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ic9: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Icc() //  [R1]
         { info_tbl: [(c9Icc,
                       label: block_c9Icc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Icc: // global
           if (R1 & 7 == 4) goto u9IcI; else goto u9IcJ;
       u9IcI: // global
           Sp = Sp + 8;
           call _c9Ico() args: 0, res: 0, upd: 0;
       u9IcJ: // global
           Sp = Sp + 8;
           call _c9Ick() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ico() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ico: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Ick() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ick: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.988268093 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c<_entry() //  [R2, R3]
         { info_tbl: [(c9Idb,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Idb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Idc; else goto c9Idd;
       c9Idc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Idd: // global
           I64[Sp - 16] = block_c9Id2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Ihi; else goto c9Id3;
       u9Ihi: // global
           call _c9Id2(R1) args: 0, res: 0, upd: 0;
       c9Id3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Id2() //  [R1]
         { info_tbl: [(c9Id2,
                       label: block_c9Id2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Id2: // global
           _s9Fzw::P64 = P64[Sp + 8];
           _c9Ida::P64 = R1 & 7;
           if (_c9Ida::P64 < 3) goto u9IgF; else goto u9IgG;
       u9IgF: // global
           if (_c9Ida::P64 < 2) goto c9Id6; else goto c9Id7;
       c9Id6: // global
           I64[Sp + 8] = block_c9Idg_info;
           R1 = _s9Fzw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ihe; else goto c9Idi;
       u9Ihe: // global
           call _c9Idg(R1) args: 0, res: 0, upd: 0;
       c9Idi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Id7: // global
           I64[Sp + 8] = block_c9IdD_info;
           R1 = _s9Fzw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ihf; else goto c9IdF;
       u9Ihf: // global
           call _c9IdD(R1) args: 0, res: 0, upd: 0;
       c9IdF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9IgG: // global
           if (_c9Ida::P64 < 4) goto c9Id8; else goto c9Id9;
       c9Id8: // global
           I64[Sp] = block_c9IdW_info;
           _s9FzC::P64 = P64[R1 + 5];
           R1 = _s9Fzw::P64;
           P64[Sp + 8] = _s9FzC::P64;
           if (R1 & 7 != 0) goto u9Ihg; else goto c9IdY;
       u9Ihg: // global
           call _c9IdW(R1) args: 0, res: 0, upd: 0;
       c9IdY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Id9: // global
           I64[Sp + 8] = block_c9Igp_info;
           R1 = _s9Fzw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ihh; else goto c9Igr;
       u9Ihh: // global
           call _c9Igp() args: 0, res: 0, upd: 0;
       c9Igr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Idg() //  [R1]
         { info_tbl: [(c9Idg,
                       label: block_c9Idg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Idg: // global
           _c9IgE::P64 = R1 & 7;
           if (_c9IgE::P64 < 2) goto u9IgO; else goto u9IgH;
       u9IgO: // global
           Sp = Sp + 8;
           call _c9Ig4() args: 0, res: 0, upd: 0;
       u9IgH: // global
           if (_c9IgE::P64 != 3) goto u9IgQ; else goto u9IgQ;
       u9IgQ: // global
           Sp = Sp + 8;
           call _c9Igm() args: 0, res: 0, upd: 0;
     }
 },
 _c9IdD() //  [R1]
         { info_tbl: [(c9IdD,
                       label: block_c9IdD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IdD: // global
           _c9IgD::P64 = R1 & 7;
           if (_c9IgD::P64 != 3) goto u9IgI; else goto u9IgR;
       u9IgI: // global
           if (_c9IgD::P64 != 4) goto u9IgT; else goto u9IgS;
       u9IgT: // global
           Sp = Sp + 8;
           call _c9Ig4() args: 0, res: 0, upd: 0;
       u9IgS: // global
           Sp = Sp + 8;
           goto u9Ihm;
       u9IgR: // global
           Sp = Sp + 8;
           goto u9Ihm;
       u9Ihm: // global
           call _c9Igm() args: 0, res: 0, upd: 0;
     }
 },
 _c9IdW() //  [R1]
         { info_tbl: [(c9IdW,
                       label: block_c9IdW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IdW: // global
           _c9Igw::P64 = R1 & 7;
           if (_c9Igw::P64 == 3) goto c9Ie9; else goto u9IgJ;
       c9Ie9: // global
           I64[Sp] = block_c9Ie7_info;
           _s9FzE::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FzE::P64;
           if (R1 & 7 != 0) goto u9Iho; else goto c9Iea;
       u9Iho: // global
           call _c9Ie7(R1) args: 0, res: 0, upd: 0;
       c9Iea: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9IgJ: // global
           if (_c9Igw::P64 != 4) goto u9IgV; else goto u9IgU;
       u9IgV: // global
           Sp = Sp + 16;
           call _c9Ig4() args: 0, res: 0, upd: 0;
       u9IgU: // global
           Sp = Sp + 16;
           call _c9Igm() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ie7() //  [R1]
         { info_tbl: [(c9Ie7,
                       label: block_c9Ie7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ie7: // global
           _s9FzE::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Ieh;
               case 2 : goto c9IeN;
               case 3 : goto c9Iff;
               case 4 : goto c9IfD;
               case 5 : goto c9IfX;
               case 6 : goto c9Igd;
           }
       c9Igd: // global
           I64[Sp + 8] = block_c9Igb_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ihw; else goto c9Ige;
       u9Ihw: // global
           call _c9Igb() args: 0, res: 0, upd: 0;
       c9Ige: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IfX: // global
           I64[Sp + 8] = block_c9IfV_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ihv; else goto c9IfY;
       u9Ihv: // global
           call _c9IfV(R1) args: 0, res: 0, upd: 0;
       c9IfY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IfD: // global
           I64[Sp + 8] = block_c9IfB_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ihu; else goto c9IfE;
       u9Ihu: // global
           call _c9IfB(R1) args: 0, res: 0, upd: 0;
       c9IfE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Iff: // global
           I64[Sp + 8] = block_c9Ifd_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Iht; else goto c9Ifg;
       u9Iht: // global
           call _c9Ifd(R1) args: 0, res: 0, upd: 0;
       c9Ifg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IeN: // global
           I64[Sp + 8] = block_c9IeL_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ihs; else goto c9IeO;
       u9Ihs: // global
           call _c9IeL(R1) args: 0, res: 0, upd: 0;
       c9IeO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Ieh: // global
           I64[Sp + 8] = block_c9Iee_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ihr; else goto c9Iei;
       u9Ihr: // global
           call _c9Iee(R1) args: 0, res: 0, upd: 0;
       c9Iei: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Igb() //  []
         { info_tbl: [(c9Igb,
                       label: block_c9Igb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Igb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9IfV() //  [R1]
         { info_tbl: [(c9IfV,
                       label: block_c9IfV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IfV: // global
           if (R1 & 7 == 6) goto u9IgW; else goto u9IgX;
       u9IgW: // global
           Sp = Sp + 8;
           call _c9Igm() args: 0, res: 0, upd: 0;
       u9IgX: // global
           Sp = Sp + 8;
           call _c9Ig4() args: 0, res: 0, upd: 0;
     }
 },
 _c9IfB() //  [R1]
         { info_tbl: [(c9IfB,
                       label: block_c9IfB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IfB: // global
           _c9Igz::P64 = R1 & 7;
           if (_c9Igz::P64 != 5) goto u9IgN; else goto u9IgY;
       u9IgN: // global
           if (_c9Igz::P64 != 6) goto u9Ih0; else goto u9IgZ;
       u9Ih0: // global
           Sp = Sp + 8;
           call _c9Ig4() args: 0, res: 0, upd: 0;
       u9IgZ: // global
           Sp = Sp + 8;
           goto u9IhF;
       u9IgY: // global
           Sp = Sp + 8;
           goto u9IhF;
       u9IhF: // global
           call _c9Igm() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ifd() //  [R1]
         { info_tbl: [(c9Ifd,
                       label: block_c9Ifd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ifd: // global
           _c9IgA::P64 = R1 & 7;
           if (_c9IgA::P64 < 4) goto u9Ih1; else goto u9IgM;
       u9Ih1: // global
           Sp = Sp + 8;
           call _c9Ig4() args: 0, res: 0, upd: 0;
       u9IgM: // global
           if (_c9IgA::P64 != 5) goto u9Ih3; else goto u9Ih3;
       u9Ih3: // global
           Sp = Sp + 8;
           call _c9Igm() args: 0, res: 0, upd: 0;
     }
 },
 _c9IeL() //  [R1]
         { info_tbl: [(c9IeL,
                       label: block_c9IeL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IeL: // global
           _c9IgB::P64 = R1 & 7;
           if (_c9IgB::P64 < 6) goto u9IgK; else goto u9Ih4;
       u9IgK: // global
           if (_c9IgB::P64 < 3) goto u9Ih5; else goto u9IgL;
       u9Ih5: // global
           Sp = Sp + 8;
           call _c9Ig4() args: 0, res: 0, upd: 0;
       u9IgL: // global
           if (_c9IgB::P64 != 4) goto u9Ih7; else goto u9Ih7;
       u9Ih7: // global
           Sp = Sp + 8;
           goto u9IhB;
       u9Ih4: // global
           Sp = Sp + 8;
           goto u9IhB;
       u9IhB: // global
           call _c9Igm() args: 0, res: 0, upd: 0;
     }
 },
 _c9Iee() //  [R1]
         { info_tbl: [(c9Iee,
                       label: block_c9Iee_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Iee: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9Ih8;
               case 2, 3, 4, 5, 6 : goto u9Ihd;
           }
       u9Ihd: // global
           Sp = Sp + 8;
           call _c9Igm() args: 0, res: 0, upd: 0;
       u9Ih8: // global
           Sp = Sp + 8;
           call _c9Ig4() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ig4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ig4: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Igm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Igm: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Igp() //  []
         { info_tbl: [(c9Igp,
                       label: block_c9Igp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Igp: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:45.99449696 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>=_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c9IhW,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IhW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IhX; else goto c9IhY;
       c9IhX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9IhY: // global
           I64[Sp - 16] = block_c9IhN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Im3; else goto c9IhO;
       u9Im3: // global
           call _c9IhN(R1) args: 0, res: 0, upd: 0;
       c9IhO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IhN() //  [R1]
         { info_tbl: [(c9IhN,
                       label: block_c9IhN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IhN: // global
           _s9FzO::P64 = P64[Sp + 8];
           _c9IhV::P64 = R1 & 7;
           if (_c9IhV::P64 < 3) goto u9Ilq; else goto u9Ilr;
       u9Ilq: // global
           if (_c9IhV::P64 < 2) goto c9IhR; else goto c9IhS;
       c9IhR: // global
           I64[Sp + 8] = block_c9Ii1_info;
           R1 = _s9FzO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IlZ; else goto c9Ii3;
       u9IlZ: // global
           call _c9Ii1(R1) args: 0, res: 0, upd: 0;
       c9Ii3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IhS: // global
           I64[Sp + 8] = block_c9Iio_info;
           R1 = _s9FzO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Im0; else goto c9Iiq;
       u9Im0: // global
           call _c9Iio(R1) args: 0, res: 0, upd: 0;
       c9Iiq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Ilr: // global
           if (_c9IhV::P64 < 4) goto c9IhT; else goto c9IhU;
       c9IhT: // global
           I64[Sp] = block_c9IiH_info;
           _s9FzU::P64 = P64[R1 + 5];
           R1 = _s9FzO::P64;
           P64[Sp + 8] = _s9FzU::P64;
           if (R1 & 7 != 0) goto u9Im1; else goto c9IiJ;
       u9Im1: // global
           call _c9IiH(R1) args: 0, res: 0, upd: 0;
       c9IiJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IhU: // global
           I64[Sp + 8] = block_c9Ila_info;
           R1 = _s9FzO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Im2; else goto c9Ilc;
       u9Im2: // global
           call _c9Ila() args: 0, res: 0, upd: 0;
       c9Ilc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ii1() //  [R1]
         { info_tbl: [(c9Ii1,
                       label: block_c9Ii1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ii1: // global
           _c9Ilp::P64 = R1 & 7;
           if (_c9Ilp::P64 < 2) goto u9Ilz; else goto u9Ils;
       u9Ilz: // global
           Sp = Sp + 8;
           call _c9IkP() args: 0, res: 0, upd: 0;
       u9Ils: // global
           if (_c9Ilp::P64 != 3) goto u9IlB; else goto u9IlB;
       u9IlB: // global
           Sp = Sp + 8;
           call _c9Il7() args: 0, res: 0, upd: 0;
     }
 },
 _c9Iio() //  [R1]
         { info_tbl: [(c9Iio,
                       label: block_c9Iio_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Iio: // global
           _c9Ilo::P64 = R1 & 7;
           if (_c9Ilo::P64 != 3) goto u9Ilt; else goto u9IlC;
       u9Ilt: // global
           if (_c9Ilo::P64 != 4) goto u9IlE; else goto u9IlD;
       u9IlE: // global
           Sp = Sp + 8;
           call _c9IkP() args: 0, res: 0, upd: 0;
       u9IlD: // global
           Sp = Sp + 8;
           goto u9Im7;
       u9IlC: // global
           Sp = Sp + 8;
           goto u9Im7;
       u9Im7: // global
           call _c9Il7() args: 0, res: 0, upd: 0;
     }
 },
 _c9IiH() //  [R1]
         { info_tbl: [(c9IiH,
                       label: block_c9IiH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IiH: // global
           _c9Ilh::P64 = R1 & 7;
           if (_c9Ilh::P64 == 3) goto c9IiU; else goto u9Ilu;
       c9IiU: // global
           I64[Sp] = block_c9IiS_info;
           _s9FzW::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FzW::P64;
           if (R1 & 7 != 0) goto u9Im9; else goto c9IiV;
       u9Im9: // global
           call _c9IiS(R1) args: 0, res: 0, upd: 0;
       c9IiV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Ilu: // global
           if (_c9Ilh::P64 != 4) goto u9IlG; else goto u9IlF;
       u9IlG: // global
           Sp = Sp + 16;
           call _c9IkP() args: 0, res: 0, upd: 0;
       u9IlF: // global
           Sp = Sp + 16;
           call _c9Il7() args: 0, res: 0, upd: 0;
     }
 },
 _c9IiS() //  [R1]
         { info_tbl: [(c9IiS,
                       label: block_c9IiS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IiS: // global
           _s9FzW::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Ij2;
               case 2 : goto c9Ijy;
               case 3 : goto c9Ik0;
               case 4 : goto c9Iko;
               case 5 : goto c9IkI;
               case 6 : goto c9IkY;
           }
       c9IkY: // global
           I64[Sp + 8] = block_c9IkW_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Imh; else goto c9IkZ;
       u9Imh: // global
           call _c9IkW() args: 0, res: 0, upd: 0;
       c9IkZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IkI: // global
           I64[Sp + 8] = block_c9IkG_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Img; else goto c9IkJ;
       u9Img: // global
           call _c9IkG(R1) args: 0, res: 0, upd: 0;
       c9IkJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Iko: // global
           I64[Sp + 8] = block_c9Ikm_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Imf; else goto c9Ikp;
       u9Imf: // global
           call _c9Ikm(R1) args: 0, res: 0, upd: 0;
       c9Ikp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Ik0: // global
           I64[Sp + 8] = block_c9IjY_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ime; else goto c9Ik1;
       u9Ime: // global
           call _c9IjY(R1) args: 0, res: 0, upd: 0;
       c9Ik1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Ijy: // global
           I64[Sp + 8] = block_c9Ijw_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Imd; else goto c9Ijz;
       u9Imd: // global
           call _c9Ijw(R1) args: 0, res: 0, upd: 0;
       c9Ijz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Ij2: // global
           I64[Sp + 8] = block_c9IiZ_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Imc; else goto c9Ij3;
       u9Imc: // global
           call _c9IiZ(R1) args: 0, res: 0, upd: 0;
       c9Ij3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IkW() //  []
         { info_tbl: [(c9IkW,
                       label: block_c9IkW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IkW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9IkG() //  [R1]
         { info_tbl: [(c9IkG,
                       label: block_c9IkG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IkG: // global
           if (R1 & 7 == 6) goto u9IlH; else goto u9IlI;
       u9IlH: // global
           Sp = Sp + 8;
           call _c9Il7() args: 0, res: 0, upd: 0;
       u9IlI: // global
           Sp = Sp + 8;
           call _c9IkP() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ikm() //  [R1]
         { info_tbl: [(c9Ikm,
                       label: block_c9Ikm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ikm: // global
           _c9Ilk::P64 = R1 & 7;
           if (_c9Ilk::P64 != 5) goto u9Ily; else goto u9IlJ;
       u9Ily: // global
           if (_c9Ilk::P64 != 6) goto u9IlL; else goto u9IlK;
       u9IlL: // global
           Sp = Sp + 8;
           call _c9IkP() args: 0, res: 0, upd: 0;
       u9IlK: // global
           Sp = Sp + 8;
           goto u9Imq;
       u9IlJ: // global
           Sp = Sp + 8;
           goto u9Imq;
       u9Imq: // global
           call _c9Il7() args: 0, res: 0, upd: 0;
     }
 },
 _c9IjY() //  [R1]
         { info_tbl: [(c9IjY,
                       label: block_c9IjY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IjY: // global
           _c9Ill::P64 = R1 & 7;
           if (_c9Ill::P64 < 4) goto u9IlM; else goto u9Ilx;
       u9IlM: // global
           Sp = Sp + 8;
           call _c9IkP() args: 0, res: 0, upd: 0;
       u9Ilx: // global
           if (_c9Ill::P64 != 5) goto u9IlO; else goto u9IlO;
       u9IlO: // global
           Sp = Sp + 8;
           call _c9Il7() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ijw() //  [R1]
         { info_tbl: [(c9Ijw,
                       label: block_c9Ijw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ijw: // global
           _c9Ilm::P64 = R1 & 7;
           if (_c9Ilm::P64 < 6) goto u9Ilv; else goto u9IlP;
       u9Ilv: // global
           if (_c9Ilm::P64 < 3) goto u9IlQ; else goto u9Ilw;
       u9IlQ: // global
           Sp = Sp + 8;
           call _c9IkP() args: 0, res: 0, upd: 0;
       u9Ilw: // global
           if (_c9Ilm::P64 != 4) goto u9IlS; else goto u9IlS;
       u9IlS: // global
           Sp = Sp + 8;
           goto u9Imm;
       u9IlP: // global
           Sp = Sp + 8;
           goto u9Imm;
       u9Imm: // global
           call _c9Il7() args: 0, res: 0, upd: 0;
     }
 },
 _c9IiZ() //  [R1]
         { info_tbl: [(c9IiZ,
                       label: block_c9IiZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IiZ: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9IlT;
               case 2, 3, 4, 5, 6 : goto u9IlY;
           }
       u9IlY: // global
           Sp = Sp + 8;
           call _c9Il7() args: 0, res: 0, upd: 0;
       u9IlT: // global
           Sp = Sp + 8;
           call _c9IkP() args: 0, res: 0, upd: 0;
     }
 },
 _c9IkP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IkP: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Il7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Il7: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Ila() //  []
         { info_tbl: [(c9Ila,
                       label: block_c9Ila_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ila: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.000509363 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c>_entry() //  [R2, R3]
         { info_tbl: [(c9ImH,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ImH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9ImI; else goto c9ImJ;
       c9ImI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9ImJ: // global
           I64[Sp - 16] = block_c9Imy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9IqI; else goto c9Imz;
       u9IqI: // global
           call _c9Imy(R1) args: 0, res: 0, upd: 0;
       c9Imz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Imy() //  [R1]
         { info_tbl: [(c9Imy,
                       label: block_c9Imy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Imy: // global
           _s9FA6::P64 = P64[Sp + 8];
           _c9ImG::P64 = R1 & 7;
           if (_c9ImG::P64 < 3) goto u9Iq7; else goto u9Iq8;
       u9Iq7: // global
           if (_c9ImG::P64 < 2) goto c9ImC; else goto c9ImD;
       c9ImC: // global
           I64[Sp + 8] = block_c9ImM_info;
           R1 = _s9FA6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IqE; else goto c9ImO;
       u9IqE: // global
           call _c9ImM() args: 0, res: 0, upd: 0;
       c9ImO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9ImD: // global
           I64[Sp + 8] = block_c9ImV_info;
           R1 = _s9FA6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IqF; else goto c9ImX;
       u9IqF: // global
           call _c9ImV(R1) args: 0, res: 0, upd: 0;
       c9ImX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Iq8: // global
           if (_c9ImG::P64 < 4) goto c9ImE; else goto c9ImF;
       c9ImE: // global
           I64[Sp] = block_c9Ini_info;
           _s9FAb::P64 = P64[R1 + 5];
           R1 = _s9FA6::P64;
           P64[Sp + 8] = _s9FAb::P64;
           if (R1 & 7 != 0) goto u9IqG; else goto c9Ink;
       u9IqG: // global
           call _c9Ini(R1) args: 0, res: 0, upd: 0;
       c9Ink: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9ImF: // global
           I64[Sp + 8] = block_c9IpL_info;
           R1 = _s9FA6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IqH; else goto c9IpN;
       u9IqH: // global
           call _c9IpL(R1) args: 0, res: 0, upd: 0;
       c9IpN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ImM() //  []
         { info_tbl: [(c9ImM,
                       label: block_c9ImM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ImM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9ImV() //  [R1]
         { info_tbl: [(c9ImV,
                       label: block_c9ImV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ImV: // global
           _c9Iq6::P64 = R1 & 7;
           if (_c9Iq6::P64 < 2) goto u9Iqf; else goto u9Iq9;
       u9Iqf: // global
           Sp = Sp + 8;
           call _c9IpT() args: 0, res: 0, upd: 0;
       u9Iq9: // global
           if (_c9Iq6::P64 != 3) goto u9Iqh; else goto u9Iqh;
       u9Iqh: // global
           Sp = Sp + 8;
           call _c9IpX() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ini() //  [R1]
         { info_tbl: [(c9Ini,
                       label: block_c9Ini_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ini: // global
           _c9IpZ::P64 = R1 & 7;
           if (_c9IpZ::P64 == 3) goto c9Inv; else goto u9Iqa;
       c9Inv: // global
           I64[Sp] = block_c9Int_info;
           _s9FAd::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FAd::P64;
           if (R1 & 7 != 0) goto u9IqL; else goto c9Inw;
       u9IqL: // global
           call _c9Int(R1) args: 0, res: 0, upd: 0;
       c9Inw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Iqa: // global
           if (_c9IpZ::P64 != 4) goto u9Iqj; else goto u9Iqi;
       u9Iqj: // global
           Sp = Sp + 16;
           call _c9IpT() args: 0, res: 0, upd: 0;
       u9Iqi: // global
           Sp = Sp + 16;
           call _c9IpX() args: 0, res: 0, upd: 0;
     }
 },
 _c9Int() //  [R1]
         { info_tbl: [(c9Int,
                       label: block_c9Int_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Int: // global
           _s9FAd::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9InD;
               case 2 : goto c9InN;
               case 3 : goto c9Ioj;
               case 4 : goto c9IoL;
               case 5 : goto c9Ip9;
               case 6 : goto c9Ipt;
           }
       c9Ipt: // global
           I64[Sp + 8] = block_c9Ipr_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IqT; else goto c9Ipu;
       u9IqT: // global
           call _c9Ipr(R1) args: 0, res: 0, upd: 0;
       c9Ipu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Ip9: // global
           I64[Sp + 8] = block_c9Ip7_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IqS; else goto c9Ipa;
       u9IqS: // global
           call _c9Ip7(R1) args: 0, res: 0, upd: 0;
       c9Ipa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IoL: // global
           I64[Sp + 8] = block_c9IoJ_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IqR; else goto c9IoM;
       u9IqR: // global
           call _c9IoJ(R1) args: 0, res: 0, upd: 0;
       c9IoM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Ioj: // global
           I64[Sp + 8] = block_c9Ioh_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IqQ; else goto c9Iok;
       u9IqQ: // global
           call _c9Ioh(R1) args: 0, res: 0, upd: 0;
       c9Iok: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9InN: // global
           I64[Sp + 8] = block_c9InL_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IqP; else goto c9InO;
       u9IqP: // global
           call _c9InL(R1) args: 0, res: 0, upd: 0;
       c9InO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9InD: // global
           I64[Sp + 8] = block_c9InA_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IqO; else goto c9InE;
       u9IqO: // global
           call _c9InA() args: 0, res: 0, upd: 0;
       c9InE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ipr() //  [R1]
         { info_tbl: [(c9Ipr,
                       label: block_c9Ipr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ipr: // global
           if (R1 & 7 == 6) goto u9Iqk; else goto u9Iql;
       u9Iqk: // global
           Sp = Sp + 8;
           call _c9IpX() args: 0, res: 0, upd: 0;
       u9Iql: // global
           Sp = Sp + 8;
           call _c9IpT() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ip7() //  [R1]
         { info_tbl: [(c9Ip7,
                       label: block_c9Ip7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ip7: // global
           _c9Iq2::P64 = R1 & 7;
           if (_c9Iq2::P64 != 5) goto u9Iqe; else goto u9Iqm;
       u9Iqe: // global
           if (_c9Iq2::P64 != 6) goto u9Iqo; else goto u9Iqn;
       u9Iqo: // global
           Sp = Sp + 8;
           call _c9IpT() args: 0, res: 0, upd: 0;
       u9Iqn: // global
           Sp = Sp + 8;
           goto u9Ir2;
       u9Iqm: // global
           Sp = Sp + 8;
           goto u9Ir2;
       u9Ir2: // global
           call _c9IpX() args: 0, res: 0, upd: 0;
     }
 },
 _c9IoJ() //  [R1]
         { info_tbl: [(c9IoJ,
                       label: block_c9IoJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IoJ: // global
           _c9Iq3::P64 = R1 & 7;
           if (_c9Iq3::P64 < 4) goto u9Iqp; else goto u9Iqd;
       u9Iqp: // global
           Sp = Sp + 8;
           call _c9IpT() args: 0, res: 0, upd: 0;
       u9Iqd: // global
           if (_c9Iq3::P64 != 5) goto u9Iqr; else goto u9Iqr;
       u9Iqr: // global
           Sp = Sp + 8;
           call _c9IpX() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ioh() //  [R1]
         { info_tbl: [(c9Ioh,
                       label: block_c9Ioh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ioh: // global
           _c9Iq4::P64 = R1 & 7;
           if (_c9Iq4::P64 < 6) goto u9Iqb; else goto u9Iqs;
       u9Iqb: // global
           if (_c9Iq4::P64 < 3) goto u9Iqt; else goto u9Iqc;
       u9Iqt: // global
           Sp = Sp + 8;
           call _c9IpT() args: 0, res: 0, upd: 0;
       u9Iqc: // global
           if (_c9Iq4::P64 != 4) goto u9Iqv; else goto u9Iqv;
       u9Iqv: // global
           Sp = Sp + 8;
           goto u9IqY;
       u9Iqs: // global
           Sp = Sp + 8;
           goto u9IqY;
       u9IqY: // global
           call _c9IpX() args: 0, res: 0, upd: 0;
     }
 },
 _c9InL() //  [R1]
         { info_tbl: [(c9InL,
                       label: block_c9InL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9InL: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9Iqw;
               case 2, 3, 4, 5, 6 : goto u9IqB;
           }
       u9IqB: // global
           Sp = Sp + 8;
           call _c9IpX() args: 0, res: 0, upd: 0;
       u9Iqw: // global
           Sp = Sp + 8;
           call _c9IpT() args: 0, res: 0, upd: 0;
     }
 },
 _c9InA() //  []
         { info_tbl: [(c9InA,
                       label: block_c9InA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9InA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9IpL() //  [R1]
         { info_tbl: [(c9IpL,
                       label: block_c9IpL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IpL: // global
           if (R1 & 7 == 4) goto u9IqC; else goto u9IqD;
       u9IqC: // global
           Sp = Sp + 8;
           call _c9IpX() args: 0, res: 0, upd: 0;
       u9IqD: // global
           Sp = Sp + 8;
           call _c9IpT() args: 0, res: 0, upd: 0;
     }
 },
 _c9IpX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IpX: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9IpT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IpT: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.006628414 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<=_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c9Irl,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Irl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Irm; else goto c9Irn;
       c9Irm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Irn: // global
           I64[Sp - 16] = block_c9Irc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Ivm; else goto c9Ird;
       u9Ivm: // global
           call _c9Irc(R1) args: 0, res: 0, upd: 0;
       c9Ird: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Irc() //  [R1]
         { info_tbl: [(c9Irc,
                       label: block_c9Irc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Irc: // global
           _s9FAn::P64 = P64[Sp + 8];
           _c9Irk::P64 = R1 & 7;
           if (_c9Irk::P64 < 3) goto u9IuL; else goto u9IuM;
       u9IuL: // global
           if (_c9Irk::P64 < 2) goto c9Irg; else goto c9Irh;
       c9Irg: // global
           I64[Sp + 8] = block_c9Irq_info;
           R1 = _s9FAn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ivi; else goto c9Irs;
       u9Ivi: // global
           call _c9Irq() args: 0, res: 0, upd: 0;
       c9Irs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Irh: // global
           I64[Sp + 8] = block_c9Irz_info;
           R1 = _s9FAn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ivj; else goto c9IrB;
       u9Ivj: // global
           call _c9Irz(R1) args: 0, res: 0, upd: 0;
       c9IrB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9IuM: // global
           if (_c9Irk::P64 < 4) goto c9Iri; else goto c9Irj;
       c9Iri: // global
           I64[Sp] = block_c9IrW_info;
           _s9FAs::P64 = P64[R1 + 5];
           R1 = _s9FAn::P64;
           P64[Sp + 8] = _s9FAs::P64;
           if (R1 & 7 != 0) goto u9Ivk; else goto c9IrY;
       u9Ivk: // global
           call _c9IrW(R1) args: 0, res: 0, upd: 0;
       c9IrY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Irj: // global
           I64[Sp + 8] = block_c9Iup_info;
           R1 = _s9FAn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ivl; else goto c9Iur;
       u9Ivl: // global
           call _c9Iup(R1) args: 0, res: 0, upd: 0;
       c9Iur: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Irq() //  []
         { info_tbl: [(c9Irq,
                       label: block_c9Irq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Irq: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Irz() //  [R1]
         { info_tbl: [(c9Irz,
                       label: block_c9Irz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Irz: // global
           _c9IuK::P64 = R1 & 7;
           if (_c9IuK::P64 < 2) goto u9IuT; else goto u9IuN;
       u9IuT: // global
           Sp = Sp + 8;
           call _c9Iux() args: 0, res: 0, upd: 0;
       u9IuN: // global
           if (_c9IuK::P64 != 3) goto u9IuV; else goto u9IuV;
       u9IuV: // global
           Sp = Sp + 8;
           call _c9IuB() args: 0, res: 0, upd: 0;
     }
 },
 _c9IrW() //  [R1]
         { info_tbl: [(c9IrW,
                       label: block_c9IrW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IrW: // global
           _c9IuD::P64 = R1 & 7;
           if (_c9IuD::P64 == 3) goto c9Is9; else goto u9IuO;
       c9Is9: // global
           I64[Sp] = block_c9Is7_info;
           _s9FAu::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FAu::P64;
           if (R1 & 7 != 0) goto u9Ivp; else goto c9Isa;
       u9Ivp: // global
           call _c9Is7(R1) args: 0, res: 0, upd: 0;
       c9Isa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9IuO: // global
           if (_c9IuD::P64 != 4) goto u9IuX; else goto u9IuW;
       u9IuX: // global
           Sp = Sp + 16;
           call _c9Iux() args: 0, res: 0, upd: 0;
       u9IuW: // global
           Sp = Sp + 16;
           call _c9IuB() args: 0, res: 0, upd: 0;
     }
 },
 _c9Is7() //  [R1]
         { info_tbl: [(c9Is7,
                       label: block_c9Is7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Is7: // global
           _s9FAu::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Ish;
               case 2 : goto c9Isr;
               case 3 : goto c9IsX;
               case 4 : goto c9Itp;
               case 5 : goto c9ItN;
               case 6 : goto c9Iu7;
           }
       c9Iu7: // global
           I64[Sp + 8] = block_c9Iu5_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ivx; else goto c9Iu8;
       u9Ivx: // global
           call _c9Iu5(R1) args: 0, res: 0, upd: 0;
       c9Iu8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9ItN: // global
           I64[Sp + 8] = block_c9ItL_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ivw; else goto c9ItO;
       u9Ivw: // global
           call _c9ItL(R1) args: 0, res: 0, upd: 0;
       c9ItO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Itp: // global
           I64[Sp + 8] = block_c9Itn_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ivv; else goto c9Itq;
       u9Ivv: // global
           call _c9Itn(R1) args: 0, res: 0, upd: 0;
       c9Itq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IsX: // global
           I64[Sp + 8] = block_c9IsV_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ivu; else goto c9IsY;
       u9Ivu: // global
           call _c9IsV(R1) args: 0, res: 0, upd: 0;
       c9IsY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Isr: // global
           I64[Sp + 8] = block_c9Isp_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ivt; else goto c9Iss;
       u9Ivt: // global
           call _c9Isp(R1) args: 0, res: 0, upd: 0;
       c9Iss: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Ish: // global
           I64[Sp + 8] = block_c9Ise_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ivs; else goto c9Isi;
       u9Ivs: // global
           call _c9Ise() args: 0, res: 0, upd: 0;
       c9Isi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Iu5() //  [R1]
         { info_tbl: [(c9Iu5,
                       label: block_c9Iu5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Iu5: // global
           if (R1 & 7 == 6) goto u9IuY; else goto u9IuZ;
       u9IuY: // global
           Sp = Sp + 8;
           call _c9IuB() args: 0, res: 0, upd: 0;
       u9IuZ: // global
           Sp = Sp + 8;
           call _c9Iux() args: 0, res: 0, upd: 0;
     }
 },
 _c9ItL() //  [R1]
         { info_tbl: [(c9ItL,
                       label: block_c9ItL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ItL: // global
           _c9IuG::P64 = R1 & 7;
           if (_c9IuG::P64 != 5) goto u9IuS; else goto u9Iv0;
       u9IuS: // global
           if (_c9IuG::P64 != 6) goto u9Iv2; else goto u9Iv1;
       u9Iv2: // global
           Sp = Sp + 8;
           call _c9Iux() args: 0, res: 0, upd: 0;
       u9Iv1: // global
           Sp = Sp + 8;
           goto u9IvG;
       u9Iv0: // global
           Sp = Sp + 8;
           goto u9IvG;
       u9IvG: // global
           call _c9IuB() args: 0, res: 0, upd: 0;
     }
 },
 _c9Itn() //  [R1]
         { info_tbl: [(c9Itn,
                       label: block_c9Itn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Itn: // global
           _c9IuH::P64 = R1 & 7;
           if (_c9IuH::P64 < 4) goto u9Iv3; else goto u9IuR;
       u9Iv3: // global
           Sp = Sp + 8;
           call _c9Iux() args: 0, res: 0, upd: 0;
       u9IuR: // global
           if (_c9IuH::P64 != 5) goto u9Iv5; else goto u9Iv5;
       u9Iv5: // global
           Sp = Sp + 8;
           call _c9IuB() args: 0, res: 0, upd: 0;
     }
 },
 _c9IsV() //  [R1]
         { info_tbl: [(c9IsV,
                       label: block_c9IsV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IsV: // global
           _c9IuI::P64 = R1 & 7;
           if (_c9IuI::P64 < 6) goto u9IuP; else goto u9Iv6;
       u9IuP: // global
           if (_c9IuI::P64 < 3) goto u9Iv7; else goto u9IuQ;
       u9Iv7: // global
           Sp = Sp + 8;
           call _c9Iux() args: 0, res: 0, upd: 0;
       u9IuQ: // global
           if (_c9IuI::P64 != 4) goto u9Iv9; else goto u9Iv9;
       u9Iv9: // global
           Sp = Sp + 8;
           goto u9IvC;
       u9Iv6: // global
           Sp = Sp + 8;
           goto u9IvC;
       u9IvC: // global
           call _c9IuB() args: 0, res: 0, upd: 0;
     }
 },
 _c9Isp() //  [R1]
         { info_tbl: [(c9Isp,
                       label: block_c9Isp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Isp: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9Iva;
               case 2, 3, 4, 5, 6 : goto u9Ivf;
           }
       u9Ivf: // global
           Sp = Sp + 8;
           call _c9IuB() args: 0, res: 0, upd: 0;
       u9Iva: // global
           Sp = Sp + 8;
           call _c9Iux() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ise() //  []
         { info_tbl: [(c9Ise,
                       label: block_c9Ise_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ise: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Iup() //  [R1]
         { info_tbl: [(c9Iup,
                       label: block_c9Iup_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Iup: // global
           if (R1 & 7 == 4) goto u9Ivg; else goto u9Ivh;
       u9Ivg: // global
           Sp = Sp + 8;
           call _c9IuB() args: 0, res: 0, upd: 0;
       u9Ivh: // global
           Sp = Sp + 8;
           call _c9Iux() args: 0, res: 0, upd: 0;
     }
 },
 _c9IuB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IuB: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Iux() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Iux: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.012736632 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmax_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c9IvZ,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IvZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9Iw0; else goto c9Iw1;
       c9Iw0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Iw1: // global
           I64[Sp - 16] = block_c9IvQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9IzE; else goto c9IvR;
       u9IzE: // global
           call _c9IvQ(R1) args: 0, res: 0, upd: 0;
       c9IvR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IvQ() //  [R1]
         { info_tbl: [(c9IvQ,
                       label: block_c9IvQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IvQ: // global
           _s9FAE::P64 = P64[Sp + 8];
           _c9IvY::P64 = R1 & 7;
           if (_c9IvY::P64 < 3) goto u9Iz8; else goto u9Iz9;
       u9Iz8: // global
           if (_c9IvY::P64 < 2) goto c9IvU; else goto c9IvV;
       c9IvU: // global
           R1 = _s9FAE::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9IvV: // global
           I64[Sp + 8] = block_c9Iw7_info;
           R1 = _s9FAE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IzB; else goto c9Iw9;
       u9IzB: // global
           call _c9Iw7(R1) args: 0, res: 0, upd: 0;
       c9Iw9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Iz9: // global
           if (_c9IvY::P64 < 4) goto c9IvW; else goto c9IvX;
       c9IvW: // global
           I64[Sp - 8] = block_c9Iwq_info;
           _s9FAF::P64 = R1;
           _s9FAI::P64 = P64[R1 + 5];
           R1 = _s9FAE::P64;
           P64[Sp] = _s9FAI::P64;
           P64[Sp + 8] = _s9FAF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9IzC; else goto c9Iws;
       u9IzC: // global
           call _c9Iwq(R1) args: 0, res: 0, upd: 0;
       c9Iws: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IvX: // global
           I64[Sp + 8] = block_c9IyT_info;
           R1 = _s9FAE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IzD; else goto c9IyV;
       u9IzD: // global
           call _c9IyT() args: 0, res: 0, upd: 0;
       c9IyV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Iw7() //  [R1]
         { info_tbl: [(c9Iw7,
                       label: block_c9Iw7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Iw7: // global
           _c9Iz7::P64 = R1 & 7;
           if (_c9Iz7::P64 == 3) goto c9Iwj; else goto u9Iza;
       c9Iwj: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9Iza: // global
           if (_c9Iz7::P64 != 4) goto c9Iwf; else goto u9Izg;
       c9Iwf: // global
           R1 = GHC.Conc.Sync.ThreadFinished_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9Izg: // global
           Sp = Sp + 8;
           call _c9IyQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9Iwq() //  [R1]
         { info_tbl: [(c9Iwq,
                       label: block_c9Iwq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Iwq: // global
           _c9Iz0::P64 = R1 & 7;
           if (_c9Iz0::P64 == 3) goto c9IwD; else goto u9Izb;
       c9IwD: // global
           I64[Sp - 8] = block_c9IwB_info;
           _s9FAJ::P64 = R1;
           _s9FAK::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9FAK::P64;
           P64[Sp + 8] = _s9FAJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9IzG; else goto c9IwE;
       u9IzG: // global
           call _c9IwB(R1) args: 0, res: 0, upd: 0;
       c9IwE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Izb: // global
           if (_c9Iz0::P64 != 4) goto u9Izi; else goto u9Izh;
       u9Izi: // global
           Sp = Sp + 16;
           call _c9IyI() args: 0, res: 0, upd: 0;
       u9Izh: // global
           Sp = Sp + 24;
           call _c9IyQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9IwB() //  [R1]
         { info_tbl: [(c9IwB,
                       label: block_c9IwB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IwB: // global
           _s9FAK::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9IwL;
               case 2 : goto c9IwV;
               case 3 : goto c9Ixr;
               case 4 : goto c9IxT;
               case 5 : goto c9Iyh;
               case 6 : goto c9IyB;
           }
       c9IyB: // global
           I64[Sp + 8] = block_c9Iyz_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IzO; else goto c9IyC;
       u9IzO: // global
           call _c9Iyz(R1) args: 0, res: 0, upd: 0;
       c9IyC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Iyh: // global
           I64[Sp + 8] = block_c9Iyf_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IzN; else goto c9Iyi;
       u9IzN: // global
           call _c9Iyf(R1) args: 0, res: 0, upd: 0;
       c9Iyi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IxT: // global
           I64[Sp + 8] = block_c9IxR_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IzM; else goto c9IxU;
       u9IzM: // global
           call _c9IxR(R1) args: 0, res: 0, upd: 0;
       c9IxU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Ixr: // global
           I64[Sp + 8] = block_c9Ixp_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IzL; else goto c9Ixs;
       u9IzL: // global
           call _c9Ixp(R1) args: 0, res: 0, upd: 0;
       c9Ixs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IwV: // global
           I64[Sp + 8] = block_c9IwT_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IzK; else goto c9IwW;
       u9IzK: // global
           call _c9IwT(R1) args: 0, res: 0, upd: 0;
       c9IwW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IwL: // global
           I64[Sp + 8] = block_c9IwI_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IzJ; else goto c9IwM;
       u9IzJ: // global
           call _c9IwI() args: 0, res: 0, upd: 0;
       c9IwM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Iyz() //  [R1]
         { info_tbl: [(c9Iyz,
                       label: block_c9Iyz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Iyz: // global
           if (R1 & 7 == 6) goto u9Izj; else goto u9Izk;
       u9Izj: // global
           Sp = Sp + 8;
           call _c9IyM() args: 0, res: 0, upd: 0;
       u9Izk: // global
           Sp = Sp + 16;
           call _c9IyI() args: 0, res: 0, upd: 0;
     }
 },
 _c9Iyf() //  [R1]
         { info_tbl: [(c9Iyf,
                       label: block_c9Iyf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Iyf: // global
           _c9Iz3::P64 = R1 & 7;
           if (_c9Iz3::P64 != 5) goto u9Izf; else goto u9Izl;
       u9Izf: // global
           if (_c9Iz3::P64 != 6) goto u9Izn; else goto u9Izm;
       u9Izn: // global
           Sp = Sp + 16;
           call _c9IyI() args: 0, res: 0, upd: 0;
       u9Izm: // global
           Sp = Sp + 8;
           goto u9IzX;
       u9Izl: // global
           Sp = Sp + 8;
           goto u9IzX;
       u9IzX: // global
           call _c9IyM() args: 0, res: 0, upd: 0;
     }
 },
 _c9IxR() //  [R1]
         { info_tbl: [(c9IxR,
                       label: block_c9IxR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IxR: // global
           _c9Iz4::P64 = R1 & 7;
           if (_c9Iz4::P64 < 4) goto u9Izo; else goto u9Ize;
       u9Izo: // global
           Sp = Sp + 16;
           call _c9IyI() args: 0, res: 0, upd: 0;
       u9Ize: // global
           if (_c9Iz4::P64 != 5) goto u9Izq; else goto u9Izq;
       u9Izq: // global
           Sp = Sp + 8;
           call _c9IyM() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ixp() //  [R1]
         { info_tbl: [(c9Ixp,
                       label: block_c9Ixp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ixp: // global
           _c9Iz5::P64 = R1 & 7;
           if (_c9Iz5::P64 < 6) goto u9Izc; else goto u9Izr;
       u9Izc: // global
           if (_c9Iz5::P64 < 3) goto u9Izs; else goto u9Izd;
       u9Izs: // global
           Sp = Sp + 16;
           call _c9IyI() args: 0, res: 0, upd: 0;
       u9Izd: // global
           if (_c9Iz5::P64 != 4) goto u9Izu; else goto u9Izu;
       u9Izu: // global
           Sp = Sp + 8;
           goto u9IzT;
       u9Izr: // global
           Sp = Sp + 8;
           goto u9IzT;
       u9IzT: // global
           call _c9IyM() args: 0, res: 0, upd: 0;
     }
 },
 _c9IwT() //  [R1]
         { info_tbl: [(c9IwT,
                       label: block_c9IwT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IwT: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9Izv;
               case 2, 3, 4, 5, 6 : goto u9IzA;
           }
       u9IzA: // global
           Sp = Sp + 8;
           call _c9IyM() args: 0, res: 0, upd: 0;
       u9Izv: // global
           Sp = Sp + 16;
           call _c9IyI() args: 0, res: 0, upd: 0;
     }
 },
 _c9IyM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IyM: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9IwI() //  []
         { info_tbl: [(c9IwI,
                       label: block_c9IwI_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IwI: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9IyI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IyI: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9IyQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IyQ: // global
           R1 = GHC.Conc.Sync.ThreadDied_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9IyT() //  []
         { info_tbl: [(c9IyT,
                       label: block_c9IyT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IyT: // global
           R1 = GHC.Conc.Sync.ThreadDied_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.019039813 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmin_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c9IAe,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IAe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9IAf; else goto c9IAg;
       c9IAf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9IAg: // global
           I64[Sp - 16] = block_c9IA5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9IDW; else goto c9IA6;
       u9IDW: // global
           call _c9IA5(R1) args: 0, res: 0, upd: 0;
       c9IA6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IA5() //  [R1]
         { info_tbl: [(c9IA5,
                       label: block_c9IA5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IA5: // global
           _s9FAU::P64 = P64[Sp + 8];
           _c9IAd::P64 = R1 & 7;
           if (_c9IAd::P64 < 3) goto u9IDr; else goto u9IDs;
       u9IDr: // global
           if (_c9IAd::P64 < 2) goto c9IA9; else goto c9IAa;
       c9IA9: // global
           I64[Sp + 8] = block_c9IAj_info;
           R1 = _s9FAU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IDT; else goto c9IAl;
       u9IDT: // global
           call _c9IAj() args: 0, res: 0, upd: 0;
       c9IAl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IAa: // global
           I64[Sp + 8] = block_c9IAs_info;
           R1 = _s9FAU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IDU; else goto c9IAu;
       u9IDU: // global
           call _c9IAs(R1) args: 0, res: 0, upd: 0;
       c9IAu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9IDs: // global
           if (_c9IAd::P64 < 4) goto c9IAb; else goto c9IAc;
       c9IAb: // global
           I64[Sp - 8] = block_c9IAP_info;
           _s9FAV::P64 = R1;
           _s9FAZ::P64 = P64[R1 + 5];
           R1 = _s9FAU::P64;
           P64[Sp] = _s9FAZ::P64;
           P64[Sp + 8] = _s9FAV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9IDV; else goto c9IAR;
       u9IDV: // global
           call _c9IAP(R1) args: 0, res: 0, upd: 0;
       c9IAR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IAc: // global
           R1 = _s9FAU::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9IAj() //  []
         { info_tbl: [(c9IAj,
                       label: block_c9IAj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IAj: // global
           R1 = GHC.Conc.Sync.ThreadRunning_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9IAs() //  [R1]
         { info_tbl: [(c9IAs,
                       label: block_c9IAs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IAs: // global
           _c9IDq::P64 = R1 & 7;
           if (_c9IDq::P64 < 2) goto c9IAA; else goto u9IDt;
       c9IAA: // global
           R1 = GHC.Conc.Sync.ThreadRunning_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9IDt: // global
           if (_c9IDq::P64 != 3) goto c9IAM; else goto c9IAM;
       c9IAM: // global
           R1 = GHC.Conc.Sync.ThreadFinished_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9IAP() //  [R1]
         { info_tbl: [(c9IAP,
                       label: block_c9IAP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IAP: // global
           _c9IDj::P64 = R1 & 7;
           if (_c9IDj::P64 == 3) goto c9IB2; else goto u9IDu;
       c9IB2: // global
           I64[Sp - 8] = block_c9IB0_info;
           _s9FB0::P64 = R1;
           _s9FB1::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9FB1::P64;
           P64[Sp + 8] = _s9FB0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9IDX; else goto c9IB3;
       u9IDX: // global
           call _c9IB0(R1) args: 0, res: 0, upd: 0;
       c9IB3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9IDu: // global
           if (_c9IDj::P64 == 4) goto u9IDz; else goto u9IDA;
       u9IDz: // global
           Sp = Sp + 16;
           call _c9IDf() args: 0, res: 0, upd: 0;
       u9IDA: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c9ID7() args: 0, res: 0, upd: 0;
     }
 },
 _c9IB0() //  [R1]
         { info_tbl: [(c9IB0,
                       label: block_c9IB0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IB0: // global
           _s9FB1::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9IBa;
               case 2 : goto c9IBk;
               case 3 : goto c9IBQ;
               case 4 : goto c9ICi;
               case 5 : goto c9ICG;
               case 6 : goto c9ID0;
           }
       c9ID0: // global
           I64[Sp + 8] = block_c9ICY_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IE5; else goto c9ID1;
       u9IE5: // global
           call _c9ICY(R1) args: 0, res: 0, upd: 0;
       c9ID1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9ICG: // global
           I64[Sp + 8] = block_c9ICE_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IE4; else goto c9ICH;
       u9IE4: // global
           call _c9ICE(R1) args: 0, res: 0, upd: 0;
       c9ICH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9ICi: // global
           I64[Sp + 8] = block_c9ICg_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IE3; else goto c9ICj;
       u9IE3: // global
           call _c9ICg(R1) args: 0, res: 0, upd: 0;
       c9ICj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IBQ: // global
           I64[Sp + 8] = block_c9IBO_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IE2; else goto c9IBR;
       u9IE2: // global
           call _c9IBO(R1) args: 0, res: 0, upd: 0;
       c9IBR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IBk: // global
           I64[Sp + 8] = block_c9IBi_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9IE1; else goto c9IBl;
       u9IE1: // global
           call _c9IBi(R1) args: 0, res: 0, upd: 0;
       c9IBl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IBa: // global
           I64[Sp + 16] = block_c9IB7_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u9IE0; else goto c9IBb;
       u9IE0: // global
           call _c9IB7() args: 0, res: 0, upd: 0;
       c9IBb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ICY() //  [R1]
         { info_tbl: [(c9ICY,
                       label: block_c9ICY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ICY: // global
           if (R1 & 7 == 6) goto u9IDB; else goto u9IDC;
       u9IDB: // global
           Sp = Sp + 16;
           call _c9IDf() args: 0, res: 0, upd: 0;
       u9IDC: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9ID7() args: 0, res: 0, upd: 0;
     }
 },
 _c9ICE() //  [R1]
         { info_tbl: [(c9ICE,
                       label: block_c9ICE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ICE: // global
           _c9IDm::P64 = R1 & 7;
           if (_c9IDm::P64 != 5) goto u9IDy; else goto u9IDD;
       u9IDy: // global
           if (_c9IDm::P64 != 6) goto u9IDF; else goto u9IDE;
       u9IDF: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9ID7() args: 0, res: 0, upd: 0;
       u9IDE: // global
           Sp = Sp + 16;
           goto u9IEe;
       u9IDD: // global
           Sp = Sp + 16;
           goto u9IEe;
       u9IEe: // global
           call _c9IDf() args: 0, res: 0, upd: 0;
     }
 },
 _c9ICg() //  [R1]
         { info_tbl: [(c9ICg,
                       label: block_c9ICg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ICg: // global
           _c9IDn::P64 = R1 & 7;
           if (_c9IDn::P64 < 4) goto u9IDG; else goto u9IDx;
       u9IDG: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9ID7() args: 0, res: 0, upd: 0;
       u9IDx: // global
           if (_c9IDn::P64 != 5) goto u9IDI; else goto u9IDI;
       u9IDI: // global
           Sp = Sp + 16;
           call _c9IDf() args: 0, res: 0, upd: 0;
     }
 },
 _c9IBO() //  [R1]
         { info_tbl: [(c9IBO,
                       label: block_c9IBO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IBO: // global
           _c9IDo::P64 = R1 & 7;
           if (_c9IDo::P64 < 6) goto u9IDv; else goto u9IDJ;
       u9IDv: // global
           if (_c9IDo::P64 < 3) goto u9IDK; else goto u9IDw;
       u9IDK: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9ID7() args: 0, res: 0, upd: 0;
       u9IDw: // global
           if (_c9IDo::P64 != 4) goto u9IDM; else goto u9IDM;
       u9IDM: // global
           Sp = Sp + 16;
           goto u9IEa;
       u9IDJ: // global
           Sp = Sp + 16;
           goto u9IEa;
       u9IEa: // global
           call _c9IDf() args: 0, res: 0, upd: 0;
     }
 },
 _c9IBi() //  [R1]
         { info_tbl: [(c9IBi,
                       label: block_c9IBi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IBi: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9IDN;
               case 2, 3, 4, 5, 6 : goto u9IDS;
           }
       u9IDS: // global
           Sp = Sp + 16;
           call _c9IDf() args: 0, res: 0, upd: 0;
       u9IDN: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9ID7() args: 0, res: 0, upd: 0;
     }
 },
 _c9IB7() //  []
         { info_tbl: [(c9IB7,
                       label: block_c9IB7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IB7: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9IDf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IDf: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9ID7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ID7: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.026303511 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Conc.Sync.$fEqThreadStatus_closure+1;
         const GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.026909288 UTC

[section ""cstring" . GHC.Conc.Sync.$trModule4_bytes" {
     GHC.Conc.Sync.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.027442274 UTC

[section ""data" . GHC.Conc.Sync.$trModule3_closure" {
     GHC.Conc.Sync.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.027953147 UTC

[section ""cstring" . GHC.Conc.Sync.$trModule2_bytes" {
     GHC.Conc.Sync.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,83,121,110,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.028501076 UTC

[section ""data" . GHC.Conc.Sync.$trModule1_closure" {
     GHC.Conc.Sync.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.029027395 UTC

[section ""data" . GHC.Conc.Sync.$trModule_closure" {
     GHC.Conc.Sync.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.Sync.$trModule3_closure+1;
         const GHC.Conc.Sync.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.029664213 UTC

[section ""data" . $krep_r9FuN_closure" {
     $krep_r9FuN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc'LiftedRep_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.030270037 UTC

[section ""data" . $krep1_r9FuO_closure" {
     $krep1_r9FuO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRuntimeRep_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.030818282 UTC

[section ""data" . $krep2_r9FuP_closure" {
     $krep2_r9FuP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRealWorld_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.031367928 UTC

[section ""data" . $krep3_r9FuQ_closure" {
     $krep3_r9FuQ_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.031903968 UTC

[section ""data" . $krep4_r9FuR_closure" {
     $krep4_r9FuR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcThreadId#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.032458085 UTC

[section ""data" . $krep5_r9FuS_closure" {
     $krep5_r9FuS_closure:
         const :_con_info;
         const $krep3_r9FuQ_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.033002643 UTC

[section ""data" . $krep6_r9FuT_closure" {
     $krep6_r9FuT_closure:
         const :_con_info;
         const $krep2_r9FuP_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.033702957 UTC

[section ""data" . $krep7_r9FuU_closure" {
     $krep7_r9FuU_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcTVar#_closure;
         const $krep6_r9FuT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.034282655 UTC

[section ""data" . $krep8_r9FuV_closure" {
     $krep8_r9FuV_closure:
         const :_con_info;
         const $krep2_r9FuP_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.034838147 UTC

[section ""data" . $krep9_r9FuW_closure" {
     $krep9_r9FuW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcState#_closure;
         const $krep8_r9FuV_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.03538674 UTC

[section ""data" . $krep10_r9FuX_closure" {
     $krep10_r9FuX_closure:
         const :_con_info;
         const $krep1_r9FuO_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.035933789 UTC

[section ""data" . $krep11_r9FuY_closure" {
     $krep11_r9FuY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc'[]_closure;
         const $krep10_r9FuX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.036527292 UTC

[section ""data" . $krep12_r9FuZ_closure" {
     $krep12_r9FuZ_closure:
         const :_con_info;
         const $krep11_r9FuY_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.037098027 UTC

[section ""data" . $krep13_r9Fv0_closure" {
     $krep13_r9Fv0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc'TupleRep_closure;
         const $krep12_r9FuZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.037728785 UTC

[section ""data" . $krep14_r9Fv1_closure" {
     $krep14_r9Fv1_closure:
         const :_con_info;
         const $krep9_r9FuW_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.038263628 UTC

[section ""data" . $krep15_r9Fv2_closure" {
     $krep15_r9Fv2_closure:
         const :_con_info;
         const $krep_r9FuN_closure+1;
         const $krep14_r9Fv1_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.038816163 UTC

[section ""data" . $krep16_r9Fv3_closure" {
     $krep16_r9Fv3_closure:
         const :_con_info;
         const $krep13_r9Fv0_closure+1;
         const $krep15_r9Fv2_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.039382891 UTC

[section ""data" . $krep17_r9Fv4_closure" {
     $krep17_r9Fv4_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc(#,#)_closure;
         const $krep16_r9Fv3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.039963154 UTC

[section ""data" . $krep18_r9Fv5_closure" {
     $krep18_r9Fv5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r9FuW_closure+1;
         const $krep17_r9Fv4_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.040536899 UTC

[section ""cstring" . GHC.Conc.Sync.$tcThreadId2_bytes" {
     GHC.Conc.Sync.$tcThreadId2_bytes:
         I8[] [84,104,114,101,97,100,73,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.041074385 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadId1_closure" {
     GHC.Conc.Sync.$tcThreadId1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcThreadId2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.041717813 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadId_closure" {
     GHC.Conc.Sync.$tcThreadId_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcThreadId1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16775948407395805744;
         const 12520674293648100702;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.042283812 UTC

[section ""data" . $krep19_r9Fv6_closure" {
     $krep19_r9Fv6_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcThreadId_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.042856247 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadId1_closure" {
     GHC.Conc.Sync.$tc'ThreadId1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r9FuR_closure+1;
         const $krep19_r9Fv6_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.043402526 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadId3_bytes" {
     GHC.Conc.Sync.$tc'ThreadId3_bytes:
         I8[] [39,84,104,114,101,97,100,73,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.043916953 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadId2_closure" {
     GHC.Conc.Sync.$tc'ThreadId2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadId3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.044459365 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadId_closure" {
     GHC.Conc.Sync.$tc'ThreadId_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadId2_closure+1;
         const GHC.Conc.Sync.$tc'ThreadId1_closure+4;
         const 18342150043682338300;
         const 5104860271509165481;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.045044924 UTC

[section ""cstring" . GHC.Conc.Sync.$tcBlockReason2_bytes" {
     GHC.Conc.Sync.$tcBlockReason2_bytes:
         I8[] [66,108,111,99,107,82,101,97,115,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.045640614 UTC

[section ""data" . GHC.Conc.Sync.$tcBlockReason1_closure" {
     GHC.Conc.Sync.$tcBlockReason1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcBlockReason2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.046181326 UTC

[section ""data" . GHC.Conc.Sync.$tcBlockReason_closure" {
     GHC.Conc.Sync.$tcBlockReason_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcBlockReason1_closure+1;
         const GHC.Types.krep$*_closure;
         const 13301038780413995570;
         const 11021250300446969031;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.046779883 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcBlockReason_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.047325841 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnMVar2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnMVar2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.047856045 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnMVar1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnMVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.048370528 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnMVar_closure" {
     GHC.Conc.Sync.$tc'BlockedOnMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnMVar1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 6633002816895506850;
         const 13520604374172074732;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.048928511 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnBlackHole3_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole3_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,66,108,97,99,107,72,111,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.049543123 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnBlackHole2_closure" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.051491873 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnBlackHole_closure" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole2_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 9499731398899925739;
         const 7296688042620961692;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.052135166 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnException2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnException2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.052640751 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnException1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnException1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnException2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.053151517 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnException_closure" {
     GHC.Conc.Sync.$tc'BlockedOnException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnException1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 16834505563200403543;
         const 10899729493106152581;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.05413476 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnSTM2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnSTM2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.054652307 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnSTM1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnSTM1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnSTM2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.055217154 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnSTM_closure" {
     GHC.Conc.Sync.$tc'BlockedOnSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnSTM1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 1161208048218837616;
         const 14246412223428266787;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.055804757 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnForeignCall2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnForeignCall2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,70,111,114,101,105,103,110,67,97,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.056358366 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnForeignCall1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnForeignCall1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnForeignCall2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.056898147 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnForeignCall_closure" {
     GHC.Conc.Sync.$tc'BlockedOnForeignCall_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnForeignCall1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 7408412473094687054;
         const 5512662453084487661;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.057588259 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnOther2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnOther2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,79,116,104,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.058121353 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnOther1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnOther1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnOther2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.058681679 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnOther_closure" {
     GHC.Conc.Sync.$tc'BlockedOnOther_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnOther1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 12822899422417308746;
         const 1265626399802742388;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.059247496 UTC

[section ""cstring" . GHC.Conc.Sync.$tcThreadStatus2_bytes" {
     GHC.Conc.Sync.$tcThreadStatus2_bytes:
         I8[] [84,104,114,101,97,100,83,116,97,116,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.059756983 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadStatus1_closure" {
     GHC.Conc.Sync.$tcThreadStatus1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcThreadStatus2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.060340937 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadStatus_closure" {
     GHC.Conc.Sync.$tcThreadStatus_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcThreadStatus1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16437204929171641638;
         const 3495092226815585861;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.060955156 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadDied1_closure" {
     GHC.Conc.Sync.$tc'ThreadDied1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcThreadStatus_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.061574689 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadRunning2_bytes" {
     GHC.Conc.Sync.$tc'ThreadRunning2_bytes:
         I8[] [39,84,104,114,101,97,100,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.062126029 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadRunning1_closure" {
     GHC.Conc.Sync.$tc'ThreadRunning1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadRunning2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.06269787 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadRunning_closure" {
     GHC.Conc.Sync.$tc'ThreadRunning_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadRunning1_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 1667122312602609882;
         const 13647871799576313560;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.06328429 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadFinished2_bytes" {
     GHC.Conc.Sync.$tc'ThreadFinished2_bytes:
         I8[] [39,84,104,114,101,97,100,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.063817943 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadFinished1_closure" {
     GHC.Conc.Sync.$tc'ThreadFinished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadFinished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.064351831 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadFinished_closure" {
     GHC.Conc.Sync.$tc'ThreadFinished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadFinished1_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 2441107603776884109;
         const 12730966154693836607;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.064933964 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadDied3_bytes" {
     GHC.Conc.Sync.$tc'ThreadDied3_bytes:
         I8[] [39,84,104,114,101,97,100,68,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.065528882 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadDied2_closure" {
     GHC.Conc.Sync.$tc'ThreadDied2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadDied3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.066063272 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadDied_closure" {
     GHC.Conc.Sync.$tc'ThreadDied_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied2_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 9513974555658789847;
         const 4757719484357493227;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.066639254 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadBlocked1_closure" {
     GHC.Conc.Sync.$tc'ThreadBlocked1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.067169653 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadBlocked3_bytes" {
     GHC.Conc.Sync.$tc'ThreadBlocked3_bytes:
         I8[] [39,84,104,114,101,97,100,66,108,111,99,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.067707444 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadBlocked2_closure" {
     GHC.Conc.Sync.$tc'ThreadBlocked2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadBlocked3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.068250403 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadBlocked_closure" {
     GHC.Conc.Sync.$tc'ThreadBlocked_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadBlocked2_closure+1;
         const GHC.Conc.Sync.$tc'ThreadBlocked1_closure+4;
         const 1896650886570328403;
         const 13390928353603149841;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.068840673 UTC

[section ""cstring" . GHC.Conc.Sync.$tcPrimMVar2_bytes" {
     GHC.Conc.Sync.$tcPrimMVar2_bytes:
         I8[] [80,114,105,109,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.070058461 UTC

[section ""data" . GHC.Conc.Sync.$tcPrimMVar1_closure" {
     GHC.Conc.Sync.$tcPrimMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcPrimMVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.070574811 UTC

[section ""data" . GHC.Conc.Sync.$tcPrimMVar_closure" {
     GHC.Conc.Sync.$tcPrimMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcPrimMVar1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9965391380168186507;
         const 18322737771689556223;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.071139914 UTC

[section ""cstring" . GHC.Conc.Sync.$tcSTM2_bytes" {
     GHC.Conc.Sync.$tcSTM2_bytes:
         I8[] [83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.071675481 UTC

[section ""data" . GHC.Conc.Sync.$tcSTM1_closure" {
     GHC.Conc.Sync.$tcSTM1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcSTM2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.072212608 UTC

[section ""data" . GHC.Conc.Sync.$tcSTM_closure" {
     GHC.Conc.Sync.$tcSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcSTM1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 2004856025729794332;
         const 14974623362753764267;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.07277158 UTC

[section ""data" . $krep20_r9Fv7_closure" {
     $krep20_r9Fv7_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcSTM_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.073403396 UTC

[section ""data" . GHC.Conc.Sync.$tc'STM1_closure" {
     GHC.Conc.Sync.$tc'STM1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep18_r9Fv5_closure+4;
         const $krep20_r9Fv7_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.073944683 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'STM3_bytes" {
     GHC.Conc.Sync.$tc'STM3_bytes:
         I8[] [39,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.074486579 UTC

[section ""data" . GHC.Conc.Sync.$tc'STM2_closure" {
     GHC.Conc.Sync.$tc'STM2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'STM3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.075055351 UTC

[section ""data" . GHC.Conc.Sync.$tc'STM_closure" {
     GHC.Conc.Sync.$tc'STM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'STM2_closure+1;
         const GHC.Conc.Sync.$tc'STM1_closure+4;
         const 11288073744523536973;
         const 9767688212531311940;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.075622857 UTC

[section ""cstring" . GHC.Conc.Sync.$tcTVar2_bytes" {
     GHC.Conc.Sync.$tcTVar2_bytes:
         I8[] [84,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.076148142 UTC

[section ""data" . GHC.Conc.Sync.$tcTVar1_closure" {
     GHC.Conc.Sync.$tcTVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcTVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.077399054 UTC

[section ""data" . GHC.Conc.Sync.$tcTVar_closure" {
     GHC.Conc.Sync.$tcTVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcTVar1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13084572405727191592;
         const 5232564955606145236;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.077998021 UTC

[section ""data" . $krep21_r9Fv8_closure" {
     $krep21_r9Fv8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcTVar_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.078594489 UTC

[section ""data" . GHC.Conc.Sync.$tc'TVar1_closure" {
     GHC.Conc.Sync.$tc'TVar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r9FuU_closure+1;
         const $krep21_r9Fv8_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.079168796 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'TVar3_bytes" {
     GHC.Conc.Sync.$tc'TVar3_bytes:
         I8[] [39,84,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.079714528 UTC

[section ""data" . GHC.Conc.Sync.$tc'TVar2_closure" {
     GHC.Conc.Sync.$tc'TVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'TVar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.080224066 UTC

[section ""data" . GHC.Conc.Sync.$tc'TVar_closure" {
     GHC.Conc.Sync.$tc'TVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'TVar2_closure+1;
         const GHC.Conc.Sync.$tc'TVar1_closure+4;
         const 9463269625853265574;
         const 3517068532143837766;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.080834303 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadId2_bytes" {
     GHC.Conc.Sync.$fShowThreadId2_bytes:
         I8[] [84,104,114,101,97,100,73,100,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.082641005 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure" {
     GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure:
         const GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_info;
 },
 x_s9FBb_entry() //  [R1]
         { info_tbl: [(c9IEt,
                       label: x_s9FBb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IEt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9IEC; else goto c9IED;
       c9IEC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IED: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9IEq_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9IEH; else goto c9IEr;
       u9IEH: // global
           call _c9IEq(R1) args: 0, res: 0, upd: 0;
       c9IEr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9IEq() //  [R1]
         { info_tbl: [(c9IEq,
                       label: block_c9IEq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IEq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9IEG; else goto c9IEF;
       c9IEG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9IEF: // global
           (_s9FBh::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadId(P64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FBh::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FBr_entry() //  [R1]
         { info_tbl: [(c9IEU,
                       label: sat_s9FBr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IEU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9IF5; else goto c9IF6;
       c9IF5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IF6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9IER_info;
           _s9FB9::P64 = P64[R1 + 16];
           _s9FBj::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s9FB9::P64;
           P64[Sp - 24] = _s9FBj::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9IFd; else goto c9IES;
       u9IFd: // global
           call _c9IER(R1) args: 0, res: 0, upd: 0;
       c9IES: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9IER() //  [R1]
         { info_tbl: [(c9IER,
                       label: block_c9IER_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IER: // global
           I64[Sp] = block_c9IEX_info;
           _s9FBl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s9FBl::I64;
           if (R1 & 7 != 0) goto u9IFc; else goto c9IEY;
       u9IFc: // global
           call _c9IEX(R1) args: 0, res: 0, upd: 0;
       c9IEY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9IEX() //  [R1]
         { info_tbl: [(c9IEX,
                       label: block_c9IEX_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IEX: // global
           _s9FBj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9IF2_info;
           R4 = _s9FBj::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9IF2() //  [R1, R2]
         { info_tbl: [(c9IF2,
                       label: block_c9IF2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IF2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9IFb; else goto c9IFa;
       c9IFb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9IFa: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FBs_entry() //  [R1, R2]
         { info_tbl: [(c9IFe,
                       label: sat_s9FBs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IFe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9IFi; else goto c9IFh;
       c9IFi: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IFh: // global
           _s9FB9::P64 = P64[R1 + 7];
           _s9FBb::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FBr_info;
           P64[Hp - 16] = _s9FB9::P64;
           P64[Hp - 8] = _s9FBb::P64;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = GHC.Conc.Sync.$fShowThreadId2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c9IFj,
                       label: GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IFj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c9IFn; else goto c9IFm;
       c9IFn: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9IFm: // global
           I64[Hp - 40] = x_s9FBb_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s9FBs_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.086218634 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_$cshow_closure" {
     GHC.Conc.Sync.$fShowThreadId_$cshow_closure:
         const GHC.Conc.Sync.$fShowThreadId_$cshow_info;
 },
 sat_s9FBE_entry() //  [R1]
         { info_tbl: [(c9IFz,
                       label: sat_s9FBE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IFz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9IFK; else goto c9IFL;
       c9IFK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IFL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9IFw_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9IFQ; else goto c9IFx;
       u9IFQ: // global
           call _c9IFw(R1) args: 0, res: 0, upd: 0;
       c9IFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9IFw() //  [R1]
         { info_tbl: [(c9IFw,
                       label: block_c9IFw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IFw: // global
           (_s9FBz::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadId(P64[R1 + 7]);
           I64[Sp] = block_c9IFH_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FBz::I64));
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9IFH() //  [R1, R2]
         { info_tbl: [(c9IFH,
                       label: block_c9IFH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IFH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9IFP; else goto c9IFO;
       c9IFP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9IFO: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$fShowThreadId_$cshow_entry() //  [R2]
         { info_tbl: [(c9IFR,
                       label: GHC.Conc.Sync.$fShowThreadId_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IFR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9IFV; else goto c9IFU;
       c9IFV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadId_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IFU: // global
           I64[Hp - 16] = sat_s9FBE_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = GHC.Conc.Sync.$fShowThreadId2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.088612021 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId1_closure" {
     GHC.Conc.Sync.$fShowThreadId1_closure:
         const GHC.Conc.Sync.$fShowThreadId1_info;
 },
 x_s9FBG_entry() //  [R1]
         { info_tbl: [(c9IG7,
                       label: x_s9FBG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IG7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9IGg; else goto c9IGh;
       c9IGg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IGh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9IG4_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9IGl; else goto c9IG5;
       u9IGl: // global
           call _c9IG4(R1) args: 0, res: 0, upd: 0;
       c9IG5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9IG4() //  [R1]
         { info_tbl: [(c9IG4,
                       label: block_c9IG4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IG4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9IGk; else goto c9IGj;
       c9IGk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9IGj: // global
           (_s9FBM::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadId(P64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FBM::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FBU_entry() //  [R1]
         { info_tbl: [(c9IGy,
                       label: sat_s9FBU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IGy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9IGE; else goto c9IGF;
       c9IGE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IGF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c9IGv_info;
           _s9FBO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s9FBO::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9IGK; else goto c9IGw;
       u9IGK: // global
           call _c9IGv(R1) args: 0, res: 0, upd: 0;
       c9IGw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9IGv() //  [R1]
         { info_tbl: [(c9IGv,
                       label: block_c9IGv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IGv: // global
           _s9FBO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9IGB_info;
           R4 = _s9FBO::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9IGB() //  [R1, R2]
         { info_tbl: [(c9IGB,
                       label: block_c9IGB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IGB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9IGJ; else goto c9IGI;
       c9IGJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9IGI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FBV_entry() //  [R1, R2]
         { info_tbl: [(c9IGL,
                       label: sat_s9FBV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IGL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9IGP; else goto c9IGO;
       c9IGP: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IGO: // global
           _s9FBG::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s9FBU_info;
           P64[Hp - 8] = _s9FBG::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = GHC.Conc.Sync.$fShowThreadId2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fShowThreadId1_entry() //  [R2]
         { info_tbl: [(c9IGQ,
                       label: GHC.Conc.Sync.$fShowThreadId1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IGQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9IGU; else goto c9IGT;
       c9IGU: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadId1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IGT: // global
           I64[Hp - 32] = x_s9FBG_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s9FBV_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.09106763 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_$cshowList_closure" {
     GHC.Conc.Sync.$fShowThreadId_$cshowList_closure:
         const GHC.Conc.Sync.$fShowThreadId_$cshowList_info;
 },
 GHC.Conc.Sync.$fShowThreadId_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c9IGZ,
                       label: GHC.Conc.Sync.$fShowThreadId_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IGZ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$fShowThreadId1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.091763041 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_closure" {
     GHC.Conc.Sync.$fShowThreadId_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure+2;
         const GHC.Conc.Sync.$fShowThreadId_$cshow_closure+1;
         const GHC.Conc.Sync.$fShowThreadId_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.092442162 UTC

[section ""data" . reportHeapOverflow1_r9Fv9_closure" {
     reportHeapOverflow1_r9Fv9_closure:
         const reportHeapOverflow1_r9Fv9_info;
 },
 reportHeapOverflow1_r9Fv9_entry() //  []
         { info_tbl: [(c9IH7,
                       label: reportHeapOverflow1_r9Fv9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IH7: // global
           call "ccall" arg hints:  []  result hints:  [] reportHeapOverflow();
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.093198272 UTC

[section ""data" . GHC.Conc.Sync.reportHeapOverflow_closure" {
     GHC.Conc.Sync.reportHeapOverflow_closure:
         const GHC.Conc.Sync.reportHeapOverflow_info;
 },
 GHC.Conc.Sync.reportHeapOverflow_entry() //  []
         { info_tbl: [(c9IHe,
                       label: GHC.Conc.Sync.reportHeapOverflow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IHe: // global
           call reportHeapOverflow1_r9Fv9_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.09428431 UTC

[section ""data" . GHC.Conc.Sync.cmpThread_closure" {
     GHC.Conc.Sync.cmpThread_closure:
         const GHC.Conc.Sync.cmpThread_info;
 },
 GHC.Conc.Sync.cmpThread_entry() //  [R2, R3]
         { info_tbl: [(c9IHo,
                       label: GHC.Conc.Sync.cmpThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IHo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IHs; else goto c9IHt;
       c9IHs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.cmpThread_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9IHt: // global
           I64[Sp - 16] = block_c9IHl_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9II0; else goto c9IHm;
       u9II0: // global
           call _c9IHl(R1) args: 0, res: 0, upd: 0;
       c9IHm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IHl() //  [R1]
         { info_tbl: [(c9IHl,
                       label: block_c9IHl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IHl: // global
           I64[Sp] = block_c9IHr_info;
           _s9FC5::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FC5::P64;
           if (R1 & 7 != 0) goto u9IHZ; else goto c9IHv;
       u9IHZ: // global
           call _c9IHr(R1) args: 0, res: 0, upd: 0;
       c9IHv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IHr() //  [R1]
         { info_tbl: [(c9IHr,
                       label: block_c9IHr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IHr: // global
           (_s9FCb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FCc::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FCb::I64));
           if (_s9FCc::I64 != (-1)) goto u9IHY; else goto c9IHO;
       u9IHY: // global
           if (_s9FCc::I64 != 0) goto c9IHI; else goto c9IHU;
       c9IHI: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9IHU: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9IHO: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.096003877 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadId_$c==_closure" {
     GHC.Conc.Sync.$fEqThreadId_$c==_closure:
         const GHC.Conc.Sync.$fEqThreadId_$c==_info;
 },
 GHC.Conc.Sync.$fEqThreadId_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9II8,
                       label: GHC.Conc.Sync.$fEqThreadId_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9II8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IIc; else goto c9IId;
       c9IIc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadId_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9IId: // global
           I64[Sp - 16] = block_c9II5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9IID; else goto c9II6;
       u9IID: // global
           call _c9II5(R1) args: 0, res: 0, upd: 0;
       c9II6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9II5() //  [R1]
         { info_tbl: [(c9II5,
                       label: block_c9II5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9II5: // global
           I64[Sp] = block_c9IIb_info;
           _s9FCg::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCg::P64;
           if (R1 & 7 != 0) goto u9IIC; else goto c9IIf;
       u9IIC: // global
           call _c9IIb(R1) args: 0, res: 0, upd: 0;
       c9IIf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IIb() //  [R1]
         { info_tbl: [(c9IIb,
                       label: block_c9IIb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IIb: // global
           (_s9FCm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9FCm::I64) == 0 :: W32) goto c9IIy; else goto c9IIs;
       c9IIy: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9IIs: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.098025358 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadId_$c/=_closure" {
     GHC.Conc.Sync.$fEqThreadId_$c/=_closure:
         const GHC.Conc.Sync.$fEqThreadId_$c/=_info;
 },
 GHC.Conc.Sync.$fEqThreadId_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9IIL,
                       label: GHC.Conc.Sync.$fEqThreadId_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IIL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IIP; else goto c9IIQ;
       c9IIP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadId_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9IIQ: // global
           I64[Sp - 16] = block_c9III_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9IJg; else goto c9IIJ;
       u9IJg: // global
           call _c9III(R1) args: 0, res: 0, upd: 0;
       c9IIJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9III() //  [R1]
         { info_tbl: [(c9III,
                       label: block_c9III_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9III: // global
           I64[Sp] = block_c9IIO_info;
           _s9FCr::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCr::P64;
           if (R1 & 7 != 0) goto u9IJf; else goto c9IIS;
       u9IJf: // global
           call _c9IIO(R1) args: 0, res: 0, upd: 0;
       c9IIS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IIO() //  [R1]
         { info_tbl: [(c9IIO,
                       label: block_c9IIO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IIO: // global
           (_s9FCx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9FCx::I64) == 0 :: W32) goto c9IJb; else goto c9IJ5;
       c9IJb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9IJ5: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.09928995 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadId_closure" {
     GHC.Conc.Sync.$fEqThreadId_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqThreadId_$c==_closure+2;
         const GHC.Conc.Sync.$fEqThreadId_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.10018245 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c<_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c<_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c<_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c<_entry() //  [R2, R3]
         { info_tbl: [(c9IJo,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IJo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IJs; else goto c9IJt;
       c9IJs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9IJt: // global
           I64[Sp - 16] = block_c9IJl_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9IJT; else goto c9IJm;
       u9IJT: // global
           call _c9IJl(R1) args: 0, res: 0, upd: 0;
       c9IJm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IJl() //  [R1]
         { info_tbl: [(c9IJl,
                       label: block_c9IJl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IJl: // global
           I64[Sp] = block_c9IJr_info;
           _s9FCC::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCC::P64;
           if (R1 & 7 != 0) goto u9IJS; else goto c9IJv;
       u9IJS: // global
           call _c9IJr(R1) args: 0, res: 0, upd: 0;
       c9IJv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IJr() //  [R1]
         { info_tbl: [(c9IJr,
                       label: block_c9IJr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IJr: // global
           (_s9FCI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9FCI::I64) == (-1) :: W32) goto c9IJO; else goto c9IJI;
       c9IJO: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9IJI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.101837305 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c>=_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c>=_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c>=_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c9IK1,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IK1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IK5; else goto c9IK6;
       c9IK5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9IK6: // global
           I64[Sp - 16] = block_c9IJY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9IKw; else goto c9IJZ;
       u9IKw: // global
           call _c9IJY(R1) args: 0, res: 0, upd: 0;
       c9IJZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IJY() //  [R1]
         { info_tbl: [(c9IJY,
                       label: block_c9IJY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IJY: // global
           I64[Sp] = block_c9IK4_info;
           _s9FCN::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCN::P64;
           if (R1 & 7 != 0) goto u9IKv; else goto c9IK8;
       u9IKv: // global
           call _c9IK4(R1) args: 0, res: 0, upd: 0;
       c9IK8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IK4() //  [R1]
         { info_tbl: [(c9IK4,
                       label: block_c9IK4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IK4: // global
           (_s9FCT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9FCT::I64) == (-1) :: W32) goto c9IKr; else goto c9IKl;
       c9IKr: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9IKl: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.103601559 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c>_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c>_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c>_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c>_entry() //  [R2, R3]
         { info_tbl: [(c9IKE,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IKE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IKI; else goto c9IKJ;
       c9IKI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9IKJ: // global
           I64[Sp - 16] = block_c9IKB_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9ILg; else goto c9IKC;
       u9ILg: // global
           call _c9IKB(R1) args: 0, res: 0, upd: 0;
       c9IKC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IKB() //  [R1]
         { info_tbl: [(c9IKB,
                       label: block_c9IKB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IKB: // global
           I64[Sp] = block_c9IKH_info;
           _s9FCY::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCY::P64;
           if (R1 & 7 != 0) goto u9ILf; else goto c9IKL;
       u9ILf: // global
           call _c9IKH(R1) args: 0, res: 0, upd: 0;
       c9IKL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IKH() //  [R1]
         { info_tbl: [(c9IKH,
                       label: block_c9IKH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IKH: // global
           (_s9FD4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FD5::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FD4::I64));
           if (_s9FD5::I64 == (-1)) goto c9ILa; else goto u9ILe;
       u9ILe: // global
           if (_s9FD5::I64 == 0) goto c9ILa; else goto c9IKY;
       c9ILa: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9IKY: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.105386189 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c<=_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c<=_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c<=_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c9ILo,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ILo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9ILs; else goto c9ILt;
       c9ILs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9ILt: // global
           I64[Sp - 16] = block_c9ILl_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9IM0; else goto c9ILm;
       u9IM0: // global
           call _c9ILl(R1) args: 0, res: 0, upd: 0;
       c9ILm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ILl() //  [R1]
         { info_tbl: [(c9ILl,
                       label: block_c9ILl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ILl: // global
           I64[Sp] = block_c9ILr_info;
           _s9FD9::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FD9::P64;
           if (R1 & 7 != 0) goto u9ILZ; else goto c9ILv;
       u9ILZ: // global
           call _c9ILr(R1) args: 0, res: 0, upd: 0;
       c9ILv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ILr() //  [R1]
         { info_tbl: [(c9ILr,
                       label: block_c9ILr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ILr: // global
           (_s9FDf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FDg::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FDf::I64));
           if (_s9FDg::I64 == (-1)) goto c9ILU; else goto u9ILY;
       u9ILY: // global
           if (_s9FDg::I64 == 0) goto c9ILU; else goto c9ILI;
       c9ILU: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9ILI: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.107135286 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$cmax_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$cmax_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$cmax_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c9IM8,
                       label: GHC.Conc.Sync.$fOrdThreadId_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IM8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9IMc; else goto c9IMd;
       c9IMc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9IMd: // global
           I64[Sp - 16] = block_c9IM5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9IMK; else goto c9IM6;
       u9IMK: // global
           call _c9IM5(R1) args: 0, res: 0, upd: 0;
       c9IM6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IM5() //  [R1]
         { info_tbl: [(c9IM5,
                       label: block_c9IM5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IM5: // global
           I64[Sp - 8] = block_c9IMb_info;
           _s9FDj::P64 = R1;
           _s9FDk::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9FDk::P64;
           P64[Sp + 8] = _s9FDj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9IMJ; else goto c9IMf;
       u9IMJ: // global
           call _c9IMb(R1) args: 0, res: 0, upd: 0;
       c9IMf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IMb() //  [R1]
         { info_tbl: [(c9IMb,
                       label: block_c9IMb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IMb: // global
           _s9FDj::P64 = P64[Sp + 16];
           (_s9FDq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FDr::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FDq::I64));
           if (_s9FDr::I64 == (-1)) goto c9IME; else goto u9IMI;
       u9IMI: // global
           if (_s9FDr::I64 == 0) goto c9IME; else goto c9IMs;
       c9IME: // global
           R1 = _s9FDj::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9IMs: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.108965072 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$cmin_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$cmin_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$cmin_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c9IMS,
                       label: GHC.Conc.Sync.$fOrdThreadId_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IMS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9IMW; else goto c9IMX;
       c9IMW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9IMX: // global
           I64[Sp - 16] = block_c9IMP_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9INu; else goto c9IMQ;
       u9INu: // global
           call _c9IMP(R1) args: 0, res: 0, upd: 0;
       c9IMQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IMP() //  [R1]
         { info_tbl: [(c9IMP,
                       label: block_c9IMP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IMP: // global
           I64[Sp - 8] = block_c9IMV_info;
           _s9FDu::P64 = R1;
           _s9FDv::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9FDv::P64;
           P64[Sp + 8] = _s9FDu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9INt; else goto c9IMZ;
       u9INt: // global
           call _c9IMV(R1) args: 0, res: 0, upd: 0;
       c9IMZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IMV() //  [R1]
         { info_tbl: [(c9IMV,
                       label: block_c9IMV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IMV: // global
           _s9FDu::P64 = P64[Sp + 16];
           (_s9FDB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FDw::P64 = R1;
           _s9FDC::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FDB::I64));
           if (_s9FDC::I64 == (-1)) goto c9INo; else goto u9INs;
       u9INs: // global
           if (_s9FDC::I64 == 0) goto c9INo; else goto c9INc;
       c9INo: // global
           R1 = _s9FDw::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9INc: // global
           R1 = _s9FDu::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.110522061 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_closure" {
     GHC.Conc.Sync.$fOrdThreadId_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Conc.Sync.$fEqThreadId_closure+1;
         const GHC.Conc.Sync.cmpThread_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c<_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c<=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c>_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c>=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$cmax_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.111158795 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus10_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus10_bytes:
         I8[] [84,104,114,101,97,100,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.111829497 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus9_closure" {
     GHC.Conc.Sync.$fShowThreadStatus9_closure:
         const GHC.Conc.Sync.$fShowThreadStatus9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus9_entry() //  [R1]
         { info_tbl: [(c9INB,
                       label: GHC.Conc.Sync.$fShowThreadStatus9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9INB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9INC; else goto c9IND;
       c9INC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IND: // global
           (_c9INy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9INy::I64 == 0) goto c9INA; else goto c9INz;
       c9INA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9INz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9INy::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.112694541 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus8_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus8_bytes:
         I8[] [84,104,114,101,97,100,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.113416741 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus7_closure" {
     GHC.Conc.Sync.$fShowThreadStatus7_closure:
         const GHC.Conc.Sync.$fShowThreadStatus7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus7_entry() //  [R1]
         { info_tbl: [(c9INK,
                       label: GHC.Conc.Sync.$fShowThreadStatus7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9INK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9INL; else goto c9INM;
       c9INL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9INM: // global
           (_c9INH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9INH::I64 == 0) goto c9INJ; else goto c9INI;
       c9INJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9INI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9INH::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.114275982 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus6_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus6_bytes:
         I8[] [84,104,114,101,97,100,66,108,111,99,107,101,100,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.114965312 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus5_closure" {
     GHC.Conc.Sync.$fShowThreadStatus5_closure:
         const GHC.Conc.Sync.$fShowThreadStatus5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus5_entry() //  [R1]
         { info_tbl: [(c9INT,
                       label: GHC.Conc.Sync.$fShowThreadStatus5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9INT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9INU; else goto c9INV;
       c9INU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9INV: // global
           (_c9INQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9INQ::I64 == 0) goto c9INS; else goto c9INR;
       c9INS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9INR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9INQ::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.115740399 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus4_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus4_bytes:
         I8[] [84,104,114,101,97,100,68,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.116417252 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus3_closure" {
     GHC.Conc.Sync.$fShowThreadStatus3_closure:
         const GHC.Conc.Sync.$fShowThreadStatus3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus3_entry() //  [R1]
         { info_tbl: [(c9IO2,
                       label: GHC.Conc.Sync.$fShowThreadStatus3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IO2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IO3; else goto c9IO4;
       c9IO3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IO4: // global
           (_c9INZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9INZ::I64 == 0) goto c9IO1; else goto c9IO0;
       c9IO1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9IO0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9INZ::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.118359766 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure:
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_info;
         const 0;
 },
 sat_s9FDL_entry() //  [R1]
         { info_tbl: [(c9IOs,
                       label: sat_s9FDL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IOs: // global
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FDN_entry() //  [R1]
         { info_tbl: [(c9IOF,
                       label: sat_s9FDN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IOF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9IOJ; else goto c9IOI;
       c9IOJ: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IOI: // global
           _s9FDF::P64 = P64[R1 + 16];
           _s9FDH::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s9FDF::P64;
           R3 = Hp - 14;
           R2 = _s9FDH::P64;
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FDO_entry() //  [R1]
         { info_tbl: [(c9IOK,
                       label: sat_s9FDO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IOK: // global
           _s9FDO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9IOL; else goto c9IOM;
       c9IOM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9IOO; else goto c9ION;
       c9IOO: // global
           HpAlloc = 32;
           goto c9IOL;
       c9IOL: // global
           R1 = _s9FDO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9ION: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9FDO::P64;
           _s9FDF::P64 = P64[_s9FDO::P64 + 16];
           _s9FDH::P64 = P64[_s9FDO::P64 + 24];
           I64[Hp - 24] = sat_s9FDN_info;
           P64[Hp - 8] = _s9FDF::P64;
           P64[Hp] = _s9FDH::P64;
           R3 = Hp - 24;
           R2 = GHC.Conc.Sync.$fShowThreadStatus5_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c9IOV,
                       label: GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IOV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9IOW; else goto c9IOX;
       c9IOW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9IOX: // global
           I64[Sp - 24] = block_c9IO9_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9IPg; else goto c9IOa;
       u9IPg: // global
           call _c9IO9(R1) args: 0, res: 0, upd: 0;
       c9IOa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IO9() //  [R1]
         { info_tbl: [(c9IO9,
                       label: block_c9IO9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IO9: // global
           _s9FDF::P64 = P64[Sp + 16];
           _c9IOU::P64 = R1 & 7;
           if (_c9IOU::P64 < 3) goto u9IPd; else goto u9IPe;
       u9IPd: // global
           if (_c9IOU::P64 < 2) goto c9IOQ; else goto c9IOR;
       c9IOQ: // global
           R3 = _s9FDF::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus9_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9IOR: // global
           R3 = _s9FDF::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus7_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u9IPe: // global
           if (_c9IOU::P64 < 4) goto c9IOS; else goto c9IOT;
       c9IOS: // global
           I64[Sp] = block_c9IOg_info;
           _s9FDH::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FDH::P64;
           if (R1 & 7 != 0) goto u9IPf; else goto c9IOh;
       u9IPf: // global
           call _c9IOg(R1) args: 0, res: 0, upd: 0;
       c9IOh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9IOT: // global
           R3 = _s9FDF::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus3_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c9IOg() //  [R1]
         { info_tbl: [(c9IOg,
                       label: block_c9IOg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IOg: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9IP5; else goto c9IP4;
       c9IP5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9IP4: // global
           _s9FDF::P64 = P64[Sp + 16];
           _s9FDH::P64 = P64[Sp + 8];
           if (%MO_S_Lt_W64(I64[R1 + 7], 11)) goto c9IP7; else goto c9IP9;
       c9IP7: // global
           I64[Hp - 48] = sat_s9FDL_info;
           P64[Hp - 32] = _s9FDF::P64;
           P64[Hp - 24] = _s9FDH::P64;
           _c9IOo::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c9IOo::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus5_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9IP9: // global
           I64[Hp - 48] = sat_s9FDO_info;
           P64[Hp - 32] = _s9FDF::P64;
           P64[Hp - 24] = _s9FDH::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.121587885 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure:
         const GHC.Conc.Sync.$fShowThreadStatus_$cshow_info;
         const 0;
 },
 sat_s9FDS_entry() //  [R1]
         { info_tbl: [(c9IPw,
                       label: sat_s9FDS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IPw: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fShowThreadStatus_$cshow_entry() //  [R2]
         { info_tbl: [(c9IPF,
                       label: GHC.Conc.Sync.$fShowThreadStatus_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IPF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9IPG; else goto c9IPH;
       c9IPG: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IPH: // global
           I64[Sp - 8] = block_c9IPl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9IPU; else goto c9IPm;
       u9IPU: // global
           call _c9IPl(R1) args: 0, res: 0, upd: 0;
       c9IPm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IPl() //  [R1]
         { info_tbl: [(c9IPl,
                       label: block_c9IPl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IPl: // global
           _c9IPE::P64 = R1 & 7;
           if (_c9IPE::P64 < 3) goto u9IPS; else goto u9IPT;
       u9IPS: // global
           if (_c9IPE::P64 < 2) goto c9IPA; else goto c9IPB;
       c9IPA: // global
           R1 = GHC.Conc.Sync.$fShowThreadStatus9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9IPB: // global
           R1 = GHC.Conc.Sync.$fShowThreadStatus7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9IPT: // global
           if (_c9IPE::P64 < 4) goto c9IPC; else goto c9IPD;
       c9IPC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9IPO; else goto c9IPN;
       c9IPO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9IPN: // global
           _s9FDR::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_s9FDS_info;
           P64[Hp] = _s9FDR::P64;
           R3 = Hp - 16;
           R2 = GHC.Conc.Sync.$fShowThreadStatus5_closure;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9IPD: // global
           R1 = GHC.Conc.Sync.$fShowThreadStatus3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.123019464 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus2_closure" {
     GHC.Conc.Sync.$fShowThreadStatus2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.123680775 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus1_closure" {
     GHC.Conc.Sync.$fShowThreadStatus1_closure:
         const GHC.Conc.Sync.$fShowThreadStatus1_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus1_entry() //  [R2, R3]
         { info_tbl: [(c9IPZ,
                       label: GHC.Conc.Sync.$fShowThreadStatus1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IPZ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$fShowThreadStatus2_closure+1;
           call GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.124513771 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_$cshowList_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_$cshowList_closure:
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowList_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c9IQ6,
                       label: GHC.Conc.Sync.$fShowThreadStatus_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IQ6: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$fShowThreadStatus1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.125276165 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure+3;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure+1;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.126033598 UTC

[section ""data" . GHC.Conc.Sync.killThread2_closure" {
     GHC.Conc.Sync.killThread2_closure:
         const GHC.Conc.Sync.killThread2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.killThread2_entry() //  [R1]
         { info_tbl: [(c9IQf,
                       label: GHC.Conc.Sync.killThread2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IQf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IQg; else goto c9IQh;
       c9IQg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IQh: // global
           (_c9IQc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9IQc::I64 == 0) goto c9IQe; else goto c9IQd;
       c9IQe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9IQd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9IQc::I64;
           R2 = GHC.IO.Exception.ThreadKilled_closure+3;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.127148751 UTC

[section ""data" . GHC.Conc.Sync.killThread1_closure" {
     GHC.Conc.Sync.killThread1_closure:
         const GHC.Conc.Sync.killThread1_info;
         const 0;
 },
 GHC.Conc.Sync.killThread1_entry() //  [R2]
         { info_tbl: [(c9IQp,
                       label: GHC.Conc.Sync.killThread1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IQp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9IQt; else goto c9IQu;
       c9IQt: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.killThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IQu: // global
           I64[Sp - 8] = block_c9IQm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9IQy; else goto c9IQn;
       u9IQy: // global
           call _c9IQm(R1) args: 0, res: 0, upd: 0;
       c9IQn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IQm() //  [R1]
         { info_tbl: [(c9IQm,
                       label: block_c9IQm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IQm: // global
           I64[Sp] = block_c9IQs_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IQs() //  []
         { info_tbl: [(c9IQs,
                       label: block_c9IQs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IQs: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.128357149 UTC

[section ""data" . GHC.Conc.Sync.killThread_closure" {
     GHC.Conc.Sync.killThread_closure:
         const GHC.Conc.Sync.killThread_info;
         const 0;
 },
 GHC.Conc.Sync.killThread_entry() //  [R2]
         { info_tbl: [(c9IQD,
                       label: GHC.Conc.Sync.killThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IQD: // global
           R2 = R2;
           call GHC.Conc.Sync.killThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.12926793 UTC

[section ""data" . GHC.Conc.Sync.getNumProcessors1_closure" {
     GHC.Conc.Sync.getNumProcessors1_closure:
         const GHC.Conc.Sync.getNumProcessors1_info;
 },
 GHC.Conc.Sync.getNumProcessors1_entry() //  []
         { info_tbl: [(c9IQN,
                       label: GHC.Conc.Sync.getNumProcessors1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IQN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9IQW; else goto c9IQV;
       c9IQW: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.getNumProcessors1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9IQV: // global
           (_s9FE4::I64) = call "ccall" arg hints:  []  result hints:  [] getNumberOfProcessors();
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s9FE4::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.131728775 UTC

[section ""data" . GHC.Conc.Sync.getNumProcessors_closure" {
     GHC.Conc.Sync.getNumProcessors_closure:
         const GHC.Conc.Sync.getNumProcessors_info;
 },
 GHC.Conc.Sync.getNumProcessors_entry() //  []
         { info_tbl: [(c9IR1,
                       label: GHC.Conc.Sync.getNumProcessors_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IR1: // global
           call GHC.Conc.Sync.getNumProcessors1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.132395936 UTC

[section ""data" . GHC.Conc.Sync.threadStatus7_closure" {
     GHC.Conc.Sync.threadStatus7_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnOther_closure+6;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.13291449 UTC

[section ""data" . GHC.Conc.Sync.threadStatus6_closure" {
     GHC.Conc.Sync.threadStatus6_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnMVar_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.133723391 UTC

[section ""data" . GHC.Conc.Sync.threadStatus2_closure" {
     GHC.Conc.Sync.threadStatus2_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnException_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.134247156 UTC

[section ""data" . GHC.Conc.Sync.threadStatus3_closure" {
     GHC.Conc.Sync.threadStatus3_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.134786991 UTC

[section ""data" . GHC.Conc.Sync.threadStatus4_closure" {
     GHC.Conc.Sync.threadStatus4_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnSTM_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.135343128 UTC

[section ""data" . GHC.Conc.Sync.threadStatus5_closure" {
     GHC.Conc.Sync.threadStatus5_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.136529419 UTC

[section ""data" . GHC.Conc.Sync.$wthreadStatus_closure" {
     GHC.Conc.Sync.$wthreadStatus_closure:
         const GHC.Conc.Sync.$wthreadStatus_info;
 },
 sat_s9FEg_entry() //  [R1]
         { info_tbl: [(c9IRt,
                       label: sat_s9FEg_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IRt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IRu; else goto c9IRv;
       c9IRu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IRv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s9FEf::I64 = I64[R1 + 16];
           if (%MO_S_Ge_W64(_s9FEf::I64, 18)) goto c9IRi; else goto u9IRw;
       u9IRw: // global
           if (%MO_S_Lt_W64(_s9FEf::I64, 0)) goto c9IRi; else goto u9IRx;
       u9IRx: // global
           switch [0 .. 17] _s9FEf::I64 {
               case 0 : goto c9IRj;
               case 1 : goto c9IRq;
               case 2 : goto c9IRl;
               case 6 : goto c9IRm;
               case 10, 11 : goto c9IRo;
               case 12 : goto c9IRp;
               case 14 : goto c9IRq;
               case 16 : goto c9IRr;
               case 17 : goto c9IRs;
               default: {goto c9IRi;}
           }
       c9IRs: // global
           R1 = GHC.Conc.Sync.ThreadDied_closure+4;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9IRr: // global
           R1 = GHC.Conc.Sync.ThreadFinished_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9IRp: // global
           R1 = GHC.Conc.Sync.threadStatus2_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9IRo: // global
           R1 = GHC.Conc.Sync.threadStatus3_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9IRm: // global
           R1 = GHC.Conc.Sync.threadStatus4_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9IRl: // global
           R1 = GHC.Conc.Sync.threadStatus5_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9IRq: // global
           R1 = GHC.Conc.Sync.threadStatus6_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9IRj: // global
           R1 = GHC.Conc.Sync.ThreadRunning_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9IRi: // global
           R1 = GHC.Conc.Sync.threadStatus7_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$wthreadStatus_entry() //  [R2]
         { info_tbl: [(c9IRy,
                       label: GHC.Conc.Sync.$wthreadStatus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IRy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IRz; else goto c9IRA;
       c9IRz: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.$wthreadStatus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IRA: // global
           I64[Sp - 8] = block_c9IR8_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IR8() //  [R1]
         { info_tbl: [(c9IR8,
                       label: block_c9IR8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IR8: // global
           I64[Sp] = R1;
           Sp = Sp - 8;
           call _c9IR9() args: 0, res: 0, upd: 0;
     }
 },
 _c9IR9() //  []
         { info_tbl: [(c9IR9,
                       label: block_c9IR9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IR9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9IRD; else goto c9IRC;
       c9IRD: // global
           HpAlloc = 24;
           I64[Sp] = block_c9IR9_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c9IRC: // global
           I64[Hp - 16] = sat_s9FEg_info;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.138579592 UTC

[section ""data" . GHC.Conc.Sync.threadStatus1_closure" {
     GHC.Conc.Sync.threadStatus1_closure:
         const GHC.Conc.Sync.threadStatus1_info;
 },
 GHC.Conc.Sync.threadStatus1_entry() //  [R2]
         { info_tbl: [(c9IRN,
                       label: GHC.Conc.Sync.threadStatus1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IRN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9IRO; else goto c9IRP;
       c9IRO: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.threadStatus1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IRP: // global
           I64[Sp - 8] = block_c9IRK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9IRT; else goto c9IRL;
       u9IRT: // global
           call _c9IRK(R1) args: 0, res: 0, upd: 0;
       c9IRL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IRK() //  [R1]
         { info_tbl: [(c9IRK,
                       label: block_c9IRK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IRK: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wthreadStatus_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.139607536 UTC

[section ""data" . GHC.Conc.Sync.threadStatus_closure" {
     GHC.Conc.Sync.threadStatus_closure:
         const GHC.Conc.Sync.threadStatus_info;
 },
 GHC.Conc.Sync.threadStatus_entry() //  [R2]
         { info_tbl: [(c9IRY,
                       label: GHC.Conc.Sync.threadStatus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IRY: // global
           R2 = R2;
           call GHC.Conc.Sync.threadStatus1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.14053188 UTC

[section ""data" . GHC.Conc.Sync.$fFunctorSTM2_closure" {
     GHC.Conc.Sync.$fFunctorSTM2_closure:
         const GHC.Conc.Sync.$fFunctorSTM2_info;
 },
 GHC.Conc.Sync.$fFunctorSTM2_entry() //  [R2, R3]
         { info_tbl: [(c9IS8,
                       label: GHC.Conc.Sync.$fFunctorSTM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IS8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IS9; else goto c9ISa;
       c9IS9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fFunctorSTM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9ISa: // global
           I64[Sp - 16] = block_c9IS5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IS5() //  [R1]
         { info_tbl: [(c9IS5,
                       label: block_c9IS5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IS5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9ISd; else goto c9ISc;
       c9ISd: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9ISc: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.141794174 UTC

[section ""data" . GHC.Conc.Sync.$fFunctorSTM1_closure" {
     GHC.Conc.Sync.$fFunctorSTM1_closure:
         const GHC.Conc.Sync.$fFunctorSTM1_info;
 },
 GHC.Conc.Sync.$fFunctorSTM1_entry() //  [R2, R3]
         { info_tbl: [(c9ISk,
                       label: GHC.Conc.Sync.$fFunctorSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ISk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9ISl; else goto c9ISm;
       c9ISl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fFunctorSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9ISm: // global
           I64[Sp - 16] = block_c9ISi_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ISi() //  []
         { info_tbl: [(c9ISi,
                       label: block_c9ISi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ISi: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.142978634 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM2_closure" {
     GHC.Conc.Sync.$fApplicativeSTM2_closure:
         const GHC.Conc.Sync.$fApplicativeSTM2_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM2_entry() //  [R2, R3]
         { info_tbl: [(c9ISx,
                       label: GHC.Conc.Sync.$fApplicativeSTM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ISx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9ISy; else goto c9ISz;
       c9ISy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fApplicativeSTM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9ISz: // global
           I64[Sp - 16] = block_c9ISs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ISs() //  [R1]
         { info_tbl: [(c9ISs,
                       label: block_c9ISs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ISs: // global
           I64[Sp] = block_c9ISu_info;
           _s9FED::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FED::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ISu() //  [R1]
         { info_tbl: [(c9ISu,
                       label: block_c9ISu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ISu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9ISD; else goto c9ISC;
       c9ISD: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9ISC: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.144376942 UTC

[section ""data" . $cliftA2_r9Fva_closure" {
     $cliftA2_r9Fva_closure:
         const $cliftA2_r9Fva_info;
 },
 $cliftA2_r9Fva_entry() //  [R2, R3, R4]
         { info_tbl: [(c9ISN,
                       label: $cliftA2_r9Fva_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ISN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9ISO; else goto c9ISP;
       c9ISO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cliftA2_r9Fva_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9ISP: // global
           I64[Sp - 24] = block_c9ISI_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ISI() //  [R1]
         { info_tbl: [(c9ISI,
                       label: block_c9ISI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ISI: // global
           I64[Sp] = block_c9ISK_info;
           _s9FEO::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s9FEO::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ISK() //  [R1]
         { info_tbl: [(c9ISK,
                       label: block_c9ISK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ISK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9IST; else goto c9ISS;
       c9IST: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9ISS: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.145750848 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_closure:
         const GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(c9ISY,
                       label: GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ISY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cliftA2_r9Fva_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.146685463 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM1_closure" {
     GHC.Conc.Sync.$fApplicativeSTM1_closure:
         const GHC.Conc.Sync.$fApplicativeSTM1_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM1_entry() //  [R2, R3]
         { info_tbl: [(c9IT9,
                       label: GHC.Conc.Sync.$fApplicativeSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IT9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9ITa; else goto c9ITb;
       c9ITa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fApplicativeSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9ITb: // global
           I64[Sp - 16] = block_c9IT5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IT5() //  [R1]
         { info_tbl: [(c9IT5,
                       label: block_c9IT5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IT5: // global
           I64[Sp] = block_c9IT7_info;
           _s9FEY::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FEY::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IT7() //  []
         { info_tbl: [(c9IT7,
                       label: block_c9IT7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IT7: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.147686021 UTC

[section ""data" . GHC.Conc.Sync.$fFunctorSTM_closure" {
     GHC.Conc.Sync.$fFunctorSTM_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Conc.Sync.$fFunctorSTM2_closure+3;
         const GHC.Conc.Sync.$fFunctorSTM1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.148278465 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Conc.Sync.$fFunctorSTM_closure+1;
         const GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure+2;
         const GHC.Conc.Sync.$fApplicativeSTM2_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_closure+4;
         const GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.148970794 UTC

[section ""data" . lvl_r9Fvb_closure" {
     lvl_r9Fvb_closure:
         const lvl_r9Fvb_info;
         const 0;
 },
 lvl_r9Fvb_entry() //  [R2]
         { info_tbl: [(c9ITi,
                       label: lvl_r9Fvb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ITi: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.15000933 UTC

[section ""data" . GHC.Conc.Sync.$fMonadSTM_closure" {
     GHC.Conc.Sync.$fMonadSTM_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Conc.Sync.$fApplicativeSTM_closure+1;
         const GHC.Conc.Sync.$fMonadSTM_$c>>=_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure+2;
         const lvl_r9Fvb_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.1506438 UTC

[section ""data" . GHC.Conc.Sync.always2_closure" {
     GHC.Conc.Sync.always2_closure:
         const GHC.Conc.Sync.always2_info;
 },
 GHC.Conc.Sync.always2_entry() //  []
         { info_tbl: [(c9ITp,
                       label: GHC.Conc.Sync.always2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ITp: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.151727197 UTC

[section ""data" . GHC.Conc.Sync.alwaysSucceeds1_closure" {
     GHC.Conc.Sync.alwaysSucceeds1_closure:
         const GHC.Conc.Sync.alwaysSucceeds1_info;
 },
 sat_s9FFa_entry() //  [R1]
         { info_tbl: [(c9ITD,
                       label: sat_s9FFa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ITD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9ITE; else goto c9ITF;
       c9ITE: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9ITF: // global
           I64[Sp - 8] = block_c9ITB_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ITB() //  []
         { info_tbl: [(c9ITB,
                       label: block_c9ITB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ITB: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.alwaysSucceeds1_entry() //  [R2]
         { info_tbl: [(c9ITL,
                       label: GHC.Conc.Sync.alwaysSucceeds1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ITL: // global
           _s9FF4::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9ITM; else goto c9ITN;
       c9ITN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9ITP; else goto c9ITO;
       c9ITP: // global
           HpAlloc = 16;
           goto c9ITM;
       c9ITM: // global
           R2 = _s9FF4::P64;
           R1 = GHC.Conc.Sync.alwaysSucceeds1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9ITO: // global
           I64[Hp - 8] = sat_s9FFa_info;
           P64[Hp] = _s9FF4::P64;
           I64[Sp - 16] = block_c9ITH_info;
           R2 = GHC.Conc.Sync.always2_closure+1;
           R1 = Hp - 7;
           P64[Sp - 8] = _s9FF4::P64;
           Sp = Sp - 16;
           call stg_catchRetry#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ITH() //  []
         { info_tbl: [(c9ITH,
                       label: block_c9ITH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ITH: // global
           _s9FF4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9ITJ_info;
           R1 = _s9FF4::P64;
           Sp = Sp + 8;
           call stg_check#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ITJ() //  []
         { info_tbl: [(c9ITJ,
                       label: block_c9ITJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ITJ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.153225882 UTC

[section ""data" . GHC.Conc.Sync.alwaysSucceeds_closure" {
     GHC.Conc.Sync.alwaysSucceeds_closure:
         const GHC.Conc.Sync.alwaysSucceeds_info;
 },
 GHC.Conc.Sync.alwaysSucceeds_entry() //  [R2]
         { info_tbl: [(c9ITW,
                       label: GHC.Conc.Sync.alwaysSucceeds_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ITW: // global
           R2 = R2;
           call GHC.Conc.Sync.alwaysSucceeds1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.154036806 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM2_closure" {
     GHC.Conc.Sync.$fAlternativeSTM2_closure:
         const GHC.Conc.Sync.$fAlternativeSTM2_info;
 },
 GHC.Conc.Sync.$fAlternativeSTM2_entry() //  []
         { info_tbl: [(c9IU3,
                       label: GHC.Conc.Sync.$fAlternativeSTM2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IU3: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.155125587 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM3_closure" {
     GHC.Conc.Sync.$fAlternativeSTM3_closure:
         const GHC.Conc.Sync.$fAlternativeSTM3_info;
 },
 some_v_s9FFi_entry() //  [R1]
         { info_tbl: [(c9IUk,
                       label: some_v_s9FFi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IUk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IUl; else goto c9IUm;
       c9IUl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9IUm: // global
           I64[Sp - 16] = block_c9IUf_info;
           _s9FFi::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s9FFi::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IUf() //  [R1]
         { info_tbl: [(c9IUf,
                       label: block_c9IUf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IUf: // global
           I64[Sp] = block_c9IUh_info;
           R2 = GHC.Conc.Sync.$fAlternativeSTM2_closure+1;
           _s9FFm::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FFm::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IUh() //  [R1]
         { info_tbl: [(c9IUh,
                       label: block_c9IUh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IUh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9IUq; else goto c9IUp;
       c9IUq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9IUp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fAlternativeSTM3_entry() //  [R2]
         { info_tbl: [(c9IUr,
                       label: GHC.Conc.Sync.$fAlternativeSTM3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IUr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9IUv; else goto c9IUu;
       c9IUv: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fAlternativeSTM3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IUu: // global
           I64[Hp - 8] = some_v_s9FFi_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call some_v_s9FFi_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.157031045 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM1_closure" {
     GHC.Conc.Sync.$fAlternativeSTM1_closure:
         const GHC.Conc.Sync.$fAlternativeSTM1_info;
 },
 many_v_s9FFt_entry() //  [R1]
         { info_tbl: [(c9IUL,
                       label: many_v_s9FFt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IUL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IUM; else goto c9IUN;
       c9IUM: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9IUN: // global
           I64[Sp - 16] = block_c9IUG_info;
           _s9FFu::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s9FFu::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IUG() //  [R1]
         { info_tbl: [(c9IUG,
                       label: block_c9IUG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IUG: // global
           I64[Sp] = block_c9IUI_info;
           _s9FFy::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FFy::P64;
           call many_v1_s9FFu_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IUI() //  [R1]
         { info_tbl: [(c9IUI,
                       label: block_c9IUI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IUI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9IUR; else goto c9IUQ;
       c9IUR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9IUQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 many_v1_s9FFu_entry() //  [R1]
         { info_tbl: [(c9IUW,
                       label: many_v1_s9FFu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IUW: // global
           R2 = GHC.Conc.Sync.$fAlternativeSTM2_closure+1;
           R1 = P64[R1 + 7];
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fAlternativeSTM1_entry() //  [R2]
         { info_tbl: [(c9IUZ,
                       label: GHC.Conc.Sync.$fAlternativeSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IUZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9IV3; else goto c9IV2;
       c9IV3: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fAlternativeSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IV2: // global
           I64[Hp - 32] = many_v_s9FFt_info;
           P64[Hp - 24] = R2;
           _c9IUB::P64 = Hp - 7;
           P64[Hp - 16] = _c9IUB::P64;
           I64[Hp - 8] = many_v1_s9FFu_info;
           P64[Hp] = Hp - 31;
           R1 = _c9IUB::P64;
           call many_v1_s9FFu_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.158792995 UTC

[section ""data" . sat_s9FFE_closure" {
     sat_s9FFE_closure:
         const sat_s9FFE_info;
         const 0;
 },
 sat_s9FFE_entry() //  [R2, R3]
         { info_tbl: [(c9IV8,
                       label: sat_s9FFE_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IV8: // global
           _B3::P64 = R2;
           R2 = R3;
           R1 = _B3::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.159579321 UTC

[section ""data" . sat_s9FFD_closure" {
     sat_s9FFD_closure:
         const sat_s9FFD_info;
         const 0;
 },
 sat_s9FFD_entry() //  []
         { info_tbl: [(c9IVf,
                       label: sat_s9FFD_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IVf: // global
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.16024326 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM_closure" {
     GHC.Conc.Sync.$fAlternativeSTM_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Conc.Sync.$fApplicativeSTM_closure+1;
         const sat_s9FFD_closure+1;
         const sat_s9FFE_closure+3;
         const GHC.Conc.Sync.$fAlternativeSTM3_closure+2;
         const GHC.Conc.Sync.$fAlternativeSTM1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.160899369 UTC

[section ""data" . sat_s9FFG_closure" {
     sat_s9FFG_closure:
         const sat_s9FFG_info;
         const 0;
 },
 sat_s9FFG_entry() //  [R2, R3]
         { info_tbl: [(c9IVm,
                       label: sat_s9FFG_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IVm: // global
           _B3::P64 = R2;
           R2 = R3;
           R1 = _B3::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.161743939 UTC

[section ""data" . sat_s9FFF_closure" {
     sat_s9FFF_closure:
         const sat_s9FFF_info;
         const 0;
 },
 sat_s9FFF_entry() //  []
         { info_tbl: [(c9IVt,
                       label: sat_s9FFF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IVt: // global
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.162449094 UTC

[section ""data" . GHC.Conc.Sync.$fMonadPlusSTM_closure" {
     GHC.Conc.Sync.$fMonadPlusSTM_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Conc.Sync.$fAlternativeSTM_closure+1;
         const GHC.Conc.Sync.$fMonadSTM_closure+1;
         const sat_s9FFF_closure+1;
         const sat_s9FFG_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.163044068 UTC

[section ""cstring" . lvl1_r9Fvc_bytes" {
     lvl1_r9Fvc_bytes:
         I8[] [84,114,97,110,115,97,99,116,105,111,110,97,108,32,105,110,118,97,114,105,97,110,116,32,118,105,111,108,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.163802659 UTC

[section ""data" . GHC.Conc.Sync.always3_closure" {
     GHC.Conc.Sync.always3_closure:
         const GHC.Conc.Sync.always3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.always3_entry() //  [R1]
         { info_tbl: [(c9IVE,
                       label: GHC.Conc.Sync.always3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IVE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9IVF; else goto c9IVG;
       c9IVF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IVG: // global
           (_c9IVz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9IVz::I64 == 0) goto c9IVB; else goto c9IVA;
       c9IVB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9IVA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9IVz::I64;
           I64[Sp - 24] = block_c9IVC_info;
           R2 = lvl1_r9Fvc_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9IVC() //  [R1]
         { info_tbl: [(c9IVC,
                       label: block_c9IVC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IVC: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.16597259 UTC

[section ""data" . GHC.Conc.Sync.always1_closure" {
     GHC.Conc.Sync.always1_closure:
         const GHC.Conc.Sync.always1_info;
         const 0;
 },
 sat_s9FFQ_entry() //  [R1]
         { info_tbl: [(c9IW2,
                       label: sat_s9FFQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IW2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9IW3; else goto c9IW4;
       c9IW3: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9IW4: // global
           I64[Sp - 8] = block_c9IVT_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IVT() //  [R1]
         { info_tbl: [(c9IVT,
                       label: block_c9IVT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IVT: // global
           I64[Sp] = block_c9IVV_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u9IWc; else goto c9IVW;
       u9IWc: // global
           call _c9IVV(R1) args: 0, res: 0, upd: 0;
       c9IVW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IVV() //  [R1]
         { info_tbl: [(c9IVV,
                       label: block_c9IVV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IVV: // global
           if (R1 & 7 == 1) goto c9IVZ; else goto c9IW0;
       c9IVZ: // global
           R1 = GHC.Conc.Sync.always3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9IW0: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FG0_entry() //  [R1]
         { info_tbl: [(c9IWt,
                       label: sat_s9FG0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IWt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9IWu; else goto c9IWv;
       c9IWu: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9IWv: // global
           I64[Sp - 8] = block_c9IWk_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IWk() //  [R1]
         { info_tbl: [(c9IWk,
                       label: block_c9IWk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IWk: // global
           I64[Sp] = block_c9IWm_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u9IWD; else goto c9IWn;
       u9IWD: // global
           call _c9IWm(R1) args: 0, res: 0, upd: 0;
       c9IWn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IWm() //  [R1]
         { info_tbl: [(c9IWm,
                       label: block_c9IWm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IWm: // global
           if (R1 & 7 == 1) goto c9IWq; else goto c9IWr;
       c9IWq: // global
           R1 = GHC.Conc.Sync.always3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9IWr: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.always1_entry() //  [R2]
         { info_tbl: [(c9IWG,
                       label: GHC.Conc.Sync.always1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IWG: // global
           _s9FFI::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9IWH; else goto c9IWI;
       c9IWI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9IWK; else goto c9IWJ;
       c9IWK: // global
           HpAlloc = 16;
           goto c9IWH;
       c9IWH: // global
           R2 = _s9FFI::P64;
           R1 = GHC.Conc.Sync.always1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IWJ: // global
           I64[Hp - 8] = sat_s9FFQ_info;
           P64[Hp] = _s9FFI::P64;
           I64[Sp - 16] = block_c9IWd_info;
           R2 = GHC.Conc.Sync.always2_closure+1;
           R1 = Hp - 7;
           P64[Sp - 8] = _s9FFI::P64;
           Sp = Sp - 16;
           call stg_catchRetry#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IWd() //  [R1]
         { info_tbl: [(c9IWd,
                       label: block_c9IWd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IWd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9IWN; else goto c9IWM;
       c9IWN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9IWM: // global
           I64[Hp - 8] = sat_s9FG0_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c9IWE_info;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call stg_check#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IWE() //  []
         { info_tbl: [(c9IWE,
                       label: block_c9IWE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IWE: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.168304142 UTC

[section ""data" . GHC.Conc.Sync.always_closure" {
     GHC.Conc.Sync.always_closure:
         const GHC.Conc.Sync.always_info;
         const 0;
 },
 GHC.Conc.Sync.always_entry() //  [R2]
         { info_tbl: [(c9IWT,
                       label: GHC.Conc.Sync.always_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IWT: // global
           R2 = R2;
           call GHC.Conc.Sync.always1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.168972495 UTC

[section ""cstring" . lvl2_r9Fvd_bytes" {
     lvl2_r9Fvd_bytes:
         I8[] [110,111,32,116,104,114,101,97,100,115,32,116,111,32,114,117,110,58,32,32,105,110,102,105,110,105,116,101,32,108,111,111,112,32,111,114,32,100,101,97,100,108,111,99,107,63]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.16976634 UTC

[section ""data" . lvl3_r9Fve_closure" {
     lvl3_r9Fve_closure:
         const lvl3_r9Fve_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r9Fve_entry() //  [R1]
         { info_tbl: [(c9IX2,
                       label: lvl3_r9Fve_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IX2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IX3; else goto c9IX4;
       c9IX3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IX4: // global
           (_c9IWZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9IWZ::I64 == 0) goto c9IX1; else goto c9IX0;
       c9IX1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9IX0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9IWZ::I64;
           R2 = lvl2_r9Fvd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.171078918 UTC

[section ""data" . lvl4_r9Fvf_closure" {
     lvl4_r9Fvf_closure:
         const lvl4_r9Fvf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r9Fvf_entry() //  [R1]
         { info_tbl: [(c9IXg,
                       label: lvl4_r9Fvf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IXg: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9IXh; else goto c9IXi;
       c9IXh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IXi: // global
           (_c9IX8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9IX8::I64 == 0) goto c9IXa; else goto c9IX9;
       c9IXa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9IX9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9IX8::I64;
           I64[Sp - 24] = block_c9IXb_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionDeadlock4_closure;
           R4 = GHC.IO.Exception.$trModule_closure;
           R3 = 11186984538024031318;
           R2 = 18363794241794644491;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c9IXb() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c9IXb,
                       label: block_c9IXb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IXb: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c9IXc() args: 0, res: 0, upd: 0;
     }
 },
 _c9IXc() //  []
         { info_tbl: [(c9IXc,
                       label: block_c9IXc_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IXc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c9IXl; else goto c9IXk;
       c9IXl: // global
           HpAlloc = 48;
           I64[Sp] = block_c9IXc_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c9IXk: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.172510298 UTC

[section ""cstring" . lvl5_r9Fvg_bytes" {
     lvl5_r9Fvg_bytes:
         I8[] [37,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.173207885 UTC

[section ""data" . lvl6_r9Fvh_closure" {
     lvl6_r9Fvh_closure:
         const lvl6_r9Fvh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r9Fvh_entry() //  [R1]
         { info_tbl: [(c9IXu,
                       label: lvl6_r9Fvh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IXu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IXv; else goto c9IXw;
       c9IXv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IXw: // global
           (_c9IXr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9IXr::I64 == 0) goto c9IXt; else goto c9IXs;
       c9IXt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9IXs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9IXr::I64;
           R2 = lvl5_r9Fvg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.174380602 UTC

[section ""data" . lvl7_r9Fvi_closure" {
     lvl7_r9Fvi_closure:
         const lvl7_r9Fvi_info;
 },
 lvl7_r9Fvi_entry() //  [R2]
         { info_tbl: [(c9IXE,
                       label: lvl7_r9Fvi_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IXE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9IXF; else goto c9IXG;
       c9IXF: // global
           R2 = R2;
           R1 = lvl7_r9Fvi_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IXG: // global
           I64[Sp - 8] = block_c9IXB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9IXK; else goto c9IXC;
       u9IXK: // global
           call _c9IXB() args: 0, res: 0, upd: 0;
       c9IXC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IXB() //  []
         { info_tbl: [(c9IXB,
                       label: block_c9IXB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IXB: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.176967508 UTC

[section ""data" . lvl8_r9Fvj_closure" {
     lvl8_r9Fvj_closure:
         const lvl8_r9Fvj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_r9Fvj_entry() //  [R1]
         { info_tbl: [(c9IXR,
                       label: lvl8_r9Fvj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IXR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IXS; else goto c9IXT;
       c9IXS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IXT: // global
           (_c9IXO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9IXO::I64 == 0) goto c9IXQ; else goto c9IXP;
       c9IXQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9IXP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9IXO::I64;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           R1 = GHC.IO.Handle.hFlush_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.179273981 UTC

[section ""data" . lvl9_r9Fvk_closure" {
     lvl9_r9Fvk_closure:
         const lvl9_r9Fvk_info;
         const 0;
 },
 msg_s9FGp_entry() //  [R1]
         { info_tbl: [(c9IYf,
                       label: msg_s9FGp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IYf: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c9IYg; else goto c9IYh;
       c9IYg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IYh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9IYd_info;
           _s9FGg::P64 = P64[R1 + 16];
           R2 = _s9FGg::P64;
           P64[Sp - 32] = _s9FGg::P64;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9IYd() //  [R1]
         { info_tbl: [(c9IYd,
                       label: block_c9IYd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IYd: // global
           I64[Sp] = block_c9IYk_info;
           R3 = lvl4_r9Fvf_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9IYk() //  [R1]
         { info_tbl: [(c9IYk,
                       label: block_c9IYk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IYk: // global
           if (R1 & 7 == 1) goto c9IYs; else goto c9IYB;
       c9IYs: // global
           _s9FGg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9IYp_info;
           R2 = _s9FGg::P64;
           Sp = Sp + 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 24;
       c9IYB: // global
           _s9FGh::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9IYz_info;
           R1 = _s9FGh::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9IYp() //  [R1]
         { info_tbl: [(c9IYp,
                       label: block_c9IYp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IYp: // global
           R2 = R1;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = GHC.Conc.Sync.$fShowThreadStatus2_closure+1;
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 _c9IYz() //  []
         { info_tbl: [(c9IYz,
                       label: block_c9IYz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IYz: // global
           R1 = lvl3_r9Fve_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FGI_entry() //  [R1, R2]
         { info_tbl: [(c9IYW,
                       label: sat_s9FGI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IYW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9IZ0; else goto c9IZ1;
       c9IZ0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IZ1: // global
           I64[Sp - 16] = block_c9IYT_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9IZc; else goto c9IYU;
       u9IZc: // global
           call _c9IYT(R1) args: 0, res: 0, upd: 0;
       c9IYU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IYT() //  [R1]
         { info_tbl: [(c9IYT,
                       label: block_c9IYT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IYT: // global
           I64[Sp] = block_c9IYZ_info;
           _s9FGC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s9FGC::I64;
           if (R1 & 7 != 0) goto u9IZb; else goto c9IZ3;
       u9IZb: // global
           call _c9IYZ(R1) args: 0, res: 0, upd: 0;
       c9IZ3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IYZ() //  [R1]
         { info_tbl: [(c9IYZ,
                       label: block_c9IYZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IYZ: // global
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] errorBelch2(I64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FGJ_entry() //  [R1, R2]
         { info_tbl: [(c9IZd,
                       label: sat_s9FGJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IZd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9IZe; else goto c9IZf;
       c9IZe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IZf: // global
           I64[Sp - 24] = block_c9IYM_info;
           _s9FGp::P64 = P64[R1 + 6];
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 16] = _s9FGp::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IYM() //  [R1]
         { info_tbl: [(c9IYM,
                       label: block_c9IYM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IYM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9IZi; else goto c9IZh;
       c9IZi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9IZh: // global
           I64[Hp - 8] = sat_s9FGI_info;
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 6;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 lvl9_r9Fvk_entry() //  [R2]
         { info_tbl: [(c9IZj,
                       label: lvl9_r9Fvk_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IZj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9IZk; else goto c9IZl;
       c9IZk: // global
           R2 = R2;
           R1 = lvl9_r9Fvk_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9IZl: // global
           I64[Sp - 8] = block_c9IXY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9IZs; else goto c9IXZ;
       u9IZs: // global
           call _c9IXY(R1) args: 0, res: 0, upd: 0;
       c9IXZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IXY() //  [R1]
         { info_tbl: [(c9IXY,
                       label: block_c9IXY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IXY: // global
           I64[Sp - 16] = block_c9IY3_info;
           _s9FGg::P64 = P64[R1 + 7];
           _s9FGh::P64 = P64[R1 + 15];
           R1 = lvl8_r9Fvj_closure;
           P64[Sp - 8] = _s9FGh::P64;
           P64[Sp] = _s9FGg::P64;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IY3() //  [R1]
         { info_tbl: [(c9IY3,
                       label: block_c9IY3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IY3: // global
           I64[Sp] = block_c9IY5_info;
           R2 = lvl7_r9Fvi_closure+2;
           R1 = R1;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IY5() //  []
         { info_tbl: [(c9IY5,
                       label: block_c9IY5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IY5: // global
           I64[Sp] = block_c9IY7_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IY7() //  [R1]
         { info_tbl: [(c9IY7,
                       label: block_c9IY7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IY7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c9IZr; else goto c9IZq;
       c9IZr: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9IZq: // global
           I64[Hp - 40] = msg_s9FGp_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_s9FGJ_info;
           P64[Hp] = Hp - 40;
           R4 = Hp - 6;
           R3 = lvl6_r9Fvh_closure;
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.183288986 UTC

[section ""data" . lvl10_r9Fvl_closure" {
     lvl10_r9Fvl_closure:
         const lvl10_r9Fvl_info;
         const 0;
 },
 lvl10_r9Fvl_entry() //  []
         { info_tbl: [(c9IZC,
                       label: lvl10_r9Fvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IZC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9IZD; else goto c9IZE;
       c9IZD: // global
           R1 = lvl10_r9Fvl_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9IZE: // global
           I64[Sp - 8] = block_c9IZx_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _c9IZx() //  []
         { info_tbl: [(c9IZx,
                       label: block_c9IZx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IZx: // global
           I64[Sp] = block_c9IZz_info;
           R1 = lvl9_r9Fvk_closure+2;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9IZz() //  [R1]
         { info_tbl: [(c9IZz,
                       label: block_c9IZz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IZz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9IZI; else goto c9IZH;
       c9IZI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9IZH: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.184554341 UTC

[section ""data" . GHC.Conc.Sync.uncaughtExceptionHandler_closure" {
     GHC.Conc.Sync.uncaughtExceptionHandler_closure:
         const GHC.Conc.Sync.uncaughtExceptionHandler_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.uncaughtExceptionHandler_entry() //  [R1]
         { info_tbl: [(c9IZR,
                       label: GHC.Conc.Sync.uncaughtExceptionHandler_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IZR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9IZS; else goto c9IZT;
       c9IZS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9IZT: // global
           (_c9IZM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9IZM::I64 == 0) goto c9IZO; else goto c9IZN;
       c9IZO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9IZN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9IZM::I64;
           I64[Sp - 24] = block_c9IZP_info;
           Sp = Sp - 24;
           call lvl10_r9Fvl_entry() args: 8, res: 8, upd: 24;
     }
 },
 _c9IZP() //  [R1]
         { info_tbl: [(c9IZP,
                       label: block_c9IZP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IZP: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.185663394 UTC

[section ""data" . GHC.Conc.Sync.setUncaughtExceptionHandler1_closure" {
     GHC.Conc.Sync.setUncaughtExceptionHandler1_closure:
         const GHC.Conc.Sync.setUncaughtExceptionHandler1_info;
         const 0;
 },
 GHC.Conc.Sync.setUncaughtExceptionHandler1_entry() //  [R2]
         { info_tbl: [(c9IZZ,
                       label: GHC.Conc.Sync.setUncaughtExceptionHandler1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9IZZ: // global
           R3 = R2;
           R2 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           call GHC.STRef.writeSTRef1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.186494411 UTC

[section ""data" . GHC.Conc.Sync.setUncaughtExceptionHandler_closure" {
     GHC.Conc.Sync.setUncaughtExceptionHandler_closure:
         const GHC.Conc.Sync.setUncaughtExceptionHandler_info;
         const 0;
 },
 GHC.Conc.Sync.setUncaughtExceptionHandler_entry() //  [R2]
         { info_tbl: [(c9J06,
                       label: GHC.Conc.Sync.setUncaughtExceptionHandler_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J06: // global
           R2 = R2;
           call GHC.Conc.Sync.setUncaughtExceptionHandler1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.187248848 UTC

[section ""data" . GHC.Conc.Sync.getUncaughtExceptionHandler1_closure" {
     GHC.Conc.Sync.getUncaughtExceptionHandler1_closure:
         const GHC.Conc.Sync.getUncaughtExceptionHandler1_info;
         const 0;
 },
 GHC.Conc.Sync.getUncaughtExceptionHandler1_entry() //  []
         { info_tbl: [(c9J0d,
                       label: GHC.Conc.Sync.getUncaughtExceptionHandler1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J0d: // global
           R2 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           call GHC.STRef.readSTRef1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.188022209 UTC

[section ""data" . GHC.Conc.Sync.getUncaughtExceptionHandler_closure" {
     GHC.Conc.Sync.getUncaughtExceptionHandler_closure:
         const GHC.Conc.Sync.getUncaughtExceptionHandler_info;
         const 0;
 },
 GHC.Conc.Sync.getUncaughtExceptionHandler_entry() //  []
         { info_tbl: [(c9J0k,
                       label: GHC.Conc.Sync.getUncaughtExceptionHandler_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J0k: // global
           call GHC.Conc.Sync.getUncaughtExceptionHandler1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.188912884 UTC

[section ""data" . GHC.Conc.Sync.reportError1_closure" {
     GHC.Conc.Sync.reportError1_closure:
         const GHC.Conc.Sync.reportError1_info;
         const 0;
 },
 GHC.Conc.Sync.reportError1_entry() //  [R2]
         { info_tbl: [(c9J0u,
                       label: GHC.Conc.Sync.reportError1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J0u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9J0v; else goto c9J0w;
       c9J0v: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.reportError1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9J0w: // global
           I64[Sp - 16] = block_c9J0r_info;
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9J0A; else goto c9J0s;
       u9J0A: // global
           call _c9J0r(R1) args: 0, res: 0, upd: 0;
       c9J0s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J0r() //  [R1]
         { info_tbl: [(c9J0r,
                       label: block_c9J0r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J0r: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.190049521 UTC

[section ""data" . GHC.Conc.Sync.reportError_closure" {
     GHC.Conc.Sync.reportError_closure:
         const GHC.Conc.Sync.reportError_info;
         const 0;
 },
 GHC.Conc.Sync.reportError_entry() //  [R2]
         { info_tbl: [(c9J0F,
                       label: GHC.Conc.Sync.reportError_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J0F: // global
           R2 = R2;
           call GHC.Conc.Sync.reportError1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.191504249 UTC

[section ""data" . GHC.Conc.Sync.sharedCAF1_closure" {
     GHC.Conc.Sync.sharedCAF1_closure:
         const GHC.Conc.Sync.sharedCAF1_info;
 },
 io_s9FH6_entry() //  [R1]
         { info_tbl: [(c9J11,
                       label: io_s9FH6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J11: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J12; else goto c9J13;
       c9J12: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9J13: // global
           I64[Sp - 24] = block_c9J0T_info;
           _s9FH0::P64 = P64[R1 + 7];
           _s9FH1::P64 = P64[R1 + 15];
           R1 = _s9FH0::P64;
           P64[Sp - 16] = _s9FH0::P64;
           P64[Sp - 8] = _s9FH1::P64;
           Sp = Sp - 24;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J0T() //  [R1]
         { info_tbl: [(c9J0T,
                       label: block_c9J0T_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J0T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9J16; else goto c9J15;
       c9J16: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9J15: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = R1;
           I64[Sp] = block_c9J0W_info;
           R2 = Hp - 7;
           _s9FHa::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s9FHa::I64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J0W() //  [R1]
         { info_tbl: [(c9J0W,
                       label: block_c9J0W_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J0W: // global
           I64[Sp] = block_c9J0Y_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u9J1j; else goto c9J0Z;
       u9J1j: // global
           call _c9J0Y(R1) args: 0, res: 0, upd: 0;
       c9J0Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J0Y() //  [R1]
         { info_tbl: [(c9J0Y,
                       label: block_c9J0Y_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J0Y: // global
           _s9FHa::I64 = I64[Sp + 16];
           _s9FHg::I64 = I64[R1 + 7];
           if (_s9FHa::I64 == _s9FHg::I64) goto c9J1f; else goto c9J1e;
       c9J1f: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9J1e: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(_s9FHa::I64);
           R1 = _s9FHg::I64;
           Sp = Sp + 24;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.sharedCAF1_entry() //  [R2, R3]
         { info_tbl: [(c9J1o,
                       label: GHC.Conc.Sync.sharedCAF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J1o: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J1p; else goto c9J1q;
       c9J1p: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.sharedCAF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9J1q: // global
           I64[Sp - 24] = block_c9J0M_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c9J0M() //  [R1]
         { info_tbl: [(c9J0M,
                       label: block_c9J0M_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J0M: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9J1t; else goto c9J1s;
       c9J1t: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9J1s: // global
           I64[Hp - 16] = io_s9FH6_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _c9J0O::P64 = Hp - 15;
           if (R1 == 0) goto c9J1n; else goto c9J1m;
       c9J1n: // global
           R1 = _c9J0O::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       c9J1m: // global
           R1 = _c9J0O::P64;
           Sp = Sp + 24;
           call io_s9FH6_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.193621643 UTC

[section ""data" . GHC.Conc.Sync.sharedCAF_closure" {
     GHC.Conc.Sync.sharedCAF_closure:
         const GHC.Conc.Sync.sharedCAF_info;
 },
 GHC.Conc.Sync.sharedCAF_entry() //  [R2, R3]
         { info_tbl: [(c9J1y,
                       label: GHC.Conc.Sync.sharedCAF_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J1y: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.sharedCAF1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.196961373 UTC

[section ""data" . GHC.Conc.Sync.$wmodifyMVar__closure" {
     GHC.Conc.Sync.$wmodifyMVar__closure:
         const GHC.Conc.Sync.$wmodifyMVar__info;
 },
 sat_s9FHF_entry() //  [R1]
         { info_tbl: [(c9J22,
                       label: sat_s9FHF_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J22: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J23; else goto c9J24;
       c9J23: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9J24: // global
           I64[Sp - 24] = block_c9J20_info;
           R2 = P64[R1 + 15];
           _s9FHA::P64 = P64[R1 + 23];
           _s9FHB::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FHA::P64;
           P64[Sp - 8] = _s9FHB::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J20() //  []
         { info_tbl: [(c9J20,
                       label: block_c9J20_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J20: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHG_entry() //  [R1, R2]
         { info_tbl: [(c9J26,
                       label: sat_s9FHG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J26: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J27; else goto c9J28;
       c9J27: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9J28: // global
           I64[Sp - 24] = block_c9J1Q_info;
           _s9FHm::P64 = P64[R1 + 7];
           _s9FHv::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FHm::P64;
           P64[Sp - 8] = _s9FHv::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9J2c; else goto c9J1R;
       u9J2c: // global
           call _c9J1Q(R1) args: 0, res: 0, upd: 0;
       c9J1R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J1Q() //  [R1]
         { info_tbl: [(c9J1Q,
                       label: block_c9J1Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J1Q: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9J2b; else goto c9J2a;
       c9J2b: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9J2a: // global
           _s9FHA::P64 = P64[R1 + 7];
           _s9FHB::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FHF_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FHA::P64;
           P64[Hp] = _s9FHB::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHx_entry() //  [R1]
         { info_tbl: [(c9J2j,
                       label: sat_s9FHx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J2j: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHY_entry() //  [R1]
         { info_tbl: [(c9J2L,
                       label: sat_s9FHY_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J2L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J2M; else goto c9J2N;
       c9J2M: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9J2N: // global
           I64[Sp - 24] = block_c9J2J_info;
           R2 = P64[R1 + 15];
           _s9FHT::P64 = P64[R1 + 23];
           _s9FHU::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FHT::P64;
           P64[Sp - 8] = _s9FHU::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J2J() //  []
         { info_tbl: [(c9J2J,
                       label: block_c9J2J_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J2J: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHZ_entry() //  [R1, R2]
         { info_tbl: [(c9J2P,
                       label: sat_s9FHZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J2P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J2Q; else goto c9J2R;
       c9J2Q: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9J2R: // global
           I64[Sp - 24] = block_c9J2z_info;
           _s9FHm::P64 = P64[R1 + 7];
           _s9FHO::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FHm::P64;
           P64[Sp - 8] = _s9FHO::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9J2V; else goto c9J2A;
       u9J2V: // global
           call _c9J2z(R1) args: 0, res: 0, upd: 0;
       c9J2A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J2z() //  [R1]
         { info_tbl: [(c9J2z,
                       label: block_c9J2z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J2z: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9J2U; else goto c9J2T;
       c9J2U: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9J2T: // global
           _s9FHT::P64 = P64[R1 + 7];
           _s9FHU::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FHY_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FHT::P64;
           P64[Hp] = _s9FHU::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHQ_entry() //  [R1]
         { info_tbl: [(c9J32,
                       label: sat_s9FHQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J32: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FI4_entry() //  [R1]
         { info_tbl: [(c9J39,
                       label: sat_s9FI4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J39: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J3a; else goto c9J3b;
       c9J3a: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9J3b: // global
           I64[Sp - 24] = block_c9J2s_info;
           _s9FHm::P64 = P64[R1 + 7];
           _s9FHn::P64 = P64[R1 + 15];
           R1 = _s9FHm::P64;
           P64[Sp - 16] = _s9FHm::P64;
           P64[Sp - 8] = _s9FHn::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J2s() //  [R1]
         { info_tbl: [(c9J2s,
                       label: block_c9J2s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J2s: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9J3e; else goto c9J3d;
       c9J3e: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9J3d: // global
           I64[Hp - 64] = sat_s9FHZ_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FHQ_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9J35_info;
           R2 = Hp - 63;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J35() //  [R1]
         { info_tbl: [(c9J35,
                       label: block_c9J35_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J35: // global
           I64[Sp + 16] = block_c9J37_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J37() //  []
         { info_tbl: [(c9J37,
                       label: block_c9J37_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J37: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FIh_entry() //  [R1]
         { info_tbl: [(c9J3B,
                       label: sat_s9FIh_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J3B: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J3C; else goto c9J3D;
       c9J3C: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9J3D: // global
           I64[Sp - 24] = block_c9J3z_info;
           R2 = P64[R1 + 15];
           _s9FIc::P64 = P64[R1 + 23];
           _s9FId::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FIc::P64;
           P64[Sp - 8] = _s9FId::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J3z() //  []
         { info_tbl: [(c9J3z,
                       label: block_c9J3z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J3z: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FIi_entry() //  [R1, R2]
         { info_tbl: [(c9J3F,
                       label: sat_s9FIi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J3F: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J3G; else goto c9J3H;
       c9J3G: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9J3H: // global
           I64[Sp - 24] = block_c9J3p_info;
           _s9FHm::P64 = P64[R1 + 7];
           _s9FI7::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FHm::P64;
           P64[Sp - 8] = _s9FI7::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9J3L; else goto c9J3q;
       u9J3L: // global
           call _c9J3p(R1) args: 0, res: 0, upd: 0;
       c9J3q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J3p() //  [R1]
         { info_tbl: [(c9J3p,
                       label: block_c9J3p_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J3p: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9J3K; else goto c9J3J;
       c9J3K: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9J3J: // global
           _s9FIc::P64 = P64[R1 + 7];
           _s9FId::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FIh_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FIc::P64;
           P64[Hp] = _s9FId::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FI9_entry() //  [R1]
         { info_tbl: [(c9J3S,
                       label: sat_s9FI9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J3S: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$wmodifyMVar__entry() //  [R2, R3]
         { info_tbl: [(c9J3Z,
                       label: GHC.Conc.Sync.$wmodifyMVar__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J3Z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J40; else goto c9J41;
       c9J40: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$wmodifyMVar__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9J41: // global
           I64[Sp - 24] = block_c9J1F_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c9J1F() //  [R1]
         { info_tbl: [(c9J1F,
                       label: block_c9J1F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J1F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9J44; else goto c9J43;
       c9J44: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9J43: // global
           _s9FHm::P64 = P64[Sp + 8];
           if (R1 == 0) goto c9J3X; else goto u9J4n;
       c9J3X: // global
           I64[Hp - 16] = sat_s9FI4_info;
           P64[Hp - 8] = _s9FHm::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u9J4n: // global
           if (R1 == 1) goto c9J3Y; else goto c9J3W;
       c9J3Y: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9J3i_info;
           R1 = _s9FHm::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       c9J3W: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9J1J_info;
           R1 = _s9FHm::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J3i() //  [R1]
         { info_tbl: [(c9J3i,
                       label: block_c9J3i_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J3i: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9J4j; else goto c9J4i;
       c9J4j: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9J4i: // global
           I64[Hp - 64] = sat_s9FIi_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FI9_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9J4e_info;
           R2 = Hp - 63;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J4e() //  [R1]
         { info_tbl: [(c9J4e,
                       label: block_c9J4e_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J4e: // global
           I64[Sp + 16] = block_c9J4g_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J1J() //  [R1]
         { info_tbl: [(c9J1J,
                       label: block_c9J1J_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J1J: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9J4a; else goto c9J49;
       c9J4a: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9J49: // global
           I64[Hp - 64] = sat_s9FHG_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FHx_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9J45_info;
           R2 = Hp - 63;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J45() //  [R1]
         { info_tbl: [(c9J45,
                       label: block_c9J45_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J45: // global
           I64[Sp + 16] = block_c9J4g_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J4g() //  []
         { info_tbl: [(c9J4g,
                       label: block_c9J4g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J4g: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.20332796 UTC

[section ""data" . GHC.Conc.Sync.modifyMVar_1_closure" {
     GHC.Conc.Sync.modifyMVar_1_closure:
         const GHC.Conc.Sync.modifyMVar_1_info;
 },
 GHC.Conc.Sync.modifyMVar_1_entry() //  [R2, R3]
         { info_tbl: [(c9J4v,
                       label: GHC.Conc.Sync.modifyMVar_1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J4v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9J4w; else goto c9J4x;
       c9J4w: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.modifyMVar_1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9J4x: // global
           I64[Sp - 16] = block_c9J4s_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9J4B; else goto c9J4t;
       u9J4B: // global
           call _c9J4s(R1) args: 0, res: 0, upd: 0;
       c9J4t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J4s() //  [R1]
         { info_tbl: [(c9J4s,
                       label: block_c9J4s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J4s: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$wmodifyMVar__entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.204415861 UTC

[section ""data" . GHC.Conc.Sync.modifyMVar__closure" {
     GHC.Conc.Sync.modifyMVar__closure:
         const GHC.Conc.Sync.modifyMVar__info;
 },
 GHC.Conc.Sync.modifyMVar__entry() //  [R2, R3]
         { info_tbl: [(c9J4G,
                       label: GHC.Conc.Sync.modifyMVar__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J4G: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.modifyMVar_1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.208011409 UTC

[section ""data" . GHC.Conc.Sync.$wwithMVar_closure" {
     GHC.Conc.Sync.$wwithMVar_closure:
         const GHC.Conc.Sync.$wwithMVar_info;
 },
 sat_s9FIL_entry() //  [R1]
         { info_tbl: [(c9J5a,
                       label: sat_s9FIL_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J5a: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J5b; else goto c9J5c;
       c9J5b: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9J5c: // global
           I64[Sp - 24] = block_c9J58_info;
           R2 = P64[R1 + 15];
           _s9FIG::P64 = P64[R1 + 23];
           _s9FIH::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FIG::P64;
           P64[Sp - 8] = _s9FIH::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J58() //  []
         { info_tbl: [(c9J58,
                       label: block_c9J58_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J58: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FIM_entry() //  [R1, R2]
         { info_tbl: [(c9J5e,
                       label: sat_s9FIM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J5e: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J5f; else goto c9J5g;
       c9J5f: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9J5g: // global
           I64[Sp - 24] = block_c9J4Y_info;
           _s9FIs::P64 = P64[R1 + 7];
           _s9FIB::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FIs::P64;
           P64[Sp - 8] = _s9FIB::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9J5k; else goto c9J4Z;
       u9J5k: // global
           call _c9J4Y(R1) args: 0, res: 0, upd: 0;
       c9J4Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J4Y() //  [R1]
         { info_tbl: [(c9J4Y,
                       label: block_c9J4Y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J4Y: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9J5j; else goto c9J5i;
       c9J5j: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9J5i: // global
           _s9FIG::P64 = P64[R1 + 7];
           _s9FIH::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FIL_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FIG::P64;
           P64[Hp] = _s9FIH::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FID_entry() //  [R1]
         { info_tbl: [(c9J5r,
                       label: sat_s9FID_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J5r: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJ4_entry() //  [R1]
         { info_tbl: [(c9J5T,
                       label: sat_s9FJ4_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J5T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J5U; else goto c9J5V;
       c9J5U: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9J5V: // global
           I64[Sp - 24] = block_c9J5R_info;
           R2 = P64[R1 + 15];
           _s9FIZ::P64 = P64[R1 + 23];
           _s9FJ0::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FIZ::P64;
           P64[Sp - 8] = _s9FJ0::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J5R() //  []
         { info_tbl: [(c9J5R,
                       label: block_c9J5R_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J5R: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJ5_entry() //  [R1, R2]
         { info_tbl: [(c9J5X,
                       label: sat_s9FJ5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J5X: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J5Y; else goto c9J5Z;
       c9J5Y: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9J5Z: // global
           I64[Sp - 24] = block_c9J5H_info;
           _s9FIs::P64 = P64[R1 + 7];
           _s9FIU::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FIs::P64;
           P64[Sp - 8] = _s9FIU::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9J63; else goto c9J5I;
       u9J63: // global
           call _c9J5H(R1) args: 0, res: 0, upd: 0;
       c9J5I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J5H() //  [R1]
         { info_tbl: [(c9J5H,
                       label: block_c9J5H_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J5H: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9J62; else goto c9J61;
       c9J62: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9J61: // global
           _s9FIZ::P64 = P64[R1 + 7];
           _s9FJ0::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FJ4_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FIZ::P64;
           P64[Hp] = _s9FJ0::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FIW_entry() //  [R1]
         { info_tbl: [(c9J6a,
                       label: sat_s9FIW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J6a: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJa_entry() //  [R1]
         { info_tbl: [(c9J6h,
                       label: sat_s9FJa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J6h: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J6i; else goto c9J6j;
       c9J6i: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9J6j: // global
           I64[Sp - 24] = block_c9J5A_info;
           _s9FIs::P64 = P64[R1 + 7];
           _s9FIt::P64 = P64[R1 + 15];
           R1 = _s9FIs::P64;
           P64[Sp - 16] = _s9FIs::P64;
           P64[Sp - 8] = _s9FIt::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J5A() //  [R1]
         { info_tbl: [(c9J5A,
                       label: block_c9J5A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J5A: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9J6m; else goto c9J6l;
       c9J6m: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9J6l: // global
           I64[Hp - 64] = sat_s9FJ5_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FIW_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9J6d_info;
           R2 = Hp - 63;
           _s9FIU::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s9FIU::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J6d() //  [R1]
         { info_tbl: [(c9J6d,
                       label: block_c9J6d_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J6d: // global
           _s9FIs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9J6f_info;
           R2 = P64[Sp + 16];
           _s9FJ8::P64 = R1;
           R1 = _s9FIs::P64;
           P64[Sp + 16] = _s9FJ8::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J6f() //  []
         { info_tbl: [(c9J6f,
                       label: block_c9J6f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J6f: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJn_entry() //  [R1]
         { info_tbl: [(c9J6J,
                       label: sat_s9FJn_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J6J: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J6K; else goto c9J6L;
       c9J6K: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9J6L: // global
           I64[Sp - 24] = block_c9J6H_info;
           R2 = P64[R1 + 15];
           _s9FJi::P64 = P64[R1 + 23];
           _s9FJj::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FJi::P64;
           P64[Sp - 8] = _s9FJj::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J6H() //  []
         { info_tbl: [(c9J6H,
                       label: block_c9J6H_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J6H: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJo_entry() //  [R1, R2]
         { info_tbl: [(c9J6N,
                       label: sat_s9FJo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J6N: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J6O; else goto c9J6P;
       c9J6O: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9J6P: // global
           I64[Sp - 24] = block_c9J6x_info;
           _s9FIs::P64 = P64[R1 + 7];
           _s9FJd::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FIs::P64;
           P64[Sp - 8] = _s9FJd::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9J6T; else goto c9J6y;
       u9J6T: // global
           call _c9J6x(R1) args: 0, res: 0, upd: 0;
       c9J6y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J6x() //  [R1]
         { info_tbl: [(c9J6x,
                       label: block_c9J6x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J6x: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9J6S; else goto c9J6R;
       c9J6S: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9J6R: // global
           _s9FJi::P64 = P64[R1 + 7];
           _s9FJj::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FJn_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FJi::P64;
           P64[Hp] = _s9FJj::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJf_entry() //  [R1]
         { info_tbl: [(c9J70,
                       label: sat_s9FJf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J70: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$wwithMVar_entry() //  [R2, R3]
         { info_tbl: [(c9J77,
                       label: GHC.Conc.Sync.$wwithMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J77: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9J78; else goto c9J79;
       c9J78: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$wwithMVar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9J79: // global
           I64[Sp - 24] = block_c9J4N_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c9J4N() //  [R1]
         { info_tbl: [(c9J4N,
                       label: block_c9J4N_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J4N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9J7c; else goto c9J7b;
       c9J7c: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9J7b: // global
           _s9FIs::P64 = P64[Sp + 8];
           if (R1 == 0) goto c9J75; else goto u9J7v;
       c9J75: // global
           I64[Hp - 16] = sat_s9FJa_info;
           P64[Hp - 8] = _s9FIs::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u9J7v: // global
           if (R1 == 1) goto c9J76; else goto c9J74;
       c9J76: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9J6q_info;
           R1 = _s9FIs::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       c9J74: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9J4R_info;
           R1 = _s9FIs::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J6q() //  [R1]
         { info_tbl: [(c9J6q,
                       label: block_c9J6q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J6q: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9J7r; else goto c9J7q;
       c9J7r: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9J7q: // global
           I64[Hp - 64] = sat_s9FJo_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FJf_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9J7m_info;
           R2 = Hp - 63;
           _s9FJd::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s9FJd::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J7m() //  [R1]
         { info_tbl: [(c9J7m,
                       label: block_c9J7m_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J7m: // global
           _s9FIs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9J7o_info;
           R2 = P64[Sp + 16];
           _s9FJr::P64 = R1;
           R1 = _s9FIs::P64;
           P64[Sp + 16] = _s9FJr::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J7o() //  []
         { info_tbl: [(c9J7o,
                       label: block_c9J7o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J7o: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9J4R() //  [R1]
         { info_tbl: [(c9J4R,
                       label: block_c9J4R_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J4R: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9J7i; else goto c9J7h;
       c9J7i: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9J7h: // global
           I64[Hp - 64] = sat_s9FIM_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FID_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9J7d_info;
           R2 = Hp - 63;
           _s9FIB::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s9FIB::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J7d() //  [R1]
         { info_tbl: [(c9J7d,
                       label: block_c9J7d_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J7d: // global
           _s9FIs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9J7f_info;
           R2 = P64[Sp + 16];
           _s9FIP::P64 = R1;
           R1 = _s9FIs::P64;
           P64[Sp + 16] = _s9FIP::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J7f() //  []
         { info_tbl: [(c9J7f,
                       label: block_c9J7f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J7f: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.214682228 UTC

[section ""data" . GHC.Conc.Sync.withMVar1_closure" {
     GHC.Conc.Sync.withMVar1_closure:
         const GHC.Conc.Sync.withMVar1_info;
 },
 GHC.Conc.Sync.withMVar1_entry() //  [R2, R3]
         { info_tbl: [(c9J7D,
                       label: GHC.Conc.Sync.withMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J7D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9J7E; else goto c9J7F;
       c9J7E: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.withMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9J7F: // global
           I64[Sp - 16] = block_c9J7A_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9J7J; else goto c9J7B;
       u9J7J: // global
           call _c9J7A(R1) args: 0, res: 0, upd: 0;
       c9J7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J7A() //  [R1]
         { info_tbl: [(c9J7A,
                       label: block_c9J7A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J7A: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.215765925 UTC

[section ""data" . GHC.Conc.Sync.withMVar_closure" {
     GHC.Conc.Sync.withMVar_closure:
         const GHC.Conc.Sync.withMVar_info;
 },
 GHC.Conc.Sync.withMVar_entry() //  [R2, R3]
         { info_tbl: [(c9J7O,
                       label: GHC.Conc.Sync.withMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J7O: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.withMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.216593361 UTC

[section ""data" . GHC.Conc.Sync.reportStackOverflow1_closure" {
     GHC.Conc.Sync.reportStackOverflow1_closure:
         const GHC.Conc.Sync.reportStackOverflow1_info;
 },
 GHC.Conc.Sync.reportStackOverflow1_entry() //  []
         { info_tbl: [(c9J7X,
                       label: GHC.Conc.Sync.reportStackOverflow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J7X: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] reportStackOverflow(CurrentTSO);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.217704316 UTC

[section ""data" . GHC.Conc.Sync.reportStackOverflow_closure" {
     GHC.Conc.Sync.reportStackOverflow_closure:
         const GHC.Conc.Sync.reportStackOverflow_info;
 },
 GHC.Conc.Sync.reportStackOverflow_entry() //  []
         { info_tbl: [(c9J84,
                       label: GHC.Conc.Sync.reportStackOverflow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J84: // global
           call GHC.Conc.Sync.reportStackOverflow1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.220778272 UTC

[section ""data" . GHC.Conc.Sync.forkIO2_closure" {
     GHC.Conc.Sync.forkIO2_closure:
         const GHC.Conc.Sync.forkIO2_info;
         const 0;
 },
 GHC.Conc.Sync.forkIO2_entry() //  [R2]
         { info_tbl: [(c9J8b,
                       label: GHC.Conc.Sync.forkIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J8b: // global
           R2 = R2;
           call GHC.Conc.Sync.childHandler1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Conc.Sync.childHandler1_closure" {
     GHC.Conc.Sync.childHandler1_closure:
         const GHC.Conc.Sync.childHandler1_info;
         const 0;
 },
 sat_s9FK0_entry() //  [R1]
         { info_tbl: [(c9J96,
                       label: sat_s9FK0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J96: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9J97; else goto c9J98;
       c9J97: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9J98: // global
           I64[Sp - 16] = block_c9J93_info;
           _s9FJJ::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = _s9FJJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9J9c; else goto c9J94;
       u9J9c: // global
           call _c9J93(R1) args: 0, res: 0, upd: 0;
       c9J94: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J93() //  [R1]
         { info_tbl: [(c9J93,
                       label: block_c9J93_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J93: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKc_entry() //  [R1]
         { info_tbl: [(c9J9z,
                       label: sat_s9FKc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J9z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9J9A; else goto c9J9B;
       c9J9A: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9J9B: // global
           I64[Sp - 16] = block_c9J9w_info;
           _s9FJJ::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = _s9FJJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9J9F; else goto c9J9x;
       u9J9F: // global
           call _c9J9w(R1) args: 0, res: 0, upd: 0;
       c9J9x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J9w() //  [R1]
         { info_tbl: [(c9J9w,
                       label: block_c9J9w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J9w: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKk_entry() //  [R1]
         { info_tbl: [(c9J9U,
                       label: sat_s9FKk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J9U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9J9V; else goto c9J9W;
       c9J9V: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9J9W: // global
           I64[Sp - 16] = block_c9J9R_info;
           _s9FJJ::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = _s9FJJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Ja0; else goto c9J9S;
       u9Ja0: // global
           call _c9J9R(R1) args: 0, res: 0, upd: 0;
       c9J9S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J9R() //  [R1]
         { info_tbl: [(c9J9R,
                       label: block_c9J9R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J9R: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKv_entry() //  [R1]
         { info_tbl: [(c9Ja1,
                       label: sat_s9FKv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ja1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9Ja2; else goto c9Ja3;
       c9Ja2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Ja3: // global
           I64[Sp - 8] = block_c9J8m_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9JbP; else goto c9J8n;
       u9JbP: // global
           call _c9J8m(R1) args: 0, res: 0, upd: 0;
       c9J8n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J8m() //  [R1]
         { info_tbl: [(c9J8m,
                       label: block_c9J8m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J8m: // global
           I64[Sp - 24] = block_c9J8r_info;
           _s9FJK::P64 = P64[R1 + 7];
           R2 = _s9FJK::P64;
           P64[Sp - 16] = _s9FJK::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 24;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9J8r() //  [R1]
         { info_tbl: [(c9J8r,
                       label: block_c9J8r_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J8r: // global
           I64[Sp] = block_c9J8v_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9J8v() //  [R1]
         { info_tbl: [(c9J8v,
                       label: block_c9J8v_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J8v: // global
           if (R1 & 7 == 1) goto c9Ja8; else goto c9Jbz;
       c9Ja8: // global
           I64[Sp] = block_c9J8z_info;
           R2 = P64[Sp + 8];
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       c9Jbz: // global
           I64[Sp + 24] = block_c9Jbx_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J8z() //  [R1]
         { info_tbl: [(c9J8z,
                       label: block_c9J8z_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J8z: // global
           I64[Sp] = block_c9J8D_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9J8D() //  [R1]
         { info_tbl: [(c9J8D,
                       label: block_c9J8D_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J8D: // global
           if (R1 & 7 == 1) goto c9Jac; else goto c9Jbq;
       c9Jac: // global
           I64[Sp] = block_c9J8H_info;
           R2 = P64[Sp + 8];
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       c9Jbq: // global
           I64[Sp + 24] = block_c9Jbo_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J8H() //  [R1]
         { info_tbl: [(c9J8H,
                       label: block_c9J8H_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J8H: // global
           I64[Sp] = block_c9Jad_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jad() //  [R1]
         { info_tbl: [(c9Jad,
                       label: block_c9Jad_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jad: // global
           if (R1 & 7 == 1) goto u9JbM; else goto c9JaU;
       u9JbM: // global
           Sp = Sp + 8;
           call _s9FJQ() args: 0, res: 0, upd: 0;
       c9JaU: // global
           I64[Sp] = block_c9JaO_info;
           R1 = P64[Sp + 16];
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JaO() //  [R1]
         { info_tbl: [(c9JaO,
                       label: block_c9JaO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JaO: // global
           I64[Sp - 8] = block_c9JaS_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9JaS() //  [R1]
         { info_tbl: [(c9JaS,
                       label: block_c9JaS_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JaS: // global
           I64[Sp] = block_c9JaZ_info;
           R3 = GHC.IO.Exception.$fExceptionAsyncException9_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9JaZ() //  [R1]
         { info_tbl: [(c9JaZ,
                       label: block_c9JaZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JaZ: // global
           if (R1 & 7 == 1) goto u9JbN; else goto c9Jbb;
       u9JbN: // global
           Sp = Sp + 16;
           call _s9FJQ() args: 0, res: 0, upd: 0;
       c9Jbb: // global
           _s9FKp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9Jb9_info;
           R1 = _s9FKp::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jb9() //  [R1]
         { info_tbl: [(c9Jb9,
                       label: block_c9Jb9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jb9: // global
           if (R1 & 7 == 3) goto c9Jbl; else goto u9JbO;
       c9Jbl: // global
           R1 = GHC.Conc.Sync.always2_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9JbO: // global
           Sp = Sp + 8;
           call _s9FJQ() args: 0, res: 0, upd: 0;
     }
 },
 _s9FJQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s9FJQ: // global
           _s9FJK::P64 = P64[Sp];
           I64[Sp] = block_c9J8Q_info;
           R2 = _s9FJK::P64;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9J8Q() //  [R1]
         { info_tbl: [(c9J8Q,
                       label: block_c9J8Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J8Q: // global
           I64[Sp] = block_c9J8U_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9J8U() //  [R1]
         { info_tbl: [(c9J8U,
                       label: block_c9J8U_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J8U: // global
           if (R1 & 7 == 1) goto c9Jai; else goto c9Jan;
       c9Jai: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Jal; else goto c9Jak;
       c9Jal: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Jak: // global
           I64[Hp - 8] = sat_s9FK0_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Jan: // global
           _s9FJL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9J9f_info;
           R1 = _s9FJL::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J9f() //  [R1]
         { info_tbl: [(c9J9f,
                       label: block_c9J9f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J9f: // global
           I64[Sp - 8] = block_c9J9j_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9J9j() //  [R1]
         { info_tbl: [(c9J9j,
                       label: block_c9J9j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J9j: // global
           I64[Sp] = block_c9J9n_info;
           R3 = GHC.IO.Exception.$fExceptionAsyncException9_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9J9n() //  [R1]
         { info_tbl: [(c9J9n,
                       label: block_c9J9n_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J9n: // global
           if (R1 & 7 == 1) goto c9Jar; else goto c9Jaw;
       c9Jar: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Jau; else goto c9Jat;
       c9Jau: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Jat: // global
           I64[Hp - 8] = sat_s9FKc_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Jaw: // global
           _s9FK3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9J9I_info;
           R1 = _s9FK3::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9J9I() //  [R1]
         { info_tbl: [(c9J9I,
                       label: block_c9J9I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9J9I: // global
           if (R1 & 7 == 1) goto c9JaF; else goto c9Jay;
       c9JaF: // global
           R1 = GHC.Conc.Sync.reportStackOverflow1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Jay: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JaB; else goto c9JaA;
       c9JaB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9JaA: // global
           I64[Hp - 8] = sat_s9FKk_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Jbo() //  []
         { info_tbl: [(c9Jbo,
                       label: block_c9Jbo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jbo: // global
           R1 = GHC.Conc.Sync.always2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Jbx() //  []
         { info_tbl: [(c9Jbx,
                       label: block_c9Jbx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jbx: // global
           R1 = GHC.Conc.Sync.always2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.childHandler1_entry() //  [R2]
         { info_tbl: [(c9JbT,
                       label: GHC.Conc.Sync.childHandler1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JbT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9JbX; else goto c9JbW;
       c9JbX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Conc.Sync.childHandler1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JbW: // global
           I64[Hp - 16] = sat_s9FKv_info;
           P64[Hp] = R2;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.226690218 UTC

[section ""data" . GHC.Conc.Sync.childHandler_closure" {
     GHC.Conc.Sync.childHandler_closure:
         const GHC.Conc.Sync.childHandler_info;
         const 0;
 },
 GHC.Conc.Sync.childHandler_entry() //  [R2]
         { info_tbl: [(c9Jc2,
                       label: GHC.Conc.Sync.childHandler_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jc2: // global
           R2 = R2;
           call GHC.Conc.Sync.childHandler1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.227874279 UTC

[section ""data" . GHC.Conc.Sync.forkOn1_closure" {
     GHC.Conc.Sync.forkOn1_closure:
         const GHC.Conc.Sync.forkOn1_info;
         const 0;
 },
 sat_s9FKC_entry() //  [R1]
         { info_tbl: [(c9Jcj,
                       label: sat_s9FKC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jcj: // global
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = P64[R1 + 7];
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkOn1_entry() //  [R2, R3]
         { info_tbl: [(c9Jcm,
                       label: GHC.Conc.Sync.forkOn1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jcm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Jcq; else goto c9Jcr;
       c9Jcq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.forkOn1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Jcr: // global
           I64[Sp - 16] = block_c9Jc9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Jcy; else goto c9Jca;
       u9Jcy: // global
           call _c9Jc9(R1) args: 0, res: 0, upd: 0;
       c9Jca: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jc9() //  [R1]
         { info_tbl: [(c9Jc9,
                       label: block_c9Jc9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jc9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Jcu; else goto c9Jct;
       c9Jcu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Jct: // global
           _s9FKA::I64 = I64[R1 + 7];
           I64[Hp - 8] = sat_s9FKC_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c9Jcn_info;
           R2 = Hp - 7;
           R1 = _s9FKA::I64;
           Sp = Sp + 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jcn() //  [R1]
         { info_tbl: [(c9Jcn,
                       label: block_c9Jcn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jcn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Jcx; else goto c9Jcw;
       c9Jcx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Jcw: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.229607393 UTC

[section ""data" . GHC.Conc.Sync.forkOn_closure" {
     GHC.Conc.Sync.forkOn_closure:
         const GHC.Conc.Sync.forkOn_info;
         const 0;
 },
 GHC.Conc.Sync.forkOn_entry() //  [R2, R3]
         { info_tbl: [(c9JcD,
                       label: GHC.Conc.Sync.forkOn_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JcD: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.forkOn1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.23104211 UTC

[section ""data" . GHC.Conc.Sync.forkOnWithUnmask1_closure" {
     GHC.Conc.Sync.forkOnWithUnmask1_closure:
         const GHC.Conc.Sync.forkOnWithUnmask1_info;
         const 0;
 },
 sat_s9FKN_entry() //  [R2]
         { info_tbl: [(c9Jd3,
                       label: sat_s9FKN_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jd3: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKO_entry() //  [R1]
         { info_tbl: [(c9Jd6,
                       label: sat_s9FKO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jd6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Jda; else goto c9Jd9;
       c9Jda: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Jd9: // global
           _s9FKI::P64 = P64[R1 + 16];
           I64[Hp - 8] = sat_s9FKN_info;
           R2 = Hp - 6;
           R1 = _s9FKI::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKP_entry() //  [R1]
         { info_tbl: [(c9Jdb,
                       label: sat_s9FKP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jdb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Jdf; else goto c9Jde;
       c9Jdf: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Jde: // global
           _s9FKI::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_s9FKO_info;
           P64[Hp] = _s9FKI::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkOnWithUnmask1_entry() //  [R2, R3]
         { info_tbl: [(c9Jdg,
                       label: GHC.Conc.Sync.forkOnWithUnmask1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jdg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Jdk; else goto c9Jdl;
       c9Jdk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.forkOnWithUnmask1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Jdl: // global
           I64[Sp - 16] = block_c9JcK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Jds; else goto c9JcL;
       u9Jds: // global
           call _c9JcK(R1) args: 0, res: 0, upd: 0;
       c9JcL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JcK() //  [R1]
         { info_tbl: [(c9JcK,
                       label: block_c9JcK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JcK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Jdo; else goto c9Jdn;
       c9Jdo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Jdn: // global
           _s9FKL::I64 = I64[R1 + 7];
           I64[Hp - 8] = sat_s9FKP_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c9Jdh_info;
           R2 = Hp - 7;
           R1 = _s9FKL::I64;
           Sp = Sp + 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jdh() //  [R1]
         { info_tbl: [(c9Jdh,
                       label: block_c9Jdh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jdh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Jdr; else goto c9Jdq;
       c9Jdr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Jdq: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.233051516 UTC

[section ""data" . GHC.Conc.Sync.forkOnWithUnmask_closure" {
     GHC.Conc.Sync.forkOnWithUnmask_closure:
         const GHC.Conc.Sync.forkOnWithUnmask_info;
         const 0;
 },
 GHC.Conc.Sync.forkOnWithUnmask_entry() //  [R2, R3]
         { info_tbl: [(c9Jdx,
                       label: GHC.Conc.Sync.forkOnWithUnmask_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jdx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.forkOnWithUnmask1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.234178473 UTC

[section ""data" . GHC.Conc.Sync.forkIO1_closure" {
     GHC.Conc.Sync.forkIO1_closure:
         const GHC.Conc.Sync.forkIO1_info;
         const 0;
 },
 sat_s9FKX_entry() //  [R1]
         { info_tbl: [(c9JdJ,
                       label: sat_s9FKX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JdJ: // global
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = P64[R1 + 7];
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkIO1_entry() //  [R2]
         { info_tbl: [(c9JdP,
                       label: GHC.Conc.Sync.forkIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JdP: // global
           _s9FKU::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c9JdQ; else goto c9JdR;
       c9JdR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JdT; else goto c9JdS;
       c9JdT: // global
           HpAlloc = 16;
           goto c9JdQ;
       c9JdQ: // global
           R2 = _s9FKU::P64;
           R1 = GHC.Conc.Sync.forkIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JdS: // global
           I64[Hp - 8] = sat_s9FKX_info;
           P64[Hp] = _s9FKU::P64;
           I64[Sp - 8] = block_c9JdM_info;
           R1 = Hp - 7;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JdM() //  [R1]
         { info_tbl: [(c9JdM,
                       label: block_c9JdM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JdM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JdW; else goto c9JdV;
       c9JdW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9JdV: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.235564392 UTC

[section ""data" . GHC.Conc.Sync.forkIO_closure" {
     GHC.Conc.Sync.forkIO_closure:
         const GHC.Conc.Sync.forkIO_info;
         const 0;
 },
 GHC.Conc.Sync.forkIO_entry() //  [R2]
         { info_tbl: [(c9Je1,
                       label: GHC.Conc.Sync.forkIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Je1: // global
           R2 = R2;
           call GHC.Conc.Sync.forkIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.236893587 UTC

[section ""data" . GHC.Conc.Sync.forkIOWithUnmask1_closure" {
     GHC.Conc.Sync.forkIOWithUnmask1_closure:
         const GHC.Conc.Sync.forkIOWithUnmask1_info;
         const 0;
 },
 sat_s9FL5_entry() //  [R2]
         { info_tbl: [(c9Jem,
                       label: sat_s9FL5_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jem: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FL6_entry() //  [R1]
         { info_tbl: [(c9Jep,
                       label: sat_s9FL6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jep: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Jet; else goto c9Jes;
       c9Jet: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Jes: // global
           _s9FL2::P64 = P64[R1 + 16];
           I64[Hp - 8] = sat_s9FL5_info;
           R2 = Hp - 6;
           R1 = _s9FL2::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FL7_entry() //  [R1]
         { info_tbl: [(c9Jeu,
                       label: sat_s9FL7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jeu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Jey; else goto c9Jex;
       c9Jey: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Jex: // global
           _s9FL2::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_s9FL6_info;
           P64[Hp] = _s9FL2::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkIOWithUnmask1_entry() //  [R2]
         { info_tbl: [(c9JeC,
                       label: GHC.Conc.Sync.forkIOWithUnmask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JeC: // global
           _s9FL2::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c9JeD; else goto c9JeE;
       c9JeE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JeG; else goto c9JeF;
       c9JeG: // global
           HpAlloc = 16;
           goto c9JeD;
       c9JeD: // global
           R2 = _s9FL2::P64;
           R1 = GHC.Conc.Sync.forkIOWithUnmask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JeF: // global
           I64[Hp - 8] = sat_s9FL7_info;
           P64[Hp] = _s9FL2::P64;
           I64[Sp - 8] = block_c9Jez_info;
           R1 = Hp - 7;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jez() //  [R1]
         { info_tbl: [(c9Jez,
                       label: block_c9Jez_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jez: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JeJ; else goto c9JeI;
       c9JeJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9JeI: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.238762724 UTC

[section ""data" . GHC.Conc.Sync.forkIOWithUnmask_closure" {
     GHC.Conc.Sync.forkIOWithUnmask_closure:
         const GHC.Conc.Sync.forkIOWithUnmask_info;
         const 0;
 },
 GHC.Conc.Sync.forkIOWithUnmask_entry() //  [R2]
         { info_tbl: [(c9JeO,
                       label: GHC.Conc.Sync.forkIOWithUnmask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JeO: // global
           R2 = R2;
           call GHC.Conc.Sync.forkIOWithUnmask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.239456695 UTC

[section ""cstring" . lvl11_r9Fvm_bytes" {
     lvl11_r9Fvm_bytes:
         I8[] [115,101,116,78,117,109,67,97,112,97,98,105,108,105,116,105,101,115,58,32,67,97,112,97,98,105,108,105,116,121,32,99,111,117,110,116,32,40]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.239959988 UTC

[section ""cstring" . lvl12_r9Fvn_bytes" {
     lvl12_r9Fvn_bytes:
         I8[] [41,32,109,117,115,116,32,98,101,32,112,111,115,105,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.240673071 UTC

[section ""data" . lvl13_r9Fvo_closure" {
     lvl13_r9Fvo_closure:
         const lvl13_r9Fvo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_r9Fvo_entry() //  [R1]
         { info_tbl: [(c9JeX,
                       label: lvl13_r9Fvo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JeX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JeY; else goto c9JeZ;
       c9JeY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9JeZ: // global
           (_c9JeU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9JeU::I64 == 0) goto c9JeW; else goto c9JeV;
       c9JeW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9JeV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9JeU::I64;
           R2 = lvl12_r9Fvn_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.242065838 UTC

[section ""data" . GHC.Conc.Sync.$wlvl_closure" {
     GHC.Conc.Sync.$wlvl_closure:
         const GHC.Conc.Sync.$wlvl_info;
         const 0;
 },
 sat_s9FLi_entry() //  [R1]
         { info_tbl: [(c9Jfb,
                       label: sat_s9FLi_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jfb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Jfc; else goto c9Jfd;
       c9Jfc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Jfd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9Jf8_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9Jf8() //  [R1, R2]
         { info_tbl: [(c9Jf8,
                       label: block_c9Jf8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jf8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Jfg; else goto c9Jff;
       c9Jfg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9Jff: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl13_r9Fvo_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$wlvl_entry() //  [R2]
         { info_tbl: [(c9Jfj,
                       label: GHC.Conc.Sync.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jfj: // global
           _s9FLc::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c9Jfk; else goto c9Jfl;
       c9Jfl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Jfn; else goto c9Jfm;
       c9Jfn: // global
           HpAlloc = 24;
           goto c9Jfk;
       c9Jfk: // global
           R2 = _s9FLc::I64;
           R1 = GHC.Conc.Sync.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Jfm: // global
           I64[Hp - 16] = sat_s9FLi_info;
           I64[Hp] = _s9FLc::I64;
           I64[Sp - 8] = block_c9Jfh_info;
           R3 = Hp - 16;
           R2 = lvl11_r9Fvm_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jfh() //  [R1]
         { info_tbl: [(c9Jfh,
                       label: block_c9Jfh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jfh: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.243770737 UTC

[section ""data" . GHC.Conc.Sync.setNumCapabilities2_closure" {
     GHC.Conc.Sync.setNumCapabilities2_closure:
         const GHC.Conc.Sync.setNumCapabilities2_info;
         const 0;
 },
 GHC.Conc.Sync.setNumCapabilities2_entry() //  [R2]
         { info_tbl: [(c9Jfy,
                       label: GHC.Conc.Sync.setNumCapabilities2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jfy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Jfz; else goto c9JfA;
       c9Jfz: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.setNumCapabilities2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JfA: // global
           I64[Sp - 8] = block_c9Jfv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9JfE; else goto c9Jfw;
       u9JfE: // global
           call _c9Jfv(R1) args: 0, res: 0, upd: 0;
       c9Jfw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jfv() //  [R1]
         { info_tbl: [(c9Jfv,
                       label: block_c9Jfv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jfv: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.24521289 UTC

[section ""data" . GHC.Conc.Sync.setNumCapabilities1_closure" {
     GHC.Conc.Sync.setNumCapabilities1_closure:
         const GHC.Conc.Sync.setNumCapabilities1_info;
         const 0;
 },
 GHC.Conc.Sync.setNumCapabilities1_entry() //  [R2]
         { info_tbl: [(c9JfM,
                       label: GHC.Conc.Sync.setNumCapabilities1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JfM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9JfN; else goto c9JfO;
       c9JfN: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.setNumCapabilities1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JfO: // global
           I64[Sp - 8] = block_c9JfJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Jgj; else goto c9JfK;
       u9Jgj: // global
           call _c9JfJ(R1) args: 0, res: 0, upd: 0;
       c9JfK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JfJ() //  [R1]
         { info_tbl: [(c9JfJ,
                       label: block_c9JfJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JfJ: // global
           _s9FLr::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s9FLr::I64, 0)) goto c9JfV; else goto c9Jg8;
       c9JfV: // global
           I64[Sp] = block_c9Jg5_info;
           _u9Jgb::P64 = CurrentTSO;
           I64[I64[_u9Jgb::P64 + 24] + 16] = Sp;
           _u9Jgc::I64 = CurrentNursery;
           P64[_u9Jgc::I64 + 8] = Hp + 8;
           I64[_u9Jgb::P64 + 104] = I64[_u9Jgb::P64 + 104] - ((Hp + 8) - I64[_u9Jgc::I64]);
           (_u9Jg9::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  []  result hints:  [] setNumCapabilities(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s9FLr::I64)));
           (_u9Jga::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_u9Jg9::I64);
           BaseReg = _u9Jga::I64;
           _u9Jgd::P64 = CurrentTSO;
           _u9Jge::P64 = I64[_u9Jgd::P64 + 24];
           Sp = I64[_u9Jge::P64 + 16];
           SpLim = _u9Jge::P64 + 192;
           HpAlloc = 0;
           _u9Jgf::I64 = CurrentNursery;
           _u9Jgg::I64 = I64[_u9Jgf::I64 + 8];
           Hp = _u9Jgg::I64 - 8;
           _u9Jgh::I64 = I64[_u9Jgf::I64];
           HpLim = _u9Jgh::I64 + ((%MO_SS_Conv_W32_W64(I32[_u9Jgf::I64 + 48]) << 12) - 1);
           I64[_u9Jgd::P64 + 104] = I64[_u9Jgd::P64 + 104] + (_u9Jgg::I64 - _u9Jgh::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
       c9Jg8: // global
           R2 = _s9FLr::I64;
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c9Jg5() //  []
         { info_tbl: [(c9Jg5,
                       label: block_c9Jg5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jg5: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.247013167 UTC

[section ""data" . GHC.Conc.Sync.setNumCapabilities_closure" {
     GHC.Conc.Sync.setNumCapabilities_closure:
         const GHC.Conc.Sync.setNumCapabilities_info;
         const 0;
 },
 GHC.Conc.Sync.setNumCapabilities_entry() //  [R2]
         { info_tbl: [(c9Jgo,
                       label: GHC.Conc.Sync.setNumCapabilities_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jgo: // global
           R2 = R2;
           call GHC.Conc.Sync.setNumCapabilities1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.247859734 UTC

[section ""data" . GHC.Conc.Sync.getNumCapabilities1_closure" {
     GHC.Conc.Sync.getNumCapabilities1_closure:
         const GHC.Conc.Sync.getNumCapabilities1_info;
 },
 GHC.Conc.Sync.getNumCapabilities1_entry() //  []
         { info_tbl: [(c9Jgw,
                       label: GHC.Conc.Sync.getNumCapabilities1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jgw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JgA; else goto c9Jgz;
       c9JgA: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.getNumCapabilities1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Jgz: // global
           _s9FLB::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s9FLB::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.248788814 UTC

[section ""data" . GHC.Conc.Sync.getNumCapabilities_closure" {
     GHC.Conc.Sync.getNumCapabilities_closure:
         const GHC.Conc.Sync.getNumCapabilities_info;
 },
 GHC.Conc.Sync.getNumCapabilities_entry() //  []
         { info_tbl: [(c9JgF,
                       label: GHC.Conc.Sync.getNumCapabilities_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JgF: // global
           call GHC.Conc.Sync.getNumCapabilities1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.24970412 UTC

[section ""data" . GHC.Conc.Sync.numCapabilities1_closure" {
     GHC.Conc.Sync.numCapabilities1_closure:
         const GHC.Conc.Sync.numCapabilities1_info;
 },
 GHC.Conc.Sync.numCapabilities1_entry() //  []
         { info_tbl: [(c9JgP,
                       label: GHC.Conc.Sync.numCapabilities1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JgP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9JgQ; else goto c9JgR;
       c9JgQ: // global
           R1 = GHC.Conc.Sync.numCapabilities1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9JgR: // global
           I64[Sp - 8] = block_c9JgM_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _c9JgM() //  []
         { info_tbl: [(c9JgM,
                       label: block_c9JgM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JgM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JgU; else goto c9JgT;
       c9JgU: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c9JgT: // global
           _s9FLH::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s9FLH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.250876921 UTC

[section ""data" . GHC.Conc.Sync.numCapabilities_closure" {
     GHC.Conc.Sync.numCapabilities_closure:
         const GHC.Conc.Sync.numCapabilities_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.numCapabilities_entry() //  [R1]
         { info_tbl: [(c9Jh3,
                       label: GHC.Conc.Sync.numCapabilities_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jh3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Jh4; else goto c9Jh5;
       c9Jh4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Jh5: // global
           (_c9JgY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9JgY::I64 == 0) goto c9Jh0; else goto c9JgZ;
       c9Jh0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9JgZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9JgY::I64;
           I64[Sp - 24] = block_c9Jh1_info;
           Sp = Sp - 24;
           call GHC.Conc.Sync.numCapabilities1_entry() args: 8, res: 8, upd: 24;
     }
 },
 _c9Jh1() //  [R1]
         { info_tbl: [(c9Jh1,
                       label: block_c9Jh1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jh1: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.252021204 UTC

[section ""data" . GHC.Conc.Sync.disableAllocationLimit1_closure" {
     GHC.Conc.Sync.disableAllocationLimit1_closure:
         const GHC.Conc.Sync.disableAllocationLimit1_info;
 },
 GHC.Conc.Sync.disableAllocationLimit1_entry() //  []
         { info_tbl: [(c9Jhd,
                       label: GHC.Conc.Sync.disableAllocationLimit1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jhd: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] rts_disableThreadAllocationLimit(CurrentTSO);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.252859796 UTC

[section ""data" . GHC.Conc.Sync.disableAllocationLimit_closure" {
     GHC.Conc.Sync.disableAllocationLimit_closure:
         const GHC.Conc.Sync.disableAllocationLimit_info;
 },
 GHC.Conc.Sync.disableAllocationLimit_entry() //  []
         { info_tbl: [(c9Jhk,
                       label: GHC.Conc.Sync.disableAllocationLimit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jhk: // global
           call GHC.Conc.Sync.disableAllocationLimit1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.256262971 UTC

[section ""data" . GHC.Conc.Sync.enableAllocationLimit1_closure" {
     GHC.Conc.Sync.enableAllocationLimit1_closure:
         const GHC.Conc.Sync.enableAllocationLimit1_info;
 },
 GHC.Conc.Sync.enableAllocationLimit1_entry() //  []
         { info_tbl: [(c9Jht,
                       label: GHC.Conc.Sync.enableAllocationLimit1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jht: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] rts_enableThreadAllocationLimit(CurrentTSO);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.257118094 UTC

[section ""data" . GHC.Conc.Sync.enableAllocationLimit_closure" {
     GHC.Conc.Sync.enableAllocationLimit_closure:
         const GHC.Conc.Sync.enableAllocationLimit_info;
 },
 GHC.Conc.Sync.enableAllocationLimit_entry() //  []
         { info_tbl: [(c9JhA,
                       label: GHC.Conc.Sync.enableAllocationLimit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JhA: // global
           call GHC.Conc.Sync.enableAllocationLimit1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.258005022 UTC

[section ""data" . GHC.Conc.Sync.getAllocationCounter1_closure" {
     GHC.Conc.Sync.getAllocationCounter1_closure:
         const GHC.Conc.Sync.getAllocationCounter1_info;
 },
 GHC.Conc.Sync.getAllocationCounter1_entry() //  []
         { info_tbl: [(c9JhK,
                       label: GHC.Conc.Sync.getAllocationCounter1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JhK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JhO; else goto c9JhN;
       c9JhO: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.getAllocationCounter1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9JhN: // global
           (_s9FM7::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadAllocationCounter(CurrentTSO);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s9FM7::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.25893546 UTC

[section ""data" . GHC.Conc.Sync.getAllocationCounter_closure" {
     GHC.Conc.Sync.getAllocationCounter_closure:
         const GHC.Conc.Sync.getAllocationCounter_info;
 },
 GHC.Conc.Sync.getAllocationCounter_entry() //  []
         { info_tbl: [(c9JhT,
                       label: GHC.Conc.Sync.getAllocationCounter_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JhT: // global
           call GHC.Conc.Sync.getAllocationCounter1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.259820975 UTC

[section ""data" . GHC.Conc.Sync.setAllocationCounter1_closure" {
     GHC.Conc.Sync.setAllocationCounter1_closure:
         const GHC.Conc.Sync.setAllocationCounter1_info;
 },
 GHC.Conc.Sync.setAllocationCounter1_entry() //  [R2]
         { info_tbl: [(c9Ji3,
                       label: GHC.Conc.Sync.setAllocationCounter1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ji3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Ji4; else goto c9Ji5;
       c9Ji4: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.setAllocationCounter1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Ji5: // global
           I64[Sp - 16] = block_c9Ji0_info;
           R1 = R2;
           I64[Sp - 8] = CurrentTSO;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Jic; else goto c9Ji1;
       u9Jic: // global
           call _c9Ji0(R1) args: 0, res: 0, upd: 0;
       c9Ji1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ji0() //  [R1]
         { info_tbl: [(c9Ji0,
                       label: block_c9Ji0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ji0: // global
           call "ccall" arg hints:  [PtrHint,
                                     signed]  result hints:  [] rts_setThreadAllocationCounter(P64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.260929872 UTC

[section ""data" . GHC.Conc.Sync.setAllocationCounter_closure" {
     GHC.Conc.Sync.setAllocationCounter_closure:
         const GHC.Conc.Sync.setAllocationCounter_info;
 },
 GHC.Conc.Sync.setAllocationCounter_entry() //  [R2]
         { info_tbl: [(c9Jih,
                       label: GHC.Conc.Sync.setAllocationCounter_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jih: // global
           R2 = R2;
           call GHC.Conc.Sync.setAllocationCounter1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.262119139 UTC

[section ""data" . GHC.Conc.Sync.TVar_closure" {
     GHC.Conc.Sync.TVar_closure:
         const GHC.Conc.Sync.TVar_info;
 },
 GHC.Conc.Sync.TVar_entry() //  [R2]
         { info_tbl: [(c9Jip,
                       label: GHC.Conc.Sync.TVar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jip: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Jit; else goto c9Jis;
       c9Jit: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.TVar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Jis: // global
           I64[Hp - 8] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.262940278 UTC

[section ""data" . GHC.Conc.Sync.ThreadRunning_closure" {
     GHC.Conc.Sync.ThreadRunning_closure:
         const GHC.Conc.Sync.ThreadRunning_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.263486631 UTC

[section ""data" . GHC.Conc.Sync.ThreadFinished_closure" {
     GHC.Conc.Sync.ThreadFinished_closure:
         const GHC.Conc.Sync.ThreadFinished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.2642047 UTC

[section ""data" . GHC.Conc.Sync.ThreadBlocked_closure" {
     GHC.Conc.Sync.ThreadBlocked_closure:
         const GHC.Conc.Sync.ThreadBlocked_info;
 },
 GHC.Conc.Sync.ThreadBlocked_entry() //  [R2]
         { info_tbl: [(c9Jiz,
                       label: GHC.Conc.Sync.ThreadBlocked_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jiz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JiD; else goto c9JiC;
       c9JiD: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.ThreadBlocked_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JiC: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadBlocked_con_info;
           P64[Hp] = R2;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.264990607 UTC

[section ""data" . GHC.Conc.Sync.ThreadDied_closure" {
     GHC.Conc.Sync.ThreadDied_closure:
         const GHC.Conc.Sync.ThreadDied_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.26558572 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnMVar_closure" {
     GHC.Conc.Sync.BlockedOnMVar_closure:
         const GHC.Conc.Sync.BlockedOnMVar_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.266102472 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnBlackHole_closure" {
     GHC.Conc.Sync.BlockedOnBlackHole_closure:
         const GHC.Conc.Sync.BlockedOnBlackHole_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.266633895 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnException_closure" {
     GHC.Conc.Sync.BlockedOnException_closure:
         const GHC.Conc.Sync.BlockedOnException_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.267154399 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnSTM_closure" {
     GHC.Conc.Sync.BlockedOnSTM_closure:
         const GHC.Conc.Sync.BlockedOnSTM_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.26771205 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnForeignCall_closure" {
     GHC.Conc.Sync.BlockedOnForeignCall_closure:
         const GHC.Conc.Sync.BlockedOnForeignCall_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.268264005 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnOther_closure" {
     GHC.Conc.Sync.BlockedOnOther_closure:
         const GHC.Conc.Sync.BlockedOnOther_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.268977084 UTC

[section ""data" . GHC.Conc.Sync.ThreadId_closure" {
     GHC.Conc.Sync.ThreadId_closure:
         const GHC.Conc.Sync.ThreadId_info;
 },
 GHC.Conc.Sync.ThreadId_entry() //  [R2]
         { info_tbl: [(c9JiJ,
                       label: GHC.Conc.Sync.ThreadId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JiJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JiN; else goto c9JiM;
       c9JiN: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.ThreadId_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JiM: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.269908491 UTC

[GHC.Conc.Sync.TVar_con_entry() //  [R1]
         { info_tbl: [(c9JiO,
                       label: GHC.Conc.Sync.TVar_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JiO: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.270644238 UTC

[GHC.Conc.Sync.ThreadRunning_con_entry() //  [R1]
         { info_tbl: [(c9JiQ,
                       label: GHC.Conc.Sync.ThreadRunning_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,82,117,110,110,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JiQ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.271376019 UTC

[GHC.Conc.Sync.ThreadFinished_con_entry() //  [R1]
         { info_tbl: [(c9JiS,
                       label: GHC.Conc.Sync.ThreadFinished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,70,105,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JiS: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.272056725 UTC

[GHC.Conc.Sync.ThreadBlocked_con_entry() //  [R1]
         { info_tbl: [(c9JiU,
                       label: GHC.Conc.Sync.ThreadBlocked_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,66,108,111,99,107,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JiU: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.272739761 UTC

[GHC.Conc.Sync.ThreadDied_con_entry() //  [R1]
         { info_tbl: [(c9JiW,
                       label: GHC.Conc.Sync.ThreadDied_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,68,105,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JiW: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.273462195 UTC

[section ""relreadonly" . GHC.Conc.Sync.BlockReason_closure_tbl" {
     GHC.Conc.Sync.BlockReason_closure_tbl:
         const GHC.Conc.Sync.BlockedOnMVar_closure+1;
         const GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
         const GHC.Conc.Sync.BlockedOnException_closure+3;
         const GHC.Conc.Sync.BlockedOnSTM_closure+4;
         const GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
         const GHC.Conc.Sync.BlockedOnOther_closure+6;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.27413412 UTC

[GHC.Conc.Sync.BlockedOnMVar_con_entry() //  [R1]
         { info_tbl: [(c9JiY,
                       label: GHC.Conc.Sync.BlockedOnMVar_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,77,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JiY: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.274769892 UTC

[GHC.Conc.Sync.BlockedOnBlackHole_con_entry() //  [R1]
         { info_tbl: [(c9Jj0,
                       label: GHC.Conc.Sync.BlockedOnBlackHole_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,66,108,97,99,107,72,111,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jj0: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.275517546 UTC

[GHC.Conc.Sync.BlockedOnException_con_entry() //  [R1]
         { info_tbl: [(c9Jj2,
                       label: GHC.Conc.Sync.BlockedOnException_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,69,120,99,101,112,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jj2: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.276248593 UTC

[GHC.Conc.Sync.BlockedOnSTM_con_entry() //  [R1]
         { info_tbl: [(c9Jj4,
                       label: GHC.Conc.Sync.BlockedOnSTM_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,83,84,77]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jj4: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.276960181 UTC

[GHC.Conc.Sync.BlockedOnForeignCall_con_entry() //  [R1]
         { info_tbl: [(c9Jj6,
                       label: GHC.Conc.Sync.BlockedOnForeignCall_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,70,111,114,101,105,103,110,67,97,108,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jj6: // global
           R1 = R1 + 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.277932709 UTC

[GHC.Conc.Sync.BlockedOnOther_con_entry() //  [R1]
         { info_tbl: [(c9Jj8,
                       label: GHC.Conc.Sync.BlockedOnOther_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 5
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,79,116,104,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jj8: // global
           R1 = R1 + 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.278608728 UTC

[GHC.Conc.Sync.ThreadId_con_entry() //  [R1]
         { info_tbl: [(c9Jja,
                       label: GHC.Conc.Sync.ThreadId_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,73,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jja: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.279257376 UTC

[section ""relreadonly" . S9FOI_srt" {
     S9FOI_srt:
         const GHC.Conc.Sync.$w$cshowsPrec_closure;
         const GHC.Conc.Sync.$fShowBlockReason1_closure;
         const GHC.Conc.Sync.$fShowBlockReason3_closure;
         const GHC.Conc.Sync.$fShowBlockReason5_closure;
         const GHC.Conc.Sync.$fShowBlockReason7_closure;
         const GHC.Conc.Sync.$fShowBlockReason9_closure;
         const GHC.Conc.Sync.$fShowBlockReason11_closure;
         const GHC.Conc.Sync.$fShowBlockReason_$cshow_closure;
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const GHC.Conc.Sync.labelThread1_closure;
         const GHC.Conc.Sync.$fShowThreadStatus5_closure;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure;
         const GHC.Conc.Sync.$fShowThreadStatus3_closure;
         const GHC.Conc.Sync.$fShowThreadStatus7_closure;
         const GHC.Conc.Sync.$fShowThreadStatus9_closure;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure;
         const GHC.Conc.Sync.$fShowThreadStatus1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
         const GHC.Conc.Sync.killThread1_closure;
         const GHC.Conc.Sync.killThread2_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Conc.Sync.always3_closure;
         const GHC.Conc.Sync.always1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.hFlush_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const lvl3_r9Fve_closure;
         const lvl4_r9Fvf_closure;
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const lvl6_r9Fvh_closure;
         const lvl8_r9Fvj_closure;
         const lvl9_r9Fvk_closure;
         const lvl10_r9Fvl_closure;
         const GHC.Conc.Sync.uncaughtExceptionHandler_closure;
         const GHC.Conc.Sync.setUncaughtExceptionHandler1_closure;
         const GHC.Conc.Sync.getUncaughtExceptionHandler1_closure;
         const GHC.Conc.Sync.reportError1_closure;
         const GHC.Conc.Sync.childHandler1_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionAsyncException9_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Sync.forkOn1_closure;
         const GHC.Conc.Sync.forkOnWithUnmask1_closure;
         const GHC.Conc.Sync.forkIO1_closure;
         const GHC.Conc.Sync.forkIOWithUnmask1_closure;
         const lvl13_r9Fvo_closure;
         const GHC.IO.failIO1_closure;
         const GHC.Conc.Sync.$wlvl_closure;
         const GHC.Conc.Sync.setNumCapabilities2_closure;
         const GHC.Conc.Sync.setNumCapabilities1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.280326459 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:46.281895647 UTC

[section ""data" . GHC.Conc.Sync.$fEqTVar_$c==_closure" {
     GHC.Conc.Sync.$fEqTVar_$c==_closure:
         const GHC.Conc.Sync.$fEqTVar_$c==_info;
 },
 GHC.Conc.Sync.$fEqTVar_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9Jjj,
                       label: GHC.Conc.Sync.$fEqTVar_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jjj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Jjn; else goto c9Jjo;
       c9Jjn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqTVar_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Jjo: // global
           I64[Sp - 16] = block_c9Jjg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Jjx; else goto c9Jjh;
       u9Jjx: // global
           call _c9Jjg(R1) args: 0, res: 0, upd: 0;
       c9Jjh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jjg() //  [R1]
         { info_tbl: [(c9Jjg,
                       label: block_c9Jjg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jjg: // global
           I64[Sp] = block_c9Jjm_info;
           _s9Fvt::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9Fvt::P64;
           if (R1 & 7 != 0) goto u9Jjw; else goto c9Jjq;
       u9Jjw: // global
           call _c9Jjm(R1) args: 0, res: 0, upd: 0;
       c9Jjq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jjm() //  [R1]
         { info_tbl: [(c9Jjm,
                       label: block_c9Jjm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jjm: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.291080303 UTC

[section ""data" . GHC.Conc.Sync.$fEqTVar_$c/=_closure" {
     GHC.Conc.Sync.$fEqTVar_$c/=_closure:
         const GHC.Conc.Sync.$fEqTVar_$c/=_info;
 },
 GHC.Conc.Sync.$fEqTVar_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9JjW,
                       label: GHC.Conc.Sync.$fEqTVar_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JjW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Jk0; else goto c9Jk1;
       c9Jk0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqTVar_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Jk1: // global
           I64[Sp - 16] = block_c9JjT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Jko; else goto c9JjU;
       u9Jko: // global
           call _c9JjT(R1) args: 0, res: 0, upd: 0;
       c9JjU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JjT() //  [R1]
         { info_tbl: [(c9JjT,
                       label: block_c9JjT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JjT: // global
           I64[Sp] = block_c9JjZ_info;
           _s9FvA::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FvA::P64;
           if (R1 & 7 != 0) goto u9Jkn; else goto c9Jk3;
       u9Jkn: // global
           call _c9JjZ(R1) args: 0, res: 0, upd: 0;
       c9Jk3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JjZ() //  [R1]
         { info_tbl: [(c9JjZ,
                       label: block_c9JjZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JjZ: // global
           if (P64[Sp + 8] == P64[R1 + 7]) goto c9Jkj; else goto c9Jkd;
       c9Jkj: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Jkd: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.298420422 UTC

[section ""data" . GHC.Conc.Sync.$fEqTVar_closure" {
     GHC.Conc.Sync.$fEqTVar_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqTVar_$c==_closure+2;
         const GHC.Conc.Sync.$fEqTVar_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.300166228 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason12_bytes" {
     GHC.Conc.Sync.$fShowBlockReason12_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.302351824 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason11_closure" {
     GHC.Conc.Sync.$fShowBlockReason11_closure:
         const GHC.Conc.Sync.$fShowBlockReason11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason11_entry() //  [R1]
         { info_tbl: [(c9JkN,
                       label: GHC.Conc.Sync.$fShowBlockReason11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JkN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JkO; else goto c9JkP;
       c9JkO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9JkP: // global
           (_c9JkK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9JkK::I64 == 0) goto c9JkM; else goto c9JkL;
       c9JkM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9JkL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9JkK::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason12_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.30621169 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason10_bytes" {
     GHC.Conc.Sync.$fShowBlockReason10_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,66,108,97,99,107,72,111,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.308057172 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason9_closure" {
     GHC.Conc.Sync.$fShowBlockReason9_closure:
         const GHC.Conc.Sync.$fShowBlockReason9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason9_entry() //  [R1]
         { info_tbl: [(c9Jl4,
                       label: GHC.Conc.Sync.$fShowBlockReason9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jl4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Jl5; else goto c9Jl6;
       c9Jl5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Jl6: // global
           (_c9Jl1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Jl1::I64 == 0) goto c9Jl3; else goto c9Jl2;
       c9Jl3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Jl2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Jl1::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.311853869 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason8_bytes" {
     GHC.Conc.Sync.$fShowBlockReason8_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.313679111 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason7_closure" {
     GHC.Conc.Sync.$fShowBlockReason7_closure:
         const GHC.Conc.Sync.$fShowBlockReason7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason7_entry() //  [R1]
         { info_tbl: [(c9Jll,
                       label: GHC.Conc.Sync.$fShowBlockReason7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jll: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Jlm; else goto c9Jln;
       c9Jlm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Jln: // global
           (_c9Jli::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Jli::I64 == 0) goto c9Jlk; else goto c9Jlj;
       c9Jlk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Jlj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Jli::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.31775745 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason6_bytes" {
     GHC.Conc.Sync.$fShowBlockReason6_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.31946498 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason5_closure" {
     GHC.Conc.Sync.$fShowBlockReason5_closure:
         const GHC.Conc.Sync.$fShowBlockReason5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason5_entry() //  [R1]
         { info_tbl: [(c9JlC,
                       label: GHC.Conc.Sync.$fShowBlockReason5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JlC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JlD; else goto c9JlE;
       c9JlD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9JlE: // global
           (_c9Jlz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Jlz::I64 == 0) goto c9JlB; else goto c9JlA;
       c9JlB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9JlA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Jlz::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.323838007 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason4_bytes" {
     GHC.Conc.Sync.$fShowBlockReason4_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,70,111,114,101,105,103,110,67,97,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.32569989 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason3_closure" {
     GHC.Conc.Sync.$fShowBlockReason3_closure:
         const GHC.Conc.Sync.$fShowBlockReason3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason3_entry() //  [R1]
         { info_tbl: [(c9JlT,
                       label: GHC.Conc.Sync.$fShowBlockReason3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JlT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JlU; else goto c9JlV;
       c9JlU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9JlV: // global
           (_c9JlQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9JlQ::I64 == 0) goto c9JlS; else goto c9JlR;
       c9JlS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9JlR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9JlQ::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.329776129 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason2_bytes" {
     GHC.Conc.Sync.$fShowBlockReason2_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,79,116,104,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.33152205 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason1_closure" {
     GHC.Conc.Sync.$fShowBlockReason1_closure:
         const GHC.Conc.Sync.$fShowBlockReason1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason1_entry() //  [R1]
         { info_tbl: [(c9Jma,
                       label: GHC.Conc.Sync.$fShowBlockReason1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jma: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Jmb; else goto c9Jmc;
       c9Jmb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Jmc: // global
           (_c9Jm7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Jm7::I64 == 0) goto c9Jm9; else goto c9Jm8;
       c9Jm9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Jm8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Jm7::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.33562386 UTC

[section ""data" . GHC.Conc.Sync.$w$cshowsPrec_closure" {
     GHC.Conc.Sync.$w$cshowsPrec_closure:
         const GHC.Conc.Sync.$w$cshowsPrec_info;
         const 0;
 },
 GHC.Conc.Sync.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c9Jmz,
                       label: GHC.Conc.Sync.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jmz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JmA; else goto c9JmB;
       c9JmA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JmB: // global
           I64[Sp - 16] = block_c9Jmo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9JmU; else goto c9Jmp;
       u9JmU: // global
           call _c9Jmo(R1) args: 0, res: 0, upd: 0;
       c9Jmp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jmo() //  [R1]
         { info_tbl: [(c9Jmo,
                       label: block_c9Jmo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jmo: // global
           _s9FvF::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Jms;
               case 2 : goto c9Jmt;
               case 3 : goto c9Jmu;
               case 4 : goto c9Jmv;
               case 5 : goto c9Jmw;
               case 6 : goto c9Jmx;
           }
       c9Jmx: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9Jmw: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9Jmv: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9Jmu: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9Jmt: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason9_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9Jms: // global
           R3 = _s9FvF::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason11_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.341918842 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_closure" {
     GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_closure:
         const GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c9Jnb,
                       label: GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jnb: // global
           _s9FvI::P64 = R3;
           R3 = R4;
           R2 = _s9FvI::P64;
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.34551881 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_$cshow_closure" {
     GHC.Conc.Sync.$fShowBlockReason_$cshow_closure:
         const GHC.Conc.Sync.$fShowBlockReason_$cshow_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason_$cshow_entry() //  [R2]
         { info_tbl: [(c9Jnx,
                       label: GHC.Conc.Sync.$fShowBlockReason_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jnx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Jny; else goto c9Jnz;
       c9Jny: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowBlockReason_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Jnz: // global
           I64[Sp - 8] = block_c9Jnm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9JnS; else goto c9Jnn;
       u9JnS: // global
           call _c9Jnm(R1) args: 0, res: 0, upd: 0;
       c9Jnn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jnm() //  [R1]
         { info_tbl: [(c9Jnm,
                       label: block_c9Jnm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jnm: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Jnq;
               case 2 : goto c9Jnr;
               case 3 : goto c9Jns;
               case 4 : goto c9Jnt;
               case 5 : goto c9Jnu;
               case 6 : goto c9Jnv;
           }
       c9Jnv: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Jnu: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Jnt: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Jns: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Jnr: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Jnq: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.351913901 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_$cshowList_closure" {
     GHC.Conc.Sync.$fShowBlockReason_$cshowList_closure:
         const GHC.Conc.Sync.$fShowBlockReason_$cshowList_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c9Jof,
                       label: GHC.Conc.Sync.$fShowBlockReason_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jof: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.355689552 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_closure" {
     GHC.Conc.Sync.$fShowBlockReason_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_closure+3;
         const GHC.Conc.Sync.$fShowBlockReason_$cshow_closure+1;
         const GHC.Conc.Sync.$fShowBlockReason_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.358489775 UTC

[section ""data" . GHC.Conc.Sync.$fEqBlockReason_$c==_closure" {
     GHC.Conc.Sync.$fEqBlockReason_$c==_closure:
         const GHC.Conc.Sync.$fEqBlockReason_$c==_info;
 },
 GHC.Conc.Sync.$fEqBlockReason_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9JoC,
                       label: GHC.Conc.Sync.$fEqBlockReason_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JoC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JoD; else goto c9JoE;
       c9JoD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqBlockReason_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JoE: // global
           I64[Sp - 16] = block_c9Jor_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Jqv; else goto c9Jos;
       u9Jqv: // global
           call _c9Jor(R1) args: 0, res: 0, upd: 0;
       c9Jos: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jor() //  [R1]
         { info_tbl: [(c9Jor,
                       label: block_c9Jor_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jor: // global
           _s9FvP::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Jov;
               case 2 : goto c9Jow;
               case 3 : goto c9Jox;
               case 4 : goto c9Joy;
               case 5 : goto c9Joz;
               case 6 : goto c9JoA;
           }
       c9JoA: // global
           I64[Sp + 8] = block_c9JpU_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Jqu; else goto c9JpW;
       u9Jqu: // global
           call _c9JpU(R1) args: 0, res: 0, upd: 0;
       c9JpW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Joz: // global
           I64[Sp + 8] = block_c9JpF_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Jqt; else goto c9JpH;
       u9Jqt: // global
           call _c9JpF(R1) args: 0, res: 0, upd: 0;
       c9JpH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Joy: // global
           I64[Sp + 8] = block_c9Jpq_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Jqs; else goto c9Jps;
       u9Jqs: // global
           call _c9Jpq(R1) args: 0, res: 0, upd: 0;
       c9Jps: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Jox: // global
           I64[Sp + 8] = block_c9Jpb_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Jqr; else goto c9Jpd;
       u9Jqr: // global
           call _c9Jpb(R1) args: 0, res: 0, upd: 0;
       c9Jpd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Jow: // global
           I64[Sp + 8] = block_c9JoW_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Jqq; else goto c9JoY;
       u9Jqq: // global
           call _c9JoW(R1) args: 0, res: 0, upd: 0;
       c9JoY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Jov: // global
           I64[Sp + 8] = block_c9JoH_info;
           R1 = _s9FvP::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Jqp; else goto c9JoJ;
       u9Jqp: // global
           call _c9JoH(R1) args: 0, res: 0, upd: 0;
       c9JoJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JpU() //  [R1]
         { info_tbl: [(c9JpU,
                       label: block_c9JpU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JpU: // global
           if (R1 & 7 == 6) goto u9Jqd; else goto u9Jqe;
       u9Jqd: // global
           Sp = Sp + 8;
           call _c9Jq6() args: 0, res: 0, upd: 0;
       u9Jqe: // global
           Sp = Sp + 8;
           call _c9Jq2() args: 0, res: 0, upd: 0;
     }
 },
 _c9JpF() //  [R1]
         { info_tbl: [(c9JpF,
                       label: block_c9JpF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JpF: // global
           if (R1 & 7 == 5) goto u9Jqf; else goto u9Jqg;
       u9Jqf: // global
           Sp = Sp + 8;
           call _c9Jq6() args: 0, res: 0, upd: 0;
       u9Jqg: // global
           Sp = Sp + 8;
           call _c9Jq2() args: 0, res: 0, upd: 0;
     }
 },
 _c9Jpq() //  [R1]
         { info_tbl: [(c9Jpq,
                       label: block_c9Jpq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jpq: // global
           if (R1 & 7 == 4) goto u9Jqh; else goto u9Jqi;
       u9Jqh: // global
           Sp = Sp + 8;
           call _c9Jq6() args: 0, res: 0, upd: 0;
       u9Jqi: // global
           Sp = Sp + 8;
           call _c9Jq2() args: 0, res: 0, upd: 0;
     }
 },
 _c9Jpb() //  [R1]
         { info_tbl: [(c9Jpb,
                       label: block_c9Jpb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jpb: // global
           if (R1 & 7 == 3) goto u9Jqj; else goto u9Jqk;
       u9Jqj: // global
           Sp = Sp + 8;
           call _c9Jq6() args: 0, res: 0, upd: 0;
       u9Jqk: // global
           Sp = Sp + 8;
           call _c9Jq2() args: 0, res: 0, upd: 0;
     }
 },
 _c9JoW() //  [R1]
         { info_tbl: [(c9JoW,
                       label: block_c9JoW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JoW: // global
           if (R1 & 7 == 2) goto u9Jql; else goto u9Jqm;
       u9Jql: // global
           Sp = Sp + 8;
           call _c9Jq6() args: 0, res: 0, upd: 0;
       u9Jqm: // global
           Sp = Sp + 8;
           call _c9Jq2() args: 0, res: 0, upd: 0;
     }
 },
 _c9JoH() //  [R1]
         { info_tbl: [(c9JoH,
                       label: block_c9JoH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JoH: // global
           if (R1 & 7 == 1) goto u9Jqn; else goto u9Jqo;
       u9Jqn: // global
           Sp = Sp + 8;
           call _c9Jq6() args: 0, res: 0, upd: 0;
       u9Jqo: // global
           Sp = Sp + 8;
           call _c9Jq2() args: 0, res: 0, upd: 0;
     }
 },
 _c9Jq6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jq6: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Jq2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jq2: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.377153799 UTC

[section ""data" . GHC.Conc.Sync.$fEqBlockReason_$c/=_closure" {
     GHC.Conc.Sync.$fEqBlockReason_$c/=_closure:
         const GHC.Conc.Sync.$fEqBlockReason_$c/=_info;
 },
 GHC.Conc.Sync.$fEqBlockReason_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9JrP,
                       label: GHC.Conc.Sync.$fEqBlockReason_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JrP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JrQ; else goto c9JrR;
       c9JrQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqBlockReason_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JrR: // global
           I64[Sp - 16] = block_c9JrE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9JtI; else goto c9JrF;
       u9JtI: // global
           call _c9JrE(R1) args: 0, res: 0, upd: 0;
       c9JrF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JrE() //  [R1]
         { info_tbl: [(c9JrE,
                       label: block_c9JrE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JrE: // global
           _s9FvY::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9JrI;
               case 2 : goto c9JrJ;
               case 3 : goto c9JrK;
               case 4 : goto c9JrL;
               case 5 : goto c9JrM;
               case 6 : goto c9JrN;
           }
       c9JrN: // global
           I64[Sp + 8] = block_c9Jt7_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JtH; else goto c9Jt9;
       u9JtH: // global
           call _c9Jt7(R1) args: 0, res: 0, upd: 0;
       c9Jt9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JrM: // global
           I64[Sp + 8] = block_c9JsS_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JtG; else goto c9JsU;
       u9JtG: // global
           call _c9JsS(R1) args: 0, res: 0, upd: 0;
       c9JsU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JrL: // global
           I64[Sp + 8] = block_c9JsD_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JtF; else goto c9JsF;
       u9JtF: // global
           call _c9JsD(R1) args: 0, res: 0, upd: 0;
       c9JsF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JrK: // global
           I64[Sp + 8] = block_c9Jso_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JtE; else goto c9Jsq;
       u9JtE: // global
           call _c9Jso(R1) args: 0, res: 0, upd: 0;
       c9Jsq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JrJ: // global
           I64[Sp + 8] = block_c9Js9_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JtD; else goto c9Jsb;
       u9JtD: // global
           call _c9Js9(R1) args: 0, res: 0, upd: 0;
       c9Jsb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JrI: // global
           I64[Sp + 8] = block_c9JrU_info;
           R1 = _s9FvY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JtC; else goto c9JrW;
       u9JtC: // global
           call _c9JrU(R1) args: 0, res: 0, upd: 0;
       c9JrW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jt7() //  [R1]
         { info_tbl: [(c9Jt7,
                       label: block_c9Jt7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jt7: // global
           if (R1 & 7 == 6) goto u9Jtq; else goto u9Jtr;
       u9Jtq: // global
           Sp = Sp + 8;
           call _c9Jtj() args: 0, res: 0, upd: 0;
       u9Jtr: // global
           Sp = Sp + 8;
           call _c9Jtf() args: 0, res: 0, upd: 0;
     }
 },
 _c9JsS() //  [R1]
         { info_tbl: [(c9JsS,
                       label: block_c9JsS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JsS: // global
           if (R1 & 7 == 5) goto u9Jts; else goto u9Jtt;
       u9Jts: // global
           Sp = Sp + 8;
           call _c9Jtj() args: 0, res: 0, upd: 0;
       u9Jtt: // global
           Sp = Sp + 8;
           call _c9Jtf() args: 0, res: 0, upd: 0;
     }
 },
 _c9JsD() //  [R1]
         { info_tbl: [(c9JsD,
                       label: block_c9JsD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JsD: // global
           if (R1 & 7 == 4) goto u9Jtu; else goto u9Jtv;
       u9Jtu: // global
           Sp = Sp + 8;
           call _c9Jtj() args: 0, res: 0, upd: 0;
       u9Jtv: // global
           Sp = Sp + 8;
           call _c9Jtf() args: 0, res: 0, upd: 0;
     }
 },
 _c9Jso() //  [R1]
         { info_tbl: [(c9Jso,
                       label: block_c9Jso_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jso: // global
           if (R1 & 7 == 3) goto u9Jtw; else goto u9Jtx;
       u9Jtw: // global
           Sp = Sp + 8;
           call _c9Jtj() args: 0, res: 0, upd: 0;
       u9Jtx: // global
           Sp = Sp + 8;
           call _c9Jtf() args: 0, res: 0, upd: 0;
     }
 },
 _c9Js9() //  [R1]
         { info_tbl: [(c9Js9,
                       label: block_c9Js9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Js9: // global
           if (R1 & 7 == 2) goto u9Jty; else goto u9Jtz;
       u9Jty: // global
           Sp = Sp + 8;
           call _c9Jtj() args: 0, res: 0, upd: 0;
       u9Jtz: // global
           Sp = Sp + 8;
           call _c9Jtf() args: 0, res: 0, upd: 0;
     }
 },
 _c9JrU() //  [R1]
         { info_tbl: [(c9JrU,
                       label: block_c9JrU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JrU: // global
           if (R1 & 7 == 1) goto u9JtA; else goto u9JtB;
       u9JtA: // global
           Sp = Sp + 8;
           call _c9Jtj() args: 0, res: 0, upd: 0;
       u9JtB: // global
           Sp = Sp + 8;
           call _c9Jtf() args: 0, res: 0, upd: 0;
     }
 },
 _c9Jtj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jtj: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Jtf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jtf: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.396092533 UTC

[section ""data" . GHC.Conc.Sync.$fEqBlockReason_closure" {
     GHC.Conc.Sync.$fEqBlockReason_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqBlockReason_$c==_closure+2;
         const GHC.Conc.Sync.$fEqBlockReason_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.399034437 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadStatus_$c==_closure" {
     GHC.Conc.Sync.$fEqThreadStatus_$c==_closure:
         const GHC.Conc.Sync.$fEqThreadStatus_$c==_info;
 },
 GHC.Conc.Sync.$fEqThreadStatus_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9Jv1,
                       label: GHC.Conc.Sync.$fEqThreadStatus_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jv1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Jv2; else goto c9Jv3;
       c9Jv2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadStatus_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Jv3: // global
           I64[Sp - 16] = block_c9JuS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Jwj; else goto c9JuT;
       u9Jwj: // global
           call _c9JuS(R1) args: 0, res: 0, upd: 0;
       c9JuT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JuS() //  [R1]
         { info_tbl: [(c9JuS,
                       label: block_c9JuS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JuS: // global
           _s9Fw7::P64 = P64[Sp + 8];
           _c9Jv0::P64 = R1 & 7;
           if (_c9Jv0::P64 < 3) goto u9Jw6; else goto u9Jw7;
       u9Jw6: // global
           if (_c9Jv0::P64 < 2) goto c9JuW; else goto c9JuX;
       c9JuW: // global
           I64[Sp + 8] = block_c9Jv6_info;
           R1 = _s9Fw7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Jwf; else goto c9Jv8;
       u9Jwf: // global
           call _c9Jv6(R1) args: 0, res: 0, upd: 0;
       c9Jv8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JuX: // global
           I64[Sp + 8] = block_c9Jvl_info;
           R1 = _s9Fw7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Jwg; else goto c9Jvn;
       u9Jwg: // global
           call _c9Jvl(R1) args: 0, res: 0, upd: 0;
       c9Jvn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Jw7: // global
           if (_c9Jv0::P64 < 4) goto c9JuY; else goto c9JuZ;
       c9JuY: // global
           I64[Sp] = block_c9JvA_info;
           _s9Fwb::P64 = P64[R1 + 5];
           R1 = _s9Fw7::P64;
           P64[Sp + 8] = _s9Fwb::P64;
           if (R1 & 7 != 0) goto u9Jwh; else goto c9JvC;
       u9Jwh: // global
           call _c9JvA(R1) args: 0, res: 0, upd: 0;
       c9JvC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JuZ: // global
           I64[Sp + 8] = block_c9JvP_info;
           R1 = _s9Fw7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Jwi; else goto c9JvR;
       u9Jwi: // global
           call _c9JvP(R1) args: 0, res: 0, upd: 0;
       c9JvR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jv6() //  [R1]
         { info_tbl: [(c9Jv6,
                       label: block_c9Jv6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jv6: // global
           if (R1 & 7 == 1) goto u9Jw8; else goto u9Jw9;
       u9Jw8: // global
           Sp = Sp + 8;
           call _c9Jw1() args: 0, res: 0, upd: 0;
       u9Jw9: // global
           Sp = Sp + 8;
           call _c9JvX() args: 0, res: 0, upd: 0;
     }
 },
 _c9Jvl() //  [R1]
         { info_tbl: [(c9Jvl,
                       label: block_c9Jvl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jvl: // global
           if (R1 & 7 == 2) goto u9Jwa; else goto u9Jwb;
       u9Jwa: // global
           Sp = Sp + 8;
           call _c9Jw1() args: 0, res: 0, upd: 0;
       u9Jwb: // global
           Sp = Sp + 8;
           call _c9JvX() args: 0, res: 0, upd: 0;
     }
 },
 _c9JvA() //  [R1]
         { info_tbl: [(c9JvA,
                       label: block_c9JvA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JvA: // global
           if (R1 & 7 == 3) goto c9JvM; else goto u9Jwc;
       c9JvM: // global
           R3 = P64[R1 + 5];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$fEqBlockReason_$c==_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
       u9Jwc: // global
           Sp = Sp + 16;
           call _c9JvX() args: 0, res: 0, upd: 0;
     }
 },
 _c9JvP() //  [R1]
         { info_tbl: [(c9JvP,
                       label: block_c9JvP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JvP: // global
           if (R1 & 7 == 4) goto u9Jwd; else goto u9Jwe;
       u9Jwd: // global
           Sp = Sp + 8;
           call _c9Jw1() args: 0, res: 0, upd: 0;
       u9Jwe: // global
           Sp = Sp + 8;
           call _c9JvX() args: 0, res: 0, upd: 0;
     }
 },
 _c9Jw1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jw1: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9JvX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JvX: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.415275356 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure" {
     GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure:
         const GHC.Conc.Sync.$fEqThreadStatus_$c/=_info;
 },
 GHC.Conc.Sync.$fEqThreadStatus_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9Jxi,
                       label: GHC.Conc.Sync.$fEqThreadStatus_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jxi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Jxj; else goto c9Jxk;
       c9Jxj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Jxk: // global
           I64[Sp - 16] = block_c9Jx9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9JAv; else goto c9Jxa;
       u9JAv: // global
           call _c9Jx9(R1) args: 0, res: 0, upd: 0;
       c9Jxa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jx9() //  [R1]
         { info_tbl: [(c9Jx9,
                       label: block_c9Jx9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jx9: // global
           _s9Fwg::P64 = P64[Sp + 8];
           _c9Jxh::P64 = R1 & 7;
           if (_c9Jxh::P64 < 3) goto u9JA6; else goto u9JA7;
       u9JA6: // global
           if (_c9Jxh::P64 < 2) goto c9Jxd; else goto c9Jxe;
       c9Jxd: // global
           I64[Sp + 8] = block_c9Jxn_info;
           R1 = _s9Fwg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JAr; else goto c9Jxp;
       u9JAr: // global
           call _c9Jxn(R1) args: 0, res: 0, upd: 0;
       c9Jxp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Jxe: // global
           I64[Sp + 8] = block_c9JxC_info;
           R1 = _s9Fwg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JAs; else goto c9JxE;
       u9JAs: // global
           call _c9JxC(R1) args: 0, res: 0, upd: 0;
       c9JxE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9JA7: // global
           if (_c9Jxh::P64 < 4) goto c9Jxf; else goto c9Jxg;
       c9Jxf: // global
           I64[Sp] = block_c9JxR_info;
           _s9Fwk::P64 = P64[R1 + 5];
           R1 = _s9Fwg::P64;
           P64[Sp + 8] = _s9Fwk::P64;
           if (R1 & 7 != 0) goto u9JAt; else goto c9JxT;
       u9JAt: // global
           call _c9JxR(R1) args: 0, res: 0, upd: 0;
       c9JxT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Jxg: // global
           I64[Sp + 8] = block_c9JzI_info;
           R1 = _s9Fwg::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JAu; else goto c9JzK;
       u9JAu: // global
           call _c9JzI(R1) args: 0, res: 0, upd: 0;
       c9JzK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jxn() //  [R1]
         { info_tbl: [(c9Jxn,
                       label: block_c9Jxn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jxn: // global
           if (R1 & 7 == 1) goto u9JA8; else goto u9JA9;
       u9JA8: // global
           Sp = Sp + 8;
           call _c9JzU() args: 0, res: 0, upd: 0;
       u9JA9: // global
           Sp = Sp + 8;
           call _c9JzQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9JxC() //  [R1]
         { info_tbl: [(c9JxC,
                       label: block_c9JxC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JxC: // global
           if (R1 & 7 == 2) goto u9JAa; else goto u9JAb;
       u9JAa: // global
           Sp = Sp + 8;
           call _c9JzU() args: 0, res: 0, upd: 0;
       u9JAb: // global
           Sp = Sp + 8;
           call _c9JzQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9JxR() //  [R1]
         { info_tbl: [(c9JxR,
                       label: block_c9JxR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JxR: // global
           if (R1 & 7 == 3) goto c9Jy4; else goto u9JAc;
       c9Jy4: // global
           I64[Sp] = block_c9Jy2_info;
           _s9Fwm::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9Fwm::P64;
           if (R1 & 7 != 0) goto u9JAA; else goto c9Jy5;
       u9JAA: // global
           call _c9Jy2(R1) args: 0, res: 0, upd: 0;
       c9Jy5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9JAc: // global
           Sp = Sp + 16;
           call _c9JzQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9Jy2() //  [R1]
         { info_tbl: [(c9Jy2,
                       label: block_c9Jy2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jy2: // global
           _s9Fwm::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Jyc;
               case 2 : goto c9Jys;
               case 3 : goto c9JyI;
               case 4 : goto c9JyY;
               case 5 : goto c9Jze;
               case 6 : goto c9Jzu;
           }
       c9Jzu: // global
           I64[Sp + 8] = block_c9Jzs_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JAH; else goto c9Jzv;
       u9JAH: // global
           call _c9Jzs(R1) args: 0, res: 0, upd: 0;
       c9Jzv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Jze: // global
           I64[Sp + 8] = block_c9Jzc_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JAG; else goto c9Jzf;
       u9JAG: // global
           call _c9Jzc(R1) args: 0, res: 0, upd: 0;
       c9Jzf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JyY: // global
           I64[Sp + 8] = block_c9JyW_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JAF; else goto c9JyZ;
       u9JAF: // global
           call _c9JyW(R1) args: 0, res: 0, upd: 0;
       c9JyZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JyI: // global
           I64[Sp + 8] = block_c9JyG_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JAE; else goto c9JyJ;
       u9JAE: // global
           call _c9JyG(R1) args: 0, res: 0, upd: 0;
       c9JyJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Jys: // global
           I64[Sp + 8] = block_c9Jyq_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JAD; else goto c9Jyt;
       u9JAD: // global
           call _c9Jyq(R1) args: 0, res: 0, upd: 0;
       c9Jyt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Jyc: // global
           I64[Sp + 8] = block_c9Jy9_info;
           R1 = _s9Fwm::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JAC; else goto c9Jyd;
       u9JAC: // global
           call _c9Jy9(R1) args: 0, res: 0, upd: 0;
       c9Jyd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Jzs() //  [R1]
         { info_tbl: [(c9Jzs,
                       label: block_c9Jzs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jzs: // global
           if (R1 & 7 == 6) goto u9JAd; else goto u9JAe;
       u9JAd: // global
           Sp = Sp + 8;
           call _c9JzU() args: 0, res: 0, upd: 0;
       u9JAe: // global
           Sp = Sp + 8;
           call _c9JzQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9Jzc() //  [R1]
         { info_tbl: [(c9Jzc,
                       label: block_c9Jzc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jzc: // global
           if (R1 & 7 == 5) goto u9JAf; else goto u9JAg;
       u9JAf: // global
           Sp = Sp + 8;
           call _c9JzU() args: 0, res: 0, upd: 0;
       u9JAg: // global
           Sp = Sp + 8;
           call _c9JzQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9JyW() //  [R1]
         { info_tbl: [(c9JyW,
                       label: block_c9JyW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JyW: // global
           if (R1 & 7 == 4) goto u9JAh; else goto u9JAi;
       u9JAh: // global
           Sp = Sp + 8;
           call _c9JzU() args: 0, res: 0, upd: 0;
       u9JAi: // global
           Sp = Sp + 8;
           call _c9JzQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9JyG() //  [R1]
         { info_tbl: [(c9JyG,
                       label: block_c9JyG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JyG: // global
           if (R1 & 7 == 3) goto u9JAj; else goto u9JAk;
       u9JAj: // global
           Sp = Sp + 8;
           call _c9JzU() args: 0, res: 0, upd: 0;
       u9JAk: // global
           Sp = Sp + 8;
           call _c9JzQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9Jyq() //  [R1]
         { info_tbl: [(c9Jyq,
                       label: block_c9Jyq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jyq: // global
           if (R1 & 7 == 2) goto u9JAl; else goto u9JAm;
       u9JAl: // global
           Sp = Sp + 8;
           call _c9JzU() args: 0, res: 0, upd: 0;
       u9JAm: // global
           Sp = Sp + 8;
           call _c9JzQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9Jy9() //  [R1]
         { info_tbl: [(c9Jy9,
                       label: block_c9Jy9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Jy9: // global
           if (R1 & 7 == 1) goto u9JAn; else goto u9JAo;
       u9JAn: // global
           Sp = Sp + 8;
           call _c9JzU() args: 0, res: 0, upd: 0;
       u9JAo: // global
           Sp = Sp + 8;
           call _c9JzQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9JzI() //  [R1]
         { info_tbl: [(c9JzI,
                       label: block_c9JzI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JzI: // global
           if (R1 & 7 == 4) goto u9JAp; else goto u9JAq;
       u9JAp: // global
           Sp = Sp + 8;
           call _c9JzU() args: 0, res: 0, upd: 0;
       u9JAq: // global
           Sp = Sp + 8;
           call _c9JzQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9JzU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JzU: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9JzQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JzQ: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.443169077 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadStatus_closure" {
     GHC.Conc.Sync.$fEqThreadStatus_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqThreadStatus_$c==_closure+2;
         const GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.445229535 UTC

[section ""data" . GHC.Conc.Sync.numSparks1_closure" {
     GHC.Conc.Sync.numSparks1_closure:
         const GHC.Conc.Sync.numSparks1_info;
 },
 GHC.Conc.Sync.numSparks1_entry() //  []
         { info_tbl: [(c9JCp,
                       label: GHC.Conc.Sync.numSparks1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JCp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9JCq; else goto c9JCr;
       c9JCq: // global
           R1 = GHC.Conc.Sync.numSparks1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9JCr: // global
           I64[Sp - 8] = block_c9JCm_info;
           Sp = Sp - 8;
           call stg_numSparks#() args: 8, res: 8, upd: 8;
     }
 },
 _c9JCm() //  [R1]
         { info_tbl: [(c9JCm,
                       label: block_c9JCm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JCm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JCu; else goto c9JCt;
       c9JCu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9JCt: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.450379119 UTC

[section ""data" . GHC.Conc.Sync.numSparks_closure" {
     GHC.Conc.Sync.numSparks_closure:
         const GHC.Conc.Sync.numSparks_info;
 },
 GHC.Conc.Sync.numSparks_entry() //  []
         { info_tbl: [(c9JCI,
                       label: GHC.Conc.Sync.numSparks_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JCI: // global
           call GHC.Conc.Sync.numSparks1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.454161746 UTC

[section ""data" . GHC.Conc.Sync.throwTo1_closure" {
     GHC.Conc.Sync.throwTo1_closure:
         const GHC.Conc.Sync.throwTo1_info;
 },
 sat_s9FwG_entry() //  [R1]
         { info_tbl: [(c9JD2,
                       label: sat_s9FwG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JD2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9JD3; else goto c9JD4;
       c9JD3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9JD4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.throwTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c9JD5,
                       label: GHC.Conc.Sync.throwTo1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JD5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9JD7; else goto c9JD8;
       c9JD7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.throwTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JD8: // global
           I64[Sp - 24] = block_c9JCT_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9JDe; else goto c9JCU;
       u9JDe: // global
           call _c9JCT(R1) args: 0, res: 0, upd: 0;
       c9JCU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JCT() //  [R1]
         { info_tbl: [(c9JCT,
                       label: block_c9JCT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JCT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9JDb; else goto c9JDa;
       c9JDb: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9JDa: // global
           _s9FwF::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s9FwG_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c9JD6_info;
           R2 = Hp - 24;
           R1 = _s9FwF::P64;
           Sp = Sp + 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JD6() //  []
         { info_tbl: [(c9JD6,
                       label: block_c9JD6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JD6: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.463027578 UTC

[section ""data" . GHC.Conc.Sync.throwTo_closure" {
     GHC.Conc.Sync.throwTo_closure:
         const GHC.Conc.Sync.throwTo_info;
 },
 GHC.Conc.Sync.throwTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c9JDD,
                       label: GHC.Conc.Sync.throwTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JDD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.throwTo1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.466430889 UTC

[section ""data" . GHC.Conc.Sync.myThreadId1_closure" {
     GHC.Conc.Sync.myThreadId1_closure:
         const GHC.Conc.Sync.myThreadId1_info;
 },
 GHC.Conc.Sync.myThreadId1_entry() //  []
         { info_tbl: [(c9JDP,
                       label: GHC.Conc.Sync.myThreadId1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JDP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JDT; else goto c9JDS;
       c9JDT: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.myThreadId1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9JDS: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           I64[Hp] = CurrentTSO;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.471002693 UTC

[section ""data" . GHC.Conc.Sync.myThreadId_closure" {
     GHC.Conc.Sync.myThreadId_closure:
         const GHC.Conc.Sync.myThreadId_info;
 },
 GHC.Conc.Sync.myThreadId_entry() //  []
         { info_tbl: [(c9JE4,
                       label: GHC.Conc.Sync.myThreadId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JE4: // global
           call GHC.Conc.Sync.myThreadId1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.474200134 UTC

[section ""data" . GHC.Conc.Sync.yield1_closure" {
     GHC.Conc.Sync.yield1_closure:
         const GHC.Conc.Sync.yield1_info;
 },
 GHC.Conc.Sync.yield1_entry() //  []
         { info_tbl: [(c9JEh,
                       label: GHC.Conc.Sync.yield1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JEh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9JEi; else goto c9JEj;
       c9JEi: // global
           R1 = GHC.Conc.Sync.yield1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9JEj: // global
           I64[Sp - 8] = block_c9JEf_info;
           Sp = Sp - 8;
           call stg_yield#() args: 8, res: 8, upd: 8;
     }
 },
 _c9JEf() //  []
         { info_tbl: [(c9JEf,
                       label: block_c9JEf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JEf: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.479058841 UTC

[section ""data" . GHC.Conc.Sync.yield_closure" {
     GHC.Conc.Sync.yield_closure:
         const GHC.Conc.Sync.yield_info;
 },
 GHC.Conc.Sync.yield_entry() //  []
         { info_tbl: [(c9JEy,
                       label: GHC.Conc.Sync.yield_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JEy: // global
           call GHC.Conc.Sync.yield1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.48274152 UTC

[section ""data" . GHC.Conc.Sync.labelThread1_closure" {
     GHC.Conc.Sync.labelThread1_closure:
         const GHC.Conc.Sync.labelThread1_info;
         const 0;
 },
 sat_s9FwZ_entry() //  [R1, R2]
         { info_tbl: [(c9JEW,
                       label: sat_s9FwZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JEW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JF0; else goto c9JF1;
       c9JF0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JF1: // global
           I64[Sp - 16] = block_c9JET_info;
           _s9FwT::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s9FwT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9JF5; else goto c9JEU;
       u9JF5: // global
           call _c9JET(R1) args: 0, res: 0, upd: 0;
       c9JEU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JET() //  [R1]
         { info_tbl: [(c9JET,
                       label: block_c9JET_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JET: // global
           _s9FwT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9JEZ_info;
           R2 = I64[R1 + 7];
           R1 = _s9FwT::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JEZ() //  []
         { info_tbl: [(c9JEZ,
                       label: block_c9JEZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JEZ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.labelThread1_entry() //  [R2, R3]
         { info_tbl: [(c9JF6,
                       label: GHC.Conc.Sync.labelThread1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JF6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JF7; else goto c9JF8;
       c9JF7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.labelThread1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JF8: // global
           I64[Sp - 16] = block_c9JEJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9JFc; else goto c9JEK;
       u9JFc: // global
           call _c9JEJ(R1) args: 0, res: 0, upd: 0;
       c9JEK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JEJ() //  [R1]
         { info_tbl: [(c9JEJ,
                       label: block_c9JEJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JEJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JFb; else goto c9JFa;
       c9JFb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9JFa: // global
           _s9FwT::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s9FwZ_info;
           P64[Hp] = _s9FwT::P64;
           R4 = Hp - 6;
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.493614761 UTC

[section ""data" . GHC.Conc.Sync.labelThread_closure" {
     GHC.Conc.Sync.labelThread_closure:
         const GHC.Conc.Sync.labelThread_info;
         const 0;
 },
 GHC.Conc.Sync.labelThread_entry() //  [R2, R3]
         { info_tbl: [(c9JFC,
                       label: GHC.Conc.Sync.labelThread_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JFC: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.labelThread1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.496898401 UTC

[section ""data" . GHC.Conc.Sync.pseq_closure" {
     GHC.Conc.Sync.pseq_closure:
         const GHC.Conc.Sync.pseq_info;
 },
 GHC.Conc.Sync.pseq_entry() //  [R2, R3]
         { info_tbl: [(c9JFP,
                       label: GHC.Conc.Sync.pseq_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JFP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JFQ; else goto c9JFR;
       c9JFQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.pseq_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JFR: // global
           I64[Sp - 16] = block_c9JFN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JFN() //  []
         { info_tbl: [(c9JFN,
                       label: block_c9JFN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JFN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.50255186 UTC

[section ""data" . GHC.Conc.Sync.par_closure" {
     GHC.Conc.Sync.par_closure:
         const GHC.Conc.Sync.par_info;
 },
 GHC.Conc.Sync.par_entry() //  [R2, R3]
         { info_tbl: [(c9JGa,
                       label: GHC.Conc.Sync.par_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JGa: // global
           _s9Fx4::P64 = R3;
           (_c9JG5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [] newSpark(BaseReg, R2);
           R1 = _s9Fx4::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.506091523 UTC

[section ""data" . GHC.Conc.Sync.runSparks_loop_closure" {
     GHC.Conc.Sync.runSparks_loop_closure:
         const GHC.Conc.Sync.runSparks_loop_info;
 },
 GHC.Conc.Sync.runSparks_loop_entry() //  []
         { info_tbl: [(c9JGu,
                       label: GHC.Conc.Sync.runSparks_loop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JGu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9JGv; else goto u9JGD;
       c9JGv: // global
           R1 = GHC.Conc.Sync.runSparks_loop_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       u9JGD: // global
           call _c9JGj() args: 0, res: 0, upd: 0;
     }
 },
 _c9JGj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JGj: // global
           I64[Sp - 8] = block_c9JGm_info;
           Sp = Sp - 8;
           call stg_getSpark#() args: 8, res: 8, upd: 8;
     }
 },
 _c9JGm() //  [R1, R2]
         { info_tbl: [(c9JGm,
                       label: block_c9JGm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JGm: // global
           if (R1 == 0) goto c9JGt; else goto c9JGs;
       c9JGt: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9JGs: // global
           I64[Sp] = block_c9JGz_info;
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JGz() //  []
         { info_tbl: [(c9JGz,
                       label: block_c9JGz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JGz: // global
           Sp = Sp + 8;
           call _c9JGj() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.513366804 UTC

[section ""data" . GHC.Conc.Sync.runSparks_closure" {
     GHC.Conc.Sync.runSparks_closure:
         const GHC.Conc.Sync.runSparks_info;
 },
 GHC.Conc.Sync.runSparks_entry() //  []
         { info_tbl: [(c9JGX,
                       label: GHC.Conc.Sync.runSparks_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JGX: // global
           call GHC.Conc.Sync.runSparks_loop_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.516981058 UTC

[section ""data" . GHC.Conc.Sync.threadCapability1_closure" {
     GHC.Conc.Sync.threadCapability1_closure:
         const GHC.Conc.Sync.threadCapability1_info;
 },
 sat_s9Fxo_entry() //  [R1]
         { info_tbl: [(c9JHp,
                       label: sat_s9Fxo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JHp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JHq; else goto c9JHr;
       c9JHq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9JHr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c9JHo; else goto c9JHn;
       c9JHo: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9JHn: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.threadCapability1_entry() //  [R2]
         { info_tbl: [(c9JHs,
                       label: GHC.Conc.Sync.threadCapability1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JHs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9JHv; else goto c9JHw;
       c9JHv: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.threadCapability1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JHw: // global
           I64[Sp - 8] = block_c9JH8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9JHD; else goto c9JH9;
       u9JHD: // global
           call _c9JH8(R1) args: 0, res: 0, upd: 0;
       c9JH9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JH8() //  [R1]
         { info_tbl: [(c9JH8,
                       label: block_c9JH8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JH8: // global
           I64[Sp] = block_c9JHd_info;
           R1 = P64[R1 + 7];
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JHd() //  [R2, R3]
         { info_tbl: [(c9JHd,
                       label: block_c9JHd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JHd: // global
           I64[Sp - 8] = R3;
           I64[Sp] = R2;
           Sp = Sp - 16;
           call _c9JHe() args: 0, res: 0, upd: 0;
     }
 },
 _c9JHe() //  []
         { info_tbl: [(c9JHe,
                       label: block_c9JHe_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JHe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c9JHA; else goto c9JHz;
       c9JHA: // global
           HpAlloc = 64;
           I64[Sp] = block_c9JHe_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c9JHz: // global
           I64[Hp - 56] = sat_s9Fxo_info;
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.527830607 UTC

[section ""data" . GHC.Conc.Sync.threadCapability_closure" {
     GHC.Conc.Sync.threadCapability_closure:
         const GHC.Conc.Sync.threadCapability_info;
 },
 GHC.Conc.Sync.threadCapability_entry() //  [R2]
         { info_tbl: [(c9JI8,
                       label: GHC.Conc.Sync.threadCapability_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JI8: // global
           R2 = R2;
           call GHC.Conc.Sync.threadCapability1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.531316035 UTC

[section ""data" . GHC.Conc.Sync.mkWeakThreadId1_closure" {
     GHC.Conc.Sync.mkWeakThreadId1_closure:
         const GHC.Conc.Sync.mkWeakThreadId1_info;
 },
 GHC.Conc.Sync.mkWeakThreadId1_entry() //  [R2]
         { info_tbl: [(c9JIm,
                       label: GHC.Conc.Sync.mkWeakThreadId1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JIm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9JIs; else goto c9JIt;
       c9JIs: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.mkWeakThreadId1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JIt: // global
           I64[Sp - 8] = block_c9JIj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9JIy; else goto c9JIk;
       u9JIy: // global
           call _c9JIj(R1) args: 0, res: 0, upd: 0;
       c9JIk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JIj() //  [R1]
         { info_tbl: [(c9JIj,
                       label: block_c9JIj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JIj: // global
           I64[Sp] = block_c9JIp_info;
           R2 = R1;
           R1 = P64[R1 + 7];
           call stg_mkWeakNoFinalizer#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JIp() //  [R1]
         { info_tbl: [(c9JIp,
                       label: block_c9JIp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JIp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JIx; else goto c9JIw;
       c9JIx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9JIw: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.538934891 UTC

[section ""data" . GHC.Conc.Sync.mkWeakThreadId_closure" {
     GHC.Conc.Sync.mkWeakThreadId_closure:
         const GHC.Conc.Sync.mkWeakThreadId_info;
 },
 GHC.Conc.Sync.mkWeakThreadId_entry() //  [R2]
         { info_tbl: [(c9JIQ,
                       label: GHC.Conc.Sync.mkWeakThreadId_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JIQ: // global
           R2 = R2;
           call GHC.Conc.Sync.mkWeakThreadId1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.542451905 UTC

[section ""data" . GHC.Conc.Sync.newStablePtrPrimMVar1_closure" {
     GHC.Conc.Sync.newStablePtrPrimMVar1_closure:
         const GHC.Conc.Sync.newStablePtrPrimMVar1_info;
 },
 GHC.Conc.Sync.newStablePtrPrimMVar1_entry() //  [R2]
         { info_tbl: [(c9JJ4,
                       label: GHC.Conc.Sync.newStablePtrPrimMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JJ4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9JJa; else goto c9JJb;
       c9JJa: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.newStablePtrPrimMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JJb: // global
           I64[Sp - 8] = block_c9JJ1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9JJg; else goto c9JJ2;
       u9JJg: // global
           call _c9JJ1(R1) args: 0, res: 0, upd: 0;
       c9JJ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JJ1() //  [R1]
         { info_tbl: [(c9JJ1,
                       label: block_c9JJ1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JJ1: // global
           I64[Sp] = block_c9JJ7_info;
           R1 = P64[R1 + 7];
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JJ7() //  [R1]
         { info_tbl: [(c9JJ7,
                       label: block_c9JJ7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JJ7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JJf; else goto c9JJe;
       c9JJf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9JJe: // global
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.549159844 UTC

[section ""data" . GHC.Conc.Sync.newStablePtrPrimMVar_closure" {
     GHC.Conc.Sync.newStablePtrPrimMVar_closure:
         const GHC.Conc.Sync.newStablePtrPrimMVar_info;
 },
 GHC.Conc.Sync.newStablePtrPrimMVar_entry() //  [R2]
         { info_tbl: [(c9JJy,
                       label: GHC.Conc.Sync.newStablePtrPrimMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JJy: // global
           R2 = R2;
           call GHC.Conc.Sync.newStablePtrPrimMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.552854171 UTC

[section ""data" . $c>>=_r9FuK_closure" {
     $c>>=_r9FuK_closure:
         const $c>>=_r9FuK_info;
 },
 $c>>=_r9FuK_entry() //  [R2, R3]
         { info_tbl: [(c9JJL,
                       label: $c>>=_r9FuK_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JJL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JJM; else goto c9JJN;
       c9JJM: // global
           R3 = R3;
           R2 = R2;
           R1 = $c>>=_r9FuK_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JJN: // global
           I64[Sp - 16] = block_c9JJJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JJJ() //  [R1]
         { info_tbl: [(c9JJJ,
                       label: block_c9JJJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JJJ: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.557883159 UTC

[section ""data" . GHC.Conc.Sync.$fMonadSTM_$c>>=_closure" {
     GHC.Conc.Sync.$fMonadSTM_$c>>=_closure:
         const GHC.Conc.Sync.$fMonadSTM_$c>>=_info;
 },
 GHC.Conc.Sync.$fMonadSTM_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c9JK1,
                       label: GHC.Conc.Sync.$fMonadSTM_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JK1: // global
           R3 = R3;
           R2 = R2;
           call $c>>=_r9FuK_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.561289506 UTC

[section ""data" . $c*>_r9FuL_closure" {
     $c*>_r9FuL_closure:
         const $c*>_r9FuL_info;
 },
 $c*>_r9FuL_entry() //  [R2, R3]
         { info_tbl: [(c9JKe,
                       label: $c*>_r9FuL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JKe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JKf; else goto c9JKg;
       c9JKf: // global
           R3 = R3;
           R2 = R2;
           R1 = $c*>_r9FuL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JKg: // global
           I64[Sp - 16] = block_c9JKc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JKc() //  []
         { info_tbl: [(c9JKc,
                       label: block_c9JKc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JKc: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.566771455 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure:
         const GHC.Conc.Sync.$fApplicativeSTM_$c*>_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM_$c*>_entry() //  [R2, R3]
         { info_tbl: [(c9JKu,
                       label: GHC.Conc.Sync.$fApplicativeSTM_$c*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JKu: // global
           R3 = R3;
           R2 = R2;
           call $c*>_r9FuL_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.571151243 UTC

[section ""data" . GHC.Conc.Sync.orElse_closure" {
     GHC.Conc.Sync.orElse_closure:
         const GHC.Conc.Sync.orElse_info;
 },
 GHC.Conc.Sync.orElse_entry() //  [R2, R3]
         { info_tbl: [(c9JKF,
                       label: GHC.Conc.Sync.orElse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JKF: // global
           _B3::P64 = R2;
           R2 = R3;
           R1 = _B3::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.575097306 UTC

[section ""data" . GHC.Conc.Sync.catchSTM1_closure" {
     GHC.Conc.Sync.catchSTM1_closure:
         const GHC.Conc.Sync.catchSTM1_info;
 },
 sat_s9FxY_entry() //  [R1]
         { info_tbl: [(c9JL4,
                       label: sat_s9FxY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JL4: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9Fy0_entry() //  [R1, R2]
         { info_tbl: [(c9JLb,
                       label: sat_s9Fy0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JLb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9JLc; else goto c9JLd;
       c9JLc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JLd: // global
           I64[Sp - 24] = block_c9JKV_info;
           _s9FxW::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s9FxW::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _s9FxW::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c9JKV() //  [R1]
         { info_tbl: [(c9JKV,
                       label: block_c9JKV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JKV: // global
           if (R1 & 7 == 1) goto c9JL8; else goto c9JL9;
       c9JL8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JLg; else goto c9JLf;
       c9JLg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9JLf: // global
           I64[Hp - 8] = sat_s9FxY_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9JL9: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.catchSTM1_entry() //  [R2, R3, R4]
         { info_tbl: [(c9JLk,
                       label: GHC.Conc.Sync.catchSTM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JLk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9JLo; else goto c9JLn;
       c9JLo: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.catchSTM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JLn: // global
           I64[Hp - 16] = sat_s9Fy0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 15;
           R1 = R3;
           call stg_catchSTM#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.584271708 UTC

[section ""data" . GHC.Conc.Sync.catchSTM_closure" {
     GHC.Conc.Sync.catchSTM_closure:
         const GHC.Conc.Sync.catchSTM_info;
 },
 GHC.Conc.Sync.catchSTM_entry() //  [R2, R3, R4]
         { info_tbl: [(c9JLM,
                       label: GHC.Conc.Sync.catchSTM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JLM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.catchSTM1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.588176779 UTC

[section ""data" . $cpure_r9FuM_closure" {
     $cpure_r9FuM_closure:
         const $cpure_r9FuM_info;
 },
 $cpure_r9FuM_entry() //  [R2]
         { info_tbl: [(c9JLX,
                       label: $cpure_r9FuM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JLX: // global
           R1 = R2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.591346694 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure:
         const GHC.Conc.Sync.$fApplicativeSTM_$cpure_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM_$cpure_entry() //  [R2]
         { info_tbl: [(c9JM9,
                       label: GHC.Conc.Sync.$fApplicativeSTM_$cpure_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JM9: // global
           R2 = R2;
           call $cpure_r9FuM_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.594575625 UTC

[section ""data" . GHC.Conc.Sync.unsafeIOToSTM1_closure" {
     GHC.Conc.Sync.unsafeIOToSTM1_closure:
         const GHC.Conc.Sync.unsafeIOToSTM1_info;
 },
 GHC.Conc.Sync.unsafeIOToSTM1_entry() //  [R2]
         { info_tbl: [(c9JMk,
                       label: GHC.Conc.Sync.unsafeIOToSTM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JMk: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.59825224 UTC

[section ""data" . GHC.Conc.Sync.unsafeIOToSTM_closure" {
     GHC.Conc.Sync.unsafeIOToSTM_closure:
         const GHC.Conc.Sync.unsafeIOToSTM_info;
 },
 GHC.Conc.Sync.unsafeIOToSTM_entry() //  [R2]
         { info_tbl: [(c9JMv,
                       label: GHC.Conc.Sync.unsafeIOToSTM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JMv: // global
           R2 = R2;
           call GHC.Conc.Sync.unsafeIOToSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.601736406 UTC

[section ""data" . GHC.Conc.Sync.atomically_closure" {
     GHC.Conc.Sync.atomically_closure:
         const GHC.Conc.Sync.atomically_info;
 },
 GHC.Conc.Sync.atomically_entry() //  [R2]
         { info_tbl: [(c9JMG,
                       label: GHC.Conc.Sync.atomically_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JMG: // global
           R1 = R2;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.604932472 UTC

[section ""data" . GHC.Conc.Sync.retry_closure" {
     GHC.Conc.Sync.retry_closure:
         const GHC.Conc.Sync.retry_info;
 },
 GHC.Conc.Sync.retry_entry() //  []
         { info_tbl: [(c9JMR,
                       label: GHC.Conc.Sync.retry_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JMR: // global
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.608304832 UTC

[section ""data" . GHC.Conc.Sync.throwSTM1_closure" {
     GHC.Conc.Sync.throwSTM1_closure:
         const GHC.Conc.Sync.throwSTM1_info;
 },
 sat_s9Fy7_entry() //  [R1]
         { info_tbl: [(c9JN6,
                       label: sat_s9Fy7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JN6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9JN7; else goto c9JN8;
       c9JN7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9JN8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.throwSTM1_entry() //  [R2, R3]
         { info_tbl: [(c9JN9,
                       label: GHC.Conc.Sync.throwSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JN9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9JNd; else goto c9JNc;
       c9JNd: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.throwSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JNc: // global
           I64[Hp - 24] = sat_s9Fy7_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.614250602 UTC

[section ""data" . GHC.Conc.Sync.throwSTM_closure" {
     GHC.Conc.Sync.throwSTM_closure:
         const GHC.Conc.Sync.throwSTM_info;
 },
 GHC.Conc.Sync.throwSTM_entry() //  [R2, R3]
         { info_tbl: [(c9JNr,
                       label: GHC.Conc.Sync.throwSTM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JNr: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.throwSTM1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.61755257 UTC

[section ""data" . GHC.Conc.Sync.newTVar1_closure" {
     GHC.Conc.Sync.newTVar1_closure:
         const GHC.Conc.Sync.newTVar1_info;
 },
 GHC.Conc.Sync.newTVar1_entry() //  [R2]
         { info_tbl: [(c9JNF,
                       label: GHC.Conc.Sync.newTVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JNF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9JNG; else goto c9JNH;
       c9JNG: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.newTVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JNH: // global
           I64[Sp - 8] = block_c9JNC_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JNC() //  [R1]
         { info_tbl: [(c9JNC,
                       label: block_c9JNC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JNC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9JNK; else goto c9JNJ;
       c9JNK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9JNJ: // global
           I64[Hp - 8] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.622921493 UTC

[section ""data" . GHC.Conc.Sync.newTVar_closure" {
     GHC.Conc.Sync.newTVar_closure:
         const GHC.Conc.Sync.newTVar_info;
 },
 GHC.Conc.Sync.newTVar_entry() //  [R2]
         { info_tbl: [(c9JNY,
                       label: GHC.Conc.Sync.newTVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JNY: // global
           R2 = R2;
           call GHC.Conc.Sync.newTVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.626433557 UTC

[section ""data" . GHC.Conc.Sync.newTVarIO_closure" {
     GHC.Conc.Sync.newTVarIO_closure:
         const GHC.Conc.Sync.newTVarIO_info;
 },
 GHC.Conc.Sync.newTVarIO_entry() //  [R2]
         { info_tbl: [(c9JO9,
                       label: GHC.Conc.Sync.newTVarIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JO9: // global
           R2 = R2;
           call GHC.Conc.Sync.newTVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.630253165 UTC

[section ""data" . GHC.Conc.Sync.readTVarIO1_closure" {
     GHC.Conc.Sync.readTVarIO1_closure:
         const GHC.Conc.Sync.readTVarIO1_info;
 },
 GHC.Conc.Sync.readTVarIO1_entry() //  [R2]
         { info_tbl: [(c9JOn,
                       label: GHC.Conc.Sync.readTVarIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JOn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9JOo; else goto c9JOp;
       c9JOo: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.readTVarIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JOp: // global
           I64[Sp - 8] = block_c9JOk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9JOt; else goto c9JOl;
       u9JOt: // global
           call _c9JOk(R1) args: 0, res: 0, upd: 0;
       c9JOl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JOk() //  [R1]
         { info_tbl: [(c9JOk,
                       label: block_c9JOk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JOk: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readTVarIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.635366476 UTC

[section ""data" . GHC.Conc.Sync.readTVarIO_closure" {
     GHC.Conc.Sync.readTVarIO_closure:
         const GHC.Conc.Sync.readTVarIO_info;
 },
 GHC.Conc.Sync.readTVarIO_entry() //  [R2]
         { info_tbl: [(c9JOH,
                       label: GHC.Conc.Sync.readTVarIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JOH: // global
           R2 = R2;
           call GHC.Conc.Sync.readTVarIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.638895748 UTC

[section ""data" . GHC.Conc.Sync.readTVar1_closure" {
     GHC.Conc.Sync.readTVar1_closure:
         const GHC.Conc.Sync.readTVar1_info;
 },
 GHC.Conc.Sync.readTVar1_entry() //  [R2]
         { info_tbl: [(c9JOV,
                       label: GHC.Conc.Sync.readTVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JOV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9JOW; else goto c9JOX;
       c9JOW: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.readTVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9JOX: // global
           I64[Sp - 8] = block_c9JOS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9JP1; else goto c9JOT;
       u9JP1: // global
           call _c9JOS(R1) args: 0, res: 0, upd: 0;
       c9JOT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JOS() //  [R1]
         { info_tbl: [(c9JOS,
                       label: block_c9JOS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JOS: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readTVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.643892715 UTC

[section ""data" . GHC.Conc.Sync.readTVar_closure" {
     GHC.Conc.Sync.readTVar_closure:
         const GHC.Conc.Sync.readTVar_info;
 },
 GHC.Conc.Sync.readTVar_entry() //  [R2]
         { info_tbl: [(c9JPf,
                       label: GHC.Conc.Sync.readTVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JPf: // global
           R2 = R2;
           call GHC.Conc.Sync.readTVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.647204822 UTC

[section ""data" . GHC.Conc.Sync.writeTVar1_closure" {
     GHC.Conc.Sync.writeTVar1_closure:
         const GHC.Conc.Sync.writeTVar1_info;
 },
 GHC.Conc.Sync.writeTVar1_entry() //  [R2, R3]
         { info_tbl: [(c9JPt,
                       label: GHC.Conc.Sync.writeTVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JPt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JPx; else goto c9JPy;
       c9JPx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.writeTVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JPy: // global
           I64[Sp - 16] = block_c9JPq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9JPC; else goto c9JPr;
       u9JPC: // global
           call _c9JPq(R1) args: 0, res: 0, upd: 0;
       c9JPr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JPq() //  [R1]
         { info_tbl: [(c9JPq,
                       label: block_c9JPq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JPq: // global
           _s9Fyn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9JPw_info;
           R2 = _s9Fyn::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JPw() //  []
         { info_tbl: [(c9JPw,
                       label: block_c9JPw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JPw: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.654065297 UTC

[section ""data" . GHC.Conc.Sync.writeTVar_closure" {
     GHC.Conc.Sync.writeTVar_closure:
         const GHC.Conc.Sync.writeTVar_info;
 },
 GHC.Conc.Sync.writeTVar_entry() //  [R2, R3]
         { info_tbl: [(c9JPU,
                       label: GHC.Conc.Sync.writeTVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JPU: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.writeTVar1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.65851399 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$ccompare_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c9JQg,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JQg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JQh; else goto c9JQi;
       c9JQh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JQi: // global
           I64[Sp - 16] = block_c9JQ5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9JTl; else goto c9JQ6;
       u9JTl: // global
           call _c9JQ5(R1) args: 0, res: 0, upd: 0;
       c9JQ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JQ5() //  [R1]
         { info_tbl: [(c9JQ5,
                       label: block_c9JQ5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JQ5: // global
           _s9Fyt::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9JQ9;
               case 2 : goto c9JQa;
               case 3 : goto c9JQb;
               case 4 : goto c9JQc;
               case 5 : goto c9JQd;
               case 6 : goto c9JQe;
           }
       c9JQe: // global
           I64[Sp + 8] = block_c9JSs_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JTk; else goto c9JSu;
       u9JTk: // global
           call _c9JSs(R1) args: 0, res: 0, upd: 0;
       c9JSu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JQd: // global
           I64[Sp + 8] = block_c9JS9_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JTj; else goto c9JSb;
       u9JTj: // global
           call _c9JS9(R1) args: 0, res: 0, upd: 0;
       c9JSb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JQc: // global
           I64[Sp + 8] = block_c9JRM_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JTi; else goto c9JRO;
       u9JTi: // global
           call _c9JRM(R1) args: 0, res: 0, upd: 0;
       c9JRO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JQb: // global
           I64[Sp + 8] = block_c9JRl_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JTh; else goto c9JRn;
       u9JTh: // global
           call _c9JRl(R1) args: 0, res: 0, upd: 0;
       c9JRn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JQa: // global
           I64[Sp + 8] = block_c9JQQ_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JTg; else goto c9JQS;
       u9JTg: // global
           call _c9JQQ(R1) args: 0, res: 0, upd: 0;
       c9JQS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JQ9: // global
           I64[Sp + 8] = block_c9JQl_info;
           R1 = _s9Fyt::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JTf; else goto c9JQn;
       u9JTf: // global
           call _c9JQl(R1) args: 0, res: 0, upd: 0;
       c9JQn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JSs() //  [R1]
         { info_tbl: [(c9JSs,
                       label: block_c9JSs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JSs: // global
           if (R1 & 7 == 6) goto u9JSQ; else goto u9JSR;
       u9JSQ: // global
           Sp = Sp + 8;
           call _c9JSE() args: 0, res: 0, upd: 0;
       u9JSR: // global
           Sp = Sp + 8;
           call _c9JSA() args: 0, res: 0, upd: 0;
     }
 },
 _c9JS9() //  [R1]
         { info_tbl: [(c9JS9,
                       label: block_c9JS9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JS9: // global
           _c9JSG::P64 = R1 & 7;
           if (_c9JSG::P64 != 5) goto u9JSP; else goto u9JSS;
       u9JSP: // global
           if (_c9JSG::P64 != 6) goto u9JSU; else goto u9JST;
       u9JSU: // global
           Sp = Sp + 8;
           call _c9JSA() args: 0, res: 0, upd: 0;
       u9JST: // global
           Sp = Sp + 8;
           call _c9JSp() args: 0, res: 0, upd: 0;
       u9JSS: // global
           Sp = Sp + 8;
           call _c9JSE() args: 0, res: 0, upd: 0;
     }
 },
 _c9JRM() //  [R1]
         { info_tbl: [(c9JRM,
                       label: block_c9JRM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JRM: // global
           _c9JSH::P64 = R1 & 7;
           if (_c9JSH::P64 < 5) goto u9JSN; else goto u9JSO;
       u9JSN: // global
           if (_c9JSH::P64 < 4) goto u9JSW; else goto u9JSV;
       u9JSW: // global
           Sp = Sp + 8;
           call _c9JSA() args: 0, res: 0, upd: 0;
       u9JSV: // global
           Sp = Sp + 8;
           call _c9JSE() args: 0, res: 0, upd: 0;
       u9JSO: // global
           if (_c9JSH::P64 < 6) goto u9JSY; else goto u9JSY;
       u9JSY: // global
           Sp = Sp + 8;
           call _c9JSp() args: 0, res: 0, upd: 0;
     }
 },
 _c9JRl() //  [R1]
         { info_tbl: [(c9JRl,
                       label: block_c9JRl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JRl: // global
           _c9JSI::P64 = R1 & 7;
           if (_c9JSI::P64 < 4) goto u9JSL; else goto u9JSM;
       u9JSL: // global
           if (_c9JSI::P64 < 3) goto u9JT0; else goto u9JSZ;
       u9JT0: // global
           Sp = Sp + 8;
           call _c9JSA() args: 0, res: 0, upd: 0;
       u9JSZ: // global
           Sp = Sp + 8;
           call _c9JSE() args: 0, res: 0, upd: 0;
       u9JSM: // global
           if (_c9JSI::P64 != 5) goto u9JT2; else goto u9JT2;
       u9JT2: // global
           Sp = Sp + 8;
           call _c9JSp() args: 0, res: 0, upd: 0;
     }
 },
 _c9JQQ() //  [R1]
         { info_tbl: [(c9JQQ,
                       label: block_c9JQQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JQQ: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9JT3;
               case 2 : goto u9JT4;
               case 3, 4, 5, 6 : goto u9JT8;
           }
       u9JT8: // global
           Sp = Sp + 8;
           call _c9JSp() args: 0, res: 0, upd: 0;
       u9JT4: // global
           Sp = Sp + 8;
           call _c9JSE() args: 0, res: 0, upd: 0;
       u9JT3: // global
           Sp = Sp + 8;
           call _c9JSA() args: 0, res: 0, upd: 0;
     }
 },
 _c9JSA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JSA: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9JQl() //  [R1]
         { info_tbl: [(c9JQl,
                       label: block_c9JQl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JQl: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9JT9;
               case 2, 3, 4, 5, 6 : goto u9JTe;
           }
       u9JTe: // global
           Sp = Sp + 8;
           call _c9JSp() args: 0, res: 0, upd: 0;
       u9JT9: // global
           Sp = Sp + 8;
           call _c9JSE() args: 0, res: 0, upd: 0;
     }
 },
 _c9JSp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JSp: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9JSE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JSE: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.680042023 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c<_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c<_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c<_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c<_entry() //  [R2, R3]
         { info_tbl: [(c9JUL,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JUL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JUM; else goto c9JUN;
       c9JUM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JUN: // global
           I64[Sp - 16] = block_c9JUA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9JXl; else goto c9JUB;
       u9JXl: // global
           call _c9JUA(R1) args: 0, res: 0, upd: 0;
       c9JUB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JUA() //  [R1]
         { info_tbl: [(c9JUA,
                       label: block_c9JUA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JUA: // global
           _s9FyC::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9JUE;
               case 2 : goto c9JUF;
               case 3 : goto c9JUG;
               case 4 : goto c9JUH;
               case 5 : goto c9JUI;
               case 6 : goto c9JUJ;
           }
       c9JUJ: // global
           I64[Sp + 8] = block_c9JWH_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JXk; else goto c9JWJ;
       u9JXk: // global
           call _c9JWH() args: 0, res: 0, upd: 0;
       c9JWJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JUI: // global
           I64[Sp + 8] = block_c9JWs_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JXj; else goto c9JWu;
       u9JXj: // global
           call _c9JWs(R1) args: 0, res: 0, upd: 0;
       c9JWu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JUH: // global
           I64[Sp + 8] = block_c9JW9_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JXi; else goto c9JWb;
       u9JXi: // global
           call _c9JW9(R1) args: 0, res: 0, upd: 0;
       c9JWb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JUG: // global
           I64[Sp + 8] = block_c9JVM_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JXh; else goto c9JVO;
       u9JXh: // global
           call _c9JVM(R1) args: 0, res: 0, upd: 0;
       c9JVO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JUF: // global
           I64[Sp + 8] = block_c9JVl_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JXg; else goto c9JVn;
       u9JXg: // global
           call _c9JVl(R1) args: 0, res: 0, upd: 0;
       c9JVn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JUE: // global
           I64[Sp + 8] = block_c9JUQ_info;
           R1 = _s9FyC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9JXf; else goto c9JUS;
       u9JXf: // global
           call _c9JUQ(R1) args: 0, res: 0, upd: 0;
       c9JUS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JWH() //  []
         { info_tbl: [(c9JWH,
                       label: block_c9JWH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JWH: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9JWs() //  [R1]
         { info_tbl: [(c9JWs,
                       label: block_c9JWs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JWs: // global
           if (R1 & 7 == 6) goto u9JWX; else goto u9JWY;
       u9JWX: // global
           Sp = Sp + 8;
           call _c9JWE() args: 0, res: 0, upd: 0;
       u9JWY: // global
           Sp = Sp + 8;
           call _c9JWA() args: 0, res: 0, upd: 0;
     }
 },
 _c9JW9() //  [R1]
         { info_tbl: [(c9JW9,
                       label: block_c9JW9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JW9: // global
           _c9JWP::P64 = R1 & 7;
           if (_c9JWP::P64 != 5) goto u9JWW; else goto u9JWZ;
       u9JWW: // global
           if (_c9JWP::P64 != 6) goto u9JX1; else goto u9JX0;
       u9JX1: // global
           Sp = Sp + 8;
           call _c9JWA() args: 0, res: 0, upd: 0;
       u9JX0: // global
           Sp = Sp + 8;
           goto u9JXu;
       u9JWZ: // global
           Sp = Sp + 8;
           goto u9JXu;
       u9JXu: // global
           call _c9JWE() args: 0, res: 0, upd: 0;
     }
 },
 _c9JVM() //  [R1]
         { info_tbl: [(c9JVM,
                       label: block_c9JVM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JVM: // global
           _c9JWQ::P64 = R1 & 7;
           if (_c9JWQ::P64 < 4) goto u9JX2; else goto u9JWV;
       u9JX2: // global
           Sp = Sp + 8;
           call _c9JWA() args: 0, res: 0, upd: 0;
       u9JWV: // global
           if (_c9JWQ::P64 != 5) goto u9JX4; else goto u9JX4;
       u9JX4: // global
           Sp = Sp + 8;
           call _c9JWE() args: 0, res: 0, upd: 0;
     }
 },
 _c9JVl() //  [R1]
         { info_tbl: [(c9JVl,
                       label: block_c9JVl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JVl: // global
           _c9JWR::P64 = R1 & 7;
           if (_c9JWR::P64 < 6) goto u9JWT; else goto u9JX5;
       u9JWT: // global
           if (_c9JWR::P64 < 3) goto u9JX6; else goto u9JWU;
       u9JX6: // global
           Sp = Sp + 8;
           call _c9JWA() args: 0, res: 0, upd: 0;
       u9JWU: // global
           if (_c9JWR::P64 != 4) goto u9JX8; else goto u9JX8;
       u9JX8: // global
           Sp = Sp + 8;
           goto u9JXq;
       u9JX5: // global
           Sp = Sp + 8;
           goto u9JXq;
       u9JXq: // global
           call _c9JWE() args: 0, res: 0, upd: 0;
     }
 },
 _c9JUQ() //  [R1]
         { info_tbl: [(c9JUQ,
                       label: block_c9JUQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JUQ: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9JX9;
               case 2, 3, 4, 5, 6 : goto u9JXe;
           }
       u9JXe: // global
           Sp = Sp + 8;
           call _c9JWE() args: 0, res: 0, upd: 0;
       u9JX9: // global
           Sp = Sp + 8;
           call _c9JWA() args: 0, res: 0, upd: 0;
     }
 },
 _c9JWE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JWE: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9JWA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JWA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.699588081 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c<=_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c9JYC,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JYC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9JYD; else goto c9JYE;
       c9JYD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9JYE: // global
           I64[Sp - 16] = block_c9JYr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9K1c; else goto c9JYs;
       u9K1c: // global
           call _c9JYr(R1) args: 0, res: 0, upd: 0;
       c9JYs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9JYr() //  [R1]
         { info_tbl: [(c9JYr,
                       label: block_c9JYr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JYr: // global
           _s9FyK::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9JYv;
               case 2 : goto c9JYw;
               case 3 : goto c9JYx;
               case 4 : goto c9JYy;
               case 5 : goto c9JYz;
               case 6 : goto c9JYA;
           }
       c9JYA: // global
           I64[Sp + 8] = block_c9K0y_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K1b; else goto c9K0A;
       u9K1b: // global
           call _c9K0y() args: 0, res: 0, upd: 0;
       c9K0A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JYz: // global
           I64[Sp + 8] = block_c9K0j_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K1a; else goto c9K0l;
       u9K1a: // global
           call _c9K0j(R1) args: 0, res: 0, upd: 0;
       c9K0l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JYy: // global
           I64[Sp + 8] = block_c9K00_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K19; else goto c9K02;
       u9K19: // global
           call _c9K00(R1) args: 0, res: 0, upd: 0;
       c9K02: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JYx: // global
           I64[Sp + 8] = block_c9JZD_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K18; else goto c9JZF;
       u9K18: // global
           call _c9JZD(R1) args: 0, res: 0, upd: 0;
       c9JZF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JYw: // global
           I64[Sp + 8] = block_c9JZc_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K17; else goto c9JZe;
       u9K17: // global
           call _c9JZc(R1) args: 0, res: 0, upd: 0;
       c9JZe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9JYv: // global
           I64[Sp + 8] = block_c9JYH_info;
           R1 = _s9FyK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K16; else goto c9JYJ;
       u9K16: // global
           call _c9JYH(R1) args: 0, res: 0, upd: 0;
       c9JYJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9K0y() //  []
         { info_tbl: [(c9K0y,
                       label: block_c9K0y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K0y: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9K0j() //  [R1]
         { info_tbl: [(c9K0j,
                       label: block_c9K0j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K0j: // global
           if (R1 & 7 == 6) goto u9K0O; else goto u9K0P;
       u9K0O: // global
           Sp = Sp + 8;
           call _c9K0v() args: 0, res: 0, upd: 0;
       u9K0P: // global
           Sp = Sp + 8;
           call _c9K0r() args: 0, res: 0, upd: 0;
     }
 },
 _c9K00() //  [R1]
         { info_tbl: [(c9K00,
                       label: block_c9K00_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K00: // global
           _c9K0G::P64 = R1 & 7;
           if (_c9K0G::P64 != 5) goto u9K0N; else goto u9K0Q;
       u9K0N: // global
           if (_c9K0G::P64 != 6) goto u9K0S; else goto u9K0R;
       u9K0S: // global
           Sp = Sp + 8;
           call _c9K0r() args: 0, res: 0, upd: 0;
       u9K0R: // global
           Sp = Sp + 8;
           goto u9K1l;
       u9K0Q: // global
           Sp = Sp + 8;
           goto u9K1l;
       u9K1l: // global
           call _c9K0v() args: 0, res: 0, upd: 0;
     }
 },
 _c9JZD() //  [R1]
         { info_tbl: [(c9JZD,
                       label: block_c9JZD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JZD: // global
           _c9K0H::P64 = R1 & 7;
           if (_c9K0H::P64 < 4) goto u9K0T; else goto u9K0M;
       u9K0T: // global
           Sp = Sp + 8;
           call _c9K0r() args: 0, res: 0, upd: 0;
       u9K0M: // global
           if (_c9K0H::P64 != 5) goto u9K0V; else goto u9K0V;
       u9K0V: // global
           Sp = Sp + 8;
           call _c9K0v() args: 0, res: 0, upd: 0;
     }
 },
 _c9JZc() //  [R1]
         { info_tbl: [(c9JZc,
                       label: block_c9JZc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JZc: // global
           _c9K0I::P64 = R1 & 7;
           if (_c9K0I::P64 < 6) goto u9K0K; else goto u9K0W;
       u9K0K: // global
           if (_c9K0I::P64 < 3) goto u9K0X; else goto u9K0L;
       u9K0X: // global
           Sp = Sp + 8;
           call _c9K0r() args: 0, res: 0, upd: 0;
       u9K0L: // global
           if (_c9K0I::P64 != 4) goto u9K0Z; else goto u9K0Z;
       u9K0Z: // global
           Sp = Sp + 8;
           goto u9K1h;
       u9K0W: // global
           Sp = Sp + 8;
           goto u9K1h;
       u9K1h: // global
           call _c9K0v() args: 0, res: 0, upd: 0;
     }
 },
 _c9JYH() //  [R1]
         { info_tbl: [(c9JYH,
                       label: block_c9JYH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9JYH: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9K10;
               case 2, 3, 4, 5, 6 : goto u9K15;
           }
       u9K15: // global
           Sp = Sp + 8;
           call _c9K0v() args: 0, res: 0, upd: 0;
       u9K10: // global
           Sp = Sp + 8;
           call _c9K0r() args: 0, res: 0, upd: 0;
     }
 },
 _c9K0v() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K0v: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9K0r() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K0r: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.720084835 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$cmax_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c9K2t,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K2t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9K2u; else goto c9K2v;
       c9K2u: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9K2v: // global
           I64[Sp - 16] = block_c9K2i_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9K4w; else goto c9K2j;
       u9K4w: // global
           call _c9K2i(R1) args: 0, res: 0, upd: 0;
       c9K2j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9K2i() //  [R1]
         { info_tbl: [(c9K2i,
                       label: block_c9K2i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K2i: // global
           _s9FyT::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9K2m;
               case 2 : goto c9K2n;
               case 3 : goto c9K2o;
               case 4 : goto c9K2p;
               case 5 : goto c9K2q;
               case 6 : goto c9K2r;
           }
       c9K2r: // global
           I64[Sp + 8] = block_c9K3X_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K4v; else goto c9K3Z;
       u9K4v: // global
           call _c9K3X() args: 0, res: 0, upd: 0;
       c9K3Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K2q: // global
           I64[Sp + 8] = block_c9K3I_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K4u; else goto c9K3K;
       u9K4u: // global
           call _c9K3I(R1) args: 0, res: 0, upd: 0;
       c9K3K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K2p: // global
           I64[Sp + 8] = block_c9K3p_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K4t; else goto c9K3r;
       u9K4t: // global
           call _c9K3p(R1) args: 0, res: 0, upd: 0;
       c9K3r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K2o: // global
           I64[Sp + 8] = block_c9K32_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K4s; else goto c9K34;
       u9K4s: // global
           call _c9K32(R1) args: 0, res: 0, upd: 0;
       c9K34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K2n: // global
           I64[Sp + 8] = block_c9K2B_info;
           R1 = _s9FyT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K4r; else goto c9K2D;
       u9K4r: // global
           call _c9K2B(R1) args: 0, res: 0, upd: 0;
       c9K2D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K2m: // global
           R1 = _s9FyT::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9K3X() //  []
         { info_tbl: [(c9K3X,
                       label: block_c9K3X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K3X: // global
           R1 = GHC.Conc.Sync.BlockedOnOther_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9K3I() //  [R1]
         { info_tbl: [(c9K3I,
                       label: block_c9K3I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K3I: // global
           if (R1 & 7 == 6) goto u9K4e; else goto u9K4f;
       u9K4e: // global
           Sp = Sp + 8;
           call _c9K3U() args: 0, res: 0, upd: 0;
       u9K4f: // global
           Sp = Sp + 8;
           call _c9K3Q() args: 0, res: 0, upd: 0;
     }
 },
 _c9K3p() //  [R1]
         { info_tbl: [(c9K3p,
                       label: block_c9K3p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K3p: // global
           _c9K45::P64 = R1 & 7;
           if (_c9K45::P64 != 5) goto u9K4d; else goto u9K4g;
       u9K4d: // global
           if (_c9K45::P64 != 6) goto u9K4i; else goto u9K4h;
       u9K4i: // global
           Sp = Sp + 8;
           call _c9K3x() args: 0, res: 0, upd: 0;
       u9K4h: // global
           Sp = Sp + 8;
           call _c9K3U() args: 0, res: 0, upd: 0;
       u9K4g: // global
           Sp = Sp + 8;
           call _c9K3Q() args: 0, res: 0, upd: 0;
     }
 },
 _c9K32() //  [R1]
         { info_tbl: [(c9K32,
                       label: block_c9K32_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K32: // global
           _c9K46::P64 = R1 & 7;
           if (_c9K46::P64 < 5) goto u9K4b; else goto u9K4c;
       u9K4b: // global
           if (_c9K46::P64 < 4) goto u9K4k; else goto u9K4j;
       u9K4k: // global
           Sp = Sp + 8;
           call _c9K3a() args: 0, res: 0, upd: 0;
       u9K4j: // global
           Sp = Sp + 8;
           call _c9K3x() args: 0, res: 0, upd: 0;
       u9K4c: // global
           if (_c9K46::P64 < 6) goto u9K4m; else goto u9K4l;
       u9K4m: // global
           Sp = Sp + 8;
           call _c9K3Q() args: 0, res: 0, upd: 0;
       u9K4l: // global
           Sp = Sp + 8;
           call _c9K3U() args: 0, res: 0, upd: 0;
     }
 },
 _c9K2B() //  [R1]
         { info_tbl: [(c9K2B,
                       label: block_c9K2B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K2B: // global
           _c9K47::P64 = R1 & 7;
           if (_c9K47::P64 < 5) goto u9K48; else goto u9K4a;
       u9K48: // global
           if (_c9K47::P64 < 4) goto u9K49; else goto u9K4n;
       u9K49: // global
           if (_c9K47::P64 < 3) goto c9K2J; else goto u9K4o;
       c9K2J: // global
           R1 = GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9K4o: // global
           Sp = Sp + 8;
           call _c9K3a() args: 0, res: 0, upd: 0;
       u9K4n: // global
           Sp = Sp + 8;
           call _c9K3x() args: 0, res: 0, upd: 0;
       u9K4a: // global
           if (_c9K47::P64 < 6) goto u9K4q; else goto u9K4p;
       u9K4q: // global
           Sp = Sp + 8;
           call _c9K3Q() args: 0, res: 0, upd: 0;
       u9K4p: // global
           Sp = Sp + 8;
           call _c9K3U() args: 0, res: 0, upd: 0;
     }
 },
 _c9K3a() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K3a: // global
           R1 = GHC.Conc.Sync.BlockedOnException_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9K3x() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K3x: // global
           R1 = GHC.Conc.Sync.BlockedOnSTM_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9K3Q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K3Q: // global
           R1 = GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9K3U() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K3U: // global
           R1 = GHC.Conc.Sync.BlockedOnOther_closure+6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.740319417 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c>=_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c9K5Q,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K5Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9K5R; else goto c9K5S;
       c9K5R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9K5S: // global
           I64[Sp - 16] = block_c9K5F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9K8q; else goto c9K5G;
       u9K8q: // global
           call _c9K5F(R1) args: 0, res: 0, upd: 0;
       c9K5G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9K5F() //  [R1]
         { info_tbl: [(c9K5F,
                       label: block_c9K5F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K5F: // global
           _s9Fz2::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9K5J;
               case 2 : goto c9K5K;
               case 3 : goto c9K5L;
               case 4 : goto c9K5M;
               case 5 : goto c9K5N;
               case 6 : goto c9K5O;
           }
       c9K5O: // global
           I64[Sp + 8] = block_c9K7M_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K8p; else goto c9K7O;
       u9K8p: // global
           call _c9K7M() args: 0, res: 0, upd: 0;
       c9K7O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K5N: // global
           I64[Sp + 8] = block_c9K7x_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K8o; else goto c9K7z;
       u9K8o: // global
           call _c9K7x(R1) args: 0, res: 0, upd: 0;
       c9K7z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K5M: // global
           I64[Sp + 8] = block_c9K7e_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K8n; else goto c9K7g;
       u9K8n: // global
           call _c9K7e(R1) args: 0, res: 0, upd: 0;
       c9K7g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K5L: // global
           I64[Sp + 8] = block_c9K6R_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K8m; else goto c9K6T;
       u9K8m: // global
           call _c9K6R(R1) args: 0, res: 0, upd: 0;
       c9K6T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K5K: // global
           I64[Sp + 8] = block_c9K6q_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K8l; else goto c9K6s;
       u9K8l: // global
           call _c9K6q(R1) args: 0, res: 0, upd: 0;
       c9K6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K5J: // global
           I64[Sp + 8] = block_c9K5V_info;
           R1 = _s9Fz2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9K8k; else goto c9K5X;
       u9K8k: // global
           call _c9K5V(R1) args: 0, res: 0, upd: 0;
       c9K5X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9K7M() //  []
         { info_tbl: [(c9K7M,
                       label: block_c9K7M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K7M: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9K7x() //  [R1]
         { info_tbl: [(c9K7x,
                       label: block_c9K7x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K7x: // global
           if (R1 & 7 == 6) goto u9K82; else goto u9K83;
       u9K82: // global
           Sp = Sp + 8;
           call _c9K7J() args: 0, res: 0, upd: 0;
       u9K83: // global
           Sp = Sp + 8;
           call _c9K7F() args: 0, res: 0, upd: 0;
     }
 },
 _c9K7e() //  [R1]
         { info_tbl: [(c9K7e,
                       label: block_c9K7e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K7e: // global
           _c9K7U::P64 = R1 & 7;
           if (_c9K7U::P64 != 5) goto u9K81; else goto u9K84;
       u9K81: // global
           if (_c9K7U::P64 != 6) goto u9K86; else goto u9K85;
       u9K86: // global
           Sp = Sp + 8;
           call _c9K7F() args: 0, res: 0, upd: 0;
       u9K85: // global
           Sp = Sp + 8;
           goto u9K8z;
       u9K84: // global
           Sp = Sp + 8;
           goto u9K8z;
       u9K8z: // global
           call _c9K7J() args: 0, res: 0, upd: 0;
     }
 },
 _c9K6R() //  [R1]
         { info_tbl: [(c9K6R,
                       label: block_c9K6R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K6R: // global
           _c9K7V::P64 = R1 & 7;
           if (_c9K7V::P64 < 4) goto u9K87; else goto u9K80;
       u9K87: // global
           Sp = Sp + 8;
           call _c9K7F() args: 0, res: 0, upd: 0;
       u9K80: // global
           if (_c9K7V::P64 != 5) goto u9K89; else goto u9K89;
       u9K89: // global
           Sp = Sp + 8;
           call _c9K7J() args: 0, res: 0, upd: 0;
     }
 },
 _c9K6q() //  [R1]
         { info_tbl: [(c9K6q,
                       label: block_c9K6q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K6q: // global
           _c9K7W::P64 = R1 & 7;
           if (_c9K7W::P64 < 6) goto u9K7Y; else goto u9K8a;
       u9K7Y: // global
           if (_c9K7W::P64 < 3) goto u9K8b; else goto u9K7Z;
       u9K8b: // global
           Sp = Sp + 8;
           call _c9K7F() args: 0, res: 0, upd: 0;
       u9K7Z: // global
           if (_c9K7W::P64 != 4) goto u9K8d; else goto u9K8d;
       u9K8d: // global
           Sp = Sp + 8;
           goto u9K8v;
       u9K8a: // global
           Sp = Sp + 8;
           goto u9K8v;
       u9K8v: // global
           call _c9K7J() args: 0, res: 0, upd: 0;
     }
 },
 _c9K5V() //  [R1]
         { info_tbl: [(c9K5V,
                       label: block_c9K5V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K5V: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9K8e;
               case 2, 3, 4, 5, 6 : goto u9K8j;
           }
       u9K8j: // global
           Sp = Sp + 8;
           call _c9K7J() args: 0, res: 0, upd: 0;
       u9K8e: // global
           Sp = Sp + 8;
           call _c9K7F() args: 0, res: 0, upd: 0;
     }
 },
 _c9K7J() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K7J: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9K7F() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K7F: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.759491218 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c>_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c>_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c>_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c>_entry() //  [R2, R3]
         { info_tbl: [(c9K9w,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K9w: // global
           _s9Fzb::P64 = R3;
           R3 = R2;
           R2 = _s9Fzb::P64;
           call GHC.Conc.Sync.$fOrdBlockReason_$c<_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.763769596 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$cmin_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c9K9S,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K9S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9K9T; else goto c9K9U;
       c9K9T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9K9U: // global
           I64[Sp - 16] = block_c9K9H_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9KbG; else goto c9K9I;
       u9KbG: // global
           call _c9K9H(R1) args: 0, res: 0, upd: 0;
       c9K9I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9K9H() //  [R1]
         { info_tbl: [(c9K9H,
                       label: block_c9K9H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K9H: // global
           _s9Fzc::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9K9L;
               case 2 : goto c9K9M;
               case 3 : goto c9K9N;
               case 4 : goto c9K9O;
               case 5 : goto c9K9P;
               case 6 : goto c9K9Q;
           }
       c9K9Q: // global
           R1 = _s9Fzc::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9K9P: // global
           I64[Sp + 8] = block_c9Kbd_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KbF; else goto c9Kbf;
       u9KbF: // global
           call _c9Kbd(R1) args: 0, res: 0, upd: 0;
       c9Kbf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K9O: // global
           I64[Sp + 8] = block_c9KaU_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KbE; else goto c9KaW;
       u9KbE: // global
           call _c9KaU(R1) args: 0, res: 0, upd: 0;
       c9KaW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K9N: // global
           I64[Sp + 8] = block_c9Kax_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KbD; else goto c9Kaz;
       u9KbD: // global
           call _c9Kax(R1) args: 0, res: 0, upd: 0;
       c9Kaz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K9M: // global
           I64[Sp + 8] = block_c9Ka6_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KbC; else goto c9Ka8;
       u9KbC: // global
           call _c9Ka6(R1) args: 0, res: 0, upd: 0;
       c9Ka8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9K9L: // global
           I64[Sp + 8] = block_c9K9X_info;
           R1 = _s9Fzc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KbB; else goto c9K9Z;
       u9KbB: // global
           call _c9K9X() args: 0, res: 0, upd: 0;
       c9K9Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Kbd() //  [R1]
         { info_tbl: [(c9Kbd,
                       label: block_c9Kbd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kbd: // global
           if (R1 & 7 == 6) goto c9Kbp; else goto c9Kbl;
       c9Kbp: // global
           R1 = GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Kbl: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KaU() //  [R1]
         { info_tbl: [(c9KaU,
                       label: block_c9KaU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KaU: // global
           _c9Kbu::P64 = R1 & 7;
           if (_c9Kbu::P64 == 5) goto c9Kba; else goto u9KbA;
       u9KbA: // global
           if (_c9Kbu::P64 == 6) goto c9Kba; else goto c9Kb2;
       c9Kba: // global
           R1 = GHC.Conc.Sync.BlockedOnSTM_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Kb2: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Kax() //  [R1]
         { info_tbl: [(c9Kax,
                       label: block_c9Kax_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kax: // global
           _c9Kbv::P64 = R1 & 7;
           if (_c9Kbv::P64 < 4) goto c9KaF; else goto u9Kbz;
       c9KaF: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9Kbz: // global
           if (_c9Kbv::P64 != 5) goto c9KaR; else goto c9KaR;
       c9KaR: // global
           R1 = GHC.Conc.Sync.BlockedOnException_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Ka6() //  [R1]
         { info_tbl: [(c9Ka6,
                       label: block_c9Ka6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ka6: // global
           _c9Kbw::P64 = R1 & 7;
           if (_c9Kbw::P64 >= 6) goto c9Kau; else goto u9Kbx;
       u9Kbx: // global
           if (_c9Kbw::P64 < 3) goto c9Kae; else goto u9Kby;
       c9Kae: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9Kby: // global
           if (_c9Kbw::P64 != 4) goto c9Kau; else goto c9Kau;
       c9Kau: // global
           R1 = GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9K9X() //  []
         { info_tbl: [(c9K9X,
                       label: block_c9K9X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9K9X: // global
           R1 = GHC.Conc.Sync.BlockedOnMVar_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.779324106 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Conc.Sync.$fEqBlockReason_closure+1;
         const GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c<_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c>_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.783388296 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c9KcL,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KcL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9KcM; else goto c9KcN;
       c9KcM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9KcN: // global
           I64[Sp - 16] = block_c9KcC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Kev; else goto c9KcD;
       u9Kev: // global
           call _c9KcC(R1) args: 0, res: 0, upd: 0;
       c9KcD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KcC() //  [R1]
         { info_tbl: [(c9KcC,
                       label: block_c9KcC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KcC: // global
           _s9Fzl::P64 = P64[Sp + 8];
           _c9KcK::P64 = R1 & 7;
           if (_c9KcK::P64 < 3) goto u9Kea; else goto u9Keb;
       u9Kea: // global
           if (_c9KcK::P64 < 2) goto c9KcG; else goto c9KcH;
       c9KcG: // global
           I64[Sp + 8] = block_c9KcQ_info;
           R1 = _s9Fzl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ker; else goto c9KcS;
       u9Ker: // global
           call _c9KcQ(R1) args: 0, res: 0, upd: 0;
       c9KcS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KcH: // global
           I64[Sp + 8] = block_c9Kdd_info;
           R1 = _s9Fzl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Kes; else goto c9Kdf;
       u9Kes: // global
           call _c9Kdd(R1) args: 0, res: 0, upd: 0;
       c9Kdf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Keb: // global
           if (_c9KcK::P64 < 4) goto c9KcI; else goto c9KcJ;
       c9KcI: // global
           I64[Sp] = block_c9KdA_info;
           _s9Fzr::P64 = P64[R1 + 5];
           R1 = _s9Fzl::P64;
           P64[Sp + 8] = _s9Fzr::P64;
           if (R1 & 7 != 0) goto u9Ket; else goto c9KdC;
       u9Ket: // global
           call _c9KdA(R1) args: 0, res: 0, upd: 0;
       c9KdC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KcJ: // global
           I64[Sp + 8] = block_c9KdT_info;
           R1 = _s9Fzl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Keu; else goto c9KdV;
       u9Keu: // global
           call _c9KdT(R1) args: 0, res: 0, upd: 0;
       c9KdV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KcQ() //  [R1]
         { info_tbl: [(c9KcQ,
                       label: block_c9KcQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KcQ: // global
           _c9Ke9::P64 = R1 & 7;
           if (_c9Ke9::P64 < 2) goto u9Keg; else goto u9Kec;
       u9Keg: // global
           Sp = Sp + 8;
           call _c9Ke5() args: 0, res: 0, upd: 0;
       u9Kec: // global
           if (_c9Ke9::P64 != 3) goto u9Kei; else goto u9Kei;
       u9Kei: // global
           Sp = Sp + 8;
           call _c9KdQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kdd() //  [R1]
         { info_tbl: [(c9Kdd,
                       label: block_c9Kdd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kdd: // global
           _c9Ke8::P64 = R1 & 7;
           if (_c9Ke8::P64 < 3) goto u9Ked; else goto u9Kee;
       u9Ked: // global
           if (_c9Ke8::P64 < 2) goto u9Kek; else goto u9Kej;
       u9Kek: // global
           Sp = Sp + 8;
           call _c9Ke1() args: 0, res: 0, upd: 0;
       u9Kej: // global
           Sp = Sp + 8;
           call _c9Ke5() args: 0, res: 0, upd: 0;
       u9Kee: // global
           if (_c9Ke8::P64 < 4) goto u9Kem; else goto u9Kem;
       u9Kem: // global
           Sp = Sp + 8;
           call _c9KdQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9KdA() //  [R1]
         { info_tbl: [(c9KdA,
                       label: block_c9KdA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KdA: // global
           _c9Ke7::P64 = R1 & 7;
           if (_c9Ke7::P64 == 3) goto c9KdM; else goto u9Kef;
       c9KdM: // global
           R3 = P64[R1 + 5];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$fOrdBlockReason_$ccompare_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
       u9Kef: // global
           if (_c9Ke7::P64 != 4) goto u9Keo; else goto u9Ken;
       u9Keo: // global
           Sp = Sp + 16;
           call _c9Ke1() args: 0, res: 0, upd: 0;
       u9Ken: // global
           Sp = Sp + 16;
           call _c9KdQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9KdQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KdQ: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KdT() //  [R1]
         { info_tbl: [(c9KdT,
                       label: block_c9KdT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KdT: // global
           if (R1 & 7 == 4) goto u9Kep; else goto u9Keq;
       u9Kep: // global
           Sp = Sp + 8;
           call _c9Ke5() args: 0, res: 0, upd: 0;
       u9Keq: // global
           Sp = Sp + 8;
           call _c9Ke1() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ke5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ke5: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Ke1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ke1: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.801061942 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c<_entry() //  [R2, R3]
         { info_tbl: [(c9Kfw,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kfw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Kfx; else goto c9Kfy;
       c9Kfx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Kfy: // global
           I64[Sp - 16] = block_c9Kfn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9KjD; else goto c9Kfo;
       u9KjD: // global
           call _c9Kfn(R1) args: 0, res: 0, upd: 0;
       c9Kfo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Kfn() //  [R1]
         { info_tbl: [(c9Kfn,
                       label: block_c9Kfn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kfn: // global
           _s9Fzw::P64 = P64[Sp + 8];
           _c9Kfv::P64 = R1 & 7;
           if (_c9Kfv::P64 < 3) goto u9Kj0; else goto u9Kj1;
       u9Kj0: // global
           if (_c9Kfv::P64 < 2) goto c9Kfr; else goto c9Kfs;
       c9Kfr: // global
           I64[Sp + 8] = block_c9KfB_info;
           R1 = _s9Fzw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Kjz; else goto c9KfD;
       u9Kjz: // global
           call _c9KfB(R1) args: 0, res: 0, upd: 0;
       c9KfD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Kfs: // global
           I64[Sp + 8] = block_c9KfY_info;
           R1 = _s9Fzw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KjA; else goto c9Kg0;
       u9KjA: // global
           call _c9KfY(R1) args: 0, res: 0, upd: 0;
       c9Kg0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Kj1: // global
           if (_c9Kfv::P64 < 4) goto c9Kft; else goto c9Kfu;
       c9Kft: // global
           I64[Sp] = block_c9Kgh_info;
           _s9FzC::P64 = P64[R1 + 5];
           R1 = _s9Fzw::P64;
           P64[Sp + 8] = _s9FzC::P64;
           if (R1 & 7 != 0) goto u9KjB; else goto c9Kgj;
       u9KjB: // global
           call _c9Kgh(R1) args: 0, res: 0, upd: 0;
       c9Kgj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Kfu: // global
           I64[Sp + 8] = block_c9KiK_info;
           R1 = _s9Fzw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KjC; else goto c9KiM;
       u9KjC: // global
           call _c9KiK() args: 0, res: 0, upd: 0;
       c9KiM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KfB() //  [R1]
         { info_tbl: [(c9KfB,
                       label: block_c9KfB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KfB: // global
           _c9KiZ::P64 = R1 & 7;
           if (_c9KiZ::P64 < 2) goto u9Kj9; else goto u9Kj2;
       u9Kj9: // global
           Sp = Sp + 8;
           call _c9Kip() args: 0, res: 0, upd: 0;
       u9Kj2: // global
           if (_c9KiZ::P64 != 3) goto u9Kjb; else goto u9Kjb;
       u9Kjb: // global
           Sp = Sp + 8;
           call _c9KiH() args: 0, res: 0, upd: 0;
     }
 },
 _c9KfY() //  [R1]
         { info_tbl: [(c9KfY,
                       label: block_c9KfY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KfY: // global
           _c9KiY::P64 = R1 & 7;
           if (_c9KiY::P64 != 3) goto u9Kj3; else goto u9Kjc;
       u9Kj3: // global
           if (_c9KiY::P64 != 4) goto u9Kje; else goto u9Kjd;
       u9Kje: // global
           Sp = Sp + 8;
           call _c9Kip() args: 0, res: 0, upd: 0;
       u9Kjd: // global
           Sp = Sp + 8;
           goto u9KjH;
       u9Kjc: // global
           Sp = Sp + 8;
           goto u9KjH;
       u9KjH: // global
           call _c9KiH() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kgh() //  [R1]
         { info_tbl: [(c9Kgh,
                       label: block_c9Kgh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kgh: // global
           _c9KiR::P64 = R1 & 7;
           if (_c9KiR::P64 == 3) goto c9Kgu; else goto u9Kj4;
       c9Kgu: // global
           I64[Sp] = block_c9Kgs_info;
           _s9FzE::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FzE::P64;
           if (R1 & 7 != 0) goto u9KjJ; else goto c9Kgv;
       u9KjJ: // global
           call _c9Kgs(R1) args: 0, res: 0, upd: 0;
       c9Kgv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Kj4: // global
           if (_c9KiR::P64 != 4) goto u9Kjg; else goto u9Kjf;
       u9Kjg: // global
           Sp = Sp + 16;
           call _c9Kip() args: 0, res: 0, upd: 0;
       u9Kjf: // global
           Sp = Sp + 16;
           call _c9KiH() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kgs() //  [R1]
         { info_tbl: [(c9Kgs,
                       label: block_c9Kgs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kgs: // global
           _s9FzE::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9KgC;
               case 2 : goto c9Kh8;
               case 3 : goto c9KhA;
               case 4 : goto c9KhY;
               case 5 : goto c9Kii;
               case 6 : goto c9Kiy;
           }
       c9Kiy: // global
           I64[Sp + 8] = block_c9Kiw_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KjR; else goto c9Kiz;
       u9KjR: // global
           call _c9Kiw() args: 0, res: 0, upd: 0;
       c9Kiz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Kii: // global
           I64[Sp + 8] = block_c9Kig_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KjQ; else goto c9Kij;
       u9KjQ: // global
           call _c9Kig(R1) args: 0, res: 0, upd: 0;
       c9Kij: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KhY: // global
           I64[Sp + 8] = block_c9KhW_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KjP; else goto c9KhZ;
       u9KjP: // global
           call _c9KhW(R1) args: 0, res: 0, upd: 0;
       c9KhZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KhA: // global
           I64[Sp + 8] = block_c9Khy_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KjO; else goto c9KhB;
       u9KjO: // global
           call _c9Khy(R1) args: 0, res: 0, upd: 0;
       c9KhB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Kh8: // global
           I64[Sp + 8] = block_c9Kh6_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KjN; else goto c9Kh9;
       u9KjN: // global
           call _c9Kh6(R1) args: 0, res: 0, upd: 0;
       c9Kh9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KgC: // global
           I64[Sp + 8] = block_c9Kgz_info;
           R1 = _s9FzE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KjM; else goto c9KgD;
       u9KjM: // global
           call _c9Kgz(R1) args: 0, res: 0, upd: 0;
       c9KgD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Kiw() //  []
         { info_tbl: [(c9Kiw,
                       label: block_c9Kiw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kiw: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Kig() //  [R1]
         { info_tbl: [(c9Kig,
                       label: block_c9Kig_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kig: // global
           if (R1 & 7 == 6) goto u9Kjh; else goto u9Kji;
       u9Kjh: // global
           Sp = Sp + 8;
           call _c9KiH() args: 0, res: 0, upd: 0;
       u9Kji: // global
           Sp = Sp + 8;
           call _c9Kip() args: 0, res: 0, upd: 0;
     }
 },
 _c9KhW() //  [R1]
         { info_tbl: [(c9KhW,
                       label: block_c9KhW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KhW: // global
           _c9KiU::P64 = R1 & 7;
           if (_c9KiU::P64 != 5) goto u9Kj8; else goto u9Kjj;
       u9Kj8: // global
           if (_c9KiU::P64 != 6) goto u9Kjl; else goto u9Kjk;
       u9Kjl: // global
           Sp = Sp + 8;
           call _c9Kip() args: 0, res: 0, upd: 0;
       u9Kjk: // global
           Sp = Sp + 8;
           goto u9Kk0;
       u9Kjj: // global
           Sp = Sp + 8;
           goto u9Kk0;
       u9Kk0: // global
           call _c9KiH() args: 0, res: 0, upd: 0;
     }
 },
 _c9Khy() //  [R1]
         { info_tbl: [(c9Khy,
                       label: block_c9Khy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Khy: // global
           _c9KiV::P64 = R1 & 7;
           if (_c9KiV::P64 < 4) goto u9Kjm; else goto u9Kj7;
       u9Kjm: // global
           Sp = Sp + 8;
           call _c9Kip() args: 0, res: 0, upd: 0;
       u9Kj7: // global
           if (_c9KiV::P64 != 5) goto u9Kjo; else goto u9Kjo;
       u9Kjo: // global
           Sp = Sp + 8;
           call _c9KiH() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kh6() //  [R1]
         { info_tbl: [(c9Kh6,
                       label: block_c9Kh6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kh6: // global
           _c9KiW::P64 = R1 & 7;
           if (_c9KiW::P64 < 6) goto u9Kj5; else goto u9Kjp;
       u9Kj5: // global
           if (_c9KiW::P64 < 3) goto u9Kjq; else goto u9Kj6;
       u9Kjq: // global
           Sp = Sp + 8;
           call _c9Kip() args: 0, res: 0, upd: 0;
       u9Kj6: // global
           if (_c9KiW::P64 != 4) goto u9Kjs; else goto u9Kjs;
       u9Kjs: // global
           Sp = Sp + 8;
           goto u9KjW;
       u9Kjp: // global
           Sp = Sp + 8;
           goto u9KjW;
       u9KjW: // global
           call _c9KiH() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kgz() //  [R1]
         { info_tbl: [(c9Kgz,
                       label: block_c9Kgz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kgz: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9Kjt;
               case 2, 3, 4, 5, 6 : goto u9Kjy;
           }
       u9Kjy: // global
           Sp = Sp + 8;
           call _c9KiH() args: 0, res: 0, upd: 0;
       u9Kjt: // global
           Sp = Sp + 8;
           call _c9Kip() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kip() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kip: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KiH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KiH: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KiK() //  []
         { info_tbl: [(c9KiK,
                       label: block_c9KiK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KiK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.832027474 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>=_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c9Klv,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Klv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Klw; else goto c9Klx;
       c9Klw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Klx: // global
           I64[Sp - 16] = block_c9Klm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9KpC; else goto c9Kln;
       u9KpC: // global
           call _c9Klm(R1) args: 0, res: 0, upd: 0;
       c9Kln: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Klm() //  [R1]
         { info_tbl: [(c9Klm,
                       label: block_c9Klm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Klm: // global
           _s9FzO::P64 = P64[Sp + 8];
           _c9Klu::P64 = R1 & 7;
           if (_c9Klu::P64 < 3) goto u9KoZ; else goto u9Kp0;
       u9KoZ: // global
           if (_c9Klu::P64 < 2) goto c9Klq; else goto c9Klr;
       c9Klq: // global
           I64[Sp + 8] = block_c9KlA_info;
           R1 = _s9FzO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Kpy; else goto c9KlC;
       u9Kpy: // global
           call _c9KlA(R1) args: 0, res: 0, upd: 0;
       c9KlC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Klr: // global
           I64[Sp + 8] = block_c9KlX_info;
           R1 = _s9FzO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Kpz; else goto c9KlZ;
       u9Kpz: // global
           call _c9KlX(R1) args: 0, res: 0, upd: 0;
       c9KlZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Kp0: // global
           if (_c9Klu::P64 < 4) goto c9Kls; else goto c9Klt;
       c9Kls: // global
           I64[Sp] = block_c9Kmg_info;
           _s9FzU::P64 = P64[R1 + 5];
           R1 = _s9FzO::P64;
           P64[Sp + 8] = _s9FzU::P64;
           if (R1 & 7 != 0) goto u9KpA; else goto c9Kmi;
       u9KpA: // global
           call _c9Kmg(R1) args: 0, res: 0, upd: 0;
       c9Kmi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Klt: // global
           I64[Sp + 8] = block_c9KoJ_info;
           R1 = _s9FzO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KpB; else goto c9KoL;
       u9KpB: // global
           call _c9KoJ() args: 0, res: 0, upd: 0;
       c9KoL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KlA() //  [R1]
         { info_tbl: [(c9KlA,
                       label: block_c9KlA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KlA: // global
           _c9KoY::P64 = R1 & 7;
           if (_c9KoY::P64 < 2) goto u9Kp8; else goto u9Kp1;
       u9Kp8: // global
           Sp = Sp + 8;
           call _c9Koo() args: 0, res: 0, upd: 0;
       u9Kp1: // global
           if (_c9KoY::P64 != 3) goto u9Kpa; else goto u9Kpa;
       u9Kpa: // global
           Sp = Sp + 8;
           call _c9KoG() args: 0, res: 0, upd: 0;
     }
 },
 _c9KlX() //  [R1]
         { info_tbl: [(c9KlX,
                       label: block_c9KlX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KlX: // global
           _c9KoX::P64 = R1 & 7;
           if (_c9KoX::P64 != 3) goto u9Kp2; else goto u9Kpb;
       u9Kp2: // global
           if (_c9KoX::P64 != 4) goto u9Kpd; else goto u9Kpc;
       u9Kpd: // global
           Sp = Sp + 8;
           call _c9Koo() args: 0, res: 0, upd: 0;
       u9Kpc: // global
           Sp = Sp + 8;
           goto u9KpG;
       u9Kpb: // global
           Sp = Sp + 8;
           goto u9KpG;
       u9KpG: // global
           call _c9KoG() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kmg() //  [R1]
         { info_tbl: [(c9Kmg,
                       label: block_c9Kmg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kmg: // global
           _c9KoQ::P64 = R1 & 7;
           if (_c9KoQ::P64 == 3) goto c9Kmt; else goto u9Kp3;
       c9Kmt: // global
           I64[Sp] = block_c9Kmr_info;
           _s9FzW::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FzW::P64;
           if (R1 & 7 != 0) goto u9KpI; else goto c9Kmu;
       u9KpI: // global
           call _c9Kmr(R1) args: 0, res: 0, upd: 0;
       c9Kmu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Kp3: // global
           if (_c9KoQ::P64 != 4) goto u9Kpf; else goto u9Kpe;
       u9Kpf: // global
           Sp = Sp + 16;
           call _c9Koo() args: 0, res: 0, upd: 0;
       u9Kpe: // global
           Sp = Sp + 16;
           call _c9KoG() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kmr() //  [R1]
         { info_tbl: [(c9Kmr,
                       label: block_c9Kmr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kmr: // global
           _s9FzW::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9KmB;
               case 2 : goto c9Kn7;
               case 3 : goto c9Knz;
               case 4 : goto c9KnX;
               case 5 : goto c9Koh;
               case 6 : goto c9Kox;
           }
       c9Kox: // global
           I64[Sp + 8] = block_c9Kov_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KpQ; else goto c9Koy;
       u9KpQ: // global
           call _c9Kov() args: 0, res: 0, upd: 0;
       c9Koy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Koh: // global
           I64[Sp + 8] = block_c9Kof_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KpP; else goto c9Koi;
       u9KpP: // global
           call _c9Kof(R1) args: 0, res: 0, upd: 0;
       c9Koi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KnX: // global
           I64[Sp + 8] = block_c9KnV_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KpO; else goto c9KnY;
       u9KpO: // global
           call _c9KnV(R1) args: 0, res: 0, upd: 0;
       c9KnY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Knz: // global
           I64[Sp + 8] = block_c9Knx_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KpN; else goto c9KnA;
       u9KpN: // global
           call _c9Knx(R1) args: 0, res: 0, upd: 0;
       c9KnA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Kn7: // global
           I64[Sp + 8] = block_c9Kn5_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KpM; else goto c9Kn8;
       u9KpM: // global
           call _c9Kn5(R1) args: 0, res: 0, upd: 0;
       c9Kn8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KmB: // global
           I64[Sp + 8] = block_c9Kmy_info;
           R1 = _s9FzW::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KpL; else goto c9KmC;
       u9KpL: // global
           call _c9Kmy(R1) args: 0, res: 0, upd: 0;
       c9KmC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Kov() //  []
         { info_tbl: [(c9Kov,
                       label: block_c9Kov_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kov: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Kof() //  [R1]
         { info_tbl: [(c9Kof,
                       label: block_c9Kof_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kof: // global
           if (R1 & 7 == 6) goto u9Kpg; else goto u9Kph;
       u9Kpg: // global
           Sp = Sp + 8;
           call _c9KoG() args: 0, res: 0, upd: 0;
       u9Kph: // global
           Sp = Sp + 8;
           call _c9Koo() args: 0, res: 0, upd: 0;
     }
 },
 _c9KnV() //  [R1]
         { info_tbl: [(c9KnV,
                       label: block_c9KnV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KnV: // global
           _c9KoT::P64 = R1 & 7;
           if (_c9KoT::P64 != 5) goto u9Kp7; else goto u9Kpi;
       u9Kp7: // global
           if (_c9KoT::P64 != 6) goto u9Kpk; else goto u9Kpj;
       u9Kpk: // global
           Sp = Sp + 8;
           call _c9Koo() args: 0, res: 0, upd: 0;
       u9Kpj: // global
           Sp = Sp + 8;
           goto u9KpZ;
       u9Kpi: // global
           Sp = Sp + 8;
           goto u9KpZ;
       u9KpZ: // global
           call _c9KoG() args: 0, res: 0, upd: 0;
     }
 },
 _c9Knx() //  [R1]
         { info_tbl: [(c9Knx,
                       label: block_c9Knx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Knx: // global
           _c9KoU::P64 = R1 & 7;
           if (_c9KoU::P64 < 4) goto u9Kpl; else goto u9Kp6;
       u9Kpl: // global
           Sp = Sp + 8;
           call _c9Koo() args: 0, res: 0, upd: 0;
       u9Kp6: // global
           if (_c9KoU::P64 != 5) goto u9Kpn; else goto u9Kpn;
       u9Kpn: // global
           Sp = Sp + 8;
           call _c9KoG() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kn5() //  [R1]
         { info_tbl: [(c9Kn5,
                       label: block_c9Kn5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kn5: // global
           _c9KoV::P64 = R1 & 7;
           if (_c9KoV::P64 < 6) goto u9Kp4; else goto u9Kpo;
       u9Kp4: // global
           if (_c9KoV::P64 < 3) goto u9Kpp; else goto u9Kp5;
       u9Kpp: // global
           Sp = Sp + 8;
           call _c9Koo() args: 0, res: 0, upd: 0;
       u9Kp5: // global
           if (_c9KoV::P64 != 4) goto u9Kpr; else goto u9Kpr;
       u9Kpr: // global
           Sp = Sp + 8;
           goto u9KpV;
       u9Kpo: // global
           Sp = Sp + 8;
           goto u9KpV;
       u9KpV: // global
           call _c9KoG() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kmy() //  [R1]
         { info_tbl: [(c9Kmy,
                       label: block_c9Kmy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kmy: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9Kps;
               case 2, 3, 4, 5, 6 : goto u9Kpx;
           }
       u9Kpx: // global
           Sp = Sp + 8;
           call _c9KoG() args: 0, res: 0, upd: 0;
       u9Kps: // global
           Sp = Sp + 8;
           call _c9Koo() args: 0, res: 0, upd: 0;
     }
 },
 _c9Koo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Koo: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KoG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KoG: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KoJ() //  []
         { info_tbl: [(c9KoJ,
                       label: block_c9KoJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KoJ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.862314425 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c>_entry() //  [R2, R3]
         { info_tbl: [(c9Kru,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kru: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Krv; else goto c9Krw;
       c9Krv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Krw: // global
           I64[Sp - 16] = block_c9Krl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Kvv; else goto c9Krm;
       u9Kvv: // global
           call _c9Krl(R1) args: 0, res: 0, upd: 0;
       c9Krm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Krl() //  [R1]
         { info_tbl: [(c9Krl,
                       label: block_c9Krl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Krl: // global
           _s9FA6::P64 = P64[Sp + 8];
           _c9Krt::P64 = R1 & 7;
           if (_c9Krt::P64 < 3) goto u9KuU; else goto u9KuV;
       u9KuU: // global
           if (_c9Krt::P64 < 2) goto c9Krp; else goto c9Krq;
       c9Krp: // global
           I64[Sp + 8] = block_c9Krz_info;
           R1 = _s9FA6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Kvr; else goto c9KrB;
       u9Kvr: // global
           call _c9Krz() args: 0, res: 0, upd: 0;
       c9KrB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Krq: // global
           I64[Sp + 8] = block_c9KrI_info;
           R1 = _s9FA6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Kvs; else goto c9KrK;
       u9Kvs: // global
           call _c9KrI(R1) args: 0, res: 0, upd: 0;
       c9KrK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9KuV: // global
           if (_c9Krt::P64 < 4) goto c9Krr; else goto c9Krs;
       c9Krr: // global
           I64[Sp] = block_c9Ks5_info;
           _s9FAb::P64 = P64[R1 + 5];
           R1 = _s9FA6::P64;
           P64[Sp + 8] = _s9FAb::P64;
           if (R1 & 7 != 0) goto u9Kvt; else goto c9Ks7;
       u9Kvt: // global
           call _c9Ks5(R1) args: 0, res: 0, upd: 0;
       c9Ks7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Krs: // global
           I64[Sp + 8] = block_c9Kuy_info;
           R1 = _s9FA6::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Kvu; else goto c9KuA;
       u9Kvu: // global
           call _c9Kuy(R1) args: 0, res: 0, upd: 0;
       c9KuA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Krz() //  []
         { info_tbl: [(c9Krz,
                       label: block_c9Krz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Krz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KrI() //  [R1]
         { info_tbl: [(c9KrI,
                       label: block_c9KrI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KrI: // global
           _c9KuT::P64 = R1 & 7;
           if (_c9KuT::P64 < 2) goto u9Kv2; else goto u9KuW;
       u9Kv2: // global
           Sp = Sp + 8;
           call _c9KuG() args: 0, res: 0, upd: 0;
       u9KuW: // global
           if (_c9KuT::P64 != 3) goto u9Kv4; else goto u9Kv4;
       u9Kv4: // global
           Sp = Sp + 8;
           call _c9KuK() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ks5() //  [R1]
         { info_tbl: [(c9Ks5,
                       label: block_c9Ks5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ks5: // global
           _c9KuM::P64 = R1 & 7;
           if (_c9KuM::P64 == 3) goto c9Ksi; else goto u9KuX;
       c9Ksi: // global
           I64[Sp] = block_c9Ksg_info;
           _s9FAd::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FAd::P64;
           if (R1 & 7 != 0) goto u9Kvy; else goto c9Ksj;
       u9Kvy: // global
           call _c9Ksg(R1) args: 0, res: 0, upd: 0;
       c9Ksj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9KuX: // global
           if (_c9KuM::P64 != 4) goto u9Kv6; else goto u9Kv5;
       u9Kv6: // global
           Sp = Sp + 16;
           call _c9KuG() args: 0, res: 0, upd: 0;
       u9Kv5: // global
           Sp = Sp + 16;
           call _c9KuK() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ksg() //  [R1]
         { info_tbl: [(c9Ksg,
                       label: block_c9Ksg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ksg: // global
           _s9FAd::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Ksq;
               case 2 : goto c9KsA;
               case 3 : goto c9Kt6;
               case 4 : goto c9Kty;
               case 5 : goto c9KtW;
               case 6 : goto c9Kug;
           }
       c9Kug: // global
           I64[Sp + 8] = block_c9Kue_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KvG; else goto c9Kuh;
       u9KvG: // global
           call _c9Kue(R1) args: 0, res: 0, upd: 0;
       c9Kuh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KtW: // global
           I64[Sp + 8] = block_c9KtU_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KvF; else goto c9KtX;
       u9KvF: // global
           call _c9KtU(R1) args: 0, res: 0, upd: 0;
       c9KtX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Kty: // global
           I64[Sp + 8] = block_c9Ktw_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KvE; else goto c9Ktz;
       u9KvE: // global
           call _c9Ktw(R1) args: 0, res: 0, upd: 0;
       c9Ktz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Kt6: // global
           I64[Sp + 8] = block_c9Kt4_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KvD; else goto c9Kt7;
       u9KvD: // global
           call _c9Kt4(R1) args: 0, res: 0, upd: 0;
       c9Kt7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KsA: // global
           I64[Sp + 8] = block_c9Ksy_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KvC; else goto c9KsB;
       u9KvC: // global
           call _c9Ksy(R1) args: 0, res: 0, upd: 0;
       c9KsB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Ksq: // global
           I64[Sp + 8] = block_c9Ksn_info;
           R1 = _s9FAd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KvB; else goto c9Ksr;
       u9KvB: // global
           call _c9Ksn() args: 0, res: 0, upd: 0;
       c9Ksr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Kue() //  [R1]
         { info_tbl: [(c9Kue,
                       label: block_c9Kue_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kue: // global
           if (R1 & 7 == 6) goto u9Kv7; else goto u9Kv8;
       u9Kv7: // global
           Sp = Sp + 8;
           call _c9KuK() args: 0, res: 0, upd: 0;
       u9Kv8: // global
           Sp = Sp + 8;
           call _c9KuG() args: 0, res: 0, upd: 0;
     }
 },
 _c9KtU() //  [R1]
         { info_tbl: [(c9KtU,
                       label: block_c9KtU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KtU: // global
           _c9KuP::P64 = R1 & 7;
           if (_c9KuP::P64 != 5) goto u9Kv1; else goto u9Kv9;
       u9Kv1: // global
           if (_c9KuP::P64 != 6) goto u9Kvb; else goto u9Kva;
       u9Kvb: // global
           Sp = Sp + 8;
           call _c9KuG() args: 0, res: 0, upd: 0;
       u9Kva: // global
           Sp = Sp + 8;
           goto u9KvP;
       u9Kv9: // global
           Sp = Sp + 8;
           goto u9KvP;
       u9KvP: // global
           call _c9KuK() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ktw() //  [R1]
         { info_tbl: [(c9Ktw,
                       label: block_c9Ktw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ktw: // global
           _c9KuQ::P64 = R1 & 7;
           if (_c9KuQ::P64 < 4) goto u9Kvc; else goto u9Kv0;
       u9Kvc: // global
           Sp = Sp + 8;
           call _c9KuG() args: 0, res: 0, upd: 0;
       u9Kv0: // global
           if (_c9KuQ::P64 != 5) goto u9Kve; else goto u9Kve;
       u9Kve: // global
           Sp = Sp + 8;
           call _c9KuK() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kt4() //  [R1]
         { info_tbl: [(c9Kt4,
                       label: block_c9Kt4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kt4: // global
           _c9KuR::P64 = R1 & 7;
           if (_c9KuR::P64 < 6) goto u9KuY; else goto u9Kvf;
       u9KuY: // global
           if (_c9KuR::P64 < 3) goto u9Kvg; else goto u9KuZ;
       u9Kvg: // global
           Sp = Sp + 8;
           call _c9KuG() args: 0, res: 0, upd: 0;
       u9KuZ: // global
           if (_c9KuR::P64 != 4) goto u9Kvi; else goto u9Kvi;
       u9Kvi: // global
           Sp = Sp + 8;
           goto u9KvL;
       u9Kvf: // global
           Sp = Sp + 8;
           goto u9KvL;
       u9KvL: // global
           call _c9KuK() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ksy() //  [R1]
         { info_tbl: [(c9Ksy,
                       label: block_c9Ksy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ksy: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9Kvj;
               case 2, 3, 4, 5, 6 : goto u9Kvo;
           }
       u9Kvo: // global
           Sp = Sp + 8;
           call _c9KuK() args: 0, res: 0, upd: 0;
       u9Kvj: // global
           Sp = Sp + 8;
           call _c9KuG() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ksn() //  []
         { info_tbl: [(c9Ksn,
                       label: block_c9Ksn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ksn: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Kuy() //  [R1]
         { info_tbl: [(c9Kuy,
                       label: block_c9Kuy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kuy: // global
           if (R1 & 7 == 4) goto u9Kvp; else goto u9Kvq;
       u9Kvp: // global
           Sp = Sp + 8;
           call _c9KuK() args: 0, res: 0, upd: 0;
       u9Kvq: // global
           Sp = Sp + 8;
           call _c9KuG() args: 0, res: 0, upd: 0;
     }
 },
 _c9KuK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KuK: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KuG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KuG: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.892944276 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<=_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c9Kxn,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kxn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Kxo; else goto c9Kxp;
       c9Kxo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Kxp: // global
           I64[Sp - 16] = block_c9Kxe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9KBo; else goto c9Kxf;
       u9KBo: // global
           call _c9Kxe(R1) args: 0, res: 0, upd: 0;
       c9Kxf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Kxe() //  [R1]
         { info_tbl: [(c9Kxe,
                       label: block_c9Kxe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kxe: // global
           _s9FAn::P64 = P64[Sp + 8];
           _c9Kxm::P64 = R1 & 7;
           if (_c9Kxm::P64 < 3) goto u9KAN; else goto u9KAO;
       u9KAN: // global
           if (_c9Kxm::P64 < 2) goto c9Kxi; else goto c9Kxj;
       c9Kxi: // global
           I64[Sp + 8] = block_c9Kxs_info;
           R1 = _s9FAn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KBk; else goto c9Kxu;
       u9KBk: // global
           call _c9Kxs() args: 0, res: 0, upd: 0;
       c9Kxu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Kxj: // global
           I64[Sp + 8] = block_c9KxB_info;
           R1 = _s9FAn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KBl; else goto c9KxD;
       u9KBl: // global
           call _c9KxB(R1) args: 0, res: 0, upd: 0;
       c9KxD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9KAO: // global
           if (_c9Kxm::P64 < 4) goto c9Kxk; else goto c9Kxl;
       c9Kxk: // global
           I64[Sp] = block_c9KxY_info;
           _s9FAs::P64 = P64[R1 + 5];
           R1 = _s9FAn::P64;
           P64[Sp + 8] = _s9FAs::P64;
           if (R1 & 7 != 0) goto u9KBm; else goto c9Ky0;
       u9KBm: // global
           call _c9KxY(R1) args: 0, res: 0, upd: 0;
       c9Ky0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Kxl: // global
           I64[Sp + 8] = block_c9KAr_info;
           R1 = _s9FAn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KBn; else goto c9KAt;
       u9KBn: // global
           call _c9KAr(R1) args: 0, res: 0, upd: 0;
       c9KAt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Kxs() //  []
         { info_tbl: [(c9Kxs,
                       label: block_c9Kxs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kxs: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KxB() //  [R1]
         { info_tbl: [(c9KxB,
                       label: block_c9KxB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KxB: // global
           _c9KAM::P64 = R1 & 7;
           if (_c9KAM::P64 < 2) goto u9KAV; else goto u9KAP;
       u9KAV: // global
           Sp = Sp + 8;
           call _c9KAz() args: 0, res: 0, upd: 0;
       u9KAP: // global
           if (_c9KAM::P64 != 3) goto u9KAX; else goto u9KAX;
       u9KAX: // global
           Sp = Sp + 8;
           call _c9KAD() args: 0, res: 0, upd: 0;
     }
 },
 _c9KxY() //  [R1]
         { info_tbl: [(c9KxY,
                       label: block_c9KxY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KxY: // global
           _c9KAF::P64 = R1 & 7;
           if (_c9KAF::P64 == 3) goto c9Kyb; else goto u9KAQ;
       c9Kyb: // global
           I64[Sp] = block_c9Ky9_info;
           _s9FAu::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FAu::P64;
           if (R1 & 7 != 0) goto u9KBr; else goto c9Kyc;
       u9KBr: // global
           call _c9Ky9(R1) args: 0, res: 0, upd: 0;
       c9Kyc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9KAQ: // global
           if (_c9KAF::P64 != 4) goto u9KAZ; else goto u9KAY;
       u9KAZ: // global
           Sp = Sp + 16;
           call _c9KAz() args: 0, res: 0, upd: 0;
       u9KAY: // global
           Sp = Sp + 16;
           call _c9KAD() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ky9() //  [R1]
         { info_tbl: [(c9Ky9,
                       label: block_c9Ky9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ky9: // global
           _s9FAu::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Kyj;
               case 2 : goto c9Kyt;
               case 3 : goto c9KyZ;
               case 4 : goto c9Kzr;
               case 5 : goto c9KzP;
               case 6 : goto c9KA9;
           }
       c9KA9: // global
           I64[Sp + 8] = block_c9KA7_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KBz; else goto c9KAa;
       u9KBz: // global
           call _c9KA7(R1) args: 0, res: 0, upd: 0;
       c9KAa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KzP: // global
           I64[Sp + 8] = block_c9KzN_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KBy; else goto c9KzQ;
       u9KBy: // global
           call _c9KzN(R1) args: 0, res: 0, upd: 0;
       c9KzQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Kzr: // global
           I64[Sp + 8] = block_c9Kzp_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KBx; else goto c9Kzs;
       u9KBx: // global
           call _c9Kzp(R1) args: 0, res: 0, upd: 0;
       c9Kzs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KyZ: // global
           I64[Sp + 8] = block_c9KyX_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KBw; else goto c9Kz0;
       u9KBw: // global
           call _c9KyX(R1) args: 0, res: 0, upd: 0;
       c9Kz0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Kyt: // global
           I64[Sp + 8] = block_c9Kyr_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KBv; else goto c9Kyu;
       u9KBv: // global
           call _c9Kyr(R1) args: 0, res: 0, upd: 0;
       c9Kyu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Kyj: // global
           I64[Sp + 8] = block_c9Kyg_info;
           R1 = _s9FAu::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KBu; else goto c9Kyk;
       u9KBu: // global
           call _c9Kyg() args: 0, res: 0, upd: 0;
       c9Kyk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KA7() //  [R1]
         { info_tbl: [(c9KA7,
                       label: block_c9KA7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KA7: // global
           if (R1 & 7 == 6) goto u9KB0; else goto u9KB1;
       u9KB0: // global
           Sp = Sp + 8;
           call _c9KAD() args: 0, res: 0, upd: 0;
       u9KB1: // global
           Sp = Sp + 8;
           call _c9KAz() args: 0, res: 0, upd: 0;
     }
 },
 _c9KzN() //  [R1]
         { info_tbl: [(c9KzN,
                       label: block_c9KzN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KzN: // global
           _c9KAI::P64 = R1 & 7;
           if (_c9KAI::P64 != 5) goto u9KAU; else goto u9KB2;
       u9KAU: // global
           if (_c9KAI::P64 != 6) goto u9KB4; else goto u9KB3;
       u9KB4: // global
           Sp = Sp + 8;
           call _c9KAz() args: 0, res: 0, upd: 0;
       u9KB3: // global
           Sp = Sp + 8;
           goto u9KBI;
       u9KB2: // global
           Sp = Sp + 8;
           goto u9KBI;
       u9KBI: // global
           call _c9KAD() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kzp() //  [R1]
         { info_tbl: [(c9Kzp,
                       label: block_c9Kzp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kzp: // global
           _c9KAJ::P64 = R1 & 7;
           if (_c9KAJ::P64 < 4) goto u9KB5; else goto u9KAT;
       u9KB5: // global
           Sp = Sp + 8;
           call _c9KAz() args: 0, res: 0, upd: 0;
       u9KAT: // global
           if (_c9KAJ::P64 != 5) goto u9KB7; else goto u9KB7;
       u9KB7: // global
           Sp = Sp + 8;
           call _c9KAD() args: 0, res: 0, upd: 0;
     }
 },
 _c9KyX() //  [R1]
         { info_tbl: [(c9KyX,
                       label: block_c9KyX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KyX: // global
           _c9KAK::P64 = R1 & 7;
           if (_c9KAK::P64 < 6) goto u9KAR; else goto u9KB8;
       u9KAR: // global
           if (_c9KAK::P64 < 3) goto u9KB9; else goto u9KAS;
       u9KB9: // global
           Sp = Sp + 8;
           call _c9KAz() args: 0, res: 0, upd: 0;
       u9KAS: // global
           if (_c9KAK::P64 != 4) goto u9KBb; else goto u9KBb;
       u9KBb: // global
           Sp = Sp + 8;
           goto u9KBE;
       u9KB8: // global
           Sp = Sp + 8;
           goto u9KBE;
       u9KBE: // global
           call _c9KAD() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kyr() //  [R1]
         { info_tbl: [(c9Kyr,
                       label: block_c9Kyr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kyr: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9KBc;
               case 2, 3, 4, 5, 6 : goto u9KBh;
           }
       u9KBh: // global
           Sp = Sp + 8;
           call _c9KAD() args: 0, res: 0, upd: 0;
       u9KBc: // global
           Sp = Sp + 8;
           call _c9KAz() args: 0, res: 0, upd: 0;
     }
 },
 _c9Kyg() //  []
         { info_tbl: [(c9Kyg,
                       label: block_c9Kyg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Kyg: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KAr() //  [R1]
         { info_tbl: [(c9KAr,
                       label: block_c9KAr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KAr: // global
           if (R1 & 7 == 4) goto u9KBi; else goto u9KBj;
       u9KBi: // global
           Sp = Sp + 8;
           call _c9KAD() args: 0, res: 0, upd: 0;
       u9KBj: // global
           Sp = Sp + 8;
           call _c9KAz() args: 0, res: 0, upd: 0;
     }
 },
 _c9KAD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KAD: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KAz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KAz: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.924003176 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmax_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c9KDg,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KDg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9KDh; else goto c9KDi;
       c9KDh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9KDi: // global
           I64[Sp - 16] = block_c9KD7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9KGV; else goto c9KD8;
       u9KGV: // global
           call _c9KD7(R1) args: 0, res: 0, upd: 0;
       c9KD8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KD7() //  [R1]
         { info_tbl: [(c9KD7,
                       label: block_c9KD7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KD7: // global
           _s9FAE::P64 = P64[Sp + 8];
           _c9KDf::P64 = R1 & 7;
           if (_c9KDf::P64 < 3) goto u9KGp; else goto u9KGq;
       u9KGp: // global
           if (_c9KDf::P64 < 2) goto c9KDb; else goto c9KDc;
       c9KDb: // global
           R1 = _s9FAE::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9KDc: // global
           I64[Sp + 8] = block_c9KDo_info;
           R1 = _s9FAE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KGS; else goto c9KDq;
       u9KGS: // global
           call _c9KDo(R1) args: 0, res: 0, upd: 0;
       c9KDq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9KGq: // global
           if (_c9KDf::P64 < 4) goto c9KDd; else goto c9KDe;
       c9KDd: // global
           I64[Sp - 8] = block_c9KDH_info;
           _s9FAF::P64 = R1;
           _s9FAI::P64 = P64[R1 + 5];
           R1 = _s9FAE::P64;
           P64[Sp] = _s9FAI::P64;
           P64[Sp + 8] = _s9FAF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9KGT; else goto c9KDJ;
       u9KGT: // global
           call _c9KDH(R1) args: 0, res: 0, upd: 0;
       c9KDJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KDe: // global
           I64[Sp + 8] = block_c9KGa_info;
           R1 = _s9FAE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KGU; else goto c9KGc;
       u9KGU: // global
           call _c9KGa() args: 0, res: 0, upd: 0;
       c9KGc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KDo() //  [R1]
         { info_tbl: [(c9KDo,
                       label: block_c9KDo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KDo: // global
           _c9KGo::P64 = R1 & 7;
           if (_c9KGo::P64 == 3) goto c9KDA; else goto u9KGr;
       c9KDA: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9KGr: // global
           if (_c9KGo::P64 != 4) goto c9KDw; else goto u9KGx;
       c9KDw: // global
           R1 = GHC.Conc.Sync.ThreadFinished_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9KGx: // global
           Sp = Sp + 8;
           call _c9KG7() args: 0, res: 0, upd: 0;
     }
 },
 _c9KDH() //  [R1]
         { info_tbl: [(c9KDH,
                       label: block_c9KDH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KDH: // global
           _c9KGh::P64 = R1 & 7;
           if (_c9KGh::P64 == 3) goto c9KDU; else goto u9KGs;
       c9KDU: // global
           I64[Sp - 8] = block_c9KDS_info;
           _s9FAJ::P64 = R1;
           _s9FAK::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9FAK::P64;
           P64[Sp + 8] = _s9FAJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9KGX; else goto c9KDV;
       u9KGX: // global
           call _c9KDS(R1) args: 0, res: 0, upd: 0;
       c9KDV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9KGs: // global
           if (_c9KGh::P64 != 4) goto u9KGz; else goto u9KGy;
       u9KGz: // global
           Sp = Sp + 16;
           call _c9KFZ() args: 0, res: 0, upd: 0;
       u9KGy: // global
           Sp = Sp + 24;
           call _c9KG7() args: 0, res: 0, upd: 0;
     }
 },
 _c9KDS() //  [R1]
         { info_tbl: [(c9KDS,
                       label: block_c9KDS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KDS: // global
           _s9FAK::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9KE2;
               case 2 : goto c9KEc;
               case 3 : goto c9KEI;
               case 4 : goto c9KFa;
               case 5 : goto c9KFy;
               case 6 : goto c9KFS;
           }
       c9KFS: // global
           I64[Sp + 8] = block_c9KFQ_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KH5; else goto c9KFT;
       u9KH5: // global
           call _c9KFQ(R1) args: 0, res: 0, upd: 0;
       c9KFT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KFy: // global
           I64[Sp + 8] = block_c9KFw_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KH4; else goto c9KFz;
       u9KH4: // global
           call _c9KFw(R1) args: 0, res: 0, upd: 0;
       c9KFz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KFa: // global
           I64[Sp + 8] = block_c9KF8_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KH3; else goto c9KFb;
       u9KH3: // global
           call _c9KF8(R1) args: 0, res: 0, upd: 0;
       c9KFb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KEI: // global
           I64[Sp + 8] = block_c9KEG_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KH2; else goto c9KEJ;
       u9KH2: // global
           call _c9KEG(R1) args: 0, res: 0, upd: 0;
       c9KEJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KEc: // global
           I64[Sp + 8] = block_c9KEa_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KH1; else goto c9KEd;
       u9KH1: // global
           call _c9KEa(R1) args: 0, res: 0, upd: 0;
       c9KEd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KE2: // global
           I64[Sp + 8] = block_c9KDZ_info;
           R1 = _s9FAK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KH0; else goto c9KE3;
       u9KH0: // global
           call _c9KDZ() args: 0, res: 0, upd: 0;
       c9KE3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KFQ() //  [R1]
         { info_tbl: [(c9KFQ,
                       label: block_c9KFQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KFQ: // global
           if (R1 & 7 == 6) goto u9KGA; else goto u9KGB;
       u9KGA: // global
           Sp = Sp + 8;
           call _c9KG3() args: 0, res: 0, upd: 0;
       u9KGB: // global
           Sp = Sp + 16;
           call _c9KFZ() args: 0, res: 0, upd: 0;
     }
 },
 _c9KFw() //  [R1]
         { info_tbl: [(c9KFw,
                       label: block_c9KFw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KFw: // global
           _c9KGk::P64 = R1 & 7;
           if (_c9KGk::P64 != 5) goto u9KGw; else goto u9KGC;
       u9KGw: // global
           if (_c9KGk::P64 != 6) goto u9KGE; else goto u9KGD;
       u9KGE: // global
           Sp = Sp + 16;
           call _c9KFZ() args: 0, res: 0, upd: 0;
       u9KGD: // global
           Sp = Sp + 8;
           goto u9KHe;
       u9KGC: // global
           Sp = Sp + 8;
           goto u9KHe;
       u9KHe: // global
           call _c9KG3() args: 0, res: 0, upd: 0;
     }
 },
 _c9KF8() //  [R1]
         { info_tbl: [(c9KF8,
                       label: block_c9KF8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KF8: // global
           _c9KGl::P64 = R1 & 7;
           if (_c9KGl::P64 < 4) goto u9KGF; else goto u9KGv;
       u9KGF: // global
           Sp = Sp + 16;
           call _c9KFZ() args: 0, res: 0, upd: 0;
       u9KGv: // global
           if (_c9KGl::P64 != 5) goto u9KGH; else goto u9KGH;
       u9KGH: // global
           Sp = Sp + 8;
           call _c9KG3() args: 0, res: 0, upd: 0;
     }
 },
 _c9KEG() //  [R1]
         { info_tbl: [(c9KEG,
                       label: block_c9KEG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KEG: // global
           _c9KGm::P64 = R1 & 7;
           if (_c9KGm::P64 < 6) goto u9KGt; else goto u9KGI;
       u9KGt: // global
           if (_c9KGm::P64 < 3) goto u9KGJ; else goto u9KGu;
       u9KGJ: // global
           Sp = Sp + 16;
           call _c9KFZ() args: 0, res: 0, upd: 0;
       u9KGu: // global
           if (_c9KGm::P64 != 4) goto u9KGL; else goto u9KGL;
       u9KGL: // global
           Sp = Sp + 8;
           goto u9KHa;
       u9KGI: // global
           Sp = Sp + 8;
           goto u9KHa;
       u9KHa: // global
           call _c9KG3() args: 0, res: 0, upd: 0;
     }
 },
 _c9KEa() //  [R1]
         { info_tbl: [(c9KEa,
                       label: block_c9KEa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KEa: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9KGM;
               case 2, 3, 4, 5, 6 : goto u9KGR;
           }
       u9KGR: // global
           Sp = Sp + 8;
           call _c9KG3() args: 0, res: 0, upd: 0;
       u9KGM: // global
           Sp = Sp + 16;
           call _c9KFZ() args: 0, res: 0, upd: 0;
     }
 },
 _c9KG3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KG3: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KDZ() //  []
         { info_tbl: [(c9KDZ,
                       label: block_c9KDZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KDZ: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KFZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KFZ: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KG7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KG7: // global
           R1 = GHC.Conc.Sync.ThreadDied_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KGa() //  []
         { info_tbl: [(c9KGa,
                       label: block_c9KGa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KGa: // global
           R1 = GHC.Conc.Sync.ThreadDied_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.954325509 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmin_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c9KIP,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KIP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9KIQ; else goto c9KIR;
       c9KIQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9KIR: // global
           I64[Sp - 16] = block_c9KIG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9KMx; else goto c9KIH;
       u9KMx: // global
           call _c9KIG(R1) args: 0, res: 0, upd: 0;
       c9KIH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KIG() //  [R1]
         { info_tbl: [(c9KIG,
                       label: block_c9KIG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KIG: // global
           _s9FAU::P64 = P64[Sp + 8];
           _c9KIO::P64 = R1 & 7;
           if (_c9KIO::P64 < 3) goto u9KM2; else goto u9KM3;
       u9KM2: // global
           if (_c9KIO::P64 < 2) goto c9KIK; else goto c9KIL;
       c9KIK: // global
           I64[Sp + 8] = block_c9KIU_info;
           R1 = _s9FAU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KMu; else goto c9KIW;
       u9KMu: // global
           call _c9KIU() args: 0, res: 0, upd: 0;
       c9KIW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KIL: // global
           I64[Sp + 8] = block_c9KJ3_info;
           R1 = _s9FAU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KMv; else goto c9KJ5;
       u9KMv: // global
           call _c9KJ3(R1) args: 0, res: 0, upd: 0;
       c9KJ5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9KM3: // global
           if (_c9KIO::P64 < 4) goto c9KIM; else goto c9KIN;
       c9KIM: // global
           I64[Sp - 8] = block_c9KJq_info;
           _s9FAV::P64 = R1;
           _s9FAZ::P64 = P64[R1 + 5];
           R1 = _s9FAU::P64;
           P64[Sp] = _s9FAZ::P64;
           P64[Sp + 8] = _s9FAV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9KMw; else goto c9KJs;
       u9KMw: // global
           call _c9KJq(R1) args: 0, res: 0, upd: 0;
       c9KJs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KIN: // global
           R1 = _s9FAU::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KIU() //  []
         { info_tbl: [(c9KIU,
                       label: block_c9KIU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KIU: // global
           R1 = GHC.Conc.Sync.ThreadRunning_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KJ3() //  [R1]
         { info_tbl: [(c9KJ3,
                       label: block_c9KJ3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KJ3: // global
           _c9KM1::P64 = R1 & 7;
           if (_c9KM1::P64 < 2) goto c9KJb; else goto u9KM4;
       c9KJb: // global
           R1 = GHC.Conc.Sync.ThreadRunning_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9KM4: // global
           if (_c9KM1::P64 != 3) goto c9KJn; else goto c9KJn;
       c9KJn: // global
           R1 = GHC.Conc.Sync.ThreadFinished_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KJq() //  [R1]
         { info_tbl: [(c9KJq,
                       label: block_c9KJq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KJq: // global
           _c9KLU::P64 = R1 & 7;
           if (_c9KLU::P64 == 3) goto c9KJD; else goto u9KM5;
       c9KJD: // global
           I64[Sp - 8] = block_c9KJB_info;
           _s9FB0::P64 = R1;
           _s9FB1::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9FB1::P64;
           P64[Sp + 8] = _s9FB0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9KMy; else goto c9KJE;
       u9KMy: // global
           call _c9KJB(R1) args: 0, res: 0, upd: 0;
       c9KJE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9KM5: // global
           if (_c9KLU::P64 == 4) goto u9KMa; else goto u9KMb;
       u9KMa: // global
           Sp = Sp + 16;
           call _c9KLQ() args: 0, res: 0, upd: 0;
       u9KMb: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c9KLI() args: 0, res: 0, upd: 0;
     }
 },
 _c9KJB() //  [R1]
         { info_tbl: [(c9KJB,
                       label: block_c9KJB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KJB: // global
           _s9FB1::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9KJL;
               case 2 : goto c9KJV;
               case 3 : goto c9KKr;
               case 4 : goto c9KKT;
               case 5 : goto c9KLh;
               case 6 : goto c9KLB;
           }
       c9KLB: // global
           I64[Sp + 8] = block_c9KLz_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KMG; else goto c9KLC;
       u9KMG: // global
           call _c9KLz(R1) args: 0, res: 0, upd: 0;
       c9KLC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KLh: // global
           I64[Sp + 8] = block_c9KLf_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KMF; else goto c9KLi;
       u9KMF: // global
           call _c9KLf(R1) args: 0, res: 0, upd: 0;
       c9KLi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KKT: // global
           I64[Sp + 8] = block_c9KKR_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KME; else goto c9KKU;
       u9KME: // global
           call _c9KKR(R1) args: 0, res: 0, upd: 0;
       c9KKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KKr: // global
           I64[Sp + 8] = block_c9KKp_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KMD; else goto c9KKs;
       u9KMD: // global
           call _c9KKp(R1) args: 0, res: 0, upd: 0;
       c9KKs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KJV: // global
           I64[Sp + 8] = block_c9KJT_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9KMC; else goto c9KJW;
       u9KMC: // global
           call _c9KJT(R1) args: 0, res: 0, upd: 0;
       c9KJW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9KJL: // global
           I64[Sp + 16] = block_c9KJI_info;
           R1 = _s9FB1::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u9KMB; else goto c9KJM;
       u9KMB: // global
           call _c9KJI() args: 0, res: 0, upd: 0;
       c9KJM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KLz() //  [R1]
         { info_tbl: [(c9KLz,
                       label: block_c9KLz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KLz: // global
           if (R1 & 7 == 6) goto u9KMc; else goto u9KMd;
       u9KMc: // global
           Sp = Sp + 16;
           call _c9KLQ() args: 0, res: 0, upd: 0;
       u9KMd: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9KLI() args: 0, res: 0, upd: 0;
     }
 },
 _c9KLf() //  [R1]
         { info_tbl: [(c9KLf,
                       label: block_c9KLf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KLf: // global
           _c9KLX::P64 = R1 & 7;
           if (_c9KLX::P64 != 5) goto u9KM9; else goto u9KMe;
       u9KM9: // global
           if (_c9KLX::P64 != 6) goto u9KMg; else goto u9KMf;
       u9KMg: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9KLI() args: 0, res: 0, upd: 0;
       u9KMf: // global
           Sp = Sp + 16;
           goto u9KMP;
       u9KMe: // global
           Sp = Sp + 16;
           goto u9KMP;
       u9KMP: // global
           call _c9KLQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9KKR() //  [R1]
         { info_tbl: [(c9KKR,
                       label: block_c9KKR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KKR: // global
           _c9KLY::P64 = R1 & 7;
           if (_c9KLY::P64 < 4) goto u9KMh; else goto u9KM8;
       u9KMh: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9KLI() args: 0, res: 0, upd: 0;
       u9KM8: // global
           if (_c9KLY::P64 != 5) goto u9KMj; else goto u9KMj;
       u9KMj: // global
           Sp = Sp + 16;
           call _c9KLQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9KKp() //  [R1]
         { info_tbl: [(c9KKp,
                       label: block_c9KKp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KKp: // global
           _c9KLZ::P64 = R1 & 7;
           if (_c9KLZ::P64 < 6) goto u9KM6; else goto u9KMk;
       u9KM6: // global
           if (_c9KLZ::P64 < 3) goto u9KMl; else goto u9KM7;
       u9KMl: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9KLI() args: 0, res: 0, upd: 0;
       u9KM7: // global
           if (_c9KLZ::P64 != 4) goto u9KMn; else goto u9KMn;
       u9KMn: // global
           Sp = Sp + 16;
           goto u9KML;
       u9KMk: // global
           Sp = Sp + 16;
           goto u9KML;
       u9KML: // global
           call _c9KLQ() args: 0, res: 0, upd: 0;
     }
 },
 _c9KJT() //  [R1]
         { info_tbl: [(c9KJT,
                       label: block_c9KJT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KJT: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9KMo;
               case 2, 3, 4, 5, 6 : goto u9KMt;
           }
       u9KMt: // global
           Sp = Sp + 16;
           call _c9KLQ() args: 0, res: 0, upd: 0;
       u9KMo: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9KLI() args: 0, res: 0, upd: 0;
     }
 },
 _c9KJI() //  []
         { info_tbl: [(c9KJI,
                       label: block_c9KJI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KJI: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KLQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KLQ: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9KLI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KLI: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.981796358 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Conc.Sync.$fEqThreadStatus_closure+1;
         const GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.983631693 UTC

[section ""cstring" . GHC.Conc.Sync.$trModule4_bytes" {
     GHC.Conc.Sync.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.985308507 UTC

[section ""data" . GHC.Conc.Sync.$trModule3_closure" {
     GHC.Conc.Sync.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.98696167 UTC

[section ""cstring" . GHC.Conc.Sync.$trModule2_bytes" {
     GHC.Conc.Sync.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,83,121,110,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.989138865 UTC

[section ""data" . GHC.Conc.Sync.$trModule1_closure" {
     GHC.Conc.Sync.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.990871202 UTC

[section ""data" . GHC.Conc.Sync.$trModule_closure" {
     GHC.Conc.Sync.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.Sync.$trModule3_closure+1;
         const GHC.Conc.Sync.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.992606817 UTC

[section ""data" . $krep_r9FuN_closure" {
     $krep_r9FuN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc'LiftedRep_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.994879459 UTC

[section ""data" . $krep1_r9FuO_closure" {
     $krep1_r9FuO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRuntimeRep_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.99656382 UTC

[section ""data" . $krep2_r9FuP_closure" {
     $krep2_r9FuP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRealWorld_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.998234353 UTC

[section ""data" . $krep3_r9FuQ_closure" {
     $krep3_r9FuQ_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:46.999838898 UTC

[section ""data" . $krep4_r9FuR_closure" {
     $krep4_r9FuR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcThreadId#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.001464508 UTC

[section ""data" . $krep5_r9FuS_closure" {
     $krep5_r9FuS_closure:
         const :_con_info;
         const $krep3_r9FuQ_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.003144557 UTC

[section ""data" . $krep6_r9FuT_closure" {
     $krep6_r9FuT_closure:
         const :_con_info;
         const $krep2_r9FuP_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.004864146 UTC

[section ""data" . $krep7_r9FuU_closure" {
     $krep7_r9FuU_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcTVar#_closure;
         const $krep6_r9FuT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.006875481 UTC

[section ""data" . $krep8_r9FuV_closure" {
     $krep8_r9FuV_closure:
         const :_con_info;
         const $krep2_r9FuP_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.008510876 UTC

[section ""data" . $krep9_r9FuW_closure" {
     $krep9_r9FuW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcState#_closure;
         const $krep8_r9FuV_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.010236827 UTC

[section ""data" . $krep10_r9FuX_closure" {
     $krep10_r9FuX_closure:
         const :_con_info;
         const $krep1_r9FuO_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.011879181 UTC

[section ""data" . $krep11_r9FuY_closure" {
     $krep11_r9FuY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc'[]_closure;
         const $krep10_r9FuX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.014088589 UTC

[section ""data" . $krep12_r9FuZ_closure" {
     $krep12_r9FuZ_closure:
         const :_con_info;
         const $krep11_r9FuY_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.015850215 UTC

[section ""data" . $krep13_r9Fv0_closure" {
     $krep13_r9Fv0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc'TupleRep_closure;
         const $krep12_r9FuZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.017878951 UTC

[section ""data" . $krep14_r9Fv1_closure" {
     $krep14_r9Fv1_closure:
         const :_con_info;
         const $krep9_r9FuW_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.019531762 UTC

[section ""data" . $krep15_r9Fv2_closure" {
     $krep15_r9Fv2_closure:
         const :_con_info;
         const $krep_r9FuN_closure+1;
         const $krep14_r9Fv1_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.021218104 UTC

[section ""data" . $krep16_r9Fv3_closure" {
     $krep16_r9Fv3_closure:
         const :_con_info;
         const $krep13_r9Fv0_closure+1;
         const $krep15_r9Fv2_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.022848225 UTC

[section ""data" . $krep17_r9Fv4_closure" {
     $krep17_r9Fv4_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc(#,#)_closure;
         const $krep16_r9Fv3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.024509953 UTC

[section ""data" . $krep18_r9Fv5_closure" {
     $krep18_r9Fv5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r9FuW_closure+1;
         const $krep17_r9Fv4_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.026225717 UTC

[section ""cstring" . GHC.Conc.Sync.$tcThreadId2_bytes" {
     GHC.Conc.Sync.$tcThreadId2_bytes:
         I8[] [84,104,114,101,97,100,73,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.027807781 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadId1_closure" {
     GHC.Conc.Sync.$tcThreadId1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcThreadId2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.029884571 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadId_closure" {
     GHC.Conc.Sync.$tcThreadId_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcThreadId1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16775948407395805744;
         const 12520674293648100702;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.031615082 UTC

[section ""data" . $krep19_r9Fv6_closure" {
     $krep19_r9Fv6_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcThreadId_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.033342313 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadId1_closure" {
     GHC.Conc.Sync.$tc'ThreadId1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r9FuR_closure+1;
         const $krep19_r9Fv6_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.035004328 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadId3_bytes" {
     GHC.Conc.Sync.$tc'ThreadId3_bytes:
         I8[] [39,84,104,114,101,97,100,73,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.036672627 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadId2_closure" {
     GHC.Conc.Sync.$tc'ThreadId2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadId3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.038346103 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadId_closure" {
     GHC.Conc.Sync.$tc'ThreadId_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadId2_closure+1;
         const GHC.Conc.Sync.$tc'ThreadId1_closure+4;
         const 18342150043682338300;
         const 5104860271509165481;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.04064583 UTC

[section ""cstring" . GHC.Conc.Sync.$tcBlockReason2_bytes" {
     GHC.Conc.Sync.$tcBlockReason2_bytes:
         I8[] [66,108,111,99,107,82,101,97,115,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.042699117 UTC

[section ""data" . GHC.Conc.Sync.$tcBlockReason1_closure" {
     GHC.Conc.Sync.$tcBlockReason1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcBlockReason2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.044374736 UTC

[section ""data" . GHC.Conc.Sync.$tcBlockReason_closure" {
     GHC.Conc.Sync.$tcBlockReason_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcBlockReason1_closure+1;
         const GHC.Types.krep$*_closure;
         const 13301038780413995570;
         const 11021250300446969031;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.046132033 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcBlockReason_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.047780944 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnMVar2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnMVar2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.049408522 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnMVar1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnMVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.051041974 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnMVar_closure" {
     GHC.Conc.Sync.$tc'BlockedOnMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnMVar1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 6633002816895506850;
         const 13520604374172074732;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.052796534 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnBlackHole3_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole3_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,66,108,97,99,107,72,111,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.0544433 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnBlackHole2_closure" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.056088164 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnBlackHole_closure" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole2_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 9499731398899925739;
         const 7296688042620961692;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.057903966 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnException2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnException2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.059501883 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnException1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnException1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnException2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.061197782 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnException_closure" {
     GHC.Conc.Sync.$tc'BlockedOnException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnException1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 16834505563200403543;
         const 10899729493106152581;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.063403453 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnSTM2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnSTM2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.065631595 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnSTM1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnSTM1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnSTM2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.06725244 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnSTM_closure" {
     GHC.Conc.Sync.$tc'BlockedOnSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnSTM1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 1161208048218837616;
         const 14246412223428266787;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.069051599 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnForeignCall2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnForeignCall2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,70,111,114,101,105,103,110,67,97,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.070688201 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnForeignCall1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnForeignCall1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnForeignCall2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.07239159 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnForeignCall_closure" {
     GHC.Conc.Sync.$tc'BlockedOnForeignCall_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnForeignCall1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 7408412473094687054;
         const 5512662453084487661;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.074878124 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnOther2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnOther2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,79,116,104,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.076559783 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnOther1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnOther1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnOther2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.078211047 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnOther_closure" {
     GHC.Conc.Sync.$tc'BlockedOnOther_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnOther1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 12822899422417308746;
         const 1265626399802742388;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.080037184 UTC

[section ""cstring" . GHC.Conc.Sync.$tcThreadStatus2_bytes" {
     GHC.Conc.Sync.$tcThreadStatus2_bytes:
         I8[] [84,104,114,101,97,100,83,116,97,116,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.081722732 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadStatus1_closure" {
     GHC.Conc.Sync.$tcThreadStatus1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcThreadStatus2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.083375549 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadStatus_closure" {
     GHC.Conc.Sync.$tcThreadStatus_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcThreadStatus1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16437204929171641638;
         const 3495092226815585861;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.085183368 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadDied1_closure" {
     GHC.Conc.Sync.$tc'ThreadDied1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcThreadStatus_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.087222217 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadRunning2_bytes" {
     GHC.Conc.Sync.$tc'ThreadRunning2_bytes:
         I8[] [39,84,104,114,101,97,100,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.088892868 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadRunning1_closure" {
     GHC.Conc.Sync.$tc'ThreadRunning1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadRunning2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.09106706 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadRunning_closure" {
     GHC.Conc.Sync.$tc'ThreadRunning_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadRunning1_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 1667122312602609882;
         const 13647871799576313560;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.092871688 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadFinished2_bytes" {
     GHC.Conc.Sync.$tc'ThreadFinished2_bytes:
         I8[] [39,84,104,114,101,97,100,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.094557582 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadFinished1_closure" {
     GHC.Conc.Sync.$tc'ThreadFinished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadFinished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.09626248 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadFinished_closure" {
     GHC.Conc.Sync.$tc'ThreadFinished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadFinished1_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 2441107603776884109;
         const 12730966154693836607;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.098012541 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadDied3_bytes" {
     GHC.Conc.Sync.$tc'ThreadDied3_bytes:
         I8[] [39,84,104,114,101,97,100,68,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.099656665 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadDied2_closure" {
     GHC.Conc.Sync.$tc'ThreadDied2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadDied3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.101325834 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadDied_closure" {
     GHC.Conc.Sync.$tc'ThreadDied_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied2_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 9513974555658789847;
         const 4757719484357493227;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.10310663 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadBlocked1_closure" {
     GHC.Conc.Sync.$tc'ThreadBlocked1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.10476563 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadBlocked3_bytes" {
     GHC.Conc.Sync.$tc'ThreadBlocked3_bytes:
         I8[] [39,84,104,114,101,97,100,66,108,111,99,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.106805187 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadBlocked2_closure" {
     GHC.Conc.Sync.$tc'ThreadBlocked2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadBlocked3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.108471795 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadBlocked_closure" {
     GHC.Conc.Sync.$tc'ThreadBlocked_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadBlocked2_closure+1;
         const GHC.Conc.Sync.$tc'ThreadBlocked1_closure+4;
         const 1896650886570328403;
         const 13390928353603149841;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.110217169 UTC

[section ""cstring" . GHC.Conc.Sync.$tcPrimMVar2_bytes" {
     GHC.Conc.Sync.$tcPrimMVar2_bytes:
         I8[] [80,114,105,109,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.111883108 UTC

[section ""data" . GHC.Conc.Sync.$tcPrimMVar1_closure" {
     GHC.Conc.Sync.$tcPrimMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcPrimMVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.113608119 UTC

[section ""data" . GHC.Conc.Sync.$tcPrimMVar_closure" {
     GHC.Conc.Sync.$tcPrimMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcPrimMVar1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9965391380168186507;
         const 18322737771689556223;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.115885362 UTC

[section ""cstring" . GHC.Conc.Sync.$tcSTM2_bytes" {
     GHC.Conc.Sync.$tcSTM2_bytes:
         I8[] [83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.118181337 UTC

[section ""data" . GHC.Conc.Sync.$tcSTM1_closure" {
     GHC.Conc.Sync.$tcSTM1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcSTM2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.119769574 UTC

[section ""data" . GHC.Conc.Sync.$tcSTM_closure" {
     GHC.Conc.Sync.$tcSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcSTM1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 2004856025729794332;
         const 14974623362753764267;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.121563625 UTC

[section ""data" . $krep20_r9Fv7_closure" {
     $krep20_r9Fv7_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcSTM_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.123195599 UTC

[section ""data" . GHC.Conc.Sync.$tc'STM1_closure" {
     GHC.Conc.Sync.$tc'STM1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep18_r9Fv5_closure+4;
         const $krep20_r9Fv7_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.124920508 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'STM3_bytes" {
     GHC.Conc.Sync.$tc'STM3_bytes:
         I8[] [39,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.126502782 UTC

[section ""data" . GHC.Conc.Sync.$tc'STM2_closure" {
     GHC.Conc.Sync.$tc'STM2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'STM3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.128129783 UTC

[section ""data" . GHC.Conc.Sync.$tc'STM_closure" {
     GHC.Conc.Sync.$tc'STM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'STM2_closure+1;
         const GHC.Conc.Sync.$tc'STM1_closure+4;
         const 11288073744523536973;
         const 9767688212531311940;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.130208418 UTC

[section ""cstring" . GHC.Conc.Sync.$tcTVar2_bytes" {
     GHC.Conc.Sync.$tcTVar2_bytes:
         I8[] [84,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.131845819 UTC

[section ""data" . GHC.Conc.Sync.$tcTVar1_closure" {
     GHC.Conc.Sync.$tcTVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcTVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.133569399 UTC

[section ""data" . GHC.Conc.Sync.$tcTVar_closure" {
     GHC.Conc.Sync.$tcTVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcTVar1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13084572405727191592;
         const 5232564955606145236;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.135362243 UTC

[section ""data" . $krep21_r9Fv8_closure" {
     $krep21_r9Fv8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcTVar_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.13705698 UTC

[section ""data" . GHC.Conc.Sync.$tc'TVar1_closure" {
     GHC.Conc.Sync.$tc'TVar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r9FuU_closure+1;
         const $krep21_r9Fv8_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.138708318 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'TVar3_bytes" {
     GHC.Conc.Sync.$tc'TVar3_bytes:
         I8[] [39,84,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.14033962 UTC

[section ""data" . GHC.Conc.Sync.$tc'TVar2_closure" {
     GHC.Conc.Sync.$tc'TVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'TVar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.142862884 UTC

[section ""data" . GHC.Conc.Sync.$tc'TVar_closure" {
     GHC.Conc.Sync.$tc'TVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'TVar2_closure+1;
         const GHC.Conc.Sync.$tc'TVar1_closure+4;
         const 9463269625853265574;
         const 3517068532143837766;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.14456457 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadId2_bytes" {
     GHC.Conc.Sync.$fShowThreadId2_bytes:
         I8[] [84,104,114,101,97,100,73,100,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.147450058 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure" {
     GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure:
         const GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_info;
 },
 x_s9FBb_entry() //  [R1]
         { info_tbl: [(c9KPT,
                       label: x_s9FBb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KPT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9KQ2; else goto c9KQ3;
       c9KQ2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9KQ3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9KPQ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9KQ7; else goto c9KPR;
       u9KQ7: // global
           call _c9KPQ(R1) args: 0, res: 0, upd: 0;
       c9KPR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9KPQ() //  [R1]
         { info_tbl: [(c9KPQ,
                       label: block_c9KPQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KPQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9KQ6; else goto c9KQ5;
       c9KQ6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9KQ5: // global
           (_s9FBh::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadId(P64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FBh::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FBr_entry() //  [R1]
         { info_tbl: [(c9KQk,
                       label: sat_s9FBr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KQk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9KQv; else goto c9KQw;
       c9KQv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9KQw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9KQh_info;
           _s9FB9::P64 = P64[R1 + 16];
           _s9FBj::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s9FB9::P64;
           P64[Sp - 24] = _s9FBj::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9KQD; else goto c9KQi;
       u9KQD: // global
           call _c9KQh(R1) args: 0, res: 0, upd: 0;
       c9KQi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9KQh() //  [R1]
         { info_tbl: [(c9KQh,
                       label: block_c9KQh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KQh: // global
           I64[Sp] = block_c9KQn_info;
           _s9FBl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s9FBl::I64;
           if (R1 & 7 != 0) goto u9KQC; else goto c9KQo;
       u9KQC: // global
           call _c9KQn(R1) args: 0, res: 0, upd: 0;
       c9KQo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9KQn() //  [R1]
         { info_tbl: [(c9KQn,
                       label: block_c9KQn_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KQn: // global
           _s9FBj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9KQs_info;
           R4 = _s9FBj::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9KQs() //  [R1, R2]
         { info_tbl: [(c9KQs,
                       label: block_c9KQs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KQs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9KQB; else goto c9KQA;
       c9KQB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9KQA: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FBs_entry() //  [R1, R2]
         { info_tbl: [(c9KQE,
                       label: sat_s9FBs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KQE: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9KQI; else goto c9KQH;
       c9KQI: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9KQH: // global
           _s9FB9::P64 = P64[R1 + 7];
           _s9FBb::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FBr_info;
           P64[Hp - 16] = _s9FB9::P64;
           P64[Hp - 8] = _s9FBb::P64;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = GHC.Conc.Sync.$fShowThreadId2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c9KQJ,
                       label: GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KQJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c9KQN; else goto c9KQM;
       c9KQN: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9KQM: // global
           I64[Hp - 40] = x_s9FBb_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s9FBs_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.164691701 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_$cshow_closure" {
     GHC.Conc.Sync.$fShowThreadId_$cshow_closure:
         const GHC.Conc.Sync.$fShowThreadId_$cshow_info;
 },
 sat_s9FBE_entry() //  [R1]
         { info_tbl: [(c9KRy,
                       label: sat_s9FBE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KRy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9KRJ; else goto c9KRK;
       c9KRJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9KRK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9KRv_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9KRP; else goto c9KRw;
       u9KRP: // global
           call _c9KRv(R1) args: 0, res: 0, upd: 0;
       c9KRw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9KRv() //  [R1]
         { info_tbl: [(c9KRv,
                       label: block_c9KRv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KRv: // global
           (_s9FBz::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadId(P64[R1 + 7]);
           I64[Sp] = block_c9KRG_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FBz::I64));
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9KRG() //  [R1, R2]
         { info_tbl: [(c9KRG,
                       label: block_c9KRG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KRG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9KRO; else goto c9KRN;
       c9KRO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9KRN: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$fShowThreadId_$cshow_entry() //  [R2]
         { info_tbl: [(c9KRQ,
                       label: GHC.Conc.Sync.$fShowThreadId_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KRQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9KRU; else goto c9KRT;
       c9KRU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadId_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9KRT: // global
           I64[Hp - 16] = sat_s9FBE_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = GHC.Conc.Sync.$fShowThreadId2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.174988292 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId1_closure" {
     GHC.Conc.Sync.$fShowThreadId1_closure:
         const GHC.Conc.Sync.$fShowThreadId1_info;
 },
 x_s9FBG_entry() //  [R1]
         { info_tbl: [(c9KSm,
                       label: x_s9FBG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KSm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9KSv; else goto c9KSw;
       c9KSv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9KSw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9KSj_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9KSA; else goto c9KSk;
       u9KSA: // global
           call _c9KSj(R1) args: 0, res: 0, upd: 0;
       c9KSk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9KSj() //  [R1]
         { info_tbl: [(c9KSj,
                       label: block_c9KSj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KSj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9KSz; else goto c9KSy;
       c9KSz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9KSy: // global
           (_s9FBM::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadId(P64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FBM::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FBU_entry() //  [R1]
         { info_tbl: [(c9KSN,
                       label: sat_s9FBU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KSN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9KST; else goto c9KSU;
       c9KST: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9KSU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c9KSK_info;
           _s9FBO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s9FBO::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9KSZ; else goto c9KSL;
       u9KSZ: // global
           call _c9KSK(R1) args: 0, res: 0, upd: 0;
       c9KSL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9KSK() //  [R1]
         { info_tbl: [(c9KSK,
                       label: block_c9KSK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KSK: // global
           _s9FBO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9KSQ_info;
           R4 = _s9FBO::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9KSQ() //  [R1, R2]
         { info_tbl: [(c9KSQ,
                       label: block_c9KSQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KSQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9KSY; else goto c9KSX;
       c9KSY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9KSX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FBV_entry() //  [R1, R2]
         { info_tbl: [(c9KT0,
                       label: sat_s9FBV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KT0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9KT4; else goto c9KT3;
       c9KT4: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9KT3: // global
           _s9FBG::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s9FBU_info;
           P64[Hp - 8] = _s9FBG::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = GHC.Conc.Sync.$fShowThreadId2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fShowThreadId1_entry() //  [R2]
         { info_tbl: [(c9KT5,
                       label: GHC.Conc.Sync.$fShowThreadId1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KT5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9KT9; else goto c9KT8;
       c9KT9: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadId1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9KT8: // global
           I64[Hp - 32] = x_s9FBG_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s9FBV_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.191173598 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_$cshowList_closure" {
     GHC.Conc.Sync.$fShowThreadId_$cshowList_closure:
         const GHC.Conc.Sync.$fShowThreadId_$cshowList_info;
 },
 GHC.Conc.Sync.$fShowThreadId_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c9KTJ,
                       label: GHC.Conc.Sync.$fShowThreadId_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KTJ: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$fShowThreadId1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.194624002 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_closure" {
     GHC.Conc.Sync.$fShowThreadId_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure+2;
         const GHC.Conc.Sync.$fShowThreadId_$cshow_closure+1;
         const GHC.Conc.Sync.$fShowThreadId_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.196433994 UTC

[section ""data" . reportHeapOverflow1_r9Fv9_closure" {
     reportHeapOverflow1_r9Fv9_closure:
         const reportHeapOverflow1_r9Fv9_info;
 },
 reportHeapOverflow1_r9Fv9_entry() //  []
         { info_tbl: [(c9KTW,
                       label: reportHeapOverflow1_r9Fv9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KTW: // global
           call "ccall" arg hints:  []  result hints:  [] reportHeapOverflow();
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.199823896 UTC

[section ""data" . GHC.Conc.Sync.reportHeapOverflow_closure" {
     GHC.Conc.Sync.reportHeapOverflow_closure:
         const GHC.Conc.Sync.reportHeapOverflow_info;
 },
 GHC.Conc.Sync.reportHeapOverflow_entry() //  []
         { info_tbl: [(c9KU8,
                       label: GHC.Conc.Sync.reportHeapOverflow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KU8: // global
           call reportHeapOverflow1_r9Fv9_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.204084246 UTC

[section ""data" . GHC.Conc.Sync.cmpThread_closure" {
     GHC.Conc.Sync.cmpThread_closure:
         const GHC.Conc.Sync.cmpThread_info;
 },
 GHC.Conc.Sync.cmpThread_entry() //  [R2, R3]
         { info_tbl: [(c9KUm,
                       label: GHC.Conc.Sync.cmpThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KUm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9KUq; else goto c9KUr;
       c9KUq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.cmpThread_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9KUr: // global
           I64[Sp - 16] = block_c9KUj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9KUY; else goto c9KUk;
       u9KUY: // global
           call _c9KUj(R1) args: 0, res: 0, upd: 0;
       c9KUk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KUj() //  [R1]
         { info_tbl: [(c9KUj,
                       label: block_c9KUj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KUj: // global
           I64[Sp] = block_c9KUp_info;
           _s9FC5::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FC5::P64;
           if (R1 & 7 != 0) goto u9KUX; else goto c9KUt;
       u9KUX: // global
           call _c9KUp(R1) args: 0, res: 0, upd: 0;
       c9KUt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KUp() //  [R1]
         { info_tbl: [(c9KUp,
                       label: block_c9KUp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KUp: // global
           (_s9FCb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FCc::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FCb::I64));
           if (_s9FCc::I64 != (-1)) goto u9KUW; else goto c9KUM;
       u9KUW: // global
           if (_s9FCc::I64 != 0) goto c9KUG; else goto c9KUS;
       c9KUG: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9KUS: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9KUM: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.212149357 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadId_$c==_closure" {
     GHC.Conc.Sync.$fEqThreadId_$c==_closure:
         const GHC.Conc.Sync.$fEqThreadId_$c==_info;
 },
 GHC.Conc.Sync.$fEqThreadId_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9KVm,
                       label: GHC.Conc.Sync.$fEqThreadId_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KVm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9KVq; else goto c9KVr;
       c9KVq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadId_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9KVr: // global
           I64[Sp - 16] = block_c9KVj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9KVR; else goto c9KVk;
       u9KVR: // global
           call _c9KVj(R1) args: 0, res: 0, upd: 0;
       c9KVk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KVj() //  [R1]
         { info_tbl: [(c9KVj,
                       label: block_c9KVj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KVj: // global
           I64[Sp] = block_c9KVp_info;
           _s9FCg::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCg::P64;
           if (R1 & 7 != 0) goto u9KVQ; else goto c9KVt;
       u9KVQ: // global
           call _c9KVp(R1) args: 0, res: 0, upd: 0;
       c9KVt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KVp() //  [R1]
         { info_tbl: [(c9KVp,
                       label: block_c9KVp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KVp: // global
           (_s9FCm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9FCm::I64) == 0 :: W32) goto c9KVM; else goto c9KVG;
       c9KVM: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9KVG: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.22050319 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadId_$c/=_closure" {
     GHC.Conc.Sync.$fEqThreadId_$c/=_closure:
         const GHC.Conc.Sync.$fEqThreadId_$c/=_info;
 },
 GHC.Conc.Sync.$fEqThreadId_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9KWe,
                       label: GHC.Conc.Sync.$fEqThreadId_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KWe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9KWi; else goto c9KWj;
       c9KWi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadId_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9KWj: // global
           I64[Sp - 16] = block_c9KWb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9KWJ; else goto c9KWc;
       u9KWJ: // global
           call _c9KWb(R1) args: 0, res: 0, upd: 0;
       c9KWc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KWb() //  [R1]
         { info_tbl: [(c9KWb,
                       label: block_c9KWb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KWb: // global
           I64[Sp] = block_c9KWh_info;
           _s9FCr::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCr::P64;
           if (R1 & 7 != 0) goto u9KWI; else goto c9KWl;
       u9KWI: // global
           call _c9KWh(R1) args: 0, res: 0, upd: 0;
       c9KWl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KWh() //  [R1]
         { info_tbl: [(c9KWh,
                       label: block_c9KWh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KWh: // global
           (_s9FCx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9FCx::I64) == 0 :: W32) goto c9KWE; else goto c9KWy;
       c9KWE: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9KWy: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.228248829 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadId_closure" {
     GHC.Conc.Sync.$fEqThreadId_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqThreadId_$c==_closure+2;
         const GHC.Conc.Sync.$fEqThreadId_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.230451002 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c<_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c<_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c<_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c<_entry() //  [R2, R3]
         { info_tbl: [(c9KX7,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KX7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9KXb; else goto c9KXc;
       c9KXb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9KXc: // global
           I64[Sp - 16] = block_c9KX4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9KXC; else goto c9KX5;
       u9KXC: // global
           call _c9KX4(R1) args: 0, res: 0, upd: 0;
       c9KX5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KX4() //  [R1]
         { info_tbl: [(c9KX4,
                       label: block_c9KX4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KX4: // global
           I64[Sp] = block_c9KXa_info;
           _s9FCC::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCC::P64;
           if (R1 & 7 != 0) goto u9KXB; else goto c9KXe;
       u9KXB: // global
           call _c9KXa(R1) args: 0, res: 0, upd: 0;
       c9KXe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KXa() //  [R1]
         { info_tbl: [(c9KXa,
                       label: block_c9KXa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KXa: // global
           (_s9FCI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9FCI::I64) == (-1) :: W32) goto c9KXx; else goto c9KXr;
       c9KXx: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9KXr: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.238750745 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c>=_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c>=_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c>=_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c9KXZ,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KXZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9KY3; else goto c9KY4;
       c9KY3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9KY4: // global
           I64[Sp - 16] = block_c9KXW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9KYu; else goto c9KXX;
       u9KYu: // global
           call _c9KXW(R1) args: 0, res: 0, upd: 0;
       c9KXX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KXW() //  [R1]
         { info_tbl: [(c9KXW,
                       label: block_c9KXW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KXW: // global
           I64[Sp] = block_c9KY2_info;
           _s9FCN::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCN::P64;
           if (R1 & 7 != 0) goto u9KYt; else goto c9KY6;
       u9KYt: // global
           call _c9KY2(R1) args: 0, res: 0, upd: 0;
       c9KY6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KY2() //  [R1]
         { info_tbl: [(c9KY2,
                       label: block_c9KY2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KY2: // global
           (_s9FCT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9FCT::I64) == (-1) :: W32) goto c9KYp; else goto c9KYj;
       c9KYp: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9KYj: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.246622007 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c>_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c>_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c>_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c>_entry() //  [R2, R3]
         { info_tbl: [(c9KYR,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KYR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9KYV; else goto c9KYW;
       c9KYV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9KYW: // global
           I64[Sp - 16] = block_c9KYO_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9KZt; else goto c9KYP;
       u9KZt: // global
           call _c9KYO(R1) args: 0, res: 0, upd: 0;
       c9KYP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KYO() //  [R1]
         { info_tbl: [(c9KYO,
                       label: block_c9KYO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KYO: // global
           I64[Sp] = block_c9KYU_info;
           _s9FCY::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FCY::P64;
           if (R1 & 7 != 0) goto u9KZs; else goto c9KYY;
       u9KZs: // global
           call _c9KYU(R1) args: 0, res: 0, upd: 0;
       c9KYY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KYU() //  [R1]
         { info_tbl: [(c9KYU,
                       label: block_c9KYU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KYU: // global
           (_s9FD4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FD5::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FD4::I64));
           if (_s9FD5::I64 == (-1)) goto c9KZn; else goto u9KZr;
       u9KZr: // global
           if (_s9FD5::I64 == 0) goto c9KZn; else goto c9KZb;
       c9KZn: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9KZb: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.255486922 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c<=_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c<=_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c<=_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c9KZQ,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KZQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9KZU; else goto c9KZV;
       c9KZU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9KZV: // global
           I64[Sp - 16] = block_c9KZN_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9L0s; else goto c9KZO;
       u9L0s: // global
           call _c9KZN(R1) args: 0, res: 0, upd: 0;
       c9KZO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KZN() //  [R1]
         { info_tbl: [(c9KZN,
                       label: block_c9KZN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KZN: // global
           I64[Sp] = block_c9KZT_info;
           _s9FD9::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FD9::P64;
           if (R1 & 7 != 0) goto u9L0r; else goto c9KZX;
       u9L0r: // global
           call _c9KZT(R1) args: 0, res: 0, upd: 0;
       c9KZX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9KZT() //  [R1]
         { info_tbl: [(c9KZT,
                       label: block_c9KZT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9KZT: // global
           (_s9FDf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FDg::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FDf::I64));
           if (_s9FDg::I64 == (-1)) goto c9L0m; else goto u9L0q;
       u9L0q: // global
           if (_s9FDg::I64 == 0) goto c9L0m; else goto c9L0a;
       c9L0m: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9L0a: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.263282954 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$cmax_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$cmax_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$cmax_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c9L0P,
                       label: GHC.Conc.Sync.$fOrdThreadId_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L0P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9L0T; else goto c9L0U;
       c9L0T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9L0U: // global
           I64[Sp - 16] = block_c9L0M_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9L1r; else goto c9L0N;
       u9L1r: // global
           call _c9L0M(R1) args: 0, res: 0, upd: 0;
       c9L0N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9L0M() //  [R1]
         { info_tbl: [(c9L0M,
                       label: block_c9L0M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L0M: // global
           I64[Sp - 8] = block_c9L0S_info;
           _s9FDj::P64 = R1;
           _s9FDk::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9FDk::P64;
           P64[Sp + 8] = _s9FDj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9L1q; else goto c9L0W;
       u9L1q: // global
           call _c9L0S(R1) args: 0, res: 0, upd: 0;
       c9L0W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9L0S() //  [R1]
         { info_tbl: [(c9L0S,
                       label: block_c9L0S_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L0S: // global
           _s9FDj::P64 = P64[Sp + 16];
           (_s9FDq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FDr::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FDq::I64));
           if (_s9FDr::I64 == (-1)) goto c9L1l; else goto u9L1p;
       u9L1p: // global
           if (_s9FDr::I64 == 0) goto c9L1l; else goto c9L19;
       c9L1l: // global
           R1 = _s9FDj::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9L19: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.27164448 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$cmin_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$cmin_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$cmin_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c9L1Q,
                       label: GHC.Conc.Sync.$fOrdThreadId_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L1Q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9L1U; else goto c9L1V;
       c9L1U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9L1V: // global
           I64[Sp - 16] = block_c9L1N_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9L2s; else goto c9L1O;
       u9L2s: // global
           call _c9L1N(R1) args: 0, res: 0, upd: 0;
       c9L1O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9L1N() //  [R1]
         { info_tbl: [(c9L1N,
                       label: block_c9L1N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L1N: // global
           I64[Sp - 8] = block_c9L1T_info;
           _s9FDu::P64 = R1;
           _s9FDv::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9FDv::P64;
           P64[Sp + 8] = _s9FDu::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9L2r; else goto c9L1X;
       u9L2r: // global
           call _c9L1T(R1) args: 0, res: 0, upd: 0;
       c9L1X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9L1T() //  [R1]
         { info_tbl: [(c9L1T,
                       label: block_c9L1T_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L1T: // global
           _s9FDu::P64 = P64[Sp + 16];
           (_s9FDB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9FDw::P64 = R1;
           _s9FDC::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9FDB::I64));
           if (_s9FDC::I64 == (-1)) goto c9L2m; else goto u9L2q;
       u9L2q: // global
           if (_s9FDC::I64 == 0) goto c9L2m; else goto c9L2a;
       c9L2m: // global
           R1 = _s9FDw::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9L2a: // global
           R1 = _s9FDu::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.279413156 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_closure" {
     GHC.Conc.Sync.$fOrdThreadId_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Conc.Sync.$fEqThreadId_closure+1;
         const GHC.Conc.Sync.cmpThread_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c<_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c<=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c>_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c>=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$cmax_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.281223579 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus10_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus10_bytes:
         I8[] [84,104,114,101,97,100,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.283196079 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus9_closure" {
     GHC.Conc.Sync.$fShowThreadStatus9_closure:
         const GHC.Conc.Sync.$fShowThreadStatus9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus9_entry() //  [R1]
         { info_tbl: [(c9L2S,
                       label: GHC.Conc.Sync.$fShowThreadStatus9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L2S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9L2T; else goto c9L2U;
       c9L2T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9L2U: // global
           (_c9L2P::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9L2P::I64 == 0) goto c9L2R; else goto c9L2Q;
       c9L2R: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9L2Q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9L2P::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.286992555 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus8_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus8_bytes:
         I8[] [84,104,114,101,97,100,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.289683992 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus7_closure" {
     GHC.Conc.Sync.$fShowThreadStatus7_closure:
         const GHC.Conc.Sync.$fShowThreadStatus7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus7_entry() //  [R1]
         { info_tbl: [(c9L39,
                       label: GHC.Conc.Sync.$fShowThreadStatus7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L39: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9L3a; else goto c9L3b;
       c9L3a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9L3b: // global
           (_c9L36::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9L36::I64 == 0) goto c9L38; else goto c9L37;
       c9L38: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9L37: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9L36::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.293563029 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus6_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus6_bytes:
         I8[] [84,104,114,101,97,100,66,108,111,99,107,101,100,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.295343174 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus5_closure" {
     GHC.Conc.Sync.$fShowThreadStatus5_closure:
         const GHC.Conc.Sync.$fShowThreadStatus5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus5_entry() //  [R1]
         { info_tbl: [(c9L3q,
                       label: GHC.Conc.Sync.$fShowThreadStatus5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L3q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9L3r; else goto c9L3s;
       c9L3r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9L3s: // global
           (_c9L3n::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9L3n::I64 == 0) goto c9L3p; else goto c9L3o;
       c9L3p: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9L3o: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9L3n::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.299144286 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus4_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus4_bytes:
         I8[] [84,104,114,101,97,100,68,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.300901213 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus3_closure" {
     GHC.Conc.Sync.$fShowThreadStatus3_closure:
         const GHC.Conc.Sync.$fShowThreadStatus3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus3_entry() //  [R1]
         { info_tbl: [(c9L3H,
                       label: GHC.Conc.Sync.$fShowThreadStatus3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L3H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9L3I; else goto c9L3J;
       c9L3I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9L3J: // global
           (_c9L3E::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9L3E::I64 == 0) goto c9L3G; else goto c9L3F;
       c9L3G: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9L3F: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9L3E::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.306182972 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure:
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_info;
         const 0;
 },
 sat_s9FDL_entry() //  [R1]
         { info_tbl: [(c9L4e,
                       label: sat_s9FDL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L4e: // global
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FDN_entry() //  [R1]
         { info_tbl: [(c9L4r,
                       label: sat_s9FDN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L4r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9L4v; else goto c9L4u;
       c9L4v: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9L4u: // global
           _s9FDF::P64 = P64[R1 + 16];
           _s9FDH::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s9FDF::P64;
           R3 = Hp - 14;
           R2 = _s9FDH::P64;
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FDO_entry() //  [R1]
         { info_tbl: [(c9L4w,
                       label: sat_s9FDO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L4w: // global
           _s9FDO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9L4x; else goto c9L4y;
       c9L4y: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9L4A; else goto c9L4z;
       c9L4A: // global
           HpAlloc = 32;
           goto c9L4x;
       c9L4x: // global
           R1 = _s9FDO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9L4z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9FDO::P64;
           _s9FDF::P64 = P64[_s9FDO::P64 + 16];
           _s9FDH::P64 = P64[_s9FDO::P64 + 24];
           I64[Hp - 24] = sat_s9FDN_info;
           P64[Hp - 8] = _s9FDF::P64;
           P64[Hp] = _s9FDH::P64;
           R3 = Hp - 24;
           R2 = GHC.Conc.Sync.$fShowThreadStatus5_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c9L4H,
                       label: GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L4H: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9L4I; else goto c9L4J;
       c9L4I: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9L4J: // global
           I64[Sp - 24] = block_c9L3V_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9L52; else goto c9L3W;
       u9L52: // global
           call _c9L3V(R1) args: 0, res: 0, upd: 0;
       c9L3W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9L3V() //  [R1]
         { info_tbl: [(c9L3V,
                       label: block_c9L3V_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L3V: // global
           _s9FDF::P64 = P64[Sp + 16];
           _c9L4G::P64 = R1 & 7;
           if (_c9L4G::P64 < 3) goto u9L4Z; else goto u9L50;
       u9L4Z: // global
           if (_c9L4G::P64 < 2) goto c9L4C; else goto c9L4D;
       c9L4C: // global
           R3 = _s9FDF::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus9_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9L4D: // global
           R3 = _s9FDF::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus7_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u9L50: // global
           if (_c9L4G::P64 < 4) goto c9L4E; else goto c9L4F;
       c9L4E: // global
           I64[Sp] = block_c9L42_info;
           _s9FDH::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FDH::P64;
           if (R1 & 7 != 0) goto u9L51; else goto c9L43;
       u9L51: // global
           call _c9L42(R1) args: 0, res: 0, upd: 0;
       c9L43: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9L4F: // global
           R3 = _s9FDF::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus3_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c9L42() //  [R1]
         { info_tbl: [(c9L42,
                       label: block_c9L42_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L42: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9L4R; else goto c9L4Q;
       c9L4R: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9L4Q: // global
           _s9FDF::P64 = P64[Sp + 16];
           _s9FDH::P64 = P64[Sp + 8];
           if (%MO_S_Lt_W64(I64[R1 + 7], 11)) goto c9L4T; else goto c9L4V;
       c9L4T: // global
           I64[Hp - 48] = sat_s9FDL_info;
           P64[Hp - 32] = _s9FDF::P64;
           P64[Hp - 24] = _s9FDH::P64;
           _c9L4a::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c9L4a::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus5_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9L4V: // global
           I64[Hp - 48] = sat_s9FDO_info;
           P64[Hp - 32] = _s9FDF::P64;
           P64[Hp - 24] = _s9FDH::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.32117547 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure:
         const GHC.Conc.Sync.$fShowThreadStatus_$cshow_info;
         const 0;
 },
 sat_s9FDS_entry() //  [R1]
         { info_tbl: [(c9L5I,
                       label: sat_s9FDS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L5I: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fShowThreadStatus_$cshow_entry() //  [R2]
         { info_tbl: [(c9L5R,
                       label: GHC.Conc.Sync.$fShowThreadStatus_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L5R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9L5S; else goto c9L5T;
       c9L5S: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9L5T: // global
           I64[Sp - 8] = block_c9L5x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9L66; else goto c9L5y;
       u9L66: // global
           call _c9L5x(R1) args: 0, res: 0, upd: 0;
       c9L5y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9L5x() //  [R1]
         { info_tbl: [(c9L5x,
                       label: block_c9L5x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L5x: // global
           _c9L5Q::P64 = R1 & 7;
           if (_c9L5Q::P64 < 3) goto u9L64; else goto u9L65;
       u9L64: // global
           if (_c9L5Q::P64 < 2) goto c9L5M; else goto c9L5N;
       c9L5M: // global
           R1 = GHC.Conc.Sync.$fShowThreadStatus9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9L5N: // global
           R1 = GHC.Conc.Sync.$fShowThreadStatus7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9L65: // global
           if (_c9L5Q::P64 < 4) goto c9L5O; else goto c9L5P;
       c9L5O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9L60; else goto c9L5Z;
       c9L60: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9L5Z: // global
           _s9FDR::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_s9FDS_info;
           P64[Hp] = _s9FDR::P64;
           R3 = Hp - 16;
           R2 = GHC.Conc.Sync.$fShowThreadStatus5_closure;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9L5P: // global
           R1 = GHC.Conc.Sync.$fShowThreadStatus3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.329663247 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus2_closure" {
     GHC.Conc.Sync.$fShowThreadStatus2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.33145754 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus1_closure" {
     GHC.Conc.Sync.$fShowThreadStatus1_closure:
         const GHC.Conc.Sync.$fShowThreadStatus1_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus1_entry() //  [R2, R3]
         { info_tbl: [(c9L6s,
                       label: GHC.Conc.Sync.$fShowThreadStatus1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L6s: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$fShowThreadStatus2_closure+1;
           call GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.334741632 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_$cshowList_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_$cshowList_closure:
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowList_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c9L6D,
                       label: GHC.Conc.Sync.$fShowThreadStatus_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L6D: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$fShowThreadStatus1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.338276138 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure+3;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure+1;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.340189936 UTC

[section ""data" . GHC.Conc.Sync.killThread2_closure" {
     GHC.Conc.Sync.killThread2_closure:
         const GHC.Conc.Sync.killThread2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.killThread2_entry() //  [R1]
         { info_tbl: [(c9L6R,
                       label: GHC.Conc.Sync.killThread2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L6R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9L6S; else goto c9L6T;
       c9L6S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9L6T: // global
           (_c9L6O::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9L6O::I64 == 0) goto c9L6Q; else goto c9L6P;
       c9L6Q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9L6P: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9L6O::I64;
           R2 = GHC.IO.Exception.ThreadKilled_closure+3;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.344356542 UTC

[section ""data" . GHC.Conc.Sync.killThread1_closure" {
     GHC.Conc.Sync.killThread1_closure:
         const GHC.Conc.Sync.killThread1_info;
         const 0;
 },
 GHC.Conc.Sync.killThread1_entry() //  [R2]
         { info_tbl: [(c9L78,
                       label: GHC.Conc.Sync.killThread1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L78: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9L7c; else goto c9L7d;
       c9L7c: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.killThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9L7d: // global
           I64[Sp - 8] = block_c9L75_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9L7h; else goto c9L76;
       u9L7h: // global
           call _c9L75(R1) args: 0, res: 0, upd: 0;
       c9L76: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9L75() //  [R1]
         { info_tbl: [(c9L75,
                       label: block_c9L75_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L75: // global
           I64[Sp] = block_c9L7b_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9L7b() //  []
         { info_tbl: [(c9L7b,
                       label: block_c9L7b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L7b: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.351360531 UTC

[section ""data" . GHC.Conc.Sync.killThread_closure" {
     GHC.Conc.Sync.killThread_closure:
         const GHC.Conc.Sync.killThread_info;
         const 0;
 },
 GHC.Conc.Sync.killThread_entry() //  [R2]
         { info_tbl: [(c9L7z,
                       label: GHC.Conc.Sync.killThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L7z: // global
           R2 = R2;
           call GHC.Conc.Sync.killThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.354732088 UTC

[section ""data" . GHC.Conc.Sync.getNumProcessors1_closure" {
     GHC.Conc.Sync.getNumProcessors1_closure:
         const GHC.Conc.Sync.getNumProcessors1_info;
 },
 GHC.Conc.Sync.getNumProcessors1_entry() //  []
         { info_tbl: [(c9L7N,
                       label: GHC.Conc.Sync.getNumProcessors1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L7N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9L7W; else goto c9L7V;
       c9L7W: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.getNumProcessors1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9L7V: // global
           (_s9FE4::I64) = call "ccall" arg hints:  []  result hints:  [] getNumberOfProcessors();
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s9FE4::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.358967363 UTC

[section ""data" . GHC.Conc.Sync.getNumProcessors_closure" {
     GHC.Conc.Sync.getNumProcessors_closure:
         const GHC.Conc.Sync.getNumProcessors_info;
 },
 GHC.Conc.Sync.getNumProcessors_entry() //  []
         { info_tbl: [(c9L87,
                       label: GHC.Conc.Sync.getNumProcessors_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L87: // global
           call GHC.Conc.Sync.getNumProcessors1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.362434478 UTC

[section ""data" . GHC.Conc.Sync.threadStatus7_closure" {
     GHC.Conc.Sync.threadStatus7_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnOther_closure+6;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.36411845 UTC

[section ""data" . GHC.Conc.Sync.threadStatus6_closure" {
     GHC.Conc.Sync.threadStatus6_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnMVar_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.365820483 UTC

[section ""data" . GHC.Conc.Sync.threadStatus2_closure" {
     GHC.Conc.Sync.threadStatus2_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnException_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.367560634 UTC

[section ""data" . GHC.Conc.Sync.threadStatus3_closure" {
     GHC.Conc.Sync.threadStatus3_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.3692729 UTC

[section ""data" . GHC.Conc.Sync.threadStatus4_closure" {
     GHC.Conc.Sync.threadStatus4_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnSTM_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.370912478 UTC

[section ""data" . GHC.Conc.Sync.threadStatus5_closure" {
     GHC.Conc.Sync.threadStatus5_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.373385006 UTC

[section ""data" . GHC.Conc.Sync.$wthreadStatus_closure" {
     GHC.Conc.Sync.$wthreadStatus_closure:
         const GHC.Conc.Sync.$wthreadStatus_info;
 },
 sat_s9FEg_entry() //  [R1]
         { info_tbl: [(c9L8J,
                       label: sat_s9FEg_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L8J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9L8K; else goto c9L8L;
       c9L8K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9L8L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s9FEf::I64 = I64[R1 + 16];
           if (%MO_S_Ge_W64(_s9FEf::I64, 18)) goto c9L8y; else goto u9L8M;
       u9L8M: // global
           if (%MO_S_Lt_W64(_s9FEf::I64, 0)) goto c9L8y; else goto u9L8N;
       u9L8N: // global
           switch [0 .. 17] _s9FEf::I64 {
               case 0 : goto c9L8z;
               case 1 : goto c9L8G;
               case 2 : goto c9L8B;
               case 6 : goto c9L8C;
               case 10, 11 : goto c9L8E;
               case 12 : goto c9L8F;
               case 14 : goto c9L8G;
               case 16 : goto c9L8H;
               case 17 : goto c9L8I;
               default: {goto c9L8y;}
           }
       c9L8I: // global
           R1 = GHC.Conc.Sync.ThreadDied_closure+4;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9L8H: // global
           R1 = GHC.Conc.Sync.ThreadFinished_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9L8F: // global
           R1 = GHC.Conc.Sync.threadStatus2_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9L8E: // global
           R1 = GHC.Conc.Sync.threadStatus3_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9L8C: // global
           R1 = GHC.Conc.Sync.threadStatus4_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9L8B: // global
           R1 = GHC.Conc.Sync.threadStatus5_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9L8G: // global
           R1 = GHC.Conc.Sync.threadStatus6_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9L8z: // global
           R1 = GHC.Conc.Sync.ThreadRunning_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9L8y: // global
           R1 = GHC.Conc.Sync.threadStatus7_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$wthreadStatus_entry() //  [R2]
         { info_tbl: [(c9L8O,
                       label: GHC.Conc.Sync.$wthreadStatus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L8O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9L8P; else goto c9L8Q;
       c9L8P: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.$wthreadStatus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9L8Q: // global
           I64[Sp - 8] = block_c9L8o_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9L8o() //  [R1]
         { info_tbl: [(c9L8o,
                       label: block_c9L8o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L8o: // global
           I64[Sp] = R1;
           Sp = Sp - 8;
           call _c9L8p() args: 0, res: 0, upd: 0;
     }
 },
 _c9L8p() //  []
         { info_tbl: [(c9L8p,
                       label: block_c9L8p_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L8p: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9L8T; else goto c9L8S;
       c9L8T: // global
           HpAlloc = 24;
           I64[Sp] = block_c9L8p_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c9L8S: // global
           I64[Hp - 16] = sat_s9FEg_info;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.383918594 UTC

[section ""data" . GHC.Conc.Sync.threadStatus1_closure" {
     GHC.Conc.Sync.threadStatus1_closure:
         const GHC.Conc.Sync.threadStatus1_info;
 },
 GHC.Conc.Sync.threadStatus1_entry() //  [R2]
         { info_tbl: [(c9L9u,
                       label: GHC.Conc.Sync.threadStatus1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L9u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9L9v; else goto c9L9w;
       c9L9v: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.threadStatus1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9L9w: // global
           I64[Sp - 8] = block_c9L9r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9L9A; else goto c9L9s;
       u9L9A: // global
           call _c9L9r(R1) args: 0, res: 0, upd: 0;
       c9L9s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9L9r() //  [R1]
         { info_tbl: [(c9L9r,
                       label: block_c9L9r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L9r: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wthreadStatus_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.388963195 UTC

[section ""data" . GHC.Conc.Sync.threadStatus_closure" {
     GHC.Conc.Sync.threadStatus_closure:
         const GHC.Conc.Sync.threadStatus_info;
 },
 GHC.Conc.Sync.threadStatus_entry() //  [R2]
         { info_tbl: [(c9L9O,
                       label: GHC.Conc.Sync.threadStatus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L9O: // global
           R2 = R2;
           call GHC.Conc.Sync.threadStatus1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.393394143 UTC

[section ""data" . GHC.Conc.Sync.$fFunctorSTM2_closure" {
     GHC.Conc.Sync.$fFunctorSTM2_closure:
         const GHC.Conc.Sync.$fFunctorSTM2_info;
 },
 GHC.Conc.Sync.$fFunctorSTM2_entry() //  [R2, R3]
         { info_tbl: [(c9La2,
                       label: GHC.Conc.Sync.$fFunctorSTM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9La2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9La3; else goto c9La4;
       c9La3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fFunctorSTM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9La4: // global
           I64[Sp - 16] = block_c9L9Z_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9L9Z() //  [R1]
         { info_tbl: [(c9L9Z,
                       label: block_c9L9Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9L9Z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9La7; else goto c9La6;
       c9La7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9La6: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.398819732 UTC

[section ""data" . GHC.Conc.Sync.$fFunctorSTM1_closure" {
     GHC.Conc.Sync.$fFunctorSTM1_closure:
         const GHC.Conc.Sync.$fFunctorSTM1_info;
 },
 GHC.Conc.Sync.$fFunctorSTM1_entry() //  [R2, R3]
         { info_tbl: [(c9Lao,
                       label: GHC.Conc.Sync.$fFunctorSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lao: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Lap; else goto c9Laq;
       c9Lap: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fFunctorSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Laq: // global
           I64[Sp - 16] = block_c9Lam_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lam() //  []
         { info_tbl: [(c9Lam,
                       label: block_c9Lam_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lam: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.404265668 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM2_closure" {
     GHC.Conc.Sync.$fApplicativeSTM2_closure:
         const GHC.Conc.Sync.$fApplicativeSTM2_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM2_entry() //  [R2, R3]
         { info_tbl: [(c9LaK,
                       label: GHC.Conc.Sync.$fApplicativeSTM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LaK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LaL; else goto c9LaM;
       c9LaL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fApplicativeSTM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9LaM: // global
           I64[Sp - 16] = block_c9LaF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LaF() //  [R1]
         { info_tbl: [(c9LaF,
                       label: block_c9LaF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LaF: // global
           I64[Sp] = block_c9LaH_info;
           _s9FED::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FED::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LaH() //  [R1]
         { info_tbl: [(c9LaH,
                       label: block_c9LaH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LaH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9LaQ; else goto c9LaP;
       c9LaQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LaP: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.411327904 UTC

[section ""data" . $cliftA2_r9Fva_closure" {
     $cliftA2_r9Fva_closure:
         const $cliftA2_r9Fva_info;
 },
 $cliftA2_r9Fva_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Lbd,
                       label: $cliftA2_r9Fva_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lbd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lbe; else goto c9Lbf;
       c9Lbe: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cliftA2_r9Fva_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Lbf: // global
           I64[Sp - 24] = block_c9Lb8_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lb8() //  [R1]
         { info_tbl: [(c9Lb8,
                       label: block_c9Lb8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lb8: // global
           I64[Sp] = block_c9Lba_info;
           _s9FEO::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s9FEO::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lba() //  [R1]
         { info_tbl: [(c9Lba,
                       label: block_c9Lba_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lba: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9Lbj; else goto c9Lbi;
       c9Lbj: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Lbi: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.418527766 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_closure:
         const GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(c9LbC,
                       label: GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LbC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cliftA2_r9Fva_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.421904751 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM1_closure" {
     GHC.Conc.Sync.$fApplicativeSTM1_closure:
         const GHC.Conc.Sync.$fApplicativeSTM1_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM1_entry() //  [R2, R3]
         { info_tbl: [(c9LbR,
                       label: GHC.Conc.Sync.$fApplicativeSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LbR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LbS; else goto c9LbT;
       c9LbS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fApplicativeSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9LbT: // global
           I64[Sp - 16] = block_c9LbN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LbN() //  [R1]
         { info_tbl: [(c9LbN,
                       label: block_c9LbN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LbN: // global
           I64[Sp] = block_c9LbP_info;
           _s9FEY::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FEY::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LbP() //  []
         { info_tbl: [(c9LbP,
                       label: block_c9LbP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LbP: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.429083363 UTC

[section ""data" . GHC.Conc.Sync.$fFunctorSTM_closure" {
     GHC.Conc.Sync.$fFunctorSTM_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Conc.Sync.$fFunctorSTM2_closure+3;
         const GHC.Conc.Sync.$fFunctorSTM1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.430825474 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Conc.Sync.$fFunctorSTM_closure+1;
         const GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure+2;
         const GHC.Conc.Sync.$fApplicativeSTM2_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_closure+4;
         const GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.432783614 UTC

[section ""data" . lvl_r9Fvb_closure" {
     lvl_r9Fvb_closure:
         const lvl_r9Fvb_info;
         const 0;
 },
 lvl_r9Fvb_entry() //  [R2]
         { info_tbl: [(c9Lce,
                       label: lvl_r9Fvb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lce: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.435905985 UTC

[section ""data" . GHC.Conc.Sync.$fMonadSTM_closure" {
     GHC.Conc.Sync.$fMonadSTM_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Conc.Sync.$fApplicativeSTM_closure+1;
         const GHC.Conc.Sync.$fMonadSTM_$c>>=_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure+2;
         const lvl_r9Fvb_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.438052751 UTC

[section ""data" . GHC.Conc.Sync.always2_closure" {
     GHC.Conc.Sync.always2_closure:
         const GHC.Conc.Sync.always2_info;
 },
 GHC.Conc.Sync.always2_entry() //  []
         { info_tbl: [(c9Lcq,
                       label: GHC.Conc.Sync.always2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lcq: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.441811674 UTC

[section ""data" . GHC.Conc.Sync.alwaysSucceeds1_closure" {
     GHC.Conc.Sync.alwaysSucceeds1_closure:
         const GHC.Conc.Sync.alwaysSucceeds1_info;
 },
 sat_s9FFa_entry() //  [R1]
         { info_tbl: [(c9LcJ,
                       label: sat_s9FFa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LcJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9LcK; else goto c9LcL;
       c9LcK: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LcL: // global
           I64[Sp - 8] = block_c9LcH_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LcH() //  []
         { info_tbl: [(c9LcH,
                       label: block_c9LcH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LcH: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.alwaysSucceeds1_entry() //  [R2]
         { info_tbl: [(c9LcR,
                       label: GHC.Conc.Sync.alwaysSucceeds1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LcR: // global
           _s9FF4::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9LcS; else goto c9LcT;
       c9LcT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LcV; else goto c9LcU;
       c9LcV: // global
           HpAlloc = 16;
           goto c9LcS;
       c9LcS: // global
           R2 = _s9FF4::P64;
           R1 = GHC.Conc.Sync.alwaysSucceeds1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LcU: // global
           I64[Hp - 8] = sat_s9FFa_info;
           P64[Hp] = _s9FF4::P64;
           I64[Sp - 16] = block_c9LcN_info;
           R2 = GHC.Conc.Sync.always2_closure+1;
           R1 = Hp - 7;
           P64[Sp - 8] = _s9FF4::P64;
           Sp = Sp - 16;
           call stg_catchRetry#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LcN() //  []
         { info_tbl: [(c9LcN,
                       label: block_c9LcN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LcN: // global
           _s9FF4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9LcP_info;
           R1 = _s9FF4::P64;
           Sp = Sp + 8;
           call stg_check#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LcP() //  []
         { info_tbl: [(c9LcP,
                       label: block_c9LcP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LcP: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.452083703 UTC

[section ""data" . GHC.Conc.Sync.alwaysSucceeds_closure" {
     GHC.Conc.Sync.alwaysSucceeds_closure:
         const GHC.Conc.Sync.alwaysSucceeds_info;
 },
 GHC.Conc.Sync.alwaysSucceeds_entry() //  [R2]
         { info_tbl: [(c9Ldl,
                       label: GHC.Conc.Sync.alwaysSucceeds_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ldl: // global
           R2 = R2;
           call GHC.Conc.Sync.alwaysSucceeds1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.456055054 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM2_closure" {
     GHC.Conc.Sync.$fAlternativeSTM2_closure:
         const GHC.Conc.Sync.$fAlternativeSTM2_info;
 },
 GHC.Conc.Sync.$fAlternativeSTM2_entry() //  []
         { info_tbl: [(c9Ldw,
                       label: GHC.Conc.Sync.$fAlternativeSTM2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ldw: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.460236959 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM3_closure" {
     GHC.Conc.Sync.$fAlternativeSTM3_closure:
         const GHC.Conc.Sync.$fAlternativeSTM3_info;
 },
 some_v_s9FFi_entry() //  [R1]
         { info_tbl: [(c9LdS,
                       label: some_v_s9FFi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LdS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LdT; else goto c9LdU;
       c9LdT: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LdU: // global
           I64[Sp - 16] = block_c9LdN_info;
           _s9FFi::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s9FFi::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LdN() //  [R1]
         { info_tbl: [(c9LdN,
                       label: block_c9LdN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LdN: // global
           I64[Sp] = block_c9LdP_info;
           R2 = GHC.Conc.Sync.$fAlternativeSTM2_closure+1;
           _s9FFm::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FFm::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LdP() //  [R1]
         { info_tbl: [(c9LdP,
                       label: block_c9LdP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LdP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9LdY; else goto c9LdX;
       c9LdY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LdX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fAlternativeSTM3_entry() //  [R2]
         { info_tbl: [(c9LdZ,
                       label: GHC.Conc.Sync.$fAlternativeSTM3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LdZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Le3; else goto c9Le2;
       c9Le3: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fAlternativeSTM3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Le2: // global
           I64[Hp - 8] = some_v_s9FFi_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call some_v_s9FFi_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.469546996 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM1_closure" {
     GHC.Conc.Sync.$fAlternativeSTM1_closure:
         const GHC.Conc.Sync.$fAlternativeSTM1_info;
 },
 many_v_s9FFt_entry() //  [R1]
         { info_tbl: [(c9Lez,
                       label: many_v_s9FFt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lez: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LeA; else goto c9LeB;
       c9LeA: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LeB: // global
           I64[Sp - 16] = block_c9Leu_info;
           _s9FFu::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s9FFu::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Leu() //  [R1]
         { info_tbl: [(c9Leu,
                       label: block_c9Leu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Leu: // global
           I64[Sp] = block_c9Lew_info;
           _s9FFy::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9FFy::P64;
           call many_v1_s9FFu_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lew() //  [R1]
         { info_tbl: [(c9Lew,
                       label: block_c9Lew_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lew: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9LeF; else goto c9LeE;
       c9LeF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LeE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 many_v1_s9FFu_entry() //  [R1]
         { info_tbl: [(c9LeK,
                       label: many_v1_s9FFu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LeK: // global
           R2 = GHC.Conc.Sync.$fAlternativeSTM2_closure+1;
           R1 = P64[R1 + 7];
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fAlternativeSTM1_entry() //  [R2]
         { info_tbl: [(c9LeN,
                       label: GHC.Conc.Sync.$fAlternativeSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LeN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9LeR; else goto c9LeQ;
       c9LeR: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fAlternativeSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LeQ: // global
           I64[Hp - 32] = many_v_s9FFt_info;
           P64[Hp - 24] = R2;
           _c9Lep::P64 = Hp - 7;
           P64[Hp - 16] = _c9Lep::P64;
           I64[Hp - 8] = many_v1_s9FFu_info;
           P64[Hp] = Hp - 31;
           R1 = _c9Lep::P64;
           call many_v1_s9FFu_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.480490389 UTC

[section ""data" . sat_s9FFE_closure" {
     sat_s9FFE_closure:
         const sat_s9FFE_info;
         const 0;
 },
 sat_s9FFE_entry() //  [R2, R3]
         { info_tbl: [(c9Lfg,
                       label: sat_s9FFE_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lfg: // global
           _B3::P64 = R2;
           R2 = R3;
           R1 = _B3::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.483795645 UTC

[section ""data" . sat_s9FFD_closure" {
     sat_s9FFD_closure:
         const sat_s9FFD_info;
         const 0;
 },
 sat_s9FFD_entry() //  []
         { info_tbl: [(c9Lfr,
                       label: sat_s9FFD_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lfr: // global
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.486887786 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM_closure" {
     GHC.Conc.Sync.$fAlternativeSTM_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Conc.Sync.$fApplicativeSTM_closure+1;
         const sat_s9FFD_closure+1;
         const sat_s9FFE_closure+3;
         const GHC.Conc.Sync.$fAlternativeSTM3_closure+2;
         const GHC.Conc.Sync.$fAlternativeSTM1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.489399149 UTC

[section ""data" . sat_s9FFG_closure" {
     sat_s9FFG_closure:
         const sat_s9FFG_info;
         const 0;
 },
 sat_s9FFG_entry() //  [R2, R3]
         { info_tbl: [(c9LfD,
                       label: sat_s9FFG_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LfD: // global
           _B3::P64 = R2;
           R2 = R3;
           R1 = _B3::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.492629851 UTC

[section ""data" . sat_s9FFF_closure" {
     sat_s9FFF_closure:
         const sat_s9FFF_info;
         const 0;
 },
 sat_s9FFF_entry() //  []
         { info_tbl: [(c9LfO,
                       label: sat_s9FFF_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LfO: // global
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.495674527 UTC

[section ""data" . GHC.Conc.Sync.$fMonadPlusSTM_closure" {
     GHC.Conc.Sync.$fMonadPlusSTM_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Conc.Sync.$fAlternativeSTM_closure+1;
         const GHC.Conc.Sync.$fMonadSTM_closure+1;
         const sat_s9FFF_closure+1;
         const sat_s9FFG_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.497821902 UTC

[section ""cstring" . lvl1_r9Fvc_bytes" {
     lvl1_r9Fvc_bytes:
         I8[] [84,114,97,110,115,97,99,116,105,111,110,97,108,32,105,110,118,97,114,105,97,110,116,32,118,105,111,108,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.499663834 UTC

[section ""data" . GHC.Conc.Sync.always3_closure" {
     GHC.Conc.Sync.always3_closure:
         const GHC.Conc.Sync.always3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.always3_entry() //  [R1]
         { info_tbl: [(c9Lg5,
                       label: GHC.Conc.Sync.always3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lg5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lg6; else goto c9Lg7;
       c9Lg6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Lg7: // global
           (_c9Lg0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Lg0::I64 == 0) goto c9Lg2; else goto c9Lg1;
       c9Lg2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Lg1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Lg0::I64;
           I64[Sp - 24] = block_c9Lg3_info;
           R2 = lvl1_r9Fvc_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9Lg3() //  [R1]
         { info_tbl: [(c9Lg3,
                       label: block_c9Lg3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lg3: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.505780935 UTC

[section ""data" . GHC.Conc.Sync.always1_closure" {
     GHC.Conc.Sync.always1_closure:
         const GHC.Conc.Sync.always1_info;
         const 0;
 },
 sat_s9FFQ_entry() //  [R1]
         { info_tbl: [(c9LgD,
                       label: sat_s9FFQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LgD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9LgE; else goto c9LgF;
       c9LgE: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LgF: // global
           I64[Sp - 8] = block_c9Lgu_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lgu() //  [R1]
         { info_tbl: [(c9Lgu,
                       label: block_c9Lgu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lgu: // global
           I64[Sp] = block_c9Lgw_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u9LgN; else goto c9Lgx;
       u9LgN: // global
           call _c9Lgw(R1) args: 0, res: 0, upd: 0;
       c9Lgx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lgw() //  [R1]
         { info_tbl: [(c9Lgw,
                       label: block_c9Lgw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lgw: // global
           if (R1 & 7 == 1) goto c9LgA; else goto c9LgB;
       c9LgA: // global
           R1 = GHC.Conc.Sync.always3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9LgB: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FG0_entry() //  [R1]
         { info_tbl: [(c9Lh4,
                       label: sat_s9FG0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lh4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Lh5; else goto c9Lh6;
       c9Lh5: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Lh6: // global
           I64[Sp - 8] = block_c9LgV_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LgV() //  [R1]
         { info_tbl: [(c9LgV,
                       label: block_c9LgV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LgV: // global
           I64[Sp] = block_c9LgX_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u9Lhe; else goto c9LgY;
       u9Lhe: // global
           call _c9LgX(R1) args: 0, res: 0, upd: 0;
       c9LgY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LgX() //  [R1]
         { info_tbl: [(c9LgX,
                       label: block_c9LgX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LgX: // global
           if (R1 & 7 == 1) goto c9Lh1; else goto c9Lh2;
       c9Lh1: // global
           R1 = GHC.Conc.Sync.always3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9Lh2: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.always1_entry() //  [R2]
         { info_tbl: [(c9Lhh,
                       label: GHC.Conc.Sync.always1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lhh: // global
           _s9FFI::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Lhi; else goto c9Lhj;
       c9Lhj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Lhl; else goto c9Lhk;
       c9Lhl: // global
           HpAlloc = 16;
           goto c9Lhi;
       c9Lhi: // global
           R2 = _s9FFI::P64;
           R1 = GHC.Conc.Sync.always1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Lhk: // global
           I64[Hp - 8] = sat_s9FFQ_info;
           P64[Hp] = _s9FFI::P64;
           I64[Sp - 16] = block_c9LgO_info;
           R2 = GHC.Conc.Sync.always2_closure+1;
           R1 = Hp - 7;
           P64[Sp - 8] = _s9FFI::P64;
           Sp = Sp - 16;
           call stg_catchRetry#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LgO() //  [R1]
         { info_tbl: [(c9LgO,
                       label: block_c9LgO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LgO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Lho; else goto c9Lhn;
       c9Lho: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Lhn: // global
           I64[Hp - 8] = sat_s9FG0_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c9Lhf_info;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call stg_check#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lhf() //  []
         { info_tbl: [(c9Lhf,
                       label: block_c9Lhf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lhf: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.524051468 UTC

[section ""data" . GHC.Conc.Sync.always_closure" {
     GHC.Conc.Sync.always_closure:
         const GHC.Conc.Sync.always_info;
         const 0;
 },
 GHC.Conc.Sync.always_entry() //  [R2]
         { info_tbl: [(c9Li8,
                       label: GHC.Conc.Sync.always_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Li8: // global
           R2 = R2;
           call GHC.Conc.Sync.always1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.527207166 UTC

[section ""cstring" . lvl2_r9Fvd_bytes" {
     lvl2_r9Fvd_bytes:
         I8[] [110,111,32,116,104,114,101,97,100,115,32,116,111,32,114,117,110,58,32,32,105,110,102,105,110,105,116,101,32,108,111,111,112,32,111,114,32,100,101,97,100,108,111,99,107,63]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.528992054 UTC

[section ""data" . lvl3_r9Fve_closure" {
     lvl3_r9Fve_closure:
         const lvl3_r9Fve_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r9Fve_entry() //  [R1]
         { info_tbl: [(c9Lim,
                       label: lvl3_r9Fve_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lim: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Lin; else goto c9Lio;
       c9Lin: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Lio: // global
           (_c9Lij::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Lij::I64 == 0) goto c9Lil; else goto c9Lik;
       c9Lil: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Lik: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Lij::I64;
           R2 = lvl2_r9Fvd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.533221387 UTC

[section ""data" . lvl4_r9Fvf_closure" {
     lvl4_r9Fvf_closure:
         const lvl4_r9Fvf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r9Fvf_entry() //  [R1]
         { info_tbl: [(c9LiH,
                       label: lvl4_r9Fvf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LiH: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9LiI; else goto c9LiJ;
       c9LiI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9LiJ: // global
           (_c9Liz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Liz::I64 == 0) goto c9LiB; else goto c9LiA;
       c9LiB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9LiA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Liz::I64;
           I64[Sp - 24] = block_c9LiC_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionDeadlock4_closure;
           R4 = GHC.IO.Exception.$trModule_closure;
           R3 = 11186984538024031318;
           R2 = 18363794241794644491;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c9LiC() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c9LiC,
                       label: block_c9LiC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LiC: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c9LiD() args: 0, res: 0, upd: 0;
     }
 },
 _c9LiD() //  []
         { info_tbl: [(c9LiD,
                       label: block_c9LiD_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LiD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c9LiM; else goto c9LiL;
       c9LiM: // global
           HpAlloc = 48;
           I64[Sp] = block_c9LiD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c9LiL: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.541124103 UTC

[section ""cstring" . lvl5_r9Fvg_bytes" {
     lvl5_r9Fvg_bytes:
         I8[] [37,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.542986992 UTC

[section ""data" . lvl6_r9Fvh_closure" {
     lvl6_r9Fvh_closure:
         const lvl6_r9Fvh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r9Fvh_entry() //  [R1]
         { info_tbl: [(c9Ljf,
                       label: lvl6_r9Fvh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ljf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Ljg; else goto c9Ljh;
       c9Ljg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Ljh: // global
           (_c9Ljc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Ljc::I64 == 0) goto c9Lje; else goto c9Ljd;
       c9Lje: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Ljd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Ljc::I64;
           R2 = lvl5_r9Fvg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.546831968 UTC

[section ""data" . lvl7_r9Fvi_closure" {
     lvl7_r9Fvi_closure:
         const lvl7_r9Fvi_info;
 },
 lvl7_r9Fvi_entry() //  [R2]
         { info_tbl: [(c9Ljw,
                       label: lvl7_r9Fvi_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ljw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Ljx; else goto c9Ljy;
       c9Ljx: // global
           R2 = R2;
           R1 = lvl7_r9Fvi_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Ljy: // global
           I64[Sp - 8] = block_c9Ljt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9LjC; else goto c9Lju;
       u9LjC: // global
           call _c9Ljt() args: 0, res: 0, upd: 0;
       c9Lju: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ljt() //  []
         { info_tbl: [(c9Ljt,
                       label: block_c9Ljt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ljt: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.552241565 UTC

[section ""data" . lvl8_r9Fvj_closure" {
     lvl8_r9Fvj_closure:
         const lvl8_r9Fvj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_r9Fvj_entry() //  [R1]
         { info_tbl: [(c9LjT,
                       label: lvl8_r9Fvj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LjT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LjU; else goto c9LjV;
       c9LjU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9LjV: // global
           (_c9LjQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9LjQ::I64 == 0) goto c9LjS; else goto c9LjR;
       c9LjS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9LjR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9LjQ::I64;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           R1 = GHC.IO.Handle.hFlush_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.557970032 UTC

[section ""data" . lvl9_r9Fvk_closure" {
     lvl9_r9Fvk_closure:
         const lvl9_r9Fvk_info;
         const 0;
 },
 msg_s9FGp_entry() //  [R1]
         { info_tbl: [(c9Lko,
                       label: msg_s9FGp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lko: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c9Lkp; else goto c9Lkq;
       c9Lkp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Lkq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9Lkm_info;
           _s9FGg::P64 = P64[R1 + 16];
           R2 = _s9FGg::P64;
           P64[Sp - 32] = _s9FGg::P64;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9Lkm() //  [R1]
         { info_tbl: [(c9Lkm,
                       label: block_c9Lkm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lkm: // global
           I64[Sp] = block_c9Lkt_info;
           R3 = lvl4_r9Fvf_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9Lkt() //  [R1]
         { info_tbl: [(c9Lkt,
                       label: block_c9Lkt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lkt: // global
           if (R1 & 7 == 1) goto c9LkB; else goto c9LkK;
       c9LkB: // global
           _s9FGg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9Lky_info;
           R2 = _s9FGg::P64;
           Sp = Sp + 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 24;
       c9LkK: // global
           _s9FGh::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9LkI_info;
           R1 = _s9FGh::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9Lky() //  [R1]
         { info_tbl: [(c9Lky,
                       label: block_c9Lky_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lky: // global
           R2 = R1;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = GHC.Conc.Sync.$fShowThreadStatus2_closure+1;
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 _c9LkI() //  []
         { info_tbl: [(c9LkI,
                       label: block_c9LkI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LkI: // global
           R1 = lvl3_r9Fve_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9FGI_entry() //  [R1, R2]
         { info_tbl: [(c9Ll5,
                       label: sat_s9FGI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ll5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Ll9; else goto c9Lla;
       c9Ll9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Lla: // global
           I64[Sp - 16] = block_c9Ll2_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Lll; else goto c9Ll3;
       u9Lll: // global
           call _c9Ll2(R1) args: 0, res: 0, upd: 0;
       c9Ll3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ll2() //  [R1]
         { info_tbl: [(c9Ll2,
                       label: block_c9Ll2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ll2: // global
           I64[Sp] = block_c9Ll8_info;
           _s9FGC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s9FGC::I64;
           if (R1 & 7 != 0) goto u9Llk; else goto c9Llc;
       u9Llk: // global
           call _c9Ll8(R1) args: 0, res: 0, upd: 0;
       c9Llc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ll8() //  [R1]
         { info_tbl: [(c9Ll8,
                       label: block_c9Ll8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ll8: // global
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] errorBelch2(I64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FGJ_entry() //  [R1, R2]
         { info_tbl: [(c9Llm,
                       label: sat_s9FGJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Llm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lln; else goto c9Llo;
       c9Lln: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Llo: // global
           I64[Sp - 24] = block_c9LkV_info;
           _s9FGp::P64 = P64[R1 + 6];
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 16] = _s9FGp::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LkV() //  [R1]
         { info_tbl: [(c9LkV,
                       label: block_c9LkV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LkV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Llr; else goto c9Llq;
       c9Llr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Llq: // global
           I64[Hp - 8] = sat_s9FGI_info;
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 6;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 lvl9_r9Fvk_entry() //  [R2]
         { info_tbl: [(c9Lls,
                       label: lvl9_r9Fvk_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lls: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Llt; else goto c9Llu;
       c9Llt: // global
           R2 = R2;
           R1 = lvl9_r9Fvk_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Llu: // global
           I64[Sp - 8] = block_c9Lk7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9LlB; else goto c9Lk8;
       u9LlB: // global
           call _c9Lk7(R1) args: 0, res: 0, upd: 0;
       c9Lk8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lk7() //  [R1]
         { info_tbl: [(c9Lk7,
                       label: block_c9Lk7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lk7: // global
           I64[Sp - 16] = block_c9Lkc_info;
           _s9FGg::P64 = P64[R1 + 7];
           _s9FGh::P64 = P64[R1 + 15];
           R1 = lvl8_r9Fvj_closure;
           P64[Sp - 8] = _s9FGh::P64;
           P64[Sp] = _s9FGg::P64;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lkc() //  [R1]
         { info_tbl: [(c9Lkc,
                       label: block_c9Lkc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lkc: // global
           I64[Sp] = block_c9Lke_info;
           R2 = lvl7_r9Fvi_closure+2;
           R1 = R1;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lke() //  []
         { info_tbl: [(c9Lke,
                       label: block_c9Lke_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lke: // global
           I64[Sp] = block_c9Lkg_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lkg() //  [R1]
         { info_tbl: [(c9Lkg,
                       label: block_c9Lkg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lkg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c9LlA; else goto c9Llz;
       c9LlA: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Llz: // global
           I64[Hp - 40] = msg_s9FGp_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_s9FGJ_info;
           P64[Hp] = Hp - 40;
           R4 = Hp - 6;
           R3 = lvl6_r9Fvh_closure;
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.585735261 UTC

[section ""data" . lvl10_r9Fvl_closure" {
     lvl10_r9Fvl_closure:
         const lvl10_r9Fvl_info;
         const 0;
 },
 lvl10_r9Fvl_entry() //  []
         { info_tbl: [(c9LmM,
                       label: lvl10_r9Fvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LmM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9LmN; else goto c9LmO;
       c9LmN: // global
           R1 = lvl10_r9Fvl_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LmO: // global
           I64[Sp - 8] = block_c9LmH_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _c9LmH() //  []
         { info_tbl: [(c9LmH,
                       label: block_c9LmH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LmH: // global
           I64[Sp] = block_c9LmJ_info;
           R1 = lvl9_r9Fvk_closure+2;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LmJ() //  [R1]
         { info_tbl: [(c9LmJ,
                       label: block_c9LmJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LmJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LmS; else goto c9LmR;
       c9LmS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LmR: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.593506558 UTC

[section ""data" . GHC.Conc.Sync.uncaughtExceptionHandler_closure" {
     GHC.Conc.Sync.uncaughtExceptionHandler_closure:
         const GHC.Conc.Sync.uncaughtExceptionHandler_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.uncaughtExceptionHandler_entry() //  [R1]
         { info_tbl: [(c9Lnd,
                       label: GHC.Conc.Sync.uncaughtExceptionHandler_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lnd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lne; else goto c9Lnf;
       c9Lne: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Lnf: // global
           (_c9Ln8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Ln8::I64 == 0) goto c9Lna; else goto c9Ln9;
       c9Lna: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Ln9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Ln8::I64;
           I64[Sp - 24] = block_c9Lnb_info;
           Sp = Sp - 24;
           call lvl10_r9Fvl_entry() args: 8, res: 8, upd: 24;
     }
 },
 _c9Lnb() //  [R1]
         { info_tbl: [(c9Lnb,
                       label: block_c9Lnb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lnb: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.598934284 UTC

[section ""data" . GHC.Conc.Sync.setUncaughtExceptionHandler1_closure" {
     GHC.Conc.Sync.setUncaughtExceptionHandler1_closure:
         const GHC.Conc.Sync.setUncaughtExceptionHandler1_info;
         const 0;
 },
 GHC.Conc.Sync.setUncaughtExceptionHandler1_entry() //  [R2]
         { info_tbl: [(c9Lnx,
                       label: GHC.Conc.Sync.setUncaughtExceptionHandler1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lnx: // global
           R3 = R2;
           R2 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           call GHC.STRef.writeSTRef1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.602544068 UTC

[section ""data" . GHC.Conc.Sync.setUncaughtExceptionHandler_closure" {
     GHC.Conc.Sync.setUncaughtExceptionHandler_closure:
         const GHC.Conc.Sync.setUncaughtExceptionHandler_info;
         const 0;
 },
 GHC.Conc.Sync.setUncaughtExceptionHandler_entry() //  [R2]
         { info_tbl: [(c9LnI,
                       label: GHC.Conc.Sync.setUncaughtExceptionHandler_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LnI: // global
           R2 = R2;
           call GHC.Conc.Sync.setUncaughtExceptionHandler1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.605789832 UTC

[section ""data" . GHC.Conc.Sync.getUncaughtExceptionHandler1_closure" {
     GHC.Conc.Sync.getUncaughtExceptionHandler1_closure:
         const GHC.Conc.Sync.getUncaughtExceptionHandler1_info;
         const 0;
 },
 GHC.Conc.Sync.getUncaughtExceptionHandler1_entry() //  []
         { info_tbl: [(c9LnT,
                       label: GHC.Conc.Sync.getUncaughtExceptionHandler1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LnT: // global
           R2 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           call GHC.STRef.readSTRef1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.609019984 UTC

[section ""data" . GHC.Conc.Sync.getUncaughtExceptionHandler_closure" {
     GHC.Conc.Sync.getUncaughtExceptionHandler_closure:
         const GHC.Conc.Sync.getUncaughtExceptionHandler_info;
         const 0;
 },
 GHC.Conc.Sync.getUncaughtExceptionHandler_entry() //  []
         { info_tbl: [(c9Lo4,
                       label: GHC.Conc.Sync.getUncaughtExceptionHandler_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lo4: // global
           call GHC.Conc.Sync.getUncaughtExceptionHandler1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.612477503 UTC

[section ""data" . GHC.Conc.Sync.reportError1_closure" {
     GHC.Conc.Sync.reportError1_closure:
         const GHC.Conc.Sync.reportError1_info;
         const 0;
 },
 GHC.Conc.Sync.reportError1_entry() //  [R2]
         { info_tbl: [(c9Loi,
                       label: GHC.Conc.Sync.reportError1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Loi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Loj; else goto c9Lok;
       c9Loj: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.reportError1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Lok: // global
           I64[Sp - 16] = block_c9Lof_info;
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Loo; else goto c9Log;
       u9Loo: // global
           call _c9Lof(R1) args: 0, res: 0, upd: 0;
       c9Log: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lof() //  [R1]
         { info_tbl: [(c9Lof,
                       label: block_c9Lof_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lof: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.61825731 UTC

[section ""data" . GHC.Conc.Sync.reportError_closure" {
     GHC.Conc.Sync.reportError_closure:
         const GHC.Conc.Sync.reportError_info;
         const 0;
 },
 GHC.Conc.Sync.reportError_entry() //  [R2]
         { info_tbl: [(c9LoD,
                       label: GHC.Conc.Sync.reportError_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LoD: // global
           R2 = R2;
           call GHC.Conc.Sync.reportError1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.622304961 UTC

[section ""data" . GHC.Conc.Sync.sharedCAF1_closure" {
     GHC.Conc.Sync.sharedCAF1_closure:
         const GHC.Conc.Sync.sharedCAF1_info;
 },
 io_s9FH6_entry() //  [R1]
         { info_tbl: [(c9Lp3,
                       label: io_s9FH6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lp3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lp4; else goto c9Lp5;
       c9Lp4: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Lp5: // global
           I64[Sp - 24] = block_c9LoV_info;
           _s9FH0::P64 = P64[R1 + 7];
           _s9FH1::P64 = P64[R1 + 15];
           R1 = _s9FH0::P64;
           P64[Sp - 16] = _s9FH0::P64;
           P64[Sp - 8] = _s9FH1::P64;
           Sp = Sp - 24;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LoV() //  [R1]
         { info_tbl: [(c9LoV,
                       label: block_c9LoV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LoV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Lp8; else goto c9Lp7;
       c9Lp8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9Lp7: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = R1;
           I64[Sp] = block_c9LoY_info;
           R2 = Hp - 7;
           _s9FHa::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s9FHa::I64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LoY() //  [R1]
         { info_tbl: [(c9LoY,
                       label: block_c9LoY_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LoY: // global
           I64[Sp] = block_c9Lp0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u9Lpl; else goto c9Lp1;
       u9Lpl: // global
           call _c9Lp0(R1) args: 0, res: 0, upd: 0;
       c9Lp1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lp0() //  [R1]
         { info_tbl: [(c9Lp0,
                       label: block_c9Lp0_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lp0: // global
           _s9FHa::I64 = I64[Sp + 16];
           _s9FHg::I64 = I64[R1 + 7];
           if (_s9FHa::I64 == _s9FHg::I64) goto c9Lph; else goto c9Lpg;
       c9Lph: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Lpg: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(_s9FHa::I64);
           R1 = _s9FHg::I64;
           Sp = Sp + 24;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.sharedCAF1_entry() //  [R2, R3]
         { info_tbl: [(c9Lpq,
                       label: GHC.Conc.Sync.sharedCAF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lpq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lpr; else goto c9Lps;
       c9Lpr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.sharedCAF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Lps: // global
           I64[Sp - 24] = block_c9LoO_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c9LoO() //  [R1]
         { info_tbl: [(c9LoO,
                       label: block_c9LoO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LoO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Lpv; else goto c9Lpu;
       c9Lpv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9Lpu: // global
           I64[Hp - 16] = io_s9FH6_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _c9LoQ::P64 = Hp - 15;
           if (R1 == 0) goto c9Lpp; else goto c9Lpo;
       c9Lpp: // global
           R1 = _c9LoQ::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       c9Lpo: // global
           R1 = _c9LoQ::P64;
           Sp = Sp + 24;
           call io_s9FH6_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.635992053 UTC

[section ""data" . GHC.Conc.Sync.sharedCAF_closure" {
     GHC.Conc.Sync.sharedCAF_closure:
         const GHC.Conc.Sync.sharedCAF_info;
 },
 GHC.Conc.Sync.sharedCAF_entry() //  [R2, R3]
         { info_tbl: [(c9LpZ,
                       label: GHC.Conc.Sync.sharedCAF_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LpZ: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.sharedCAF1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.642186215 UTC

[section ""data" . GHC.Conc.Sync.$wmodifyMVar__closure" {
     GHC.Conc.Sync.$wmodifyMVar__closure:
         const GHC.Conc.Sync.$wmodifyMVar__info;
 },
 sat_s9FHF_entry() //  [R1]
         { info_tbl: [(c9Lqx,
                       label: sat_s9FHF_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lqx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lqy; else goto c9Lqz;
       c9Lqy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Lqz: // global
           I64[Sp - 24] = block_c9Lqv_info;
           R2 = P64[R1 + 15];
           _s9FHA::P64 = P64[R1 + 23];
           _s9FHB::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FHA::P64;
           P64[Sp - 8] = _s9FHB::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lqv() //  []
         { info_tbl: [(c9Lqv,
                       label: block_c9Lqv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lqv: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHG_entry() //  [R1, R2]
         { info_tbl: [(c9LqB,
                       label: sat_s9FHG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LqB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9LqC; else goto c9LqD;
       c9LqC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LqD: // global
           I64[Sp - 24] = block_c9Lql_info;
           _s9FHm::P64 = P64[R1 + 7];
           _s9FHv::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FHm::P64;
           P64[Sp - 8] = _s9FHv::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9LqH; else goto c9Lqm;
       u9LqH: // global
           call _c9Lql(R1) args: 0, res: 0, upd: 0;
       c9Lqm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lql() //  [R1]
         { info_tbl: [(c9Lql,
                       label: block_c9Lql_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lql: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9LqG; else goto c9LqF;
       c9LqG: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LqF: // global
           _s9FHA::P64 = P64[R1 + 7];
           _s9FHB::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FHF_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FHA::P64;
           P64[Hp] = _s9FHB::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHx_entry() //  [R1]
         { info_tbl: [(c9LqO,
                       label: sat_s9FHx_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LqO: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHY_entry() //  [R1]
         { info_tbl: [(c9Lrg,
                       label: sat_s9FHY_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lrg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lrh; else goto c9Lri;
       c9Lrh: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Lri: // global
           I64[Sp - 24] = block_c9Lre_info;
           R2 = P64[R1 + 15];
           _s9FHT::P64 = P64[R1 + 23];
           _s9FHU::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FHT::P64;
           P64[Sp - 8] = _s9FHU::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lre() //  []
         { info_tbl: [(c9Lre,
                       label: block_c9Lre_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lre: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHZ_entry() //  [R1, R2]
         { info_tbl: [(c9Lrk,
                       label: sat_s9FHZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lrk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lrl; else goto c9Lrm;
       c9Lrl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Lrm: // global
           I64[Sp - 24] = block_c9Lr4_info;
           _s9FHm::P64 = P64[R1 + 7];
           _s9FHO::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FHm::P64;
           P64[Sp - 8] = _s9FHO::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Lrq; else goto c9Lr5;
       u9Lrq: // global
           call _c9Lr4(R1) args: 0, res: 0, upd: 0;
       c9Lr5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lr4() //  [R1]
         { info_tbl: [(c9Lr4,
                       label: block_c9Lr4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lr4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9Lrp; else goto c9Lro;
       c9Lrp: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Lro: // global
           _s9FHT::P64 = P64[R1 + 7];
           _s9FHU::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FHY_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FHT::P64;
           P64[Hp] = _s9FHU::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FHQ_entry() //  [R1]
         { info_tbl: [(c9Lrx,
                       label: sat_s9FHQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lrx: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FI4_entry() //  [R1]
         { info_tbl: [(c9LrE,
                       label: sat_s9FI4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LrE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9LrF; else goto c9LrG;
       c9LrF: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LrG: // global
           I64[Sp - 24] = block_c9LqX_info;
           _s9FHm::P64 = P64[R1 + 7];
           _s9FHn::P64 = P64[R1 + 15];
           R1 = _s9FHm::P64;
           P64[Sp - 16] = _s9FHm::P64;
           P64[Sp - 8] = _s9FHn::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LqX() //  [R1]
         { info_tbl: [(c9LqX,
                       label: block_c9LqX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LqX: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9LrJ; else goto c9LrI;
       c9LrJ: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LrI: // global
           I64[Hp - 64] = sat_s9FHZ_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FHQ_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9LrA_info;
           R2 = Hp - 63;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LrA() //  [R1]
         { info_tbl: [(c9LrA,
                       label: block_c9LrA_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LrA: // global
           I64[Sp + 16] = block_c9LrC_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LrC() //  []
         { info_tbl: [(c9LrC,
                       label: block_c9LrC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LrC: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FIh_entry() //  [R1]
         { info_tbl: [(c9Ls6,
                       label: sat_s9FIh_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ls6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Ls7; else goto c9Ls8;
       c9Ls7: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Ls8: // global
           I64[Sp - 24] = block_c9Ls4_info;
           R2 = P64[R1 + 15];
           _s9FIc::P64 = P64[R1 + 23];
           _s9FId::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FIc::P64;
           P64[Sp - 8] = _s9FId::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ls4() //  []
         { info_tbl: [(c9Ls4,
                       label: block_c9Ls4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ls4: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FIi_entry() //  [R1, R2]
         { info_tbl: [(c9Lsa,
                       label: sat_s9FIi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lsa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lsb; else goto c9Lsc;
       c9Lsb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Lsc: // global
           I64[Sp - 24] = block_c9LrU_info;
           _s9FHm::P64 = P64[R1 + 7];
           _s9FI7::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FHm::P64;
           P64[Sp - 8] = _s9FI7::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Lsg; else goto c9LrV;
       u9Lsg: // global
           call _c9LrU(R1) args: 0, res: 0, upd: 0;
       c9LrV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LrU() //  [R1]
         { info_tbl: [(c9LrU,
                       label: block_c9LrU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LrU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9Lsf; else goto c9Lse;
       c9Lsf: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Lse: // global
           _s9FIc::P64 = P64[R1 + 7];
           _s9FId::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FIh_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FIc::P64;
           P64[Hp] = _s9FId::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FI9_entry() //  [R1]
         { info_tbl: [(c9Lsn,
                       label: sat_s9FI9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lsn: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$wmodifyMVar__entry() //  [R2, R3]
         { info_tbl: [(c9Lsu,
                       label: GHC.Conc.Sync.$wmodifyMVar__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lsu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lsv; else goto c9Lsw;
       c9Lsv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$wmodifyMVar__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Lsw: // global
           I64[Sp - 24] = block_c9Lqa_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c9Lqa() //  [R1]
         { info_tbl: [(c9Lqa,
                       label: block_c9Lqa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lqa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Lsz; else goto c9Lsy;
       c9Lsz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9Lsy: // global
           _s9FHm::P64 = P64[Sp + 8];
           if (R1 == 0) goto c9Lss; else goto u9LsS;
       c9Lss: // global
           I64[Hp - 16] = sat_s9FI4_info;
           P64[Hp - 8] = _s9FHm::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u9LsS: // global
           if (R1 == 1) goto c9Lst; else goto c9Lsr;
       c9Lst: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9LrN_info;
           R1 = _s9FHm::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       c9Lsr: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9Lqe_info;
           R1 = _s9FHm::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LrN() //  [R1]
         { info_tbl: [(c9LrN,
                       label: block_c9LrN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LrN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9LsO; else goto c9LsN;
       c9LsO: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LsN: // global
           I64[Hp - 64] = sat_s9FIi_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FI9_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9LsJ_info;
           R2 = Hp - 63;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LsJ() //  [R1]
         { info_tbl: [(c9LsJ,
                       label: block_c9LsJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LsJ: // global
           I64[Sp + 16] = block_c9LsL_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lqe() //  [R1]
         { info_tbl: [(c9Lqe,
                       label: block_c9Lqe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lqe: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9LsF; else goto c9LsE;
       c9LsF: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LsE: // global
           I64[Hp - 64] = sat_s9FHG_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FHx_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9LsA_info;
           R2 = Hp - 63;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LsA() //  [R1]
         { info_tbl: [(c9LsA,
                       label: block_c9LsA_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LsA: // global
           I64[Sp + 16] = block_c9LsL_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LsL() //  []
         { info_tbl: [(c9LsL,
                       label: block_c9LsL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LsL: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.690429487 UTC

[section ""data" . GHC.Conc.Sync.modifyMVar_1_closure" {
     GHC.Conc.Sync.modifyMVar_1_closure:
         const GHC.Conc.Sync.modifyMVar_1_info;
 },
 GHC.Conc.Sync.modifyMVar_1_entry() //  [R2, R3]
         { info_tbl: [(c9LuN,
                       label: GHC.Conc.Sync.modifyMVar_1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LuN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LuO; else goto c9LuP;
       c9LuO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.modifyMVar_1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9LuP: // global
           I64[Sp - 16] = block_c9LuK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9LuT; else goto c9LuL;
       u9LuT: // global
           call _c9LuK(R1) args: 0, res: 0, upd: 0;
       c9LuL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LuK() //  [R1]
         { info_tbl: [(c9LuK,
                       label: block_c9LuK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LuK: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$wmodifyMVar__entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.695753986 UTC

[section ""data" . GHC.Conc.Sync.modifyMVar__closure" {
     GHC.Conc.Sync.modifyMVar__closure:
         const GHC.Conc.Sync.modifyMVar__info;
 },
 GHC.Conc.Sync.modifyMVar__entry() //  [R2, R3]
         { info_tbl: [(c9Lv7,
                       label: GHC.Conc.Sync.modifyMVar__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lv7: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.modifyMVar_1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.701924036 UTC

[section ""data" . GHC.Conc.Sync.$wwithMVar_closure" {
     GHC.Conc.Sync.$wwithMVar_closure:
         const GHC.Conc.Sync.$wwithMVar_info;
 },
 sat_s9FIL_entry() //  [R1]
         { info_tbl: [(c9LvF,
                       label: sat_s9FIL_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LvF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9LvG; else goto c9LvH;
       c9LvG: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LvH: // global
           I64[Sp - 24] = block_c9LvD_info;
           R2 = P64[R1 + 15];
           _s9FIG::P64 = P64[R1 + 23];
           _s9FIH::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FIG::P64;
           P64[Sp - 8] = _s9FIH::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LvD() //  []
         { info_tbl: [(c9LvD,
                       label: block_c9LvD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LvD: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FIM_entry() //  [R1, R2]
         { info_tbl: [(c9LvJ,
                       label: sat_s9FIM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LvJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9LvK; else goto c9LvL;
       c9LvK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LvL: // global
           I64[Sp - 24] = block_c9Lvt_info;
           _s9FIs::P64 = P64[R1 + 7];
           _s9FIB::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FIs::P64;
           P64[Sp - 8] = _s9FIB::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9LvP; else goto c9Lvu;
       u9LvP: // global
           call _c9Lvt(R1) args: 0, res: 0, upd: 0;
       c9Lvu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lvt() //  [R1]
         { info_tbl: [(c9Lvt,
                       label: block_c9Lvt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lvt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9LvO; else goto c9LvN;
       c9LvO: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LvN: // global
           _s9FIG::P64 = P64[R1 + 7];
           _s9FIH::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FIL_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FIG::P64;
           P64[Hp] = _s9FIH::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FID_entry() //  [R1]
         { info_tbl: [(c9LvW,
                       label: sat_s9FID_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LvW: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJ4_entry() //  [R1]
         { info_tbl: [(c9Lwo,
                       label: sat_s9FJ4_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lwo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lwp; else goto c9Lwq;
       c9Lwp: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Lwq: // global
           I64[Sp - 24] = block_c9Lwm_info;
           R2 = P64[R1 + 15];
           _s9FIZ::P64 = P64[R1 + 23];
           _s9FJ0::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FIZ::P64;
           P64[Sp - 8] = _s9FJ0::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lwm() //  []
         { info_tbl: [(c9Lwm,
                       label: block_c9Lwm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lwm: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJ5_entry() //  [R1, R2]
         { info_tbl: [(c9Lws,
                       label: sat_s9FJ5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lws: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lwt; else goto c9Lwu;
       c9Lwt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Lwu: // global
           I64[Sp - 24] = block_c9Lwc_info;
           _s9FIs::P64 = P64[R1 + 7];
           _s9FIU::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FIs::P64;
           P64[Sp - 8] = _s9FIU::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Lwy; else goto c9Lwd;
       u9Lwy: // global
           call _c9Lwc(R1) args: 0, res: 0, upd: 0;
       c9Lwd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lwc() //  [R1]
         { info_tbl: [(c9Lwc,
                       label: block_c9Lwc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lwc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9Lwx; else goto c9Lww;
       c9Lwx: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Lww: // global
           _s9FIZ::P64 = P64[R1 + 7];
           _s9FJ0::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FJ4_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FIZ::P64;
           P64[Hp] = _s9FJ0::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FIW_entry() //  [R1]
         { info_tbl: [(c9LwF,
                       label: sat_s9FIW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LwF: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJa_entry() //  [R1]
         { info_tbl: [(c9LwM,
                       label: sat_s9FJa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LwM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9LwN; else goto c9LwO;
       c9LwN: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LwO: // global
           I64[Sp - 24] = block_c9Lw5_info;
           _s9FIs::P64 = P64[R1 + 7];
           _s9FIt::P64 = P64[R1 + 15];
           R1 = _s9FIs::P64;
           P64[Sp - 16] = _s9FIs::P64;
           P64[Sp - 8] = _s9FIt::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lw5() //  [R1]
         { info_tbl: [(c9Lw5,
                       label: block_c9Lw5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lw5: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9LwR; else goto c9LwQ;
       c9LwR: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LwQ: // global
           I64[Hp - 64] = sat_s9FJ5_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FIW_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9LwI_info;
           R2 = Hp - 63;
           _s9FIU::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s9FIU::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LwI() //  [R1]
         { info_tbl: [(c9LwI,
                       label: block_c9LwI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LwI: // global
           _s9FIs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9LwK_info;
           R2 = P64[Sp + 16];
           _s9FJ8::P64 = R1;
           R1 = _s9FIs::P64;
           P64[Sp + 16] = _s9FJ8::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LwK() //  []
         { info_tbl: [(c9LwK,
                       label: block_c9LwK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LwK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJn_entry() //  [R1]
         { info_tbl: [(c9Lxe,
                       label: sat_s9FJn_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lxe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lxf; else goto c9Lxg;
       c9Lxf: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Lxg: // global
           I64[Sp - 24] = block_c9Lxc_info;
           R2 = P64[R1 + 15];
           _s9FJi::P64 = P64[R1 + 23];
           _s9FJj::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9FJi::P64;
           P64[Sp - 8] = _s9FJj::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lxc() //  []
         { info_tbl: [(c9Lxc,
                       label: block_c9Lxc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lxc: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJo_entry() //  [R1, R2]
         { info_tbl: [(c9Lxi,
                       label: sat_s9FJo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lxi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Lxj; else goto c9Lxk;
       c9Lxj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Lxk: // global
           I64[Sp - 24] = block_c9Lx2_info;
           _s9FIs::P64 = P64[R1 + 7];
           _s9FJd::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9FIs::P64;
           P64[Sp - 8] = _s9FJd::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Lxo; else goto c9Lx3;
       u9Lxo: // global
           call _c9Lx2(R1) args: 0, res: 0, upd: 0;
       c9Lx3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Lx2() //  [R1]
         { info_tbl: [(c9Lx2,
                       label: block_c9Lx2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lx2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9Lxn; else goto c9Lxm;
       c9Lxn: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Lxm: // global
           _s9FJi::P64 = P64[R1 + 7];
           _s9FJj::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9FJn_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9FJi::P64;
           P64[Hp] = _s9FJj::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FJf_entry() //  [R1]
         { info_tbl: [(c9Lxv,
                       label: sat_s9FJf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lxv: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$wwithMVar_entry() //  [R2, R3]
         { info_tbl: [(c9LxC,
                       label: GHC.Conc.Sync.$wwithMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LxC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9LxD; else goto c9LxE;
       c9LxD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$wwithMVar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9LxE: // global
           I64[Sp - 24] = block_c9Lvi_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c9Lvi() //  [R1]
         { info_tbl: [(c9Lvi,
                       label: block_c9Lvi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lvi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9LxH; else goto c9LxG;
       c9LxH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9LxG: // global
           _s9FIs::P64 = P64[Sp + 8];
           if (R1 == 0) goto c9LxA; else goto u9Ly0;
       c9LxA: // global
           I64[Hp - 16] = sat_s9FJa_info;
           P64[Hp - 8] = _s9FIs::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u9Ly0: // global
           if (R1 == 1) goto c9LxB; else goto c9Lxz;
       c9LxB: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9LwV_info;
           R1 = _s9FIs::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       c9Lxz: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9Lvm_info;
           R1 = _s9FIs::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LwV() //  [R1]
         { info_tbl: [(c9LwV,
                       label: block_c9LwV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LwV: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9LxW; else goto c9LxV;
       c9LxW: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LxV: // global
           I64[Hp - 64] = sat_s9FJo_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FJf_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9LxR_info;
           R2 = Hp - 63;
           _s9FJd::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s9FJd::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LxR() //  [R1]
         { info_tbl: [(c9LxR,
                       label: block_c9LxR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LxR: // global
           _s9FIs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9LxT_info;
           R2 = P64[Sp + 16];
           _s9FJr::P64 = R1;
           R1 = _s9FIs::P64;
           P64[Sp + 16] = _s9FJr::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LxT() //  []
         { info_tbl: [(c9LxT,
                       label: block_c9LxT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LxT: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Lvm() //  [R1]
         { info_tbl: [(c9Lvm,
                       label: block_c9Lvm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Lvm: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9LxN; else goto c9LxM;
       c9LxN: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LxM: // global
           I64[Hp - 64] = sat_s9FIM_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9FID_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9LxI_info;
           R2 = Hp - 63;
           _s9FIB::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s9FIB::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LxI() //  [R1]
         { info_tbl: [(c9LxI,
                       label: block_c9LxI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LxI: // global
           _s9FIs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9LxK_info;
           R2 = P64[Sp + 16];
           _s9FIP::P64 = R1;
           R1 = _s9FIs::P64;
           P64[Sp + 16] = _s9FIP::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LxK() //  []
         { info_tbl: [(c9LxK,
                       label: block_c9LxK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LxK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.754036945 UTC

[section ""data" . GHC.Conc.Sync.withMVar1_closure" {
     GHC.Conc.Sync.withMVar1_closure:
         const GHC.Conc.Sync.withMVar1_info;
 },
 GHC.Conc.Sync.withMVar1_entry() //  [R2, R3]
         { info_tbl: [(c9LzZ,
                       label: GHC.Conc.Sync.withMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LzZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LA0; else goto c9LA1;
       c9LA0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.withMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9LA1: // global
           I64[Sp - 16] = block_c9LzW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9LA5; else goto c9LzX;
       u9LA5: // global
           call _c9LzW(R1) args: 0, res: 0, upd: 0;
       c9LzX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LzW() //  [R1]
         { info_tbl: [(c9LzW,
                       label: block_c9LzW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LzW: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.759338427 UTC

[section ""data" . GHC.Conc.Sync.withMVar_closure" {
     GHC.Conc.Sync.withMVar_closure:
         const GHC.Conc.Sync.withMVar_info;
 },
 GHC.Conc.Sync.withMVar_entry() //  [R2, R3]
         { info_tbl: [(c9LAj,
                       label: GHC.Conc.Sync.withMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LAj: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.withMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.762656636 UTC

[section ""data" . GHC.Conc.Sync.reportStackOverflow1_closure" {
     GHC.Conc.Sync.reportStackOverflow1_closure:
         const GHC.Conc.Sync.reportStackOverflow1_info;
 },
 GHC.Conc.Sync.reportStackOverflow1_entry() //  []
         { info_tbl: [(c9LAw,
                       label: GHC.Conc.Sync.reportStackOverflow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LAw: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] reportStackOverflow(CurrentTSO);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.765963361 UTC

[section ""data" . GHC.Conc.Sync.reportStackOverflow_closure" {
     GHC.Conc.Sync.reportStackOverflow_closure:
         const GHC.Conc.Sync.reportStackOverflow_info;
 },
 GHC.Conc.Sync.reportStackOverflow_entry() //  []
         { info_tbl: [(c9LAI,
                       label: GHC.Conc.Sync.reportStackOverflow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LAI: // global
           call GHC.Conc.Sync.reportStackOverflow1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.771633637 UTC

[section ""data" . GHC.Conc.Sync.forkIO2_closure" {
     GHC.Conc.Sync.forkIO2_closure:
         const GHC.Conc.Sync.forkIO2_info;
         const 0;
 },
 GHC.Conc.Sync.forkIO2_entry() //  [R2]
         { info_tbl: [(c9LAT,
                       label: GHC.Conc.Sync.forkIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LAT: // global
           R2 = R2;
           call GHC.Conc.Sync.childHandler1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Conc.Sync.childHandler1_closure" {
     GHC.Conc.Sync.childHandler1_closure:
         const GHC.Conc.Sync.childHandler1_info;
         const 0;
 },
 sat_s9FK0_entry() //  [R1]
         { info_tbl: [(c9LBO,
                       label: sat_s9FK0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LBO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LBP; else goto c9LBQ;
       c9LBP: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LBQ: // global
           I64[Sp - 16] = block_c9LBL_info;
           _s9FJJ::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = _s9FJJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9LBU; else goto c9LBM;
       u9LBU: // global
           call _c9LBL(R1) args: 0, res: 0, upd: 0;
       c9LBM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LBL() //  [R1]
         { info_tbl: [(c9LBL,
                       label: block_c9LBL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LBL: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKc_entry() //  [R1]
         { info_tbl: [(c9LCh,
                       label: sat_s9FKc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LCh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LCi; else goto c9LCj;
       c9LCi: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LCj: // global
           I64[Sp - 16] = block_c9LCe_info;
           _s9FJJ::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = _s9FJJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9LCn; else goto c9LCf;
       u9LCn: // global
           call _c9LCe(R1) args: 0, res: 0, upd: 0;
       c9LCf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LCe() //  [R1]
         { info_tbl: [(c9LCe,
                       label: block_c9LCe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LCe: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKk_entry() //  [R1]
         { info_tbl: [(c9LCC,
                       label: sat_s9FKk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LCC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LCD; else goto c9LCE;
       c9LCD: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LCE: // global
           I64[Sp - 16] = block_c9LCz_info;
           _s9FJJ::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = _s9FJJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9LCI; else goto c9LCA;
       u9LCI: // global
           call _c9LCz(R1) args: 0, res: 0, upd: 0;
       c9LCA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LCz() //  [R1]
         { info_tbl: [(c9LCz,
                       label: block_c9LCz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LCz: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKv_entry() //  [R1]
         { info_tbl: [(c9LCJ,
                       label: sat_s9FKv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LCJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9LCK; else goto c9LCL;
       c9LCK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9LCL: // global
           I64[Sp - 8] = block_c9LB4_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9LEx; else goto c9LB5;
       u9LEx: // global
           call _c9LB4(R1) args: 0, res: 0, upd: 0;
       c9LB5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LB4() //  [R1]
         { info_tbl: [(c9LB4,
                       label: block_c9LB4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LB4: // global
           I64[Sp - 24] = block_c9LB9_info;
           _s9FJK::P64 = P64[R1 + 7];
           R2 = _s9FJK::P64;
           P64[Sp - 16] = _s9FJK::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 24;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9LB9() //  [R1]
         { info_tbl: [(c9LB9,
                       label: block_c9LB9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LB9: // global
           I64[Sp] = block_c9LBd_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9LBd() //  [R1]
         { info_tbl: [(c9LBd,
                       label: block_c9LBd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LBd: // global
           if (R1 & 7 == 1) goto c9LCQ; else goto c9LEh;
       c9LCQ: // global
           I64[Sp] = block_c9LBh_info;
           R2 = P64[Sp + 8];
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       c9LEh: // global
           I64[Sp + 24] = block_c9LEf_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LBh() //  [R1]
         { info_tbl: [(c9LBh,
                       label: block_c9LBh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LBh: // global
           I64[Sp] = block_c9LBl_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9LBl() //  [R1]
         { info_tbl: [(c9LBl,
                       label: block_c9LBl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LBl: // global
           if (R1 & 7 == 1) goto c9LCU; else goto c9LE8;
       c9LCU: // global
           I64[Sp] = block_c9LBp_info;
           R2 = P64[Sp + 8];
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       c9LE8: // global
           I64[Sp + 24] = block_c9LE6_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LBp() //  [R1]
         { info_tbl: [(c9LBp,
                       label: block_c9LBp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LBp: // global
           I64[Sp] = block_c9LCV_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9LCV() //  [R1]
         { info_tbl: [(c9LCV,
                       label: block_c9LCV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LCV: // global
           if (R1 & 7 == 1) goto u9LEu; else goto c9LDC;
       u9LEu: // global
           Sp = Sp + 8;
           call _s9FJQ() args: 0, res: 0, upd: 0;
       c9LDC: // global
           I64[Sp] = block_c9LDw_info;
           R1 = P64[Sp + 16];
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LDw() //  [R1]
         { info_tbl: [(c9LDw,
                       label: block_c9LDw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LDw: // global
           I64[Sp - 8] = block_c9LDA_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9LDA() //  [R1]
         { info_tbl: [(c9LDA,
                       label: block_c9LDA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LDA: // global
           I64[Sp] = block_c9LDH_info;
           R3 = GHC.IO.Exception.$fExceptionAsyncException9_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9LDH() //  [R1]
         { info_tbl: [(c9LDH,
                       label: block_c9LDH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LDH: // global
           if (R1 & 7 == 1) goto u9LEv; else goto c9LDT;
       u9LEv: // global
           Sp = Sp + 16;
           call _s9FJQ() args: 0, res: 0, upd: 0;
       c9LDT: // global
           _s9FKp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9LDR_info;
           R1 = _s9FKp::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LDR() //  [R1]
         { info_tbl: [(c9LDR,
                       label: block_c9LDR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LDR: // global
           if (R1 & 7 == 3) goto c9LE3; else goto u9LEw;
       c9LE3: // global
           R1 = GHC.Conc.Sync.always2_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9LEw: // global
           Sp = Sp + 8;
           call _s9FJQ() args: 0, res: 0, upd: 0;
     }
 },
 _s9FJQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s9FJQ: // global
           _s9FJK::P64 = P64[Sp];
           I64[Sp] = block_c9LBy_info;
           R2 = _s9FJK::P64;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9LBy() //  [R1]
         { info_tbl: [(c9LBy,
                       label: block_c9LBy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LBy: // global
           I64[Sp] = block_c9LBC_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9LBC() //  [R1]
         { info_tbl: [(c9LBC,
                       label: block_c9LBC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LBC: // global
           if (R1 & 7 == 1) goto c9LD0; else goto c9LD5;
       c9LD0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LD3; else goto c9LD2;
       c9LD3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LD2: // global
           I64[Hp - 8] = sat_s9FK0_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9LD5: // global
           _s9FJL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9LBX_info;
           R1 = _s9FJL::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LBX() //  [R1]
         { info_tbl: [(c9LBX,
                       label: block_c9LBX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LBX: // global
           I64[Sp - 8] = block_c9LC1_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9LC1() //  [R1]
         { info_tbl: [(c9LC1,
                       label: block_c9LC1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LC1: // global
           I64[Sp] = block_c9LC5_info;
           R3 = GHC.IO.Exception.$fExceptionAsyncException9_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9LC5() //  [R1]
         { info_tbl: [(c9LC5,
                       label: block_c9LC5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LC5: // global
           if (R1 & 7 == 1) goto c9LD9; else goto c9LDe;
       c9LD9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LDc; else goto c9LDb;
       c9LDc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LDb: // global
           I64[Hp - 8] = sat_s9FKc_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9LDe: // global
           _s9FK3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9LCq_info;
           R1 = _s9FK3::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LCq() //  [R1]
         { info_tbl: [(c9LCq,
                       label: block_c9LCq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LCq: // global
           if (R1 & 7 == 1) goto c9LDn; else goto c9LDg;
       c9LDn: // global
           R1 = GHC.Conc.Sync.reportStackOverflow1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9LDg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LDj; else goto c9LDi;
       c9LDj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LDi: // global
           I64[Hp - 8] = sat_s9FKk_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9LE6() //  []
         { info_tbl: [(c9LE6,
                       label: block_c9LE6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LE6: // global
           R1 = GHC.Conc.Sync.always2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9LEf() //  []
         { info_tbl: [(c9LEf,
                       label: block_c9LEf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LEf: // global
           R1 = GHC.Conc.Sync.always2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.childHandler1_entry() //  [R2]
         { info_tbl: [(c9LEB,
                       label: GHC.Conc.Sync.childHandler1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LEB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9LEF; else goto c9LEE;
       c9LEF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Conc.Sync.childHandler1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LEE: // global
           I64[Hp - 16] = sat_s9FKv_info;
           P64[Hp] = R2;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.823697435 UTC

[section ""data" . GHC.Conc.Sync.childHandler_closure" {
     GHC.Conc.Sync.childHandler_closure:
         const GHC.Conc.Sync.childHandler_info;
         const 0;
 },
 GHC.Conc.Sync.childHandler_entry() //  [R2]
         { info_tbl: [(c9LGO,
                       label: GHC.Conc.Sync.childHandler_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LGO: // global
           R2 = R2;
           call GHC.Conc.Sync.childHandler1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.827886404 UTC

[section ""data" . GHC.Conc.Sync.forkOn1_closure" {
     GHC.Conc.Sync.forkOn1_closure:
         const GHC.Conc.Sync.forkOn1_info;
         const 0;
 },
 sat_s9FKC_entry() //  [R1]
         { info_tbl: [(c9LH9,
                       label: sat_s9FKC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LH9: // global
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = P64[R1 + 7];
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkOn1_entry() //  [R2, R3]
         { info_tbl: [(c9LHc,
                       label: GHC.Conc.Sync.forkOn1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LHc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LHg; else goto c9LHh;
       c9LHg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.forkOn1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9LHh: // global
           I64[Sp - 16] = block_c9LGZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9LHo; else goto c9LH0;
       u9LHo: // global
           call _c9LGZ(R1) args: 0, res: 0, upd: 0;
       c9LH0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LGZ() //  [R1]
         { info_tbl: [(c9LGZ,
                       label: block_c9LGZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LGZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LHk; else goto c9LHj;
       c9LHk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LHj: // global
           _s9FKA::I64 = I64[R1 + 7];
           I64[Hp - 8] = sat_s9FKC_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c9LHd_info;
           R2 = Hp - 7;
           R1 = _s9FKA::I64;
           Sp = Sp + 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LHd() //  [R1]
         { info_tbl: [(c9LHd,
                       label: block_c9LHd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LHd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LHn; else goto c9LHm;
       c9LHn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LHm: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.838563923 UTC

[section ""data" . GHC.Conc.Sync.forkOn_closure" {
     GHC.Conc.Sync.forkOn_closure:
         const GHC.Conc.Sync.forkOn_info;
         const 0;
 },
 GHC.Conc.Sync.forkOn_entry() //  [R2, R3]
         { info_tbl: [(c9LHK,
                       label: GHC.Conc.Sync.forkOn_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LHK: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.forkOn1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.842978202 UTC

[section ""data" . GHC.Conc.Sync.forkOnWithUnmask1_closure" {
     GHC.Conc.Sync.forkOnWithUnmask1_closure:
         const GHC.Conc.Sync.forkOnWithUnmask1_info;
         const 0;
 },
 sat_s9FKN_entry() //  [R2]
         { info_tbl: [(c9LIe,
                       label: sat_s9FKN_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LIe: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKO_entry() //  [R1]
         { info_tbl: [(c9LIh,
                       label: sat_s9FKO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LIh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LIl; else goto c9LIk;
       c9LIl: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9LIk: // global
           _s9FKI::P64 = P64[R1 + 16];
           I64[Hp - 8] = sat_s9FKN_info;
           R2 = Hp - 6;
           R1 = _s9FKI::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FKP_entry() //  [R1]
         { info_tbl: [(c9LIm,
                       label: sat_s9FKP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LIm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9LIq; else goto c9LIp;
       c9LIq: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LIp: // global
           _s9FKI::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_s9FKO_info;
           P64[Hp] = _s9FKI::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkOnWithUnmask1_entry() //  [R2, R3]
         { info_tbl: [(c9LIr,
                       label: GHC.Conc.Sync.forkOnWithUnmask1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LIr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LIv; else goto c9LIw;
       c9LIv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.forkOnWithUnmask1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9LIw: // global
           I64[Sp - 16] = block_c9LHV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9LID; else goto c9LHW;
       u9LID: // global
           call _c9LHV(R1) args: 0, res: 0, upd: 0;
       c9LHW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LHV() //  [R1]
         { info_tbl: [(c9LHV,
                       label: block_c9LHV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LHV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LIz; else goto c9LIy;
       c9LIz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LIy: // global
           _s9FKL::I64 = I64[R1 + 7];
           I64[Hp - 8] = sat_s9FKP_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c9LIs_info;
           R2 = Hp - 7;
           R1 = _s9FKL::I64;
           Sp = Sp + 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LIs() //  [R1]
         { info_tbl: [(c9LIs,
                       label: block_c9LIs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LIs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LIC; else goto c9LIB;
       c9LIC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LIB: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.857074178 UTC

[section ""data" . GHC.Conc.Sync.forkOnWithUnmask_closure" {
     GHC.Conc.Sync.forkOnWithUnmask_closure:
         const GHC.Conc.Sync.forkOnWithUnmask_info;
         const 0;
 },
 GHC.Conc.Sync.forkOnWithUnmask_entry() //  [R2, R3]
         { info_tbl: [(c9LJ5,
                       label: GHC.Conc.Sync.forkOnWithUnmask_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LJ5: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.forkOnWithUnmask1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.860704533 UTC

[section ""data" . GHC.Conc.Sync.forkIO1_closure" {
     GHC.Conc.Sync.forkIO1_closure:
         const GHC.Conc.Sync.forkIO1_info;
         const 0;
 },
 sat_s9FKX_entry() //  [R1]
         { info_tbl: [(c9LJl,
                       label: sat_s9FKX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LJl: // global
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = P64[R1 + 7];
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkIO1_entry() //  [R2]
         { info_tbl: [(c9LJr,
                       label: GHC.Conc.Sync.forkIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LJr: // global
           _s9FKU::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c9LJs; else goto c9LJt;
       c9LJt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LJv; else goto c9LJu;
       c9LJv: // global
           HpAlloc = 16;
           goto c9LJs;
       c9LJs: // global
           R2 = _s9FKU::P64;
           R1 = GHC.Conc.Sync.forkIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LJu: // global
           I64[Hp - 8] = sat_s9FKX_info;
           P64[Hp] = _s9FKU::P64;
           I64[Sp - 8] = block_c9LJo_info;
           R1 = Hp - 7;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LJo() //  [R1]
         { info_tbl: [(c9LJo,
                       label: block_c9LJo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LJo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LJy; else goto c9LJx;
       c9LJy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LJx: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.868013874 UTC

[section ""data" . GHC.Conc.Sync.forkIO_closure" {
     GHC.Conc.Sync.forkIO_closure:
         const GHC.Conc.Sync.forkIO_info;
         const 0;
 },
 GHC.Conc.Sync.forkIO_entry() //  [R2]
         { info_tbl: [(c9LJP,
                       label: GHC.Conc.Sync.forkIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LJP: // global
           R2 = R2;
           call GHC.Conc.Sync.forkIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.872139454 UTC

[section ""data" . GHC.Conc.Sync.forkIOWithUnmask1_closure" {
     GHC.Conc.Sync.forkIOWithUnmask1_closure:
         const GHC.Conc.Sync.forkIOWithUnmask1_info;
         const 0;
 },
 sat_s9FL5_entry() //  [R2]
         { info_tbl: [(c9LKe,
                       label: sat_s9FL5_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LKe: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FL6_entry() //  [R1]
         { info_tbl: [(c9LKh,
                       label: sat_s9FL6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LKh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LKl; else goto c9LKk;
       c9LKl: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9LKk: // global
           _s9FL2::P64 = P64[R1 + 16];
           I64[Hp - 8] = sat_s9FL5_info;
           R2 = Hp - 6;
           R1 = _s9FL2::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9FL7_entry() //  [R1]
         { info_tbl: [(c9LKm,
                       label: sat_s9FL7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LKm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9LKq; else goto c9LKp;
       c9LKq: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LKp: // global
           _s9FL2::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_s9FL6_info;
           P64[Hp] = _s9FL2::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkIOWithUnmask1_entry() //  [R2]
         { info_tbl: [(c9LKu,
                       label: GHC.Conc.Sync.forkIOWithUnmask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LKu: // global
           _s9FL2::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c9LKv; else goto c9LKw;
       c9LKw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LKy; else goto c9LKx;
       c9LKy: // global
           HpAlloc = 16;
           goto c9LKv;
       c9LKv: // global
           R2 = _s9FL2::P64;
           R1 = GHC.Conc.Sync.forkIOWithUnmask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LKx: // global
           I64[Hp - 8] = sat_s9FL7_info;
           P64[Hp] = _s9FL2::P64;
           I64[Sp - 8] = block_c9LKr_info;
           R1 = Hp - 7;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LKr() //  [R1]
         { info_tbl: [(c9LKr,
                       label: block_c9LKr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LKr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LKB; else goto c9LKA;
       c9LKB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9LKA: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.883005662 UTC

[section ""data" . GHC.Conc.Sync.forkIOWithUnmask_closure" {
     GHC.Conc.Sync.forkIOWithUnmask_closure:
         const GHC.Conc.Sync.forkIOWithUnmask_info;
         const 0;
 },
 GHC.Conc.Sync.forkIOWithUnmask_entry() //  [R2]
         { info_tbl: [(c9LKY,
                       label: GHC.Conc.Sync.forkIOWithUnmask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LKY: // global
           R2 = R2;
           call GHC.Conc.Sync.forkIOWithUnmask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.886126929 UTC

[section ""cstring" . lvl11_r9Fvm_bytes" {
     lvl11_r9Fvm_bytes:
         I8[] [115,101,116,78,117,109,67,97,112,97,98,105,108,105,116,105,101,115,58,32,67,97,112,97,98,105,108,105,116,121,32,99,111,117,110,116,32,40]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.888404084 UTC

[section ""cstring" . lvl12_r9Fvn_bytes" {
     lvl12_r9Fvn_bytes:
         I8[] [41,32,109,117,115,116,32,98,101,32,112,111,115,105,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.890165002 UTC

[section ""data" . lvl13_r9Fvo_closure" {
     lvl13_r9Fvo_closure:
         const lvl13_r9Fvo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_r9Fvo_entry() //  [R1]
         { info_tbl: [(c9LLd,
                       label: lvl13_r9Fvo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LLd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LLe; else goto c9LLf;
       c9LLe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9LLf: // global
           (_c9LLa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9LLa::I64 == 0) goto c9LLc; else goto c9LLb;
       c9LLc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9LLb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9LLa::I64;
           R2 = lvl12_r9Fvn_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.894590788 UTC

[section ""data" . GHC.Conc.Sync.$wlvl_closure" {
     GHC.Conc.Sync.$wlvl_closure:
         const GHC.Conc.Sync.$wlvl_info;
         const 0;
 },
 sat_s9FLi_entry() //  [R1]
         { info_tbl: [(c9LLy,
                       label: sat_s9FLi_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LLy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9LLz; else goto c9LLA;
       c9LLz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9LLA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9LLv_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9LLv() //  [R1, R2]
         { info_tbl: [(c9LLv,
                       label: block_c9LLv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LLv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9LLD; else goto c9LLC;
       c9LLD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9LLC: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl13_r9Fvo_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$wlvl_entry() //  [R2]
         { info_tbl: [(c9LLG,
                       label: GHC.Conc.Sync.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LLG: // global
           _s9FLc::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c9LLH; else goto c9LLI;
       c9LLI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9LLK; else goto c9LLJ;
       c9LLK: // global
           HpAlloc = 24;
           goto c9LLH;
       c9LLH: // global
           R2 = _s9FLc::I64;
           R1 = GHC.Conc.Sync.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LLJ: // global
           I64[Hp - 16] = sat_s9FLi_info;
           I64[Hp] = _s9FLc::I64;
           I64[Sp - 8] = block_c9LLE_info;
           R3 = Hp - 16;
           R2 = lvl11_r9Fvm_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9LLE() //  [R1]
         { info_tbl: [(c9LLE,
                       label: block_c9LLE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LLE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.903600347 UTC

[section ""data" . GHC.Conc.Sync.setNumCapabilities2_closure" {
     GHC.Conc.Sync.setNumCapabilities2_closure:
         const GHC.Conc.Sync.setNumCapabilities2_info;
         const 0;
 },
 GHC.Conc.Sync.setNumCapabilities2_entry() //  [R2]
         { info_tbl: [(c9LMa,
                       label: GHC.Conc.Sync.setNumCapabilities2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LMa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9LMb; else goto c9LMc;
       c9LMb: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.setNumCapabilities2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LMc: // global
           I64[Sp - 8] = block_c9LM7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9LMg; else goto c9LM8;
       u9LMg: // global
           call _c9LM7(R1) args: 0, res: 0, upd: 0;
       c9LM8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LM7() //  [R1]
         { info_tbl: [(c9LM7,
                       label: block_c9LM7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LM7: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.909453504 UTC

[section ""data" . GHC.Conc.Sync.setNumCapabilities1_closure" {
     GHC.Conc.Sync.setNumCapabilities1_closure:
         const GHC.Conc.Sync.setNumCapabilities1_info;
         const 0;
 },
 GHC.Conc.Sync.setNumCapabilities1_entry() //  [R2]
         { info_tbl: [(c9LMx,
                       label: GHC.Conc.Sync.setNumCapabilities1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LMx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9LMy; else goto c9LMz;
       c9LMy: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.setNumCapabilities1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LMz: // global
           I64[Sp - 8] = block_c9LMu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9LN4; else goto c9LMv;
       u9LN4: // global
           call _c9LMu(R1) args: 0, res: 0, upd: 0;
       c9LMv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LMu() //  [R1]
         { info_tbl: [(c9LMu,
                       label: block_c9LMu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LMu: // global
           _s9FLr::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s9FLr::I64, 0)) goto c9LMG; else goto c9LMT;
       c9LMG: // global
           I64[Sp] = block_c9LMQ_info;
           _u9LMW::P64 = CurrentTSO;
           I64[I64[_u9LMW::P64 + 24] + 16] = Sp;
           _u9LMX::I64 = CurrentNursery;
           P64[_u9LMX::I64 + 8] = Hp + 8;
           I64[_u9LMW::P64 + 104] = I64[_u9LMW::P64 + 104] - ((Hp + 8) - I64[_u9LMX::I64]);
           (_u9LMU::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  []  result hints:  [] setNumCapabilities(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s9FLr::I64)));
           (_u9LMV::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_u9LMU::I64);
           BaseReg = _u9LMV::I64;
           _u9LMY::P64 = CurrentTSO;
           _u9LMZ::P64 = I64[_u9LMY::P64 + 24];
           Sp = I64[_u9LMZ::P64 + 16];
           SpLim = _u9LMZ::P64 + 192;
           HpAlloc = 0;
           _u9LN0::I64 = CurrentNursery;
           _u9LN1::I64 = I64[_u9LN0::I64 + 8];
           Hp = _u9LN1::I64 - 8;
           _u9LN2::I64 = I64[_u9LN0::I64];
           HpLim = _u9LN2::I64 + ((%MO_SS_Conv_W32_W64(I32[_u9LN0::I64 + 48]) << 12) - 1);
           I64[_u9LMY::P64 + 104] = I64[_u9LMY::P64 + 104] + (_u9LN1::I64 - _u9LN2::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
       c9LMT: // global
           R2 = _s9FLr::I64;
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c9LMQ() //  []
         { info_tbl: [(c9LMQ,
                       label: block_c9LMQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LMQ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.917742551 UTC

[section ""data" . GHC.Conc.Sync.setNumCapabilities_closure" {
     GHC.Conc.Sync.setNumCapabilities_closure:
         const GHC.Conc.Sync.setNumCapabilities_info;
         const 0;
 },
 GHC.Conc.Sync.setNumCapabilities_entry() //  [R2]
         { info_tbl: [(c9LNB,
                       label: GHC.Conc.Sync.setNumCapabilities_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LNB: // global
           R2 = R2;
           call GHC.Conc.Sync.setNumCapabilities1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.921054654 UTC

[section ""data" . GHC.Conc.Sync.getNumCapabilities1_closure" {
     GHC.Conc.Sync.getNumCapabilities1_closure:
         const GHC.Conc.Sync.getNumCapabilities1_info;
 },
 GHC.Conc.Sync.getNumCapabilities1_entry() //  []
         { info_tbl: [(c9LNN,
                       label: GHC.Conc.Sync.getNumCapabilities1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LNN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LNR; else goto c9LNQ;
       c9LNR: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.getNumCapabilities1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LNQ: // global
           _s9FLB::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s9FLB::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.925531691 UTC

[section ""data" . GHC.Conc.Sync.getNumCapabilities_closure" {
     GHC.Conc.Sync.getNumCapabilities_closure:
         const GHC.Conc.Sync.getNumCapabilities_info;
 },
 GHC.Conc.Sync.getNumCapabilities_entry() //  []
         { info_tbl: [(c9LO1,
                       label: GHC.Conc.Sync.getNumCapabilities_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LO1: // global
           call GHC.Conc.Sync.getNumCapabilities1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.92867931 UTC

[section ""data" . GHC.Conc.Sync.numCapabilities1_closure" {
     GHC.Conc.Sync.numCapabilities1_closure:
         const GHC.Conc.Sync.numCapabilities1_info;
 },
 GHC.Conc.Sync.numCapabilities1_entry() //  []
         { info_tbl: [(c9LOf,
                       label: GHC.Conc.Sync.numCapabilities1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LOf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9LOg; else goto c9LOh;
       c9LOg: // global
           R1 = GHC.Conc.Sync.numCapabilities1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LOh: // global
           I64[Sp - 8] = block_c9LOc_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _c9LOc() //  []
         { info_tbl: [(c9LOc,
                       label: block_c9LOc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LOc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LOk; else goto c9LOj;
       c9LOk: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c9LOj: // global
           _s9FLH::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s9FLH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.933978794 UTC

[section ""data" . GHC.Conc.Sync.numCapabilities_closure" {
     GHC.Conc.Sync.numCapabilities_closure:
         const GHC.Conc.Sync.numCapabilities_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.numCapabilities_entry() //  [R1]
         { info_tbl: [(c9LOC,
                       label: GHC.Conc.Sync.numCapabilities_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LOC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9LOD; else goto c9LOE;
       c9LOD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9LOE: // global
           (_c9LOx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9LOx::I64 == 0) goto c9LOz; else goto c9LOy;
       c9LOz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9LOy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9LOx::I64;
           I64[Sp - 24] = block_c9LOA_info;
           Sp = Sp - 24;
           call GHC.Conc.Sync.numCapabilities1_entry() args: 8, res: 8, upd: 24;
     }
 },
 _c9LOA() //  [R1]
         { info_tbl: [(c9LOA,
                       label: block_c9LOA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LOA: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.939419232 UTC

[section ""data" . GHC.Conc.Sync.disableAllocationLimit1_closure" {
     GHC.Conc.Sync.disableAllocationLimit1_closure:
         const GHC.Conc.Sync.disableAllocationLimit1_info;
 },
 GHC.Conc.Sync.disableAllocationLimit1_entry() //  []
         { info_tbl: [(c9LOY,
                       label: GHC.Conc.Sync.disableAllocationLimit1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LOY: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] rts_disableThreadAllocationLimit(CurrentTSO);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.942755183 UTC

[section ""data" . GHC.Conc.Sync.disableAllocationLimit_closure" {
     GHC.Conc.Sync.disableAllocationLimit_closure:
         const GHC.Conc.Sync.disableAllocationLimit_info;
 },
 GHC.Conc.Sync.disableAllocationLimit_entry() //  []
         { info_tbl: [(c9LPa,
                       label: GHC.Conc.Sync.disableAllocationLimit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LPa: // global
           call GHC.Conc.Sync.disableAllocationLimit1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.945918312 UTC

[section ""data" . GHC.Conc.Sync.enableAllocationLimit1_closure" {
     GHC.Conc.Sync.enableAllocationLimit1_closure:
         const GHC.Conc.Sync.enableAllocationLimit1_info;
 },
 GHC.Conc.Sync.enableAllocationLimit1_entry() //  []
         { info_tbl: [(c9LPn,
                       label: GHC.Conc.Sync.enableAllocationLimit1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LPn: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] rts_enableThreadAllocationLimit(CurrentTSO);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.949191464 UTC

[section ""data" . GHC.Conc.Sync.enableAllocationLimit_closure" {
     GHC.Conc.Sync.enableAllocationLimit_closure:
         const GHC.Conc.Sync.enableAllocationLimit_info;
 },
 GHC.Conc.Sync.enableAllocationLimit_entry() //  []
         { info_tbl: [(c9LPz,
                       label: GHC.Conc.Sync.enableAllocationLimit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LPz: // global
           call GHC.Conc.Sync.enableAllocationLimit1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.95318926 UTC

[section ""data" . GHC.Conc.Sync.getAllocationCounter1_closure" {
     GHC.Conc.Sync.getAllocationCounter1_closure:
         const GHC.Conc.Sync.getAllocationCounter1_info;
 },
 GHC.Conc.Sync.getAllocationCounter1_entry() //  []
         { info_tbl: [(c9LPN,
                       label: GHC.Conc.Sync.getAllocationCounter1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LPN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LPR; else goto c9LPQ;
       c9LPR: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.getAllocationCounter1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9LPQ: // global
           (_s9FM7::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadAllocationCounter(CurrentTSO);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s9FM7::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.956921373 UTC

[section ""data" . GHC.Conc.Sync.getAllocationCounter_closure" {
     GHC.Conc.Sync.getAllocationCounter_closure:
         const GHC.Conc.Sync.getAllocationCounter_info;
 },
 GHC.Conc.Sync.getAllocationCounter_entry() //  []
         { info_tbl: [(c9LQ1,
                       label: GHC.Conc.Sync.getAllocationCounter_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LQ1: // global
           call GHC.Conc.Sync.getAllocationCounter1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.960209554 UTC

[section ""data" . GHC.Conc.Sync.setAllocationCounter1_closure" {
     GHC.Conc.Sync.setAllocationCounter1_closure:
         const GHC.Conc.Sync.setAllocationCounter1_info;
 },
 GHC.Conc.Sync.setAllocationCounter1_entry() //  [R2]
         { info_tbl: [(c9LQf,
                       label: GHC.Conc.Sync.setAllocationCounter1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LQf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9LQg; else goto c9LQh;
       c9LQg: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.setAllocationCounter1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LQh: // global
           I64[Sp - 16] = block_c9LQc_info;
           R1 = R2;
           I64[Sp - 8] = CurrentTSO;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9LQo; else goto c9LQd;
       u9LQo: // global
           call _c9LQc(R1) args: 0, res: 0, upd: 0;
       c9LQd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9LQc() //  [R1]
         { info_tbl: [(c9LQc,
                       label: block_c9LQc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LQc: // global
           call "ccall" arg hints:  [PtrHint,
                                     signed]  result hints:  [] rts_setThreadAllocationCounter(P64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.965924396 UTC

[section ""data" . GHC.Conc.Sync.setAllocationCounter_closure" {
     GHC.Conc.Sync.setAllocationCounter_closure:
         const GHC.Conc.Sync.setAllocationCounter_info;
 },
 GHC.Conc.Sync.setAllocationCounter_entry() //  [R2]
         { info_tbl: [(c9LQE,
                       label: GHC.Conc.Sync.setAllocationCounter_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LQE: // global
           R2 = R2;
           call GHC.Conc.Sync.setAllocationCounter1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.968997998 UTC

[section ""data" . GHC.Conc.Sync.TVar_closure" {
     GHC.Conc.Sync.TVar_closure:
         const GHC.Conc.Sync.TVar_info;
 },
 GHC.Conc.Sync.TVar_entry() //  [R2]
         { info_tbl: [(c9LQQ,
                       label: GHC.Conc.Sync.TVar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LQQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LQU; else goto c9LQT;
       c9LQU: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.TVar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LQT: // global
           I64[Hp - 8] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.972431819 UTC

[section ""data" . GHC.Conc.Sync.ThreadRunning_closure" {
     GHC.Conc.Sync.ThreadRunning_closure:
         const GHC.Conc.Sync.ThreadRunning_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.974314494 UTC

[section ""data" . GHC.Conc.Sync.ThreadFinished_closure" {
     GHC.Conc.Sync.ThreadFinished_closure:
         const GHC.Conc.Sync.ThreadFinished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.97611721 UTC

[section ""data" . GHC.Conc.Sync.ThreadBlocked_closure" {
     GHC.Conc.Sync.ThreadBlocked_closure:
         const GHC.Conc.Sync.ThreadBlocked_info;
 },
 GHC.Conc.Sync.ThreadBlocked_entry() //  [R2]
         { info_tbl: [(c9LR7,
                       label: GHC.Conc.Sync.ThreadBlocked_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LR7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LRb; else goto c9LRa;
       c9LRb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.ThreadBlocked_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LRa: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadBlocked_con_info;
           P64[Hp] = R2;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.979616341 UTC

[section ""data" . GHC.Conc.Sync.ThreadDied_closure" {
     GHC.Conc.Sync.ThreadDied_closure:
         const GHC.Conc.Sync.ThreadDied_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.981188034 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnMVar_closure" {
     GHC.Conc.Sync.BlockedOnMVar_closure:
         const GHC.Conc.Sync.BlockedOnMVar_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.983323068 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnBlackHole_closure" {
     GHC.Conc.Sync.BlockedOnBlackHole_closure:
         const GHC.Conc.Sync.BlockedOnBlackHole_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.984870942 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnException_closure" {
     GHC.Conc.Sync.BlockedOnException_closure:
         const GHC.Conc.Sync.BlockedOnException_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.986729342 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnSTM_closure" {
     GHC.Conc.Sync.BlockedOnSTM_closure:
         const GHC.Conc.Sync.BlockedOnSTM_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.988271422 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnForeignCall_closure" {
     GHC.Conc.Sync.BlockedOnForeignCall_closure:
         const GHC.Conc.Sync.BlockedOnForeignCall_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.98985462 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnOther_closure" {
     GHC.Conc.Sync.BlockedOnOther_closure:
         const GHC.Conc.Sync.BlockedOnOther_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.991695737 UTC

[section ""data" . GHC.Conc.Sync.ThreadId_closure" {
     GHC.Conc.Sync.ThreadId_closure:
         const GHC.Conc.Sync.ThreadId_info;
 },
 GHC.Conc.Sync.ThreadId_entry() //  [R2]
         { info_tbl: [(c9LRt,
                       label: GHC.Conc.Sync.ThreadId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LRt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9LRx; else goto c9LRw;
       c9LRx: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.ThreadId_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9LRw: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.995217112 UTC

[GHC.Conc.Sync.TVar_con_entry() //  [R1]
         { info_tbl: [(c9LRD,
                       label: GHC.Conc.Sync.TVar_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LRD: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:47.998217915 UTC

[GHC.Conc.Sync.ThreadRunning_con_entry() //  [R1]
         { info_tbl: [(c9LRJ,
                       label: GHC.Conc.Sync.ThreadRunning_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,82,117,110,110,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LRJ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:48.001057726 UTC

[GHC.Conc.Sync.ThreadFinished_con_entry() //  [R1]
         { info_tbl: [(c9LRP,
                       label: GHC.Conc.Sync.ThreadFinished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,70,105,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LRP: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:48.004291903 UTC

[GHC.Conc.Sync.ThreadBlocked_con_entry() //  [R1]
         { info_tbl: [(c9LRV,
                       label: GHC.Conc.Sync.ThreadBlocked_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,66,108,111,99,107,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LRV: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:48.007171102 UTC

[GHC.Conc.Sync.ThreadDied_con_entry() //  [R1]
         { info_tbl: [(c9LS1,
                       label: GHC.Conc.Sync.ThreadDied_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,68,105,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LS1: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:48.010548888 UTC

[section ""relreadonly" . GHC.Conc.Sync.BlockReason_closure_tbl" {
     GHC.Conc.Sync.BlockReason_closure_tbl:
         const GHC.Conc.Sync.BlockedOnMVar_closure+1;
         const GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
         const GHC.Conc.Sync.BlockedOnException_closure+3;
         const GHC.Conc.Sync.BlockedOnSTM_closure+4;
         const GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
         const GHC.Conc.Sync.BlockedOnOther_closure+6;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:48.012194525 UTC

[GHC.Conc.Sync.BlockedOnMVar_con_entry() //  [R1]
         { info_tbl: [(c9LS8,
                       label: GHC.Conc.Sync.BlockedOnMVar_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,77,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LS8: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:48.015590239 UTC

[GHC.Conc.Sync.BlockedOnBlackHole_con_entry() //  [R1]
         { info_tbl: [(c9LSe,
                       label: GHC.Conc.Sync.BlockedOnBlackHole_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,66,108,97,99,107,72,111,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LSe: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:48.018557875 UTC

[GHC.Conc.Sync.BlockedOnException_con_entry() //  [R1]
         { info_tbl: [(c9LSk,
                       label: GHC.Conc.Sync.BlockedOnException_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,69,120,99,101,112,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LSk: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:48.021505367 UTC

[GHC.Conc.Sync.BlockedOnSTM_con_entry() //  [R1]
         { info_tbl: [(c9LSq,
                       label: GHC.Conc.Sync.BlockedOnSTM_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,83,84,77]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LSq: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:48.024485176 UTC

[GHC.Conc.Sync.BlockedOnForeignCall_con_entry() //  [R1]
         { info_tbl: [(c9LSw,
                       label: GHC.Conc.Sync.BlockedOnForeignCall_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,70,111,114,101,105,103,110,67,97,108,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LSw: // global
           R1 = R1 + 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:48.02783116 UTC

[GHC.Conc.Sync.BlockedOnOther_con_entry() //  [R1]
         { info_tbl: [(c9LSC,
                       label: GHC.Conc.Sync.BlockedOnOther_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 5
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,79,116,104,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LSC: // global
           R1 = R1 + 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:48.030741082 UTC

[GHC.Conc.Sync.ThreadId_con_entry() //  [R1]
         { info_tbl: [(c9LSI,
                       label: GHC.Conc.Sync.ThreadId_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,73,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9LSI: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:48.033830899 UTC

[section ""relreadonly" . S9FOI_srt" {
     S9FOI_srt:
         const GHC.Conc.Sync.$w$cshowsPrec_closure;
         const GHC.Conc.Sync.$fShowBlockReason1_closure;
         const GHC.Conc.Sync.$fShowBlockReason3_closure;
         const GHC.Conc.Sync.$fShowBlockReason5_closure;
         const GHC.Conc.Sync.$fShowBlockReason7_closure;
         const GHC.Conc.Sync.$fShowBlockReason9_closure;
         const GHC.Conc.Sync.$fShowBlockReason11_closure;
         const GHC.Conc.Sync.$fShowBlockReason_$cshow_closure;
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const GHC.Conc.Sync.labelThread1_closure;
         const GHC.Conc.Sync.$fShowThreadStatus5_closure;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure;
         const GHC.Conc.Sync.$fShowThreadStatus3_closure;
         const GHC.Conc.Sync.$fShowThreadStatus7_closure;
         const GHC.Conc.Sync.$fShowThreadStatus9_closure;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure;
         const GHC.Conc.Sync.$fShowThreadStatus1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
         const GHC.Conc.Sync.killThread1_closure;
         const GHC.Conc.Sync.killThread2_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Conc.Sync.always3_closure;
         const GHC.Conc.Sync.always1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.hFlush_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const lvl3_r9Fve_closure;
         const lvl4_r9Fvf_closure;
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const lvl6_r9Fvh_closure;
         const lvl8_r9Fvj_closure;
         const lvl9_r9Fvk_closure;
         const lvl10_r9Fvl_closure;
         const GHC.Conc.Sync.uncaughtExceptionHandler_closure;
         const GHC.Conc.Sync.setUncaughtExceptionHandler1_closure;
         const GHC.Conc.Sync.getUncaughtExceptionHandler1_closure;
         const GHC.Conc.Sync.reportError1_closure;
         const GHC.Conc.Sync.childHandler1_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionAsyncException9_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Sync.forkOn1_closure;
         const GHC.Conc.Sync.forkOnWithUnmask1_closure;
         const GHC.Conc.Sync.forkIO1_closure;
         const GHC.Conc.Sync.forkIOWithUnmask1_closure;
         const lvl13_r9Fvo_closure;
         const GHC.IO.failIO1_closure;
         const GHC.Conc.Sync.$wlvl_closure;
         const GHC.Conc.Sync.setNumCapabilities2_closure;
         const GHC.Conc.Sync.setNumCapabilities1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.479841905 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:52.481372565 UTC

[section ""data" . GHC.Conc.Sync.$fEqTVar_$c==_closure" {
     GHC.Conc.Sync.$fEqTVar_$c==_closure:
         const GHC.Conc.Sync.$fEqTVar_$c==_info;
 },
 GHC.Conc.Sync.$fEqTVar_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9M9P,
                       label: GHC.Conc.Sync.$fEqTVar_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9M9P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9M9T; else goto c9M9U;
       c9M9T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqTVar_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9M9U: // global
           I64[Sp - 16] = block_c9M9M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Ma3; else goto c9M9N;
       u9Ma3: // global
           call _c9M9M(R1) args: 0, res: 0, upd: 0;
       c9M9N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9M9M() //  [R1]
         { info_tbl: [(c9M9M,
                       label: block_c9M9M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9M9M: // global
           I64[Sp] = block_c9M9S_info;
           _s9LSS::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9LSS::P64;
           if (R1 & 7 != 0) goto u9Ma2; else goto c9M9W;
       u9Ma2: // global
           call _c9M9S(R1) args: 0, res: 0, upd: 0;
       c9M9W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9M9S() //  [R1]
         { info_tbl: [(c9M9S,
                       label: block_c9M9S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9M9S: // global
           R1 = I64[((P64[Sp + 8] == P64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.488765481 UTC

[section ""data" . GHC.Conc.Sync.$fEqTVar_$c/=_closure" {
     GHC.Conc.Sync.$fEqTVar_$c/=_closure:
         const GHC.Conc.Sync.$fEqTVar_$c/=_info;
 },
 GHC.Conc.Sync.$fEqTVar_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9Mav,
                       label: GHC.Conc.Sync.$fEqTVar_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mav: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Maz; else goto c9MaA;
       c9Maz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqTVar_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MaA: // global
           I64[Sp - 16] = block_c9Mas_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9MaX; else goto c9Mat;
       u9MaX: // global
           call _c9Mas(R1) args: 0, res: 0, upd: 0;
       c9Mat: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Mas() //  [R1]
         { info_tbl: [(c9Mas,
                       label: block_c9Mas_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mas: // global
           I64[Sp] = block_c9May_info;
           _s9LSZ::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9LSZ::P64;
           if (R1 & 7 != 0) goto u9MaW; else goto c9MaC;
       u9MaW: // global
           call _c9May(R1) args: 0, res: 0, upd: 0;
       c9MaC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9May() //  [R1]
         { info_tbl: [(c9May,
                       label: block_c9May_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9May: // global
           if (P64[Sp + 8] == P64[R1 + 7]) goto c9MaS; else goto c9MaM;
       c9MaS: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9MaM: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.4954275 UTC

[section ""data" . GHC.Conc.Sync.$fEqTVar_closure" {
     GHC.Conc.Sync.$fEqTVar_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqTVar_$c==_closure+2;
         const GHC.Conc.Sync.$fEqTVar_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.497031652 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason12_bytes" {
     GHC.Conc.Sync.$fShowBlockReason12_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.498817392 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason11_closure" {
     GHC.Conc.Sync.$fShowBlockReason11_closure:
         const GHC.Conc.Sync.$fShowBlockReason11_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason11_entry() //  [R1]
         { info_tbl: [(c9Mbq,
                       label: GHC.Conc.Sync.$fShowBlockReason11_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mbq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Mbr; else goto c9Mbs;
       c9Mbr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Mbs: // global
           (_c9Mbn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Mbn::I64 == 0) goto c9Mbp; else goto c9Mbo;
       c9Mbp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Mbo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Mbn::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason12_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.502654366 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason10_bytes" {
     GHC.Conc.Sync.$fShowBlockReason10_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,66,108,97,99,107,72,111,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.504440989 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason9_closure" {
     GHC.Conc.Sync.$fShowBlockReason9_closure:
         const GHC.Conc.Sync.$fShowBlockReason9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason9_entry() //  [R1]
         { info_tbl: [(c9MbI,
                       label: GHC.Conc.Sync.$fShowBlockReason9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MbI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MbJ; else goto c9MbK;
       c9MbJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9MbK: // global
           (_c9MbF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9MbF::I64 == 0) goto c9MbH; else goto c9MbG;
       c9MbH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9MbG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9MbF::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.508175365 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason8_bytes" {
     GHC.Conc.Sync.$fShowBlockReason8_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.511341777 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason7_closure" {
     GHC.Conc.Sync.$fShowBlockReason7_closure:
         const GHC.Conc.Sync.$fShowBlockReason7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason7_entry() //  [R1]
         { info_tbl: [(c9Mc0,
                       label: GHC.Conc.Sync.$fShowBlockReason7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mc0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Mc1; else goto c9Mc2;
       c9Mc1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Mc2: // global
           (_c9MbX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9MbX::I64 == 0) goto c9MbZ; else goto c9MbY;
       c9MbZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9MbY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9MbX::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.515086075 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason6_bytes" {
     GHC.Conc.Sync.$fShowBlockReason6_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.516726457 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason5_closure" {
     GHC.Conc.Sync.$fShowBlockReason5_closure:
         const GHC.Conc.Sync.$fShowBlockReason5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason5_entry() //  [R1]
         { info_tbl: [(c9Mci,
                       label: GHC.Conc.Sync.$fShowBlockReason5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mci: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Mcj; else goto c9Mck;
       c9Mcj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Mck: // global
           (_c9Mcf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Mcf::I64 == 0) goto c9Mch; else goto c9Mcg;
       c9Mch: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Mcg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Mcf::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.520630361 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason4_bytes" {
     GHC.Conc.Sync.$fShowBlockReason4_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,70,111,114,101,105,103,110,67,97,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.522378982 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason3_closure" {
     GHC.Conc.Sync.$fShowBlockReason3_closure:
         const GHC.Conc.Sync.$fShowBlockReason3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason3_entry() //  [R1]
         { info_tbl: [(c9McA,
                       label: GHC.Conc.Sync.$fShowBlockReason3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9McA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9McB; else goto c9McC;
       c9McB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9McC: // global
           (_c9Mcx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Mcx::I64 == 0) goto c9Mcz; else goto c9Mcy;
       c9Mcz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Mcy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Mcx::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.526047085 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowBlockReason2_bytes" {
     GHC.Conc.Sync.$fShowBlockReason2_bytes:
         I8[] [66,108,111,99,107,101,100,79,110,79,116,104,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.527785116 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason1_closure" {
     GHC.Conc.Sync.$fShowBlockReason1_closure:
         const GHC.Conc.Sync.$fShowBlockReason1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason1_entry() //  [R1]
         { info_tbl: [(c9McS,
                       label: GHC.Conc.Sync.$fShowBlockReason1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9McS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9McT; else goto c9McU;
       c9McT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9McU: // global
           (_c9McP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9McP::I64 == 0) goto c9McR; else goto c9McQ;
       c9McR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9McQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9McP::I64;
           R2 = GHC.Conc.Sync.$fShowBlockReason2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.532133587 UTC

[section ""data" . GHC.Conc.Sync.$w$cshowsPrec_closure" {
     GHC.Conc.Sync.$w$cshowsPrec_closure:
         const GHC.Conc.Sync.$w$cshowsPrec_info;
         const 0;
 },
 GHC.Conc.Sync.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c9Mdi,
                       label: GHC.Conc.Sync.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mdi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Mdj; else goto c9Mdk;
       c9Mdj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Mdk: // global
           I64[Sp - 16] = block_c9Md7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9MdD; else goto c9Md8;
       u9MdD: // global
           call _c9Md7(R1) args: 0, res: 0, upd: 0;
       c9Md8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Md7() //  [R1]
         { info_tbl: [(c9Md7,
                       label: block_c9Md7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Md7: // global
           _s9LT4::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Mdb;
               case 2 : goto c9Mdc;
               case 3 : goto c9Mdd;
               case 4 : goto c9Mde;
               case 5 : goto c9Mdf;
               case 6 : goto c9Mdg;
           }
       c9Mdg: // global
           R3 = _s9LT4::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason1_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9Mdf: // global
           R3 = _s9LT4::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason3_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9Mde: // global
           R3 = _s9LT4::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason5_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9Mdd: // global
           R3 = _s9LT4::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason7_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9Mdc: // global
           R3 = _s9LT4::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason9_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9Mdb: // global
           R3 = _s9LT4::P64;
           R2 = GHC.Conc.Sync.$fShowBlockReason11_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.538508449 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_closure" {
     GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_closure:
         const GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_entry() //  [R3, R4]
         { info_tbl: [(c9MdY,
                       label: GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MdY: // global
           _s9LT7::P64 = R3;
           R3 = R4;
           R2 = _s9LT7::P64;
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.542402062 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_$cshow_closure" {
     GHC.Conc.Sync.$fShowBlockReason_$cshow_closure:
         const GHC.Conc.Sync.$fShowBlockReason_$cshow_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason_$cshow_entry() //  [R2]
         { info_tbl: [(c9Mek,
                       label: GHC.Conc.Sync.$fShowBlockReason_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mek: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Mel; else goto c9Mem;
       c9Mel: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowBlockReason_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Mem: // global
           I64[Sp - 8] = block_c9Me9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9MeF; else goto c9Mea;
       u9MeF: // global
           call _c9Me9(R1) args: 0, res: 0, upd: 0;
       c9Mea: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Me9() //  [R1]
         { info_tbl: [(c9Me9,
                       label: block_c9Me9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Me9: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Med;
               case 2 : goto c9Mee;
               case 3 : goto c9Mef;
               case 4 : goto c9Meg;
               case 5 : goto c9Meh;
               case 6 : goto c9Mei;
           }
       c9Mei: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Meh: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Meg: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Mef: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Mee: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Med: // global
           R1 = GHC.Conc.Sync.$fShowBlockReason11_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.548939258 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_$cshowList_closure" {
     GHC.Conc.Sync.$fShowBlockReason_$cshowList_closure:
         const GHC.Conc.Sync.$fShowBlockReason_$cshowList_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowBlockReason_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c9Mf5,
                       label: GHC.Conc.Sync.$fShowBlockReason_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mf5: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$w$cshowsPrec_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.552207714 UTC

[section ""data" . GHC.Conc.Sync.$fShowBlockReason_closure" {
     GHC.Conc.Sync.$fShowBlockReason_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Conc.Sync.$fShowBlockReason_$cshowsPrec_closure+3;
         const GHC.Conc.Sync.$fShowBlockReason_$cshow_closure+1;
         const GHC.Conc.Sync.$fShowBlockReason_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.555227501 UTC

[section ""data" . GHC.Conc.Sync.$fEqBlockReason_$c==_closure" {
     GHC.Conc.Sync.$fEqBlockReason_$c==_closure:
         const GHC.Conc.Sync.$fEqBlockReason_$c==_info;
 },
 GHC.Conc.Sync.$fEqBlockReason_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9Mfs,
                       label: GHC.Conc.Sync.$fEqBlockReason_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mfs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Mft; else goto c9Mfu;
       c9Mft: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqBlockReason_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Mfu: // global
           I64[Sp - 16] = block_c9Mfh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Mhl; else goto c9Mfi;
       u9Mhl: // global
           call _c9Mfh(R1) args: 0, res: 0, upd: 0;
       c9Mfi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Mfh() //  [R1]
         { info_tbl: [(c9Mfh,
                       label: block_c9Mfh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mfh: // global
           _s9LTe::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Mfl;
               case 2 : goto c9Mfm;
               case 3 : goto c9Mfn;
               case 4 : goto c9Mfo;
               case 5 : goto c9Mfp;
               case 6 : goto c9Mfq;
           }
       c9Mfq: // global
           I64[Sp + 8] = block_c9MgK_info;
           R1 = _s9LTe::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Mhk; else goto c9MgM;
       u9Mhk: // global
           call _c9MgK(R1) args: 0, res: 0, upd: 0;
       c9MgM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Mfp: // global
           I64[Sp + 8] = block_c9Mgv_info;
           R1 = _s9LTe::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Mhj; else goto c9Mgx;
       u9Mhj: // global
           call _c9Mgv(R1) args: 0, res: 0, upd: 0;
       c9Mgx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Mfo: // global
           I64[Sp + 8] = block_c9Mgg_info;
           R1 = _s9LTe::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Mhi; else goto c9Mgi;
       u9Mhi: // global
           call _c9Mgg(R1) args: 0, res: 0, upd: 0;
       c9Mgi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Mfn: // global
           I64[Sp + 8] = block_c9Mg1_info;
           R1 = _s9LTe::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Mhh; else goto c9Mg3;
       u9Mhh: // global
           call _c9Mg1(R1) args: 0, res: 0, upd: 0;
       c9Mg3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Mfm: // global
           I64[Sp + 8] = block_c9MfM_info;
           R1 = _s9LTe::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Mhg; else goto c9MfO;
       u9Mhg: // global
           call _c9MfM(R1) args: 0, res: 0, upd: 0;
       c9MfO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Mfl: // global
           I64[Sp + 8] = block_c9Mfx_info;
           R1 = _s9LTe::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Mhf; else goto c9Mfz;
       u9Mhf: // global
           call _c9Mfx(R1) args: 0, res: 0, upd: 0;
       c9Mfz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MgK() //  [R1]
         { info_tbl: [(c9MgK,
                       label: block_c9MgK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MgK: // global
           if (R1 & 7 == 6) goto u9Mh3; else goto u9Mh4;
       u9Mh3: // global
           Sp = Sp + 8;
           call _c9MgW() args: 0, res: 0, upd: 0;
       u9Mh4: // global
           Sp = Sp + 8;
           call _c9MgS() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mgv() //  [R1]
         { info_tbl: [(c9Mgv,
                       label: block_c9Mgv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mgv: // global
           if (R1 & 7 == 5) goto u9Mh5; else goto u9Mh6;
       u9Mh5: // global
           Sp = Sp + 8;
           call _c9MgW() args: 0, res: 0, upd: 0;
       u9Mh6: // global
           Sp = Sp + 8;
           call _c9MgS() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mgg() //  [R1]
         { info_tbl: [(c9Mgg,
                       label: block_c9Mgg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mgg: // global
           if (R1 & 7 == 4) goto u9Mh7; else goto u9Mh8;
       u9Mh7: // global
           Sp = Sp + 8;
           call _c9MgW() args: 0, res: 0, upd: 0;
       u9Mh8: // global
           Sp = Sp + 8;
           call _c9MgS() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mg1() //  [R1]
         { info_tbl: [(c9Mg1,
                       label: block_c9Mg1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mg1: // global
           if (R1 & 7 == 3) goto u9Mh9; else goto u9Mha;
       u9Mh9: // global
           Sp = Sp + 8;
           call _c9MgW() args: 0, res: 0, upd: 0;
       u9Mha: // global
           Sp = Sp + 8;
           call _c9MgS() args: 0, res: 0, upd: 0;
     }
 },
 _c9MfM() //  [R1]
         { info_tbl: [(c9MfM,
                       label: block_c9MfM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MfM: // global
           if (R1 & 7 == 2) goto u9Mhb; else goto u9Mhc;
       u9Mhb: // global
           Sp = Sp + 8;
           call _c9MgW() args: 0, res: 0, upd: 0;
       u9Mhc: // global
           Sp = Sp + 8;
           call _c9MgS() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mfx() //  [R1]
         { info_tbl: [(c9Mfx,
                       label: block_c9Mfx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mfx: // global
           if (R1 & 7 == 1) goto u9Mhd; else goto u9Mhe;
       u9Mhd: // global
           Sp = Sp + 8;
           call _c9MgW() args: 0, res: 0, upd: 0;
       u9Mhe: // global
           Sp = Sp + 8;
           call _c9MgS() args: 0, res: 0, upd: 0;
     }
 },
 _c9MgW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MgW: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9MgS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MgS: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.574159403 UTC

[section ""data" . GHC.Conc.Sync.$fEqBlockReason_$c/=_closure" {
     GHC.Conc.Sync.$fEqBlockReason_$c/=_closure:
         const GHC.Conc.Sync.$fEqBlockReason_$c/=_info;
 },
 GHC.Conc.Sync.$fEqBlockReason_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9MiQ,
                       label: GHC.Conc.Sync.$fEqBlockReason_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MiQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MiR; else goto c9MiS;
       c9MiR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqBlockReason_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MiS: // global
           I64[Sp - 16] = block_c9MiF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9MkJ; else goto c9MiG;
       u9MkJ: // global
           call _c9MiF(R1) args: 0, res: 0, upd: 0;
       c9MiG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MiF() //  [R1]
         { info_tbl: [(c9MiF,
                       label: block_c9MiF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MiF: // global
           _s9LTn::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9MiJ;
               case 2 : goto c9MiK;
               case 3 : goto c9MiL;
               case 4 : goto c9MiM;
               case 5 : goto c9MiN;
               case 6 : goto c9MiO;
           }
       c9MiO: // global
           I64[Sp + 8] = block_c9Mk8_info;
           R1 = _s9LTn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MkI; else goto c9Mka;
       u9MkI: // global
           call _c9Mk8(R1) args: 0, res: 0, upd: 0;
       c9Mka: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MiN: // global
           I64[Sp + 8] = block_c9MjT_info;
           R1 = _s9LTn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MkH; else goto c9MjV;
       u9MkH: // global
           call _c9MjT(R1) args: 0, res: 0, upd: 0;
       c9MjV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MiM: // global
           I64[Sp + 8] = block_c9MjE_info;
           R1 = _s9LTn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MkG; else goto c9MjG;
       u9MkG: // global
           call _c9MjE(R1) args: 0, res: 0, upd: 0;
       c9MjG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MiL: // global
           I64[Sp + 8] = block_c9Mjp_info;
           R1 = _s9LTn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MkF; else goto c9Mjr;
       u9MkF: // global
           call _c9Mjp(R1) args: 0, res: 0, upd: 0;
       c9Mjr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MiK: // global
           I64[Sp + 8] = block_c9Mja_info;
           R1 = _s9LTn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MkE; else goto c9Mjc;
       u9MkE: // global
           call _c9Mja(R1) args: 0, res: 0, upd: 0;
       c9Mjc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MiJ: // global
           I64[Sp + 8] = block_c9MiV_info;
           R1 = _s9LTn::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MkD; else goto c9MiX;
       u9MkD: // global
           call _c9MiV(R1) args: 0, res: 0, upd: 0;
       c9MiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Mk8() //  [R1]
         { info_tbl: [(c9Mk8,
                       label: block_c9Mk8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mk8: // global
           if (R1 & 7 == 6) goto u9Mkr; else goto u9Mks;
       u9Mkr: // global
           Sp = Sp + 8;
           call _c9Mkk() args: 0, res: 0, upd: 0;
       u9Mks: // global
           Sp = Sp + 8;
           call _c9Mkg() args: 0, res: 0, upd: 0;
     }
 },
 _c9MjT() //  [R1]
         { info_tbl: [(c9MjT,
                       label: block_c9MjT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MjT: // global
           if (R1 & 7 == 5) goto u9Mkt; else goto u9Mku;
       u9Mkt: // global
           Sp = Sp + 8;
           call _c9Mkk() args: 0, res: 0, upd: 0;
       u9Mku: // global
           Sp = Sp + 8;
           call _c9Mkg() args: 0, res: 0, upd: 0;
     }
 },
 _c9MjE() //  [R1]
         { info_tbl: [(c9MjE,
                       label: block_c9MjE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MjE: // global
           if (R1 & 7 == 4) goto u9Mkv; else goto u9Mkw;
       u9Mkv: // global
           Sp = Sp + 8;
           call _c9Mkk() args: 0, res: 0, upd: 0;
       u9Mkw: // global
           Sp = Sp + 8;
           call _c9Mkg() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mjp() //  [R1]
         { info_tbl: [(c9Mjp,
                       label: block_c9Mjp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mjp: // global
           if (R1 & 7 == 3) goto u9Mkx; else goto u9Mky;
       u9Mkx: // global
           Sp = Sp + 8;
           call _c9Mkk() args: 0, res: 0, upd: 0;
       u9Mky: // global
           Sp = Sp + 8;
           call _c9Mkg() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mja() //  [R1]
         { info_tbl: [(c9Mja,
                       label: block_c9Mja_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mja: // global
           if (R1 & 7 == 2) goto u9Mkz; else goto u9MkA;
       u9Mkz: // global
           Sp = Sp + 8;
           call _c9Mkk() args: 0, res: 0, upd: 0;
       u9MkA: // global
           Sp = Sp + 8;
           call _c9Mkg() args: 0, res: 0, upd: 0;
     }
 },
 _c9MiV() //  [R1]
         { info_tbl: [(c9MiV,
                       label: block_c9MiV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MiV: // global
           if (R1 & 7 == 1) goto u9MkB; else goto u9MkC;
       u9MkB: // global
           Sp = Sp + 8;
           call _c9Mkk() args: 0, res: 0, upd: 0;
       u9MkC: // global
           Sp = Sp + 8;
           call _c9Mkg() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mkk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mkk: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Mkg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mkg: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.592838151 UTC

[section ""data" . GHC.Conc.Sync.$fEqBlockReason_closure" {
     GHC.Conc.Sync.$fEqBlockReason_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqBlockReason_$c==_closure+2;
         const GHC.Conc.Sync.$fEqBlockReason_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.595832876 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadStatus_$c==_closure" {
     GHC.Conc.Sync.$fEqThreadStatus_$c==_closure:
         const GHC.Conc.Sync.$fEqThreadStatus_$c==_info;
 },
 GHC.Conc.Sync.$fEqThreadStatus_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9Mmd,
                       label: GHC.Conc.Sync.$fEqThreadStatus_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mmd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Mme; else goto c9Mmf;
       c9Mme: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadStatus_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Mmf: // global
           I64[Sp - 16] = block_c9Mm4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Mnv; else goto c9Mm5;
       u9Mnv: // global
           call _c9Mm4(R1) args: 0, res: 0, upd: 0;
       c9Mm5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Mm4() //  [R1]
         { info_tbl: [(c9Mm4,
                       label: block_c9Mm4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mm4: // global
           _s9LTw::P64 = P64[Sp + 8];
           _c9Mmc::P64 = R1 & 7;
           if (_c9Mmc::P64 < 3) goto u9Mni; else goto u9Mnj;
       u9Mni: // global
           if (_c9Mmc::P64 < 2) goto c9Mm8; else goto c9Mm9;
       c9Mm8: // global
           I64[Sp + 8] = block_c9Mmi_info;
           R1 = _s9LTw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Mnr; else goto c9Mmk;
       u9Mnr: // global
           call _c9Mmi(R1) args: 0, res: 0, upd: 0;
       c9Mmk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Mm9: // global
           I64[Sp + 8] = block_c9Mmx_info;
           R1 = _s9LTw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Mns; else goto c9Mmz;
       u9Mns: // global
           call _c9Mmx(R1) args: 0, res: 0, upd: 0;
       c9Mmz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Mnj: // global
           if (_c9Mmc::P64 < 4) goto c9Mma; else goto c9Mmb;
       c9Mma: // global
           I64[Sp] = block_c9MmM_info;
           _s9LTA::P64 = P64[R1 + 5];
           R1 = _s9LTw::P64;
           P64[Sp + 8] = _s9LTA::P64;
           if (R1 & 7 != 0) goto u9Mnt; else goto c9MmO;
       u9Mnt: // global
           call _c9MmM(R1) args: 0, res: 0, upd: 0;
       c9MmO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Mmb: // global
           I64[Sp + 8] = block_c9Mn1_info;
           R1 = _s9LTw::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Mnu; else goto c9Mn3;
       u9Mnu: // global
           call _c9Mn1(R1) args: 0, res: 0, upd: 0;
       c9Mn3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Mmi() //  [R1]
         { info_tbl: [(c9Mmi,
                       label: block_c9Mmi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mmi: // global
           if (R1 & 7 == 1) goto u9Mnk; else goto u9Mnl;
       u9Mnk: // global
           Sp = Sp + 8;
           call _c9Mnd() args: 0, res: 0, upd: 0;
       u9Mnl: // global
           Sp = Sp + 8;
           call _c9Mn9() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mmx() //  [R1]
         { info_tbl: [(c9Mmx,
                       label: block_c9Mmx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mmx: // global
           if (R1 & 7 == 2) goto u9Mnm; else goto u9Mnn;
       u9Mnm: // global
           Sp = Sp + 8;
           call _c9Mnd() args: 0, res: 0, upd: 0;
       u9Mnn: // global
           Sp = Sp + 8;
           call _c9Mn9() args: 0, res: 0, upd: 0;
     }
 },
 _c9MmM() //  [R1]
         { info_tbl: [(c9MmM,
                       label: block_c9MmM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MmM: // global
           if (R1 & 7 == 3) goto c9MmY; else goto u9Mno;
       c9MmY: // global
           R3 = P64[R1 + 5];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$fEqBlockReason_$c==_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
       u9Mno: // global
           Sp = Sp + 16;
           call _c9Mn9() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mn1() //  [R1]
         { info_tbl: [(c9Mn1,
                       label: block_c9Mn1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mn1: // global
           if (R1 & 7 == 4) goto u9Mnp; else goto u9Mnq;
       u9Mnp: // global
           Sp = Sp + 8;
           call _c9Mnd() args: 0, res: 0, upd: 0;
       u9Mnq: // global
           Sp = Sp + 8;
           call _c9Mn9() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mnd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mnd: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Mn9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mn9: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.611995945 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure" {
     GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure:
         const GHC.Conc.Sync.$fEqThreadStatus_$c/=_info;
 },
 GHC.Conc.Sync.$fEqThreadStatus_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9MoB,
                       label: GHC.Conc.Sync.$fEqThreadStatus_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MoB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MoC; else goto c9MoD;
       c9MoC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MoD: // global
           I64[Sp - 16] = block_c9Mos_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9MrO; else goto c9Mot;
       u9MrO: // global
           call _c9Mos(R1) args: 0, res: 0, upd: 0;
       c9Mot: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Mos() //  [R1]
         { info_tbl: [(c9Mos,
                       label: block_c9Mos_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mos: // global
           _s9LTF::P64 = P64[Sp + 8];
           _c9MoA::P64 = R1 & 7;
           if (_c9MoA::P64 < 3) goto u9Mrp; else goto u9Mrq;
       u9Mrp: // global
           if (_c9MoA::P64 < 2) goto c9Mow; else goto c9Mox;
       c9Mow: // global
           I64[Sp + 8] = block_c9MoG_info;
           R1 = _s9LTF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MrK; else goto c9MoI;
       u9MrK: // global
           call _c9MoG(R1) args: 0, res: 0, upd: 0;
       c9MoI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Mox: // global
           I64[Sp + 8] = block_c9MoV_info;
           R1 = _s9LTF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MrL; else goto c9MoX;
       u9MrL: // global
           call _c9MoV(R1) args: 0, res: 0, upd: 0;
       c9MoX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Mrq: // global
           if (_c9MoA::P64 < 4) goto c9Moy; else goto c9Moz;
       c9Moy: // global
           I64[Sp] = block_c9Mpa_info;
           _s9LTJ::P64 = P64[R1 + 5];
           R1 = _s9LTF::P64;
           P64[Sp + 8] = _s9LTJ::P64;
           if (R1 & 7 != 0) goto u9MrM; else goto c9Mpc;
       u9MrM: // global
           call _c9Mpa(R1) args: 0, res: 0, upd: 0;
       c9Mpc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Moz: // global
           I64[Sp + 8] = block_c9Mr1_info;
           R1 = _s9LTF::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MrN; else goto c9Mr3;
       u9MrN: // global
           call _c9Mr1(R1) args: 0, res: 0, upd: 0;
       c9Mr3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MoG() //  [R1]
         { info_tbl: [(c9MoG,
                       label: block_c9MoG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MoG: // global
           if (R1 & 7 == 1) goto u9Mrr; else goto u9Mrs;
       u9Mrr: // global
           Sp = Sp + 8;
           call _c9Mrd() args: 0, res: 0, upd: 0;
       u9Mrs: // global
           Sp = Sp + 8;
           call _c9Mr9() args: 0, res: 0, upd: 0;
     }
 },
 _c9MoV() //  [R1]
         { info_tbl: [(c9MoV,
                       label: block_c9MoV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MoV: // global
           if (R1 & 7 == 2) goto u9Mrt; else goto u9Mru;
       u9Mrt: // global
           Sp = Sp + 8;
           call _c9Mrd() args: 0, res: 0, upd: 0;
       u9Mru: // global
           Sp = Sp + 8;
           call _c9Mr9() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mpa() //  [R1]
         { info_tbl: [(c9Mpa,
                       label: block_c9Mpa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mpa: // global
           if (R1 & 7 == 3) goto c9Mpn; else goto u9Mrv;
       c9Mpn: // global
           I64[Sp] = block_c9Mpl_info;
           _s9LTL::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9LTL::P64;
           if (R1 & 7 != 0) goto u9MrT; else goto c9Mpo;
       u9MrT: // global
           call _c9Mpl(R1) args: 0, res: 0, upd: 0;
       c9Mpo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Mrv: // global
           Sp = Sp + 16;
           call _c9Mr9() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mpl() //  [R1]
         { info_tbl: [(c9Mpl,
                       label: block_c9Mpl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mpl: // global
           _s9LTL::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Mpv;
               case 2 : goto c9MpL;
               case 3 : goto c9Mq1;
               case 4 : goto c9Mqh;
               case 5 : goto c9Mqx;
               case 6 : goto c9MqN;
           }
       c9MqN: // global
           I64[Sp + 8] = block_c9MqL_info;
           R1 = _s9LTL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ms0; else goto c9MqO;
       u9Ms0: // global
           call _c9MqL(R1) args: 0, res: 0, upd: 0;
       c9MqO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Mqx: // global
           I64[Sp + 8] = block_c9Mqv_info;
           R1 = _s9LTL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MrZ; else goto c9Mqy;
       u9MrZ: // global
           call _c9Mqv(R1) args: 0, res: 0, upd: 0;
       c9Mqy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Mqh: // global
           I64[Sp + 8] = block_c9Mqf_info;
           R1 = _s9LTL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MrY; else goto c9Mqi;
       u9MrY: // global
           call _c9Mqf(R1) args: 0, res: 0, upd: 0;
       c9Mqi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Mq1: // global
           I64[Sp + 8] = block_c9MpZ_info;
           R1 = _s9LTL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MrX; else goto c9Mq2;
       u9MrX: // global
           call _c9MpZ(R1) args: 0, res: 0, upd: 0;
       c9Mq2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MpL: // global
           I64[Sp + 8] = block_c9MpJ_info;
           R1 = _s9LTL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MrW; else goto c9MpM;
       u9MrW: // global
           call _c9MpJ(R1) args: 0, res: 0, upd: 0;
       c9MpM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Mpv: // global
           I64[Sp + 8] = block_c9Mps_info;
           R1 = _s9LTL::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MrV; else goto c9Mpw;
       u9MrV: // global
           call _c9Mps(R1) args: 0, res: 0, upd: 0;
       c9Mpw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MqL() //  [R1]
         { info_tbl: [(c9MqL,
                       label: block_c9MqL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MqL: // global
           if (R1 & 7 == 6) goto u9Mrw; else goto u9Mrx;
       u9Mrw: // global
           Sp = Sp + 8;
           call _c9Mrd() args: 0, res: 0, upd: 0;
       u9Mrx: // global
           Sp = Sp + 8;
           call _c9Mr9() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mqv() //  [R1]
         { info_tbl: [(c9Mqv,
                       label: block_c9Mqv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mqv: // global
           if (R1 & 7 == 5) goto u9Mry; else goto u9Mrz;
       u9Mry: // global
           Sp = Sp + 8;
           call _c9Mrd() args: 0, res: 0, upd: 0;
       u9Mrz: // global
           Sp = Sp + 8;
           call _c9Mr9() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mqf() //  [R1]
         { info_tbl: [(c9Mqf,
                       label: block_c9Mqf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mqf: // global
           if (R1 & 7 == 4) goto u9MrA; else goto u9MrB;
       u9MrA: // global
           Sp = Sp + 8;
           call _c9Mrd() args: 0, res: 0, upd: 0;
       u9MrB: // global
           Sp = Sp + 8;
           call _c9Mr9() args: 0, res: 0, upd: 0;
     }
 },
 _c9MpZ() //  [R1]
         { info_tbl: [(c9MpZ,
                       label: block_c9MpZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MpZ: // global
           if (R1 & 7 == 3) goto u9MrC; else goto u9MrD;
       u9MrC: // global
           Sp = Sp + 8;
           call _c9Mrd() args: 0, res: 0, upd: 0;
       u9MrD: // global
           Sp = Sp + 8;
           call _c9Mr9() args: 0, res: 0, upd: 0;
     }
 },
 _c9MpJ() //  [R1]
         { info_tbl: [(c9MpJ,
                       label: block_c9MpJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MpJ: // global
           if (R1 & 7 == 2) goto u9MrE; else goto u9MrF;
       u9MrE: // global
           Sp = Sp + 8;
           call _c9Mrd() args: 0, res: 0, upd: 0;
       u9MrF: // global
           Sp = Sp + 8;
           call _c9Mr9() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mps() //  [R1]
         { info_tbl: [(c9Mps,
                       label: block_c9Mps_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mps: // global
           if (R1 & 7 == 1) goto u9MrG; else goto u9MrH;
       u9MrG: // global
           Sp = Sp + 8;
           call _c9Mrd() args: 0, res: 0, upd: 0;
       u9MrH: // global
           Sp = Sp + 8;
           call _c9Mr9() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mr1() //  [R1]
         { info_tbl: [(c9Mr1,
                       label: block_c9Mr1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mr1: // global
           if (R1 & 7 == 4) goto u9MrI; else goto u9MrJ;
       u9MrI: // global
           Sp = Sp + 8;
           call _c9Mrd() args: 0, res: 0, upd: 0;
       u9MrJ: // global
           Sp = Sp + 8;
           call _c9Mr9() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mrd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mrd: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Mr9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mr9: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.639919946 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadStatus_closure" {
     GHC.Conc.Sync.$fEqThreadStatus_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqThreadStatus_$c==_closure+2;
         const GHC.Conc.Sync.$fEqThreadStatus_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.642060576 UTC

[section ""data" . GHC.Conc.Sync.numSparks1_closure" {
     GHC.Conc.Sync.numSparks1_closure:
         const GHC.Conc.Sync.numSparks1_info;
 },
 GHC.Conc.Sync.numSparks1_entry() //  []
         { info_tbl: [(c9MtY,
                       label: GHC.Conc.Sync.numSparks1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MtY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9MtZ; else goto c9Mu0;
       c9MtZ: // global
           R1 = GHC.Conc.Sync.numSparks1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Mu0: // global
           I64[Sp - 8] = block_c9MtV_info;
           Sp = Sp - 8;
           call stg_numSparks#() args: 8, res: 8, upd: 8;
     }
 },
 _c9MtV() //  [R1]
         { info_tbl: [(c9MtV,
                       label: block_c9MtV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MtV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Mu3; else goto c9Mu2;
       c9Mu3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9Mu2: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.647432159 UTC

[section ""data" . GHC.Conc.Sync.numSparks_closure" {
     GHC.Conc.Sync.numSparks_closure:
         const GHC.Conc.Sync.numSparks_info;
 },
 GHC.Conc.Sync.numSparks_entry() //  []
         { info_tbl: [(c9Muj,
                       label: GHC.Conc.Sync.numSparks_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Muj: // global
           call GHC.Conc.Sync.numSparks1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.650960581 UTC

[section ""data" . GHC.Conc.Sync.throwTo1_closure" {
     GHC.Conc.Sync.throwTo1_closure:
         const GHC.Conc.Sync.throwTo1_info;
 },
 sat_s9LU5_entry() //  [R1]
         { info_tbl: [(c9MuD,
                       label: sat_s9LU5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MuD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9MuE; else goto c9MuF;
       c9MuE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9MuF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.throwTo1_entry() //  [R2, R3, R4]
         { info_tbl: [(c9MuG,
                       label: GHC.Conc.Sync.throwTo1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MuG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9MuI; else goto c9MuJ;
       c9MuI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.throwTo1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MuJ: // global
           I64[Sp - 24] = block_c9Muu_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9MuP; else goto c9Muv;
       u9MuP: // global
           call _c9Muu(R1) args: 0, res: 0, upd: 0;
       c9Muv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Muu() //  [R1]
         { info_tbl: [(c9Muu,
                       label: block_c9Muu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Muu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9MuM; else goto c9MuL;
       c9MuM: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9MuL: // global
           _s9LU4::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s9LU5_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c9MuH_info;
           R2 = Hp - 24;
           R1 = _s9LU4::P64;
           Sp = Sp + 16;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MuH() //  []
         { info_tbl: [(c9MuH,
                       label: block_c9MuH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MuH: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.660667798 UTC

[section ""data" . GHC.Conc.Sync.throwTo_closure" {
     GHC.Conc.Sync.throwTo_closure:
         const GHC.Conc.Sync.throwTo_info;
 },
 GHC.Conc.Sync.throwTo_entry() //  [R2, R3, R4]
         { info_tbl: [(c9Mvk,
                       label: GHC.Conc.Sync.throwTo_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mvk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.throwTo1_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.664918809 UTC

[section ""data" . GHC.Conc.Sync.myThreadId1_closure" {
     GHC.Conc.Sync.myThreadId1_closure:
         const GHC.Conc.Sync.myThreadId1_info;
 },
 GHC.Conc.Sync.myThreadId1_entry() //  []
         { info_tbl: [(c9Mvw,
                       label: GHC.Conc.Sync.myThreadId1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mvw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9MvA; else goto c9Mvz;
       c9MvA: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.myThreadId1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Mvz: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           I64[Hp] = CurrentTSO;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.668443054 UTC

[section ""data" . GHC.Conc.Sync.myThreadId_closure" {
     GHC.Conc.Sync.myThreadId_closure:
         const GHC.Conc.Sync.myThreadId_info;
 },
 GHC.Conc.Sync.myThreadId_entry() //  []
         { info_tbl: [(c9MvM,
                       label: GHC.Conc.Sync.myThreadId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MvM: // global
           call GHC.Conc.Sync.myThreadId1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.671851155 UTC

[section ""data" . GHC.Conc.Sync.yield1_closure" {
     GHC.Conc.Sync.yield1_closure:
         const GHC.Conc.Sync.yield1_info;
 },
 GHC.Conc.Sync.yield1_entry() //  []
         { info_tbl: [(c9MvZ,
                       label: GHC.Conc.Sync.yield1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MvZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Mw0; else goto c9Mw1;
       c9Mw0: // global
           R1 = GHC.Conc.Sync.yield1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Mw1: // global
           I64[Sp - 8] = block_c9MvX_info;
           Sp = Sp - 8;
           call stg_yield#() args: 8, res: 8, upd: 8;
     }
 },
 _c9MvX() //  []
         { info_tbl: [(c9MvX,
                       label: block_c9MvX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MvX: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.676612409 UTC

[section ""data" . GHC.Conc.Sync.yield_closure" {
     GHC.Conc.Sync.yield_closure:
         const GHC.Conc.Sync.yield_info;
 },
 GHC.Conc.Sync.yield_entry() //  []
         { info_tbl: [(c9Mwi,
                       label: GHC.Conc.Sync.yield_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mwi: // global
           call GHC.Conc.Sync.yield1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.680161976 UTC

[section ""data" . GHC.Conc.Sync.labelThread1_closure" {
     GHC.Conc.Sync.labelThread1_closure:
         const GHC.Conc.Sync.labelThread1_info;
         const 0;
 },
 sat_s9LUo_entry() //  [R1, R2]
         { info_tbl: [(c9MwG,
                       label: sat_s9LUo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MwG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MwK; else goto c9MwL;
       c9MwK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9MwL: // global
           I64[Sp - 16] = block_c9MwD_info;
           _s9LUi::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s9LUi::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9MwP; else goto c9MwE;
       u9MwP: // global
           call _c9MwD(R1) args: 0, res: 0, upd: 0;
       c9MwE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MwD() //  [R1]
         { info_tbl: [(c9MwD,
                       label: block_c9MwD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MwD: // global
           _s9LUi::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9MwJ_info;
           R2 = I64[R1 + 7];
           R1 = _s9LUi::P64;
           Sp = Sp + 8;
           call stg_labelThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MwJ() //  []
         { info_tbl: [(c9MwJ,
                       label: block_c9MwJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MwJ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.labelThread1_entry() //  [R2, R3]
         { info_tbl: [(c9MwQ,
                       label: GHC.Conc.Sync.labelThread1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MwQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MwR; else goto c9MwS;
       c9MwR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.labelThread1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MwS: // global
           I64[Sp - 16] = block_c9Mwt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9MwW; else goto c9Mwu;
       u9MwW: // global
           call _c9Mwt(R1) args: 0, res: 0, upd: 0;
       c9Mwu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Mwt() //  [R1]
         { info_tbl: [(c9Mwt,
                       label: block_c9Mwt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mwt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9MwV; else goto c9MwU;
       c9MwV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9MwU: // global
           _s9LUi::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s9LUo_info;
           P64[Hp] = _s9LUi::P64;
           R4 = Hp - 6;
           R3 = P64[Sp + 8];
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.691511513 UTC

[section ""data" . GHC.Conc.Sync.labelThread_closure" {
     GHC.Conc.Sync.labelThread_closure:
         const GHC.Conc.Sync.labelThread_info;
         const 0;
 },
 GHC.Conc.Sync.labelThread_entry() //  [R2, R3]
         { info_tbl: [(c9Mxr,
                       label: GHC.Conc.Sync.labelThread_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mxr: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.labelThread1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.694922462 UTC

[section ""data" . GHC.Conc.Sync.pseq_closure" {
     GHC.Conc.Sync.pseq_closure:
         const GHC.Conc.Sync.pseq_info;
 },
 GHC.Conc.Sync.pseq_entry() //  [R2, R3]
         { info_tbl: [(c9MxE,
                       label: GHC.Conc.Sync.pseq_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MxE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MxF; else goto c9MxG;
       c9MxF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.pseq_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MxG: // global
           I64[Sp - 16] = block_c9MxC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MxC() //  []
         { info_tbl: [(c9MxC,
                       label: block_c9MxC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MxC: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.700327886 UTC

[section ""data" . GHC.Conc.Sync.par_closure" {
     GHC.Conc.Sync.par_closure:
         const GHC.Conc.Sync.par_info;
 },
 GHC.Conc.Sync.par_entry() //  [R2, R3]
         { info_tbl: [(c9My0,
                       label: GHC.Conc.Sync.par_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9My0: // global
           _s9LUt::P64 = R3;
           (_c9MxV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [] newSpark(BaseReg, R2);
           R1 = _s9LUt::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.704044963 UTC

[section ""data" . GHC.Conc.Sync.runSparks_loop_closure" {
     GHC.Conc.Sync.runSparks_loop_closure:
         const GHC.Conc.Sync.runSparks_loop_info;
 },
 GHC.Conc.Sync.runSparks_loop_entry() //  []
         { info_tbl: [(c9Myk,
                       label: GHC.Conc.Sync.runSparks_loop_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Myk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Myl; else goto u9Myt;
       c9Myl: // global
           R1 = GHC.Conc.Sync.runSparks_loop_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       u9Myt: // global
           call _c9My9() args: 0, res: 0, upd: 0;
     }
 },
 _c9My9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9My9: // global
           I64[Sp - 8] = block_c9Myc_info;
           Sp = Sp - 8;
           call stg_getSpark#() args: 8, res: 8, upd: 8;
     }
 },
 _c9Myc() //  [R1, R2]
         { info_tbl: [(c9Myc,
                       label: block_c9Myc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Myc: // global
           if (R1 == 0) goto c9Myj; else goto c9Myi;
       c9Myj: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Myi: // global
           I64[Sp] = block_c9Myp_info;
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Myp() //  []
         { info_tbl: [(c9Myp,
                       label: block_c9Myp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Myp: // global
           Sp = Sp + 8;
           call _c9My9() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.711238343 UTC

[section ""data" . GHC.Conc.Sync.runSparks_closure" {
     GHC.Conc.Sync.runSparks_closure:
         const GHC.Conc.Sync.runSparks_info;
 },
 GHC.Conc.Sync.runSparks_entry() //  []
         { info_tbl: [(c9MyQ,
                       label: GHC.Conc.Sync.runSparks_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MyQ: // global
           call GHC.Conc.Sync.runSparks_loop_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.715315486 UTC

[section ""data" . GHC.Conc.Sync.threadCapability1_closure" {
     GHC.Conc.Sync.threadCapability1_closure:
         const GHC.Conc.Sync.threadCapability1_info;
 },
 sat_s9LUN_entry() //  [R1]
         { info_tbl: [(c9Mzi,
                       label: sat_s9LUN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mzi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Mzj; else goto c9Mzk;
       c9Mzj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Mzk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c9Mzh; else goto c9Mzg;
       c9Mzh: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9Mzg: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.threadCapability1_entry() //  [R2]
         { info_tbl: [(c9Mzl,
                       label: GHC.Conc.Sync.threadCapability1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mzl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Mzo; else goto c9Mzp;
       c9Mzo: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.threadCapability1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Mzp: // global
           I64[Sp - 8] = block_c9Mz1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Mzw; else goto c9Mz2;
       u9Mzw: // global
           call _c9Mz1(R1) args: 0, res: 0, upd: 0;
       c9Mz2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Mz1() //  [R1]
         { info_tbl: [(c9Mz1,
                       label: block_c9Mz1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mz1: // global
           I64[Sp] = block_c9Mz6_info;
           R1 = P64[R1 + 7];
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Mz6() //  [R2, R3]
         { info_tbl: [(c9Mz6,
                       label: block_c9Mz6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mz6: // global
           I64[Sp - 8] = R3;
           I64[Sp] = R2;
           Sp = Sp - 16;
           call _c9Mz7() args: 0, res: 0, upd: 0;
     }
 },
 _c9Mz7() //  []
         { info_tbl: [(c9Mz7,
                       label: block_c9Mz7_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Mz7: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c9Mzt; else goto c9Mzs;
       c9Mzt: // global
           HpAlloc = 64;
           I64[Sp] = block_c9Mz7_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c9Mzs: // global
           I64[Hp - 56] = sat_s9LUN_info;
           I64[Hp - 40] = I64[Sp + 8];
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.726779976 UTC

[section ""data" . GHC.Conc.Sync.threadCapability_closure" {
     GHC.Conc.Sync.threadCapability_closure:
         const GHC.Conc.Sync.threadCapability_info;
 },
 GHC.Conc.Sync.threadCapability_entry() //  [R2]
         { info_tbl: [(c9MAa,
                       label: GHC.Conc.Sync.threadCapability_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MAa: // global
           R2 = R2;
           call GHC.Conc.Sync.threadCapability1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.730148711 UTC

[section ""data" . GHC.Conc.Sync.mkWeakThreadId1_closure" {
     GHC.Conc.Sync.mkWeakThreadId1_closure:
         const GHC.Conc.Sync.mkWeakThreadId1_info;
 },
 GHC.Conc.Sync.mkWeakThreadId1_entry() //  [R2]
         { info_tbl: [(c9MAo,
                       label: GHC.Conc.Sync.mkWeakThreadId1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MAo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9MAu; else goto c9MAv;
       c9MAu: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.mkWeakThreadId1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9MAv: // global
           I64[Sp - 8] = block_c9MAl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9MAA; else goto c9MAm;
       u9MAA: // global
           call _c9MAl(R1) args: 0, res: 0, upd: 0;
       c9MAm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MAl() //  [R1]
         { info_tbl: [(c9MAl,
                       label: block_c9MAl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MAl: // global
           I64[Sp] = block_c9MAr_info;
           R2 = R1;
           R1 = P64[R1 + 7];
           call stg_mkWeakNoFinalizer#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MAr() //  [R1]
         { info_tbl: [(c9MAr,
                       label: block_c9MAr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MAr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9MAz; else goto c9MAy;
       c9MAz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9MAy: // global
           I64[Hp - 8] = GHC.Weak.Weak_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.737226759 UTC

[section ""data" . GHC.Conc.Sync.mkWeakThreadId_closure" {
     GHC.Conc.Sync.mkWeakThreadId_closure:
         const GHC.Conc.Sync.mkWeakThreadId_info;
 },
 GHC.Conc.Sync.mkWeakThreadId_entry() //  [R2]
         { info_tbl: [(c9MAV,
                       label: GHC.Conc.Sync.mkWeakThreadId_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MAV: // global
           R2 = R2;
           call GHC.Conc.Sync.mkWeakThreadId1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.740658418 UTC

[section ""data" . GHC.Conc.Sync.newStablePtrPrimMVar1_closure" {
     GHC.Conc.Sync.newStablePtrPrimMVar1_closure:
         const GHC.Conc.Sync.newStablePtrPrimMVar1_info;
 },
 GHC.Conc.Sync.newStablePtrPrimMVar1_entry() //  [R2]
         { info_tbl: [(c9MB9,
                       label: GHC.Conc.Sync.newStablePtrPrimMVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MB9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9MBf; else goto c9MBg;
       c9MBf: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.newStablePtrPrimMVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9MBg: // global
           I64[Sp - 8] = block_c9MB6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9MBl; else goto c9MB7;
       u9MBl: // global
           call _c9MB6(R1) args: 0, res: 0, upd: 0;
       c9MB7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MB6() //  [R1]
         { info_tbl: [(c9MB6,
                       label: block_c9MB6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MB6: // global
           I64[Sp] = block_c9MBc_info;
           R1 = P64[R1 + 7];
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MBc() //  [R1]
         { info_tbl: [(c9MBc,
                       label: block_c9MBc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MBc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9MBk; else goto c9MBj;
       c9MBk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9MBj: // global
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.74789985 UTC

[section ""data" . GHC.Conc.Sync.newStablePtrPrimMVar_closure" {
     GHC.Conc.Sync.newStablePtrPrimMVar_closure:
         const GHC.Conc.Sync.newStablePtrPrimMVar_info;
 },
 GHC.Conc.Sync.newStablePtrPrimMVar_entry() //  [R2]
         { info_tbl: [(c9MBG,
                       label: GHC.Conc.Sync.newStablePtrPrimMVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MBG: // global
           R2 = R2;
           call GHC.Conc.Sync.newStablePtrPrimMVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.751135268 UTC

[section ""data" . $c>>=_r9FuK_closure" {
     $c>>=_r9FuK_closure:
         const $c>>=_r9FuK_info;
 },
 $c>>=_r9FuK_entry() //  [R2, R3]
         { info_tbl: [(c9MBT,
                       label: $c>>=_r9FuK_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MBT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MBU; else goto c9MBV;
       c9MBU: // global
           R3 = R3;
           R2 = R2;
           R1 = $c>>=_r9FuK_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MBV: // global
           I64[Sp - 16] = block_c9MBR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MBR() //  [R1]
         { info_tbl: [(c9MBR,
                       label: block_c9MBR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MBR: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.756947496 UTC

[section ""data" . GHC.Conc.Sync.$fMonadSTM_$c>>=_closure" {
     GHC.Conc.Sync.$fMonadSTM_$c>>=_closure:
         const GHC.Conc.Sync.$fMonadSTM_$c>>=_info;
 },
 GHC.Conc.Sync.$fMonadSTM_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c9MCa,
                       label: GHC.Conc.Sync.$fMonadSTM_$c>>=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MCa: // global
           R3 = R3;
           R2 = R2;
           call $c>>=_r9FuK_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.760222574 UTC

[section ""data" . $c*>_r9FuL_closure" {
     $c*>_r9FuL_closure:
         const $c*>_r9FuL_info;
 },
 $c*>_r9FuL_entry() //  [R2, R3]
         { info_tbl: [(c9MCn,
                       label: $c*>_r9FuL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MCn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MCo; else goto c9MCp;
       c9MCo: // global
           R3 = R3;
           R2 = R2;
           R1 = $c*>_r9FuL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MCp: // global
           I64[Sp - 16] = block_c9MCl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MCl() //  []
         { info_tbl: [(c9MCl,
                       label: block_c9MCl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MCl: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.765178217 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure:
         const GHC.Conc.Sync.$fApplicativeSTM_$c*>_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM_$c*>_entry() //  [R2, R3]
         { info_tbl: [(c9MCE,
                       label: GHC.Conc.Sync.$fApplicativeSTM_$c*>_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MCE: // global
           R3 = R3;
           R2 = R2;
           call $c*>_r9FuL_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.768477476 UTC

[section ""data" . GHC.Conc.Sync.orElse_closure" {
     GHC.Conc.Sync.orElse_closure:
         const GHC.Conc.Sync.orElse_info;
 },
 GHC.Conc.Sync.orElse_entry() //  [R2, R3]
         { info_tbl: [(c9MCP,
                       label: GHC.Conc.Sync.orElse_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MCP: // global
           _B3::P64 = R2;
           R2 = R3;
           R1 = _B3::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.772302223 UTC

[section ""data" . GHC.Conc.Sync.catchSTM1_closure" {
     GHC.Conc.Sync.catchSTM1_closure:
         const GHC.Conc.Sync.catchSTM1_info;
 },
 sat_s9LVn_entry() //  [R1]
         { info_tbl: [(c9MDe,
                       label: sat_s9LVn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MDe: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9LVp_entry() //  [R1, R2]
         { info_tbl: [(c9MDl,
                       label: sat_s9LVp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MDl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9MDm; else goto c9MDn;
       c9MDm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9MDn: // global
           I64[Sp - 24] = block_c9MD5_info;
           _s9LVl::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _s9LVl::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = _s9LVl::P64;
           Sp = Sp - 40;
           call GHC.Exception.fromException_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c9MD5() //  [R1]
         { info_tbl: [(c9MD5,
                       label: block_c9MD5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MD5: // global
           if (R1 & 7 == 1) goto c9MDi; else goto c9MDj;
       c9MDi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9MDq; else goto c9MDp;
       c9MDq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9MDp: // global
           I64[Hp - 8] = sat_s9LVn_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9MDj: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.catchSTM1_entry() //  [R2, R3, R4]
         { info_tbl: [(c9MDu,
                       label: GHC.Conc.Sync.catchSTM1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MDu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9MDy; else goto c9MDx;
       c9MDy: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.catchSTM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MDx: // global
           I64[Hp - 16] = sat_s9LVp_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = Hp - 15;
           R1 = R3;
           call stg_catchSTM#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.782506214 UTC

[section ""data" . GHC.Conc.Sync.catchSTM_closure" {
     GHC.Conc.Sync.catchSTM_closure:
         const GHC.Conc.Sync.catchSTM_info;
 },
 GHC.Conc.Sync.catchSTM_entry() //  [R2, R3, R4]
         { info_tbl: [(c9ME0,
                       label: GHC.Conc.Sync.catchSTM_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ME0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.catchSTM1_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.785872802 UTC

[section ""data" . $cpure_r9FuM_closure" {
     $cpure_r9FuM_closure:
         const $cpure_r9FuM_info;
 },
 $cpure_r9FuM_entry() //  [R2]
         { info_tbl: [(c9MEb,
                       label: $cpure_r9FuM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MEb: // global
           R1 = R2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.789756405 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure:
         const GHC.Conc.Sync.$fApplicativeSTM_$cpure_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM_$cpure_entry() //  [R2]
         { info_tbl: [(c9MEn,
                       label: GHC.Conc.Sync.$fApplicativeSTM_$cpure_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MEn: // global
           R2 = R2;
           call $cpure_r9FuM_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.792788512 UTC

[section ""data" . GHC.Conc.Sync.unsafeIOToSTM1_closure" {
     GHC.Conc.Sync.unsafeIOToSTM1_closure:
         const GHC.Conc.Sync.unsafeIOToSTM1_info;
 },
 GHC.Conc.Sync.unsafeIOToSTM1_entry() //  [R2]
         { info_tbl: [(c9MEy,
                       label: GHC.Conc.Sync.unsafeIOToSTM1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MEy: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.795928479 UTC

[section ""data" . GHC.Conc.Sync.unsafeIOToSTM_closure" {
     GHC.Conc.Sync.unsafeIOToSTM_closure:
         const GHC.Conc.Sync.unsafeIOToSTM_info;
 },
 GHC.Conc.Sync.unsafeIOToSTM_entry() //  [R2]
         { info_tbl: [(c9MEJ,
                       label: GHC.Conc.Sync.unsafeIOToSTM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MEJ: // global
           R2 = R2;
           call GHC.Conc.Sync.unsafeIOToSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.799083599 UTC

[section ""data" . GHC.Conc.Sync.atomically_closure" {
     GHC.Conc.Sync.atomically_closure:
         const GHC.Conc.Sync.atomically_info;
 },
 GHC.Conc.Sync.atomically_entry() //  [R2]
         { info_tbl: [(c9MEU,
                       label: GHC.Conc.Sync.atomically_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MEU: // global
           R1 = R2;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.802150654 UTC

[section ""data" . GHC.Conc.Sync.retry_closure" {
     GHC.Conc.Sync.retry_closure:
         const GHC.Conc.Sync.retry_info;
 },
 GHC.Conc.Sync.retry_entry() //  []
         { info_tbl: [(c9MF5,
                       label: GHC.Conc.Sync.retry_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MF5: // global
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.805472509 UTC

[section ""data" . GHC.Conc.Sync.throwSTM1_closure" {
     GHC.Conc.Sync.throwSTM1_closure:
         const GHC.Conc.Sync.throwSTM1_info;
 },
 sat_s9LVw_entry() //  [R1]
         { info_tbl: [(c9MFk,
                       label: sat_s9LVw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MFk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9MFl; else goto c9MFm;
       c9MFl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9MFm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Exception.toException_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.throwSTM1_entry() //  [R2, R3]
         { info_tbl: [(c9MFn,
                       label: GHC.Conc.Sync.throwSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MFn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9MFr; else goto c9MFq;
       c9MFr: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.throwSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MFq: // global
           I64[Hp - 24] = sat_s9LVw_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.811207568 UTC

[section ""data" . GHC.Conc.Sync.throwSTM_closure" {
     GHC.Conc.Sync.throwSTM_closure:
         const GHC.Conc.Sync.throwSTM_info;
 },
 GHC.Conc.Sync.throwSTM_entry() //  [R2, R3]
         { info_tbl: [(c9MFI,
                       label: GHC.Conc.Sync.throwSTM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MFI: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.throwSTM1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.814563043 UTC

[section ""data" . GHC.Conc.Sync.newTVar1_closure" {
     GHC.Conc.Sync.newTVar1_closure:
         const GHC.Conc.Sync.newTVar1_info;
 },
 GHC.Conc.Sync.newTVar1_entry() //  [R2]
         { info_tbl: [(c9MFW,
                       label: GHC.Conc.Sync.newTVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MFW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9MFX; else goto c9MFY;
       c9MFX: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.newTVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9MFY: // global
           I64[Sp - 8] = block_c9MFT_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MFT() //  [R1]
         { info_tbl: [(c9MFT,
                       label: block_c9MFT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MFT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9MG1; else goto c9MG0;
       c9MG1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9MG0: // global
           I64[Hp - 8] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.820385459 UTC

[section ""data" . GHC.Conc.Sync.newTVar_closure" {
     GHC.Conc.Sync.newTVar_closure:
         const GHC.Conc.Sync.newTVar_info;
 },
 GHC.Conc.Sync.newTVar_entry() //  [R2]
         { info_tbl: [(c9MGh,
                       label: GHC.Conc.Sync.newTVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MGh: // global
           R2 = R2;
           call GHC.Conc.Sync.newTVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.824162255 UTC

[section ""data" . GHC.Conc.Sync.newTVarIO_closure" {
     GHC.Conc.Sync.newTVarIO_closure:
         const GHC.Conc.Sync.newTVarIO_info;
 },
 GHC.Conc.Sync.newTVarIO_entry() //  [R2]
         { info_tbl: [(c9MGs,
                       label: GHC.Conc.Sync.newTVarIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MGs: // global
           R2 = R2;
           call GHC.Conc.Sync.newTVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.827465001 UTC

[section ""data" . GHC.Conc.Sync.readTVarIO1_closure" {
     GHC.Conc.Sync.readTVarIO1_closure:
         const GHC.Conc.Sync.readTVarIO1_info;
 },
 GHC.Conc.Sync.readTVarIO1_entry() //  [R2]
         { info_tbl: [(c9MGG,
                       label: GHC.Conc.Sync.readTVarIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MGG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9MGH; else goto c9MGI;
       c9MGH: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.readTVarIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9MGI: // global
           I64[Sp - 8] = block_c9MGD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9MGM; else goto c9MGE;
       u9MGM: // global
           call _c9MGD(R1) args: 0, res: 0, upd: 0;
       c9MGE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MGD() //  [R1]
         { info_tbl: [(c9MGD,
                       label: block_c9MGD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MGD: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readTVarIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.832986744 UTC

[section ""data" . GHC.Conc.Sync.readTVarIO_closure" {
     GHC.Conc.Sync.readTVarIO_closure:
         const GHC.Conc.Sync.readTVarIO_info;
 },
 GHC.Conc.Sync.readTVarIO_entry() //  [R2]
         { info_tbl: [(c9MH1,
                       label: GHC.Conc.Sync.readTVarIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MH1: // global
           R2 = R2;
           call GHC.Conc.Sync.readTVarIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.836174713 UTC

[section ""data" . GHC.Conc.Sync.readTVar1_closure" {
     GHC.Conc.Sync.readTVar1_closure:
         const GHC.Conc.Sync.readTVar1_info;
 },
 GHC.Conc.Sync.readTVar1_entry() //  [R2]
         { info_tbl: [(c9MHf,
                       label: GHC.Conc.Sync.readTVar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MHf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9MHg; else goto c9MHh;
       c9MHg: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.readTVar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9MHh: // global
           I64[Sp - 8] = block_c9MHc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9MHl; else goto c9MHd;
       u9MHl: // global
           call _c9MHc(R1) args: 0, res: 0, upd: 0;
       c9MHd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MHc() //  [R1]
         { info_tbl: [(c9MHc,
                       label: block_c9MHc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MHc: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_readTVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.8413257 UTC

[section ""data" . GHC.Conc.Sync.readTVar_closure" {
     GHC.Conc.Sync.readTVar_closure:
         const GHC.Conc.Sync.readTVar_info;
 },
 GHC.Conc.Sync.readTVar_entry() //  [R2]
         { info_tbl: [(c9MHA,
                       label: GHC.Conc.Sync.readTVar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MHA: // global
           R2 = R2;
           call GHC.Conc.Sync.readTVar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.84468363 UTC

[section ""data" . GHC.Conc.Sync.writeTVar1_closure" {
     GHC.Conc.Sync.writeTVar1_closure:
         const GHC.Conc.Sync.writeTVar1_info;
 },
 GHC.Conc.Sync.writeTVar1_entry() //  [R2, R3]
         { info_tbl: [(c9MHO,
                       label: GHC.Conc.Sync.writeTVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MHO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MHS; else goto c9MHT;
       c9MHS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.writeTVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MHT: // global
           I64[Sp - 16] = block_c9MHL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9MHX; else goto c9MHM;
       u9MHX: // global
           call _c9MHL(R1) args: 0, res: 0, upd: 0;
       c9MHM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MHL() //  [R1]
         { info_tbl: [(c9MHL,
                       label: block_c9MHL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MHL: // global
           _s9LVM::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9MHR_info;
           R2 = _s9LVM::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MHR() //  []
         { info_tbl: [(c9MHR,
                       label: block_c9MHR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MHR: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.852269748 UTC

[section ""data" . GHC.Conc.Sync.writeTVar_closure" {
     GHC.Conc.Sync.writeTVar_closure:
         const GHC.Conc.Sync.writeTVar_info;
 },
 GHC.Conc.Sync.writeTVar_entry() //  [R2, R3]
         { info_tbl: [(c9MIi,
                       label: GHC.Conc.Sync.writeTVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MIi: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.writeTVar1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.856687895 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$ccompare_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c9MIE,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MIE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MIF; else goto c9MIG;
       c9MIF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MIG: // global
           I64[Sp - 16] = block_c9MIt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9MLJ; else goto c9MIu;
       u9MLJ: // global
           call _c9MIt(R1) args: 0, res: 0, upd: 0;
       c9MIu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MIt() //  [R1]
         { info_tbl: [(c9MIt,
                       label: block_c9MIt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MIt: // global
           _s9LVS::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9MIx;
               case 2 : goto c9MIy;
               case 3 : goto c9MIz;
               case 4 : goto c9MIA;
               case 5 : goto c9MIB;
               case 6 : goto c9MIC;
           }
       c9MIC: // global
           I64[Sp + 8] = block_c9MKQ_info;
           R1 = _s9LVS::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MLI; else goto c9MKS;
       u9MLI: // global
           call _c9MKQ(R1) args: 0, res: 0, upd: 0;
       c9MKS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MIB: // global
           I64[Sp + 8] = block_c9MKx_info;
           R1 = _s9LVS::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MLH; else goto c9MKz;
       u9MLH: // global
           call _c9MKx(R1) args: 0, res: 0, upd: 0;
       c9MKz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MIA: // global
           I64[Sp + 8] = block_c9MKa_info;
           R1 = _s9LVS::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MLG; else goto c9MKc;
       u9MLG: // global
           call _c9MKa(R1) args: 0, res: 0, upd: 0;
       c9MKc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MIz: // global
           I64[Sp + 8] = block_c9MJJ_info;
           R1 = _s9LVS::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MLF; else goto c9MJL;
       u9MLF: // global
           call _c9MJJ(R1) args: 0, res: 0, upd: 0;
       c9MJL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MIy: // global
           I64[Sp + 8] = block_c9MJe_info;
           R1 = _s9LVS::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MLE; else goto c9MJg;
       u9MLE: // global
           call _c9MJe(R1) args: 0, res: 0, upd: 0;
       c9MJg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MIx: // global
           I64[Sp + 8] = block_c9MIJ_info;
           R1 = _s9LVS::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MLD; else goto c9MIL;
       u9MLD: // global
           call _c9MIJ(R1) args: 0, res: 0, upd: 0;
       c9MIL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MKQ() //  [R1]
         { info_tbl: [(c9MKQ,
                       label: block_c9MKQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MKQ: // global
           if (R1 & 7 == 6) goto u9MLe; else goto u9MLf;
       u9MLe: // global
           Sp = Sp + 8;
           call _c9ML2() args: 0, res: 0, upd: 0;
       u9MLf: // global
           Sp = Sp + 8;
           call _c9MKY() args: 0, res: 0, upd: 0;
     }
 },
 _c9MKx() //  [R1]
         { info_tbl: [(c9MKx,
                       label: block_c9MKx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MKx: // global
           _c9ML4::P64 = R1 & 7;
           if (_c9ML4::P64 != 5) goto u9MLd; else goto u9MLg;
       u9MLd: // global
           if (_c9ML4::P64 != 6) goto u9MLi; else goto u9MLh;
       u9MLi: // global
           Sp = Sp + 8;
           call _c9MKY() args: 0, res: 0, upd: 0;
       u9MLh: // global
           Sp = Sp + 8;
           call _c9MKN() args: 0, res: 0, upd: 0;
       u9MLg: // global
           Sp = Sp + 8;
           call _c9ML2() args: 0, res: 0, upd: 0;
     }
 },
 _c9MKa() //  [R1]
         { info_tbl: [(c9MKa,
                       label: block_c9MKa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MKa: // global
           _c9ML5::P64 = R1 & 7;
           if (_c9ML5::P64 < 5) goto u9MLb; else goto u9MLc;
       u9MLb: // global
           if (_c9ML5::P64 < 4) goto u9MLk; else goto u9MLj;
       u9MLk: // global
           Sp = Sp + 8;
           call _c9MKY() args: 0, res: 0, upd: 0;
       u9MLj: // global
           Sp = Sp + 8;
           call _c9ML2() args: 0, res: 0, upd: 0;
       u9MLc: // global
           if (_c9ML5::P64 < 6) goto u9MLm; else goto u9MLm;
       u9MLm: // global
           Sp = Sp + 8;
           call _c9MKN() args: 0, res: 0, upd: 0;
     }
 },
 _c9MJJ() //  [R1]
         { info_tbl: [(c9MJJ,
                       label: block_c9MJJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MJJ: // global
           _c9ML6::P64 = R1 & 7;
           if (_c9ML6::P64 < 4) goto u9ML9; else goto u9MLa;
       u9ML9: // global
           if (_c9ML6::P64 < 3) goto u9MLo; else goto u9MLn;
       u9MLo: // global
           Sp = Sp + 8;
           call _c9MKY() args: 0, res: 0, upd: 0;
       u9MLn: // global
           Sp = Sp + 8;
           call _c9ML2() args: 0, res: 0, upd: 0;
       u9MLa: // global
           if (_c9ML6::P64 != 5) goto u9MLq; else goto u9MLq;
       u9MLq: // global
           Sp = Sp + 8;
           call _c9MKN() args: 0, res: 0, upd: 0;
     }
 },
 _c9MJe() //  [R1]
         { info_tbl: [(c9MJe,
                       label: block_c9MJe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MJe: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9MLr;
               case 2 : goto u9MLs;
               case 3, 4, 5, 6 : goto u9MLw;
           }
       u9MLw: // global
           Sp = Sp + 8;
           call _c9MKN() args: 0, res: 0, upd: 0;
       u9MLs: // global
           Sp = Sp + 8;
           call _c9ML2() args: 0, res: 0, upd: 0;
       u9MLr: // global
           Sp = Sp + 8;
           call _c9MKY() args: 0, res: 0, upd: 0;
     }
 },
 _c9MKY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MKY: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9MIJ() //  [R1]
         { info_tbl: [(c9MIJ,
                       label: block_c9MIJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MIJ: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9MLx;
               case 2, 3, 4, 5, 6 : goto u9MLC;
           }
       u9MLC: // global
           Sp = Sp + 8;
           call _c9MKN() args: 0, res: 0, upd: 0;
       u9MLx: // global
           Sp = Sp + 8;
           call _c9ML2() args: 0, res: 0, upd: 0;
     }
 },
 _c9MKN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MKN: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9ML2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ML2: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.87817968 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c<_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c<_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c<_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c<_entry() //  [R2, R3]
         { info_tbl: [(c9MNp,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MNp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MNq; else goto c9MNr;
       c9MNq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MNr: // global
           I64[Sp - 16] = block_c9MNe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9MPZ; else goto c9MNf;
       u9MPZ: // global
           call _c9MNe(R1) args: 0, res: 0, upd: 0;
       c9MNf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MNe() //  [R1]
         { info_tbl: [(c9MNe,
                       label: block_c9MNe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MNe: // global
           _s9LW1::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9MNi;
               case 2 : goto c9MNj;
               case 3 : goto c9MNk;
               case 4 : goto c9MNl;
               case 5 : goto c9MNm;
               case 6 : goto c9MNn;
           }
       c9MNn: // global
           I64[Sp + 8] = block_c9MPl_info;
           R1 = _s9LW1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MPY; else goto c9MPn;
       u9MPY: // global
           call _c9MPl() args: 0, res: 0, upd: 0;
       c9MPn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MNm: // global
           I64[Sp + 8] = block_c9MP6_info;
           R1 = _s9LW1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MPX; else goto c9MP8;
       u9MPX: // global
           call _c9MP6(R1) args: 0, res: 0, upd: 0;
       c9MP8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MNl: // global
           I64[Sp + 8] = block_c9MON_info;
           R1 = _s9LW1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MPW; else goto c9MOP;
       u9MPW: // global
           call _c9MON(R1) args: 0, res: 0, upd: 0;
       c9MOP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MNk: // global
           I64[Sp + 8] = block_c9MOq_info;
           R1 = _s9LW1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MPV; else goto c9MOs;
       u9MPV: // global
           call _c9MOq(R1) args: 0, res: 0, upd: 0;
       c9MOs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MNj: // global
           I64[Sp + 8] = block_c9MNZ_info;
           R1 = _s9LW1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MPU; else goto c9MO1;
       u9MPU: // global
           call _c9MNZ(R1) args: 0, res: 0, upd: 0;
       c9MO1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MNi: // global
           I64[Sp + 8] = block_c9MNu_info;
           R1 = _s9LW1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MPT; else goto c9MNw;
       u9MPT: // global
           call _c9MNu(R1) args: 0, res: 0, upd: 0;
       c9MNw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MPl() //  []
         { info_tbl: [(c9MPl,
                       label: block_c9MPl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MPl: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9MP6() //  [R1]
         { info_tbl: [(c9MP6,
                       label: block_c9MP6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MP6: // global
           if (R1 & 7 == 6) goto u9MPB; else goto u9MPC;
       u9MPB: // global
           Sp = Sp + 8;
           call _c9MPi() args: 0, res: 0, upd: 0;
       u9MPC: // global
           Sp = Sp + 8;
           call _c9MPe() args: 0, res: 0, upd: 0;
     }
 },
 _c9MON() //  [R1]
         { info_tbl: [(c9MON,
                       label: block_c9MON_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MON: // global
           _c9MPt::P64 = R1 & 7;
           if (_c9MPt::P64 != 5) goto u9MPA; else goto u9MPD;
       u9MPA: // global
           if (_c9MPt::P64 != 6) goto u9MPF; else goto u9MPE;
       u9MPF: // global
           Sp = Sp + 8;
           call _c9MPe() args: 0, res: 0, upd: 0;
       u9MPE: // global
           Sp = Sp + 8;
           goto u9MQ8;
       u9MPD: // global
           Sp = Sp + 8;
           goto u9MQ8;
       u9MQ8: // global
           call _c9MPi() args: 0, res: 0, upd: 0;
     }
 },
 _c9MOq() //  [R1]
         { info_tbl: [(c9MOq,
                       label: block_c9MOq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MOq: // global
           _c9MPu::P64 = R1 & 7;
           if (_c9MPu::P64 < 4) goto u9MPG; else goto u9MPz;
       u9MPG: // global
           Sp = Sp + 8;
           call _c9MPe() args: 0, res: 0, upd: 0;
       u9MPz: // global
           if (_c9MPu::P64 != 5) goto u9MPI; else goto u9MPI;
       u9MPI: // global
           Sp = Sp + 8;
           call _c9MPi() args: 0, res: 0, upd: 0;
     }
 },
 _c9MNZ() //  [R1]
         { info_tbl: [(c9MNZ,
                       label: block_c9MNZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MNZ: // global
           _c9MPv::P64 = R1 & 7;
           if (_c9MPv::P64 < 6) goto u9MPx; else goto u9MPJ;
       u9MPx: // global
           if (_c9MPv::P64 < 3) goto u9MPK; else goto u9MPy;
       u9MPK: // global
           Sp = Sp + 8;
           call _c9MPe() args: 0, res: 0, upd: 0;
       u9MPy: // global
           if (_c9MPv::P64 != 4) goto u9MPM; else goto u9MPM;
       u9MPM: // global
           Sp = Sp + 8;
           goto u9MQ4;
       u9MPJ: // global
           Sp = Sp + 8;
           goto u9MQ4;
       u9MQ4: // global
           call _c9MPi() args: 0, res: 0, upd: 0;
     }
 },
 _c9MNu() //  [R1]
         { info_tbl: [(c9MNu,
                       label: block_c9MNu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MNu: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9MPN;
               case 2, 3, 4, 5, 6 : goto u9MPS;
           }
       u9MPS: // global
           Sp = Sp + 8;
           call _c9MPi() args: 0, res: 0, upd: 0;
       u9MPN: // global
           Sp = Sp + 8;
           call _c9MPe() args: 0, res: 0, upd: 0;
     }
 },
 _c9MPi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MPi: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9MPe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MPe: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.898821523 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c<=_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c9MRu,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MRu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MRv; else goto c9MRw;
       c9MRv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MRw: // global
           I64[Sp - 16] = block_c9MRj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9MU4; else goto c9MRk;
       u9MU4: // global
           call _c9MRj(R1) args: 0, res: 0, upd: 0;
       c9MRk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MRj() //  [R1]
         { info_tbl: [(c9MRj,
                       label: block_c9MRj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MRj: // global
           _s9LW9::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9MRn;
               case 2 : goto c9MRo;
               case 3 : goto c9MRp;
               case 4 : goto c9MRq;
               case 5 : goto c9MRr;
               case 6 : goto c9MRs;
           }
       c9MRs: // global
           I64[Sp + 8] = block_c9MTq_info;
           R1 = _s9LW9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MU3; else goto c9MTs;
       u9MU3: // global
           call _c9MTq() args: 0, res: 0, upd: 0;
       c9MTs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MRr: // global
           I64[Sp + 8] = block_c9MTb_info;
           R1 = _s9LW9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MU2; else goto c9MTd;
       u9MU2: // global
           call _c9MTb(R1) args: 0, res: 0, upd: 0;
       c9MTd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MRq: // global
           I64[Sp + 8] = block_c9MSS_info;
           R1 = _s9LW9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MU1; else goto c9MSU;
       u9MU1: // global
           call _c9MSS(R1) args: 0, res: 0, upd: 0;
       c9MSU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MRp: // global
           I64[Sp + 8] = block_c9MSv_info;
           R1 = _s9LW9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MU0; else goto c9MSx;
       u9MU0: // global
           call _c9MSv(R1) args: 0, res: 0, upd: 0;
       c9MSx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MRo: // global
           I64[Sp + 8] = block_c9MS4_info;
           R1 = _s9LW9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MTZ; else goto c9MS6;
       u9MTZ: // global
           call _c9MS4(R1) args: 0, res: 0, upd: 0;
       c9MS6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MRn: // global
           I64[Sp + 8] = block_c9MRz_info;
           R1 = _s9LW9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MTY; else goto c9MRB;
       u9MTY: // global
           call _c9MRz(R1) args: 0, res: 0, upd: 0;
       c9MRB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MTq() //  []
         { info_tbl: [(c9MTq,
                       label: block_c9MTq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MTq: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9MTb() //  [R1]
         { info_tbl: [(c9MTb,
                       label: block_c9MTb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MTb: // global
           if (R1 & 7 == 6) goto u9MTG; else goto u9MTH;
       u9MTG: // global
           Sp = Sp + 8;
           call _c9MTn() args: 0, res: 0, upd: 0;
       u9MTH: // global
           Sp = Sp + 8;
           call _c9MTj() args: 0, res: 0, upd: 0;
     }
 },
 _c9MSS() //  [R1]
         { info_tbl: [(c9MSS,
                       label: block_c9MSS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MSS: // global
           _c9MTy::P64 = R1 & 7;
           if (_c9MTy::P64 != 5) goto u9MTF; else goto u9MTI;
       u9MTF: // global
           if (_c9MTy::P64 != 6) goto u9MTK; else goto u9MTJ;
       u9MTK: // global
           Sp = Sp + 8;
           call _c9MTj() args: 0, res: 0, upd: 0;
       u9MTJ: // global
           Sp = Sp + 8;
           goto u9MUd;
       u9MTI: // global
           Sp = Sp + 8;
           goto u9MUd;
       u9MUd: // global
           call _c9MTn() args: 0, res: 0, upd: 0;
     }
 },
 _c9MSv() //  [R1]
         { info_tbl: [(c9MSv,
                       label: block_c9MSv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MSv: // global
           _c9MTz::P64 = R1 & 7;
           if (_c9MTz::P64 < 4) goto u9MTL; else goto u9MTE;
       u9MTL: // global
           Sp = Sp + 8;
           call _c9MTj() args: 0, res: 0, upd: 0;
       u9MTE: // global
           if (_c9MTz::P64 != 5) goto u9MTN; else goto u9MTN;
       u9MTN: // global
           Sp = Sp + 8;
           call _c9MTn() args: 0, res: 0, upd: 0;
     }
 },
 _c9MS4() //  [R1]
         { info_tbl: [(c9MS4,
                       label: block_c9MS4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MS4: // global
           _c9MTA::P64 = R1 & 7;
           if (_c9MTA::P64 < 6) goto u9MTC; else goto u9MTO;
       u9MTC: // global
           if (_c9MTA::P64 < 3) goto u9MTP; else goto u9MTD;
       u9MTP: // global
           Sp = Sp + 8;
           call _c9MTj() args: 0, res: 0, upd: 0;
       u9MTD: // global
           if (_c9MTA::P64 != 4) goto u9MTR; else goto u9MTR;
       u9MTR: // global
           Sp = Sp + 8;
           goto u9MU9;
       u9MTO: // global
           Sp = Sp + 8;
           goto u9MU9;
       u9MU9: // global
           call _c9MTn() args: 0, res: 0, upd: 0;
     }
 },
 _c9MRz() //  [R1]
         { info_tbl: [(c9MRz,
                       label: block_c9MRz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MRz: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9MTS;
               case 2, 3, 4, 5, 6 : goto u9MTX;
           }
       u9MTX: // global
           Sp = Sp + 8;
           call _c9MTn() args: 0, res: 0, upd: 0;
       u9MTS: // global
           Sp = Sp + 8;
           call _c9MTj() args: 0, res: 0, upd: 0;
     }
 },
 _c9MTn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MTn: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9MTj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MTj: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.91879539 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$cmax_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c9MVz,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MVz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MVA; else goto c9MVB;
       c9MVA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MVB: // global
           I64[Sp - 16] = block_c9MVo_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9MXC; else goto c9MVp;
       u9MXC: // global
           call _c9MVo(R1) args: 0, res: 0, upd: 0;
       c9MVp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MVo() //  [R1]
         { info_tbl: [(c9MVo,
                       label: block_c9MVo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MVo: // global
           _s9LWi::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9MVs;
               case 2 : goto c9MVt;
               case 3 : goto c9MVu;
               case 4 : goto c9MVv;
               case 5 : goto c9MVw;
               case 6 : goto c9MVx;
           }
       c9MVx: // global
           I64[Sp + 8] = block_c9MX3_info;
           R1 = _s9LWi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MXB; else goto c9MX5;
       u9MXB: // global
           call _c9MX3() args: 0, res: 0, upd: 0;
       c9MX5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MVw: // global
           I64[Sp + 8] = block_c9MWO_info;
           R1 = _s9LWi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MXA; else goto c9MWQ;
       u9MXA: // global
           call _c9MWO(R1) args: 0, res: 0, upd: 0;
       c9MWQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MVv: // global
           I64[Sp + 8] = block_c9MWv_info;
           R1 = _s9LWi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MXz; else goto c9MWx;
       u9MXz: // global
           call _c9MWv(R1) args: 0, res: 0, upd: 0;
       c9MWx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MVu: // global
           I64[Sp + 8] = block_c9MW8_info;
           R1 = _s9LWi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MXy; else goto c9MWa;
       u9MXy: // global
           call _c9MW8(R1) args: 0, res: 0, upd: 0;
       c9MWa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MVt: // global
           I64[Sp + 8] = block_c9MVH_info;
           R1 = _s9LWi::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9MXx; else goto c9MVJ;
       u9MXx: // global
           call _c9MVH(R1) args: 0, res: 0, upd: 0;
       c9MVJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MVs: // global
           R1 = _s9LWi::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9MX3() //  []
         { info_tbl: [(c9MX3,
                       label: block_c9MX3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MX3: // global
           R1 = GHC.Conc.Sync.BlockedOnOther_closure+6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9MWO() //  [R1]
         { info_tbl: [(c9MWO,
                       label: block_c9MWO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MWO: // global
           if (R1 & 7 == 6) goto u9MXk; else goto u9MXl;
       u9MXk: // global
           Sp = Sp + 8;
           call _c9MX0() args: 0, res: 0, upd: 0;
       u9MXl: // global
           Sp = Sp + 8;
           call _c9MWW() args: 0, res: 0, upd: 0;
     }
 },
 _c9MWv() //  [R1]
         { info_tbl: [(c9MWv,
                       label: block_c9MWv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MWv: // global
           _c9MXb::P64 = R1 & 7;
           if (_c9MXb::P64 != 5) goto u9MXj; else goto u9MXm;
       u9MXj: // global
           if (_c9MXb::P64 != 6) goto u9MXo; else goto u9MXn;
       u9MXo: // global
           Sp = Sp + 8;
           call _c9MWD() args: 0, res: 0, upd: 0;
       u9MXn: // global
           Sp = Sp + 8;
           call _c9MX0() args: 0, res: 0, upd: 0;
       u9MXm: // global
           Sp = Sp + 8;
           call _c9MWW() args: 0, res: 0, upd: 0;
     }
 },
 _c9MW8() //  [R1]
         { info_tbl: [(c9MW8,
                       label: block_c9MW8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MW8: // global
           _c9MXc::P64 = R1 & 7;
           if (_c9MXc::P64 < 5) goto u9MXh; else goto u9MXi;
       u9MXh: // global
           if (_c9MXc::P64 < 4) goto u9MXq; else goto u9MXp;
       u9MXq: // global
           Sp = Sp + 8;
           call _c9MWg() args: 0, res: 0, upd: 0;
       u9MXp: // global
           Sp = Sp + 8;
           call _c9MWD() args: 0, res: 0, upd: 0;
       u9MXi: // global
           if (_c9MXc::P64 < 6) goto u9MXs; else goto u9MXr;
       u9MXs: // global
           Sp = Sp + 8;
           call _c9MWW() args: 0, res: 0, upd: 0;
       u9MXr: // global
           Sp = Sp + 8;
           call _c9MX0() args: 0, res: 0, upd: 0;
     }
 },
 _c9MVH() //  [R1]
         { info_tbl: [(c9MVH,
                       label: block_c9MVH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MVH: // global
           _c9MXd::P64 = R1 & 7;
           if (_c9MXd::P64 < 5) goto u9MXe; else goto u9MXg;
       u9MXe: // global
           if (_c9MXd::P64 < 4) goto u9MXf; else goto u9MXt;
       u9MXf: // global
           if (_c9MXd::P64 < 3) goto c9MVP; else goto u9MXu;
       c9MVP: // global
           R1 = GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9MXu: // global
           Sp = Sp + 8;
           call _c9MWg() args: 0, res: 0, upd: 0;
       u9MXt: // global
           Sp = Sp + 8;
           call _c9MWD() args: 0, res: 0, upd: 0;
       u9MXg: // global
           if (_c9MXd::P64 < 6) goto u9MXw; else goto u9MXv;
       u9MXw: // global
           Sp = Sp + 8;
           call _c9MWW() args: 0, res: 0, upd: 0;
       u9MXv: // global
           Sp = Sp + 8;
           call _c9MX0() args: 0, res: 0, upd: 0;
     }
 },
 _c9MWg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MWg: // global
           R1 = GHC.Conc.Sync.BlockedOnException_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9MWD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MWD: // global
           R1 = GHC.Conc.Sync.BlockedOnSTM_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9MWW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MWW: // global
           R1 = GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9MX0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MX0: // global
           R1 = GHC.Conc.Sync.BlockedOnOther_closure+6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.939214547 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c>=_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c9MZ4,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MZ4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9MZ5; else goto c9MZ6;
       c9MZ5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9MZ6: // global
           I64[Sp - 16] = block_c9MYT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9N1E; else goto c9MYU;
       u9N1E: // global
           call _c9MYT(R1) args: 0, res: 0, upd: 0;
       c9MYU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9MYT() //  [R1]
         { info_tbl: [(c9MYT,
                       label: block_c9MYT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MYT: // global
           _s9LWr::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9MYX;
               case 2 : goto c9MYY;
               case 3 : goto c9MYZ;
               case 4 : goto c9MZ0;
               case 5 : goto c9MZ1;
               case 6 : goto c9MZ2;
           }
       c9MZ2: // global
           I64[Sp + 8] = block_c9N10_info;
           R1 = _s9LWr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N1D; else goto c9N12;
       u9N1D: // global
           call _c9N10() args: 0, res: 0, upd: 0;
       c9N12: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MZ1: // global
           I64[Sp + 8] = block_c9N0L_info;
           R1 = _s9LWr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N1C; else goto c9N0N;
       u9N1C: // global
           call _c9N0L(R1) args: 0, res: 0, upd: 0;
       c9N0N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MZ0: // global
           I64[Sp + 8] = block_c9N0s_info;
           R1 = _s9LWr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N1B; else goto c9N0u;
       u9N1B: // global
           call _c9N0s(R1) args: 0, res: 0, upd: 0;
       c9N0u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MYZ: // global
           I64[Sp + 8] = block_c9N05_info;
           R1 = _s9LWr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N1A; else goto c9N07;
       u9N1A: // global
           call _c9N05(R1) args: 0, res: 0, upd: 0;
       c9N07: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MYY: // global
           I64[Sp + 8] = block_c9MZE_info;
           R1 = _s9LWr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N1z; else goto c9MZG;
       u9N1z: // global
           call _c9MZE(R1) args: 0, res: 0, upd: 0;
       c9MZG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9MYX: // global
           I64[Sp + 8] = block_c9MZ9_info;
           R1 = _s9LWr::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N1y; else goto c9MZb;
       u9N1y: // global
           call _c9MZ9(R1) args: 0, res: 0, upd: 0;
       c9MZb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9N10() //  []
         { info_tbl: [(c9N10,
                       label: block_c9N10_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N10: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9N0L() //  [R1]
         { info_tbl: [(c9N0L,
                       label: block_c9N0L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N0L: // global
           if (R1 & 7 == 6) goto u9N1g; else goto u9N1h;
       u9N1g: // global
           Sp = Sp + 8;
           call _c9N0X() args: 0, res: 0, upd: 0;
       u9N1h: // global
           Sp = Sp + 8;
           call _c9N0T() args: 0, res: 0, upd: 0;
     }
 },
 _c9N0s() //  [R1]
         { info_tbl: [(c9N0s,
                       label: block_c9N0s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N0s: // global
           _c9N18::P64 = R1 & 7;
           if (_c9N18::P64 != 5) goto u9N1f; else goto u9N1i;
       u9N1f: // global
           if (_c9N18::P64 != 6) goto u9N1k; else goto u9N1j;
       u9N1k: // global
           Sp = Sp + 8;
           call _c9N0T() args: 0, res: 0, upd: 0;
       u9N1j: // global
           Sp = Sp + 8;
           goto u9N1N;
       u9N1i: // global
           Sp = Sp + 8;
           goto u9N1N;
       u9N1N: // global
           call _c9N0X() args: 0, res: 0, upd: 0;
     }
 },
 _c9N05() //  [R1]
         { info_tbl: [(c9N05,
                       label: block_c9N05_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N05: // global
           _c9N19::P64 = R1 & 7;
           if (_c9N19::P64 < 4) goto u9N1l; else goto u9N1e;
       u9N1l: // global
           Sp = Sp + 8;
           call _c9N0T() args: 0, res: 0, upd: 0;
       u9N1e: // global
           if (_c9N19::P64 != 5) goto u9N1n; else goto u9N1n;
       u9N1n: // global
           Sp = Sp + 8;
           call _c9N0X() args: 0, res: 0, upd: 0;
     }
 },
 _c9MZE() //  [R1]
         { info_tbl: [(c9MZE,
                       label: block_c9MZE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MZE: // global
           _c9N1a::P64 = R1 & 7;
           if (_c9N1a::P64 < 6) goto u9N1c; else goto u9N1o;
       u9N1c: // global
           if (_c9N1a::P64 < 3) goto u9N1p; else goto u9N1d;
       u9N1p: // global
           Sp = Sp + 8;
           call _c9N0T() args: 0, res: 0, upd: 0;
       u9N1d: // global
           if (_c9N1a::P64 != 4) goto u9N1r; else goto u9N1r;
       u9N1r: // global
           Sp = Sp + 8;
           goto u9N1J;
       u9N1o: // global
           Sp = Sp + 8;
           goto u9N1J;
       u9N1J: // global
           call _c9N0X() args: 0, res: 0, upd: 0;
     }
 },
 _c9MZ9() //  [R1]
         { info_tbl: [(c9MZ9,
                       label: block_c9MZ9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9MZ9: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9N1s;
               case 2, 3, 4, 5, 6 : goto u9N1x;
           }
       u9N1x: // global
           Sp = Sp + 8;
           call _c9N0X() args: 0, res: 0, upd: 0;
       u9N1s: // global
           Sp = Sp + 8;
           call _c9N0T() args: 0, res: 0, upd: 0;
     }
 },
 _c9N0X() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N0X: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9N0T() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N0T: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.957996381 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$c>_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$c>_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$c>_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$c>_entry() //  [R2, R3]
         { info_tbl: [(c9N2Y,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N2Y: // global
           _s9LWA::P64 = R3;
           R3 = R2;
           R2 = _s9LWA::P64;
           call GHC.Conc.Sync.$fOrdBlockReason_$c<_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.962250105 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure:
         const GHC.Conc.Sync.$fOrdBlockReason_$cmin_info;
 },
 GHC.Conc.Sync.$fOrdBlockReason_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c9N3k,
                       label: GHC.Conc.Sync.$fOrdBlockReason_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N3k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9N3l; else goto c9N3m;
       c9N3l: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9N3m: // global
           I64[Sp - 16] = block_c9N39_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9N58; else goto c9N3a;
       u9N58: // global
           call _c9N39(R1) args: 0, res: 0, upd: 0;
       c9N3a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9N39() //  [R1]
         { info_tbl: [(c9N39,
                       label: block_c9N39_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N39: // global
           _s9LWB::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9N3d;
               case 2 : goto c9N3e;
               case 3 : goto c9N3f;
               case 4 : goto c9N3g;
               case 5 : goto c9N3h;
               case 6 : goto c9N3i;
           }
       c9N3i: // global
           R1 = _s9LWB::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9N3h: // global
           I64[Sp + 8] = block_c9N4F_info;
           R1 = _s9LWB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N57; else goto c9N4H;
       u9N57: // global
           call _c9N4F(R1) args: 0, res: 0, upd: 0;
       c9N4H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9N3g: // global
           I64[Sp + 8] = block_c9N4m_info;
           R1 = _s9LWB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N56; else goto c9N4o;
       u9N56: // global
           call _c9N4m(R1) args: 0, res: 0, upd: 0;
       c9N4o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9N3f: // global
           I64[Sp + 8] = block_c9N3Z_info;
           R1 = _s9LWB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N55; else goto c9N41;
       u9N55: // global
           call _c9N3Z(R1) args: 0, res: 0, upd: 0;
       c9N41: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9N3e: // global
           I64[Sp + 8] = block_c9N3y_info;
           R1 = _s9LWB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N54; else goto c9N3A;
       u9N54: // global
           call _c9N3y(R1) args: 0, res: 0, upd: 0;
       c9N3A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9N3d: // global
           I64[Sp + 8] = block_c9N3p_info;
           R1 = _s9LWB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N53; else goto c9N3r;
       u9N53: // global
           call _c9N3p() args: 0, res: 0, upd: 0;
       c9N3r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9N4F() //  [R1]
         { info_tbl: [(c9N4F,
                       label: block_c9N4F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N4F: // global
           if (R1 & 7 == 6) goto c9N4R; else goto c9N4N;
       c9N4R: // global
           R1 = GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9N4N: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9N4m() //  [R1]
         { info_tbl: [(c9N4m,
                       label: block_c9N4m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N4m: // global
           _c9N4W::P64 = R1 & 7;
           if (_c9N4W::P64 == 5) goto c9N4C; else goto u9N52;
       u9N52: // global
           if (_c9N4W::P64 == 6) goto c9N4C; else goto c9N4u;
       c9N4C: // global
           R1 = GHC.Conc.Sync.BlockedOnSTM_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9N4u: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9N3Z() //  [R1]
         { info_tbl: [(c9N3Z,
                       label: block_c9N3Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N3Z: // global
           _c9N4X::P64 = R1 & 7;
           if (_c9N4X::P64 < 4) goto c9N47; else goto u9N51;
       c9N47: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9N51: // global
           if (_c9N4X::P64 != 5) goto c9N4j; else goto c9N4j;
       c9N4j: // global
           R1 = GHC.Conc.Sync.BlockedOnException_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9N3y() //  [R1]
         { info_tbl: [(c9N3y,
                       label: block_c9N3y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N3y: // global
           _c9N4Y::P64 = R1 & 7;
           if (_c9N4Y::P64 >= 6) goto c9N3W; else goto u9N4Z;
       u9N4Z: // global
           if (_c9N4Y::P64 < 3) goto c9N3G; else goto u9N50;
       c9N3G: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9N50: // global
           if (_c9N4Y::P64 != 4) goto c9N3W; else goto c9N3W;
       c9N3W: // global
           R1 = GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9N3p() //  []
         { info_tbl: [(c9N3p,
                       label: block_c9N3p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N3p: // global
           R1 = GHC.Conc.Sync.BlockedOnMVar_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.978724205 UTC

[section ""data" . GHC.Conc.Sync.$fOrdBlockReason_closure" {
     GHC.Conc.Sync.$fOrdBlockReason_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Conc.Sync.$fEqBlockReason_closure+1;
         const GHC.Conc.Sync.$fOrdBlockReason_$ccompare_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c<_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c<=_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c>_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$c>=_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$cmax_closure+2;
         const GHC.Conc.Sync.$fOrdBlockReason_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.981724902 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c9N6l,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N6l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9N6m; else goto c9N6n;
       c9N6m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9N6n: // global
           I64[Sp - 16] = block_c9N6c_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9N85; else goto c9N6d;
       u9N85: // global
           call _c9N6c(R1) args: 0, res: 0, upd: 0;
       c9N6d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9N6c() //  [R1]
         { info_tbl: [(c9N6c,
                       label: block_c9N6c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N6c: // global
           _s9LWK::P64 = P64[Sp + 8];
           _c9N6k::P64 = R1 & 7;
           if (_c9N6k::P64 < 3) goto u9N7K; else goto u9N7L;
       u9N7K: // global
           if (_c9N6k::P64 < 2) goto c9N6g; else goto c9N6h;
       c9N6g: // global
           I64[Sp + 8] = block_c9N6q_info;
           R1 = _s9LWK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N81; else goto c9N6s;
       u9N81: // global
           call _c9N6q(R1) args: 0, res: 0, upd: 0;
       c9N6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9N6h: // global
           I64[Sp + 8] = block_c9N6N_info;
           R1 = _s9LWK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N82; else goto c9N6P;
       u9N82: // global
           call _c9N6N(R1) args: 0, res: 0, upd: 0;
       c9N6P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9N7L: // global
           if (_c9N6k::P64 < 4) goto c9N6i; else goto c9N6j;
       c9N6i: // global
           I64[Sp] = block_c9N7a_info;
           _s9LWQ::P64 = P64[R1 + 5];
           R1 = _s9LWK::P64;
           P64[Sp + 8] = _s9LWQ::P64;
           if (R1 & 7 != 0) goto u9N83; else goto c9N7c;
       u9N83: // global
           call _c9N7a(R1) args: 0, res: 0, upd: 0;
       c9N7c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9N6j: // global
           I64[Sp + 8] = block_c9N7t_info;
           R1 = _s9LWK::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9N84; else goto c9N7v;
       u9N84: // global
           call _c9N7t(R1) args: 0, res: 0, upd: 0;
       c9N7v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9N6q() //  [R1]
         { info_tbl: [(c9N6q,
                       label: block_c9N6q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N6q: // global
           _c9N7J::P64 = R1 & 7;
           if (_c9N7J::P64 < 2) goto u9N7Q; else goto u9N7M;
       u9N7Q: // global
           Sp = Sp + 8;
           call _c9N7F() args: 0, res: 0, upd: 0;
       u9N7M: // global
           if (_c9N7J::P64 != 3) goto u9N7S; else goto u9N7S;
       u9N7S: // global
           Sp = Sp + 8;
           call _c9N7q() args: 0, res: 0, upd: 0;
     }
 },
 _c9N6N() //  [R1]
         { info_tbl: [(c9N6N,
                       label: block_c9N6N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N6N: // global
           _c9N7I::P64 = R1 & 7;
           if (_c9N7I::P64 < 3) goto u9N7N; else goto u9N7O;
       u9N7N: // global
           if (_c9N7I::P64 < 2) goto u9N7U; else goto u9N7T;
       u9N7U: // global
           Sp = Sp + 8;
           call _c9N7B() args: 0, res: 0, upd: 0;
       u9N7T: // global
           Sp = Sp + 8;
           call _c9N7F() args: 0, res: 0, upd: 0;
       u9N7O: // global
           if (_c9N7I::P64 < 4) goto u9N7W; else goto u9N7W;
       u9N7W: // global
           Sp = Sp + 8;
           call _c9N7q() args: 0, res: 0, upd: 0;
     }
 },
 _c9N7a() //  [R1]
         { info_tbl: [(c9N7a,
                       label: block_c9N7a_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N7a: // global
           _c9N7H::P64 = R1 & 7;
           if (_c9N7H::P64 == 3) goto c9N7m; else goto u9N7P;
       c9N7m: // global
           R3 = P64[R1 + 5];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$fOrdBlockReason_$ccompare_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
       u9N7P: // global
           if (_c9N7H::P64 != 4) goto u9N7Y; else goto u9N7X;
       u9N7Y: // global
           Sp = Sp + 16;
           call _c9N7B() args: 0, res: 0, upd: 0;
       u9N7X: // global
           Sp = Sp + 16;
           call _c9N7q() args: 0, res: 0, upd: 0;
     }
 },
 _c9N7q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N7q: // global
           R1 = GHC.Types.LT_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9N7t() //  [R1]
         { info_tbl: [(c9N7t,
                       label: block_c9N7t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N7t: // global
           if (R1 & 7 == 4) goto u9N7Z; else goto u9N80;
       u9N7Z: // global
           Sp = Sp + 8;
           call _c9N7F() args: 0, res: 0, upd: 0;
       u9N80: // global
           Sp = Sp + 8;
           call _c9N7B() args: 0, res: 0, upd: 0;
     }
 },
 _c9N7F() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N7F: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9N7B() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N7B: // global
           R1 = GHC.Types.GT_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:52.99967741 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c<_entry() //  [R2, R3]
         { info_tbl: [(c9N9e,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N9e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9N9f; else goto c9N9g;
       c9N9f: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9N9g: // global
           I64[Sp - 16] = block_c9N95_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Ndl; else goto c9N96;
       u9Ndl: // global
           call _c9N95(R1) args: 0, res: 0, upd: 0;
       c9N96: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9N95() //  [R1]
         { info_tbl: [(c9N95,
                       label: block_c9N95_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N95: // global
           _s9LWV::P64 = P64[Sp + 8];
           _c9N9d::P64 = R1 & 7;
           if (_c9N9d::P64 < 3) goto u9NcI; else goto u9NcJ;
       u9NcI: // global
           if (_c9N9d::P64 < 2) goto c9N99; else goto c9N9a;
       c9N99: // global
           I64[Sp + 8] = block_c9N9j_info;
           R1 = _s9LWV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ndh; else goto c9N9l;
       u9Ndh: // global
           call _c9N9j(R1) args: 0, res: 0, upd: 0;
       c9N9l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9N9a: // global
           I64[Sp + 8] = block_c9N9G_info;
           R1 = _s9LWV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ndi; else goto c9N9I;
       u9Ndi: // global
           call _c9N9G(R1) args: 0, res: 0, upd: 0;
       c9N9I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9NcJ: // global
           if (_c9N9d::P64 < 4) goto c9N9b; else goto c9N9c;
       c9N9b: // global
           I64[Sp] = block_c9N9Z_info;
           _s9LX1::P64 = P64[R1 + 5];
           R1 = _s9LWV::P64;
           P64[Sp + 8] = _s9LX1::P64;
           if (R1 & 7 != 0) goto u9Ndj; else goto c9Na1;
       u9Ndj: // global
           call _c9N9Z(R1) args: 0, res: 0, upd: 0;
       c9Na1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9N9c: // global
           I64[Sp + 8] = block_c9Ncs_info;
           R1 = _s9LWV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ndk; else goto c9Ncu;
       u9Ndk: // global
           call _c9Ncs() args: 0, res: 0, upd: 0;
       c9Ncu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9N9j() //  [R1]
         { info_tbl: [(c9N9j,
                       label: block_c9N9j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N9j: // global
           _c9NcH::P64 = R1 & 7;
           if (_c9NcH::P64 < 2) goto u9NcR; else goto u9NcK;
       u9NcR: // global
           Sp = Sp + 8;
           call _c9Nc7() args: 0, res: 0, upd: 0;
       u9NcK: // global
           if (_c9NcH::P64 != 3) goto u9NcT; else goto u9NcT;
       u9NcT: // global
           Sp = Sp + 8;
           call _c9Ncp() args: 0, res: 0, upd: 0;
     }
 },
 _c9N9G() //  [R1]
         { info_tbl: [(c9N9G,
                       label: block_c9N9G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N9G: // global
           _c9NcG::P64 = R1 & 7;
           if (_c9NcG::P64 != 3) goto u9NcL; else goto u9NcU;
       u9NcL: // global
           if (_c9NcG::P64 != 4) goto u9NcW; else goto u9NcV;
       u9NcW: // global
           Sp = Sp + 8;
           call _c9Nc7() args: 0, res: 0, upd: 0;
       u9NcV: // global
           Sp = Sp + 8;
           goto u9Ndp;
       u9NcU: // global
           Sp = Sp + 8;
           goto u9Ndp;
       u9Ndp: // global
           call _c9Ncp() args: 0, res: 0, upd: 0;
     }
 },
 _c9N9Z() //  [R1]
         { info_tbl: [(c9N9Z,
                       label: block_c9N9Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9N9Z: // global
           _c9Ncz::P64 = R1 & 7;
           if (_c9Ncz::P64 == 3) goto c9Nac; else goto u9NcM;
       c9Nac: // global
           I64[Sp] = block_c9Naa_info;
           _s9LX3::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9LX3::P64;
           if (R1 & 7 != 0) goto u9Ndr; else goto c9Nad;
       u9Ndr: // global
           call _c9Naa(R1) args: 0, res: 0, upd: 0;
       c9Nad: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9NcM: // global
           if (_c9Ncz::P64 != 4) goto u9NcY; else goto u9NcX;
       u9NcY: // global
           Sp = Sp + 16;
           call _c9Nc7() args: 0, res: 0, upd: 0;
       u9NcX: // global
           Sp = Sp + 16;
           call _c9Ncp() args: 0, res: 0, upd: 0;
     }
 },
 _c9Naa() //  [R1]
         { info_tbl: [(c9Naa,
                       label: block_c9Naa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Naa: // global
           _s9LX3::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Nak;
               case 2 : goto c9NaQ;
               case 3 : goto c9Nbi;
               case 4 : goto c9NbG;
               case 5 : goto c9Nc0;
               case 6 : goto c9Ncg;
           }
       c9Ncg: // global
           I64[Sp + 8] = block_c9Nce_info;
           R1 = _s9LX3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ndz; else goto c9Nch;
       u9Ndz: // global
           call _c9Nce() args: 0, res: 0, upd: 0;
       c9Nch: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nc0: // global
           I64[Sp + 8] = block_c9NbY_info;
           R1 = _s9LX3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ndy; else goto c9Nc1;
       u9Ndy: // global
           call _c9NbY(R1) args: 0, res: 0, upd: 0;
       c9Nc1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NbG: // global
           I64[Sp + 8] = block_c9NbE_info;
           R1 = _s9LX3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ndx; else goto c9NbH;
       u9Ndx: // global
           call _c9NbE(R1) args: 0, res: 0, upd: 0;
       c9NbH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nbi: // global
           I64[Sp + 8] = block_c9Nbg_info;
           R1 = _s9LX3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ndw; else goto c9Nbj;
       u9Ndw: // global
           call _c9Nbg(R1) args: 0, res: 0, upd: 0;
       c9Nbj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NaQ: // global
           I64[Sp + 8] = block_c9NaO_info;
           R1 = _s9LX3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ndv; else goto c9NaR;
       u9Ndv: // global
           call _c9NaO(R1) args: 0, res: 0, upd: 0;
       c9NaR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nak: // global
           I64[Sp + 8] = block_c9Nah_info;
           R1 = _s9LX3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Ndu; else goto c9Nal;
       u9Ndu: // global
           call _c9Nah(R1) args: 0, res: 0, upd: 0;
       c9Nal: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Nce() //  []
         { info_tbl: [(c9Nce,
                       label: block_c9Nce_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nce: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9NbY() //  [R1]
         { info_tbl: [(c9NbY,
                       label: block_c9NbY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NbY: // global
           if (R1 & 7 == 6) goto u9NcZ; else goto u9Nd0;
       u9NcZ: // global
           Sp = Sp + 8;
           call _c9Ncp() args: 0, res: 0, upd: 0;
       u9Nd0: // global
           Sp = Sp + 8;
           call _c9Nc7() args: 0, res: 0, upd: 0;
     }
 },
 _c9NbE() //  [R1]
         { info_tbl: [(c9NbE,
                       label: block_c9NbE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NbE: // global
           _c9NcC::P64 = R1 & 7;
           if (_c9NcC::P64 != 5) goto u9NcQ; else goto u9Nd1;
       u9NcQ: // global
           if (_c9NcC::P64 != 6) goto u9Nd3; else goto u9Nd2;
       u9Nd3: // global
           Sp = Sp + 8;
           call _c9Nc7() args: 0, res: 0, upd: 0;
       u9Nd2: // global
           Sp = Sp + 8;
           goto u9NdI;
       u9Nd1: // global
           Sp = Sp + 8;
           goto u9NdI;
       u9NdI: // global
           call _c9Ncp() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nbg() //  [R1]
         { info_tbl: [(c9Nbg,
                       label: block_c9Nbg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nbg: // global
           _c9NcD::P64 = R1 & 7;
           if (_c9NcD::P64 < 4) goto u9Nd4; else goto u9NcP;
       u9Nd4: // global
           Sp = Sp + 8;
           call _c9Nc7() args: 0, res: 0, upd: 0;
       u9NcP: // global
           if (_c9NcD::P64 != 5) goto u9Nd6; else goto u9Nd6;
       u9Nd6: // global
           Sp = Sp + 8;
           call _c9Ncp() args: 0, res: 0, upd: 0;
     }
 },
 _c9NaO() //  [R1]
         { info_tbl: [(c9NaO,
                       label: block_c9NaO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NaO: // global
           _c9NcE::P64 = R1 & 7;
           if (_c9NcE::P64 < 6) goto u9NcN; else goto u9Nd7;
       u9NcN: // global
           if (_c9NcE::P64 < 3) goto u9Nd8; else goto u9NcO;
       u9Nd8: // global
           Sp = Sp + 8;
           call _c9Nc7() args: 0, res: 0, upd: 0;
       u9NcO: // global
           if (_c9NcE::P64 != 4) goto u9Nda; else goto u9Nda;
       u9Nda: // global
           Sp = Sp + 8;
           goto u9NdE;
       u9Nd7: // global
           Sp = Sp + 8;
           goto u9NdE;
       u9NdE: // global
           call _c9Ncp() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nah() //  [R1]
         { info_tbl: [(c9Nah,
                       label: block_c9Nah_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nah: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9Ndb;
               case 2, 3, 4, 5, 6 : goto u9Ndg;
           }
       u9Ndg: // global
           Sp = Sp + 8;
           call _c9Ncp() args: 0, res: 0, upd: 0;
       u9Ndb: // global
           Sp = Sp + 8;
           call _c9Nc7() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nc7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nc7: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Ncp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ncp: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Ncs() //  []
         { info_tbl: [(c9Ncs,
                       label: block_c9Ncs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ncs: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.030271196 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>=_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c9Nfx,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nfx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Nfy; else goto c9Nfz;
       c9Nfy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Nfz: // global
           I64[Sp - 16] = block_c9Nfo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9NjE; else goto c9Nfp;
       u9NjE: // global
           call _c9Nfo(R1) args: 0, res: 0, upd: 0;
       c9Nfp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Nfo() //  [R1]
         { info_tbl: [(c9Nfo,
                       label: block_c9Nfo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nfo: // global
           _s9LXd::P64 = P64[Sp + 8];
           _c9Nfw::P64 = R1 & 7;
           if (_c9Nfw::P64 < 3) goto u9Nj1; else goto u9Nj2;
       u9Nj1: // global
           if (_c9Nfw::P64 < 2) goto c9Nfs; else goto c9Nft;
       c9Nfs: // global
           I64[Sp + 8] = block_c9NfC_info;
           R1 = _s9LXd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NjA; else goto c9NfE;
       u9NjA: // global
           call _c9NfC(R1) args: 0, res: 0, upd: 0;
       c9NfE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nft: // global
           I64[Sp + 8] = block_c9NfZ_info;
           R1 = _s9LXd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NjB; else goto c9Ng1;
       u9NjB: // global
           call _c9NfZ(R1) args: 0, res: 0, upd: 0;
       c9Ng1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Nj2: // global
           if (_c9Nfw::P64 < 4) goto c9Nfu; else goto c9Nfv;
       c9Nfu: // global
           I64[Sp] = block_c9Ngi_info;
           _s9LXj::P64 = P64[R1 + 5];
           R1 = _s9LXd::P64;
           P64[Sp + 8] = _s9LXj::P64;
           if (R1 & 7 != 0) goto u9NjC; else goto c9Ngk;
       u9NjC: // global
           call _c9Ngi(R1) args: 0, res: 0, upd: 0;
       c9Ngk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nfv: // global
           I64[Sp + 8] = block_c9NiL_info;
           R1 = _s9LXd::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NjD; else goto c9NiN;
       u9NjD: // global
           call _c9NiL() args: 0, res: 0, upd: 0;
       c9NiN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NfC() //  [R1]
         { info_tbl: [(c9NfC,
                       label: block_c9NfC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NfC: // global
           _c9Nj0::P64 = R1 & 7;
           if (_c9Nj0::P64 < 2) goto u9Nja; else goto u9Nj3;
       u9Nja: // global
           Sp = Sp + 8;
           call _c9Niq() args: 0, res: 0, upd: 0;
       u9Nj3: // global
           if (_c9Nj0::P64 != 3) goto u9Njc; else goto u9Njc;
       u9Njc: // global
           Sp = Sp + 8;
           call _c9NiI() args: 0, res: 0, upd: 0;
     }
 },
 _c9NfZ() //  [R1]
         { info_tbl: [(c9NfZ,
                       label: block_c9NfZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NfZ: // global
           _c9NiZ::P64 = R1 & 7;
           if (_c9NiZ::P64 != 3) goto u9Nj4; else goto u9Njd;
       u9Nj4: // global
           if (_c9NiZ::P64 != 4) goto u9Njf; else goto u9Nje;
       u9Njf: // global
           Sp = Sp + 8;
           call _c9Niq() args: 0, res: 0, upd: 0;
       u9Nje: // global
           Sp = Sp + 8;
           goto u9NjI;
       u9Njd: // global
           Sp = Sp + 8;
           goto u9NjI;
       u9NjI: // global
           call _c9NiI() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ngi() //  [R1]
         { info_tbl: [(c9Ngi,
                       label: block_c9Ngi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ngi: // global
           _c9NiS::P64 = R1 & 7;
           if (_c9NiS::P64 == 3) goto c9Ngv; else goto u9Nj5;
       c9Ngv: // global
           I64[Sp] = block_c9Ngt_info;
           _s9LXl::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9LXl::P64;
           if (R1 & 7 != 0) goto u9NjK; else goto c9Ngw;
       u9NjK: // global
           call _c9Ngt(R1) args: 0, res: 0, upd: 0;
       c9Ngw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Nj5: // global
           if (_c9NiS::P64 != 4) goto u9Njh; else goto u9Njg;
       u9Njh: // global
           Sp = Sp + 16;
           call _c9Niq() args: 0, res: 0, upd: 0;
       u9Njg: // global
           Sp = Sp + 16;
           call _c9NiI() args: 0, res: 0, upd: 0;
     }
 },
 _c9Ngt() //  [R1]
         { info_tbl: [(c9Ngt,
                       label: block_c9Ngt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ngt: // global
           _s9LXl::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9NgD;
               case 2 : goto c9Nh9;
               case 3 : goto c9NhB;
               case 4 : goto c9NhZ;
               case 5 : goto c9Nij;
               case 6 : goto c9Niz;
           }
       c9Niz: // global
           I64[Sp + 8] = block_c9Nix_info;
           R1 = _s9LXl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NjS; else goto c9NiA;
       u9NjS: // global
           call _c9Nix() args: 0, res: 0, upd: 0;
       c9NiA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nij: // global
           I64[Sp + 8] = block_c9Nih_info;
           R1 = _s9LXl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NjR; else goto c9Nik;
       u9NjR: // global
           call _c9Nih(R1) args: 0, res: 0, upd: 0;
       c9Nik: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NhZ: // global
           I64[Sp + 8] = block_c9NhX_info;
           R1 = _s9LXl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NjQ; else goto c9Ni0;
       u9NjQ: // global
           call _c9NhX(R1) args: 0, res: 0, upd: 0;
       c9Ni0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NhB: // global
           I64[Sp + 8] = block_c9Nhz_info;
           R1 = _s9LXl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NjP; else goto c9NhC;
       u9NjP: // global
           call _c9Nhz(R1) args: 0, res: 0, upd: 0;
       c9NhC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nh9: // global
           I64[Sp + 8] = block_c9Nh7_info;
           R1 = _s9LXl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NjO; else goto c9Nha;
       u9NjO: // global
           call _c9Nh7(R1) args: 0, res: 0, upd: 0;
       c9Nha: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NgD: // global
           I64[Sp + 8] = block_c9NgA_info;
           R1 = _s9LXl::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NjN; else goto c9NgE;
       u9NjN: // global
           call _c9NgA(R1) args: 0, res: 0, upd: 0;
       c9NgE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Nix() //  []
         { info_tbl: [(c9Nix,
                       label: block_c9Nix_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nix: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Nih() //  [R1]
         { info_tbl: [(c9Nih,
                       label: block_c9Nih_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nih: // global
           if (R1 & 7 == 6) goto u9Nji; else goto u9Njj;
       u9Nji: // global
           Sp = Sp + 8;
           call _c9NiI() args: 0, res: 0, upd: 0;
       u9Njj: // global
           Sp = Sp + 8;
           call _c9Niq() args: 0, res: 0, upd: 0;
     }
 },
 _c9NhX() //  [R1]
         { info_tbl: [(c9NhX,
                       label: block_c9NhX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NhX: // global
           _c9NiV::P64 = R1 & 7;
           if (_c9NiV::P64 != 5) goto u9Nj9; else goto u9Njk;
       u9Nj9: // global
           if (_c9NiV::P64 != 6) goto u9Njm; else goto u9Njl;
       u9Njm: // global
           Sp = Sp + 8;
           call _c9Niq() args: 0, res: 0, upd: 0;
       u9Njl: // global
           Sp = Sp + 8;
           goto u9Nk1;
       u9Njk: // global
           Sp = Sp + 8;
           goto u9Nk1;
       u9Nk1: // global
           call _c9NiI() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nhz() //  [R1]
         { info_tbl: [(c9Nhz,
                       label: block_c9Nhz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nhz: // global
           _c9NiW::P64 = R1 & 7;
           if (_c9NiW::P64 < 4) goto u9Njn; else goto u9Nj8;
       u9Njn: // global
           Sp = Sp + 8;
           call _c9Niq() args: 0, res: 0, upd: 0;
       u9Nj8: // global
           if (_c9NiW::P64 != 5) goto u9Njp; else goto u9Njp;
       u9Njp: // global
           Sp = Sp + 8;
           call _c9NiI() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nh7() //  [R1]
         { info_tbl: [(c9Nh7,
                       label: block_c9Nh7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nh7: // global
           _c9NiX::P64 = R1 & 7;
           if (_c9NiX::P64 < 6) goto u9Nj6; else goto u9Njq;
       u9Nj6: // global
           if (_c9NiX::P64 < 3) goto u9Njr; else goto u9Nj7;
       u9Njr: // global
           Sp = Sp + 8;
           call _c9Niq() args: 0, res: 0, upd: 0;
       u9Nj7: // global
           if (_c9NiX::P64 != 4) goto u9Njt; else goto u9Njt;
       u9Njt: // global
           Sp = Sp + 8;
           goto u9NjX;
       u9Njq: // global
           Sp = Sp + 8;
           goto u9NjX;
       u9NjX: // global
           call _c9NiI() args: 0, res: 0, upd: 0;
     }
 },
 _c9NgA() //  [R1]
         { info_tbl: [(c9NgA,
                       label: block_c9NgA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NgA: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9Nju;
               case 2, 3, 4, 5, 6 : goto u9Njz;
           }
       u9Njz: // global
           Sp = Sp + 8;
           call _c9NiI() args: 0, res: 0, upd: 0;
       u9Nju: // global
           Sp = Sp + 8;
           call _c9Niq() args: 0, res: 0, upd: 0;
     }
 },
 _c9Niq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Niq: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9NiI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NiI: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9NiL() //  []
         { info_tbl: [(c9NiL,
                       label: block_c9NiL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NiL: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.061593219 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c>_entry() //  [R2, R3]
         { info_tbl: [(c9NlQ,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NlQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9NlR; else goto c9NlS;
       c9NlR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9NlS: // global
           I64[Sp - 16] = block_c9NlH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9NpR; else goto c9NlI;
       u9NpR: // global
           call _c9NlH(R1) args: 0, res: 0, upd: 0;
       c9NlI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NlH() //  [R1]
         { info_tbl: [(c9NlH,
                       label: block_c9NlH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NlH: // global
           _s9LXv::P64 = P64[Sp + 8];
           _c9NlP::P64 = R1 & 7;
           if (_c9NlP::P64 < 3) goto u9Npg; else goto u9Nph;
       u9Npg: // global
           if (_c9NlP::P64 < 2) goto c9NlL; else goto c9NlM;
       c9NlL: // global
           I64[Sp + 8] = block_c9NlV_info;
           R1 = _s9LXv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NpN; else goto c9NlX;
       u9NpN: // global
           call _c9NlV() args: 0, res: 0, upd: 0;
       c9NlX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NlM: // global
           I64[Sp + 8] = block_c9Nm4_info;
           R1 = _s9LXv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NpO; else goto c9Nm6;
       u9NpO: // global
           call _c9Nm4(R1) args: 0, res: 0, upd: 0;
       c9Nm6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Nph: // global
           if (_c9NlP::P64 < 4) goto c9NlN; else goto c9NlO;
       c9NlN: // global
           I64[Sp] = block_c9Nmr_info;
           _s9LXA::P64 = P64[R1 + 5];
           R1 = _s9LXv::P64;
           P64[Sp + 8] = _s9LXA::P64;
           if (R1 & 7 != 0) goto u9NpP; else goto c9Nmt;
       u9NpP: // global
           call _c9Nmr(R1) args: 0, res: 0, upd: 0;
       c9Nmt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NlO: // global
           I64[Sp + 8] = block_c9NoU_info;
           R1 = _s9LXv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NpQ; else goto c9NoW;
       u9NpQ: // global
           call _c9NoU(R1) args: 0, res: 0, upd: 0;
       c9NoW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NlV() //  []
         { info_tbl: [(c9NlV,
                       label: block_c9NlV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NlV: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Nm4() //  [R1]
         { info_tbl: [(c9Nm4,
                       label: block_c9Nm4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nm4: // global
           _c9Npf::P64 = R1 & 7;
           if (_c9Npf::P64 < 2) goto u9Npo; else goto u9Npi;
       u9Npo: // global
           Sp = Sp + 8;
           call _c9Np2() args: 0, res: 0, upd: 0;
       u9Npi: // global
           if (_c9Npf::P64 != 3) goto u9Npq; else goto u9Npq;
       u9Npq: // global
           Sp = Sp + 8;
           call _c9Np6() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nmr() //  [R1]
         { info_tbl: [(c9Nmr,
                       label: block_c9Nmr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nmr: // global
           _c9Np8::P64 = R1 & 7;
           if (_c9Np8::P64 == 3) goto c9NmE; else goto u9Npj;
       c9NmE: // global
           I64[Sp] = block_c9NmC_info;
           _s9LXC::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9LXC::P64;
           if (R1 & 7 != 0) goto u9NpU; else goto c9NmF;
       u9NpU: // global
           call _c9NmC(R1) args: 0, res: 0, upd: 0;
       c9NmF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Npj: // global
           if (_c9Np8::P64 != 4) goto u9Nps; else goto u9Npr;
       u9Nps: // global
           Sp = Sp + 16;
           call _c9Np2() args: 0, res: 0, upd: 0;
       u9Npr: // global
           Sp = Sp + 16;
           call _c9Np6() args: 0, res: 0, upd: 0;
     }
 },
 _c9NmC() //  [R1]
         { info_tbl: [(c9NmC,
                       label: block_c9NmC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NmC: // global
           _s9LXC::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9NmM;
               case 2 : goto c9NmW;
               case 3 : goto c9Nns;
               case 4 : goto c9NnU;
               case 5 : goto c9Noi;
               case 6 : goto c9NoC;
           }
       c9NoC: // global
           I64[Sp + 8] = block_c9NoA_info;
           R1 = _s9LXC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Nq2; else goto c9NoD;
       u9Nq2: // global
           call _c9NoA(R1) args: 0, res: 0, upd: 0;
       c9NoD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Noi: // global
           I64[Sp + 8] = block_c9Nog_info;
           R1 = _s9LXC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Nq1; else goto c9Noj;
       u9Nq1: // global
           call _c9Nog(R1) args: 0, res: 0, upd: 0;
       c9Noj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NnU: // global
           I64[Sp + 8] = block_c9NnS_info;
           R1 = _s9LXC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Nq0; else goto c9NnV;
       u9Nq0: // global
           call _c9NnS(R1) args: 0, res: 0, upd: 0;
       c9NnV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nns: // global
           I64[Sp + 8] = block_c9Nnq_info;
           R1 = _s9LXC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NpZ; else goto c9Nnt;
       u9NpZ: // global
           call _c9Nnq(R1) args: 0, res: 0, upd: 0;
       c9Nnt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NmW: // global
           I64[Sp + 8] = block_c9NmU_info;
           R1 = _s9LXC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NpY; else goto c9NmX;
       u9NpY: // global
           call _c9NmU(R1) args: 0, res: 0, upd: 0;
       c9NmX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NmM: // global
           I64[Sp + 8] = block_c9NmJ_info;
           R1 = _s9LXC::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NpX; else goto c9NmN;
       u9NpX: // global
           call _c9NmJ() args: 0, res: 0, upd: 0;
       c9NmN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NoA() //  [R1]
         { info_tbl: [(c9NoA,
                       label: block_c9NoA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NoA: // global
           if (R1 & 7 == 6) goto u9Npt; else goto u9Npu;
       u9Npt: // global
           Sp = Sp + 8;
           call _c9Np6() args: 0, res: 0, upd: 0;
       u9Npu: // global
           Sp = Sp + 8;
           call _c9Np2() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nog() //  [R1]
         { info_tbl: [(c9Nog,
                       label: block_c9Nog_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nog: // global
           _c9Npb::P64 = R1 & 7;
           if (_c9Npb::P64 != 5) goto u9Npn; else goto u9Npv;
       u9Npn: // global
           if (_c9Npb::P64 != 6) goto u9Npx; else goto u9Npw;
       u9Npx: // global
           Sp = Sp + 8;
           call _c9Np2() args: 0, res: 0, upd: 0;
       u9Npw: // global
           Sp = Sp + 8;
           goto u9Nqb;
       u9Npv: // global
           Sp = Sp + 8;
           goto u9Nqb;
       u9Nqb: // global
           call _c9Np6() args: 0, res: 0, upd: 0;
     }
 },
 _c9NnS() //  [R1]
         { info_tbl: [(c9NnS,
                       label: block_c9NnS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NnS: // global
           _c9Npc::P64 = R1 & 7;
           if (_c9Npc::P64 < 4) goto u9Npy; else goto u9Npm;
       u9Npy: // global
           Sp = Sp + 8;
           call _c9Np2() args: 0, res: 0, upd: 0;
       u9Npm: // global
           if (_c9Npc::P64 != 5) goto u9NpA; else goto u9NpA;
       u9NpA: // global
           Sp = Sp + 8;
           call _c9Np6() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nnq() //  [R1]
         { info_tbl: [(c9Nnq,
                       label: block_c9Nnq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nnq: // global
           _c9Npd::P64 = R1 & 7;
           if (_c9Npd::P64 < 6) goto u9Npk; else goto u9NpB;
       u9Npk: // global
           if (_c9Npd::P64 < 3) goto u9NpC; else goto u9Npl;
       u9NpC: // global
           Sp = Sp + 8;
           call _c9Np2() args: 0, res: 0, upd: 0;
       u9Npl: // global
           if (_c9Npd::P64 != 4) goto u9NpE; else goto u9NpE;
       u9NpE: // global
           Sp = Sp + 8;
           goto u9Nq7;
       u9NpB: // global
           Sp = Sp + 8;
           goto u9Nq7;
       u9Nq7: // global
           call _c9Np6() args: 0, res: 0, upd: 0;
     }
 },
 _c9NmU() //  [R1]
         { info_tbl: [(c9NmU,
                       label: block_c9NmU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NmU: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9NpF;
               case 2, 3, 4, 5, 6 : goto u9NpK;
           }
       u9NpK: // global
           Sp = Sp + 8;
           call _c9Np6() args: 0, res: 0, upd: 0;
       u9NpF: // global
           Sp = Sp + 8;
           call _c9Np2() args: 0, res: 0, upd: 0;
     }
 },
 _c9NmJ() //  []
         { info_tbl: [(c9NmJ,
                       label: block_c9NmJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NmJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9NoU() //  [R1]
         { info_tbl: [(c9NoU,
                       label: block_c9NoU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NoU: // global
           if (R1 & 7 == 4) goto u9NpL; else goto u9NpM;
       u9NpL: // global
           Sp = Sp + 8;
           call _c9Np6() args: 0, res: 0, upd: 0;
       u9NpM: // global
           Sp = Sp + 8;
           call _c9Np2() args: 0, res: 0, upd: 0;
     }
 },
 _c9Np6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Np6: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Np2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Np2: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.091337434 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<=_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c9Ns3,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ns3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Ns4; else goto c9Ns5;
       c9Ns4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Ns5: // global
           I64[Sp - 16] = block_c9NrU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Nw4; else goto c9NrV;
       u9Nw4: // global
           call _c9NrU(R1) args: 0, res: 0, upd: 0;
       c9NrV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NrU() //  [R1]
         { info_tbl: [(c9NrU,
                       label: block_c9NrU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NrU: // global
           _s9LXM::P64 = P64[Sp + 8];
           _c9Ns2::P64 = R1 & 7;
           if (_c9Ns2::P64 < 3) goto u9Nvt; else goto u9Nvu;
       u9Nvt: // global
           if (_c9Ns2::P64 < 2) goto c9NrY; else goto c9NrZ;
       c9NrY: // global
           I64[Sp + 8] = block_c9Ns8_info;
           R1 = _s9LXM::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Nw0; else goto c9Nsa;
       u9Nw0: // global
           call _c9Ns8() args: 0, res: 0, upd: 0;
       c9Nsa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NrZ: // global
           I64[Sp + 8] = block_c9Nsh_info;
           R1 = _s9LXM::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Nw1; else goto c9Nsj;
       u9Nw1: // global
           call _c9Nsh(R1) args: 0, res: 0, upd: 0;
       c9Nsj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Nvu: // global
           if (_c9Ns2::P64 < 4) goto c9Ns0; else goto c9Ns1;
       c9Ns0: // global
           I64[Sp] = block_c9NsE_info;
           _s9LXR::P64 = P64[R1 + 5];
           R1 = _s9LXM::P64;
           P64[Sp + 8] = _s9LXR::P64;
           if (R1 & 7 != 0) goto u9Nw2; else goto c9NsG;
       u9Nw2: // global
           call _c9NsE(R1) args: 0, res: 0, upd: 0;
       c9NsG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Ns1: // global
           I64[Sp + 8] = block_c9Nv7_info;
           R1 = _s9LXM::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Nw3; else goto c9Nv9;
       u9Nw3: // global
           call _c9Nv7(R1) args: 0, res: 0, upd: 0;
       c9Nv9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ns8() //  []
         { info_tbl: [(c9Ns8,
                       label: block_c9Ns8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ns8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Nsh() //  [R1]
         { info_tbl: [(c9Nsh,
                       label: block_c9Nsh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nsh: // global
           _c9Nvs::P64 = R1 & 7;
           if (_c9Nvs::P64 < 2) goto u9NvB; else goto u9Nvv;
       u9NvB: // global
           Sp = Sp + 8;
           call _c9Nvf() args: 0, res: 0, upd: 0;
       u9Nvv: // global
           if (_c9Nvs::P64 != 3) goto u9NvD; else goto u9NvD;
       u9NvD: // global
           Sp = Sp + 8;
           call _c9Nvj() args: 0, res: 0, upd: 0;
     }
 },
 _c9NsE() //  [R1]
         { info_tbl: [(c9NsE,
                       label: block_c9NsE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NsE: // global
           _c9Nvl::P64 = R1 & 7;
           if (_c9Nvl::P64 == 3) goto c9NsR; else goto u9Nvw;
       c9NsR: // global
           I64[Sp] = block_c9NsP_info;
           _s9LXT::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9LXT::P64;
           if (R1 & 7 != 0) goto u9Nw7; else goto c9NsS;
       u9Nw7: // global
           call _c9NsP(R1) args: 0, res: 0, upd: 0;
       c9NsS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9Nvw: // global
           if (_c9Nvl::P64 != 4) goto u9NvF; else goto u9NvE;
       u9NvF: // global
           Sp = Sp + 16;
           call _c9Nvf() args: 0, res: 0, upd: 0;
       u9NvE: // global
           Sp = Sp + 16;
           call _c9Nvj() args: 0, res: 0, upd: 0;
     }
 },
 _c9NsP() //  [R1]
         { info_tbl: [(c9NsP,
                       label: block_c9NsP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NsP: // global
           _s9LXT::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9NsZ;
               case 2 : goto c9Nt9;
               case 3 : goto c9NtF;
               case 4 : goto c9Nu7;
               case 5 : goto c9Nuv;
               case 6 : goto c9NuP;
           }
       c9NuP: // global
           I64[Sp + 8] = block_c9NuN_info;
           R1 = _s9LXT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Nwf; else goto c9NuQ;
       u9Nwf: // global
           call _c9NuN(R1) args: 0, res: 0, upd: 0;
       c9NuQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nuv: // global
           I64[Sp + 8] = block_c9Nut_info;
           R1 = _s9LXT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Nwe; else goto c9Nuw;
       u9Nwe: // global
           call _c9Nut(R1) args: 0, res: 0, upd: 0;
       c9Nuw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nu7: // global
           I64[Sp + 8] = block_c9Nu5_info;
           R1 = _s9LXT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Nwd; else goto c9Nu8;
       u9Nwd: // global
           call _c9Nu5(R1) args: 0, res: 0, upd: 0;
       c9Nu8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NtF: // global
           I64[Sp + 8] = block_c9NtD_info;
           R1 = _s9LXT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Nwc; else goto c9NtG;
       u9Nwc: // global
           call _c9NtD(R1) args: 0, res: 0, upd: 0;
       c9NtG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nt9: // global
           I64[Sp + 8] = block_c9Nt7_info;
           R1 = _s9LXT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Nwb; else goto c9Nta;
       u9Nwb: // global
           call _c9Nt7(R1) args: 0, res: 0, upd: 0;
       c9Nta: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NsZ: // global
           I64[Sp + 8] = block_c9NsW_info;
           R1 = _s9LXT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9Nwa; else goto c9Nt0;
       u9Nwa: // global
           call _c9NsW() args: 0, res: 0, upd: 0;
       c9Nt0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NuN() //  [R1]
         { info_tbl: [(c9NuN,
                       label: block_c9NuN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NuN: // global
           if (R1 & 7 == 6) goto u9NvG; else goto u9NvH;
       u9NvG: // global
           Sp = Sp + 8;
           call _c9Nvj() args: 0, res: 0, upd: 0;
       u9NvH: // global
           Sp = Sp + 8;
           call _c9Nvf() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nut() //  [R1]
         { info_tbl: [(c9Nut,
                       label: block_c9Nut_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nut: // global
           _c9Nvo::P64 = R1 & 7;
           if (_c9Nvo::P64 != 5) goto u9NvA; else goto u9NvI;
       u9NvA: // global
           if (_c9Nvo::P64 != 6) goto u9NvK; else goto u9NvJ;
       u9NvK: // global
           Sp = Sp + 8;
           call _c9Nvf() args: 0, res: 0, upd: 0;
       u9NvJ: // global
           Sp = Sp + 8;
           goto u9Nwo;
       u9NvI: // global
           Sp = Sp + 8;
           goto u9Nwo;
       u9Nwo: // global
           call _c9Nvj() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nu5() //  [R1]
         { info_tbl: [(c9Nu5,
                       label: block_c9Nu5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nu5: // global
           _c9Nvp::P64 = R1 & 7;
           if (_c9Nvp::P64 < 4) goto u9NvL; else goto u9Nvz;
       u9NvL: // global
           Sp = Sp + 8;
           call _c9Nvf() args: 0, res: 0, upd: 0;
       u9Nvz: // global
           if (_c9Nvp::P64 != 5) goto u9NvN; else goto u9NvN;
       u9NvN: // global
           Sp = Sp + 8;
           call _c9Nvj() args: 0, res: 0, upd: 0;
     }
 },
 _c9NtD() //  [R1]
         { info_tbl: [(c9NtD,
                       label: block_c9NtD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NtD: // global
           _c9Nvq::P64 = R1 & 7;
           if (_c9Nvq::P64 < 6) goto u9Nvx; else goto u9NvO;
       u9Nvx: // global
           if (_c9Nvq::P64 < 3) goto u9NvP; else goto u9Nvy;
       u9NvP: // global
           Sp = Sp + 8;
           call _c9Nvf() args: 0, res: 0, upd: 0;
       u9Nvy: // global
           if (_c9Nvq::P64 != 4) goto u9NvR; else goto u9NvR;
       u9NvR: // global
           Sp = Sp + 8;
           goto u9Nwk;
       u9NvO: // global
           Sp = Sp + 8;
           goto u9Nwk;
       u9Nwk: // global
           call _c9Nvj() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nt7() //  [R1]
         { info_tbl: [(c9Nt7,
                       label: block_c9Nt7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nt7: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9NvS;
               case 2, 3, 4, 5, 6 : goto u9NvX;
           }
       u9NvX: // global
           Sp = Sp + 8;
           call _c9Nvj() args: 0, res: 0, upd: 0;
       u9NvS: // global
           Sp = Sp + 8;
           call _c9Nvf() args: 0, res: 0, upd: 0;
     }
 },
 _c9NsW() //  []
         { info_tbl: [(c9NsW,
                       label: block_c9NsW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NsW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Nv7() //  [R1]
         { info_tbl: [(c9Nv7,
                       label: block_c9Nv7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nv7: // global
           if (R1 & 7 == 4) goto u9NvY; else goto u9NvZ;
       u9NvY: // global
           Sp = Sp + 8;
           call _c9Nvj() args: 0, res: 0, upd: 0;
       u9NvZ: // global
           Sp = Sp + 8;
           call _c9Nvf() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nvj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nvj: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Nvf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nvf: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.122448587 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmax_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c9Nyg,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nyg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9Nyh; else goto c9Nyi;
       c9Nyh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Nyi: // global
           I64[Sp - 16] = block_c9Ny7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9NBV; else goto c9Ny8;
       u9NBV: // global
           call _c9Ny7(R1) args: 0, res: 0, upd: 0;
       c9Ny8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ny7() //  [R1]
         { info_tbl: [(c9Ny7,
                       label: block_c9Ny7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ny7: // global
           _s9LY3::P64 = P64[Sp + 8];
           _c9Nyf::P64 = R1 & 7;
           if (_c9Nyf::P64 < 3) goto u9NBp; else goto u9NBq;
       u9NBp: // global
           if (_c9Nyf::P64 < 2) goto c9Nyb; else goto c9Nyc;
       c9Nyb: // global
           R1 = _s9LY3::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9Nyc: // global
           I64[Sp + 8] = block_c9Nyo_info;
           R1 = _s9LY3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NBS; else goto c9Nyq;
       u9NBS: // global
           call _c9Nyo(R1) args: 0, res: 0, upd: 0;
       c9Nyq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9NBq: // global
           if (_c9Nyf::P64 < 4) goto c9Nyd; else goto c9Nye;
       c9Nyd: // global
           I64[Sp - 8] = block_c9NyH_info;
           _s9LY4::P64 = R1;
           _s9LY7::P64 = P64[R1 + 5];
           R1 = _s9LY3::P64;
           P64[Sp] = _s9LY7::P64;
           P64[Sp + 8] = _s9LY4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9NBT; else goto c9NyJ;
       u9NBT: // global
           call _c9NyH(R1) args: 0, res: 0, upd: 0;
       c9NyJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nye: // global
           I64[Sp + 8] = block_c9NBa_info;
           R1 = _s9LY3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NBU; else goto c9NBc;
       u9NBU: // global
           call _c9NBa() args: 0, res: 0, upd: 0;
       c9NBc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Nyo() //  [R1]
         { info_tbl: [(c9Nyo,
                       label: block_c9Nyo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nyo: // global
           _c9NBo::P64 = R1 & 7;
           if (_c9NBo::P64 == 3) goto c9NyA; else goto u9NBr;
       c9NyA: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9NBr: // global
           if (_c9NBo::P64 != 4) goto c9Nyw; else goto u9NBx;
       c9Nyw: // global
           R1 = GHC.Conc.Sync.ThreadFinished_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9NBx: // global
           Sp = Sp + 8;
           call _c9NB7() args: 0, res: 0, upd: 0;
     }
 },
 _c9NyH() //  [R1]
         { info_tbl: [(c9NyH,
                       label: block_c9NyH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NyH: // global
           _c9NBh::P64 = R1 & 7;
           if (_c9NBh::P64 == 3) goto c9NyU; else goto u9NBs;
       c9NyU: // global
           I64[Sp - 8] = block_c9NyS_info;
           _s9LY8::P64 = R1;
           _s9LY9::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9LY9::P64;
           P64[Sp + 8] = _s9LY8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9NBX; else goto c9NyV;
       u9NBX: // global
           call _c9NyS(R1) args: 0, res: 0, upd: 0;
       c9NyV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9NBs: // global
           if (_c9NBh::P64 != 4) goto u9NBz; else goto u9NBy;
       u9NBz: // global
           Sp = Sp + 16;
           call _c9NAZ() args: 0, res: 0, upd: 0;
       u9NBy: // global
           Sp = Sp + 24;
           call _c9NB7() args: 0, res: 0, upd: 0;
     }
 },
 _c9NyS() //  [R1]
         { info_tbl: [(c9NyS,
                       label: block_c9NyS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NyS: // global
           _s9LY9::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9Nz2;
               case 2 : goto c9Nzc;
               case 3 : goto c9NzI;
               case 4 : goto c9NAa;
               case 5 : goto c9NAy;
               case 6 : goto c9NAS;
           }
       c9NAS: // global
           I64[Sp + 8] = block_c9NAQ_info;
           R1 = _s9LY9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NC5; else goto c9NAT;
       u9NC5: // global
           call _c9NAQ(R1) args: 0, res: 0, upd: 0;
       c9NAT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NAy: // global
           I64[Sp + 8] = block_c9NAw_info;
           R1 = _s9LY9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NC4; else goto c9NAz;
       u9NC4: // global
           call _c9NAw(R1) args: 0, res: 0, upd: 0;
       c9NAz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NAa: // global
           I64[Sp + 8] = block_c9NA8_info;
           R1 = _s9LY9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NC3; else goto c9NAb;
       u9NC3: // global
           call _c9NA8(R1) args: 0, res: 0, upd: 0;
       c9NAb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NzI: // global
           I64[Sp + 8] = block_c9NzG_info;
           R1 = _s9LY9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NC2; else goto c9NzJ;
       u9NC2: // global
           call _c9NzG(R1) args: 0, res: 0, upd: 0;
       c9NzJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nzc: // global
           I64[Sp + 8] = block_c9Nza_info;
           R1 = _s9LY9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NC1; else goto c9Nzd;
       u9NC1: // global
           call _c9Nza(R1) args: 0, res: 0, upd: 0;
       c9Nzd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9Nz2: // global
           I64[Sp + 8] = block_c9NyZ_info;
           R1 = _s9LY9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NC0; else goto c9Nz3;
       u9NC0: // global
           call _c9NyZ() args: 0, res: 0, upd: 0;
       c9Nz3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NAQ() //  [R1]
         { info_tbl: [(c9NAQ,
                       label: block_c9NAQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NAQ: // global
           if (R1 & 7 == 6) goto u9NBA; else goto u9NBB;
       u9NBA: // global
           Sp = Sp + 8;
           call _c9NB3() args: 0, res: 0, upd: 0;
       u9NBB: // global
           Sp = Sp + 16;
           call _c9NAZ() args: 0, res: 0, upd: 0;
     }
 },
 _c9NAw() //  [R1]
         { info_tbl: [(c9NAw,
                       label: block_c9NAw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NAw: // global
           _c9NBk::P64 = R1 & 7;
           if (_c9NBk::P64 != 5) goto u9NBw; else goto u9NBC;
       u9NBw: // global
           if (_c9NBk::P64 != 6) goto u9NBE; else goto u9NBD;
       u9NBE: // global
           Sp = Sp + 16;
           call _c9NAZ() args: 0, res: 0, upd: 0;
       u9NBD: // global
           Sp = Sp + 8;
           goto u9NCe;
       u9NBC: // global
           Sp = Sp + 8;
           goto u9NCe;
       u9NCe: // global
           call _c9NB3() args: 0, res: 0, upd: 0;
     }
 },
 _c9NA8() //  [R1]
         { info_tbl: [(c9NA8,
                       label: block_c9NA8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NA8: // global
           _c9NBl::P64 = R1 & 7;
           if (_c9NBl::P64 < 4) goto u9NBF; else goto u9NBv;
       u9NBF: // global
           Sp = Sp + 16;
           call _c9NAZ() args: 0, res: 0, upd: 0;
       u9NBv: // global
           if (_c9NBl::P64 != 5) goto u9NBH; else goto u9NBH;
       u9NBH: // global
           Sp = Sp + 8;
           call _c9NB3() args: 0, res: 0, upd: 0;
     }
 },
 _c9NzG() //  [R1]
         { info_tbl: [(c9NzG,
                       label: block_c9NzG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NzG: // global
           _c9NBm::P64 = R1 & 7;
           if (_c9NBm::P64 < 6) goto u9NBt; else goto u9NBI;
       u9NBt: // global
           if (_c9NBm::P64 < 3) goto u9NBJ; else goto u9NBu;
       u9NBJ: // global
           Sp = Sp + 16;
           call _c9NAZ() args: 0, res: 0, upd: 0;
       u9NBu: // global
           if (_c9NBm::P64 != 4) goto u9NBL; else goto u9NBL;
       u9NBL: // global
           Sp = Sp + 8;
           goto u9NCa;
       u9NBI: // global
           Sp = Sp + 8;
           goto u9NCa;
       u9NCa: // global
           call _c9NB3() args: 0, res: 0, upd: 0;
     }
 },
 _c9Nza() //  [R1]
         { info_tbl: [(c9Nza,
                       label: block_c9Nza_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Nza: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9NBM;
               case 2, 3, 4, 5, 6 : goto u9NBR;
           }
       u9NBR: // global
           Sp = Sp + 8;
           call _c9NB3() args: 0, res: 0, upd: 0;
       u9NBM: // global
           Sp = Sp + 16;
           call _c9NAZ() args: 0, res: 0, upd: 0;
     }
 },
 _c9NB3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NB3: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9NyZ() //  []
         { info_tbl: [(c9NyZ,
                       label: block_c9NyZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NyZ: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9NAZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NAZ: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9NB7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NB7: // global
           R1 = GHC.Conc.Sync.ThreadDied_closure+4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9NBa() //  []
         { info_tbl: [(c9NBa,
                       label: block_c9NBa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NBa: // global
           R1 = GHC.Conc.Sync.ThreadDied_closure+4;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.152648967 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure:
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmin_info;
 },
 GHC.Conc.Sync.$fOrdThreadStatus_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c9NE4,
                       label: GHC.Conc.Sync.$fOrdThreadStatus_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NE4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9NE5; else goto c9NE6;
       c9NE5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9NE6: // global
           I64[Sp - 16] = block_c9NDV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9NHM; else goto c9NDW;
       u9NHM: // global
           call _c9NDV(R1) args: 0, res: 0, upd: 0;
       c9NDW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NDV() //  [R1]
         { info_tbl: [(c9NDV,
                       label: block_c9NDV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NDV: // global
           _s9LYj::P64 = P64[Sp + 8];
           _c9NE3::P64 = R1 & 7;
           if (_c9NE3::P64 < 3) goto u9NHh; else goto u9NHi;
       u9NHh: // global
           if (_c9NE3::P64 < 2) goto c9NDZ; else goto c9NE0;
       c9NDZ: // global
           I64[Sp + 8] = block_c9NE9_info;
           R1 = _s9LYj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NHJ; else goto c9NEb;
       u9NHJ: // global
           call _c9NE9() args: 0, res: 0, upd: 0;
       c9NEb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NE0: // global
           I64[Sp + 8] = block_c9NEi_info;
           R1 = _s9LYj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NHK; else goto c9NEk;
       u9NHK: // global
           call _c9NEi(R1) args: 0, res: 0, upd: 0;
       c9NEk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9NHi: // global
           if (_c9NE3::P64 < 4) goto c9NE1; else goto c9NE2;
       c9NE1: // global
           I64[Sp - 8] = block_c9NEF_info;
           _s9LYk::P64 = R1;
           _s9LYo::P64 = P64[R1 + 5];
           R1 = _s9LYj::P64;
           P64[Sp] = _s9LYo::P64;
           P64[Sp + 8] = _s9LYk::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9NHL; else goto c9NEH;
       u9NHL: // global
           call _c9NEF(R1) args: 0, res: 0, upd: 0;
       c9NEH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NE2: // global
           R1 = _s9LYj::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9NE9() //  []
         { info_tbl: [(c9NE9,
                       label: block_c9NE9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NE9: // global
           R1 = GHC.Conc.Sync.ThreadRunning_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9NEi() //  [R1]
         { info_tbl: [(c9NEi,
                       label: block_c9NEi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NEi: // global
           _c9NHg::P64 = R1 & 7;
           if (_c9NHg::P64 < 2) goto c9NEq; else goto u9NHj;
       c9NEq: // global
           R1 = GHC.Conc.Sync.ThreadRunning_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9NHj: // global
           if (_c9NHg::P64 != 3) goto c9NEC; else goto c9NEC;
       c9NEC: // global
           R1 = GHC.Conc.Sync.ThreadFinished_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9NEF() //  [R1]
         { info_tbl: [(c9NEF,
                       label: block_c9NEF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NEF: // global
           _c9NH9::P64 = R1 & 7;
           if (_c9NH9::P64 == 3) goto c9NES; else goto u9NHk;
       c9NES: // global
           I64[Sp - 8] = block_c9NEQ_info;
           _s9LYp::P64 = R1;
           _s9LYq::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9LYq::P64;
           P64[Sp + 8] = _s9LYp::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9NHN; else goto c9NET;
       u9NHN: // global
           call _c9NEQ(R1) args: 0, res: 0, upd: 0;
       c9NET: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u9NHk: // global
           if (_c9NH9::P64 == 4) goto u9NHp; else goto u9NHq;
       u9NHp: // global
           Sp = Sp + 16;
           call _c9NH5() args: 0, res: 0, upd: 0;
       u9NHq: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 16;
           call _c9NGX() args: 0, res: 0, upd: 0;
     }
 },
 _c9NEQ() //  [R1]
         { info_tbl: [(c9NEQ,
                       label: block_c9NEQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NEQ: // global
           _s9LYq::P64 = P64[Sp + 8];
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto c9NF0;
               case 2 : goto c9NFa;
               case 3 : goto c9NFG;
               case 4 : goto c9NG8;
               case 5 : goto c9NGw;
               case 6 : goto c9NGQ;
           }
       c9NGQ: // global
           I64[Sp + 8] = block_c9NGO_info;
           R1 = _s9LYq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NHV; else goto c9NGR;
       u9NHV: // global
           call _c9NGO(R1) args: 0, res: 0, upd: 0;
       c9NGR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NGw: // global
           I64[Sp + 8] = block_c9NGu_info;
           R1 = _s9LYq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NHU; else goto c9NGx;
       u9NHU: // global
           call _c9NGu(R1) args: 0, res: 0, upd: 0;
       c9NGx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NG8: // global
           I64[Sp + 8] = block_c9NG6_info;
           R1 = _s9LYq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NHT; else goto c9NG9;
       u9NHT: // global
           call _c9NG6(R1) args: 0, res: 0, upd: 0;
       c9NG9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NFG: // global
           I64[Sp + 8] = block_c9NFE_info;
           R1 = _s9LYq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NHS; else goto c9NFH;
       u9NHS: // global
           call _c9NFE(R1) args: 0, res: 0, upd: 0;
       c9NFH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NFa: // global
           I64[Sp + 8] = block_c9NF8_info;
           R1 = _s9LYq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u9NHR; else goto c9NFb;
       u9NHR: // global
           call _c9NF8(R1) args: 0, res: 0, upd: 0;
       c9NFb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9NF0: // global
           I64[Sp + 16] = block_c9NEX_info;
           R1 = _s9LYq::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto u9NHQ; else goto c9NF1;
       u9NHQ: // global
           call _c9NEX() args: 0, res: 0, upd: 0;
       c9NF1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NGO() //  [R1]
         { info_tbl: [(c9NGO,
                       label: block_c9NGO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NGO: // global
           if (R1 & 7 == 6) goto u9NHr; else goto u9NHs;
       u9NHr: // global
           Sp = Sp + 16;
           call _c9NH5() args: 0, res: 0, upd: 0;
       u9NHs: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9NGX() args: 0, res: 0, upd: 0;
     }
 },
 _c9NGu() //  [R1]
         { info_tbl: [(c9NGu,
                       label: block_c9NGu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NGu: // global
           _c9NHc::P64 = R1 & 7;
           if (_c9NHc::P64 != 5) goto u9NHo; else goto u9NHt;
       u9NHo: // global
           if (_c9NHc::P64 != 6) goto u9NHv; else goto u9NHu;
       u9NHv: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9NGX() args: 0, res: 0, upd: 0;
       u9NHu: // global
           Sp = Sp + 16;
           goto u9NI4;
       u9NHt: // global
           Sp = Sp + 16;
           goto u9NI4;
       u9NI4: // global
           call _c9NH5() args: 0, res: 0, upd: 0;
     }
 },
 _c9NG6() //  [R1]
         { info_tbl: [(c9NG6,
                       label: block_c9NG6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NG6: // global
           _c9NHd::P64 = R1 & 7;
           if (_c9NHd::P64 < 4) goto u9NHw; else goto u9NHn;
       u9NHw: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9NGX() args: 0, res: 0, upd: 0;
       u9NHn: // global
           if (_c9NHd::P64 != 5) goto u9NHy; else goto u9NHy;
       u9NHy: // global
           Sp = Sp + 16;
           call _c9NH5() args: 0, res: 0, upd: 0;
     }
 },
 _c9NFE() //  [R1]
         { info_tbl: [(c9NFE,
                       label: block_c9NFE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NFE: // global
           _c9NHe::P64 = R1 & 7;
           if (_c9NHe::P64 < 6) goto u9NHl; else goto u9NHz;
       u9NHl: // global
           if (_c9NHe::P64 < 3) goto u9NHA; else goto u9NHm;
       u9NHA: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9NGX() args: 0, res: 0, upd: 0;
       u9NHm: // global
           if (_c9NHe::P64 != 4) goto u9NHC; else goto u9NHC;
       u9NHC: // global
           Sp = Sp + 16;
           goto u9NI0;
       u9NHz: // global
           Sp = Sp + 16;
           goto u9NI0;
       u9NI0: // global
           call _c9NH5() args: 0, res: 0, upd: 0;
     }
 },
 _c9NF8() //  [R1]
         { info_tbl: [(c9NF8,
                       label: block_c9NF8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NF8: // global
           switch [1 .. 6] (R1 & 7) {
               case 1 : goto u9NHD;
               case 2, 3, 4, 5, 6 : goto u9NHI;
           }
       u9NHI: // global
           Sp = Sp + 16;
           call _c9NH5() args: 0, res: 0, upd: 0;
       u9NHD: // global
           P64[Sp + 16] = P64[Sp + 8];
           Sp = Sp + 16;
           call _c9NGX() args: 0, res: 0, upd: 0;
     }
 },
 _c9NEX() //  []
         { info_tbl: [(c9NEX,
                       label: block_c9NEX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NEX: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9NH5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NH5: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9NGX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NGX: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.179527453 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadStatus_closure" {
     GHC.Conc.Sync.$fOrdThreadStatus_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Conc.Sync.$fEqThreadStatus_closure+1;
         const GHC.Conc.Sync.$fOrdThreadStatus_$ccompare_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c<=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$c>=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmax_closure+2;
         const GHC.Conc.Sync.$fOrdThreadStatus_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.181895593 UTC

[section ""cstring" . GHC.Conc.Sync.$trModule4_bytes" {
     GHC.Conc.Sync.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.183418308 UTC

[section ""data" . GHC.Conc.Sync.$trModule3_closure" {
     GHC.Conc.Sync.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.184970085 UTC

[section ""cstring" . GHC.Conc.Sync.$trModule2_bytes" {
     GHC.Conc.Sync.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,83,121,110,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.186570515 UTC

[section ""data" . GHC.Conc.Sync.$trModule1_closure" {
     GHC.Conc.Sync.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.188148201 UTC

[section ""data" . GHC.Conc.Sync.$trModule_closure" {
     GHC.Conc.Sync.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.Sync.$trModule3_closure+1;
         const GHC.Conc.Sync.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.192385633 UTC

[section ""data" . $krep_r9FuN_closure" {
     $krep_r9FuN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc'LiftedRep_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.194277125 UTC

[section ""data" . $krep1_r9FuO_closure" {
     $krep1_r9FuO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRuntimeRep_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.196312094 UTC

[section ""data" . $krep2_r9FuP_closure" {
     $krep2_r9FuP_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcRealWorld_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.198126946 UTC

[section ""data" . $krep3_r9FuQ_closure" {
     $krep3_r9FuQ_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.199766687 UTC

[section ""data" . $krep4_r9FuR_closure" {
     $krep4_r9FuR_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcThreadId#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.202143844 UTC

[section ""data" . $krep5_r9FuS_closure" {
     $krep5_r9FuS_closure:
         const :_con_info;
         const $krep3_r9FuQ_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.203978696 UTC

[section ""data" . $krep6_r9FuT_closure" {
     $krep6_r9FuT_closure:
         const :_con_info;
         const $krep2_r9FuP_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.205647475 UTC

[section ""data" . $krep7_r9FuU_closure" {
     $krep7_r9FuU_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcTVar#_closure;
         const $krep6_r9FuT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.207414178 UTC

[section ""data" . $krep8_r9FuV_closure" {
     $krep8_r9FuV_closure:
         const :_con_info;
         const $krep2_r9FuP_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.210079379 UTC

[section ""data" . $krep9_r9FuW_closure" {
     $krep9_r9FuW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcState#_closure;
         const $krep8_r9FuV_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.211738212 UTC

[section ""data" . $krep10_r9FuX_closure" {
     $krep10_r9FuX_closure:
         const :_con_info;
         const $krep1_r9FuO_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.213736637 UTC

[section ""data" . $krep11_r9FuY_closure" {
     $krep11_r9FuY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc'[]_closure;
         const $krep10_r9FuX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.215870975 UTC

[section ""data" . $krep12_r9FuZ_closure" {
     $krep12_r9FuZ_closure:
         const :_con_info;
         const $krep11_r9FuY_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.218253181 UTC

[section ""data" . $krep13_r9Fv0_closure" {
     $krep13_r9Fv0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc'TupleRep_closure;
         const $krep12_r9FuZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.219989169 UTC

[section ""data" . $krep14_r9Fv1_closure" {
     $krep14_r9Fv1_closure:
         const :_con_info;
         const $krep9_r9FuW_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.221657588 UTC

[section ""data" . $krep15_r9Fv2_closure" {
     $krep15_r9Fv2_closure:
         const :_con_info;
         const $krep_r9FuN_closure+1;
         const $krep14_r9Fv1_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.223263245 UTC

[section ""data" . $krep16_r9Fv3_closure" {
     $krep16_r9Fv3_closure:
         const :_con_info;
         const $krep13_r9Fv0_closure+1;
         const $krep15_r9Fv2_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.224945853 UTC

[section ""data" . $krep17_r9Fv4_closure" {
     $krep17_r9Fv4_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc(#,#)_closure;
         const $krep16_r9Fv3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.227033988 UTC

[section ""data" . $krep18_r9Fv5_closure" {
     $krep18_r9Fv5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r9FuW_closure+1;
         const $krep17_r9Fv4_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.228693066 UTC

[section ""cstring" . GHC.Conc.Sync.$tcThreadId2_bytes" {
     GHC.Conc.Sync.$tcThreadId2_bytes:
         I8[] [84,104,114,101,97,100,73,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.230431364 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadId1_closure" {
     GHC.Conc.Sync.$tcThreadId1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcThreadId2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.232114849 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadId_closure" {
     GHC.Conc.Sync.$tcThreadId_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcThreadId1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16775948407395805744;
         const 12520674293648100702;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.23394298 UTC

[section ""data" . $krep19_r9Fv6_closure" {
     $krep19_r9Fv6_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcThreadId_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.236284235 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadId1_closure" {
     GHC.Conc.Sync.$tc'ThreadId1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r9FuR_closure+1;
         const $krep19_r9Fv6_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.237954695 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadId3_bytes" {
     GHC.Conc.Sync.$tc'ThreadId3_bytes:
         I8[] [39,84,104,114,101,97,100,73,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.239570813 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadId2_closure" {
     GHC.Conc.Sync.$tc'ThreadId2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadId3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.241146392 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadId_closure" {
     GHC.Conc.Sync.$tc'ThreadId_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadId2_closure+1;
         const GHC.Conc.Sync.$tc'ThreadId1_closure+4;
         const 18342150043682338300;
         const 5104860271509165481;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.242933693 UTC

[section ""cstring" . GHC.Conc.Sync.$tcBlockReason2_bytes" {
     GHC.Conc.Sync.$tcBlockReason2_bytes:
         I8[] [66,108,111,99,107,82,101,97,115,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.244524908 UTC

[section ""data" . GHC.Conc.Sync.$tcBlockReason1_closure" {
     GHC.Conc.Sync.$tcBlockReason1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcBlockReason2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.246545248 UTC

[section ""data" . GHC.Conc.Sync.$tcBlockReason_closure" {
     GHC.Conc.Sync.$tcBlockReason_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcBlockReason1_closure+1;
         const GHC.Types.krep$*_closure;
         const 13301038780413995570;
         const 11021250300446969031;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.248295518 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcBlockReason_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.249974203 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnMVar2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnMVar2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.251415402 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnMVar1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnMVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.252989444 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnMVar_closure" {
     GHC.Conc.Sync.$tc'BlockedOnMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnMVar1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 6633002816895506850;
         const 13520604374172074732;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.25480874 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnBlackHole3_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole3_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,66,108,97,99,107,72,111,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.256450038 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnBlackHole2_closure" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.258119441 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnBlackHole_closure" {
     GHC.Conc.Sync.$tc'BlockedOnBlackHole_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole2_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 9499731398899925739;
         const 7296688042620961692;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.26034175 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnException2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnException2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,69,120,99,101,112,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.262579615 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnException1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnException1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnException2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.264248439 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnException_closure" {
     GHC.Conc.Sync.$tc'BlockedOnException_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnException1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 16834505563200403543;
         const 10899729493106152581;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.266053036 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnSTM2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnSTM2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.267564945 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnSTM1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnSTM1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnSTM2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.269184642 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnSTM_closure" {
     GHC.Conc.Sync.$tc'BlockedOnSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnSTM1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 1161208048218837616;
         const 14246412223428266787;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.270995171 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnForeignCall2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnForeignCall2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,70,111,114,101,105,103,110,67,97,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.272596352 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnForeignCall1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnForeignCall1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnForeignCall2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.274319335 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnForeignCall_closure" {
     GHC.Conc.Sync.$tc'BlockedOnForeignCall_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnForeignCall1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 7408412473094687054;
         const 5512662453084487661;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.276068258 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'BlockedOnOther2_bytes" {
     GHC.Conc.Sync.$tc'BlockedOnOther2_bytes:
         I8[] [39,66,108,111,99,107,101,100,79,110,79,116,104,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.277686466 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnOther1_closure" {
     GHC.Conc.Sync.$tc'BlockedOnOther1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnOther2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.279336237 UTC

[section ""data" . GHC.Conc.Sync.$tc'BlockedOnOther_closure" {
     GHC.Conc.Sync.$tc'BlockedOnOther_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnOther1_closure+1;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const 12822899422417308746;
         const 1265626399802742388;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.281120646 UTC

[section ""cstring" . GHC.Conc.Sync.$tcThreadStatus2_bytes" {
     GHC.Conc.Sync.$tcThreadStatus2_bytes:
         I8[] [84,104,114,101,97,100,83,116,97,116,117,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.282870942 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadStatus1_closure" {
     GHC.Conc.Sync.$tcThreadStatus1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcThreadStatus2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.285015323 UTC

[section ""data" . GHC.Conc.Sync.$tcThreadStatus_closure" {
     GHC.Conc.Sync.$tcThreadStatus_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcThreadStatus1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16437204929171641638;
         const 3495092226815585861;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.286874435 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadDied1_closure" {
     GHC.Conc.Sync.$tc'ThreadDied1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcThreadStatus_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.288553237 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadRunning2_bytes" {
     GHC.Conc.Sync.$tc'ThreadRunning2_bytes:
         I8[] [39,84,104,114,101,97,100,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.291211693 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadRunning1_closure" {
     GHC.Conc.Sync.$tc'ThreadRunning1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadRunning2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.292818335 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadRunning_closure" {
     GHC.Conc.Sync.$tc'ThreadRunning_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadRunning1_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 1667122312602609882;
         const 13647871799576313560;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.294632539 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadFinished2_bytes" {
     GHC.Conc.Sync.$tc'ThreadFinished2_bytes:
         I8[] [39,84,104,114,101,97,100,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.296244429 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadFinished1_closure" {
     GHC.Conc.Sync.$tc'ThreadFinished1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadFinished2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.297878427 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadFinished_closure" {
     GHC.Conc.Sync.$tc'ThreadFinished_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadFinished1_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 2441107603776884109;
         const 12730966154693836607;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.299673352 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadDied3_bytes" {
     GHC.Conc.Sync.$tc'ThreadDied3_bytes:
         I8[] [39,84,104,114,101,97,100,68,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.301279736 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadDied2_closure" {
     GHC.Conc.Sync.$tc'ThreadDied2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadDied3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.302943044 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadDied_closure" {
     GHC.Conc.Sync.$tc'ThreadDied_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied2_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 9513974555658789847;
         const 4757719484357493227;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.304757381 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadBlocked1_closure" {
     GHC.Conc.Sync.$tc'ThreadBlocked1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Conc.Sync.$tc'BlockedOnBlackHole1_closure+1;
         const GHC.Conc.Sync.$tc'ThreadDied1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.306427935 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'ThreadBlocked3_bytes" {
     GHC.Conc.Sync.$tc'ThreadBlocked3_bytes:
         I8[] [39,84,104,114,101,97,100,66,108,111,99,107,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.308004443 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadBlocked2_closure" {
     GHC.Conc.Sync.$tc'ThreadBlocked2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'ThreadBlocked3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.309693825 UTC

[section ""data" . GHC.Conc.Sync.$tc'ThreadBlocked_closure" {
     GHC.Conc.Sync.$tc'ThreadBlocked_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'ThreadBlocked2_closure+1;
         const GHC.Conc.Sync.$tc'ThreadBlocked1_closure+4;
         const 1896650886570328403;
         const 13390928353603149841;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.311982534 UTC

[section ""cstring" . GHC.Conc.Sync.$tcPrimMVar2_bytes" {
     GHC.Conc.Sync.$tcPrimMVar2_bytes:
         I8[] [80,114,105,109,77,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.313871454 UTC

[section ""data" . GHC.Conc.Sync.$tcPrimMVar1_closure" {
     GHC.Conc.Sync.$tcPrimMVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcPrimMVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.315515166 UTC

[section ""data" . GHC.Conc.Sync.$tcPrimMVar_closure" {
     GHC.Conc.Sync.$tcPrimMVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcPrimMVar1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9965391380168186507;
         const 18322737771689556223;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.31723452 UTC

[section ""cstring" . GHC.Conc.Sync.$tcSTM2_bytes" {
     GHC.Conc.Sync.$tcSTM2_bytes:
         I8[] [83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.318854198 UTC

[section ""data" . GHC.Conc.Sync.$tcSTM1_closure" {
     GHC.Conc.Sync.$tcSTM1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcSTM2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.320499867 UTC

[section ""data" . GHC.Conc.Sync.$tcSTM_closure" {
     GHC.Conc.Sync.$tcSTM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcSTM1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 2004856025729794332;
         const 14974623362753764267;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.322230672 UTC

[section ""data" . $krep20_r9Fv7_closure" {
     $krep20_r9Fv7_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcSTM_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.323860468 UTC

[section ""data" . GHC.Conc.Sync.$tc'STM1_closure" {
     GHC.Conc.Sync.$tc'STM1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep18_r9Fv5_closure+4;
         const $krep20_r9Fv7_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.326210247 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'STM3_bytes" {
     GHC.Conc.Sync.$tc'STM3_bytes:
         I8[] [39,83,84,77]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.327793004 UTC

[section ""data" . GHC.Conc.Sync.$tc'STM2_closure" {
     GHC.Conc.Sync.$tc'STM2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'STM3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.32937143 UTC

[section ""data" . GHC.Conc.Sync.$tc'STM_closure" {
     GHC.Conc.Sync.$tc'STM_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'STM2_closure+1;
         const GHC.Conc.Sync.$tc'STM1_closure+4;
         const 11288073744523536973;
         const 9767688212531311940;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.33100014 UTC

[section ""cstring" . GHC.Conc.Sync.$tcTVar2_bytes" {
     GHC.Conc.Sync.$tcTVar2_bytes:
         I8[] [84,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.332504731 UTC

[section ""data" . GHC.Conc.Sync.$tcTVar1_closure" {
     GHC.Conc.Sync.$tcTVar1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tcTVar2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.334113536 UTC

[section ""data" . GHC.Conc.Sync.$tcTVar_closure" {
     GHC.Conc.Sync.$tcTVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tcTVar1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13084572405727191592;
         const 5232564955606145236;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.336307776 UTC

[section ""data" . $krep21_r9Fv8_closure" {
     $krep21_r9Fv8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Conc.Sync.$tcTVar_closure+1;
         const $krep5_r9FuS_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.337922054 UTC

[section ""data" . GHC.Conc.Sync.$tc'TVar1_closure" {
     GHC.Conc.Sync.$tc'TVar1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r9FuU_closure+1;
         const $krep21_r9Fv8_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.339517913 UTC

[section ""cstring" . GHC.Conc.Sync.$tc'TVar3_bytes" {
     GHC.Conc.Sync.$tc'TVar3_bytes:
         I8[] [39,84,86,97,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.341053835 UTC

[section ""data" . GHC.Conc.Sync.$tc'TVar2_closure" {
     GHC.Conc.Sync.$tc'TVar2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Sync.$tc'TVar3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.342626738 UTC

[section ""data" . GHC.Conc.Sync.$tc'TVar_closure" {
     GHC.Conc.Sync.$tc'TVar_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Conc.Sync.$trModule_closure+1;
         const GHC.Conc.Sync.$tc'TVar2_closure+1;
         const GHC.Conc.Sync.$tc'TVar1_closure+4;
         const 9463269625853265574;
         const 3517068532143837766;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.344368254 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadId2_bytes" {
     GHC.Conc.Sync.$fShowThreadId2_bytes:
         I8[] [84,104,114,101,97,100,73,100,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.347227889 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure" {
     GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure:
         const GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_info;
 },
 x_s9LYA_entry() //  [R1]
         { info_tbl: [(c9NLn,
                       label: x_s9LYA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NLn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9NLw; else goto c9NLx;
       c9NLw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9NLx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9NLk_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9NLB; else goto c9NLl;
       u9NLB: // global
           call _c9NLk(R1) args: 0, res: 0, upd: 0;
       c9NLl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9NLk() //  [R1]
         { info_tbl: [(c9NLk,
                       label: block_c9NLk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NLk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9NLA; else goto c9NLz;
       c9NLA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9NLz: // global
           (_s9LYG::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadId(P64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9LYG::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9LYQ_entry() //  [R1]
         { info_tbl: [(c9NLO,
                       label: sat_s9LYQ_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NLO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9NLZ; else goto c9NM0;
       c9NLZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9NM0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9NLL_info;
           _s9LYy::P64 = P64[R1 + 16];
           _s9LYI::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s9LYy::P64;
           P64[Sp - 24] = _s9LYI::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u9NM7; else goto c9NLM;
       u9NM7: // global
           call _c9NLL(R1) args: 0, res: 0, upd: 0;
       c9NLM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9NLL() //  [R1]
         { info_tbl: [(c9NLL,
                       label: block_c9NLL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NLL: // global
           I64[Sp] = block_c9NLR_info;
           _s9LYK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s9LYK::I64;
           if (R1 & 7 != 0) goto u9NM6; else goto c9NLS;
       u9NM6: // global
           call _c9NLR(R1) args: 0, res: 0, upd: 0;
       c9NLS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9NLR() //  [R1]
         { info_tbl: [(c9NLR,
                       label: block_c9NLR_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NLR: // global
           _s9LYI::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9NLW_info;
           R4 = _s9LYI::P64;
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9NLW() //  [R1, R2]
         { info_tbl: [(c9NLW,
                       label: block_c9NLW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NLW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9NM5; else goto c9NM4;
       c9NM5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9NM4: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9LYR_entry() //  [R1, R2]
         { info_tbl: [(c9NM8,
                       label: sat_s9LYR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NM8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9NMc; else goto c9NMb;
       c9NMc: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9NMb: // global
           _s9LYy::P64 = P64[R1 + 7];
           _s9LYA::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9LYQ_info;
           P64[Hp - 16] = _s9LYy::P64;
           P64[Hp - 8] = _s9LYA::P64;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = GHC.Conc.Sync.$fShowThreadId2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c9NMd,
                       label: GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NMd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c9NMh; else goto c9NMg;
       c9NMh: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9NMg: // global
           I64[Hp - 40] = x_s9LYA_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s9LYR_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.365094992 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_$cshow_closure" {
     GHC.Conc.Sync.$fShowThreadId_$cshow_closure:
         const GHC.Conc.Sync.$fShowThreadId_$cshow_info;
 },
 sat_s9LZ3_entry() //  [R1]
         { info_tbl: [(c9NNd,
                       label: sat_s9LZ3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NNd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9NNo; else goto c9NNp;
       c9NNo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9NNp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9NNa_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9NNu; else goto c9NNb;
       u9NNu: // global
           call _c9NNa(R1) args: 0, res: 0, upd: 0;
       c9NNb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9NNa() //  [R1]
         { info_tbl: [(c9NNa,
                       label: block_c9NNa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NNa: // global
           (_s9LYY::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadId(P64[R1 + 7]);
           I64[Sp] = block_c9NNl_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9LYY::I64));
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9NNl() //  [R1, R2]
         { info_tbl: [(c9NNl,
                       label: block_c9NNl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NNl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9NNt; else goto c9NNs;
       c9NNt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9NNs: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$fShowThreadId_$cshow_entry() //  [R2]
         { info_tbl: [(c9NNv,
                       label: GHC.Conc.Sync.$fShowThreadId_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NNv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9NNz; else goto c9NNy;
       c9NNz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadId_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9NNy: // global
           I64[Hp - 16] = sat_s9LZ3_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = GHC.Conc.Sync.$fShowThreadId2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.376306421 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId1_closure" {
     GHC.Conc.Sync.$fShowThreadId1_closure:
         const GHC.Conc.Sync.$fShowThreadId1_info;
 },
 x_s9LZ5_entry() //  [R1]
         { info_tbl: [(c9NO7,
                       label: x_s9LZ5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NO7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9NOg; else goto c9NOh;
       c9NOg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9NOh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9NO4_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9NOl; else goto c9NO5;
       u9NOl: // global
           call _c9NO4(R1) args: 0, res: 0, upd: 0;
       c9NO5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9NO4() //  [R1]
         { info_tbl: [(c9NO4,
                       label: block_c9NO4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NO4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9NOk; else goto c9NOj;
       c9NOk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c9NOj: // global
           (_s9LZb::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadId(P64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9LZb::I64));
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9LZj_entry() //  [R1]
         { info_tbl: [(c9NOy,
                       label: sat_s9LZj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NOy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9NOE; else goto c9NOF;
       c9NOE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9NOF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c9NOv_info;
           _s9LZd::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s9LZd::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9NOK; else goto c9NOw;
       u9NOK: // global
           call _c9NOv(R1) args: 0, res: 0, upd: 0;
       c9NOw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9NOv() //  [R1]
         { info_tbl: [(c9NOv,
                       label: block_c9NOv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NOv: // global
           _s9LZd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9NOB_info;
           R4 = _s9LZd::P64;
           R3 = I64[R1 + 7];
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9NOB() //  [R1, R2]
         { info_tbl: [(c9NOB,
                       label: block_c9NOB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NOB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9NOJ; else goto c9NOI;
       c9NOJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9NOI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9LZk_entry() //  [R1, R2]
         { info_tbl: [(c9NOL,
                       label: sat_s9LZk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NOL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9NOP; else goto c9NOO;
       c9NOP: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9NOO: // global
           _s9LZ5::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s9LZj_info;
           P64[Hp - 8] = _s9LZ5::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = GHC.Conc.Sync.$fShowThreadId2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fShowThreadId1_entry() //  [R2]
         { info_tbl: [(c9NOQ,
                       label: GHC.Conc.Sync.$fShowThreadId1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NOQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9NOU; else goto c9NOT;
       c9NOU: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadId1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9NOT: // global
           I64[Hp - 32] = x_s9LZ5_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s9LZk_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.391407972 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_$cshowList_closure" {
     GHC.Conc.Sync.$fShowThreadId_$cshowList_closure:
         const GHC.Conc.Sync.$fShowThreadId_$cshowList_info;
 },
 GHC.Conc.Sync.$fShowThreadId_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c9NPE,
                       label: GHC.Conc.Sync.$fShowThreadId_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NPE: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$fShowThreadId1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.394860352 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadId_closure" {
     GHC.Conc.Sync.$fShowThreadId_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Conc.Sync.$fShowThreadId_$cshowsPrec_closure+2;
         const GHC.Conc.Sync.$fShowThreadId_$cshow_closure+1;
         const GHC.Conc.Sync.$fShowThreadId_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.396688559 UTC

[section ""data" . reportHeapOverflow1_r9Fv9_closure" {
     reportHeapOverflow1_r9Fv9_closure:
         const reportHeapOverflow1_r9Fv9_info;
 },
 reportHeapOverflow1_r9Fv9_entry() //  []
         { info_tbl: [(c9NPR,
                       label: reportHeapOverflow1_r9Fv9_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NPR: // global
           call "ccall" arg hints:  []  result hints:  [] reportHeapOverflow();
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.400002832 UTC

[section ""data" . GHC.Conc.Sync.reportHeapOverflow_closure" {
     GHC.Conc.Sync.reportHeapOverflow_closure:
         const GHC.Conc.Sync.reportHeapOverflow_info;
 },
 GHC.Conc.Sync.reportHeapOverflow_entry() //  []
         { info_tbl: [(c9NQ4,
                       label: GHC.Conc.Sync.reportHeapOverflow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NQ4: // global
           call reportHeapOverflow1_r9Fv9_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.403494713 UTC

[section ""data" . GHC.Conc.Sync.cmpThread_closure" {
     GHC.Conc.Sync.cmpThread_closure:
         const GHC.Conc.Sync.cmpThread_info;
 },
 GHC.Conc.Sync.cmpThread_entry() //  [R2, R3]
         { info_tbl: [(c9NQi,
                       label: GHC.Conc.Sync.cmpThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NQi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9NQm; else goto c9NQn;
       c9NQm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.cmpThread_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9NQn: // global
           I64[Sp - 16] = block_c9NQf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9NQU; else goto c9NQg;
       u9NQU: // global
           call _c9NQf(R1) args: 0, res: 0, upd: 0;
       c9NQg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NQf() //  [R1]
         { info_tbl: [(c9NQf,
                       label: block_c9NQf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NQf: // global
           I64[Sp] = block_c9NQl_info;
           _s9LZu::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9LZu::P64;
           if (R1 & 7 != 0) goto u9NQT; else goto c9NQp;
       u9NQT: // global
           call _c9NQl(R1) args: 0, res: 0, upd: 0;
       c9NQp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NQl() //  [R1]
         { info_tbl: [(c9NQl,
                       label: block_c9NQl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NQl: // global
           (_s9LZA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9LZB::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9LZA::I64));
           if (_s9LZB::I64 != (-1)) goto u9NQS; else goto c9NQI;
       u9NQS: // global
           if (_s9LZB::I64 != 0) goto c9NQC; else goto c9NQO;
       c9NQC: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9NQO: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9NQI: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.41230348 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadId_$c==_closure" {
     GHC.Conc.Sync.$fEqThreadId_$c==_closure:
         const GHC.Conc.Sync.$fEqThreadId_$c==_info;
 },
 GHC.Conc.Sync.$fEqThreadId_$c==_entry() //  [R2, R3]
         { info_tbl: [(c9NRn,
                       label: GHC.Conc.Sync.$fEqThreadId_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NRn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9NRr; else goto c9NRs;
       c9NRr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadId_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9NRs: // global
           I64[Sp - 16] = block_c9NRk_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9NRS; else goto c9NRl;
       u9NRS: // global
           call _c9NRk(R1) args: 0, res: 0, upd: 0;
       c9NRl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NRk() //  [R1]
         { info_tbl: [(c9NRk,
                       label: block_c9NRk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NRk: // global
           I64[Sp] = block_c9NRq_info;
           _s9LZF::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9LZF::P64;
           if (R1 & 7 != 0) goto u9NRR; else goto c9NRu;
       u9NRR: // global
           call _c9NRq(R1) args: 0, res: 0, upd: 0;
       c9NRu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NRq() //  [R1]
         { info_tbl: [(c9NRq,
                       label: block_c9NRq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NRq: // global
           (_s9LZL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9LZL::I64) == 0 :: W32) goto c9NRN; else goto c9NRH;
       c9NRN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9NRH: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.419765341 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadId_$c/=_closure" {
     GHC.Conc.Sync.$fEqThreadId_$c/=_closure:
         const GHC.Conc.Sync.$fEqThreadId_$c/=_info;
 },
 GHC.Conc.Sync.$fEqThreadId_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c9NSj,
                       label: GHC.Conc.Sync.$fEqThreadId_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NSj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9NSn; else goto c9NSo;
       c9NSn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fEqThreadId_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9NSo: // global
           I64[Sp - 16] = block_c9NSg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9NSO; else goto c9NSh;
       u9NSO: // global
           call _c9NSg(R1) args: 0, res: 0, upd: 0;
       c9NSh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NSg() //  [R1]
         { info_tbl: [(c9NSg,
                       label: block_c9NSg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NSg: // global
           I64[Sp] = block_c9NSm_info;
           _s9LZQ::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9LZQ::P64;
           if (R1 & 7 != 0) goto u9NSN; else goto c9NSq;
       u9NSN: // global
           call _c9NSm(R1) args: 0, res: 0, upd: 0;
       c9NSq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NSm() //  [R1]
         { info_tbl: [(c9NSm,
                       label: block_c9NSm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NSm: // global
           (_s9LZW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9LZW::I64) == 0 :: W32) goto c9NSJ; else goto c9NSD;
       c9NSJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9NSD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.427265457 UTC

[section ""data" . GHC.Conc.Sync.$fEqThreadId_closure" {
     GHC.Conc.Sync.$fEqThreadId_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Conc.Sync.$fEqThreadId_$c==_closure+2;
         const GHC.Conc.Sync.$fEqThreadId_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.429419222 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c<_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c<_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c<_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c<_entry() //  [R2, R3]
         { info_tbl: [(c9NTg,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NTg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9NTk; else goto c9NTl;
       c9NTk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9NTl: // global
           I64[Sp - 16] = block_c9NTd_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9NTL; else goto c9NTe;
       u9NTL: // global
           call _c9NTd(R1) args: 0, res: 0, upd: 0;
       c9NTe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NTd() //  [R1]
         { info_tbl: [(c9NTd,
                       label: block_c9NTd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NTd: // global
           I64[Sp] = block_c9NTj_info;
           _s9M01::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9M01::P64;
           if (R1 & 7 != 0) goto u9NTK; else goto c9NTn;
       u9NTK: // global
           call _c9NTj(R1) args: 0, res: 0, upd: 0;
       c9NTn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NTj() //  [R1]
         { info_tbl: [(c9NTj,
                       label: block_c9NTj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NTj: // global
           (_s9M07::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9M07::I64) == (-1) :: W32) goto c9NTG; else goto c9NTA;
       c9NTG: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9NTA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.436936812 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c>=_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c>=_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c>=_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c9NUc,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NUc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9NUg; else goto c9NUh;
       c9NUg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9NUh: // global
           I64[Sp - 16] = block_c9NU9_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9NUH; else goto c9NUa;
       u9NUH: // global
           call _c9NU9(R1) args: 0, res: 0, upd: 0;
       c9NUa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NU9() //  [R1]
         { info_tbl: [(c9NU9,
                       label: block_c9NU9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NU9: // global
           I64[Sp] = block_c9NUf_info;
           _s9M0c::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9M0c::P64;
           if (R1 & 7 != 0) goto u9NUG; else goto c9NUj;
       u9NUG: // global
           call _c9NUf(R1) args: 0, res: 0, upd: 0;
       c9NUj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NUf() //  [R1]
         { info_tbl: [(c9NUf,
                       label: block_c9NUf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NUf: // global
           (_s9M0i::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           if (%MO_SS_Conv_W64_W32(_s9M0i::I64) == (-1) :: W32) goto c9NUC; else goto c9NUw;
       c9NUC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9NUw: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.445715739 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c>_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c>_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c>_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c>_entry() //  [R2, R3]
         { info_tbl: [(c9NV8,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NV8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9NVc; else goto c9NVd;
       c9NVc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9NVd: // global
           I64[Sp - 16] = block_c9NV5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9NVK; else goto c9NV6;
       u9NVK: // global
           call _c9NV5(R1) args: 0, res: 0, upd: 0;
       c9NV6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NV5() //  [R1]
         { info_tbl: [(c9NV5,
                       label: block_c9NV5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NV5: // global
           I64[Sp] = block_c9NVb_info;
           _s9M0n::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9M0n::P64;
           if (R1 & 7 != 0) goto u9NVJ; else goto c9NVf;
       u9NVJ: // global
           call _c9NVb(R1) args: 0, res: 0, upd: 0;
       c9NVf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NVb() //  [R1]
         { info_tbl: [(c9NVb,
                       label: block_c9NVb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NVb: // global
           (_s9M0t::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9M0u::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9M0t::I64));
           if (_s9M0u::I64 == (-1)) goto c9NVE; else goto u9NVI;
       u9NVI: // global
           if (_s9M0u::I64 == 0) goto c9NVE; else goto c9NVs;
       c9NVE: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9NVs: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.453282333 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$c<=_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$c<=_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$c<=_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c9NWb,
                       label: GHC.Conc.Sync.$fOrdThreadId_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NWb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9NWf; else goto c9NWg;
       c9NWf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9NWg: // global
           I64[Sp - 16] = block_c9NW8_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9NWN; else goto c9NW9;
       u9NWN: // global
           call _c9NW8(R1) args: 0, res: 0, upd: 0;
       c9NW9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NW8() //  [R1]
         { info_tbl: [(c9NW8,
                       label: block_c9NW8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NW8: // global
           I64[Sp] = block_c9NWe_info;
           _s9M0y::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9M0y::P64;
           if (R1 & 7 != 0) goto u9NWM; else goto c9NWi;
       u9NWM: // global
           call _c9NWe(R1) args: 0, res: 0, upd: 0;
       c9NWi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NWe() //  [R1]
         { info_tbl: [(c9NWe,
                       label: block_c9NWe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NWe: // global
           (_s9M0E::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9M0F::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9M0E::I64));
           if (_s9M0F::I64 == (-1)) goto c9NWH; else goto u9NWL;
       u9NWL: // global
           if (_s9M0F::I64 == 0) goto c9NWH; else goto c9NWv;
       c9NWH: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9NWv: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.461064295 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$cmax_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$cmax_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$cmax_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c9NXe,
                       label: GHC.Conc.Sync.$fOrdThreadId_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NXe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9NXi; else goto c9NXj;
       c9NXi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9NXj: // global
           I64[Sp - 16] = block_c9NXb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9NXQ; else goto c9NXc;
       u9NXQ: // global
           call _c9NXb(R1) args: 0, res: 0, upd: 0;
       c9NXc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NXb() //  [R1]
         { info_tbl: [(c9NXb,
                       label: block_c9NXb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NXb: // global
           I64[Sp - 8] = block_c9NXh_info;
           _s9M0I::P64 = R1;
           _s9M0J::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9M0J::P64;
           P64[Sp + 8] = _s9M0I::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9NXP; else goto c9NXl;
       u9NXP: // global
           call _c9NXh(R1) args: 0, res: 0, upd: 0;
       c9NXl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NXh() //  [R1]
         { info_tbl: [(c9NXh,
                       label: block_c9NXh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NXh: // global
           _s9M0I::P64 = P64[Sp + 16];
           (_s9M0P::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9M0Q::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9M0P::I64));
           if (_s9M0Q::I64 == (-1)) goto c9NXK; else goto u9NXO;
       u9NXO: // global
           if (_s9M0Q::I64 == 0) goto c9NXK; else goto c9NXy;
       c9NXK: // global
           R1 = _s9M0I::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9NXy: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.469329138 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_$cmin_closure" {
     GHC.Conc.Sync.$fOrdThreadId_$cmin_closure:
         const GHC.Conc.Sync.$fOrdThreadId_$cmin_info;
 },
 GHC.Conc.Sync.$fOrdThreadId_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c9NYh,
                       label: GHC.Conc.Sync.$fOrdThreadId_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NYh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9NYl; else goto c9NYm;
       c9NYl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fOrdThreadId_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9NYm: // global
           I64[Sp - 16] = block_c9NYe_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9NYT; else goto c9NYf;
       u9NYT: // global
           call _c9NYe(R1) args: 0, res: 0, upd: 0;
       c9NYf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NYe() //  [R1]
         { info_tbl: [(c9NYe,
                       label: block_c9NYe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NYe: // global
           I64[Sp - 8] = block_c9NYk_info;
           _s9M0T::P64 = R1;
           _s9M0U::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp] = _s9M0U::P64;
           P64[Sp + 8] = _s9M0T::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9NYS; else goto c9NYo;
       u9NYS: // global
           call _c9NYk(R1) args: 0, res: 0, upd: 0;
       c9NYo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9NYk() //  [R1]
         { info_tbl: [(c9NYk,
                       label: block_c9NYk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NYk: // global
           _s9M0T::P64 = P64[Sp + 16];
           (_s9M10::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [signed] cmp_thread(P64[R1 + 7], P64[Sp + 8]);
           _s9M0V::P64 = R1;
           _s9M11::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_s9M10::I64));
           if (_s9M11::I64 == (-1)) goto c9NYN; else goto u9NYR;
       u9NYR: // global
           if (_s9M11::I64 == 0) goto c9NYN; else goto c9NYB;
       c9NYN: // global
           R1 = _s9M0V::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9NYB: // global
           R1 = _s9M0T::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.476682955 UTC

[section ""data" . GHC.Conc.Sync.$fOrdThreadId_closure" {
     GHC.Conc.Sync.$fOrdThreadId_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Conc.Sync.$fEqThreadId_closure+1;
         const GHC.Conc.Sync.cmpThread_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c<_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c<=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c>_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$c>=_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$cmax_closure+2;
         const GHC.Conc.Sync.$fOrdThreadId_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.479087382 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus10_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus10_bytes:
         I8[] [84,104,114,101,97,100,82,117,110,110,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.48090828 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus9_closure" {
     GHC.Conc.Sync.$fShowThreadStatus9_closure:
         const GHC.Conc.Sync.$fShowThreadStatus9_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus9_entry() //  [R1]
         { info_tbl: [(c9NZl,
                       label: GHC.Conc.Sync.$fShowThreadStatus9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NZl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9NZm; else goto c9NZn;
       c9NZm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9NZn: // global
           (_c9NZi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9NZi::I64 == 0) goto c9NZk; else goto c9NZj;
       c9NZk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9NZj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9NZi::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.484721679 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus8_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus8_bytes:
         I8[] [84,104,114,101,97,100,70,105,110,105,115,104,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.486974726 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus7_closure" {
     GHC.Conc.Sync.$fShowThreadStatus7_closure:
         const GHC.Conc.Sync.$fShowThreadStatus7_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus7_entry() //  [R1]
         { info_tbl: [(c9NZD,
                       label: GHC.Conc.Sync.$fShowThreadStatus7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NZD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9NZE; else goto c9NZF;
       c9NZE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9NZF: // global
           (_c9NZA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9NZA::I64 == 0) goto c9NZC; else goto c9NZB;
       c9NZC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9NZB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9NZA::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus8_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.490848192 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus6_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus6_bytes:
         I8[] [84,104,114,101,97,100,66,108,111,99,107,101,100,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.492600055 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus5_closure" {
     GHC.Conc.Sync.$fShowThreadStatus5_closure:
         const GHC.Conc.Sync.$fShowThreadStatus5_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus5_entry() //  [R1]
         { info_tbl: [(c9NZV,
                       label: GHC.Conc.Sync.$fShowThreadStatus5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9NZV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9NZW; else goto c9NZX;
       c9NZW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9NZX: // global
           (_c9NZS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9NZS::I64 == 0) goto c9NZU; else goto c9NZT;
       c9NZU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9NZT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9NZS::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.496266862 UTC

[section ""cstring" . GHC.Conc.Sync.$fShowThreadStatus4_bytes" {
     GHC.Conc.Sync.$fShowThreadStatus4_bytes:
         I8[] [84,104,114,101,97,100,68,105,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.498500691 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus3_closure" {
     GHC.Conc.Sync.$fShowThreadStatus3_closure:
         const GHC.Conc.Sync.$fShowThreadStatus3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus3_entry() //  [R1]
         { info_tbl: [(c9O0d,
                       label: GHC.Conc.Sync.$fShowThreadStatus3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O0d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9O0e; else goto c9O0f;
       c9O0e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9O0f: // global
           (_c9O0a::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9O0a::I64 == 0) goto c9O0c; else goto c9O0b;
       c9O0c: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9O0b: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9O0a::I64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.503321489 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure:
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_info;
         const 0;
 },
 sat_s9M1a_entry() //  [R1]
         { info_tbl: [(c9O0L,
                       label: sat_s9M1a_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O0L: // global
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M1c_entry() //  [R1]
         { info_tbl: [(c9O0Y,
                       label: sat_s9M1c_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O0Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9O12; else goto c9O11;
       c9O12: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9O11: // global
           _s9M14::P64 = P64[R1 + 16];
           _s9M16::P64 = P64[R1 + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s9M14::P64;
           R3 = Hp - 14;
           R2 = _s9M16::P64;
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M1d_entry() //  [R1]
         { info_tbl: [(c9O13,
                       label: sat_s9M1d_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O13: // global
           _s9M1d::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c9O14; else goto c9O15;
       c9O15: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9O17; else goto c9O16;
       c9O17: // global
           HpAlloc = 32;
           goto c9O14;
       c9O14: // global
           R1 = _s9M1d::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9O16: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s9M1d::P64;
           _s9M14::P64 = P64[_s9M1d::P64 + 16];
           _s9M16::P64 = P64[_s9M1d::P64 + 24];
           I64[Hp - 24] = sat_s9M1c_info;
           P64[Hp - 8] = _s9M14::P64;
           P64[Hp] = _s9M16::P64;
           R3 = Hp - 24;
           R2 = GHC.Conc.Sync.$fShowThreadStatus5_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c9O1e,
                       label: GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O1e: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9O1f; else goto c9O1g;
       c9O1f: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9O1g: // global
           I64[Sp - 24] = block_c9O0s_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9O1z; else goto c9O0t;
       u9O1z: // global
           call _c9O0s(R1) args: 0, res: 0, upd: 0;
       c9O0t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O0s() //  [R1]
         { info_tbl: [(c9O0s,
                       label: block_c9O0s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O0s: // global
           _s9M14::P64 = P64[Sp + 16];
           _c9O1d::P64 = R1 & 7;
           if (_c9O1d::P64 < 3) goto u9O1w; else goto u9O1x;
       u9O1w: // global
           if (_c9O1d::P64 < 2) goto c9O19; else goto c9O1a;
       c9O19: // global
           R3 = _s9M14::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus9_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9O1a: // global
           R3 = _s9M14::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus7_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       u9O1x: // global
           if (_c9O1d::P64 < 4) goto c9O1b; else goto c9O1c;
       c9O1b: // global
           I64[Sp] = block_c9O0z_info;
           _s9M16::P64 = P64[R1 + 5];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9M16::P64;
           if (R1 & 7 != 0) goto u9O1y; else goto c9O0A;
       u9O1y: // global
           call _c9O0z(R1) args: 0, res: 0, upd: 0;
       c9O0A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c9O1c: // global
           R3 = _s9M14::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus3_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _c9O0z() //  [R1]
         { info_tbl: [(c9O0z,
                       label: block_c9O0z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O0z: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c9O1o; else goto c9O1n;
       c9O1o: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9O1n: // global
           _s9M14::P64 = P64[Sp + 16];
           _s9M16::P64 = P64[Sp + 8];
           if (%MO_S_Lt_W64(I64[R1 + 7], 11)) goto c9O1q; else goto c9O1s;
       c9O1q: // global
           I64[Hp - 48] = sat_s9M1a_info;
           P64[Hp - 32] = _s9M14::P64;
           P64[Hp - 24] = _s9M16::P64;
           _c9O0H::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c9O0H::P64;
           R2 = GHC.Conc.Sync.$fShowThreadStatus5_closure;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9O1s: // global
           I64[Hp - 48] = sat_s9M1d_info;
           P64[Hp - 32] = _s9M14::P64;
           P64[Hp - 24] = _s9M16::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.519021602 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure:
         const GHC.Conc.Sync.$fShowThreadStatus_$cshow_info;
         const 0;
 },
 sat_s9M1h_entry() //  [R1]
         { info_tbl: [(c9O2p,
                       label: sat_s9M1h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O2p: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           call GHC.Conc.Sync.$w$cshowsPrec_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fShowThreadStatus_$cshow_entry() //  [R2]
         { info_tbl: [(c9O2y,
                       label: GHC.Conc.Sync.$fShowThreadStatus_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O2y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9O2z; else goto c9O2A;
       c9O2z: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9O2A: // global
           I64[Sp - 8] = block_c9O2e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9O2N; else goto c9O2f;
       u9O2N: // global
           call _c9O2e(R1) args: 0, res: 0, upd: 0;
       c9O2f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O2e() //  [R1]
         { info_tbl: [(c9O2e,
                       label: block_c9O2e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O2e: // global
           _c9O2x::P64 = R1 & 7;
           if (_c9O2x::P64 < 3) goto u9O2L; else goto u9O2M;
       u9O2L: // global
           if (_c9O2x::P64 < 2) goto c9O2t; else goto c9O2u;
       c9O2t: // global
           R1 = GHC.Conc.Sync.$fShowThreadStatus9_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c9O2u: // global
           R1 = GHC.Conc.Sync.$fShowThreadStatus7_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u9O2M: // global
           if (_c9O2x::P64 < 4) goto c9O2v; else goto c9O2w;
       c9O2v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9O2H; else goto c9O2G;
       c9O2H: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9O2G: // global
           _s9M1g::P64 = P64[R1 + 5];
           I64[Hp - 16] = sat_s9M1h_info;
           P64[Hp] = _s9M1g::P64;
           R3 = Hp - 16;
           R2 = GHC.Conc.Sync.$fShowThreadStatus5_closure;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c9O2w: // global
           R1 = GHC.Conc.Sync.$fShowThreadStatus3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.526953788 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus2_closure" {
     GHC.Conc.Sync.$fShowThreadStatus2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.528762556 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus1_closure" {
     GHC.Conc.Sync.$fShowThreadStatus1_closure:
         const GHC.Conc.Sync.$fShowThreadStatus1_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus1_entry() //  [R2, R3]
         { info_tbl: [(c9O3c,
                       label: GHC.Conc.Sync.$fShowThreadStatus1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O3c: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$fShowThreadStatus2_closure+1;
           call GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.532172343 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_$cshowList_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_$cshowList_closure:
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowList_info;
         const 0;
 },
 GHC.Conc.Sync.$fShowThreadStatus_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c9O3n,
                       label: GHC.Conc.Sync.$fShowThreadStatus_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O3n: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Conc.Sync.$fShowThreadStatus1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.535480898 UTC

[section ""data" . GHC.Conc.Sync.$fShowThreadStatus_closure" {
     GHC.Conc.Sync.$fShowThreadStatus_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure+3;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure+1;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.537587917 UTC

[section ""data" . GHC.Conc.Sync.killThread2_closure" {
     GHC.Conc.Sync.killThread2_closure:
         const GHC.Conc.Sync.killThread2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.killThread2_entry() //  [R1]
         { info_tbl: [(c9O3B,
                       label: GHC.Conc.Sync.killThread2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O3B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9O3C; else goto c9O3D;
       c9O3C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9O3D: // global
           (_c9O3y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9O3y::I64 == 0) goto c9O3A; else goto c9O3z;
       c9O3A: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9O3z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9O3y::I64;
           R2 = GHC.IO.Exception.ThreadKilled_closure+3;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.541734993 UTC

[section ""data" . GHC.Conc.Sync.killThread1_closure" {
     GHC.Conc.Sync.killThread1_closure:
         const GHC.Conc.Sync.killThread1_info;
         const 0;
 },
 GHC.Conc.Sync.killThread1_entry() //  [R2]
         { info_tbl: [(c9O3U,
                       label: GHC.Conc.Sync.killThread1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O3U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9O3Y; else goto c9O3Z;
       c9O3Y: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.killThread1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9O3Z: // global
           I64[Sp - 8] = block_c9O3R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9O43; else goto c9O3S;
       u9O43: // global
           call _c9O3R(R1) args: 0, res: 0, upd: 0;
       c9O3S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O3R() //  [R1]
         { info_tbl: [(c9O3R,
                       label: block_c9O3R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O3R: // global
           I64[Sp] = block_c9O3X_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O3X() //  []
         { info_tbl: [(c9O3X,
                       label: block_c9O3X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O3X: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.548972081 UTC

[section ""data" . GHC.Conc.Sync.killThread_closure" {
     GHC.Conc.Sync.killThread_closure:
         const GHC.Conc.Sync.killThread_info;
         const 0;
 },
 GHC.Conc.Sync.killThread_entry() //  [R2]
         { info_tbl: [(c9O4o,
                       label: GHC.Conc.Sync.killThread_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O4o: // global
           R2 = R2;
           call GHC.Conc.Sync.killThread1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.552630814 UTC

[section ""data" . GHC.Conc.Sync.getNumProcessors1_closure" {
     GHC.Conc.Sync.getNumProcessors1_closure:
         const GHC.Conc.Sync.getNumProcessors1_info;
 },
 GHC.Conc.Sync.getNumProcessors1_entry() //  []
         { info_tbl: [(c9O4C,
                       label: GHC.Conc.Sync.getNumProcessors1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O4C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9O4L; else goto c9O4K;
       c9O4L: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.getNumProcessors1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9O4K: // global
           (_s9M1t::I64) = call "ccall" arg hints:  []  result hints:  [] getNumberOfProcessors();
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s9M1t::I64));
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.556298316 UTC

[section ""data" . GHC.Conc.Sync.getNumProcessors_closure" {
     GHC.Conc.Sync.getNumProcessors_closure:
         const GHC.Conc.Sync.getNumProcessors_info;
 },
 GHC.Conc.Sync.getNumProcessors_entry() //  []
         { info_tbl: [(c9O4X,
                       label: GHC.Conc.Sync.getNumProcessors_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O4X: // global
           call GHC.Conc.Sync.getNumProcessors1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.559276186 UTC

[section ""data" . GHC.Conc.Sync.threadStatus7_closure" {
     GHC.Conc.Sync.threadStatus7_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnOther_closure+6;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.560985233 UTC

[section ""data" . GHC.Conc.Sync.threadStatus6_closure" {
     GHC.Conc.Sync.threadStatus6_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnMVar_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.562932565 UTC

[section ""data" . GHC.Conc.Sync.threadStatus2_closure" {
     GHC.Conc.Sync.threadStatus2_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnException_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.564585053 UTC

[section ""data" . GHC.Conc.Sync.threadStatus3_closure" {
     GHC.Conc.Sync.threadStatus3_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.566310394 UTC

[section ""data" . GHC.Conc.Sync.threadStatus4_closure" {
     GHC.Conc.Sync.threadStatus4_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnSTM_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.56798676 UTC

[section ""data" . GHC.Conc.Sync.threadStatus5_closure" {
     GHC.Conc.Sync.threadStatus5_closure:
         const GHC.Conc.Sync.ThreadBlocked_con_info;
         const GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.570481575 UTC

[section ""data" . GHC.Conc.Sync.$wthreadStatus_closure" {
     GHC.Conc.Sync.$wthreadStatus_closure:
         const GHC.Conc.Sync.$wthreadStatus_info;
 },
 sat_s9M1F_entry() //  [R1]
         { info_tbl: [(c9O5z,
                       label: sat_s9M1F_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O5z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9O5A; else goto c9O5B;
       c9O5A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9O5B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _s9M1E::I64 = I64[R1 + 16];
           if (%MO_S_Ge_W64(_s9M1E::I64, 18)) goto c9O5o; else goto u9O5C;
       u9O5C: // global
           if (%MO_S_Lt_W64(_s9M1E::I64, 0)) goto c9O5o; else goto u9O5D;
       u9O5D: // global
           switch [0 .. 17] _s9M1E::I64 {
               case 0 : goto c9O5p;
               case 1 : goto c9O5w;
               case 2 : goto c9O5r;
               case 6 : goto c9O5s;
               case 10, 11 : goto c9O5u;
               case 12 : goto c9O5v;
               case 14 : goto c9O5w;
               case 16 : goto c9O5x;
               case 17 : goto c9O5y;
               default: {goto c9O5o;}
           }
       c9O5y: // global
           R1 = GHC.Conc.Sync.ThreadDied_closure+4;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9O5x: // global
           R1 = GHC.Conc.Sync.ThreadFinished_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9O5v: // global
           R1 = GHC.Conc.Sync.threadStatus2_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9O5u: // global
           R1 = GHC.Conc.Sync.threadStatus3_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9O5s: // global
           R1 = GHC.Conc.Sync.threadStatus4_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9O5r: // global
           R1 = GHC.Conc.Sync.threadStatus5_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9O5w: // global
           R1 = GHC.Conc.Sync.threadStatus6_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9O5p: // global
           R1 = GHC.Conc.Sync.ThreadRunning_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c9O5o: // global
           R1 = GHC.Conc.Sync.threadStatus7_closure+3;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$wthreadStatus_entry() //  [R2]
         { info_tbl: [(c9O5E,
                       label: GHC.Conc.Sync.$wthreadStatus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O5E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9O5F; else goto c9O5G;
       c9O5F: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.$wthreadStatus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9O5G: // global
           I64[Sp - 8] = block_c9O5e_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_threadStatus#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O5e() //  [R1]
         { info_tbl: [(c9O5e,
                       label: block_c9O5e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O5e: // global
           I64[Sp] = R1;
           Sp = Sp - 8;
           call _c9O5f() args: 0, res: 0, upd: 0;
     }
 },
 _c9O5f() //  []
         { info_tbl: [(c9O5f,
                       label: block_c9O5f_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O5f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9O5J; else goto c9O5I;
       c9O5J: // global
           HpAlloc = 24;
           I64[Sp] = block_c9O5f_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c9O5I: // global
           I64[Hp - 16] = sat_s9M1F_info;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.581771421 UTC

[section ""data" . GHC.Conc.Sync.threadStatus1_closure" {
     GHC.Conc.Sync.threadStatus1_closure:
         const GHC.Conc.Sync.threadStatus1_info;
 },
 GHC.Conc.Sync.threadStatus1_entry() //  [R2]
         { info_tbl: [(c9O6q,
                       label: GHC.Conc.Sync.threadStatus1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O6q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9O6r; else goto c9O6s;
       c9O6r: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.threadStatus1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9O6s: // global
           I64[Sp - 8] = block_c9O6n_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9O6w; else goto c9O6o;
       u9O6w: // global
           call _c9O6n(R1) args: 0, res: 0, upd: 0;
       c9O6o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O6n() //  [R1]
         { info_tbl: [(c9O6n,
                       label: block_c9O6n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O6n: // global
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wthreadStatus_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.587257235 UTC

[section ""data" . GHC.Conc.Sync.threadStatus_closure" {
     GHC.Conc.Sync.threadStatus_closure:
         const GHC.Conc.Sync.threadStatus_info;
 },
 GHC.Conc.Sync.threadStatus_entry() //  [R2]
         { info_tbl: [(c9O6L,
                       label: GHC.Conc.Sync.threadStatus_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O6L: // global
           R2 = R2;
           call GHC.Conc.Sync.threadStatus1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.590670008 UTC

[section ""data" . GHC.Conc.Sync.$fFunctorSTM2_closure" {
     GHC.Conc.Sync.$fFunctorSTM2_closure:
         const GHC.Conc.Sync.$fFunctorSTM2_info;
 },
 GHC.Conc.Sync.$fFunctorSTM2_entry() //  [R2, R3]
         { info_tbl: [(c9O6Z,
                       label: GHC.Conc.Sync.$fFunctorSTM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O6Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9O70; else goto c9O71;
       c9O70: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fFunctorSTM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9O71: // global
           I64[Sp - 16] = block_c9O6W_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O6W() //  [R1]
         { info_tbl: [(c9O6W,
                       label: block_c9O6W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O6W: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9O74; else goto c9O73;
       c9O74: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9O73: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.596129717 UTC

[section ""data" . GHC.Conc.Sync.$fFunctorSTM1_closure" {
     GHC.Conc.Sync.$fFunctorSTM1_closure:
         const GHC.Conc.Sync.$fFunctorSTM1_info;
 },
 GHC.Conc.Sync.$fFunctorSTM1_entry() //  [R2, R3]
         { info_tbl: [(c9O7n,
                       label: GHC.Conc.Sync.$fFunctorSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O7n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9O7o; else goto c9O7p;
       c9O7o: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fFunctorSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9O7p: // global
           I64[Sp - 16] = block_c9O7l_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O7l() //  []
         { info_tbl: [(c9O7l,
                       label: block_c9O7l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O7l: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.601637897 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM2_closure" {
     GHC.Conc.Sync.$fApplicativeSTM2_closure:
         const GHC.Conc.Sync.$fApplicativeSTM2_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM2_entry() //  [R2, R3]
         { info_tbl: [(c9O7K,
                       label: GHC.Conc.Sync.$fApplicativeSTM2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O7K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9O7L; else goto c9O7M;
       c9O7L: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fApplicativeSTM2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9O7M: // global
           I64[Sp - 16] = block_c9O7F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O7F() //  [R1]
         { info_tbl: [(c9O7F,
                       label: block_c9O7F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O7F: // global
           I64[Sp] = block_c9O7H_info;
           _s9M22::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9M22::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O7H() //  [R1]
         { info_tbl: [(c9O7H,
                       label: block_c9O7H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O7H: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c9O7Q; else goto c9O7P;
       c9O7Q: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9O7P: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.608958485 UTC

[section ""data" . $cliftA2_r9Fva_closure" {
     $cliftA2_r9Fva_closure:
         const $cliftA2_r9Fva_info;
 },
 $cliftA2_r9Fva_entry() //  [R2, R3, R4]
         { info_tbl: [(c9O8g,
                       label: $cliftA2_r9Fva_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O8g: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9O8h; else goto c9O8i;
       c9O8h: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cliftA2_r9Fva_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9O8i: // global
           I64[Sp - 24] = block_c9O8b_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O8b() //  [R1]
         { info_tbl: [(c9O8b,
                       label: block_c9O8b_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O8b: // global
           I64[Sp] = block_c9O8d_info;
           _s9M2d::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s9M2d::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O8d() //  [R1]
         { info_tbl: [(c9O8d,
                       label: block_c9O8d_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O8d: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9O8m; else goto c9O8l;
       c9O8m: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9O8l: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.617005221 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_closure:
         const GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_entry() //  [R2, R3, R4]
         { info_tbl: [(c9O8I,
                       label: GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O8I: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cliftA2_r9Fva_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.620475603 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM1_closure" {
     GHC.Conc.Sync.$fApplicativeSTM1_closure:
         const GHC.Conc.Sync.$fApplicativeSTM1_info;
 },
 GHC.Conc.Sync.$fApplicativeSTM1_entry() //  [R2, R3]
         { info_tbl: [(c9O8X,
                       label: GHC.Conc.Sync.$fApplicativeSTM1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O8X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9O8Y; else goto c9O8Z;
       c9O8Y: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fApplicativeSTM1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9O8Z: // global
           I64[Sp - 16] = block_c9O8T_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O8T() //  [R1]
         { info_tbl: [(c9O8T,
                       label: block_c9O8T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O8T: // global
           I64[Sp] = block_c9O8V_info;
           _s9M2n::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9M2n::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O8V() //  []
         { info_tbl: [(c9O8V,
                       label: block_c9O8V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O8V: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.627274634 UTC

[section ""data" . GHC.Conc.Sync.$fFunctorSTM_closure" {
     GHC.Conc.Sync.$fFunctorSTM_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Conc.Sync.$fFunctorSTM2_closure+3;
         const GHC.Conc.Sync.$fFunctorSTM1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.62899032 UTC

[section ""data" . GHC.Conc.Sync.$fApplicativeSTM_closure" {
     GHC.Conc.Sync.$fApplicativeSTM_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Conc.Sync.$fFunctorSTM_closure+1;
         const GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure+2;
         const GHC.Conc.Sync.$fApplicativeSTM2_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM_$cliftA2_closure+4;
         const GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM1_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.630971797 UTC

[section ""data" . lvl_r9Fvb_closure" {
     lvl_r9Fvb_closure:
         const lvl_r9Fvb_info;
         const 0;
 },
 lvl_r9Fvb_entry() //  [R2]
         { info_tbl: [(c9O9m,
                       label: lvl_r9Fvb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O9m: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.634248166 UTC

[section ""data" . GHC.Conc.Sync.$fMonadSTM_closure" {
     GHC.Conc.Sync.$fMonadSTM_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Conc.Sync.$fApplicativeSTM_closure+1;
         const GHC.Conc.Sync.$fMonadSTM_$c>>=_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM_$c*>_closure+3;
         const GHC.Conc.Sync.$fApplicativeSTM_$cpure_closure+2;
         const lvl_r9Fvb_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.636107092 UTC

[section ""data" . GHC.Conc.Sync.always2_closure" {
     GHC.Conc.Sync.always2_closure:
         const GHC.Conc.Sync.always2_info;
 },
 GHC.Conc.Sync.always2_entry() //  []
         { info_tbl: [(c9O9y,
                       label: GHC.Conc.Sync.always2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O9y: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.63999544 UTC

[section ""data" . GHC.Conc.Sync.alwaysSucceeds1_closure" {
     GHC.Conc.Sync.alwaysSucceeds1_closure:
         const GHC.Conc.Sync.alwaysSucceeds1_info;
 },
 sat_s9M2z_entry() //  [R1]
         { info_tbl: [(c9O9S,
                       label: sat_s9M2z_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O9S: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9O9T; else goto c9O9U;
       c9O9T: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9O9U: // global
           I64[Sp - 8] = block_c9O9Q_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O9Q() //  []
         { info_tbl: [(c9O9Q,
                       label: block_c9O9Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O9Q: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.alwaysSucceeds1_entry() //  [R2]
         { info_tbl: [(c9Oa0,
                       label: GHC.Conc.Sync.alwaysSucceeds1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oa0: // global
           _s9M2t::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9Oa1; else goto c9Oa2;
       c9Oa2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Oa4; else goto c9Oa3;
       c9Oa4: // global
           HpAlloc = 16;
           goto c9Oa1;
       c9Oa1: // global
           R2 = _s9M2t::P64;
           R1 = GHC.Conc.Sync.alwaysSucceeds1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Oa3: // global
           I64[Hp - 8] = sat_s9M2z_info;
           P64[Hp] = _s9M2t::P64;
           I64[Sp - 16] = block_c9O9W_info;
           R2 = GHC.Conc.Sync.always2_closure+1;
           R1 = Hp - 7;
           P64[Sp - 8] = _s9M2t::P64;
           Sp = Sp - 16;
           call stg_catchRetry#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O9W() //  []
         { info_tbl: [(c9O9W,
                       label: block_c9O9W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O9W: // global
           _s9M2t::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9O9Y_info;
           R1 = _s9M2t::P64;
           Sp = Sp + 8;
           call stg_check#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9O9Y() //  []
         { info_tbl: [(c9O9Y,
                       label: block_c9O9Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9O9Y: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.650831401 UTC

[section ""data" . GHC.Conc.Sync.alwaysSucceeds_closure" {
     GHC.Conc.Sync.alwaysSucceeds_closure:
         const GHC.Conc.Sync.alwaysSucceeds_info;
 },
 GHC.Conc.Sync.alwaysSucceeds_entry() //  [R2]
         { info_tbl: [(c9Oaz,
                       label: GHC.Conc.Sync.alwaysSucceeds_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oaz: // global
           R2 = R2;
           call GHC.Conc.Sync.alwaysSucceeds1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.6541071 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM2_closure" {
     GHC.Conc.Sync.$fAlternativeSTM2_closure:
         const GHC.Conc.Sync.$fAlternativeSTM2_info;
 },
 GHC.Conc.Sync.$fAlternativeSTM2_entry() //  []
         { info_tbl: [(c9OaK,
                       label: GHC.Conc.Sync.$fAlternativeSTM2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OaK: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.657776557 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM3_closure" {
     GHC.Conc.Sync.$fAlternativeSTM3_closure:
         const GHC.Conc.Sync.$fAlternativeSTM3_info;
 },
 some_v_s9M2H_entry() //  [R1]
         { info_tbl: [(c9Ob7,
                       label: some_v_s9M2H_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ob7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Ob8; else goto c9Ob9;
       c9Ob8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Ob9: // global
           I64[Sp - 16] = block_c9Ob2_info;
           _s9M2H::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s9M2H::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ob2() //  [R1]
         { info_tbl: [(c9Ob2,
                       label: block_c9Ob2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ob2: // global
           I64[Sp] = block_c9Ob4_info;
           R2 = GHC.Conc.Sync.$fAlternativeSTM2_closure+1;
           _s9M2L::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9M2L::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ob4() //  [R1]
         { info_tbl: [(c9Ob4,
                       label: block_c9Ob4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ob4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Obd; else goto c9Obc;
       c9Obd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Obc: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fAlternativeSTM3_entry() //  [R2]
         { info_tbl: [(c9Obe,
                       label: GHC.Conc.Sync.$fAlternativeSTM3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Obe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Obi; else goto c9Obh;
       c9Obi: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fAlternativeSTM3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Obh: // global
           I64[Hp - 8] = some_v_s9M2H_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call some_v_s9M2H_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.666979386 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM1_closure" {
     GHC.Conc.Sync.$fAlternativeSTM1_closure:
         const GHC.Conc.Sync.$fAlternativeSTM1_info;
 },
 many_v_s9M2S_entry() //  [R1]
         { info_tbl: [(c9ObS,
                       label: many_v_s9M2S_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ObS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9ObT; else goto c9ObU;
       c9ObT: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9ObU: // global
           I64[Sp - 16] = block_c9ObN_info;
           _s9M2T::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s9M2T::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ObN() //  [R1]
         { info_tbl: [(c9ObN,
                       label: block_c9ObN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ObN: // global
           I64[Sp] = block_c9ObP_info;
           _s9M2X::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s9M2X::P64;
           call many_v1_s9M2T_entry(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ObP() //  [R1]
         { info_tbl: [(c9ObP,
                       label: block_c9ObP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ObP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9ObY; else goto c9ObX;
       c9ObY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9ObX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 many_v1_s9M2T_entry() //  [R1]
         { info_tbl: [(c9Oc3,
                       label: many_v1_s9M2T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oc3: // global
           R2 = GHC.Conc.Sync.$fAlternativeSTM2_closure+1;
           R1 = P64[R1 + 7];
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$fAlternativeSTM1_entry() //  [R2]
         { info_tbl: [(c9Oc6,
                       label: GHC.Conc.Sync.$fAlternativeSTM1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oc6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9Oca; else goto c9Oc9;
       c9Oca: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Conc.Sync.$fAlternativeSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Oc9: // global
           I64[Hp - 32] = many_v_s9M2S_info;
           P64[Hp - 24] = R2;
           _c9ObI::P64 = Hp - 7;
           P64[Hp - 16] = _c9ObI::P64;
           I64[Hp - 8] = many_v1_s9M2T_info;
           P64[Hp] = Hp - 31;
           R1 = _c9ObI::P64;
           call many_v1_s9M2T_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.677476721 UTC

[section ""data" . sat_s9M33_closure" {
     sat_s9M33_closure:
         const sat_s9M33_info;
         const 0;
 },
 sat_s9M33_entry() //  [R2, R3]
         { info_tbl: [(c9OcE,
                       label: sat_s9M33_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OcE: // global
           _B3::P64 = R2;
           R2 = R3;
           R1 = _B3::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.681234376 UTC

[section ""data" . sat_s9M32_closure" {
     sat_s9M32_closure:
         const sat_s9M32_info;
         const 0;
 },
 sat_s9M32_entry() //  []
         { info_tbl: [(c9OcP,
                       label: sat_s9M32_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OcP: // global
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.684176845 UTC

[section ""data" . GHC.Conc.Sync.$fAlternativeSTM_closure" {
     GHC.Conc.Sync.$fAlternativeSTM_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Conc.Sync.$fApplicativeSTM_closure+1;
         const sat_s9M32_closure+1;
         const sat_s9M33_closure+3;
         const GHC.Conc.Sync.$fAlternativeSTM3_closure+2;
         const GHC.Conc.Sync.$fAlternativeSTM1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.68632129 UTC

[section ""data" . sat_s9M35_closure" {
     sat_s9M35_closure:
         const sat_s9M35_info;
         const 0;
 },
 sat_s9M35_entry() //  [R2, R3]
         { info_tbl: [(c9Od1,
                       label: sat_s9M35_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Od1: // global
           _B3::P64 = R2;
           R2 = R3;
           R1 = _B3::P64;
           call stg_catchRetry#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.68944776 UTC

[section ""data" . sat_s9M34_closure" {
     sat_s9M34_closure:
         const sat_s9M34_info;
         const 0;
 },
 sat_s9M34_entry() //  []
         { info_tbl: [(c9Odc,
                       label: sat_s9M34_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Odc: // global
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.692502773 UTC

[section ""data" . GHC.Conc.Sync.$fMonadPlusSTM_closure" {
     GHC.Conc.Sync.$fMonadPlusSTM_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Conc.Sync.$fAlternativeSTM_closure+1;
         const GHC.Conc.Sync.$fMonadSTM_closure+1;
         const sat_s9M34_closure+1;
         const sat_s9M35_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.694281904 UTC

[section ""cstring" . lvl1_r9Fvc_bytes" {
     lvl1_r9Fvc_bytes:
         I8[] [84,114,97,110,115,97,99,116,105,111,110,97,108,32,105,110,118,97,114,105,97,110,116,32,118,105,111,108,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.696198583 UTC

[section ""data" . GHC.Conc.Sync.always3_closure" {
     GHC.Conc.Sync.always3_closure:
         const GHC.Conc.Sync.always3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.always3_entry() //  [R1]
         { info_tbl: [(c9Odt,
                       label: GHC.Conc.Sync.always3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Odt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Odu; else goto c9Odv;
       c9Odu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Odv: // global
           (_c9Odo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Odo::I64 == 0) goto c9Odq; else goto c9Odp;
       c9Odq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Odp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Odo::I64;
           I64[Sp - 24] = block_c9Odr_info;
           R2 = lvl1_r9Fvc_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9Odr() //  [R1]
         { info_tbl: [(c9Odr,
                       label: block_c9Odr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Odr: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.702996065 UTC

[section ""data" . GHC.Conc.Sync.always1_closure" {
     GHC.Conc.Sync.always1_closure:
         const GHC.Conc.Sync.always1_info;
         const 0;
 },
 sat_s9M3f_entry() //  [R1]
         { info_tbl: [(c9Oe3,
                       label: sat_s9M3f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oe3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Oe4; else goto c9Oe5;
       c9Oe4: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Oe5: // global
           I64[Sp - 8] = block_c9OdU_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OdU() //  [R1]
         { info_tbl: [(c9OdU,
                       label: block_c9OdU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OdU: // global
           I64[Sp] = block_c9OdW_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u9Oed; else goto c9OdX;
       u9Oed: // global
           call _c9OdW(R1) args: 0, res: 0, upd: 0;
       c9OdX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OdW() //  [R1]
         { info_tbl: [(c9OdW,
                       label: block_c9OdW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OdW: // global
           if (R1 & 7 == 1) goto c9Oe0; else goto c9Oe1;
       c9Oe0: // global
           R1 = GHC.Conc.Sync.always3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9Oe1: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M3p_entry() //  [R1]
         { info_tbl: [(c9Oeu,
                       label: sat_s9M3p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oeu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Oev; else goto c9Oew;
       c9Oev: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Oew: // global
           I64[Sp - 8] = block_c9Oel_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Oel() //  [R1]
         { info_tbl: [(c9Oel,
                       label: block_c9Oel_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oel: // global
           I64[Sp] = block_c9Oen_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u9OeE; else goto c9Oeo;
       u9OeE: // global
           call _c9Oen(R1) args: 0, res: 0, upd: 0;
       c9Oeo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Oen() //  [R1]
         { info_tbl: [(c9Oen,
                       label: block_c9Oen_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oen: // global
           if (R1 & 7 == 1) goto c9Oer; else goto c9Oes;
       c9Oer: // global
           R1 = GHC.Conc.Sync.always3_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c9Oes: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.always1_entry() //  [R2]
         { info_tbl: [(c9OeH,
                       label: GHC.Conc.Sync.always1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OeH: // global
           _s9M37::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c9OeI; else goto c9OeJ;
       c9OeJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OeL; else goto c9OeK;
       c9OeL: // global
           HpAlloc = 16;
           goto c9OeI;
       c9OeI: // global
           R2 = _s9M37::P64;
           R1 = GHC.Conc.Sync.always1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9OeK: // global
           I64[Hp - 8] = sat_s9M3f_info;
           P64[Hp] = _s9M37::P64;
           I64[Sp - 16] = block_c9Oee_info;
           R2 = GHC.Conc.Sync.always2_closure+1;
           R1 = Hp - 7;
           P64[Sp - 8] = _s9M37::P64;
           Sp = Sp - 16;
           call stg_catchRetry#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Oee() //  [R1]
         { info_tbl: [(c9Oee,
                       label: block_c9Oee_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oee: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OeO; else goto c9OeN;
       c9OeO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OeN: // global
           I64[Hp - 8] = sat_s9M3p_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c9OeF_info;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call stg_check#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OeF() //  []
         { info_tbl: [(c9OeF,
                       label: block_c9OeF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OeF: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.72117292 UTC

[section ""data" . GHC.Conc.Sync.always_closure" {
     GHC.Conc.Sync.always_closure:
         const GHC.Conc.Sync.always_info;
         const 0;
 },
 GHC.Conc.Sync.always_entry() //  [R2]
         { info_tbl: [(c9OfI,
                       label: GHC.Conc.Sync.always_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OfI: // global
           R2 = R2;
           call GHC.Conc.Sync.always1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.724937825 UTC

[section ""cstring" . lvl2_r9Fvd_bytes" {
     lvl2_r9Fvd_bytes:
         I8[] [110,111,32,116,104,114,101,97,100,115,32,116,111,32,114,117,110,58,32,32,105,110,102,105,110,105,116,101,32,108,111,111,112,32,111,114,32,100,101,97,100,108,111,99,107,63]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.726789808 UTC

[section ""data" . lvl3_r9Fve_closure" {
     lvl3_r9Fve_closure:
         const lvl3_r9Fve_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r9Fve_entry() //  [R1]
         { info_tbl: [(c9OfW,
                       label: lvl3_r9Fve_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OfW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9OfX; else goto c9OfY;
       c9OfX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9OfY: // global
           (_c9OfT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9OfT::I64 == 0) goto c9OfV; else goto c9OfU;
       c9OfV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9OfU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9OfT::I64;
           R2 = lvl2_r9Fvd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.731095524 UTC

[section ""data" . lvl4_r9Fvf_closure" {
     lvl4_r9Fvf_closure:
         const lvl4_r9Fvf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r9Fvf_entry() //  [R1]
         { info_tbl: [(c9Ogi,
                       label: lvl4_r9Fvf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ogi: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c9Ogj; else goto c9Ogk;
       c9Ogj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Ogk: // global
           (_c9Oga::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Oga::I64 == 0) goto c9Ogc; else goto c9Ogb;
       c9Ogc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Ogb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Oga::I64;
           I64[Sp - 24] = block_c9Ogd_info;
           R6 = 0;
           R5 = GHC.IO.Exception.$fExceptionDeadlock4_closure;
           R4 = GHC.IO.Exception.$trModule_closure;
           R3 = 11186984538024031318;
           R2 = 18363794241794644491;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _c9Ogd() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(c9Ogd,
                       label: block_c9Ogd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ogd: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _c9Oge() args: 0, res: 0, upd: 0;
     }
 },
 _c9Oge() //  []
         { info_tbl: [(c9Oge,
                       label: block_c9Oge_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oge: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c9Ogn; else goto c9Ogm;
       c9Ogn: // global
           HpAlloc = 48;
           I64[Sp] = block_c9Oge_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       c9Ogm: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.7389014 UTC

[section ""cstring" . lvl5_r9Fvg_bytes" {
     lvl5_r9Fvg_bytes:
         I8[] [37,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.74081724 UTC

[section ""data" . lvl6_r9Fvh_closure" {
     lvl6_r9Fvh_closure:
         const lvl6_r9Fvh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r9Fvh_entry() //  [R1]
         { info_tbl: [(c9OgX,
                       label: lvl6_r9Fvh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OgX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9OgY; else goto c9OgZ;
       c9OgY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9OgZ: // global
           (_c9OgU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9OgU::I64 == 0) goto c9OgW; else goto c9OgV;
       c9OgW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9OgV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9OgU::I64;
           R2 = lvl5_r9Fvg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.745715727 UTC

[section ""data" . lvl7_r9Fvi_closure" {
     lvl7_r9Fvi_closure:
         const lvl7_r9Fvi_info;
 },
 lvl7_r9Fvi_entry() //  [R2]
         { info_tbl: [(c9Ohf,
                       label: lvl7_r9Fvi_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ohf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9Ohg; else goto c9Ohh;
       c9Ohg: // global
           R2 = R2;
           R1 = lvl7_r9Fvi_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Ohh: // global
           I64[Sp - 8] = block_c9Ohc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Ohl; else goto c9Ohd;
       u9Ohl: // global
           call _c9Ohc() args: 0, res: 0, upd: 0;
       c9Ohd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ohc() //  []
         { info_tbl: [(c9Ohc,
                       label: block_c9Ohc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ohc: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.750929272 UTC

[section ""data" . lvl8_r9Fvj_closure" {
     lvl8_r9Fvj_closure:
         const lvl8_r9Fvj_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_r9Fvj_entry() //  [R1]
         { info_tbl: [(c9OhE,
                       label: lvl8_r9Fvj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OhE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9OhF; else goto c9OhG;
       c9OhF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9OhG: // global
           (_c9OhB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9OhB::I64 == 0) goto c9OhD; else goto c9OhC;
       c9OhD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9OhC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9OhB::I64;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           R1 = GHC.IO.Handle.hFlush_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.756141581 UTC

[section ""data" . lvl9_r9Fvk_closure" {
     lvl9_r9Fvk_closure:
         const lvl9_r9Fvk_info;
         const 0;
 },
 msg_s9M3O_entry() //  [R1]
         { info_tbl: [(c9Oia,
                       label: msg_s9M3O_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oia: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c9Oib; else goto c9Oic;
       c9Oib: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Oic: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c9Oi8_info;
           _s9M3F::P64 = P64[R1 + 16];
           R2 = _s9M3F::P64;
           P64[Sp - 32] = _s9M3F::P64;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9Oi8() //  [R1]
         { info_tbl: [(c9Oi8,
                       label: block_c9Oi8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oi8: // global
           I64[Sp] = block_c9Oif_info;
           R3 = lvl4_r9Fvf_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9Oif() //  [R1]
         { info_tbl: [(c9Oif,
                       label: block_c9Oif_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oif: // global
           if (R1 & 7 == 1) goto c9Oin; else goto c9Oiw;
       c9Oin: // global
           _s9M3F::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9Oik_info;
           R2 = _s9M3F::P64;
           Sp = Sp + 8;
           call GHC.Exception.$p2Exception_entry(R2) args: 8, res: 8, upd: 24;
       c9Oiw: // global
           _s9M3G::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c9Oiu_info;
           R1 = _s9M3G::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c9Oik() //  [R1]
         { info_tbl: [(c9Oik,
                       label: block_c9Oik_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oik: // global
           R2 = R1;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = GHC.Conc.Sync.$fShowThreadStatus2_closure+1;
           P64[Sp] = P64[Sp + 8];
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 _c9Oiu() //  []
         { info_tbl: [(c9Oiu,
                       label: block_c9Oiu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oiu: // global
           R1 = lvl3_r9Fve_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s9M47_entry() //  [R1, R2]
         { info_tbl: [(c9OiR,
                       label: sat_s9M47_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OiR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9OiV; else goto c9OiW;
       c9OiV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9OiW: // global
           I64[Sp - 16] = block_c9OiO_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Oj7; else goto c9OiP;
       u9Oj7: // global
           call _c9OiO(R1) args: 0, res: 0, upd: 0;
       c9OiP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OiO() //  [R1]
         { info_tbl: [(c9OiO,
                       label: block_c9OiO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OiO: // global
           I64[Sp] = block_c9OiU_info;
           _s9M41::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s9M41::I64;
           if (R1 & 7 != 0) goto u9Oj6; else goto c9OiY;
       u9Oj6: // global
           call _c9OiU(R1) args: 0, res: 0, upd: 0;
       c9OiY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OiU() //  [R1]
         { info_tbl: [(c9OiU,
                       label: block_c9OiU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OiU: // global
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] errorBelch2(I64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M48_entry() //  [R1, R2]
         { info_tbl: [(c9Oj8,
                       label: sat_s9M48_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oj8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Oj9; else goto c9Oja;
       c9Oj9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Oja: // global
           I64[Sp - 24] = block_c9OiH_info;
           _s9M3O::P64 = P64[R1 + 6];
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 16] = _s9M3O::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OiH() //  [R1]
         { info_tbl: [(c9OiH,
                       label: block_c9OiH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OiH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Ojd; else goto c9Ojc;
       c9Ojd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Ojc: // global
           I64[Hp - 8] = sat_s9M47_info;
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 6;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 lvl9_r9Fvk_entry() //  [R2]
         { info_tbl: [(c9Oje,
                       label: lvl9_r9Fvk_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oje: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Ojf; else goto c9Ojg;
       c9Ojf: // global
           R2 = R2;
           R1 = lvl9_r9Fvk_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Ojg: // global
           I64[Sp - 8] = block_c9OhT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9Ojn; else goto c9OhU;
       u9Ojn: // global
           call _c9OhT(R1) args: 0, res: 0, upd: 0;
       c9OhU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OhT() //  [R1]
         { info_tbl: [(c9OhT,
                       label: block_c9OhT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OhT: // global
           I64[Sp - 16] = block_c9OhY_info;
           _s9M3F::P64 = P64[R1 + 7];
           _s9M3G::P64 = P64[R1 + 15];
           R1 = lvl8_r9Fvj_closure;
           P64[Sp - 8] = _s9M3G::P64;
           P64[Sp] = _s9M3F::P64;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OhY() //  [R1]
         { info_tbl: [(c9OhY,
                       label: block_c9OhY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OhY: // global
           I64[Sp] = block_c9Oi0_info;
           R2 = lvl7_r9Fvi_closure+2;
           R1 = R1;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Oi0() //  []
         { info_tbl: [(c9Oi0,
                       label: block_c9Oi0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oi0: // global
           I64[Sp] = block_c9Oi2_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Oi2() //  [R1]
         { info_tbl: [(c9Oi2,
                       label: block_c9Oi2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oi2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c9Ojm; else goto c9Ojl;
       c9Ojm: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Ojl: // global
           I64[Hp - 40] = msg_s9M3O_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_s9M48_info;
           P64[Hp] = Hp - 40;
           R4 = Hp - 6;
           R3 = lvl6_r9Fvh_closure;
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.785726939 UTC

[section ""data" . lvl10_r9Fvl_closure" {
     lvl10_r9Fvl_closure:
         const lvl10_r9Fvl_info;
         const 0;
 },
 lvl10_r9Fvl_entry() //  []
         { info_tbl: [(c9OkS,
                       label: lvl10_r9Fvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OkS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9OkT; else goto c9OkU;
       c9OkT: // global
           R1 = lvl10_r9Fvl_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9OkU: // global
           I64[Sp - 8] = block_c9OkN_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _c9OkN() //  []
         { info_tbl: [(c9OkN,
                       label: block_c9OkN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OkN: // global
           I64[Sp] = block_c9OkP_info;
           R1 = lvl9_r9Fvk_closure+2;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OkP() //  [R1]
         { info_tbl: [(c9OkP,
                       label: block_c9OkP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OkP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OkY; else goto c9OkX;
       c9OkY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OkX: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.792849928 UTC

[section ""data" . GHC.Conc.Sync.uncaughtExceptionHandler_closure" {
     GHC.Conc.Sync.uncaughtExceptionHandler_closure:
         const GHC.Conc.Sync.uncaughtExceptionHandler_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.uncaughtExceptionHandler_entry() //  [R1]
         { info_tbl: [(c9Olm,
                       label: GHC.Conc.Sync.uncaughtExceptionHandler_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Olm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Oln; else goto c9Olo;
       c9Oln: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9Olo: // global
           (_c9Olh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9Olh::I64 == 0) goto c9Olj; else goto c9Oli;
       c9Olj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9Oli: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9Olh::I64;
           I64[Sp - 24] = block_c9Olk_info;
           Sp = Sp - 24;
           call lvl10_r9Fvl_entry() args: 8, res: 8, upd: 24;
     }
 },
 _c9Olk() //  [R1]
         { info_tbl: [(c9Olk,
                       label: block_c9Olk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Olk: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.798629002 UTC

[section ""data" . GHC.Conc.Sync.setUncaughtExceptionHandler1_closure" {
     GHC.Conc.Sync.setUncaughtExceptionHandler1_closure:
         const GHC.Conc.Sync.setUncaughtExceptionHandler1_info;
         const 0;
 },
 GHC.Conc.Sync.setUncaughtExceptionHandler1_entry() //  [R2]
         { info_tbl: [(c9OlI,
                       label: GHC.Conc.Sync.setUncaughtExceptionHandler1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OlI: // global
           R3 = R2;
           R2 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           call GHC.STRef.writeSTRef1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.801890574 UTC

[section ""data" . GHC.Conc.Sync.setUncaughtExceptionHandler_closure" {
     GHC.Conc.Sync.setUncaughtExceptionHandler_closure:
         const GHC.Conc.Sync.setUncaughtExceptionHandler_info;
         const 0;
 },
 GHC.Conc.Sync.setUncaughtExceptionHandler_entry() //  [R2]
         { info_tbl: [(c9OlT,
                       label: GHC.Conc.Sync.setUncaughtExceptionHandler_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OlT: // global
           R2 = R2;
           call GHC.Conc.Sync.setUncaughtExceptionHandler1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.805047296 UTC

[section ""data" . GHC.Conc.Sync.getUncaughtExceptionHandler1_closure" {
     GHC.Conc.Sync.getUncaughtExceptionHandler1_closure:
         const GHC.Conc.Sync.getUncaughtExceptionHandler1_info;
         const 0;
 },
 GHC.Conc.Sync.getUncaughtExceptionHandler1_entry() //  []
         { info_tbl: [(c9Om4,
                       label: GHC.Conc.Sync.getUncaughtExceptionHandler1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Om4: // global
           R2 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           call GHC.STRef.readSTRef1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.808247022 UTC

[section ""data" . GHC.Conc.Sync.getUncaughtExceptionHandler_closure" {
     GHC.Conc.Sync.getUncaughtExceptionHandler_closure:
         const GHC.Conc.Sync.getUncaughtExceptionHandler_info;
         const 0;
 },
 GHC.Conc.Sync.getUncaughtExceptionHandler_entry() //  []
         { info_tbl: [(c9Omf,
                       label: GHC.Conc.Sync.getUncaughtExceptionHandler_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Omf: // global
           call GHC.Conc.Sync.getUncaughtExceptionHandler1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.812022178 UTC

[section ""data" . GHC.Conc.Sync.reportError1_closure" {
     GHC.Conc.Sync.reportError1_closure:
         const GHC.Conc.Sync.reportError1_info;
         const 0;
 },
 GHC.Conc.Sync.reportError1_entry() //  [R2]
         { info_tbl: [(c9Omt,
                       label: GHC.Conc.Sync.reportError1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Omt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Omu; else goto c9Omv;
       c9Omu: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.reportError1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Omv: // global
           I64[Sp - 16] = block_c9Omq_info;
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Omz; else goto c9Omr;
       u9Omz: // global
           call _c9Omq(R1) args: 0, res: 0, upd: 0;
       c9Omr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Omq() //  [R1]
         { info_tbl: [(c9Omq,
                       label: block_c9Omq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Omq: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.81802709 UTC

[section ""data" . GHC.Conc.Sync.reportError_closure" {
     GHC.Conc.Sync.reportError_closure:
         const GHC.Conc.Sync.reportError_info;
         const 0;
 },
 GHC.Conc.Sync.reportError_entry() //  [R2]
         { info_tbl: [(c9OmP,
                       label: GHC.Conc.Sync.reportError_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OmP: // global
           R2 = R2;
           call GHC.Conc.Sync.reportError1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.822356022 UTC

[section ""data" . GHC.Conc.Sync.sharedCAF1_closure" {
     GHC.Conc.Sync.sharedCAF1_closure:
         const GHC.Conc.Sync.sharedCAF1_info;
 },
 io_s9M4v_entry() //  [R1]
         { info_tbl: [(c9Onf,
                       label: io_s9M4v_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Onf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Ong; else goto c9Onh;
       c9Ong: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Onh: // global
           I64[Sp - 24] = block_c9On7_info;
           _s9M4p::P64 = P64[R1 + 7];
           _s9M4q::P64 = P64[R1 + 15];
           R1 = _s9M4p::P64;
           P64[Sp - 16] = _s9M4p::P64;
           P64[Sp - 8] = _s9M4q::P64;
           Sp = Sp - 24;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9On7() //  [R1]
         { info_tbl: [(c9On7,
                       label: block_c9On7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9On7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9Onk; else goto c9Onj;
       c9Onk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9Onj: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = R1;
           I64[Sp] = block_c9Ona_info;
           R2 = Hp - 7;
           _s9M4z::I64 = R1;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s9M4z::I64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ona() //  [R1]
         { info_tbl: [(c9Ona,
                       label: block_c9Ona_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ona: // global
           I64[Sp] = block_c9Onc_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u9Onx; else goto c9Ond;
       u9Onx: // global
           call _c9Onc(R1) args: 0, res: 0, upd: 0;
       c9Ond: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Onc() //  [R1]
         { info_tbl: [(c9Onc,
                       label: block_c9Onc_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Onc: // global
           _s9M4z::I64 = I64[Sp + 16];
           _s9M4F::I64 = I64[R1 + 7];
           if (_s9M4z::I64 == _s9M4F::I64) goto c9Ont; else goto c9Ons;
       c9Ont: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9Ons: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(_s9M4z::I64);
           R1 = _s9M4F::I64;
           Sp = Sp + 24;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.sharedCAF1_entry() //  [R2, R3]
         { info_tbl: [(c9OnC,
                       label: GHC.Conc.Sync.sharedCAF1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OnC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9OnD; else goto c9OnE;
       c9OnD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.sharedCAF1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9OnE: // global
           I64[Sp - 24] = block_c9On0_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c9On0() //  [R1]
         { info_tbl: [(c9On0,
                       label: block_c9On0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9On0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9OnH; else goto c9OnG;
       c9OnH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9OnG: // global
           I64[Hp - 16] = io_s9M4v_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           _c9On2::P64 = Hp - 15;
           if (R1 == 0) goto c9OnB; else goto c9OnA;
       c9OnB: // global
           R1 = _c9On2::P64;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       c9OnA: // global
           R1 = _c9On2::P64;
           Sp = Sp + 24;
           call io_s9M4v_entry(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.835295131 UTC

[section ""data" . GHC.Conc.Sync.sharedCAF_closure" {
     GHC.Conc.Sync.sharedCAF_closure:
         const GHC.Conc.Sync.sharedCAF_info;
 },
 GHC.Conc.Sync.sharedCAF_entry() //  [R2, R3]
         { info_tbl: [(c9Ooh,
                       label: GHC.Conc.Sync.sharedCAF_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ooh: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.sharedCAF1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.841303637 UTC

[section ""data" . GHC.Conc.Sync.$wmodifyMVar__closure" {
     GHC.Conc.Sync.$wmodifyMVar__closure:
         const GHC.Conc.Sync.$wmodifyMVar__info;
 },
 sat_s9M54_entry() //  [R1]
         { info_tbl: [(c9OoP,
                       label: sat_s9M54_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OoP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9OoQ; else goto c9OoR;
       c9OoQ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9OoR: // global
           I64[Sp - 24] = block_c9OoN_info;
           R2 = P64[R1 + 15];
           _s9M4Z::P64 = P64[R1 + 23];
           _s9M50::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9M4Z::P64;
           P64[Sp - 8] = _s9M50::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OoN() //  []
         { info_tbl: [(c9OoN,
                       label: block_c9OoN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OoN: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M55_entry() //  [R1, R2]
         { info_tbl: [(c9OoT,
                       label: sat_s9M55_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OoT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9OoU; else goto c9OoV;
       c9OoU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9OoV: // global
           I64[Sp - 24] = block_c9OoD_info;
           _s9M4L::P64 = P64[R1 + 7];
           _s9M4U::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9M4L::P64;
           P64[Sp - 8] = _s9M4U::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9OoZ; else goto c9OoE;
       u9OoZ: // global
           call _c9OoD(R1) args: 0, res: 0, upd: 0;
       c9OoE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OoD() //  [R1]
         { info_tbl: [(c9OoD,
                       label: block_c9OoD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OoD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9OoY; else goto c9OoX;
       c9OoY: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OoX: // global
           _s9M4Z::P64 = P64[R1 + 7];
           _s9M50::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9M54_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9M4Z::P64;
           P64[Hp] = _s9M50::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M4W_entry() //  [R1]
         { info_tbl: [(c9Op6,
                       label: sat_s9M4W_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Op6: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M5n_entry() //  [R1]
         { info_tbl: [(c9Opy,
                       label: sat_s9M5n_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Opy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Opz; else goto c9OpA;
       c9Opz: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9OpA: // global
           I64[Sp - 24] = block_c9Opw_info;
           R2 = P64[R1 + 15];
           _s9M5i::P64 = P64[R1 + 23];
           _s9M5j::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9M5i::P64;
           P64[Sp - 8] = _s9M5j::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Opw() //  []
         { info_tbl: [(c9Opw,
                       label: block_c9Opw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Opw: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M5o_entry() //  [R1, R2]
         { info_tbl: [(c9OpC,
                       label: sat_s9M5o_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OpC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9OpD; else goto c9OpE;
       c9OpD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9OpE: // global
           I64[Sp - 24] = block_c9Opm_info;
           _s9M4L::P64 = P64[R1 + 7];
           _s9M5d::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9M4L::P64;
           P64[Sp - 8] = _s9M5d::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9OpI; else goto c9Opn;
       u9OpI: // global
           call _c9Opm(R1) args: 0, res: 0, upd: 0;
       c9Opn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Opm() //  [R1]
         { info_tbl: [(c9Opm,
                       label: block_c9Opm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Opm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9OpH; else goto c9OpG;
       c9OpH: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OpG: // global
           _s9M5i::P64 = P64[R1 + 7];
           _s9M5j::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9M5n_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9M5i::P64;
           P64[Hp] = _s9M5j::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M5f_entry() //  [R1]
         { info_tbl: [(c9OpP,
                       label: sat_s9M5f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OpP: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M5t_entry() //  [R1]
         { info_tbl: [(c9OpW,
                       label: sat_s9M5t_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OpW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9OpX; else goto c9OpY;
       c9OpX: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9OpY: // global
           I64[Sp - 24] = block_c9Opf_info;
           _s9M4L::P64 = P64[R1 + 7];
           _s9M4M::P64 = P64[R1 + 15];
           R1 = _s9M4L::P64;
           P64[Sp - 16] = _s9M4L::P64;
           P64[Sp - 8] = _s9M4M::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Opf() //  [R1]
         { info_tbl: [(c9Opf,
                       label: block_c9Opf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Opf: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9Oq1; else goto c9Oq0;
       c9Oq1: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Oq0: // global
           I64[Hp - 64] = sat_s9M5o_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9M5f_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9OpS_info;
           R2 = Hp - 63;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OpS() //  [R1]
         { info_tbl: [(c9OpS,
                       label: block_c9OpS_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OpS: // global
           I64[Sp + 16] = block_c9OpU_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OpU() //  []
         { info_tbl: [(c9OpU,
                       label: block_c9OpU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OpU: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M5G_entry() //  [R1]
         { info_tbl: [(c9Oqo,
                       label: sat_s9M5G_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oqo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Oqp; else goto c9Oqq;
       c9Oqp: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Oqq: // global
           I64[Sp - 24] = block_c9Oqm_info;
           R2 = P64[R1 + 15];
           _s9M5B::P64 = P64[R1 + 23];
           _s9M5C::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9M5B::P64;
           P64[Sp - 8] = _s9M5C::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Oqm() //  []
         { info_tbl: [(c9Oqm,
                       label: block_c9Oqm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oqm: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M5H_entry() //  [R1, R2]
         { info_tbl: [(c9Oqs,
                       label: sat_s9M5H_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oqs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Oqt; else goto c9Oqu;
       c9Oqt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Oqu: // global
           I64[Sp - 24] = block_c9Oqc_info;
           _s9M4L::P64 = P64[R1 + 7];
           _s9M5w::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9M4L::P64;
           P64[Sp - 8] = _s9M5w::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Oqy; else goto c9Oqd;
       u9Oqy: // global
           call _c9Oqc(R1) args: 0, res: 0, upd: 0;
       c9Oqd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Oqc() //  [R1]
         { info_tbl: [(c9Oqc,
                       label: block_c9Oqc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oqc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9Oqx; else goto c9Oqw;
       c9Oqx: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Oqw: // global
           _s9M5B::P64 = P64[R1 + 7];
           _s9M5C::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9M5G_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9M5B::P64;
           P64[Hp] = _s9M5C::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M5y_entry() //  [R1]
         { info_tbl: [(c9OqF,
                       label: sat_s9M5y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OqF: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$wmodifyMVar__entry() //  [R2, R3]
         { info_tbl: [(c9OqM,
                       label: GHC.Conc.Sync.$wmodifyMVar__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OqM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9OqN; else goto c9OqO;
       c9OqN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$wmodifyMVar__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9OqO: // global
           I64[Sp - 24] = block_c9Oos_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c9Oos() //  [R1]
         { info_tbl: [(c9Oos,
                       label: block_c9Oos_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oos: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9OqR; else goto c9OqQ;
       c9OqR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9OqQ: // global
           _s9M4L::P64 = P64[Sp + 8];
           if (R1 == 0) goto c9OqK; else goto u9Ora;
       c9OqK: // global
           I64[Hp - 16] = sat_s9M5t_info;
           P64[Hp - 8] = _s9M4L::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u9Ora: // global
           if (R1 == 1) goto c9OqL; else goto c9OqJ;
       c9OqL: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9Oq5_info;
           R1 = _s9M4L::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       c9OqJ: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9Oow_info;
           R1 = _s9M4L::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Oq5() //  [R1]
         { info_tbl: [(c9Oq5,
                       label: block_c9Oq5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oq5: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9Or6; else goto c9Or5;
       c9Or6: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Or5: // global
           I64[Hp - 64] = sat_s9M5H_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9M5y_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9Or1_info;
           R2 = Hp - 63;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Or1() //  [R1]
         { info_tbl: [(c9Or1,
                       label: block_c9Or1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Or1: // global
           I64[Sp + 16] = block_c9Or3_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Oow() //  [R1]
         { info_tbl: [(c9Oow,
                       label: block_c9Oow_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oow: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9OqX; else goto c9OqW;
       c9OqX: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OqW: // global
           I64[Hp - 64] = sat_s9M55_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9M4W_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9OqS_info;
           R2 = Hp - 63;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OqS() //  [R1]
         { info_tbl: [(c9OqS,
                       label: block_c9OqS_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OqS: // global
           I64[Sp + 16] = block_c9Or3_info;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Or3() //  []
         { info_tbl: [(c9Or3,
                       label: block_c9Or3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Or3: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.89061025 UTC

[section ""data" . GHC.Conc.Sync.modifyMVar_1_closure" {
     GHC.Conc.Sync.modifyMVar_1_closure:
         const GHC.Conc.Sync.modifyMVar_1_info;
 },
 GHC.Conc.Sync.modifyMVar_1_entry() //  [R2, R3]
         { info_tbl: [(c9OtA,
                       label: GHC.Conc.Sync.modifyMVar_1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OtA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9OtB; else goto c9OtC;
       c9OtB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.modifyMVar_1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9OtC: // global
           I64[Sp - 16] = block_c9Otx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9OtG; else goto c9Oty;
       u9OtG: // global
           call _c9Otx(R1) args: 0, res: 0, upd: 0;
       c9Oty: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Otx() //  [R1]
         { info_tbl: [(c9Otx,
                       label: block_c9Otx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Otx: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$wmodifyMVar__entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.896435319 UTC

[section ""data" . GHC.Conc.Sync.modifyMVar__closure" {
     GHC.Conc.Sync.modifyMVar__closure:
         const GHC.Conc.Sync.modifyMVar__info;
 },
 GHC.Conc.Sync.modifyMVar__entry() //  [R2, R3]
         { info_tbl: [(c9OtV,
                       label: GHC.Conc.Sync.modifyMVar__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OtV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.modifyMVar_1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.90269519 UTC

[section ""data" . GHC.Conc.Sync.$wwithMVar_closure" {
     GHC.Conc.Sync.$wwithMVar_closure:
         const GHC.Conc.Sync.$wwithMVar_info;
 },
 sat_s9M6a_entry() //  [R1]
         { info_tbl: [(c9Out,
                       label: sat_s9M6a_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Out: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Ouu; else goto c9Ouv;
       c9Ouu: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Ouv: // global
           I64[Sp - 24] = block_c9Our_info;
           R2 = P64[R1 + 15];
           _s9M65::P64 = P64[R1 + 23];
           _s9M66::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9M65::P64;
           P64[Sp - 8] = _s9M66::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Our() //  []
         { info_tbl: [(c9Our,
                       label: block_c9Our_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Our: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M6b_entry() //  [R1, R2]
         { info_tbl: [(c9Oux,
                       label: sat_s9M6b_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oux: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Ouy; else goto c9Ouz;
       c9Ouy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Ouz: // global
           I64[Sp - 24] = block_c9Ouh_info;
           _s9M5R::P64 = P64[R1 + 7];
           _s9M60::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9M5R::P64;
           P64[Sp - 8] = _s9M60::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9OuD; else goto c9Oui;
       u9OuD: // global
           call _c9Ouh(R1) args: 0, res: 0, upd: 0;
       c9Oui: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ouh() //  [R1]
         { info_tbl: [(c9Ouh,
                       label: block_c9Ouh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ouh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9OuC; else goto c9OuB;
       c9OuC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OuB: // global
           _s9M65::P64 = P64[R1 + 7];
           _s9M66::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9M6a_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9M65::P64;
           P64[Hp] = _s9M66::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M62_entry() //  [R1]
         { info_tbl: [(c9OuK,
                       label: sat_s9M62_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OuK: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M6t_entry() //  [R1]
         { info_tbl: [(c9Ovc,
                       label: sat_s9M6t_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ovc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Ovd; else goto c9Ove;
       c9Ovd: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Ove: // global
           I64[Sp - 24] = block_c9Ova_info;
           R2 = P64[R1 + 15];
           _s9M6o::P64 = P64[R1 + 23];
           _s9M6p::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9M6o::P64;
           P64[Sp - 8] = _s9M6p::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ova() //  []
         { info_tbl: [(c9Ova,
                       label: block_c9Ova_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ova: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M6u_entry() //  [R1, R2]
         { info_tbl: [(c9Ovg,
                       label: sat_s9M6u_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ovg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Ovh; else goto c9Ovi;
       c9Ovh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Ovi: // global
           I64[Sp - 24] = block_c9Ov0_info;
           _s9M5R::P64 = P64[R1 + 7];
           _s9M6j::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9M5R::P64;
           P64[Sp - 8] = _s9M6j::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Ovm; else goto c9Ov1;
       u9Ovm: // global
           call _c9Ov0(R1) args: 0, res: 0, upd: 0;
       c9Ov1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ov0() //  [R1]
         { info_tbl: [(c9Ov0,
                       label: block_c9Ov0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ov0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9Ovl; else goto c9Ovk;
       c9Ovl: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Ovk: // global
           _s9M6o::P64 = P64[R1 + 7];
           _s9M6p::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9M6t_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9M6o::P64;
           P64[Hp] = _s9M6p::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M6l_entry() //  [R1]
         { info_tbl: [(c9Ovt,
                       label: sat_s9M6l_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ovt: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M6z_entry() //  [R1]
         { info_tbl: [(c9OvA,
                       label: sat_s9M6z_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OvA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9OvB; else goto c9OvC;
       c9OvB: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9OvC: // global
           I64[Sp - 24] = block_c9OuT_info;
           _s9M5R::P64 = P64[R1 + 7];
           _s9M5S::P64 = P64[R1 + 15];
           R1 = _s9M5R::P64;
           P64[Sp - 16] = _s9M5R::P64;
           P64[Sp - 8] = _s9M5S::P64;
           Sp = Sp - 24;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OuT() //  [R1]
         { info_tbl: [(c9OuT,
                       label: block_c9OuT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OuT: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9OvF; else goto c9OvE;
       c9OvF: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OvE: // global
           I64[Hp - 64] = sat_s9M6u_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9M6l_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9Ovw_info;
           R2 = Hp - 63;
           _s9M6j::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s9M6j::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ovw() //  [R1]
         { info_tbl: [(c9Ovw,
                       label: block_c9Ovw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ovw: // global
           _s9M5R::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9Ovy_info;
           R2 = P64[Sp + 16];
           _s9M6x::P64 = R1;
           R1 = _s9M5R::P64;
           P64[Sp + 16] = _s9M6x::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ovy() //  []
         { info_tbl: [(c9Ovy,
                       label: block_c9Ovy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ovy: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M6M_entry() //  [R1]
         { info_tbl: [(c9Ow2,
                       label: sat_s9M6M_info
                       rep:HeapRep 4 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ow2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Ow3; else goto c9Ow4;
       c9Ow3: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9Ow4: // global
           I64[Sp - 24] = block_c9Ow0_info;
           R2 = P64[R1 + 15];
           _s9M6H::P64 = P64[R1 + 23];
           _s9M6I::P64 = P64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 16] = _s9M6H::P64;
           P64[Sp - 8] = _s9M6I::P64;
           Sp = Sp - 24;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ow0() //  []
         { info_tbl: [(c9Ow0,
                       label: block_c9Ow0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ow0: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M6N_entry() //  [R1, R2]
         { info_tbl: [(c9Ow6,
                       label: sat_s9M6N_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ow6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Ow7; else goto c9Ow8;
       c9Ow7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9Ow8: // global
           I64[Sp - 24] = block_c9OvQ_info;
           _s9M5R::P64 = P64[R1 + 7];
           _s9M6C::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _s9M5R::P64;
           P64[Sp - 8] = _s9M6C::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u9Owc; else goto c9OvR;
       u9Owc: // global
           call _c9OvQ(R1) args: 0, res: 0, upd: 0;
       c9OvR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OvQ() //  [R1]
         { info_tbl: [(c9OvQ,
                       label: block_c9OvQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OvQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9Owb; else goto c9Owa;
       c9Owb: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9Owa: // global
           _s9M6H::P64 = P64[R1 + 7];
           _s9M6I::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_s9M6M_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s9M6H::P64;
           P64[Hp] = _s9M6I::P64;
           R1 = Hp - 31;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M6E_entry() //  [R1]
         { info_tbl: [(c9Owj,
                       label: sat_s9M6E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Owj: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.$wwithMVar_entry() //  [R2, R3]
         { info_tbl: [(c9Owq,
                       label: GHC.Conc.Sync.$wwithMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Owq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9Owr; else goto c9Ows;
       c9Owr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.$wwithMVar_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Ows: // global
           I64[Sp - 24] = block_c9Ou6_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c9Ou6() //  [R1]
         { info_tbl: [(c9Ou6,
                       label: block_c9Ou6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ou6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9Owv; else goto c9Owu;
       c9Owv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c9Owu: // global
           _s9M5R::P64 = P64[Sp + 8];
           if (R1 == 0) goto c9Owo; else goto u9OwO;
       c9Owo: // global
           I64[Hp - 16] = sat_s9M6z_info;
           P64[Hp - 8] = _s9M5R::P64;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u9OwO: // global
           if (R1 == 1) goto c9Owp; else goto c9Own;
       c9Owp: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9OvJ_info;
           R1 = _s9M5R::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
       c9Own: // global
           Hp = Hp - 24;
           I64[Sp] = block_c9Oua_info;
           R1 = _s9M5R::P64;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OvJ() //  [R1]
         { info_tbl: [(c9OvJ,
                       label: block_c9OvJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OvJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9OwK; else goto c9OwJ;
       c9OwK: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OwJ: // global
           I64[Hp - 64] = sat_s9M6N_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9M6E_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9OwF_info;
           R2 = Hp - 63;
           _s9M6C::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s9M6C::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OwF() //  [R1]
         { info_tbl: [(c9OwF,
                       label: block_c9OwF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OwF: // global
           _s9M5R::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9OwH_info;
           R2 = P64[Sp + 16];
           _s9M6Q::P64 = R1;
           R1 = _s9M5R::P64;
           P64[Sp + 16] = _s9M6Q::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OwH() //  []
         { info_tbl: [(c9OwH,
                       label: block_c9OwH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OwH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9Oua() //  [R1]
         { info_tbl: [(c9Oua,
                       label: block_c9Oua_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oua: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c9OwB; else goto c9OwA;
       c9OwB: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OwA: // global
           I64[Hp - 64] = sat_s9M6b_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s9M62_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c9Oww_info;
           R2 = Hp - 63;
           _s9M60::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _s9M60::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Oww() //  [R1]
         { info_tbl: [(c9Oww,
                       label: block_c9Oww_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Oww: // global
           _s9M5R::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9Owy_info;
           R2 = P64[Sp + 16];
           _s9M6e::P64 = R1;
           R1 = _s9M5R::P64;
           P64[Sp + 16] = _s9M6e::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Owy() //  []
         { info_tbl: [(c9Owy,
                       label: block_c9Owy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Owy: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.952711957 UTC

[section ""data" . GHC.Conc.Sync.withMVar1_closure" {
     GHC.Conc.Sync.withMVar1_closure:
         const GHC.Conc.Sync.withMVar1_info;
 },
 GHC.Conc.Sync.withMVar1_entry() //  [R2, R3]
         { info_tbl: [(c9Ozg,
                       label: GHC.Conc.Sync.withMVar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ozg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9Ozh; else goto c9Ozi;
       c9Ozh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.withMVar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9Ozi: // global
           I64[Sp - 16] = block_c9Ozd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9Ozm; else goto c9Oze;
       u9Ozm: // global
           call _c9Ozd(R1) args: 0, res: 0, upd: 0;
       c9Oze: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9Ozd() //  [R1]
         { info_tbl: [(c9Ozd,
                       label: block_c9Ozd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9Ozd: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Sync.$wwithMVar_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.958122116 UTC

[section ""data" . GHC.Conc.Sync.withMVar_closure" {
     GHC.Conc.Sync.withMVar_closure:
         const GHC.Conc.Sync.withMVar_info;
 },
 GHC.Conc.Sync.withMVar_entry() //  [R2, R3]
         { info_tbl: [(c9OzB,
                       label: GHC.Conc.Sync.withMVar_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OzB: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.withMVar1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.961804141 UTC

[section ""data" . GHC.Conc.Sync.reportStackOverflow1_closure" {
     GHC.Conc.Sync.reportStackOverflow1_closure:
         const GHC.Conc.Sync.reportStackOverflow1_info;
 },
 GHC.Conc.Sync.reportStackOverflow1_entry() //  []
         { info_tbl: [(c9OzO,
                       label: GHC.Conc.Sync.reportStackOverflow1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OzO: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] reportStackOverflow(CurrentTSO);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.965213626 UTC

[section ""data" . GHC.Conc.Sync.reportStackOverflow_closure" {
     GHC.Conc.Sync.reportStackOverflow_closure:
         const GHC.Conc.Sync.reportStackOverflow_info;
 },
 GHC.Conc.Sync.reportStackOverflow_entry() //  []
         { info_tbl: [(c9OA1,
                       label: GHC.Conc.Sync.reportStackOverflow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OA1: // global
           call GHC.Conc.Sync.reportStackOverflow1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:53.971374804 UTC

[section ""data" . GHC.Conc.Sync.forkIO2_closure" {
     GHC.Conc.Sync.forkIO2_closure:
         const GHC.Conc.Sync.forkIO2_info;
         const 0;
 },
 GHC.Conc.Sync.forkIO2_entry() //  [R2]
         { info_tbl: [(c9OAc,
                       label: GHC.Conc.Sync.forkIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OAc: // global
           R2 = R2;
           call GHC.Conc.Sync.childHandler1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.Conc.Sync.childHandler1_closure" {
     GHC.Conc.Sync.childHandler1_closure:
         const GHC.Conc.Sync.childHandler1_info;
         const 0;
 },
 sat_s9M7p_entry() //  [R1]
         { info_tbl: [(c9OB7,
                       label: sat_s9M7p_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OB7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9OB8; else goto c9OB9;
       c9OB8: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9OB9: // global
           I64[Sp - 16] = block_c9OB4_info;
           _s9M78::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = _s9M78::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9OBd; else goto c9OB5;
       u9OBd: // global
           call _c9OB4(R1) args: 0, res: 0, upd: 0;
       c9OB5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OB4() //  [R1]
         { info_tbl: [(c9OB4,
                       label: block_c9OB4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OB4: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M7B_entry() //  [R1]
         { info_tbl: [(c9OBA,
                       label: sat_s9M7B_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OBA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9OBB; else goto c9OBC;
       c9OBB: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9OBC: // global
           I64[Sp - 16] = block_c9OBx_info;
           _s9M78::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = _s9M78::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9OBG; else goto c9OBy;
       u9OBG: // global
           call _c9OBx(R1) args: 0, res: 0, upd: 0;
       c9OBy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OBx() //  [R1]
         { info_tbl: [(c9OBx,
                       label: block_c9OBx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OBx: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M7J_entry() //  [R1]
         { info_tbl: [(c9OBV,
                       label: sat_s9M7J_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OBV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9OBW; else goto c9OBX;
       c9OBW: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9OBX: // global
           I64[Sp - 16] = block_c9OBS_info;
           _s9M78::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 8] = _s9M78::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9OC1; else goto c9OBT;
       u9OC1: // global
           call _c9OBS(R1) args: 0, res: 0, upd: 0;
       c9OBT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OBS() //  [R1]
         { info_tbl: [(c9OBS,
                       label: block_c9OBS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OBS: // global
           R2 = P64[Sp + 8];
           R1 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M7U_entry() //  [R1]
         { info_tbl: [(c9OC2,
                       label: sat_s9M7U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OC2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c9OC3; else goto c9OC4;
       c9OC3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9OC4: // global
           I64[Sp - 8] = block_c9OAn_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9ODQ; else goto c9OAo;
       u9ODQ: // global
           call _c9OAn(R1) args: 0, res: 0, upd: 0;
       c9OAo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OAn() //  [R1]
         { info_tbl: [(c9OAn,
                       label: block_c9OAn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OAn: // global
           I64[Sp - 24] = block_c9OAs_info;
           _s9M79::P64 = P64[R1 + 7];
           R2 = _s9M79::P64;
           P64[Sp - 16] = _s9M79::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 24;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9OAs() //  [R1]
         { info_tbl: [(c9OAs,
                       label: block_c9OAs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OAs: // global
           I64[Sp] = block_c9OAw_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9OAw() //  [R1]
         { info_tbl: [(c9OAw,
                       label: block_c9OAw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OAw: // global
           if (R1 & 7 == 1) goto c9OC9; else goto c9ODA;
       c9OC9: // global
           I64[Sp] = block_c9OAA_info;
           R2 = P64[Sp + 8];
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       c9ODA: // global
           I64[Sp + 24] = block_c9ODy_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OAA() //  [R1]
         { info_tbl: [(c9OAA,
                       label: block_c9OAA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OAA: // global
           I64[Sp] = block_c9OAE_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9OAE() //  [R1]
         { info_tbl: [(c9OAE,
                       label: block_c9OAE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OAE: // global
           if (R1 & 7 == 1) goto c9OCd; else goto c9ODr;
       c9OCd: // global
           I64[Sp] = block_c9OAI_info;
           R2 = P64[Sp + 8];
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
       c9ODr: // global
           I64[Sp + 24] = block_c9ODp_info;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OAI() //  [R1]
         { info_tbl: [(c9OAI,
                       label: block_c9OAI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OAI: // global
           I64[Sp] = block_c9OCe_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9OCe() //  [R1]
         { info_tbl: [(c9OCe,
                       label: block_c9OCe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OCe: // global
           if (R1 & 7 == 1) goto u9ODN; else goto c9OCV;
       u9ODN: // global
           Sp = Sp + 8;
           call _s9M7f() args: 0, res: 0, upd: 0;
       c9OCV: // global
           I64[Sp] = block_c9OCP_info;
           R1 = P64[Sp + 16];
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OCP() //  [R1]
         { info_tbl: [(c9OCP,
                       label: block_c9OCP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OCP: // global
           I64[Sp - 8] = block_c9OCT_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9OCT() //  [R1]
         { info_tbl: [(c9OCT,
                       label: block_c9OCT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OCT: // global
           I64[Sp] = block_c9OD0_info;
           R3 = GHC.IO.Exception.$fExceptionAsyncException9_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9OD0() //  [R1]
         { info_tbl: [(c9OD0,
                       label: block_c9OD0_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OD0: // global
           if (R1 & 7 == 1) goto u9ODO; else goto c9ODc;
       u9ODO: // global
           Sp = Sp + 16;
           call _s9M7f() args: 0, res: 0, upd: 0;
       c9ODc: // global
           _s9M7O::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9ODa_info;
           R1 = _s9M7O::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9ODa() //  [R1]
         { info_tbl: [(c9ODa,
                       label: block_c9ODa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ODa: // global
           if (R1 & 7 == 3) goto c9ODm; else goto u9ODP;
       c9ODm: // global
           R1 = GHC.Conc.Sync.always2_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u9ODP: // global
           Sp = Sp + 8;
           call _s9M7f() args: 0, res: 0, upd: 0;
     }
 },
 _s9M7f() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s9M7f: // global
           _s9M79::P64 = P64[Sp];
           I64[Sp] = block_c9OAR_info;
           R2 = _s9M79::P64;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9OAR() //  [R1]
         { info_tbl: [(c9OAR,
                       label: block_c9OAR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OAR: // global
           I64[Sp] = block_c9OAV_info;
           R3 = GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9OAV() //  [R1]
         { info_tbl: [(c9OAV,
                       label: block_c9OAV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OAV: // global
           if (R1 & 7 == 1) goto c9OCj; else goto c9OCo;
       c9OCj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OCm; else goto c9OCl;
       c9OCm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OCl: // global
           I64[Hp - 8] = sat_s9M7p_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9OCo: // global
           _s9M7a::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9OBg_info;
           R1 = _s9M7a::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OBg() //  [R1]
         { info_tbl: [(c9OBg,
                       label: block_c9OBg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OBg: // global
           I64[Sp - 8] = block_c9OBk_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9OBk() //  [R1]
         { info_tbl: [(c9OBk,
                       label: block_c9OBk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OBk: // global
           I64[Sp] = block_c9OBo_info;
           R3 = GHC.IO.Exception.$fExceptionAsyncException9_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9OBo() //  [R1]
         { info_tbl: [(c9OBo,
                       label: block_c9OBo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OBo: // global
           if (R1 & 7 == 1) goto c9OCs; else goto c9OCx;
       c9OCs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OCv; else goto c9OCu;
       c9OCv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OCu: // global
           I64[Hp - 8] = sat_s9M7B_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9OCx: // global
           _s9M7s::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c9OBJ_info;
           R1 = _s9M7s::P64;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OBJ() //  [R1]
         { info_tbl: [(c9OBJ,
                       label: block_c9OBJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OBJ: // global
           if (R1 & 7 == 1) goto c9OCG; else goto c9OCz;
       c9OCG: // global
           R1 = GHC.Conc.Sync.reportStackOverflow1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9OCz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OCC; else goto c9OCB;
       c9OCC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OCB: // global
           I64[Hp - 8] = sat_s9M7J_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9ODp() //  []
         { info_tbl: [(c9ODp,
                       label: block_c9ODp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ODp: // global
           R1 = GHC.Conc.Sync.always2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9ODy() //  []
         { info_tbl: [(c9ODy,
                       label: block_c9ODy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ODy: // global
           R1 = GHC.Conc.Sync.always2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.childHandler1_entry() //  [R2]
         { info_tbl: [(c9ODU,
                       label: GHC.Conc.Sync.childHandler1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ODU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9ODY; else goto c9ODX;
       c9ODY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Conc.Sync.childHandler1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9ODX: // global
           I64[Hp - 16] = sat_s9M7U_info;
           P64[Hp] = R2;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.021654009 UTC

[section ""data" . GHC.Conc.Sync.childHandler_closure" {
     GHC.Conc.Sync.childHandler_closure:
         const GHC.Conc.Sync.childHandler_info;
         const 0;
 },
 GHC.Conc.Sync.childHandler_entry() //  [R2]
         { info_tbl: [(c9OGx,
                       label: GHC.Conc.Sync.childHandler_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OGx: // global
           R2 = R2;
           call GHC.Conc.Sync.childHandler1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.025266913 UTC

[section ""data" . GHC.Conc.Sync.forkOn1_closure" {
     GHC.Conc.Sync.forkOn1_closure:
         const GHC.Conc.Sync.forkOn1_info;
         const 0;
 },
 sat_s9M81_entry() //  [R1]
         { info_tbl: [(c9OGS,
                       label: sat_s9M81_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OGS: // global
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = P64[R1 + 7];
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkOn1_entry() //  [R2, R3]
         { info_tbl: [(c9OGV,
                       label: GHC.Conc.Sync.forkOn1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OGV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9OGZ; else goto c9OH0;
       c9OGZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.forkOn1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9OH0: // global
           I64[Sp - 16] = block_c9OGI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9OH7; else goto c9OGJ;
       u9OH7: // global
           call _c9OGI(R1) args: 0, res: 0, upd: 0;
       c9OGJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OGI() //  [R1]
         { info_tbl: [(c9OGI,
                       label: block_c9OGI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OGI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OH3; else goto c9OH2;
       c9OH3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OH2: // global
           _s9M7Z::I64 = I64[R1 + 7];
           I64[Hp - 8] = sat_s9M81_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c9OGW_info;
           R2 = Hp - 7;
           R1 = _s9M7Z::I64;
           Sp = Sp + 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OGW() //  [R1]
         { info_tbl: [(c9OGW,
                       label: block_c9OGW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OGW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OH6; else goto c9OH5;
       c9OH6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OH5: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.034596622 UTC

[section ""data" . GHC.Conc.Sync.forkOn_closure" {
     GHC.Conc.Sync.forkOn_closure:
         const GHC.Conc.Sync.forkOn_info;
         const 0;
 },
 GHC.Conc.Sync.forkOn_entry() //  [R2, R3]
         { info_tbl: [(c9OHx,
                       label: GHC.Conc.Sync.forkOn_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OHx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.forkOn1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.039124459 UTC

[section ""data" . GHC.Conc.Sync.forkOnWithUnmask1_closure" {
     GHC.Conc.Sync.forkOnWithUnmask1_closure:
         const GHC.Conc.Sync.forkOnWithUnmask1_info;
         const 0;
 },
 sat_s9M8c_entry() //  [R2]
         { info_tbl: [(c9OI1,
                       label: sat_s9M8c_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OI1: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M8d_entry() //  [R1]
         { info_tbl: [(c9OI4,
                       label: sat_s9M8d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OI4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OI8; else goto c9OI7;
       c9OI8: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9OI7: // global
           _s9M87::P64 = P64[R1 + 16];
           I64[Hp - 8] = sat_s9M8c_info;
           R2 = Hp - 6;
           R1 = _s9M87::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M8e_entry() //  [R1]
         { info_tbl: [(c9OI9,
                       label: sat_s9M8e_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OI9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9OId; else goto c9OIc;
       c9OId: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9OIc: // global
           _s9M87::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_s9M8d_info;
           P64[Hp] = _s9M87::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkOnWithUnmask1_entry() //  [R2, R3]
         { info_tbl: [(c9OIe,
                       label: GHC.Conc.Sync.forkOnWithUnmask1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OIe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9OIi; else goto c9OIj;
       c9OIi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Sync.forkOnWithUnmask1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9OIj: // global
           I64[Sp - 16] = block_c9OHI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9OIq; else goto c9OHJ;
       u9OIq: // global
           call _c9OHI(R1) args: 0, res: 0, upd: 0;
       c9OHJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OHI() //  [R1]
         { info_tbl: [(c9OHI,
                       label: block_c9OHI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OHI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OIm; else goto c9OIl;
       c9OIm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OIl: // global
           _s9M8a::I64 = I64[R1 + 7];
           I64[Hp - 8] = sat_s9M8e_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_c9OIf_info;
           R2 = Hp - 7;
           R1 = _s9M8a::I64;
           Sp = Sp + 8;
           call stg_forkOn#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OIf() //  [R1]
         { info_tbl: [(c9OIf,
                       label: block_c9OIf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OIf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OIp; else goto c9OIo;
       c9OIp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OIo: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.051990772 UTC

[section ""data" . GHC.Conc.Sync.forkOnWithUnmask_closure" {
     GHC.Conc.Sync.forkOnWithUnmask_closure:
         const GHC.Conc.Sync.forkOnWithUnmask_info;
         const 0;
 },
 GHC.Conc.Sync.forkOnWithUnmask_entry() //  [R2, R3]
         { info_tbl: [(c9OIY,
                       label: GHC.Conc.Sync.forkOnWithUnmask_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OIY: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Sync.forkOnWithUnmask1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.05565897 UTC

[section ""data" . GHC.Conc.Sync.forkIO1_closure" {
     GHC.Conc.Sync.forkIO1_closure:
         const GHC.Conc.Sync.forkIO1_info;
         const 0;
 },
 sat_s9M8m_entry() //  [R1]
         { info_tbl: [(c9OJe,
                       label: sat_s9M8m_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OJe: // global
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = P64[R1 + 7];
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkIO1_entry() //  [R2]
         { info_tbl: [(c9OJk,
                       label: GHC.Conc.Sync.forkIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OJk: // global
           _s9M8j::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c9OJl; else goto c9OJm;
       c9OJm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OJo; else goto c9OJn;
       c9OJo: // global
           HpAlloc = 16;
           goto c9OJl;
       c9OJl: // global
           R2 = _s9M8j::P64;
           R1 = GHC.Conc.Sync.forkIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9OJn: // global
           I64[Hp - 8] = sat_s9M8m_info;
           P64[Hp] = _s9M8j::P64;
           I64[Sp - 8] = block_c9OJh_info;
           R1 = Hp - 7;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OJh() //  [R1]
         { info_tbl: [(c9OJh,
                       label: block_c9OJh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OJh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OJr; else goto c9OJq;
       c9OJr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OJq: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.062768106 UTC

[section ""data" . GHC.Conc.Sync.forkIO_closure" {
     GHC.Conc.Sync.forkIO_closure:
         const GHC.Conc.Sync.forkIO_info;
         const 0;
 },
 GHC.Conc.Sync.forkIO_entry() //  [R2]
         { info_tbl: [(c9OJL,
                       label: GHC.Conc.Sync.forkIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OJL: // global
           R2 = R2;
           call GHC.Conc.Sync.forkIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.066844708 UTC

[section ""data" . GHC.Conc.Sync.forkIOWithUnmask1_closure" {
     GHC.Conc.Sync.forkIOWithUnmask1_closure:
         const GHC.Conc.Sync.forkIOWithUnmask1_info;
         const 0;
 },
 sat_s9M8u_entry() //  [R2]
         { info_tbl: [(c9OKa,
                       label: sat_s9M8u_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OKa: // global
           R1 = R2;
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M8v_entry() //  [R1]
         { info_tbl: [(c9OKd,
                       label: sat_s9M8v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OKd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OKh; else goto c9OKg;
       c9OKh: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9OKg: // global
           _s9M8r::P64 = P64[R1 + 16];
           I64[Hp - 8] = sat_s9M8u_info;
           R2 = Hp - 6;
           R1 = _s9M8r::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s9M8w_entry() //  [R1]
         { info_tbl: [(c9OKi,
                       label: sat_s9M8w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OKi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9OKm; else goto c9OKl;
       c9OKm: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9OKl: // global
           _s9M8r::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_s9M8v_info;
           P64[Hp] = _s9M8r::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Sync.forkIOWithUnmask1_entry() //  [R2]
         { info_tbl: [(c9OKq,
                       label: GHC.Conc.Sync.forkIOWithUnmask1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OKq: // global
           _s9M8r::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c9OKr; else goto c9OKs;
       c9OKs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OKu; else goto c9OKt;
       c9OKu: // global
           HpAlloc = 16;
           goto c9OKr;
       c9OKr: // global
           R2 = _s9M8r::P64;
           R1 = GHC.Conc.Sync.forkIOWithUnmask1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9OKt: // global
           I64[Hp - 8] = sat_s9M8w_info;
           P64[Hp] = _s9M8r::P64;
           I64[Sp - 8] = block_c9OKn_info;
           R1 = Hp - 7;
           Sp = Sp - 8;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OKn() //  [R1]
         { info_tbl: [(c9OKn,
                       label: block_c9OKn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OKn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OKx; else goto c9OKw;
       c9OKx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9OKw: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.077918951 UTC

[section ""data" . GHC.Conc.Sync.forkIOWithUnmask_closure" {
     GHC.Conc.Sync.forkIOWithUnmask_closure:
         const GHC.Conc.Sync.forkIOWithUnmask_info;
         const 0;
 },
 GHC.Conc.Sync.forkIOWithUnmask_entry() //  [R2]
         { info_tbl: [(c9OKZ,
                       label: GHC.Conc.Sync.forkIOWithUnmask_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OKZ: // global
           R2 = R2;
           call GHC.Conc.Sync.forkIOWithUnmask1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.080892238 UTC

[section ""cstring" . lvl11_r9Fvm_bytes" {
     lvl11_r9Fvm_bytes:
         I8[] [115,101,116,78,117,109,67,97,112,97,98,105,108,105,116,105,101,115,58,32,67,97,112,97,98,105,108,105,116,121,32,99,111,117,110,116,32,40]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.082526357 UTC

[section ""cstring" . lvl12_r9Fvn_bytes" {
     lvl12_r9Fvn_bytes:
         I8[] [41,32,109,117,115,116,32,98,101,32,112,111,115,105,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.084290765 UTC

[section ""data" . lvl13_r9Fvo_closure" {
     lvl13_r9Fvo_closure:
         const lvl13_r9Fvo_info;
         const 0;
         const 0;
         const 0;
 },
 lvl13_r9Fvo_entry() //  [R1]
         { info_tbl: [(c9OLe,
                       label: lvl13_r9Fvo_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OLe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9OLf; else goto c9OLg;
       c9OLf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9OLg: // global
           (_c9OLb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9OLb::I64 == 0) goto c9OLd; else goto c9OLc;
       c9OLd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9OLc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9OLb::I64;
           R2 = lvl12_r9Fvn_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.08895966 UTC

[section ""data" . GHC.Conc.Sync.$wlvl_closure" {
     GHC.Conc.Sync.$wlvl_closure:
         const GHC.Conc.Sync.$wlvl_info;
         const 0;
 },
 sat_s9M8H_entry() //  [R1]
         { info_tbl: [(c9OLA,
                       label: sat_s9M8H_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OLA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9OLB; else goto c9OLC;
       c9OLB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9OLC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c9OLx_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _c9OLx() //  [R1, R2]
         { info_tbl: [(c9OLx,
                       label: block_c9OLx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OLx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9OLF; else goto c9OLE;
       c9OLF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c9OLE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl13_r9Fvo_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Conc.Sync.$wlvl_entry() //  [R2]
         { info_tbl: [(c9OLI,
                       label: GHC.Conc.Sync.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OLI: // global
           _s9M8B::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c9OLJ; else goto c9OLK;
       c9OLK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c9OLM; else goto c9OLL;
       c9OLM: // global
           HpAlloc = 24;
           goto c9OLJ;
       c9OLJ: // global
           R2 = _s9M8B::I64;
           R1 = GHC.Conc.Sync.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9OLL: // global
           I64[Hp - 16] = sat_s9M8H_info;
           I64[Hp] = _s9M8B::I64;
           I64[Sp - 8] = block_c9OLG_info;
           R3 = Hp - 16;
           R2 = lvl11_r9Fvm_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c9OLG() //  [R1]
         { info_tbl: [(c9OLG,
                       label: block_c9OLG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OLG: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.101832286 UTC

[section ""data" . GHC.Conc.Sync.setNumCapabilities2_closure" {
     GHC.Conc.Sync.setNumCapabilities2_closure:
         const GHC.Conc.Sync.setNumCapabilities2_info;
         const 0;
 },
 GHC.Conc.Sync.setNumCapabilities2_entry() //  [R2]
         { info_tbl: [(c9OMi,
                       label: GHC.Conc.Sync.setNumCapabilities2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OMi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9OMj; else goto c9OMk;
       c9OMj: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.setNumCapabilities2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9OMk: // global
           I64[Sp - 8] = block_c9OMf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9OMo; else goto c9OMg;
       u9OMo: // global
           call _c9OMf(R1) args: 0, res: 0, upd: 0;
       c9OMg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OMf() //  [R1]
         { info_tbl: [(c9OMf,
                       label: block_c9OMf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OMf: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.108063662 UTC

[section ""data" . GHC.Conc.Sync.setNumCapabilities1_closure" {
     GHC.Conc.Sync.setNumCapabilities1_closure:
         const GHC.Conc.Sync.setNumCapabilities1_info;
         const 0;
 },
 GHC.Conc.Sync.setNumCapabilities1_entry() //  [R2]
         { info_tbl: [(c9OMG,
                       label: GHC.Conc.Sync.setNumCapabilities1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OMG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9OMH; else goto c9OMI;
       c9OMH: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.setNumCapabilities1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9OMI: // global
           I64[Sp - 8] = block_c9OMD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u9ONd; else goto c9OME;
       u9ONd: // global
           call _c9OMD(R1) args: 0, res: 0, upd: 0;
       c9OME: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OMD() //  [R1]
         { info_tbl: [(c9OMD,
                       label: block_c9OMD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OMD: // global
           _s9M8Q::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s9M8Q::I64, 0)) goto c9OMP; else goto c9ON2;
       c9OMP: // global
           I64[Sp] = block_c9OMZ_info;
           _u9ON5::P64 = CurrentTSO;
           I64[I64[_u9ON5::P64 + 24] + 16] = Sp;
           _u9ON6::I64 = CurrentNursery;
           P64[_u9ON6::I64 + 8] = Hp + 8;
           I64[_u9ON5::P64 + 104] = I64[_u9ON5::P64 + 104] - ((Hp + 8) - I64[_u9ON6::I64]);
           (_u9ON3::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  []  result hints:  [] setNumCapabilities(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_s9M8Q::I64)));
           (_u9ON4::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_u9ON3::I64);
           BaseReg = _u9ON4::I64;
           _u9ON7::P64 = CurrentTSO;
           _u9ON8::P64 = I64[_u9ON7::P64 + 24];
           Sp = I64[_u9ON8::P64 + 16];
           SpLim = _u9ON8::P64 + 192;
           HpAlloc = 0;
           _u9ON9::I64 = CurrentNursery;
           _u9ONa::I64 = I64[_u9ON9::I64 + 8];
           Hp = _u9ONa::I64 - 8;
           _u9ONb::I64 = I64[_u9ON9::I64];
           HpLim = _u9ONb::I64 + ((%MO_SS_Conv_W32_W64(I32[_u9ON9::I64 + 48]) << 12) - 1);
           I64[_u9ON7::P64 + 104] = I64[_u9ON7::P64 + 104] + (_u9ONa::I64 - _u9ONb::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
       c9ON2: // global
           R2 = _s9M8Q::I64;
           Sp = Sp + 8;
           call GHC.Conc.Sync.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _c9OMZ() //  []
         { info_tbl: [(c9OMZ,
                       label: block_c9OMZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OMZ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.117657351 UTC

[section ""data" . GHC.Conc.Sync.setNumCapabilities_closure" {
     GHC.Conc.Sync.setNumCapabilities_closure:
         const GHC.Conc.Sync.setNumCapabilities_info;
         const 0;
 },
 GHC.Conc.Sync.setNumCapabilities_entry() //  [R2]
         { info_tbl: [(c9ONN,
                       label: GHC.Conc.Sync.setNumCapabilities_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ONN: // global
           R2 = R2;
           call GHC.Conc.Sync.setNumCapabilities1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.120839949 UTC

[section ""data" . GHC.Conc.Sync.getNumCapabilities1_closure" {
     GHC.Conc.Sync.getNumCapabilities1_closure:
         const GHC.Conc.Sync.getNumCapabilities1_info;
 },
 GHC.Conc.Sync.getNumCapabilities1_entry() //  []
         { info_tbl: [(c9ONZ,
                       label: GHC.Conc.Sync.getNumCapabilities1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ONZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OO3; else goto c9OO2;
       c9OO3: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.getNumCapabilities1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9OO2: // global
           _s9M90::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s9M90::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.124463356 UTC

[section ""data" . GHC.Conc.Sync.getNumCapabilities_closure" {
     GHC.Conc.Sync.getNumCapabilities_closure:
         const GHC.Conc.Sync.getNumCapabilities_info;
 },
 GHC.Conc.Sync.getNumCapabilities_entry() //  []
         { info_tbl: [(c9OOf,
                       label: GHC.Conc.Sync.getNumCapabilities_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OOf: // global
           call GHC.Conc.Sync.getNumCapabilities1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.127914971 UTC

[section ""data" . GHC.Conc.Sync.numCapabilities1_closure" {
     GHC.Conc.Sync.numCapabilities1_closure:
         const GHC.Conc.Sync.numCapabilities1_info;
 },
 GHC.Conc.Sync.numCapabilities1_entry() //  []
         { info_tbl: [(c9OOt,
                       label: GHC.Conc.Sync.numCapabilities1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OOt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9OOu; else goto c9OOv;
       c9OOu: // global
           R1 = GHC.Conc.Sync.numCapabilities1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9OOv: // global
           I64[Sp - 8] = block_c9OOq_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _c9OOq() //  []
         { info_tbl: [(c9OOq,
                       label: block_c9OOq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OOq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OOy; else goto c9OOx;
       c9OOy: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c9OOx: // global
           _s9M96::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s9M96::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.133735181 UTC

[section ""data" . GHC.Conc.Sync.numCapabilities_closure" {
     GHC.Conc.Sync.numCapabilities_closure:
         const GHC.Conc.Sync.numCapabilities_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Sync.numCapabilities_entry() //  [R1]
         { info_tbl: [(c9OOT,
                       label: GHC.Conc.Sync.numCapabilities_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OOT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9OOU; else goto c9OOV;
       c9OOU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9OOV: // global
           (_c9OOO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9OOO::I64 == 0) goto c9OOQ; else goto c9OOP;
       c9OOQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9OOP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9OOO::I64;
           I64[Sp - 24] = block_c9OOR_info;
           Sp = Sp - 24;
           call GHC.Conc.Sync.numCapabilities1_entry() args: 8, res: 8, upd: 24;
     }
 },
 _c9OOR() //  [R1]
         { info_tbl: [(c9OOR,
                       label: block_c9OOR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OOR: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.139626195 UTC

[section ""data" . GHC.Conc.Sync.disableAllocationLimit1_closure" {
     GHC.Conc.Sync.disableAllocationLimit1_closure:
         const GHC.Conc.Sync.disableAllocationLimit1_info;
 },
 GHC.Conc.Sync.disableAllocationLimit1_entry() //  []
         { info_tbl: [(c9OPh,
                       label: GHC.Conc.Sync.disableAllocationLimit1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OPh: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] rts_disableThreadAllocationLimit(CurrentTSO);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.142953808 UTC

[section ""data" . GHC.Conc.Sync.disableAllocationLimit_closure" {
     GHC.Conc.Sync.disableAllocationLimit_closure:
         const GHC.Conc.Sync.disableAllocationLimit_info;
 },
 GHC.Conc.Sync.disableAllocationLimit_entry() //  []
         { info_tbl: [(c9OPu,
                       label: GHC.Conc.Sync.disableAllocationLimit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OPu: // global
           call GHC.Conc.Sync.disableAllocationLimit1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.146781773 UTC

[section ""data" . GHC.Conc.Sync.enableAllocationLimit1_closure" {
     GHC.Conc.Sync.enableAllocationLimit1_closure:
         const GHC.Conc.Sync.enableAllocationLimit1_info;
 },
 GHC.Conc.Sync.enableAllocationLimit1_entry() //  []
         { info_tbl: [(c9OPH,
                       label: GHC.Conc.Sync.enableAllocationLimit1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OPH: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] rts_enableThreadAllocationLimit(CurrentTSO);
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.150191032 UTC

[section ""data" . GHC.Conc.Sync.enableAllocationLimit_closure" {
     GHC.Conc.Sync.enableAllocationLimit_closure:
         const GHC.Conc.Sync.enableAllocationLimit_info;
 },
 GHC.Conc.Sync.enableAllocationLimit_entry() //  []
         { info_tbl: [(c9OPU,
                       label: GHC.Conc.Sync.enableAllocationLimit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OPU: // global
           call GHC.Conc.Sync.enableAllocationLimit1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.153342898 UTC

[section ""data" . GHC.Conc.Sync.getAllocationCounter1_closure" {
     GHC.Conc.Sync.getAllocationCounter1_closure:
         const GHC.Conc.Sync.getAllocationCounter1_info;
 },
 GHC.Conc.Sync.getAllocationCounter1_entry() //  []
         { info_tbl: [(c9OQ8,
                       label: GHC.Conc.Sync.getAllocationCounter1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OQ8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9OQc; else goto c9OQb;
       c9OQc: // global
           HpAlloc = 16;
           R1 = GHC.Conc.Sync.getAllocationCounter1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c9OQb: // global
           (_s9M9w::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [signed] rts_getThreadAllocationCounter(CurrentTSO);
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s9M9w::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.157103353 UTC

[section ""data" . GHC.Conc.Sync.getAllocationCounter_closure" {
     GHC.Conc.Sync.getAllocationCounter_closure:
         const GHC.Conc.Sync.getAllocationCounter_info;
 },
 GHC.Conc.Sync.getAllocationCounter_entry() //  []
         { info_tbl: [(c9OQn,
                       label: GHC.Conc.Sync.getAllocationCounter_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OQn: // global
           call GHC.Conc.Sync.getAllocationCounter1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.160428514 UTC

[section ""data" . GHC.Conc.Sync.setAllocationCounter1_closure" {
     GHC.Conc.Sync.setAllocationCounter1_closure:
         const GHC.Conc.Sync.setAllocationCounter1_info;
 },
 GHC.Conc.Sync.setAllocationCounter1_entry() //  [R2]
         { info_tbl: [(c9OQB,
                       label: GHC.Conc.Sync.setAllocationCounter1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OQB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9OQC; else goto c9OQD;
       c9OQC: // global
           R2 = R2;
           R1 = GHC.Conc.Sync.setAllocationCounter1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9OQD: // global
           I64[Sp - 16] = block_c9OQy_info;
           R1 = R2;
           I64[Sp - 8] = CurrentTSO;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u9OQK; else goto c9OQz;
       u9OQK: // global
           call _c9OQy(R1) args: 0, res: 0, upd: 0;
       c9OQz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9OQy() //  [R1]
         { info_tbl: [(c9OQy,
                       label: block_c9OQy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OQy: // global
           call "ccall" arg hints:  [PtrHint,
                                     signed]  result hints:  [] rts_setThreadAllocationCounter(P64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.166303244 UTC

[section ""data" . GHC.Conc.Sync.setAllocationCounter_closure" {
     GHC.Conc.Sync.setAllocationCounter_closure:
         const GHC.Conc.Sync.setAllocationCounter_info;
 },
 GHC.Conc.Sync.setAllocationCounter_entry() //  [R2]
         { info_tbl: [(c9OR2,
                       label: GHC.Conc.Sync.setAllocationCounter_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OR2: // global
           R2 = R2;
           call GHC.Conc.Sync.setAllocationCounter1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.169497693 UTC

[section ""data" . GHC.Conc.Sync.TVar_closure" {
     GHC.Conc.Sync.TVar_closure:
         const GHC.Conc.Sync.TVar_info;
 },
 GHC.Conc.Sync.TVar_entry() //  [R2]
         { info_tbl: [(c9ORe,
                       label: GHC.Conc.Sync.TVar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ORe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9ORi; else goto c9ORh;
       c9ORi: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.TVar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9ORh: // global
           I64[Hp - 8] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.172979574 UTC

[section ""data" . GHC.Conc.Sync.ThreadRunning_closure" {
     GHC.Conc.Sync.ThreadRunning_closure:
         const GHC.Conc.Sync.ThreadRunning_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.17459541 UTC

[section ""data" . GHC.Conc.Sync.ThreadFinished_closure" {
     GHC.Conc.Sync.ThreadFinished_closure:
         const GHC.Conc.Sync.ThreadFinished_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.176900795 UTC

[section ""data" . GHC.Conc.Sync.ThreadBlocked_closure" {
     GHC.Conc.Sync.ThreadBlocked_closure:
         const GHC.Conc.Sync.ThreadBlocked_info;
 },
 GHC.Conc.Sync.ThreadBlocked_entry() //  [R2]
         { info_tbl: [(c9ORw,
                       label: GHC.Conc.Sync.ThreadBlocked_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ORw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9ORA; else goto c9ORz;
       c9ORA: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.ThreadBlocked_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9ORz: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadBlocked_con_info;
           P64[Hp] = R2;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.180843953 UTC

[section ""data" . GHC.Conc.Sync.ThreadDied_closure" {
     GHC.Conc.Sync.ThreadDied_closure:
         const GHC.Conc.Sync.ThreadDied_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.182463839 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnMVar_closure" {
     GHC.Conc.Sync.BlockedOnMVar_closure:
         const GHC.Conc.Sync.BlockedOnMVar_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.184051134 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnBlackHole_closure" {
     GHC.Conc.Sync.BlockedOnBlackHole_closure:
         const GHC.Conc.Sync.BlockedOnBlackHole_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.18566685 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnException_closure" {
     GHC.Conc.Sync.BlockedOnException_closure:
         const GHC.Conc.Sync.BlockedOnException_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.187215111 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnSTM_closure" {
     GHC.Conc.Sync.BlockedOnSTM_closure:
         const GHC.Conc.Sync.BlockedOnSTM_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.188801278 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnForeignCall_closure" {
     GHC.Conc.Sync.BlockedOnForeignCall_closure:
         const GHC.Conc.Sync.BlockedOnForeignCall_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.190871425 UTC

[section ""data" . GHC.Conc.Sync.BlockedOnOther_closure" {
     GHC.Conc.Sync.BlockedOnOther_closure:
         const GHC.Conc.Sync.BlockedOnOther_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.192727743 UTC

[section ""data" . GHC.Conc.Sync.ThreadId_closure" {
     GHC.Conc.Sync.ThreadId_closure:
         const GHC.Conc.Sync.ThreadId_info;
 },
 GHC.Conc.Sync.ThreadId_entry() //  [R2]
         { info_tbl: [(c9ORT,
                       label: GHC.Conc.Sync.ThreadId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9ORT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9ORX; else goto c9ORW;
       c9ORX: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Conc.Sync.ThreadId_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9ORW: // global
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.196277515 UTC

[GHC.Conc.Sync.TVar_con_entry() //  [R1]
         { info_tbl: [(c9OS4,
                       label: GHC.Conc.Sync.TVar_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OS4: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.199300031 UTC

[GHC.Conc.Sync.ThreadRunning_con_entry() //  [R1]
         { info_tbl: [(c9OSb,
                       label: GHC.Conc.Sync.ThreadRunning_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,82,117,110,110,105,110,103]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OSb: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.203213204 UTC

[GHC.Conc.Sync.ThreadFinished_con_entry() //  [R1]
         { info_tbl: [(c9OSi,
                       label: GHC.Conc.Sync.ThreadFinished_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,70,105,110,105,115,104,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OSi: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.206446345 UTC

[GHC.Conc.Sync.ThreadBlocked_con_entry() //  [R1]
         { info_tbl: [(c9OSp,
                       label: GHC.Conc.Sync.ThreadBlocked_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,66,108,111,99,107,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OSp: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.209518096 UTC

[GHC.Conc.Sync.ThreadDied_con_entry() //  [R1]
         { info_tbl: [(c9OSw,
                       label: GHC.Conc.Sync.ThreadDied_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,68,105,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OSw: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.212541181 UTC

[section ""relreadonly" . GHC.Conc.Sync.BlockReason_closure_tbl" {
     GHC.Conc.Sync.BlockReason_closure_tbl:
         const GHC.Conc.Sync.BlockedOnMVar_closure+1;
         const GHC.Conc.Sync.BlockedOnBlackHole_closure+2;
         const GHC.Conc.Sync.BlockedOnException_closure+3;
         const GHC.Conc.Sync.BlockedOnSTM_closure+4;
         const GHC.Conc.Sync.BlockedOnForeignCall_closure+5;
         const GHC.Conc.Sync.BlockedOnOther_closure+6;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.214670214 UTC

[GHC.Conc.Sync.BlockedOnMVar_con_entry() //  [R1]
         { info_tbl: [(c9OSE,
                       label: GHC.Conc.Sync.BlockedOnMVar_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,77,86,97,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OSE: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.217843427 UTC

[GHC.Conc.Sync.BlockedOnBlackHole_con_entry() //  [R1]
         { info_tbl: [(c9OSL,
                       label: GHC.Conc.Sync.BlockedOnBlackHole_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,66,108,97,99,107,72,111,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OSL: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.220942688 UTC

[GHC.Conc.Sync.BlockedOnException_con_entry() //  [R1]
         { info_tbl: [(c9OSS,
                       label: GHC.Conc.Sync.BlockedOnException_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,69,120,99,101,112,116,105,111,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OSS: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.223990591 UTC

[GHC.Conc.Sync.BlockedOnSTM_con_entry() //  [R1]
         { info_tbl: [(c9OSZ,
                       label: GHC.Conc.Sync.BlockedOnSTM_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 3
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,83,84,77]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OSZ: // global
           R1 = R1 + 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.227408872 UTC

[GHC.Conc.Sync.BlockedOnForeignCall_con_entry() //  [R1]
         { info_tbl: [(c9OT6,
                       label: GHC.Conc.Sync.BlockedOnForeignCall_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 4
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,70,111,114,101,105,103,110,67,97,108,108]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OT6: // global
           R1 = R1 + 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.231002616 UTC

[GHC.Conc.Sync.BlockedOnOther_con_entry() //  [R1]
         { info_tbl: [(c9OTd,
                       label: GHC.Conc.Sync.BlockedOnOther_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 5
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,66,108,111,99,107,101,100,79,110,79,116,104,101,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OTd: // global
           R1 = R1 + 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.234223854 UTC

[GHC.Conc.Sync.ThreadId_con_entry() //  [R1]
         { info_tbl: [(c9OTk,
                       label: GHC.Conc.Sync.ThreadId_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,67,111,110,99,46,83,121,110,99,46,84,104,114,101,97,100,73,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9OTk: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:54.237235423 UTC

[section ""relreadonly" . S9MdE_srt" {
     S9MdE_srt:
         const GHC.Conc.Sync.$w$cshowsPrec_closure;
         const GHC.Conc.Sync.$fShowBlockReason1_closure;
         const GHC.Conc.Sync.$fShowBlockReason3_closure;
         const GHC.Conc.Sync.$fShowBlockReason5_closure;
         const GHC.Conc.Sync.$fShowBlockReason7_closure;
         const GHC.Conc.Sync.$fShowBlockReason9_closure;
         const GHC.Conc.Sync.$fShowBlockReason11_closure;
         const GHC.Conc.Sync.$fShowBlockReason_$cshow_closure;
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const GHC.Conc.Sync.labelThread1_closure;
         const GHC.Conc.Sync.$fShowThreadStatus5_closure;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshowsPrec_closure;
         const GHC.Conc.Sync.$fShowThreadStatus3_closure;
         const GHC.Conc.Sync.$fShowThreadStatus7_closure;
         const GHC.Conc.Sync.$fShowThreadStatus9_closure;
         const GHC.Conc.Sync.$fShowThreadStatus_$cshow_closure;
         const GHC.Conc.Sync.$fShowThreadStatus1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
         const GHC.Conc.Sync.killThread1_closure;
         const GHC.Conc.Sync.killThread2_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Conc.Sync.always3_closure;
         const GHC.Conc.Sync.always1_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.hFlush_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const lvl3_r9Fve_closure;
         const lvl4_r9Fvf_closure;
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const lvl6_r9Fvh_closure;
         const lvl8_r9Fvj_closure;
         const lvl9_r9Fvk_closure;
         const lvl10_r9Fvl_closure;
         const GHC.Conc.Sync.uncaughtExceptionHandler_closure;
         const GHC.Conc.Sync.setUncaughtExceptionHandler1_closure;
         const GHC.Conc.Sync.getUncaughtExceptionHandler1_closure;
         const GHC.Conc.Sync.reportError1_closure;
         const GHC.Conc.Sync.childHandler1_closure;
         const GHC.IO.Exception.$fExceptionAllocationLimitExceeded6_closure;
         const GHC.IO.Exception.$fExceptionAsyncException9_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnSTM3_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Sync.forkOn1_closure;
         const GHC.Conc.Sync.forkOnWithUnmask1_closure;
         const GHC.Conc.Sync.forkIO1_closure;
         const GHC.Conc.Sync.forkIOWithUnmask1_closure;
         const lvl13_r9Fvo_closure;
         const GHC.IO.failIO1_closure;
         const GHC.Conc.Sync.$wlvl_closure;
         const GHC.Conc.Sync.setNumCapabilities2_closure;
         const GHC.Conc.Sync.setNumCapabilities1_closure;
 }]

