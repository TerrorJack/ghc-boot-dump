
==================== Output Cmm ====================
2018-03-16 16:05:22.938922507 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:22.93953039 UTC

[section ""cstring" . GHC.Conc.Signal.$trModule4_bytes" {
     GHC.Conc.Signal.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.940103061 UTC

[section ""data" . GHC.Conc.Signal.$trModule3_closure" {
     GHC.Conc.Signal.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Signal.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.940696097 UTC

[section ""cstring" . GHC.Conc.Signal.$trModule2_bytes" {
     GHC.Conc.Signal.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,83,105,103,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.941323902 UTC

[section ""data" . GHC.Conc.Signal.$trModule1_closure" {
     GHC.Conc.Signal.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Signal.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.941872052 UTC

[section ""data" . GHC.Conc.Signal.$trModule_closure" {
     GHC.Conc.Signal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.Signal.$trModule3_closure+1;
         const GHC.Conc.Signal.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.942432764 UTC

[section ""data" . lvl_ramSF_closure" {
     lvl_ramSF_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.942994192 UTC

[section ""data" . lvl1_ramSG_closure" {
     lvl1_ramSG_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.944662713 UTC

[section ""data" . lvl2_ramSH_closure" {
     lvl2_ramSH_closure:
         const lvl2_ramSH_info;
 },
 sat_samTm_entry() //  [R1]
         { info_tbl: [(camWT,
                       label: sat_samTm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camWT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto camWU; else goto camWV;
       camWU: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       camWV: // global
           I64[Sp - 16] = block_camWK_info;
           _samSX::P64 = P64[R1 + 7];
           R1 = _samSX::P64;
           P64[Sp - 8] = _samSX::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _camWK() //  [R1]
         { info_tbl: [(camWK,
                       label: block_camWK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camWK: // global
           _samSX::P64 = P64[Sp + 8];
           (_samTh::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetGHCConcSignalSignalHandlerStore(R1);
           if (R1 == _samTh::I64) goto camWS; else goto camWR;
       camWS: // global
           R1 = _samSX::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       camWR: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _samTh::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl2_ramSH_entry() //  []
         { info_tbl: [(camX3,
                       label: lvl2_ramSH_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camX3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto camX4; else goto camX5;
       camX4: // global
           R1 = lvl2_ramSH_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       camX5: // global
           I64[Sp - 8] = block_camWq_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _camWq() //  []
         { info_tbl: [(camWq,
                       label: block_camWq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camWq: // global
           I64[Sp] = block_camWs_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = 65;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _camWs() //  [R1]
         { info_tbl: [(camWs,
                       label: block_camWs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camWs: // global
           I64[Sp - 8] = block_camWu_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _camWu() //  [R1]
         { info_tbl: [(camWu,
                       label: block_camWu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camWu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto camXa; else goto camX9;
       camXa: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       camX9: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl_ramSF_closure+1;
           P64[Hp - 16] = lvl1_ramSG_closure+1;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = 65;
           I64[Sp] = block_camWx_info;
           R2 = Hp - 31;
           _samSR::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _samSR::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _camWx() //  []
         { info_tbl: [(camWx,
                       label: block_camWx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camWx: // global
           I64[Sp] = block_camWz_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _camWz() //  [R1]
         { info_tbl: [(camWz,
                       label: block_camWz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camWz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto camXe; else goto camXd;
       camXe: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       camXd: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _camWB::P64 = Hp - 23;
           if (R1 == 0) goto camX2; else goto camX1;
       camX2: // global
           I64[Hp - 8] = sat_samTm_info;
           P64[Hp] = _camWB::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       camX1: // global
           Hp = Hp - 16;
           I64[Sp] = block_camXf_info;
           R1 = _camWB::P64;
           P64[Sp + 8] = _camWB::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _camXf() //  [R1]
         { info_tbl: [(camXf,
                       label: block_camXf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camXf: // global
           _camWB::P64 = P64[Sp + 8];
           (_samT5::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetGHCConcSignalSignalHandlerStore(R1);
           if (R1 == _samT5::I64) goto camXo; else goto camXn;
       camXo: // global
           R1 = _camWB::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       camXn: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _samT5::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.947390551 UTC

[section ""data" . GHC.Conc.Signal.signal_handlers_closure" {
     GHC.Conc.Signal.signal_handlers_closure:
         const GHC.Conc.Signal.signal_handlers_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Signal.signal_handlers_entry() //  [R1]
         { info_tbl: [(camXA,
                       label: GHC.Conc.Signal.signal_handlers_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camXA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto camXB; else goto camXC;
       camXB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       camXC: // global
           (_camXv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_camXv::I64 == 0) goto camXx; else goto camXw;
       camXx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       camXw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _camXv::I64;
           I64[Sp - 24] = block_camXy_info;
           Sp = Sp - 24;
           call lvl2_ramSH_entry() args: 8, res: 8, upd: 24;
     }
 },
 _camXy() //  [R1]
         { info_tbl: [(camXy,
                       label: block_camXy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camXy: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.948367382 UTC

[section ""cstring" . lvl3_ramSI_bytes" {
     lvl3_ramSI_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,115,101,116,72,97,110,100,108,101,114,58,32,115,105,103,110,97,108,32,111,117,116,32,111,102,32,114,97,110,103,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.94914613 UTC

[section ""data" . GHC.Conc.Signal.setHandler2_closure" {
     GHC.Conc.Signal.setHandler2_closure:
         const GHC.Conc.Signal.setHandler2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Signal.setHandler2_entry() //  [R1]
         { info_tbl: [(camXM,
                       label: GHC.Conc.Signal.setHandler2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camXM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto camXN; else goto camXO;
       camXN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       camXO: // global
           (_camXH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_camXH::I64 == 0) goto camXJ; else goto camXI;
       camXJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       camXI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _camXH::I64;
           I64[Sp - 24] = block_camXK_info;
           R2 = lvl3_ramSI_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _camXK() //  [R1]
         { info_tbl: [(camXK,
                       label: block_camXK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camXK: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.953197928 UTC

[section ""data" . GHC.Conc.Signal.setHandler1_closure" {
     GHC.Conc.Signal.setHandler1_closure:
         const GHC.Conc.Signal.setHandler1_info;
         const 0;
 },
 io_samTx_entry() //  [R1, R2]
         { info_tbl: [(camY7,
                       label: io_samTx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camY7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto camYl; else goto camYm;
       camYl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       camYm: // global
           I64[Sp - 24] = block_camY4_info;
           _samTr::P64 = P64[R1 + 6];
           _samTs::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _samTr::P64;
           P64[Sp - 8] = _samTs::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uamYI; else goto camY5;
       uamYI: // global
           call _camY4(R1) args: 0, res: 0, upd: 0;
       camY5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _camY4() //  [R1]
         { info_tbl: [(camY4,
                       label: block_camY4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camY4: // global
           I64[Sp - 16] = block_camYa_info;
           _samTC::P64 = P64[R1 + 15];
           _samTE::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _samTE::P64;
           P64[Sp] = _samTC::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uamYH; else goto camYb;
       uamYH: // global
           call _camYa(R1) args: 0, res: 0, upd: 0;
       camYb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _camYa() //  [R1]
         { info_tbl: [(camYa,
                       label: block_camYa_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camYa: // global
           I64[Sp] = block_camYf_info;
           _samTG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _samTG::I64;
           if (R1 & 7 != 0) goto uamYJ; else goto camYg;
       uamYJ: // global
           call _camYf(R1) args: 0, res: 0, upd: 0;
       camYg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _camYf() //  [R1]
         { info_tbl: [(camYf,
                       label: block_camYf_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camYf: // global
           I64[Sp] = block_camYk_info;
           _samTI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _samTI::I64;
           if (R1 & 7 != 0) goto uamYK; else goto camYq;
       uamYK: // global
           call _camYk(R1) args: 0, res: 0, upd: 0;
       camYq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _camYk() //  [R1]
         { info_tbl: [(camYk,
                       label: block_camYk_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camYk: // global
           _samTK::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _samTK::I64)) goto camYE; else goto camYG;
       camYG: // global
           if (%MO_S_Gt_W64(_samTK::I64,
                            I64[Sp + 24])) goto camYE; else goto camYF;
       camYE: // global
           R1 = GHC.Conc.Signal.setHandler2_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       camYF: // global
           _samTs::P64 = P64[Sp + 32];
           _samTE::P64 = P64[Sp + 8];
           _samTR::P64 = P64[(_samTE::P64 + 24) + (_samTK::I64 << 3)];
           call MO_WriteBarrier();
           P64[(_samTE::P64 + 24) + (_samTK::I64 << 3)] = _samTs::P64;
           I64[_samTE::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_samTE::P64 + 24) + ((I64[_samTE::P64 + 8] << 3) + (_samTK::I64 >> 7))] = 1 :: W8;
           R1 = _samTR::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samU4_entry() //  [R1, R2]
         { info_tbl: [(camZ1,
                       label: sat_samU4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camZ1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto camZ2; else goto camZ3;
       camZ2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       camZ3: // global
           I64[Sp - 16] = block_camYZ_info;
           _samU1::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samU1::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _camYZ() //  []
         { info_tbl: [(camYZ,
                       label: block_camYZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camYZ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samTZ_entry() //  [R1]
         { info_tbl: [(camZa,
                       label: sat_samTZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camZa: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samTx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samU0_entry() //  [R1]
         { info_tbl: [(camZi,
                       label: sat_samU0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camZi: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUk_entry() //  [R1, R2]
         { info_tbl: [(camZF,
                       label: sat_samUk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camZF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto camZG; else goto camZH;
       camZG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       camZH: // global
           I64[Sp - 16] = block_camZD_info;
           _samUh::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samUh::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _camZD() //  []
         { info_tbl: [(camZD,
                       label: block_camZD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camZD: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUf_entry() //  [R1]
         { info_tbl: [(camZO,
                       label: sat_samUf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camZO: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samTx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUg_entry() //  [R1]
         { info_tbl: [(camZW,
                       label: sat_samUg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camZW: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUp_entry() //  [R1]
         { info_tbl: [(camZZ,
                       label: sat_samUp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camZZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto can03; else goto can04;
       can03: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       can04: // global
           I64[Sp - 16] = block_camZr_info;
           _samTx::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp - 8] = _samTx::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uan0c; else goto camZs;
       uan0c: // global
           call _camZr(R1) args: 0, res: 0, upd: 0;
       camZs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _camZr() //  [R1]
         { info_tbl: [(camZr,
                       label: block_camZr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camZr: // global
           I64[Sp - 8] = block_camZw_info;
           _samUb::P64 = P64[R1 + 7];
           R1 = _samUb::P64;
           P64[Sp] = _samUb::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _camZw() //  [R1]
         { info_tbl: [(camZw,
                       label: block_camZw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camZw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto can08; else goto can07;
       can08: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       can07: // global
           I64[Hp - 56] = sat_samUk_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samUf_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samUg_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_can00_info;
           R2 = Hp - 54;
           _samUe::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samUe::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can00() //  [R1]
         { info_tbl: [(can00,
                       label: block_can00_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can00: // global
           _samUb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_can02_info;
           R2 = P64[Sp + 16];
           _samUn::P64 = R1;
           R1 = _samUb::P64;
           P64[Sp + 16] = _samUn::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can02() //  []
         { info_tbl: [(can02,
                       label: block_can02_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can02: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUA_entry() //  [R1, R2]
         { info_tbl: [(can0s,
                       label: sat_samUA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can0s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto can0t; else goto can0u;
       can0t: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       can0u: // global
           I64[Sp - 16] = block_can0q_info;
           _samUx::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samUx::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can0q() //  []
         { info_tbl: [(can0q,
                       label: block_can0q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can0q: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUv_entry() //  [R1]
         { info_tbl: [(can0B,
                       label: sat_samUv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can0B: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samTx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUw_entry() //  [R1]
         { info_tbl: [(can0J,
                       label: sat_samUw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can0J: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Signal.setHandler1_entry() //  [R2, R3]
         { info_tbl: [(can0Q,
                       label: GHC.Conc.Signal.setHandler1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can0Q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto can0R; else goto can0S;
       can0R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.setHandler1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       can0S: // global
           I64[Sp - 24] = block_camXX_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _camXX() //  [R1]
         { info_tbl: [(camXX,
                       label: block_camXX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camXX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto can0V; else goto can0U;
       can0V: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       can0U: // global
           I64[Hp - 32] = io_samTx_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           _camXZ::P64 = Hp - 30;
           if (R1 == 0) goto can0O; else goto uan1g;
       can0O: // global
           I64[Hp - 8] = sat_samUp_info;
           P64[Hp] = _camXZ::P64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uan1g: // global
           if (R1 == 1) goto can0P; else goto can0N;
       can0P: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_can0e_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _camXZ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uan1i; else goto can0f;
       uan1i: // global
           call _can0e(R1) args: 0, res: 0, upd: 0;
       can0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       can0N: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_camYN_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _camXZ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uan1h; else goto camYO;
       uan1h: // global
           call _camYN(R1) args: 0, res: 0, upd: 0;
       camYO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can0e() //  [R1]
         { info_tbl: [(can0e,
                       label: block_can0e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can0e: // global
           I64[Sp - 8] = block_can0j_info;
           _samUr::P64 = P64[R1 + 7];
           R1 = _samUr::P64;
           P64[Sp] = _samUr::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can0j() //  [R1]
         { info_tbl: [(can0j,
                       label: block_can0j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can0j: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto can1c; else goto can1b;
       can1c: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       can1b: // global
           I64[Hp - 56] = sat_samUA_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samUv_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samUw_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_can16_info;
           R2 = Hp - 54;
           _samUu::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samUu::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can16() //  [R1]
         { info_tbl: [(can16,
                       label: block_can16_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can16: // global
           _samUr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_can18_info;
           R2 = P64[Sp + 16];
           _samUD::P64 = R1;
           R1 = _samUr::P64;
           P64[Sp + 16] = _samUD::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can18() //  []
         { info_tbl: [(can18,
                       label: block_can18_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can18: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _camYN() //  [R1]
         { info_tbl: [(camYN,
                       label: block_camYN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camYN: // global
           I64[Sp - 8] = block_camYS_info;
           _samTV::P64 = P64[R1 + 7];
           R1 = _samTV::P64;
           P64[Sp] = _samTV::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _camYS() //  [R1]
         { info_tbl: [(camYS,
                       label: block_camYS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       camYS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto can12; else goto can11;
       can12: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       can11: // global
           I64[Hp - 56] = sat_samU4_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samTZ_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samU0_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_can0W_info;
           R2 = Hp - 54;
           _samTY::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samTY::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can0W() //  [R1]
         { info_tbl: [(can0W,
                       label: block_can0W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can0W: // global
           _samTV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_can0Y_info;
           R2 = P64[Sp + 16];
           _samU7::P64 = R1;
           R1 = _samTV::P64;
           P64[Sp + 16] = _samU7::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can0Y() //  []
         { info_tbl: [(can0Y,
                       label: block_can0Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can0Y: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.96033032 UTC

[section ""data" . GHC.Conc.Signal.setHandler_closure" {
     GHC.Conc.Signal.setHandler_closure:
         const GHC.Conc.Signal.setHandler_info;
         const 0;
 },
 GHC.Conc.Signal.setHandler_entry() //  [R2, R3]
         { info_tbl: [(can1n,
                       label: GHC.Conc.Signal.setHandler_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can1n: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.setHandler1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.964775694 UTC

[section ""data" . GHC.Conc.Signal.runHandlers1_closure" {
     GHC.Conc.Signal.runHandlers1_closure:
         const GHC.Conc.Signal.runHandlers1_info;
         const 0;
 },
 sat_samV3_entry() //  [R1]
         { info_tbl: [(can28,
                       label: sat_samV3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can28: // global
           R2 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samV4_entry() //  [R1]
         { info_tbl: [(can2b,
                       label: sat_samV4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can2b: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto can2f; else goto can2e;
       can2f: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       can2e: // global
           _samUF::P64 = P64[R1 + 7];
           _samV0::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_samV3_info;
           P64[Hp - 8] = _samUF::P64;
           P64[Hp] = _samV0::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_samUL_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(can2g,
                       label: $wio_samUL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 17} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can2g: // global
           if ((Sp + -40) < SpLim) (likely: False) goto can2h; else goto can2i;
       can2h: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       can2i: // global
           I64[Sp - 40] = block_can1B_info;
           _samUF::P64 = P64[R1 + 4];
           R1 = P64[R1 + 12];
           P64[Sp - 32] = _samUF::P64;
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uan2L; else goto can1C;
       uan2L: // global
           call _can1B(R1) args: 0, res: 0, upd: 0;
       can1C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can1B() //  [R1]
         { info_tbl: [(can1B,
                       label: block_can1B_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can1B: // global
           _samUR::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _samUR::I64)) goto uan2D; else goto can2B;
       uan2D: // global
           Sp = Sp + 40;
           goto uan2I;
       can2B: // global
           if (%MO_S_Gt_W64(_samUR::I64,
                            I64[Sp + 24])) goto uan2E; else goto can2o;
       uan2E: // global
           Sp = Sp + 40;
           goto uan2I;
       uan2I: // global
           call _can2s() args: 0, res: 0, upd: 0;
       can2o: // global
           _samUW::P64 = P64[P64[Sp + 32] + ((_samUR::I64 << 3) + 24)];
           I64[Sp] = block_can1O_info;
           R1 = _samUW::P64;
           if (R1 & 7 != 0) goto uan2G; else goto can1P;
       uan2G: // global
           call _can1O(R1) args: 0, res: 0, upd: 0;
       can1P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can1O() //  [R1]
         { info_tbl: [(can1O,
                       label: block_can1O_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can1O: // global
           if (R1 & 7 == 1) goto uan2F; else goto can2v;
       uan2F: // global
           Sp = Sp + 40;
           call _can2s() args: 0, res: 0, upd: 0;
       can2v: // global
           I64[Sp] = block_can1U_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uan2J; else goto can1V;
       uan2J: // global
           call _can1U(R1) args: 0, res: 0, upd: 0;
       can1V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can2s() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can2s: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _can1U() //  [R1]
         { info_tbl: [(can1U,
                       label: block_can1U_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can1U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto can2y; else goto can2x;
       can2y: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       can2x: // global
           _samV0::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_samV4_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _samV0::P64;
           I64[Sp + 32] = block_can2t_info;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can2t() //  []
         { info_tbl: [(can2t,
                       label: block_can2t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can2t: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_samV8_entry() //  [R1, R2]
         { info_tbl: [(can2U,
                       label: io_samV8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can2U: // global
           if ((Sp + -32) < SpLim) (likely: False) goto can33; else goto can34;
       can33: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       can34: // global
           I64[Sp - 16] = block_can2R_info;
           _samUL::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _samUL::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uan3d; else goto can2S;
       uan3d: // global
           call _can2R(R1) args: 0, res: 0, upd: 0;
       can2S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can2R() //  [R1]
         { info_tbl: [(can2R,
                       label: block_can2R_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can2R: // global
           I64[Sp - 16] = block_can2X_info;
           _samVd::P64 = P64[R1 + 15];
           _samVf::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _samVf::P64;
           P64[Sp] = _samVd::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uan3c; else goto can2Y;
       uan3c: // global
           call _can2X(R1) args: 0, res: 0, upd: 0;
       can2Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can2X() //  [R1]
         { info_tbl: [(can2X,
                       label: block_can2X_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can2X: // global
           I64[Sp] = block_can32_info;
           _samVh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _samVh::I64;
           if (R1 & 7 != 0) goto uan3e; else goto can37;
       uan3e: // global
           call _can32(R1) args: 0, res: 0, upd: 0;
       can37: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can32() //  [R1]
         { info_tbl: [(can32,
                       label: block_can32_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can32: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 16];
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call $wio_samUL_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVv_entry() //  [R1, R2]
         { info_tbl: [(can3v,
                       label: sat_samVv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can3v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto can3w; else goto can3x;
       can3w: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       can3x: // global
           I64[Sp - 16] = block_can3t_info;
           _samVs::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samVs::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can3t() //  []
         { info_tbl: [(can3t,
                       label: block_can3t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can3t: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVq_entry() //  [R1]
         { info_tbl: [(can3E,
                       label: sat_samVq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can3E: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samV8_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVr_entry() //  [R1]
         { info_tbl: [(can3M,
                       label: sat_samVr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can3M: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVL_entry() //  [R1, R2]
         { info_tbl: [(can49,
                       label: sat_samVL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can49: // global
           if ((Sp + -16) < SpLim) (likely: False) goto can4a; else goto can4b;
       can4a: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       can4b: // global
           I64[Sp - 16] = block_can47_info;
           _samVI::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samVI::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can47() //  []
         { info_tbl: [(can47,
                       label: block_can47_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can47: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVG_entry() //  [R1]
         { info_tbl: [(can4i,
                       label: sat_samVG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can4i: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samV8_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVH_entry() //  [R1]
         { info_tbl: [(can4q,
                       label: sat_samVH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can4q: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVQ_entry() //  [R1]
         { info_tbl: [(can4t,
                       label: sat_samVQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can4t: // global
           if ((Sp + -24) < SpLim) (likely: False) goto can4x; else goto can4y;
       can4x: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       can4y: // global
           I64[Sp - 16] = block_can3V_info;
           _samV8::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp - 8] = _samV8::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uan4G; else goto can3W;
       uan4G: // global
           call _can3V(R1) args: 0, res: 0, upd: 0;
       can3W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can3V() //  [R1]
         { info_tbl: [(can3V,
                       label: block_can3V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can3V: // global
           I64[Sp - 8] = block_can40_info;
           _samVC::P64 = P64[R1 + 7];
           R1 = _samVC::P64;
           P64[Sp] = _samVC::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can40() //  [R1]
         { info_tbl: [(can40,
                       label: block_can40_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can40: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto can4C; else goto can4B;
       can4C: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       can4B: // global
           I64[Hp - 56] = sat_samVL_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samVG_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samVH_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_can4u_info;
           R2 = Hp - 54;
           _samVF::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samVF::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can4u() //  [R1]
         { info_tbl: [(can4u,
                       label: block_can4u_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can4u: // global
           _samVC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_can4w_info;
           R2 = P64[Sp + 16];
           _samVO::P64 = R1;
           R1 = _samVC::P64;
           P64[Sp + 16] = _samVO::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can4w() //  []
         { info_tbl: [(can4w,
                       label: block_can4w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can4w: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samW1_entry() //  [R1, R2]
         { info_tbl: [(can4W,
                       label: sat_samW1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can4W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto can4X; else goto can4Y;
       can4X: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       can4Y: // global
           I64[Sp - 16] = block_can4U_info;
           _samVY::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samVY::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can4U() //  []
         { info_tbl: [(can4U,
                       label: block_can4U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can4U: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVW_entry() //  [R1]
         { info_tbl: [(can55,
                       label: sat_samVW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can55: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samV8_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVX_entry() //  [R1]
         { info_tbl: [(can5d,
                       label: sat_samVX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can5d: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Signal.runHandlers1_entry() //  [R2, R3]
         { info_tbl: [(can5k,
                       label: GHC.Conc.Signal.runHandlers1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can5k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto can5l; else goto can5m;
       can5l: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.runHandlers1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       can5m: // global
           I64[Sp - 24] = block_can1u_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _can1u() //  [R1]
         { info_tbl: [(can1u,
                       label: block_can1u_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can1u: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto can5p; else goto can5o;
       can5p: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       can5o: // global
           I64[Hp - 48] = $wio_samUL_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = io_samV8_info;
           P64[Hp - 16] = Hp - 44;
           _can2M::P64 = Hp - 22;
           if (R1 == 0) goto can5i; else goto uan5K;
       can5i: // global
           I64[Hp - 8] = sat_samVQ_info;
           P64[Hp] = _can2M::P64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uan5K: // global
           if (R1 == 1) goto can5j; else goto can5h;
       can5j: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_can4I_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _can2M::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uan5M; else goto can4J;
       uan5M: // global
           call _can4I(R1) args: 0, res: 0, upd: 0;
       can4J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       can5h: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_can3h_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _can2M::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uan5L; else goto can3i;
       uan5L: // global
           call _can3h(R1) args: 0, res: 0, upd: 0;
       can3i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can4I() //  [R1]
         { info_tbl: [(can4I,
                       label: block_can4I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can4I: // global
           I64[Sp - 8] = block_can4N_info;
           _samVS::P64 = P64[R1 + 7];
           R1 = _samVS::P64;
           P64[Sp] = _samVS::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can4N() //  [R1]
         { info_tbl: [(can4N,
                       label: block_can4N_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can4N: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto can5G; else goto can5F;
       can5G: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       can5F: // global
           I64[Hp - 56] = sat_samW1_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samVW_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samVX_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_can5A_info;
           R2 = Hp - 54;
           _samVV::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samVV::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can5A() //  [R1]
         { info_tbl: [(can5A,
                       label: block_can5A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can5A: // global
           _samVS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_can5C_info;
           R2 = P64[Sp + 16];
           _samW4::P64 = R1;
           R1 = _samVS::P64;
           P64[Sp + 16] = _samW4::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can5C() //  []
         { info_tbl: [(can5C,
                       label: block_can5C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can5C: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _can3h() //  [R1]
         { info_tbl: [(can3h,
                       label: block_can3h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can3h: // global
           I64[Sp - 8] = block_can3m_info;
           _samVm::P64 = P64[R1 + 7];
           R1 = _samVm::P64;
           P64[Sp] = _samVm::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can3m() //  [R1]
         { info_tbl: [(can3m,
                       label: block_can3m_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can3m: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto can5w; else goto can5v;
       can5w: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       can5v: // global
           I64[Hp - 56] = sat_samVv_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samVq_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samVr_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_can5q_info;
           R2 = Hp - 54;
           _samVp::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samVp::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can5q() //  [R1]
         { info_tbl: [(can5q,
                       label: block_can5q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can5q: // global
           _samVm::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_can5s_info;
           R2 = P64[Sp + 16];
           _samVy::P64 = R1;
           R1 = _samVm::P64;
           P64[Sp + 16] = _samVy::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can5s() //  []
         { info_tbl: [(can5s,
                       label: block_can5s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can5s: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.975972818 UTC

[section ""data" . GHC.Conc.Signal.runHandlers_closure" {
     GHC.Conc.Signal.runHandlers_closure:
         const GHC.Conc.Signal.runHandlers_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlers_entry() //  [R2, R3]
         { info_tbl: [(can5R,
                       label: GHC.Conc.Signal.runHandlers_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can5R: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.977510636 UTC

[section ""data" . GHC.Conc.Signal.$wrunHandlersPtr_closure" {
     GHC.Conc.Signal.$wrunHandlersPtr_closure:
         const GHC.Conc.Signal.$wrunHandlersPtr_info;
         const 0;
 },
 GHC.Conc.Signal.$wrunHandlersPtr_entry() //  [R2, R3]
         { info_tbl: [(can64,
                       label: GHC.Conc.Signal.$wrunHandlersPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can64: // global
           if ((Sp + -40) < SpLim) (likely: False) goto can65; else goto can66;
       can65: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.$wrunHandlersPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       can66: // global
           I64[Sp - 24] = block_can5Y_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can5Y() //  [R1]
         { info_tbl: [(can5Y,
                       label: block_can5Y_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can5Y: // global
           I64[Sp - 8] = block_can60_info;
           R6 = I64[Sp + 8];
           R5 = 0;
           R4 = 0;
           R3 = free;
           R2 = R1;
           P64[Sp - 16] = GHC.Tuple.()_closure+1;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _can60() //  [R1]
         { info_tbl: [(can60,
                       label: block_can60_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can60: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto can6a; else goto can69;
       can6a: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       can69: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R3 = P64[Sp + 24];
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.979458532 UTC

[section ""data" . GHC.Conc.Signal.runHandlersPtr1_closure" {
     GHC.Conc.Signal.runHandlersPtr1_closure:
         const GHC.Conc.Signal.runHandlersPtr1_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlersPtr1_entry() //  [R2, R3]
         { info_tbl: [(can6i,
                       label: GHC.Conc.Signal.runHandlersPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can6i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto can6j; else goto can6k;
       can6j: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.runHandlersPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       can6k: // global
           I64[Sp - 16] = block_can6f_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uan6o; else goto can6g;
       uan6o: // global
           call _can6f(R1) args: 0, res: 0, upd: 0;
       can6g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can6f() //  [R1]
         { info_tbl: [(can6f,
                       label: block_can6f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can6f: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Signal.$wrunHandlersPtr_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.980892323 UTC

[section ""data" . GHC.Conc.Signal.runHandlersPtr_closure" {
     GHC.Conc.Signal.runHandlersPtr_closure:
         const GHC.Conc.Signal.runHandlersPtr_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlersPtr_entry() //  [R2, R3]
         { info_tbl: [(can6t,
                       label: GHC.Conc.Signal.runHandlersPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can6t: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.runHandlersPtr1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.981817506 UTC

[section ""relreadonly" . SamXS_srt" {
     SamXS_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Conc.Signal.setHandler2_closure;
         const GHC.Conc.Signal.signal_handlers_closure;
         const GHC.Conc.Signal.setHandler1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Signal.runHandlers1_closure;
         const GHC.ForeignPtr.$winsertCFinalizer_closure;
         const GHC.Conc.Signal.$wrunHandlersPtr_closure;
         const GHC.Conc.Signal.runHandlersPtr1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.982593852 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:22.98323742 UTC

[section ""cstring" . GHC.Conc.Signal.$trModule4_bytes" {
     GHC.Conc.Signal.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.983893508 UTC

[section ""data" . GHC.Conc.Signal.$trModule3_closure" {
     GHC.Conc.Signal.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Signal.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.984570409 UTC

[section ""cstring" . GHC.Conc.Signal.$trModule2_bytes" {
     GHC.Conc.Signal.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,83,105,103,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.985300561 UTC

[section ""data" . GHC.Conc.Signal.$trModule1_closure" {
     GHC.Conc.Signal.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Signal.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.985992317 UTC

[section ""data" . GHC.Conc.Signal.$trModule_closure" {
     GHC.Conc.Signal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.Signal.$trModule3_closure+1;
         const GHC.Conc.Signal.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.986742614 UTC

[section ""data" . lvl_ramSF_closure" {
     lvl_ramSF_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.987454629 UTC

[section ""data" . lvl1_ramSG_closure" {
     lvl1_ramSG_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.989396281 UTC

[section ""data" . lvl2_ramSH_closure" {
     lvl2_ramSH_closure:
         const lvl2_ramSH_info;
 },
 sat_samTm_entry() //  [R1]
         { info_tbl: [(can73,
                       label: sat_samTm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can73: // global
           if ((Sp + -16) < SpLim) (likely: False) goto can74; else goto can75;
       can74: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       can75: // global
           I64[Sp - 16] = block_can6U_info;
           _samSX::P64 = P64[R1 + 7];
           R1 = _samSX::P64;
           P64[Sp - 8] = _samSX::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can6U() //  [R1]
         { info_tbl: [(can6U,
                       label: block_can6U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can6U: // global
           _samSX::P64 = P64[Sp + 8];
           (_samTh::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetGHCConcSignalSignalHandlerStore(R1);
           if (R1 == _samTh::I64) goto can72; else goto can71;
       can72: // global
           R1 = _samSX::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       can71: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _samTh::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl2_ramSH_entry() //  []
         { info_tbl: [(can7d,
                       label: lvl2_ramSH_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can7d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto can7e; else goto can7f;
       can7e: // global
           R1 = lvl2_ramSH_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       can7f: // global
           I64[Sp - 8] = block_can6A_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _can6A() //  []
         { info_tbl: [(can6A,
                       label: block_can6A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can6A: // global
           I64[Sp] = block_can6C_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = 65;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can6C() //  [R1]
         { info_tbl: [(can6C,
                       label: block_can6C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can6C: // global
           I64[Sp - 8] = block_can6E_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _can6E() //  [R1]
         { info_tbl: [(can6E,
                       label: block_can6E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can6E: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto can7k; else goto can7j;
       can7k: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       can7j: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl_ramSF_closure+1;
           P64[Hp - 16] = lvl1_ramSG_closure+1;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = 65;
           I64[Sp] = block_can6H_info;
           R2 = Hp - 31;
           _samSR::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _samSR::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can6H() //  []
         { info_tbl: [(can6H,
                       label: block_can6H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can6H: // global
           I64[Sp] = block_can6J_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _can6J() //  [R1]
         { info_tbl: [(can6J,
                       label: block_can6J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can6J: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto can7o; else goto can7n;
       can7o: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       can7n: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _can6L::P64 = Hp - 23;
           if (R1 == 0) goto can7c; else goto can7b;
       can7c: // global
           I64[Hp - 8] = sat_samTm_info;
           P64[Hp] = _can6L::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       can7b: // global
           Hp = Hp - 16;
           I64[Sp] = block_can7p_info;
           R1 = _can6L::P64;
           P64[Sp + 8] = _can6L::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can7p() //  [R1]
         { info_tbl: [(can7p,
                       label: block_can7p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can7p: // global
           _can6L::P64 = P64[Sp + 8];
           (_samT5::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetGHCConcSignalSignalHandlerStore(R1);
           if (R1 == _samT5::I64) goto can7y; else goto can7x;
       can7y: // global
           R1 = _can6L::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       can7x: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _samT5::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.992937286 UTC

[section ""data" . GHC.Conc.Signal.signal_handlers_closure" {
     GHC.Conc.Signal.signal_handlers_closure:
         const GHC.Conc.Signal.signal_handlers_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Signal.signal_handlers_entry() //  [R1]
         { info_tbl: [(can7K,
                       label: GHC.Conc.Signal.signal_handlers_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can7K: // global
           if ((Sp + -24) < SpLim) (likely: False) goto can7L; else goto can7M;
       can7L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       can7M: // global
           (_can7F::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_can7F::I64 == 0) goto can7H; else goto can7G;
       can7H: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       can7G: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _can7F::I64;
           I64[Sp - 24] = block_can7I_info;
           Sp = Sp - 24;
           call lvl2_ramSH_entry() args: 8, res: 8, upd: 24;
     }
 },
 _can7I() //  [R1]
         { info_tbl: [(can7I,
                       label: block_can7I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can7I: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.994370759 UTC

[section ""cstring" . lvl3_ramSI_bytes" {
     lvl3_ramSI_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,115,101,116,72,97,110,100,108,101,114,58,32,115,105,103,110,97,108,32,111,117,116,32,111,102,32,114,97,110,103,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:22.995422373 UTC

[section ""data" . GHC.Conc.Signal.setHandler2_closure" {
     GHC.Conc.Signal.setHandler2_closure:
         const GHC.Conc.Signal.setHandler2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Signal.setHandler2_entry() //  [R1]
         { info_tbl: [(can7W,
                       label: GHC.Conc.Signal.setHandler2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can7W: // global
           if ((Sp + -24) < SpLim) (likely: False) goto can7X; else goto can7Y;
       can7X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       can7Y: // global
           (_can7R::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_can7R::I64 == 0) goto can7T; else goto can7S;
       can7T: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       can7S: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _can7R::I64;
           I64[Sp - 24] = block_can7U_info;
           R2 = lvl3_ramSI_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _can7U() //  [R1]
         { info_tbl: [(can7U,
                       label: block_can7U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can7U: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.000354449 UTC

[section ""data" . GHC.Conc.Signal.setHandler1_closure" {
     GHC.Conc.Signal.setHandler1_closure:
         const GHC.Conc.Signal.setHandler1_info;
         const 0;
 },
 io_samTx_entry() //  [R1, R2]
         { info_tbl: [(can8g,
                       label: io_samTx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can8g: // global
           if ((Sp + -40) < SpLim) (likely: False) goto can8u; else goto can8v;
       can8u: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       can8v: // global
           I64[Sp - 24] = block_can8d_info;
           _samTr::P64 = P64[R1 + 6];
           _samTs::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _samTr::P64;
           P64[Sp - 8] = _samTs::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uan8R; else goto can8e;
       uan8R: // global
           call _can8d(R1) args: 0, res: 0, upd: 0;
       can8e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can8d() //  [R1]
         { info_tbl: [(can8d,
                       label: block_can8d_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can8d: // global
           I64[Sp - 16] = block_can8j_info;
           _samTC::P64 = P64[R1 + 15];
           _samTE::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _samTE::P64;
           P64[Sp] = _samTC::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uan8Q; else goto can8k;
       uan8Q: // global
           call _can8j(R1) args: 0, res: 0, upd: 0;
       can8k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can8j() //  [R1]
         { info_tbl: [(can8j,
                       label: block_can8j_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can8j: // global
           I64[Sp] = block_can8o_info;
           _samTG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _samTG::I64;
           if (R1 & 7 != 0) goto uan8S; else goto can8p;
       uan8S: // global
           call _can8o(R1) args: 0, res: 0, upd: 0;
       can8p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can8o() //  [R1]
         { info_tbl: [(can8o,
                       label: block_can8o_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can8o: // global
           I64[Sp] = block_can8t_info;
           _samTI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _samTI::I64;
           if (R1 & 7 != 0) goto uan8T; else goto can8z;
       uan8T: // global
           call _can8t(R1) args: 0, res: 0, upd: 0;
       can8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can8t() //  [R1]
         { info_tbl: [(can8t,
                       label: block_can8t_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can8t: // global
           _samTK::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _samTK::I64)) goto can8N; else goto can8P;
       can8P: // global
           if (%MO_S_Gt_W64(_samTK::I64,
                            I64[Sp + 24])) goto can8N; else goto can8O;
       can8N: // global
           R1 = GHC.Conc.Signal.setHandler2_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       can8O: // global
           _samTs::P64 = P64[Sp + 32];
           _samTE::P64 = P64[Sp + 8];
           _samTR::P64 = P64[(_samTE::P64 + 24) + (_samTK::I64 << 3)];
           call MO_WriteBarrier();
           P64[(_samTE::P64 + 24) + (_samTK::I64 << 3)] = _samTs::P64;
           I64[_samTE::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_samTE::P64 + 24) + ((I64[_samTE::P64 + 8] << 3) + (_samTK::I64 >> 7))] = 1 :: W8;
           R1 = _samTR::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samU4_entry() //  [R1, R2]
         { info_tbl: [(can9a,
                       label: sat_samU4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can9a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto can9b; else goto can9c;
       can9b: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       can9c: // global
           I64[Sp - 16] = block_can98_info;
           _samU1::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samU1::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can98() //  []
         { info_tbl: [(can98,
                       label: block_can98_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can98: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samTZ_entry() //  [R1]
         { info_tbl: [(can9j,
                       label: sat_samTZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can9j: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samTx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samU0_entry() //  [R1]
         { info_tbl: [(can9r,
                       label: sat_samU0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can9r: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUk_entry() //  [R1, R2]
         { info_tbl: [(can9O,
                       label: sat_samUk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can9O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto can9P; else goto can9Q;
       can9P: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       can9Q: // global
           I64[Sp - 16] = block_can9M_info;
           _samUh::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samUh::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _can9M() //  []
         { info_tbl: [(can9M,
                       label: block_can9M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can9M: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUf_entry() //  [R1]
         { info_tbl: [(can9X,
                       label: sat_samUf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can9X: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samTx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUg_entry() //  [R1]
         { info_tbl: [(cana5,
                       label: sat_samUg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cana5: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUp_entry() //  [R1]
         { info_tbl: [(cana8,
                       label: sat_samUp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cana8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canac; else goto canad;
       canac: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canad: // global
           I64[Sp - 16] = block_can9A_info;
           _samTx::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp - 8] = _samTx::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanal; else goto can9B;
       uanal: // global
           call _can9A(R1) args: 0, res: 0, upd: 0;
       can9B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can9A() //  [R1]
         { info_tbl: [(can9A,
                       label: block_can9A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can9A: // global
           I64[Sp - 8] = block_can9F_info;
           _samUb::P64 = P64[R1 + 7];
           R1 = _samUb::P64;
           P64[Sp] = _samUb::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can9F() //  [R1]
         { info_tbl: [(can9F,
                       label: block_can9F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can9F: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canah; else goto canag;
       canah: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canag: // global
           I64[Hp - 56] = sat_samUk_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samUf_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samUg_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cana9_info;
           R2 = Hp - 54;
           _samUe::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samUe::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cana9() //  [R1]
         { info_tbl: [(cana9,
                       label: block_cana9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cana9: // global
           _samUb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canab_info;
           R2 = P64[Sp + 16];
           _samUn::P64 = R1;
           R1 = _samUb::P64;
           P64[Sp + 16] = _samUn::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canab() //  []
         { info_tbl: [(canab,
                       label: block_canab_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canab: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUA_entry() //  [R1, R2]
         { info_tbl: [(canaB,
                       label: sat_samUA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canaB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canaC; else goto canaD;
       canaC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canaD: // global
           I64[Sp - 16] = block_canaz_info;
           _samUx::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samUx::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canaz() //  []
         { info_tbl: [(canaz,
                       label: block_canaz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canaz: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUv_entry() //  [R1]
         { info_tbl: [(canaK,
                       label: sat_samUv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canaK: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samTx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUw_entry() //  [R1]
         { info_tbl: [(canaS,
                       label: sat_samUw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canaS: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Signal.setHandler1_entry() //  [R2, R3]
         { info_tbl: [(canaZ,
                       label: GHC.Conc.Signal.setHandler1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canaZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canb0; else goto canb1;
       canb0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.setHandler1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canb1: // global
           I64[Sp - 24] = block_can86_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _can86() //  [R1]
         { info_tbl: [(can86,
                       label: block_can86_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can86: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto canb4; else goto canb3;
       canb4: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       canb3: // global
           I64[Hp - 32] = io_samTx_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           _can88::P64 = Hp - 30;
           if (R1 == 0) goto canaX; else goto uanbp;
       canaX: // global
           I64[Hp - 8] = sat_samUp_info;
           P64[Hp] = _can88::P64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uanbp: // global
           if (R1 == 1) goto canaY; else goto canaW;
       canaY: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_canan_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _can88::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanbr; else goto canao;
       uanbr: // global
           call _canan(R1) args: 0, res: 0, upd: 0;
       canao: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       canaW: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_can8W_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _can88::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanbq; else goto can8X;
       uanbq: // global
           call _can8W(R1) args: 0, res: 0, upd: 0;
       can8X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canan() //  [R1]
         { info_tbl: [(canan,
                       label: block_canan_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canan: // global
           I64[Sp - 8] = block_canas_info;
           _samUr::P64 = P64[R1 + 7];
           R1 = _samUr::P64;
           P64[Sp] = _samUr::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canas() //  [R1]
         { info_tbl: [(canas,
                       label: block_canas_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canas: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canbl; else goto canbk;
       canbl: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canbk: // global
           I64[Hp - 56] = sat_samUA_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samUv_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samUw_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canbf_info;
           R2 = Hp - 54;
           _samUu::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samUu::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canbf() //  [R1]
         { info_tbl: [(canbf,
                       label: block_canbf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canbf: // global
           _samUr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canbh_info;
           R2 = P64[Sp + 16];
           _samUD::P64 = R1;
           R1 = _samUr::P64;
           P64[Sp + 16] = _samUD::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canbh() //  []
         { info_tbl: [(canbh,
                       label: block_canbh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canbh: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _can8W() //  [R1]
         { info_tbl: [(can8W,
                       label: block_can8W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can8W: // global
           I64[Sp - 8] = block_can91_info;
           _samTV::P64 = P64[R1 + 7];
           R1 = _samTV::P64;
           P64[Sp] = _samTV::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _can91() //  [R1]
         { info_tbl: [(can91,
                       label: block_can91_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       can91: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canbb; else goto canba;
       canbb: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canba: // global
           I64[Hp - 56] = sat_samU4_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samTZ_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samU0_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canb5_info;
           R2 = Hp - 54;
           _samTY::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samTY::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canb5() //  [R1]
         { info_tbl: [(canb5,
                       label: block_canb5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canb5: // global
           _samTV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canb7_info;
           R2 = P64[Sp + 16];
           _samU7::P64 = R1;
           R1 = _samTV::P64;
           P64[Sp + 16] = _samU7::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canb7() //  []
         { info_tbl: [(canb7,
                       label: block_canb7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canb7: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.010837526 UTC

[section ""data" . GHC.Conc.Signal.setHandler_closure" {
     GHC.Conc.Signal.setHandler_closure:
         const GHC.Conc.Signal.setHandler_info;
         const 0;
 },
 GHC.Conc.Signal.setHandler_entry() //  [R2, R3]
         { info_tbl: [(canbw,
                       label: GHC.Conc.Signal.setHandler_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canbw: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.setHandler1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.018971545 UTC

[section ""data" . GHC.Conc.Signal.runHandlers1_closure" {
     GHC.Conc.Signal.runHandlers1_closure:
         const GHC.Conc.Signal.runHandlers1_info;
         const 0;
 },
 sat_samV3_entry() //  [R1]
         { info_tbl: [(canch,
                       label: sat_samV3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canch: // global
           R2 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samV4_entry() //  [R1]
         { info_tbl: [(canck,
                       label: sat_samV4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canck: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto canco; else goto cancn;
       canco: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cancn: // global
           _samUF::P64 = P64[R1 + 7];
           _samV0::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_samV3_info;
           P64[Hp - 8] = _samUF::P64;
           P64[Hp] = _samV0::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_samUL_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(cancp,
                       label: $wio_samUL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 17} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cancp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cancq; else goto cancr;
       cancq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cancr: // global
           I64[Sp - 40] = block_canbK_info;
           _samUF::P64 = P64[R1 + 4];
           R1 = P64[R1 + 12];
           P64[Sp - 32] = _samUF::P64;
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uancU; else goto canbL;
       uancU: // global
           call _canbK(R1) args: 0, res: 0, upd: 0;
       canbL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canbK() //  [R1]
         { info_tbl: [(canbK,
                       label: block_canbK_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canbK: // global
           _samUR::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _samUR::I64)) goto uancM; else goto cancK;
       uancM: // global
           Sp = Sp + 40;
           goto uancR;
       cancK: // global
           if (%MO_S_Gt_W64(_samUR::I64,
                            I64[Sp + 24])) goto uancN; else goto cancx;
       uancN: // global
           Sp = Sp + 40;
           goto uancR;
       uancR: // global
           call _cancB() args: 0, res: 0, upd: 0;
       cancx: // global
           _samUW::P64 = P64[P64[Sp + 32] + ((_samUR::I64 << 3) + 24)];
           I64[Sp] = block_canbX_info;
           R1 = _samUW::P64;
           if (R1 & 7 != 0) goto uancP; else goto canbY;
       uancP: // global
           call _canbX(R1) args: 0, res: 0, upd: 0;
       canbY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canbX() //  [R1]
         { info_tbl: [(canbX,
                       label: block_canbX_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canbX: // global
           if (R1 & 7 == 1) goto uancO; else goto cancE;
       uancO: // global
           Sp = Sp + 40;
           call _cancB() args: 0, res: 0, upd: 0;
       cancE: // global
           I64[Sp] = block_canc3_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uancS; else goto canc4;
       uancS: // global
           call _canc3(R1) args: 0, res: 0, upd: 0;
       canc4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cancB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cancB: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _canc3() //  [R1]
         { info_tbl: [(canc3,
                       label: block_canc3_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canc3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cancH; else goto cancG;
       cancH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cancG: // global
           _samV0::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_samV4_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _samV0::P64;
           I64[Sp + 32] = block_cancC_info;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cancC() //  []
         { info_tbl: [(cancC,
                       label: block_cancC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cancC: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_samV8_entry() //  [R1, R2]
         { info_tbl: [(cand3,
                       label: io_samV8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cand3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto candc; else goto candd;
       candc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       candd: // global
           I64[Sp - 16] = block_cand0_info;
           _samUL::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _samUL::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uandm; else goto cand1;
       uandm: // global
           call _cand0(R1) args: 0, res: 0, upd: 0;
       cand1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cand0() //  [R1]
         { info_tbl: [(cand0,
                       label: block_cand0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cand0: // global
           I64[Sp - 16] = block_cand6_info;
           _samVd::P64 = P64[R1 + 15];
           _samVf::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _samVf::P64;
           P64[Sp] = _samVd::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uandl; else goto cand7;
       uandl: // global
           call _cand6(R1) args: 0, res: 0, upd: 0;
       cand7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cand6() //  [R1]
         { info_tbl: [(cand6,
                       label: block_cand6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cand6: // global
           I64[Sp] = block_candb_info;
           _samVh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _samVh::I64;
           if (R1 & 7 != 0) goto uandn; else goto candg;
       uandn: // global
           call _candb(R1) args: 0, res: 0, upd: 0;
       candg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _candb() //  [R1]
         { info_tbl: [(candb,
                       label: block_candb_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       candb: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 16];
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call $wio_samUL_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVv_entry() //  [R1, R2]
         { info_tbl: [(candE,
                       label: sat_samVv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       candE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto candF; else goto candG;
       candF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       candG: // global
           I64[Sp - 16] = block_candC_info;
           _samVs::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samVs::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _candC() //  []
         { info_tbl: [(candC,
                       label: block_candC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       candC: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVq_entry() //  [R1]
         { info_tbl: [(candN,
                       label: sat_samVq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       candN: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samV8_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVr_entry() //  [R1]
         { info_tbl: [(candV,
                       label: sat_samVr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       candV: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVL_entry() //  [R1, R2]
         { info_tbl: [(canei,
                       label: sat_samVL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canei: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canej; else goto canek;
       canej: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canek: // global
           I64[Sp - 16] = block_caneg_info;
           _samVI::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samVI::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caneg() //  []
         { info_tbl: [(caneg,
                       label: block_caneg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caneg: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVG_entry() //  [R1]
         { info_tbl: [(caner,
                       label: sat_samVG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caner: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samV8_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVH_entry() //  [R1]
         { info_tbl: [(canez,
                       label: sat_samVH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canez: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVQ_entry() //  [R1]
         { info_tbl: [(caneC,
                       label: sat_samVQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caneC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caneG; else goto caneH;
       caneG: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caneH: // global
           I64[Sp - 16] = block_cane4_info;
           _samV8::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp - 8] = _samV8::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaneP; else goto cane5;
       uaneP: // global
           call _cane4(R1) args: 0, res: 0, upd: 0;
       cane5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cane4() //  [R1]
         { info_tbl: [(cane4,
                       label: block_cane4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cane4: // global
           I64[Sp - 8] = block_cane9_info;
           _samVC::P64 = P64[R1 + 7];
           R1 = _samVC::P64;
           P64[Sp] = _samVC::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cane9() //  [R1]
         { info_tbl: [(cane9,
                       label: block_cane9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cane9: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto caneL; else goto caneK;
       caneL: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caneK: // global
           I64[Hp - 56] = sat_samVL_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samVG_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samVH_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_caneD_info;
           R2 = Hp - 54;
           _samVF::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samVF::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caneD() //  [R1]
         { info_tbl: [(caneD,
                       label: block_caneD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caneD: // global
           _samVC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_caneF_info;
           R2 = P64[Sp + 16];
           _samVO::P64 = R1;
           R1 = _samVC::P64;
           P64[Sp + 16] = _samVO::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _caneF() //  []
         { info_tbl: [(caneF,
                       label: block_caneF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caneF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samW1_entry() //  [R1, R2]
         { info_tbl: [(canf5,
                       label: sat_samW1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canf5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canf6; else goto canf7;
       canf6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canf7: // global
           I64[Sp - 16] = block_canf3_info;
           _samVY::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samVY::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canf3() //  []
         { info_tbl: [(canf3,
                       label: block_canf3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canf3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVW_entry() //  [R1]
         { info_tbl: [(canfe,
                       label: sat_samVW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canfe: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samV8_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVX_entry() //  [R1]
         { info_tbl: [(canfm,
                       label: sat_samVX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canfm: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Signal.runHandlers1_entry() //  [R2, R3]
         { info_tbl: [(canft,
                       label: GHC.Conc.Signal.runHandlers1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canft: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canfu; else goto canfv;
       canfu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.runHandlers1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canfv: // global
           I64[Sp - 24] = block_canbD_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _canbD() //  [R1]
         { info_tbl: [(canbD,
                       label: block_canbD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canbD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto canfy; else goto canfx;
       canfy: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       canfx: // global
           I64[Hp - 48] = $wio_samUL_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = io_samV8_info;
           P64[Hp - 16] = Hp - 44;
           _cancV::P64 = Hp - 22;
           if (R1 == 0) goto canfr; else goto uanfT;
       canfr: // global
           I64[Hp - 8] = sat_samVQ_info;
           P64[Hp] = _cancV::P64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uanfT: // global
           if (R1 == 1) goto canfs; else goto canfq;
       canfs: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_caneR_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _cancV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanfV; else goto caneS;
       uanfV: // global
           call _caneR(R1) args: 0, res: 0, upd: 0;
       caneS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       canfq: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_candq_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _cancV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanfU; else goto candr;
       uanfU: // global
           call _candq(R1) args: 0, res: 0, upd: 0;
       candr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caneR() //  [R1]
         { info_tbl: [(caneR,
                       label: block_caneR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caneR: // global
           I64[Sp - 8] = block_caneW_info;
           _samVS::P64 = P64[R1 + 7];
           R1 = _samVS::P64;
           P64[Sp] = _samVS::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _caneW() //  [R1]
         { info_tbl: [(caneW,
                       label: block_caneW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caneW: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canfP; else goto canfO;
       canfP: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canfO: // global
           I64[Hp - 56] = sat_samW1_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samVW_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samVX_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canfJ_info;
           R2 = Hp - 54;
           _samVV::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samVV::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canfJ() //  [R1]
         { info_tbl: [(canfJ,
                       label: block_canfJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canfJ: // global
           _samVS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canfL_info;
           R2 = P64[Sp + 16];
           _samW4::P64 = R1;
           R1 = _samVS::P64;
           P64[Sp + 16] = _samW4::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canfL() //  []
         { info_tbl: [(canfL,
                       label: block_canfL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canfL: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _candq() //  [R1]
         { info_tbl: [(candq,
                       label: block_candq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       candq: // global
           I64[Sp - 8] = block_candv_info;
           _samVm::P64 = P64[R1 + 7];
           R1 = _samVm::P64;
           P64[Sp] = _samVm::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _candv() //  [R1]
         { info_tbl: [(candv,
                       label: block_candv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       candv: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canfF; else goto canfE;
       canfF: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canfE: // global
           I64[Hp - 56] = sat_samVv_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samVq_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samVr_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canfz_info;
           R2 = Hp - 54;
           _samVp::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samVp::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canfz() //  [R1]
         { info_tbl: [(canfz,
                       label: block_canfz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canfz: // global
           _samVm::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canfB_info;
           R2 = P64[Sp + 16];
           _samVy::P64 = R1;
           R1 = _samVm::P64;
           P64[Sp + 16] = _samVy::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canfB() //  []
         { info_tbl: [(canfB,
                       label: block_canfB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canfB: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.027329345 UTC

[section ""data" . GHC.Conc.Signal.runHandlers_closure" {
     GHC.Conc.Signal.runHandlers_closure:
         const GHC.Conc.Signal.runHandlers_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlers_entry() //  [R2, R3]
         { info_tbl: [(cang0,
                       label: GHC.Conc.Signal.runHandlers_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cang0: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.028422109 UTC

[section ""data" . GHC.Conc.Signal.$wrunHandlersPtr_closure" {
     GHC.Conc.Signal.$wrunHandlersPtr_closure:
         const GHC.Conc.Signal.$wrunHandlersPtr_info;
         const 0;
 },
 GHC.Conc.Signal.$wrunHandlersPtr_entry() //  [R2, R3]
         { info_tbl: [(cangd,
                       label: GHC.Conc.Signal.$wrunHandlersPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cangd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cange; else goto cangf;
       cange: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.$wrunHandlersPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cangf: // global
           I64[Sp - 24] = block_cang7_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cang7() //  [R1]
         { info_tbl: [(cang7,
                       label: block_cang7_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cang7: // global
           I64[Sp - 8] = block_cang9_info;
           R6 = I64[Sp + 8];
           R5 = 0;
           R4 = 0;
           R3 = free;
           R2 = R1;
           P64[Sp - 16] = GHC.Tuple.()_closure+1;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _cang9() //  [R1]
         { info_tbl: [(cang9,
                       label: block_cang9_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cang9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cangj; else goto cangi;
       cangj: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cangi: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R3 = P64[Sp + 24];
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.029996715 UTC

[section ""data" . GHC.Conc.Signal.runHandlersPtr1_closure" {
     GHC.Conc.Signal.runHandlersPtr1_closure:
         const GHC.Conc.Signal.runHandlersPtr1_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlersPtr1_entry() //  [R2, R3]
         { info_tbl: [(cangr,
                       label: GHC.Conc.Signal.runHandlersPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cangr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cangs; else goto cangt;
       cangs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.runHandlersPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cangt: // global
           I64[Sp - 16] = block_cango_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uangx; else goto cangp;
       uangx: // global
           call _cango(R1) args: 0, res: 0, upd: 0;
       cangp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cango() //  [R1]
         { info_tbl: [(cango,
                       label: block_cango_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cango: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Signal.$wrunHandlersPtr_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.031081935 UTC

[section ""data" . GHC.Conc.Signal.runHandlersPtr_closure" {
     GHC.Conc.Signal.runHandlersPtr_closure:
         const GHC.Conc.Signal.runHandlersPtr_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlersPtr_entry() //  [R2, R3]
         { info_tbl: [(cangC,
                       label: GHC.Conc.Signal.runHandlersPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cangC: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.runHandlersPtr1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.031827649 UTC

[section ""relreadonly" . SamXS_srt" {
     SamXS_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Conc.Signal.setHandler2_closure;
         const GHC.Conc.Signal.signal_handlers_closure;
         const GHC.Conc.Signal.setHandler1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Signal.runHandlers1_closure;
         const GHC.ForeignPtr.$winsertCFinalizer_closure;
         const GHC.Conc.Signal.$wrunHandlersPtr_closure;
         const GHC.Conc.Signal.runHandlersPtr1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.032684473 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:23.033822092 UTC

[section ""cstring" . GHC.Conc.Signal.$trModule4_bytes" {
     GHC.Conc.Signal.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.035569768 UTC

[section ""data" . GHC.Conc.Signal.$trModule3_closure" {
     GHC.Conc.Signal.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Signal.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.037163888 UTC

[section ""cstring" . GHC.Conc.Signal.$trModule2_bytes" {
     GHC.Conc.Signal.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,83,105,103,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.038772833 UTC

[section ""data" . GHC.Conc.Signal.$trModule1_closure" {
     GHC.Conc.Signal.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Signal.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.040432183 UTC

[section ""data" . GHC.Conc.Signal.$trModule_closure" {
     GHC.Conc.Signal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.Signal.$trModule3_closure+1;
         const GHC.Conc.Signal.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.042116642 UTC

[section ""data" . lvl_ramSF_closure" {
     lvl_ramSF_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.043726433 UTC

[section ""data" . lvl1_ramSG_closure" {
     lvl1_ramSG_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.046654619 UTC

[section ""data" . lvl2_ramSH_closure" {
     lvl2_ramSH_closure:
         const lvl2_ramSH_info;
 },
 sat_samTm_entry() //  [R1]
         { info_tbl: [(canhj,
                       label: sat_samTm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canhj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canhk; else goto canhl;
       canhk: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canhl: // global
           I64[Sp - 16] = block_canha_info;
           _samSX::P64 = P64[R1 + 7];
           R1 = _samSX::P64;
           P64[Sp - 8] = _samSX::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canha() //  [R1]
         { info_tbl: [(canha,
                       label: block_canha_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canha: // global
           _samSX::P64 = P64[Sp + 8];
           (_samTh::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetGHCConcSignalSignalHandlerStore(R1);
           if (R1 == _samTh::I64) goto canhi; else goto canhh;
       canhi: // global
           R1 = _samSX::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       canhh: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _samTh::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl2_ramSH_entry() //  []
         { info_tbl: [(canht,
                       label: lvl2_ramSH_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canht: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canhu; else goto canhv;
       canhu: // global
           R1 = lvl2_ramSH_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canhv: // global
           I64[Sp - 8] = block_cangQ_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cangQ() //  []
         { info_tbl: [(cangQ,
                       label: block_cangQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cangQ: // global
           I64[Sp] = block_cangS_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = 65;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cangS() //  [R1]
         { info_tbl: [(cangS,
                       label: block_cangS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cangS: // global
           I64[Sp - 8] = block_cangU_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cangU() //  [R1]
         { info_tbl: [(cangU,
                       label: block_cangU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cangU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto canhA; else goto canhz;
       canhA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canhz: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl_ramSF_closure+1;
           P64[Hp - 16] = lvl1_ramSG_closure+1;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = 65;
           I64[Sp] = block_cangX_info;
           R2 = Hp - 31;
           _samSR::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _samSR::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cangX() //  []
         { info_tbl: [(cangX,
                       label: block_cangX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cangX: // global
           I64[Sp] = block_cangZ_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cangZ() //  [R1]
         { info_tbl: [(cangZ,
                       label: block_cangZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cangZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto canhE; else goto canhD;
       canhE: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       canhD: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _canh1::P64 = Hp - 23;
           if (R1 == 0) goto canhs; else goto canhr;
       canhs: // global
           I64[Hp - 8] = sat_samTm_info;
           P64[Hp] = _canh1::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       canhr: // global
           Hp = Hp - 16;
           I64[Sp] = block_canhF_info;
           R1 = _canh1::P64;
           P64[Sp + 8] = _canh1::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canhF() //  [R1]
         { info_tbl: [(canhF,
                       label: block_canhF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canhF: // global
           _canh1::P64 = P64[Sp + 8];
           (_samT5::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetGHCConcSignalSignalHandlerStore(R1);
           if (R1 == _samT5::I64) goto canhO; else goto canhN;
       canhO: // global
           R1 = _canh1::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       canhN: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _samT5::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.066378796 UTC

[section ""data" . GHC.Conc.Signal.signal_handlers_closure" {
     GHC.Conc.Signal.signal_handlers_closure:
         const GHC.Conc.Signal.signal_handlers_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Signal.signal_handlers_entry() //  [R1]
         { info_tbl: [(caniy,
                       label: GHC.Conc.Signal.signal_handlers_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caniy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caniz; else goto caniA;
       caniz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caniA: // global
           (_canit::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_canit::I64 == 0) goto caniv; else goto caniu;
       caniv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caniu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _canit::I64;
           I64[Sp - 24] = block_caniw_info;
           Sp = Sp - 24;
           call lvl2_ramSH_entry() args: 8, res: 8, upd: 24;
     }
 },
 _caniw() //  [R1]
         { info_tbl: [(caniw,
                       label: block_caniw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caniw: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.071876581 UTC

[section ""cstring" . lvl3_ramSI_bytes" {
     lvl3_ramSI_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,115,101,116,72,97,110,100,108,101,114,58,32,115,105,103,110,97,108,32,111,117,116,32,111,102,32,114,97,110,103,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.073811301 UTC

[section ""data" . GHC.Conc.Signal.setHandler2_closure" {
     GHC.Conc.Signal.setHandler2_closure:
         const GHC.Conc.Signal.setHandler2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Signal.setHandler2_entry() //  [R1]
         { info_tbl: [(caniX,
                       label: GHC.Conc.Signal.setHandler2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caniX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caniY; else goto caniZ;
       caniY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caniZ: // global
           (_caniS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caniS::I64 == 0) goto caniU; else goto caniT;
       caniU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caniT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caniS::I64;
           I64[Sp - 24] = block_caniV_info;
           R2 = lvl3_ramSI_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _caniV() //  [R1]
         { info_tbl: [(caniV,
                       label: block_caniV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       caniV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.082247622 UTC

[section ""data" . GHC.Conc.Signal.setHandler1_closure" {
     GHC.Conc.Signal.setHandler1_closure:
         const GHC.Conc.Signal.setHandler1_info;
         const 0;
 },
 io_samTx_entry() //  [R1, R2]
         { info_tbl: [(canjr,
                       label: io_samTx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canjr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canjF; else goto canjG;
       canjF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canjG: // global
           I64[Sp - 24] = block_canjo_info;
           _samTr::P64 = P64[R1 + 6];
           _samTs::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _samTr::P64;
           P64[Sp - 8] = _samTs::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uank2; else goto canjp;
       uank2: // global
           call _canjo(R1) args: 0, res: 0, upd: 0;
       canjp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canjo() //  [R1]
         { info_tbl: [(canjo,
                       label: block_canjo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canjo: // global
           I64[Sp - 16] = block_canju_info;
           _samTC::P64 = P64[R1 + 15];
           _samTE::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _samTE::P64;
           P64[Sp] = _samTC::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uank1; else goto canjv;
       uank1: // global
           call _canju(R1) args: 0, res: 0, upd: 0;
       canjv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canju() //  [R1]
         { info_tbl: [(canju,
                       label: block_canju_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canju: // global
           I64[Sp] = block_canjz_info;
           _samTG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _samTG::I64;
           if (R1 & 7 != 0) goto uank3; else goto canjA;
       uank3: // global
           call _canjz(R1) args: 0, res: 0, upd: 0;
       canjA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canjz() //  [R1]
         { info_tbl: [(canjz,
                       label: block_canjz_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canjz: // global
           I64[Sp] = block_canjE_info;
           _samTI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _samTI::I64;
           if (R1 & 7 != 0) goto uank4; else goto canjK;
       uank4: // global
           call _canjE(R1) args: 0, res: 0, upd: 0;
       canjK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canjE() //  [R1]
         { info_tbl: [(canjE,
                       label: block_canjE_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canjE: // global
           _samTK::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _samTK::I64)) goto canjY; else goto cank0;
       cank0: // global
           if (%MO_S_Gt_W64(_samTK::I64,
                            I64[Sp + 24])) goto canjY; else goto canjZ;
       canjY: // global
           R1 = GHC.Conc.Signal.setHandler2_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       canjZ: // global
           _samTs::P64 = P64[Sp + 32];
           _samTE::P64 = P64[Sp + 8];
           _samTR::P64 = P64[(_samTE::P64 + 24) + (_samTK::I64 << 3)];
           call MO_WriteBarrier();
           P64[(_samTE::P64 + 24) + (_samTK::I64 << 3)] = _samTs::P64;
           I64[_samTE::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_samTE::P64 + 24) + ((I64[_samTE::P64 + 8] << 3) + (_samTK::I64 >> 7))] = 1 :: W8;
           R1 = _samTR::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samU4_entry() //  [R1, R2]
         { info_tbl: [(cankl,
                       label: sat_samU4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cankl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cankm; else goto cankn;
       cankm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cankn: // global
           I64[Sp - 16] = block_cankj_info;
           _samU1::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samU1::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cankj() //  []
         { info_tbl: [(cankj,
                       label: block_cankj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cankj: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samTZ_entry() //  [R1]
         { info_tbl: [(canku,
                       label: sat_samTZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canku: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samTx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samU0_entry() //  [R1]
         { info_tbl: [(cankC,
                       label: sat_samU0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cankC: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUk_entry() //  [R1, R2]
         { info_tbl: [(cankZ,
                       label: sat_samUk_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cankZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canl0; else goto canl1;
       canl0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canl1: // global
           I64[Sp - 16] = block_cankX_info;
           _samUh::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samUh::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cankX() //  []
         { info_tbl: [(cankX,
                       label: block_cankX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cankX: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUf_entry() //  [R1]
         { info_tbl: [(canl8,
                       label: sat_samUf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canl8: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samTx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUg_entry() //  [R1]
         { info_tbl: [(canlg,
                       label: sat_samUg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canlg: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUp_entry() //  [R1]
         { info_tbl: [(canlj,
                       label: sat_samUp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canlj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canln; else goto canlo;
       canln: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canlo: // global
           I64[Sp - 16] = block_cankL_info;
           _samTx::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp - 8] = _samTx::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanlw; else goto cankM;
       uanlw: // global
           call _cankL(R1) args: 0, res: 0, upd: 0;
       cankM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cankL() //  [R1]
         { info_tbl: [(cankL,
                       label: block_cankL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cankL: // global
           I64[Sp - 8] = block_cankQ_info;
           _samUb::P64 = P64[R1 + 7];
           R1 = _samUb::P64;
           P64[Sp] = _samUb::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cankQ() //  [R1]
         { info_tbl: [(cankQ,
                       label: block_cankQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cankQ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canls; else goto canlr;
       canls: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canlr: // global
           I64[Hp - 56] = sat_samUk_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samUf_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samUg_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canlk_info;
           R2 = Hp - 54;
           _samUe::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samUe::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canlk() //  [R1]
         { info_tbl: [(canlk,
                       label: block_canlk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canlk: // global
           _samUb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canlm_info;
           R2 = P64[Sp + 16];
           _samUn::P64 = R1;
           R1 = _samUb::P64;
           P64[Sp + 16] = _samUn::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canlm() //  []
         { info_tbl: [(canlm,
                       label: block_canlm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canlm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUA_entry() //  [R1, R2]
         { info_tbl: [(canlM,
                       label: sat_samUA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canlM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canlN; else goto canlO;
       canlN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canlO: // global
           I64[Sp - 16] = block_canlK_info;
           _samUx::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samUx::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canlK() //  []
         { info_tbl: [(canlK,
                       label: block_canlK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canlK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUv_entry() //  [R1]
         { info_tbl: [(canlV,
                       label: sat_samUv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canlV: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samTx_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samUw_entry() //  [R1]
         { info_tbl: [(canm3,
                       label: sat_samUw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canm3: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Signal.setHandler1_entry() //  [R2, R3]
         { info_tbl: [(canma,
                       label: GHC.Conc.Signal.setHandler1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canma: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canmb; else goto canmc;
       canmb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.setHandler1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canmc: // global
           I64[Sp - 24] = block_canjh_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _canjh() //  [R1]
         { info_tbl: [(canjh,
                       label: block_canjh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canjh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto canmf; else goto canme;
       canmf: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       canme: // global
           I64[Hp - 32] = io_samTx_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           _canjj::P64 = Hp - 30;
           if (R1 == 0) goto canm8; else goto uanmA;
       canm8: // global
           I64[Hp - 8] = sat_samUp_info;
           P64[Hp] = _canjj::P64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uanmA: // global
           if (R1 == 1) goto canm9; else goto canm7;
       canm9: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_canly_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canjj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanmC; else goto canlz;
       uanmC: // global
           call _canly(R1) args: 0, res: 0, upd: 0;
       canlz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       canm7: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_cank7_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canjj::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanmB; else goto cank8;
       uanmB: // global
           call _cank7(R1) args: 0, res: 0, upd: 0;
       cank8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canly() //  [R1]
         { info_tbl: [(canly,
                       label: block_canly_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canly: // global
           I64[Sp - 8] = block_canlD_info;
           _samUr::P64 = P64[R1 + 7];
           R1 = _samUr::P64;
           P64[Sp] = _samUr::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canlD() //  [R1]
         { info_tbl: [(canlD,
                       label: block_canlD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canlD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canmw; else goto canmv;
       canmw: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canmv: // global
           I64[Hp - 56] = sat_samUA_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samUv_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samUw_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canmq_info;
           R2 = Hp - 54;
           _samUu::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samUu::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canmq() //  [R1]
         { info_tbl: [(canmq,
                       label: block_canmq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canmq: // global
           _samUr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canms_info;
           R2 = P64[Sp + 16];
           _samUD::P64 = R1;
           R1 = _samUr::P64;
           P64[Sp + 16] = _samUD::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canms() //  []
         { info_tbl: [(canms,
                       label: block_canms_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canms: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cank7() //  [R1]
         { info_tbl: [(cank7,
                       label: block_cank7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cank7: // global
           I64[Sp - 8] = block_cankc_info;
           _samTV::P64 = P64[R1 + 7];
           R1 = _samTV::P64;
           P64[Sp] = _samTV::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cankc() //  [R1]
         { info_tbl: [(cankc,
                       label: block_cankc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cankc: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canmm; else goto canml;
       canmm: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canml: // global
           I64[Hp - 56] = sat_samU4_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samTZ_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samU0_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canmg_info;
           R2 = Hp - 54;
           _samTY::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samTY::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canmg() //  [R1]
         { info_tbl: [(canmg,
                       label: block_canmg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canmg: // global
           _samTV::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canmi_info;
           R2 = P64[Sp + 16];
           _samU7::P64 = R1;
           R1 = _samTV::P64;
           P64[Sp + 16] = _samU7::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canmi() //  []
         { info_tbl: [(canmi,
                       label: block_canmi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canmi: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.140066675 UTC

[section ""data" . GHC.Conc.Signal.setHandler_closure" {
     GHC.Conc.Signal.setHandler_closure:
         const GHC.Conc.Signal.setHandler_info;
         const 0;
 },
 GHC.Conc.Signal.setHandler_entry() //  [R2, R3]
         { info_tbl: [(canoM,
                       label: GHC.Conc.Signal.setHandler_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canoM: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.setHandler1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.146913747 UTC

[section ""data" . GHC.Conc.Signal.runHandlers1_closure" {
     GHC.Conc.Signal.runHandlers1_closure:
         const GHC.Conc.Signal.runHandlers1_info;
         const 0;
 },
 sat_samV3_entry() //  [R1]
         { info_tbl: [(canpB,
                       label: sat_samV3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canpB: // global
           R2 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samV4_entry() //  [R1]
         { info_tbl: [(canpE,
                       label: sat_samV4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canpE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto canpI; else goto canpH;
       canpI: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canpH: // global
           _samUF::P64 = P64[R1 + 7];
           _samV0::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_samV3_info;
           P64[Hp - 8] = _samUF::P64;
           P64[Hp] = _samV0::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_samUL_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(canpJ,
                       label: $wio_samUL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 17} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canpJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canpK; else goto canpL;
       canpK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       canpL: // global
           I64[Sp - 40] = block_canp4_info;
           _samUF::P64 = P64[R1 + 4];
           R1 = P64[R1 + 12];
           P64[Sp - 32] = _samUF::P64;
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uanqe; else goto canp5;
       uanqe: // global
           call _canp4(R1) args: 0, res: 0, upd: 0;
       canp5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canp4() //  [R1]
         { info_tbl: [(canp4,
                       label: block_canp4_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canp4: // global
           _samUR::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _samUR::I64)) goto uanq6; else goto canq4;
       uanq6: // global
           Sp = Sp + 40;
           goto uanqb;
       canq4: // global
           if (%MO_S_Gt_W64(_samUR::I64,
                            I64[Sp + 24])) goto uanq7; else goto canpR;
       uanq7: // global
           Sp = Sp + 40;
           goto uanqb;
       uanqb: // global
           call _canpV() args: 0, res: 0, upd: 0;
       canpR: // global
           _samUW::P64 = P64[P64[Sp + 32] + ((_samUR::I64 << 3) + 24)];
           I64[Sp] = block_canph_info;
           R1 = _samUW::P64;
           if (R1 & 7 != 0) goto uanq9; else goto canpi;
       uanq9: // global
           call _canph(R1) args: 0, res: 0, upd: 0;
       canpi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canph() //  [R1]
         { info_tbl: [(canph,
                       label: block_canph_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canph: // global
           if (R1 & 7 == 1) goto uanq8; else goto canpY;
       uanq8: // global
           Sp = Sp + 40;
           call _canpV() args: 0, res: 0, upd: 0;
       canpY: // global
           I64[Sp] = block_canpn_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uanqc; else goto canpo;
       uanqc: // global
           call _canpn(R1) args: 0, res: 0, upd: 0;
       canpo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canpV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canpV: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _canpn() //  [R1]
         { info_tbl: [(canpn,
                       label: block_canpn_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canpn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto canq1; else goto canq0;
       canq1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canq0: // global
           _samV0::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_samV4_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _samV0::P64;
           I64[Sp + 32] = block_canpW_info;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canpW() //  []
         { info_tbl: [(canpW,
                       label: block_canpW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canpW: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_samV8_entry() //  [R1, R2]
         { info_tbl: [(canqn,
                       label: io_samV8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canqn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto canqw; else goto canqx;
       canqw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canqx: // global
           I64[Sp - 16] = block_canqk_info;
           _samUL::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _samUL::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanqG; else goto canql;
       uanqG: // global
           call _canqk(R1) args: 0, res: 0, upd: 0;
       canql: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canqk() //  [R1]
         { info_tbl: [(canqk,
                       label: block_canqk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canqk: // global
           I64[Sp - 16] = block_canqq_info;
           _samVd::P64 = P64[R1 + 15];
           _samVf::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _samVf::P64;
           P64[Sp] = _samVd::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanqF; else goto canqr;
       uanqF: // global
           call _canqq(R1) args: 0, res: 0, upd: 0;
       canqr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canqq() //  [R1]
         { info_tbl: [(canqq,
                       label: block_canqq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canqq: // global
           I64[Sp] = block_canqv_info;
           _samVh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _samVh::I64;
           if (R1 & 7 != 0) goto uanqH; else goto canqA;
       uanqH: // global
           call _canqv(R1) args: 0, res: 0, upd: 0;
       canqA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canqv() //  [R1]
         { info_tbl: [(canqv,
                       label: block_canqv_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canqv: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 16];
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call $wio_samUL_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVv_entry() //  [R1, R2]
         { info_tbl: [(canqY,
                       label: sat_samVv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canqY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canqZ; else goto canr0;
       canqZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canr0: // global
           I64[Sp - 16] = block_canqW_info;
           _samVs::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samVs::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canqW() //  []
         { info_tbl: [(canqW,
                       label: block_canqW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canqW: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVq_entry() //  [R1]
         { info_tbl: [(canr7,
                       label: sat_samVq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canr7: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samV8_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVr_entry() //  [R1]
         { info_tbl: [(canrf,
                       label: sat_samVr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canrf: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVL_entry() //  [R1, R2]
         { info_tbl: [(canrC,
                       label: sat_samVL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canrC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canrD; else goto canrE;
       canrD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canrE: // global
           I64[Sp - 16] = block_canrA_info;
           _samVI::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samVI::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canrA() //  []
         { info_tbl: [(canrA,
                       label: block_canrA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canrA: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVG_entry() //  [R1]
         { info_tbl: [(canrL,
                       label: sat_samVG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canrL: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samV8_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVH_entry() //  [R1]
         { info_tbl: [(canrT,
                       label: sat_samVH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canrT: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVQ_entry() //  [R1]
         { info_tbl: [(canrW,
                       label: sat_samVQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canrW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cans0; else goto cans1;
       cans0: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cans1: // global
           I64[Sp - 16] = block_canro_info;
           _samV8::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp - 8] = _samV8::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uans9; else goto canrp;
       uans9: // global
           call _canro(R1) args: 0, res: 0, upd: 0;
       canrp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canro() //  [R1]
         { info_tbl: [(canro,
                       label: block_canro_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canro: // global
           I64[Sp - 8] = block_canrt_info;
           _samVC::P64 = P64[R1 + 7];
           R1 = _samVC::P64;
           P64[Sp] = _samVC::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canrt() //  [R1]
         { info_tbl: [(canrt,
                       label: block_canrt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canrt: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cans5; else goto cans4;
       cans5: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cans4: // global
           I64[Hp - 56] = sat_samVL_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samVG_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samVH_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canrX_info;
           R2 = Hp - 54;
           _samVF::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samVF::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canrX() //  [R1]
         { info_tbl: [(canrX,
                       label: block_canrX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canrX: // global
           _samVC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canrZ_info;
           R2 = P64[Sp + 16];
           _samVO::P64 = R1;
           R1 = _samVC::P64;
           P64[Sp + 16] = _samVO::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canrZ() //  []
         { info_tbl: [(canrZ,
                       label: block_canrZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canrZ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samW1_entry() //  [R1, R2]
         { info_tbl: [(cansp,
                       label: sat_samW1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cansp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cansq; else goto cansr;
       cansq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cansr: // global
           I64[Sp - 16] = block_cansn_info;
           _samVY::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _samVY::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cansn() //  []
         { info_tbl: [(cansn,
                       label: block_cansn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cansn: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVW_entry() //  [R1]
         { info_tbl: [(cansy,
                       label: sat_samVW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cansy: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_samV8_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_samVX_entry() //  [R1]
         { info_tbl: [(cansG,
                       label: sat_samVX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cansG: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Signal.runHandlers1_entry() //  [R2, R3]
         { info_tbl: [(cansN,
                       label: GHC.Conc.Signal.runHandlers1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cansN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cansO; else goto cansP;
       cansO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.runHandlers1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cansP: // global
           I64[Sp - 24] = block_canoX_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _canoX() //  [R1]
         { info_tbl: [(canoX,
                       label: block_canoX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canoX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cansS; else goto cansR;
       cansS: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cansR: // global
           I64[Hp - 48] = $wio_samUL_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = io_samV8_info;
           P64[Hp - 16] = Hp - 44;
           _canqf::P64 = Hp - 22;
           if (R1 == 0) goto cansL; else goto uantd;
       cansL: // global
           I64[Hp - 8] = sat_samVQ_info;
           P64[Hp] = _canqf::P64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uantd: // global
           if (R1 == 1) goto cansM; else goto cansK;
       cansM: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_cansb_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canqf::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uantf; else goto cansc;
       uantf: // global
           call _cansb(R1) args: 0, res: 0, upd: 0;
       cansc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cansK: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_canqK_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canqf::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uante; else goto canqL;
       uante: // global
           call _canqK(R1) args: 0, res: 0, upd: 0;
       canqL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cansb() //  [R1]
         { info_tbl: [(cansb,
                       label: block_cansb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cansb: // global
           I64[Sp - 8] = block_cansg_info;
           _samVS::P64 = P64[R1 + 7];
           R1 = _samVS::P64;
           P64[Sp] = _samVS::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cansg() //  [R1]
         { info_tbl: [(cansg,
                       label: block_cansg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cansg: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cant9; else goto cant8;
       cant9: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cant8: // global
           I64[Hp - 56] = sat_samW1_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samVW_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samVX_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cant3_info;
           R2 = Hp - 54;
           _samVV::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samVV::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cant3() //  [R1]
         { info_tbl: [(cant3,
                       label: block_cant3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cant3: // global
           _samVS::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cant5_info;
           R2 = P64[Sp + 16];
           _samW4::P64 = R1;
           R1 = _samVS::P64;
           P64[Sp + 16] = _samW4::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cant5() //  []
         { info_tbl: [(cant5,
                       label: block_cant5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cant5: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _canqK() //  [R1]
         { info_tbl: [(canqK,
                       label: block_canqK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canqK: // global
           I64[Sp - 8] = block_canqP_info;
           _samVm::P64 = P64[R1 + 7];
           R1 = _samVm::P64;
           P64[Sp] = _samVm::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canqP() //  [R1]
         { info_tbl: [(canqP,
                       label: block_canqP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canqP: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cansZ; else goto cansY;
       cansZ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cansY: // global
           I64[Hp - 56] = sat_samVv_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_samVq_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_samVr_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cansT_info;
           R2 = Hp - 54;
           _samVp::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _samVp::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cansT() //  [R1]
         { info_tbl: [(cansT,
                       label: block_cansT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cansT: // global
           _samVm::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cansV_info;
           R2 = P64[Sp + 16];
           _samVy::P64 = R1;
           R1 = _samVm::P64;
           P64[Sp + 16] = _samVy::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cansV() //  []
         { info_tbl: [(cansV,
                       label: block_cansV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cansV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.217667967 UTC

[section ""data" . GHC.Conc.Signal.runHandlers_closure" {
     GHC.Conc.Signal.runHandlers_closure:
         const GHC.Conc.Signal.runHandlers_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlers_entry() //  [R2, R3]
         { info_tbl: [(canvO,
                       label: GHC.Conc.Signal.runHandlers_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canvO: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.221292372 UTC

[section ""data" . GHC.Conc.Signal.$wrunHandlersPtr_closure" {
     GHC.Conc.Signal.$wrunHandlersPtr_closure:
         const GHC.Conc.Signal.$wrunHandlersPtr_info;
         const 0;
 },
 GHC.Conc.Signal.$wrunHandlersPtr_entry() //  [R2, R3]
         { info_tbl: [(canw5,
                       label: GHC.Conc.Signal.$wrunHandlersPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canw5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canw6; else goto canw7;
       canw6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.$wrunHandlersPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canw7: // global
           I64[Sp - 24] = block_canvZ_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canvZ() //  [R1]
         { info_tbl: [(canvZ,
                       label: block_canvZ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canvZ: // global
           I64[Sp - 8] = block_canw1_info;
           R6 = I64[Sp + 8];
           R5 = 0;
           R4 = 0;
           R3 = free;
           R2 = R1;
           P64[Sp - 16] = GHC.Tuple.()_closure+1;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _canw1() //  [R1]
         { info_tbl: [(canw1,
                       label: block_canw1_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canw1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto canwb; else goto canwa;
       canwb: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canwa: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R3 = P64[Sp + 24];
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.229164717 UTC

[section ""data" . GHC.Conc.Signal.runHandlersPtr1_closure" {
     GHC.Conc.Signal.runHandlersPtr1_closure:
         const GHC.Conc.Signal.runHandlersPtr1_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlersPtr1_entry() //  [R2, R3]
         { info_tbl: [(canwx,
                       label: GHC.Conc.Signal.runHandlersPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canwx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canwy; else goto canwz;
       canwy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.runHandlersPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canwz: // global
           I64[Sp - 16] = block_canwu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanwD; else goto canwv;
       uanwD: // global
           call _canwu(R1) args: 0, res: 0, upd: 0;
       canwv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canwu() //  [R1]
         { info_tbl: [(canwu,
                       label: block_canwu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canwu: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Signal.$wrunHandlersPtr_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.234510975 UTC

[section ""data" . GHC.Conc.Signal.runHandlersPtr_closure" {
     GHC.Conc.Signal.runHandlersPtr_closure:
         const GHC.Conc.Signal.runHandlersPtr_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlersPtr_entry() //  [R2, R3]
         { info_tbl: [(canwR,
                       label: GHC.Conc.Signal.runHandlersPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canwR: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.runHandlersPtr1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.238070589 UTC

[section ""relreadonly" . SamXS_srt" {
     SamXS_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Conc.Signal.setHandler2_closure;
         const GHC.Conc.Signal.signal_handlers_closure;
         const GHC.Conc.Signal.setHandler1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Signal.runHandlers1_closure;
         const GHC.ForeignPtr.$winsertCFinalizer_closure;
         const GHC.Conc.Signal.$wrunHandlersPtr_closure;
         const GHC.Conc.Signal.runHandlersPtr1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.784765945 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:05:23.785933667 UTC

[section ""cstring" . GHC.Conc.Signal.$trModule4_bytes" {
     GHC.Conc.Signal.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.787635878 UTC

[section ""data" . GHC.Conc.Signal.$trModule3_closure" {
     GHC.Conc.Signal.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Signal.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.789406954 UTC

[section ""cstring" . GHC.Conc.Signal.$trModule2_bytes" {
     GHC.Conc.Signal.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,83,105,103,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.79106184 UTC

[section ""data" . GHC.Conc.Signal.$trModule1_closure" {
     GHC.Conc.Signal.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.Signal.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.792751673 UTC

[section ""data" . GHC.Conc.Signal.$trModule_closure" {
     GHC.Conc.Signal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.Signal.$trModule3_closure+1;
         const GHC.Conc.Signal.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.794685859 UTC

[section ""data" . lvl_ramSF_closure" {
     lvl_ramSF_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.796426674 UTC

[section ""data" . lvl1_ramSG_closure" {
     lvl1_ramSG_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.79930471 UTC

[section ""data" . lvl2_ramSH_closure" {
     lvl2_ramSH_closure:
         const lvl2_ramSH_info;
 },
 sat_sanxB_entry() //  [R1]
         { info_tbl: [(canBf,
                       label: sat_sanxB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canBf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canBg; else goto canBh;
       canBg: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canBh: // global
           I64[Sp - 16] = block_canB6_info;
           _sanxc::P64 = P64[R1 + 7];
           R1 = _sanxc::P64;
           P64[Sp - 8] = _sanxc::P64;
           Sp = Sp - 16;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canB6() //  [R1]
         { info_tbl: [(canB6,
                       label: block_canB6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canB6: // global
           _sanxc::P64 = P64[Sp + 8];
           (_sanxw::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetGHCConcSignalSignalHandlerStore(R1);
           if (R1 == _sanxw::I64) goto canBe; else goto canBd;
       canBe: // global
           R1 = _sanxc::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       canBd: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _sanxw::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 },
 lvl2_ramSH_entry() //  []
         { info_tbl: [(canBp,
                       label: lvl2_ramSH_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canBp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canBq; else goto canBr;
       canBq: // global
           R1 = lvl2_ramSH_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canBr: // global
           I64[Sp - 8] = block_canAM_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _canAM() //  []
         { info_tbl: [(canAM,
                       label: block_canAM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canAM: // global
           I64[Sp] = block_canAO_info;
           R2 = GHC.Base.Nothing_closure+1;
           R1 = 65;
           call stg_newArray#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canAO() //  [R1]
         { info_tbl: [(canAO,
                       label: block_canAO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canAO: // global
           I64[Sp - 8] = block_canAQ_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _canAQ() //  [R1]
         { info_tbl: [(canAQ,
                       label: block_canAQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canAQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto canBw; else goto canBv;
       canBw: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canBv: // global
           I64[Hp - 32] = GHC.Arr.STArray_con_info;
           P64[Hp - 24] = lvl_ramSF_closure+1;
           P64[Hp - 16] = lvl1_ramSG_closure+1;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = 65;
           I64[Sp] = block_canAT_info;
           R2 = Hp - 31;
           _sanx6::P64 = R1;
           R1 = R1;
           P64[Sp + 8] = _sanx6::P64;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canAT() //  []
         { info_tbl: [(canAT,
                       label: block_canAT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canAT: // global
           I64[Sp] = block_canAV_info;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _canAV() //  [R1]
         { info_tbl: [(canAV,
                       label: block_canAV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canAV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto canBA; else goto canBz;
       canBA: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       canBz: // global
           I64[Hp - 24] = GHC.MVar.MVar_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           _canAX::P64 = Hp - 23;
           if (R1 == 0) goto canBo; else goto canBn;
       canBo: // global
           I64[Hp - 8] = sat_sanxB_info;
           P64[Hp] = _canAX::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       canBn: // global
           Hp = Hp - 16;
           I64[Sp] = block_canBB_info;
           R1 = _canAX::P64;
           P64[Sp + 8] = _canAX::P64;
           call stg_makeStablePtr#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canBB() //  [R1]
         { info_tbl: [(canBB,
                       label: block_canBB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canBB: // global
           _canAX::P64 = P64[Sp + 8];
           (_sanxk::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getOrSetGHCConcSignalSignalHandlerStore(R1);
           if (R1 == _sanxk::I64) goto canBK; else goto canBJ;
       canBK: // global
           R1 = _canAX::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       canBJ: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] hs_free_stable_ptr(R1);
           R1 = _sanxk::I64;
           Sp = Sp + 16;
           call stg_deRefStablePtr#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.821491281 UTC

[section ""data" . GHC.Conc.Signal.signal_handlers_closure" {
     GHC.Conc.Signal.signal_handlers_closure:
         const GHC.Conc.Signal.signal_handlers_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Signal.signal_handlers_entry() //  [R1]
         { info_tbl: [(canCH,
                       label: GHC.Conc.Signal.signal_handlers_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canCH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canCI; else goto canCJ;
       canCI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       canCJ: // global
           (_canCC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_canCC::I64 == 0) goto canCE; else goto canCD;
       canCE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       canCD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _canCC::I64;
           I64[Sp - 24] = block_canCF_info;
           Sp = Sp - 24;
           call lvl2_ramSH_entry() args: 8, res: 8, upd: 24;
     }
 },
 _canCF() //  [R1]
         { info_tbl: [(canCF,
                       label: block_canCF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canCF: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.827105277 UTC

[section ""cstring" . lvl3_ramSI_bytes" {
     lvl3_ramSI_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,115,101,116,72,97,110,100,108,101,114,58,32,115,105,103,110,97,108,32,111,117,116,32,111,102,32,114,97,110,103,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.828982661 UTC

[section ""data" . GHC.Conc.Signal.setHandler2_closure" {
     GHC.Conc.Signal.setHandler2_closure:
         const GHC.Conc.Signal.setHandler2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.Signal.setHandler2_entry() //  [R1]
         { info_tbl: [(canD8,
                       label: GHC.Conc.Signal.setHandler2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canD8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canD9; else goto canDa;
       canD9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       canDa: // global
           (_canD3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_canD3::I64 == 0) goto canD5; else goto canD4;
       canD5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       canD4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _canD3::I64;
           I64[Sp - 24] = block_canD6_info;
           R2 = lvl3_ramSI_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _canD6() //  [R1]
         { info_tbl: [(canD6,
                       label: block_canD6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canD6: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.837471549 UTC

[section ""data" . GHC.Conc.Signal.setHandler1_closure" {
     GHC.Conc.Signal.setHandler1_closure:
         const GHC.Conc.Signal.setHandler1_info;
         const 0;
 },
 io_sanxM_entry() //  [R1, R2]
         { info_tbl: [(canDF,
                       label: io_sanxM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canDF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canDT; else goto canDU;
       canDT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canDU: // global
           I64[Sp - 24] = block_canDC_info;
           _sanxG::P64 = P64[R1 + 6];
           _sanxH::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sanxG::P64;
           P64[Sp - 8] = _sanxH::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uanEg; else goto canDD;
       uanEg: // global
           call _canDC(R1) args: 0, res: 0, upd: 0;
       canDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canDC() //  [R1]
         { info_tbl: [(canDC,
                       label: block_canDC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canDC: // global
           I64[Sp - 16] = block_canDI_info;
           _sanxR::P64 = P64[R1 + 15];
           _sanxT::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sanxT::P64;
           P64[Sp] = _sanxR::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanEf; else goto canDJ;
       uanEf: // global
           call _canDI(R1) args: 0, res: 0, upd: 0;
       canDJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canDI() //  [R1]
         { info_tbl: [(canDI,
                       label: block_canDI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canDI: // global
           I64[Sp] = block_canDN_info;
           _sanxV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sanxV::I64;
           if (R1 & 7 != 0) goto uanEh; else goto canDO;
       uanEh: // global
           call _canDN(R1) args: 0, res: 0, upd: 0;
       canDO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canDN() //  [R1]
         { info_tbl: [(canDN,
                       label: block_canDN_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canDN: // global
           I64[Sp] = block_canDS_info;
           _sanxX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sanxX::I64;
           if (R1 & 7 != 0) goto uanEi; else goto canDY;
       uanEi: // global
           call _canDS(R1) args: 0, res: 0, upd: 0;
       canDY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canDS() //  [R1]
         { info_tbl: [(canDS,
                       label: block_canDS_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canDS: // global
           _sanxZ::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _sanxZ::I64)) goto canEc; else goto canEe;
       canEe: // global
           if (%MO_S_Gt_W64(_sanxZ::I64,
                            I64[Sp + 24])) goto canEc; else goto canEd;
       canEc: // global
           R1 = GHC.Conc.Signal.setHandler2_closure;
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       canEd: // global
           _sanxH::P64 = P64[Sp + 32];
           _sanxT::P64 = P64[Sp + 8];
           _sany6::P64 = P64[(_sanxT::P64 + 24) + (_sanxZ::I64 << 3)];
           call MO_WriteBarrier();
           P64[(_sanxT::P64 + 24) + (_sanxZ::I64 << 3)] = _sanxH::P64;
           I64[_sanxT::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_sanxT::P64 + 24) + ((I64[_sanxT::P64 + 8] << 3) + (_sanxZ::I64 >> 7))] = 1 :: W8;
           R1 = _sany6::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanyj_entry() //  [R1, R2]
         { info_tbl: [(canEz,
                       label: sat_sanyj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canEz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canEA; else goto canEB;
       canEA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canEB: // global
           I64[Sp - 16] = block_canEx_info;
           _sanyg::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sanyg::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canEx() //  []
         { info_tbl: [(canEx,
                       label: block_canEx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canEx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanye_entry() //  [R1]
         { info_tbl: [(canEI,
                       label: sat_sanye_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canEI: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_sanxM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanyf_entry() //  [R1]
         { info_tbl: [(canEQ,
                       label: sat_sanyf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canEQ: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanyz_entry() //  [R1, R2]
         { info_tbl: [(canFd,
                       label: sat_sanyz_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canFd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canFe; else goto canFf;
       canFe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canFf: // global
           I64[Sp - 16] = block_canFb_info;
           _sanyw::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sanyw::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canFb() //  []
         { info_tbl: [(canFb,
                       label: block_canFb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canFb: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanyu_entry() //  [R1]
         { info_tbl: [(canFm,
                       label: sat_sanyu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canFm: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_sanxM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanyv_entry() //  [R1]
         { info_tbl: [(canFu,
                       label: sat_sanyv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canFu: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanyE_entry() //  [R1]
         { info_tbl: [(canFx,
                       label: sat_sanyE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canFx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canFB; else goto canFC;
       canFB: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canFC: // global
           I64[Sp - 16] = block_canEZ_info;
           _sanxM::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp - 8] = _sanxM::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanFK; else goto canF0;
       uanFK: // global
           call _canEZ(R1) args: 0, res: 0, upd: 0;
       canF0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canEZ() //  [R1]
         { info_tbl: [(canEZ,
                       label: block_canEZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canEZ: // global
           I64[Sp - 8] = block_canF4_info;
           _sanyq::P64 = P64[R1 + 7];
           R1 = _sanyq::P64;
           P64[Sp] = _sanyq::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canF4() //  [R1]
         { info_tbl: [(canF4,
                       label: block_canF4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canF4: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canFG; else goto canFF;
       canFG: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canFF: // global
           I64[Hp - 56] = sat_sanyz_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sanyu_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sanyv_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canFy_info;
           R2 = Hp - 54;
           _sanyt::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sanyt::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canFy() //  [R1]
         { info_tbl: [(canFy,
                       label: block_canFy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canFy: // global
           _sanyq::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canFA_info;
           R2 = P64[Sp + 16];
           _sanyC::P64 = R1;
           R1 = _sanyq::P64;
           P64[Sp + 16] = _sanyC::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canFA() //  []
         { info_tbl: [(canFA,
                       label: block_canFA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canFA: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanyP_entry() //  [R1, R2]
         { info_tbl: [(canG0,
                       label: sat_sanyP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canG0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canG1; else goto canG2;
       canG1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canG2: // global
           I64[Sp - 16] = block_canFY_info;
           _sanyM::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sanyM::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canFY() //  []
         { info_tbl: [(canFY,
                       label: block_canFY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canFY: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanyK_entry() //  [R1]
         { info_tbl: [(canG9,
                       label: sat_sanyK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canG9: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_sanxM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanyL_entry() //  [R1]
         { info_tbl: [(canGh,
                       label: sat_sanyL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canGh: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Signal.setHandler1_entry() //  [R2, R3]
         { info_tbl: [(canGo,
                       label: GHC.Conc.Signal.setHandler1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canGo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canGp; else goto canGq;
       canGp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.setHandler1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canGq: // global
           I64[Sp - 24] = block_canDv_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _canDv() //  [R1]
         { info_tbl: [(canDv,
                       label: block_canDv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canDv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto canGt; else goto canGs;
       canGt: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       canGs: // global
           I64[Hp - 32] = io_sanxM_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           _canDx::P64 = Hp - 30;
           if (R1 == 0) goto canGm; else goto uanGO;
       canGm: // global
           I64[Hp - 8] = sat_sanyE_info;
           P64[Hp] = _canDx::P64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uanGO: // global
           if (R1 == 1) goto canGn; else goto canGl;
       canGn: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_canFM_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canDx::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanGQ; else goto canFN;
       uanGQ: // global
           call _canFM(R1) args: 0, res: 0, upd: 0;
       canFN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       canGl: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_canEl_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canDx::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanGP; else goto canEm;
       uanGP: // global
           call _canEl(R1) args: 0, res: 0, upd: 0;
       canEm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canFM() //  [R1]
         { info_tbl: [(canFM,
                       label: block_canFM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canFM: // global
           I64[Sp - 8] = block_canFR_info;
           _sanyG::P64 = P64[R1 + 7];
           R1 = _sanyG::P64;
           P64[Sp] = _sanyG::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canFR() //  [R1]
         { info_tbl: [(canFR,
                       label: block_canFR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canFR: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canGK; else goto canGJ;
       canGK: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canGJ: // global
           I64[Hp - 56] = sat_sanyP_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sanyK_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sanyL_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canGE_info;
           R2 = Hp - 54;
           _sanyJ::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sanyJ::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canGE() //  [R1]
         { info_tbl: [(canGE,
                       label: block_canGE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canGE: // global
           _sanyG::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canGG_info;
           R2 = P64[Sp + 16];
           _sanyS::P64 = R1;
           R1 = _sanyG::P64;
           P64[Sp + 16] = _sanyS::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canGG() //  []
         { info_tbl: [(canGG,
                       label: block_canGG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canGG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _canEl() //  [R1]
         { info_tbl: [(canEl,
                       label: block_canEl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canEl: // global
           I64[Sp - 8] = block_canEq_info;
           _sanya::P64 = P64[R1 + 7];
           R1 = _sanya::P64;
           P64[Sp] = _sanya::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canEq() //  [R1]
         { info_tbl: [(canEq,
                       label: block_canEq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canEq: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canGA; else goto canGz;
       canGA: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canGz: // global
           I64[Hp - 56] = sat_sanyj_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sanye_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sanyf_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canGu_info;
           R2 = Hp - 54;
           _sanyd::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sanyd::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canGu() //  [R1]
         { info_tbl: [(canGu,
                       label: block_canGu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canGu: // global
           _sanya::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canGw_info;
           R2 = P64[Sp + 16];
           _sanym::P64 = R1;
           R1 = _sanya::P64;
           P64[Sp + 16] = _sanym::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canGw() //  []
         { info_tbl: [(canGw,
                       label: block_canGw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canGw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.904061571 UTC

[section ""data" . GHC.Conc.Signal.setHandler_closure" {
     GHC.Conc.Signal.setHandler_closure:
         const GHC.Conc.Signal.setHandler_info;
         const 0;
 },
 GHC.Conc.Signal.setHandler_entry() //  [R2, R3]
         { info_tbl: [(canJw,
                       label: GHC.Conc.Signal.setHandler_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canJw: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.setHandler1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.911178795 UTC

[section ""data" . GHC.Conc.Signal.runHandlers1_closure" {
     GHC.Conc.Signal.runHandlers1_closure:
         const GHC.Conc.Signal.runHandlers1_info;
         const 0;
 },
 sat_sanzi_entry() //  [R1]
         { info_tbl: [(canKl,
                       label: sat_sanzi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canKl: // global
           R2 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanzj_entry() //  [R1]
         { info_tbl: [(canKo,
                       label: sat_sanzj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canKo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto canKs; else goto canKr;
       canKs: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canKr: // global
           _sanyU::P64 = P64[R1 + 7];
           _sanzf::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sanzi_info;
           P64[Hp - 8] = _sanyU::P64;
           P64[Hp] = _sanzf::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 24;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wio_sanz0_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(canKt,
                       label: $wio_sanz0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 17} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canKt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canKu; else goto canKv;
       canKu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       canKv: // global
           I64[Sp - 40] = block_canJO_info;
           _sanyU::P64 = P64[R1 + 4];
           R1 = P64[R1 + 12];
           P64[Sp - 32] = _sanyU::P64;
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uanKY; else goto canJP;
       uanKY: // global
           call _canJO(R1) args: 0, res: 0, upd: 0;
       canJP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canJO() //  [R1]
         { info_tbl: [(canJO,
                       label: block_canJO_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canJO: // global
           _sanz6::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(I64[Sp + 16],
                            _sanz6::I64)) goto uanKQ; else goto canKO;
       uanKQ: // global
           Sp = Sp + 40;
           goto uanKV;
       canKO: // global
           if (%MO_S_Gt_W64(_sanz6::I64,
                            I64[Sp + 24])) goto uanKR; else goto canKB;
       uanKR: // global
           Sp = Sp + 40;
           goto uanKV;
       uanKV: // global
           call _canKF() args: 0, res: 0, upd: 0;
       canKB: // global
           _sanzb::P64 = P64[P64[Sp + 32] + ((_sanz6::I64 << 3) + 24)];
           I64[Sp] = block_canK1_info;
           R1 = _sanzb::P64;
           if (R1 & 7 != 0) goto uanKT; else goto canK2;
       uanKT: // global
           call _canK1(R1) args: 0, res: 0, upd: 0;
       canK2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canK1() //  [R1]
         { info_tbl: [(canK1,
                       label: block_canK1_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canK1: // global
           if (R1 & 7 == 1) goto uanKS; else goto canKI;
       uanKS: // global
           Sp = Sp + 40;
           call _canKF() args: 0, res: 0, upd: 0;
       canKI: // global
           I64[Sp] = block_canK7_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto uanKW; else goto canK8;
       uanKW: // global
           call _canK7(R1) args: 0, res: 0, upd: 0;
       canK8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canKF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canKF: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _canK7() //  [R1]
         { info_tbl: [(canK7,
                       label: block_canK7_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canK7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto canKL; else goto canKK;
       canKL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canKK: // global
           _sanzf::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sanzj_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sanzf::P64;
           I64[Sp + 32] = block_canKG_info;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canKG() //  []
         { info_tbl: [(canKG,
                       label: block_canKG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canKG: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 io_sanzn_entry() //  [R1, R2]
         { info_tbl: [(canL7,
                       label: io_sanzn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canL7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto canLg; else goto canLh;
       canLg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canLh: // global
           I64[Sp - 16] = block_canL4_info;
           _sanz0::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sanz0::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanLq; else goto canL5;
       uanLq: // global
           call _canL4(R1) args: 0, res: 0, upd: 0;
       canL5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canL4() //  [R1]
         { info_tbl: [(canL4,
                       label: block_canL4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canL4: // global
           I64[Sp - 16] = block_canLa_info;
           _sanzs::P64 = P64[R1 + 15];
           _sanzu::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sanzu::P64;
           P64[Sp] = _sanzs::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanLp; else goto canLb;
       uanLp: // global
           call _canLa(R1) args: 0, res: 0, upd: 0;
       canLb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canLa() //  [R1]
         { info_tbl: [(canLa,
                       label: block_canLa_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canLa: // global
           I64[Sp] = block_canLf_info;
           _sanzw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sanzw::I64;
           if (R1 & 7 != 0) goto uanLr; else goto canLk;
       uanLr: // global
           call _canLf(R1) args: 0, res: 0, upd: 0;
       canLk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canLf() //  [R1]
         { info_tbl: [(canLf,
                       label: block_canLf_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canLf: // global
           R4 = P64[Sp + 8];
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 16];
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call $wio_sanz0_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanzK_entry() //  [R1, R2]
         { info_tbl: [(canLI,
                       label: sat_sanzK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canLI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canLJ; else goto canLK;
       canLJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canLK: // global
           I64[Sp - 16] = block_canLG_info;
           _sanzH::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sanzH::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canLG() //  []
         { info_tbl: [(canLG,
                       label: block_canLG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canLG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanzF_entry() //  [R1]
         { info_tbl: [(canLR,
                       label: sat_sanzF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canLR: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_sanzn_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanzG_entry() //  [R1]
         { info_tbl: [(canLZ,
                       label: sat_sanzG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canLZ: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanA0_entry() //  [R1, R2]
         { info_tbl: [(canMm,
                       label: sat_sanA0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canMm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canMn; else goto canMo;
       canMn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canMo: // global
           I64[Sp - 16] = block_canMk_info;
           _sanzX::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sanzX::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canMk() //  []
         { info_tbl: [(canMk,
                       label: block_canMk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canMk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanzV_entry() //  [R1]
         { info_tbl: [(canMv,
                       label: sat_sanzV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canMv: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_sanzn_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanzW_entry() //  [R1]
         { info_tbl: [(canMD,
                       label: sat_sanzW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canMD: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanA5_entry() //  [R1]
         { info_tbl: [(canMG,
                       label: sat_sanA5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canMG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canMK; else goto canML;
       canMK: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       canML: // global
           I64[Sp - 16] = block_canM8_info;
           _sanzn::P64 = P64[R1 + 7];
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp - 8] = _sanzn::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanMT; else goto canM9;
       uanMT: // global
           call _canM8(R1) args: 0, res: 0, upd: 0;
       canM9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canM8() //  [R1]
         { info_tbl: [(canM8,
                       label: block_canM8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canM8: // global
           I64[Sp - 8] = block_canMd_info;
           _sanzR::P64 = P64[R1 + 7];
           R1 = _sanzR::P64;
           P64[Sp] = _sanzR::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canMd() //  [R1]
         { info_tbl: [(canMd,
                       label: block_canMd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canMd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canMP; else goto canMO;
       canMP: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canMO: // global
           I64[Hp - 56] = sat_sanA0_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sanzV_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sanzW_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canMH_info;
           R2 = Hp - 54;
           _sanzU::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sanzU::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canMH() //  [R1]
         { info_tbl: [(canMH,
                       label: block_canMH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canMH: // global
           _sanzR::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canMJ_info;
           R2 = P64[Sp + 16];
           _sanA3::P64 = R1;
           R1 = _sanzR::P64;
           P64[Sp + 16] = _sanA3::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canMJ() //  []
         { info_tbl: [(canMJ,
                       label: block_canMJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canMJ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanAg_entry() //  [R1, R2]
         { info_tbl: [(canN9,
                       label: sat_sanAg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canN9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canNa; else goto canNb;
       canNa: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       canNb: // global
           I64[Sp - 16] = block_canN7_info;
           _sanAd::P64 = R2;
           R2 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 8] = _sanAd::P64;
           Sp = Sp - 16;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canN7() //  []
         { info_tbl: [(canN7,
                       label: block_canN7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canN7: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanAb_entry() //  [R1]
         { info_tbl: [(canNi,
                       label: sat_sanAb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canNi: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call io_sanzn_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sanAc_entry() //  [R1]
         { info_tbl: [(canNq,
                       label: sat_sanAc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canNq: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Conc.Signal.runHandlers1_entry() //  [R2, R3]
         { info_tbl: [(canNx,
                       label: GHC.Conc.Signal.runHandlers1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canNx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto canNy; else goto canNz;
       canNy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.runHandlers1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canNz: // global
           I64[Sp - 24] = block_canJH_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _canJH() //  [R1]
         { info_tbl: [(canJH,
                       label: block_canJH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canJH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto canNC; else goto canNB;
       canNC: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       canNB: // global
           I64[Hp - 48] = $wio_sanz0_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = io_sanzn_info;
           P64[Hp - 16] = Hp - 44;
           _canKZ::P64 = Hp - 22;
           if (R1 == 0) goto canNv; else goto uanNX;
       canNv: // global
           I64[Hp - 8] = sat_sanA5_info;
           P64[Hp] = _canKZ::P64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       uanNX: // global
           if (R1 == 1) goto canNw; else goto canNu;
       canNw: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_canMV_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canKZ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanNZ; else goto canMW;
       uanNZ: // global
           call _canMV(R1) args: 0, res: 0, upd: 0;
       canMW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       canNu: // global
           Hp = Hp - 16;
           I64[Sp + 8] = block_canLu_info;
           R1 = GHC.Conc.Signal.signal_handlers_closure;
           P64[Sp + 16] = _canKZ::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uanNY; else goto canLv;
       uanNY: // global
           call _canLu(R1) args: 0, res: 0, upd: 0;
       canLv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canMV() //  [R1]
         { info_tbl: [(canMV,
                       label: block_canMV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canMV: // global
           I64[Sp - 8] = block_canN0_info;
           _sanA7::P64 = P64[R1 + 7];
           R1 = _sanA7::P64;
           P64[Sp] = _sanA7::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canN0() //  [R1]
         { info_tbl: [(canN0,
                       label: block_canN0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canN0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canNT; else goto canNS;
       canNT: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canNS: // global
           I64[Hp - 56] = sat_sanAg_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sanAb_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sanAc_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canNN_info;
           R2 = Hp - 54;
           _sanAa::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sanAa::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canNN() //  [R1]
         { info_tbl: [(canNN,
                       label: block_canNN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canNN: // global
           _sanA7::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canNP_info;
           R2 = P64[Sp + 16];
           _sanAj::P64 = R1;
           R1 = _sanA7::P64;
           P64[Sp + 16] = _sanAj::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canNP() //  []
         { info_tbl: [(canNP,
                       label: block_canNP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canNP: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _canLu() //  [R1]
         { info_tbl: [(canLu,
                       label: block_canLu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canLu: // global
           I64[Sp - 8] = block_canLz_info;
           _sanzB::P64 = P64[R1 + 7];
           R1 = _sanzB::P64;
           P64[Sp] = _sanzB::P64;
           Sp = Sp - 8;
           call stg_takeMVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canLz() //  [R1]
         { info_tbl: [(canLz,
                       label: block_canLz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canLz: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto canNJ; else goto canNI;
       canNJ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canNI: // global
           I64[Hp - 56] = sat_sanzK_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_sanzF_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sanzG_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_canND_info;
           R2 = Hp - 54;
           _sanzE::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 16] = _sanzE::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canND() //  [R1]
         { info_tbl: [(canND,
                       label: block_canND_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canND: // global
           _sanzB::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_canNF_info;
           R2 = P64[Sp + 16];
           _sanzN::P64 = R1;
           R1 = _sanzB::P64;
           P64[Sp + 16] = _sanzN::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _canNF() //  []
         { info_tbl: [(canNF,
                       label: block_canNF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canNF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.988966386 UTC

[section ""data" . GHC.Conc.Signal.runHandlers_closure" {
     GHC.Conc.Signal.runHandlers_closure:
         const GHC.Conc.Signal.runHandlers_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlers_entry() //  [R2, R3]
         { info_tbl: [(canRc,
                       label: GHC.Conc.Signal.runHandlers_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canRc: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:23.992830342 UTC

[section ""data" . GHC.Conc.Signal.$wrunHandlersPtr_closure" {
     GHC.Conc.Signal.$wrunHandlersPtr_closure:
         const GHC.Conc.Signal.$wrunHandlersPtr_info;
         const 0;
 },
 GHC.Conc.Signal.$wrunHandlersPtr_entry() //  [R2, R3]
         { info_tbl: [(canRt,
                       label: GHC.Conc.Signal.$wrunHandlersPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canRt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto canRu; else goto canRv;
       canRu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.$wrunHandlersPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canRv: // global
           I64[Sp - 24] = block_canRn_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canRn() //  [R1]
         { info_tbl: [(canRn,
                       label: block_canRn_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canRn: // global
           I64[Sp - 8] = block_canRp_info;
           R6 = I64[Sp + 8];
           R5 = 0;
           R4 = 0;
           R3 = free;
           R2 = R1;
           P64[Sp - 16] = GHC.Tuple.()_closure+1;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _canRp() //  [R1]
         { info_tbl: [(canRp,
                       label: block_canRp_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canRp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto canRz; else goto canRy;
       canRz: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       canRy: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R3 = P64[Sp + 24];
           R2 = Hp - 15;
           Sp = Sp + 32;
           call GHC.Conc.Signal.runHandlers1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:24.000662898 UTC

[section ""data" . GHC.Conc.Signal.runHandlersPtr1_closure" {
     GHC.Conc.Signal.runHandlersPtr1_closure:
         const GHC.Conc.Signal.runHandlersPtr1_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlersPtr1_entry() //  [R2, R3]
         { info_tbl: [(canS2,
                       label: GHC.Conc.Signal.runHandlersPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canS2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto canS3; else goto canS4;
       canS3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Conc.Signal.runHandlersPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       canS4: // global
           I64[Sp - 16] = block_canRZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uanS8; else goto canS0;
       uanS8: // global
           call _canRZ(R1) args: 0, res: 0, upd: 0;
       canS0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _canRZ() //  [R1]
         { info_tbl: [(canRZ,
                       label: block_canRZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canRZ: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.Conc.Signal.$wrunHandlersPtr_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:24.006073071 UTC

[section ""data" . GHC.Conc.Signal.runHandlersPtr_closure" {
     GHC.Conc.Signal.runHandlersPtr_closure:
         const GHC.Conc.Signal.runHandlersPtr_info;
         const 0;
 },
 GHC.Conc.Signal.runHandlersPtr_entry() //  [R2, R3]
         { info_tbl: [(canSn,
                       label: GHC.Conc.Signal.runHandlersPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       canSn: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.Signal.runHandlersPtr1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:05:24.009111944 UTC

[section ""relreadonly" . SanDe_srt" {
     SanDe_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Conc.Signal.setHandler2_closure;
         const GHC.Conc.Signal.signal_handlers_closure;
         const GHC.Conc.Signal.setHandler1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Signal.runHandlers1_closure;
         const GHC.ForeignPtr.$winsertCFinalizer_closure;
         const GHC.Conc.Signal.$wrunHandlersPtr_closure;
         const GHC.Conc.Signal.runHandlersPtr1_closure;
 }]

