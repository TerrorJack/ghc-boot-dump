
==================== Raw Cmm ====================
2018-03-16 16:05:53.916275345 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:05:53.919329536 UTC

[section ""data" . GHC.Conc.IO.ensureIOManagerIsRunning_closure" {
     GHC.Conc.IO.ensureIOManagerIsRunning_closure:
         const GHC.Conc.IO.ensureIOManagerIsRunning_info;
         const 0;
 },
 GHC.Conc.IO.ensureIOManagerIsRunning_entry() //  []
         { []
         }
     {offset
       caTPw: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning1_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.ensureIOManagerIsRunning_info" {
     GHC.Conc.IO.ensureIOManagerIsRunning_info:
         const GHC.Conc.IO.ensureIOManagerIsRunning_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const SaTDo_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.922730237 UTC

[section ""data" . GHC.Conc.IO.ioManagerCapabilitiesChanged_closure" {
     GHC.Conc.IO.ioManagerCapabilitiesChanged_closure:
         const GHC.Conc.IO.ioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Conc.IO.ioManagerCapabilitiesChanged_entry() //  []
         { []
         }
     {offset
       caTPH: // global
           call GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.ioManagerCapabilitiesChanged_info" {
     GHC.Conc.IO.ioManagerCapabilitiesChanged_info:
         const GHC.Conc.IO.ioManagerCapabilitiesChanged_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const SaTDo_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.925731297 UTC

[section ""cstring" . GHC.Conc.IO.$trModule4_bytes" {
     GHC.Conc.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.927441372 UTC

[section ""data" . GHC.Conc.IO.$trModule3_closure" {
     GHC.Conc.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.IO.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.92913284 UTC

[section ""cstring" . GHC.Conc.IO.$trModule2_bytes" {
     GHC.Conc.IO.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,73,79]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.930990514 UTC

[section ""data" . GHC.Conc.IO.$trModule1_closure" {
     GHC.Conc.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.IO.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.932760839 UTC

[section ""data" . GHC.Conc.IO.$trModule_closure" {
     GHC.Conc.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.IO.$trModule3_closure+1;
         const GHC.Conc.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.934445609 UTC

[section ""cstring" . lvl_raTBq_bytes" {
     lvl_raTBq_bytes:
         I8[] [114,101,103,105,115,116,101,114,68,101,108,97,121,58,32,114,101,113,117,105,114,101,115,32,45,116,104,114,101,97,100,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.937015379 UTC

[section ""data" . GHC.Conc.IO.registerDelay2_closure" {
     GHC.Conc.IO.registerDelay2_closure:
         const GHC.Conc.IO.registerDelay2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.IO.registerDelay2_entry() //  [R1]
         { []
         }
     {offset
       caTQ2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caTQ3; else goto caTQ4;
       caTQ3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caTQ4: // global
           (_caTPX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caTPX::I64 == 0) goto caTPZ; else goto caTPY;
       caTPZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caTPY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caTPX::I64;
           I64[Sp - 24] = block_caTQ0_info;
           R2 = lvl_raTBq_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.registerDelay2_info" {
     GHC.Conc.IO.registerDelay2_info:
         const GHC.Conc.IO.registerDelay2_entry;
         const 0;
         const 4294967317;
         const SaTDo_srt+16;
 },
 _caTQ0() //  [R1]
         { []
         }
     {offset
       caTQ0: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caTQ0_info" {
     block_caTQ0_info:
         const _caTQ0;
         const 0;
         const 4294967326;
         const SaTDo_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.942956436 UTC

[section ""data" . GHC.Conc.IO.registerDelay1_closure" {
     GHC.Conc.IO.registerDelay1_closure:
         const GHC.Conc.IO.registerDelay1_info;
         const 0;
 },
 GHC.Conc.IO.registerDelay1_entry() //  [R2]
         { []
         }
     {offset
       caTQr: // global
           (_saTBy::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBy::I64 == 0) goto caTQq; else goto caTQp;
       caTQq: // global
           R1 = GHC.Conc.IO.registerDelay2_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       caTQp: // global
           R2 = R2;
           call GHC.Event.Thread.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.registerDelay1_info" {
     GHC.Conc.IO.registerDelay1_info:
         const GHC.Conc.IO.registerDelay1_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const SaTDo_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.946538921 UTC

[section ""data" . GHC.Conc.IO.registerDelay_closure" {
     GHC.Conc.IO.registerDelay_closure:
         const GHC.Conc.IO.registerDelay_info;
         const 0;
 },
 GHC.Conc.IO.registerDelay_entry() //  [R2]
         { []
         }
     {offset
       caTQC: // global
           R2 = R2;
           call GHC.Conc.IO.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.registerDelay_info" {
     GHC.Conc.IO.registerDelay_info:
         const GHC.Conc.IO.registerDelay_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SaTDo_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.951225346 UTC

[section ""data" . GHC.Conc.IO.threadDelay1_closure" {
     GHC.Conc.IO.threadDelay1_closure:
         const GHC.Conc.IO.threadDelay1_info;
         const 0;
 },
 GHC.Conc.IO.threadDelay1_entry() //  [R2]
         { []
         }
     {offset
       caTQS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTQT; else goto caTQU;
       caTQT: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTQU: // global
           (_saTBG::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBG::I64 == 0) goto caTQR; else goto caTQQ;
       caTQR: // global
           I64[Sp - 8] = block_caTQX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaTR6; else goto caTQY;
       uaTR6: // global
           call _caTQX(R1) args: 0, res: 0, upd: 0;
       caTQY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caTQQ: // global
           R2 = R2;
           call GHC.Event.Thread.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadDelay1_info" {
     GHC.Conc.IO.threadDelay1_info:
         const GHC.Conc.IO.threadDelay1_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const SaTDo_srt+48;
 },
 _caTQX() //  [R1]
         { []
         }
     {offset
       caTQX: // global
           I64[Sp] = block_caTR2_info;
           R1 = I64[R1 + 7];
           call stg_delay#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caTQX_info" {
     block_caTQX_info:
         const _caTQX;
         const 0;
         const 30;
 },
 _caTR2() //  []
         { []
         }
     {offset
       caTR2: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caTR2_info" {
     block_caTR2_info:
         const _caTR2;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.95792467 UTC

[section ""data" . GHC.Conc.IO.threadDelay_closure" {
     GHC.Conc.IO.threadDelay_closure:
         const GHC.Conc.IO.threadDelay_info;
         const 0;
 },
 GHC.Conc.IO.threadDelay_entry() //  [R2]
         { []
         }
     {offset
       caTRo: // global
           R2 = R2;
           call GHC.Conc.IO.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadDelay_info" {
     GHC.Conc.IO.threadDelay_info:
         const GHC.Conc.IO.threadDelay_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SaTDo_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.96135163 UTC

[section ""data" . GHC.Conc.IO.closeFdWith1_closure" {
     GHC.Conc.IO.closeFdWith1_closure:
         const GHC.Conc.IO.closeFdWith1_info;
         const 0;
 },
 GHC.Conc.IO.closeFdWith1_entry() //  [R2, R3]
         { []
         }
     {offset
       caTRE: // global
           _saTBM::P64 = R3;
           (_saTBR::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBR::I64 == 0) goto caTRD; else goto caTRC;
       caTRD: // global
           _saTBL::P64 = R2;
           R2 = _saTBM::P64;
           R1 = _saTBL::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       caTRC: // global
           R3 = _saTBM::P64;
           R2 = R2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.closeFdWith1_info" {
     GHC.Conc.IO.closeFdWith1_info:
         const GHC.Conc.IO.closeFdWith1_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SaTDo_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.964832752 UTC

[section ""data" . GHC.Conc.IO.closeFdWith_closure" {
     GHC.Conc.IO.closeFdWith_closure:
         const GHC.Conc.IO.closeFdWith_info;
         const 0;
 },
 GHC.Conc.IO.closeFdWith_entry() //  [R2, R3]
         { []
         }
     {offset
       caTRP: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.IO.closeFdWith1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.closeFdWith_info" {
     GHC.Conc.IO.closeFdWith_info:
         const GHC.Conc.IO.closeFdWith_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SaTDo_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.969164043 UTC

[section ""data" . GHC.Conc.IO.threadWaitWrite1_closure" {
     GHC.Conc.IO.threadWaitWrite1_closure:
         const GHC.Conc.IO.threadWaitWrite1_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWrite1_entry() //  [R2]
         { []
         }
     {offset
       caTS5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTS6; else goto caTS7;
       caTS6: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitWrite1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTS7: // global
           (_saTBY::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTBY::I64 == 0) goto caTS4; else goto caTS3;
       caTS4: // global
           I64[Sp - 8] = block_caTSa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaTSj; else goto caTSb;
       uaTSj: // global
           call _caTSa(R1) args: 0, res: 0, upd: 0;
       caTSb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caTS3: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitWrite1_info" {
     GHC.Conc.IO.threadWaitWrite1_info:
         const GHC.Conc.IO.threadWaitWrite1_entry;
         const 0;
         const 30064771086;
         const 8589934597;
         const SaTDo_srt+80;
 },
 _caTSa() //  [R1]
         { []
         }
     {offset
       caTSa: // global
           I64[Sp] = block_caTSf_info;
           R1 = I64[R1 + 7];
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caTSa_info" {
     block_caTSa_info:
         const _caTSa;
         const 0;
         const 30;
 },
 _caTSf() //  []
         { []
         }
     {offset
       caTSf: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caTSf_info" {
     block_caTSf_info:
         const _caTSf;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.975698124 UTC

[section ""data" . GHC.Conc.IO.threadWaitWrite_closure" {
     GHC.Conc.IO.threadWaitWrite_closure:
         const GHC.Conc.IO.threadWaitWrite_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWrite_entry() //  [R2]
         { []
         }
     {offset
       caTSB: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWrite1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitWrite_info" {
     GHC.Conc.IO.threadWaitWrite_info:
         const GHC.Conc.IO.threadWaitWrite_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SaTDo_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:53.983766595 UTC

[section ""data" . GHC.Conc.IO.threadWaitWriteSTM1_closure" {
     GHC.Conc.IO.threadWaitWriteSTM1_closure:
         const GHC.Conc.IO.threadWaitWriteSTM1_info;
         const 0;
 },
 sat_saTCk_entry() //  [R1]
         { []
         }
     {offset
       caTTg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTTh; else goto caTTi;
       caTTh: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTTi: // global
           I64[Sp - 8] = block_caTTe_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saTCk_info" {
     sat_saTCk_info:
         const sat_saTCk_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _caTTe() //  []
         { []
         }
     {offset
       caTTe: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caTTe_info" {
     block_caTTe_info:
         const _caTTe;
         const 0;
         const 30;
 },
 sat_saTCl_entry() //  [R1]
         { []
         }
     {offset
       caTTk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTTl; else goto caTTm;
       caTTl: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTTm: // global
           I64[Sp - 16] = block_caTT2_info;
           _saTCc::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saTCc::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaTTr; else goto caTT3;
       uaTTr: // global
           call _caTT2(R1) args: 0, res: 0, upd: 0;
       caTT3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saTCl_info" {
     sat_saTCl_info:
         const sat_saTCl_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _caTT2() //  [R1]
         { []
         }
     {offset
       caTT2: // global
           I64[Sp] = block_caTT7_info;
           R1 = I64[R1 + 7];
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caTT2_info" {
     block_caTT2_info:
         const _caTT2;
         const 1;
         const 30;
 },
 _caTT7() //  []
         { []
         }
     {offset
       caTT7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caTTq; else goto caTTp;
       caTTq: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caTTp: // global
           I64[Hp - 8] = sat_saTCk_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caTT7_info" {
     block_caTT7_info:
         const _caTT7;
         const 1;
         const 30;
 },
 sat_saTCm_entry() //  [R1]
         { []
         }
     {offset
       caTTs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTTw; else goto caTTv;
       caTTw: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTTv: // global
           _saTC3::P64 = P64[R1 + 7];
           _saTCc::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saTCl_info;
           P64[Hp - 8] = _saTC3::P64;
           P64[Hp] = _saTCc::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saTCm_info" {
     sat_saTCm_info:
         const sat_saTCm_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SaTDo_srt+104;
 },
 sat_saTCy_entry() //  [R1]
         { []
         }
     {offset
       caTTG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTTH; else goto caTTI;
       caTTH: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTTI: // global
           I64[Sp - 8] = block_caTTE_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saTCy_info" {
     sat_saTCy_info:
         const sat_saTCy_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const SaTDo_srt+112;
 },
 _caTTE() //  []
         { []
         }
     {offset
       caTTE: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caTTE_info" {
     block_caTTE_info:
         const _caTTE;
         const 0;
         const 30;
 },
 sat_saTCv_entry() //  [R1]
         { []
         }
     {offset
       caTTY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTTZ; else goto caTU0;
       caTTZ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTU0: // global
           I64[Sp - 8] = block_caTTP_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saTCv_info" {
     sat_saTCv_info:
         const sat_saTCv_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _caTTP() //  [R1]
         { []
         }
     {offset
       caTTP: // global
           I64[Sp] = block_caTTR_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaTU8; else goto caTTS;
       uaTU8: // global
           call _caTTR(R1) args: 0, res: 0, upd: 0;
       caTTS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caTTP_info" {
     block_caTTP_info:
         const _caTTP;
         const 0;
         const 30;
 },
 _caTTR() //  [R1]
         { []
         }
     {offset
       caTTR: // global
           if (R1 & 7 == 1) goto caTTV; else goto caTTW;
       caTTV: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caTTW: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caTTR_info" {
     block_caTTR_info:
         const _caTTR;
         const 0;
         const 30;
 },
 GHC.Conc.IO.threadWaitWriteSTM1_entry() //  [R2]
         { []
         }
     {offset
       caTUc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTUd; else goto caTUe;
       caTUd: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitWriteSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTUe: // global
           (_saTC8::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTC8::I64 == 0) goto caTUb; else goto caTUa;
       caTUb: // global
           I64[Sp - 16] = block_caTSQ_info;
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
       caTUa: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitWriteSTM1_info" {
     GHC.Conc.IO.threadWaitWriteSTM1_info:
         const GHC.Conc.IO.threadWaitWriteSTM1_entry;
         const 0;
         const 519691042830;
         const 8589934597;
         const SaTDo_srt+80;
 },
 _caTSQ() //  [R1]
         { []
         }
     {offset
       caTSQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTUi; else goto caTUh;
       caTUi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTUh: // global
           I64[Hp - 16] = sat_saTCm_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_caTTx_info;
           _saTCc::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _saTCc::P64;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caTSQ_info" {
     block_caTSQ_info:
         const _caTSQ;
         const 1;
         const 12884901918;
         const SaTDo_srt+104;
 },
 _caTTx() //  [R1]
         { []
         }
     {offset
       caTTx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caTUl; else goto caTUk;
       caTUl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTUk: // global
           I64[Hp - 48] = sat_saTCy_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saTCv_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caTTx_info" {
     block_caTTx_info:
         const _caTTx;
         const 1;
         const 4294967326;
         const SaTDo_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.007373879 UTC

[section ""data" . GHC.Conc.IO.threadWaitWriteSTM_closure" {
     GHC.Conc.IO.threadWaitWriteSTM_closure:
         const GHC.Conc.IO.threadWaitWriteSTM_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWriteSTM_entry() //  [R2]
         { []
         }
     {offset
       caTVp: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWriteSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitWriteSTM_info" {
     GHC.Conc.IO.threadWaitWriteSTM_info:
         const GHC.Conc.IO.threadWaitWriteSTM_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SaTDo_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.011385305 UTC

[section ""data" . GHC.Conc.IO.threadWaitRead1_closure" {
     GHC.Conc.IO.threadWaitRead1_closure:
         const GHC.Conc.IO.threadWaitRead1_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitRead1_entry() //  [R2]
         { []
         }
     {offset
       caTVF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTVG; else goto caTVH;
       caTVG: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitRead1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTVH: // global
           (_saTCF::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTCF::I64 == 0) goto caTVE; else goto caTVD;
       caTVE: // global
           I64[Sp - 8] = block_caTVK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaTVT; else goto caTVL;
       uaTVT: // global
           call _caTVK(R1) args: 0, res: 0, upd: 0;
       caTVL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caTVD: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitRead1_info" {
     GHC.Conc.IO.threadWaitRead1_info:
         const GHC.Conc.IO.threadWaitRead1_entry;
         const 0;
         const 828928688142;
         const 8589934597;
         const SaTDo_srt+88;
 },
 _caTVK() //  [R1]
         { []
         }
     {offset
       caTVK: // global
           I64[Sp] = block_caTVP_info;
           R1 = I64[R1 + 7];
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caTVK_info" {
     block_caTVK_info:
         const _caTVK;
         const 0;
         const 30;
 },
 _caTVP() //  []
         { []
         }
     {offset
       caTVP: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caTVP_info" {
     block_caTVP_info:
         const _caTVP;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.018748956 UTC

[section ""data" . GHC.Conc.IO.threadWaitRead_closure" {
     GHC.Conc.IO.threadWaitRead_closure:
         const GHC.Conc.IO.threadWaitRead_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitRead_entry() //  [R2]
         { []
         }
     {offset
       caTWb: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitRead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitRead_info" {
     GHC.Conc.IO.threadWaitRead_info:
         const GHC.Conc.IO.threadWaitRead_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SaTDo_srt+144;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.026249609 UTC

[section ""data" . GHC.Conc.IO.threadWaitReadSTM1_closure" {
     GHC.Conc.IO.threadWaitReadSTM1_closure:
         const GHC.Conc.IO.threadWaitReadSTM1_info;
         const 0;
 },
 sat_saTD1_entry() //  [R1]
         { []
         }
     {offset
       caTWQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTWR; else goto caTWS;
       caTWR: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTWS: // global
           I64[Sp - 8] = block_caTWO_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saTD1_info" {
     sat_saTD1_info:
         const sat_saTD1_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _caTWO() //  []
         { []
         }
     {offset
       caTWO: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caTWO_info" {
     block_caTWO_info:
         const _caTWO;
         const 0;
         const 30;
 },
 sat_saTD2_entry() //  [R1]
         { []
         }
     {offset
       caTWU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTWV; else goto caTWW;
       caTWV: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTWW: // global
           I64[Sp - 16] = block_caTWC_info;
           _saTCT::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saTCT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaTX1; else goto caTWD;
       uaTX1: // global
           call _caTWC(R1) args: 0, res: 0, upd: 0;
       caTWD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saTD2_info" {
     sat_saTD2_info:
         const sat_saTD2_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _caTWC() //  [R1]
         { []
         }
     {offset
       caTWC: // global
           I64[Sp] = block_caTWH_info;
           R1 = I64[R1 + 7];
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caTWC_info" {
     block_caTWC_info:
         const _caTWC;
         const 1;
         const 30;
 },
 _caTWH() //  []
         { []
         }
     {offset
       caTWH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caTX0; else goto caTWZ;
       caTX0: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caTWZ: // global
           I64[Hp - 8] = sat_saTD1_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caTWH_info" {
     block_caTWH_info:
         const _caTWH;
         const 1;
         const 30;
 },
 sat_saTD3_entry() //  [R1]
         { []
         }
     {offset
       caTX2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTX6; else goto caTX5;
       caTX6: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTX5: // global
           _saTCK::P64 = P64[R1 + 7];
           _saTCT::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saTD2_info;
           P64[Hp - 8] = _saTCK::P64;
           P64[Hp] = _saTCT::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saTD3_info" {
     sat_saTD3_info:
         const sat_saTD3_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SaTDo_srt+104;
 },
 sat_saTDf_entry() //  [R1]
         { []
         }
     {offset
       caTXg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTXh; else goto caTXi;
       caTXh: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTXi: // global
           I64[Sp - 8] = block_caTXe_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saTDf_info" {
     sat_saTDf_info:
         const sat_saTDf_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const SaTDo_srt+112;
 },
 _caTXe() //  []
         { []
         }
     {offset
       caTXe: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caTXe_info" {
     block_caTXe_info:
         const _caTXe;
         const 0;
         const 30;
 },
 sat_saTDc_entry() //  [R1]
         { []
         }
     {offset
       caTXy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caTXz; else goto caTXA;
       caTXz: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caTXA: // global
           I64[Sp - 8] = block_caTXp_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saTDc_info" {
     sat_saTDc_info:
         const sat_saTDc_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _caTXp() //  [R1]
         { []
         }
     {offset
       caTXp: // global
           I64[Sp] = block_caTXr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaTXI; else goto caTXs;
       uaTXI: // global
           call _caTXr(R1) args: 0, res: 0, upd: 0;
       caTXs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caTXp_info" {
     block_caTXp_info:
         const _caTXp;
         const 0;
         const 30;
 },
 _caTXr() //  [R1]
         { []
         }
     {offset
       caTXr: // global
           if (R1 & 7 == 1) goto caTXv; else goto caTXw;
       caTXv: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caTXw: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caTXr_info" {
     block_caTXr_info:
         const _caTXr;
         const 0;
         const 30;
 },
 GHC.Conc.IO.threadWaitReadSTM1_entry() //  [R2]
         { []
         }
     {offset
       caTXM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caTXN; else goto caTXO;
       caTXN: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitReadSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTXO: // global
           (_saTCP::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTCP::I64 == 0) goto caTXL; else goto caTXK;
       caTXL: // global
           I64[Sp - 16] = block_caTWq_info;
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
       caTXK: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitReadSTM1_info" {
     GHC.Conc.IO.threadWaitReadSTM1_info:
         const GHC.Conc.IO.threadWaitReadSTM1_entry;
         const 0;
         const 373662154766;
         const 8589934597;
         const SaTDo_srt+104;
 },
 _caTWq() //  [R1]
         { []
         }
     {offset
       caTWq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caTXS; else goto caTXR;
       caTXS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTXR: // global
           I64[Hp - 16] = sat_saTD3_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_caTX7_info;
           _saTCT::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _saTCT::P64;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caTWq_info" {
     block_caTWq_info:
         const _caTWq;
         const 1;
         const 12884901918;
         const SaTDo_srt+104;
 },
 _caTX7() //  [R1]
         { []
         }
     {offset
       caTX7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caTXV; else goto caTXU;
       caTXV: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caTXU: // global
           I64[Hp - 48] = sat_saTDf_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saTDc_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caTX7_info" {
     block_caTX7_info:
         const _caTX7;
         const 1;
         const 4294967326;
         const SaTDo_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.049839445 UTC

[section ""data" . GHC.Conc.IO.threadWaitReadSTM_closure" {
     GHC.Conc.IO.threadWaitReadSTM_closure:
         const GHC.Conc.IO.threadWaitReadSTM_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitReadSTM_entry() //  [R2]
         { []
         }
     {offset
       caTYZ: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitReadSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitReadSTM_info" {
     GHC.Conc.IO.threadWaitReadSTM_info:
         const GHC.Conc.IO.threadWaitReadSTM_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SaTDo_srt+152;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.053623576 UTC

[section ""relreadonly" . SaTDo_srt" {
     SaTDo_srt:
         const GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Thread.registerDelay1_closure;
         const GHC.Conc.IO.registerDelay2_closure;
         const GHC.Conc.IO.registerDelay1_closure;
         const GHC.Event.Thread.threadDelay1_closure;
         const GHC.Conc.IO.threadDelay1_closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.Conc.IO.closeFdWith1_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitWrite1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Sync.killThread2_closure;
         const GHC.Event.Thread.threadWaitReadSTM1_closure;
         const GHC.Conc.IO.threadWaitWriteSTM1_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Conc.IO.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitReadSTM1_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.3351319 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:05:54.33660442 UTC

[section ""data" . GHC.Conc.IO.ensureIOManagerIsRunning_closure" {
     GHC.Conc.IO.ensureIOManagerIsRunning_closure:
         const GHC.Conc.IO.ensureIOManagerIsRunning_info;
         const 0;
 },
 GHC.Conc.IO.ensureIOManagerIsRunning_entry() //  []
         { []
         }
     {offset
       caU10: // global
           call GHC.Event.Thread.ensureIOManagerIsRunning1_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.ensureIOManagerIsRunning_info" {
     GHC.Conc.IO.ensureIOManagerIsRunning_info:
         const GHC.Conc.IO.ensureIOManagerIsRunning_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const SaU13_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.340148298 UTC

[section ""data" . GHC.Conc.IO.ioManagerCapabilitiesChanged_closure" {
     GHC.Conc.IO.ioManagerCapabilitiesChanged_closure:
         const GHC.Conc.IO.ioManagerCapabilitiesChanged_info;
         const 0;
 },
 GHC.Conc.IO.ioManagerCapabilitiesChanged_entry() //  []
         { []
         }
     {offset
       caU1c: // global
           call GHC.Event.Thread.ioManagerCapabilitiesChanged1_entry() args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.ioManagerCapabilitiesChanged_info" {
     GHC.Conc.IO.ioManagerCapabilitiesChanged_info:
         const GHC.Conc.IO.ioManagerCapabilitiesChanged_entry;
         const 0;
         const 4294967310;
         const 4294967299;
         const SaU13_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.345363745 UTC

[section ""cstring" . GHC.Conc.IO.$trModule4_bytes" {
     GHC.Conc.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.34701832 UTC

[section ""data" . GHC.Conc.IO.$trModule3_closure" {
     GHC.Conc.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.IO.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.34868172 UTC

[section ""cstring" . GHC.Conc.IO.$trModule2_bytes" {
     GHC.Conc.IO.$trModule2_bytes:
         I8[] [71,72,67,46,67,111,110,99,46,73,79]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.350296211 UTC

[section ""data" . GHC.Conc.IO.$trModule1_closure" {
     GHC.Conc.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Conc.IO.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.352013575 UTC

[section ""data" . GHC.Conc.IO.$trModule_closure" {
     GHC.Conc.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Conc.IO.$trModule3_closure+1;
         const GHC.Conc.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.353755602 UTC

[section ""cstring" . lvl_raTBq_bytes" {
     lvl_raTBq_bytes:
         I8[] [114,101,103,105,115,116,101,114,68,101,108,97,121,58,32,114,101,113,117,105,114,101,115,32,45,116,104,114,101,97,100,101,100]
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.356391531 UTC

[section ""data" . GHC.Conc.IO.registerDelay2_closure" {
     GHC.Conc.IO.registerDelay2_closure:
         const GHC.Conc.IO.registerDelay2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Conc.IO.registerDelay2_entry() //  [R1]
         { []
         }
     {offset
       caU1x: // global
           if ((Sp + -24) < SpLim) (likely: False) goto caU1y; else goto caU1z;
       caU1y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caU1z: // global
           (_caU1s::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_caU1s::I64 == 0) goto caU1u; else goto caU1t;
       caU1u: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       caU1t: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caU1s::I64;
           I64[Sp - 24] = block_caU1v_info;
           R2 = lvl_raTBq_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.registerDelay2_info" {
     GHC.Conc.IO.registerDelay2_info:
         const GHC.Conc.IO.registerDelay2_entry;
         const 0;
         const 4294967317;
         const SaU13_srt+16;
 },
 _caU1v() //  [R1]
         { []
         }
     {offset
       caU1v: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_caU1v_info" {
     block_caU1v_info:
         const _caU1v;
         const 0;
         const 4294967326;
         const SaU13_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.36244 UTC

[section ""data" . GHC.Conc.IO.registerDelay1_closure" {
     GHC.Conc.IO.registerDelay1_closure:
         const GHC.Conc.IO.registerDelay1_info;
         const 0;
 },
 GHC.Conc.IO.registerDelay1_entry() //  [R2]
         { []
         }
     {offset
       caU1Y: // global
           (_saTZd::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTZd::I64 == 0) goto caU1X; else goto caU1W;
       caU1X: // global
           R1 = GHC.Conc.IO.registerDelay2_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       caU1W: // global
           R2 = R2;
           call GHC.Event.Thread.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.registerDelay1_info" {
     GHC.Conc.IO.registerDelay1_info:
         const GHC.Conc.IO.registerDelay1_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const SaU13_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.365962381 UTC

[section ""data" . GHC.Conc.IO.registerDelay_closure" {
     GHC.Conc.IO.registerDelay_closure:
         const GHC.Conc.IO.registerDelay_info;
         const 0;
 },
 GHC.Conc.IO.registerDelay_entry() //  [R2]
         { []
         }
     {offset
       caU29: // global
           R2 = R2;
           call GHC.Conc.IO.registerDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.registerDelay_info" {
     GHC.Conc.IO.registerDelay_info:
         const GHC.Conc.IO.registerDelay_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SaU13_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.370741256 UTC

[section ""data" . GHC.Conc.IO.threadDelay1_closure" {
     GHC.Conc.IO.threadDelay1_closure:
         const GHC.Conc.IO.threadDelay1_info;
         const 0;
 },
 GHC.Conc.IO.threadDelay1_entry() //  [R2]
         { []
         }
     {offset
       caU2p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU2q; else goto caU2r;
       caU2q: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadDelay1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caU2r: // global
           (_saTZl::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTZl::I64 == 0) goto caU2o; else goto caU2n;
       caU2o: // global
           I64[Sp - 8] = block_caU2u_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaU2D; else goto caU2v;
       uaU2D: // global
           call _caU2u(R1) args: 0, res: 0, upd: 0;
       caU2v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caU2n: // global
           R2 = R2;
           call GHC.Event.Thread.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadDelay1_info" {
     GHC.Conc.IO.threadDelay1_info:
         const GHC.Conc.IO.threadDelay1_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const SaU13_srt+48;
 },
 _caU2u() //  [R1]
         { []
         }
     {offset
       caU2u: // global
           I64[Sp] = block_caU2z_info;
           R1 = I64[R1 + 7];
           call stg_delay#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caU2u_info" {
     block_caU2u_info:
         const _caU2u;
         const 0;
         const 30;
 },
 _caU2z() //  []
         { []
         }
     {offset
       caU2z: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caU2z_info" {
     block_caU2z_info:
         const _caU2z;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.377894589 UTC

[section ""data" . GHC.Conc.IO.threadDelay_closure" {
     GHC.Conc.IO.threadDelay_closure:
         const GHC.Conc.IO.threadDelay_info;
         const 0;
 },
 GHC.Conc.IO.threadDelay_entry() //  [R2]
         { []
         }
     {offset
       caU2Y: // global
           R2 = R2;
           call GHC.Conc.IO.threadDelay1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadDelay_info" {
     GHC.Conc.IO.threadDelay_info:
         const GHC.Conc.IO.threadDelay_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SaU13_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.381857859 UTC

[section ""data" . GHC.Conc.IO.closeFdWith1_closure" {
     GHC.Conc.IO.closeFdWith1_closure:
         const GHC.Conc.IO.closeFdWith1_info;
         const 0;
 },
 GHC.Conc.IO.closeFdWith1_entry() //  [R2, R3]
         { []
         }
     {offset
       caU3e: // global
           _saTZr::P64 = R3;
           (_saTZw::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTZw::I64 == 0) goto caU3d; else goto caU3c;
       caU3d: // global
           _saTZq::P64 = R2;
           R2 = _saTZr::P64;
           R1 = _saTZq::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       caU3c: // global
           R3 = _saTZr::P64;
           R2 = R2;
           call GHC.Event.Thread.closeFdWith1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.closeFdWith1_info" {
     GHC.Conc.IO.closeFdWith1_info:
         const GHC.Conc.IO.closeFdWith1_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SaU13_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.385507913 UTC

[section ""data" . GHC.Conc.IO.closeFdWith_closure" {
     GHC.Conc.IO.closeFdWith_closure:
         const GHC.Conc.IO.closeFdWith_info;
         const 0;
 },
 GHC.Conc.IO.closeFdWith_entry() //  [R2, R3]
         { []
         }
     {offset
       caU3p: // global
           R3 = R3;
           R2 = R2;
           call GHC.Conc.IO.closeFdWith1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.closeFdWith_info" {
     GHC.Conc.IO.closeFdWith_info:
         const GHC.Conc.IO.closeFdWith_entry;
         const 0;
         const 4294967310;
         const 12884901903;
         const SaU13_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.389588047 UTC

[section ""data" . GHC.Conc.IO.threadWaitWrite1_closure" {
     GHC.Conc.IO.threadWaitWrite1_closure:
         const GHC.Conc.IO.threadWaitWrite1_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWrite1_entry() //  [R2]
         { []
         }
     {offset
       caU3F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU3G; else goto caU3H;
       caU3G: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitWrite1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caU3H: // global
           (_saTZD::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTZD::I64 == 0) goto caU3E; else goto caU3D;
       caU3E: // global
           I64[Sp - 8] = block_caU3K_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaU3T; else goto caU3L;
       uaU3T: // global
           call _caU3K(R1) args: 0, res: 0, upd: 0;
       caU3L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caU3D: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitWrite1_info" {
     GHC.Conc.IO.threadWaitWrite1_info:
         const GHC.Conc.IO.threadWaitWrite1_entry;
         const 0;
         const 30064771086;
         const 8589934597;
         const SaU13_srt+80;
 },
 _caU3K() //  [R1]
         { []
         }
     {offset
       caU3K: // global
           I64[Sp] = block_caU3P_info;
           R1 = I64[R1 + 7];
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caU3K_info" {
     block_caU3K_info:
         const _caU3K;
         const 0;
         const 30;
 },
 _caU3P() //  []
         { []
         }
     {offset
       caU3P: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caU3P_info" {
     block_caU3P_info:
         const _caU3P;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.396743234 UTC

[section ""data" . GHC.Conc.IO.threadWaitWrite_closure" {
     GHC.Conc.IO.threadWaitWrite_closure:
         const GHC.Conc.IO.threadWaitWrite_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWrite_entry() //  [R2]
         { []
         }
     {offset
       caU4e: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWrite1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitWrite_info" {
     GHC.Conc.IO.threadWaitWrite_info:
         const GHC.Conc.IO.threadWaitWrite_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SaU13_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.405195415 UTC

[section ""data" . GHC.Conc.IO.threadWaitWriteSTM1_closure" {
     GHC.Conc.IO.threadWaitWriteSTM1_closure:
         const GHC.Conc.IO.threadWaitWriteSTM1_info;
         const 0;
 },
 sat_saTZZ_entry() //  [R1]
         { []
         }
     {offset
       caU4T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU4U; else goto caU4V;
       caU4U: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU4V: // global
           I64[Sp - 8] = block_caU4R_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saTZZ_info" {
     sat_saTZZ_info:
         const sat_saTZZ_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _caU4R() //  []
         { []
         }
     {offset
       caU4R: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caU4R_info" {
     block_caU4R_info:
         const _caU4R;
         const 0;
         const 30;
 },
 sat_saU00_entry() //  [R1]
         { []
         }
     {offset
       caU4X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caU4Y; else goto caU4Z;
       caU4Y: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU4Z: // global
           I64[Sp - 16] = block_caU4F_info;
           _saTZR::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saTZR::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaU54; else goto caU4G;
       uaU54: // global
           call _caU4F(R1) args: 0, res: 0, upd: 0;
       caU4G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saU00_info" {
     sat_saU00_info:
         const sat_saU00_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _caU4F() //  [R1]
         { []
         }
     {offset
       caU4F: // global
           I64[Sp] = block_caU4K_info;
           R1 = I64[R1 + 7];
           call stg_waitWrite#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caU4F_info" {
     block_caU4F_info:
         const _caU4F;
         const 1;
         const 30;
 },
 _caU4K() //  []
         { []
         }
     {offset
       caU4K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caU53; else goto caU52;
       caU53: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caU52: // global
           I64[Hp - 8] = sat_saTZZ_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caU4K_info" {
     block_caU4K_info:
         const _caU4K;
         const 1;
         const 30;
 },
 sat_saU01_entry() //  [R1]
         { []
         }
     {offset
       caU55: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caU59; else goto caU58;
       caU59: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU58: // global
           _saTZI::P64 = P64[R1 + 7];
           _saTZR::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saU00_info;
           P64[Hp - 8] = _saTZI::P64;
           P64[Hp] = _saTZR::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saU01_info" {
     sat_saU01_info:
         const sat_saU01_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SaU13_srt+104;
 },
 sat_saU0d_entry() //  [R1]
         { []
         }
     {offset
       caU5j: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU5k; else goto caU5l;
       caU5k: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU5l: // global
           I64[Sp - 8] = block_caU5h_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saU0d_info" {
     sat_saU0d_info:
         const sat_saU0d_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const SaU13_srt+112;
 },
 _caU5h() //  []
         { []
         }
     {offset
       caU5h: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caU5h_info" {
     block_caU5h_info:
         const _caU5h;
         const 0;
         const 30;
 },
 sat_saU0a_entry() //  [R1]
         { []
         }
     {offset
       caU5B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU5C; else goto caU5D;
       caU5C: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU5D: // global
           I64[Sp - 8] = block_caU5s_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saU0a_info" {
     sat_saU0a_info:
         const sat_saU0a_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _caU5s() //  [R1]
         { []
         }
     {offset
       caU5s: // global
           I64[Sp] = block_caU5u_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaU5L; else goto caU5v;
       uaU5L: // global
           call _caU5u(R1) args: 0, res: 0, upd: 0;
       caU5v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caU5s_info" {
     block_caU5s_info:
         const _caU5s;
         const 0;
         const 30;
 },
 _caU5u() //  [R1]
         { []
         }
     {offset
       caU5u: // global
           if (R1 & 7 == 1) goto caU5y; else goto caU5z;
       caU5y: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caU5z: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caU5u_info" {
     block_caU5u_info:
         const _caU5u;
         const 0;
         const 30;
 },
 GHC.Conc.IO.threadWaitWriteSTM1_entry() //  [R2]
         { []
         }
     {offset
       caU5P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caU5Q; else goto caU5R;
       caU5Q: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitWriteSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caU5R: // global
           (_saTZN::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saTZN::I64 == 0) goto caU5O; else goto caU5N;
       caU5O: // global
           I64[Sp - 16] = block_caU4t_info;
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
       caU5N: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtWrite_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitWriteSTM1_info" {
     GHC.Conc.IO.threadWaitWriteSTM1_info:
         const GHC.Conc.IO.threadWaitWriteSTM1_entry;
         const 0;
         const 519691042830;
         const 8589934597;
         const SaU13_srt+80;
 },
 _caU4t() //  [R1]
         { []
         }
     {offset
       caU4t: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caU5V; else goto caU5U;
       caU5V: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caU5U: // global
           I64[Hp - 16] = sat_saU01_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_caU5a_info;
           _saTZR::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _saTZR::P64;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caU4t_info" {
     block_caU4t_info:
         const _caU4t;
         const 1;
         const 12884901918;
         const SaU13_srt+104;
 },
 _caU5a() //  [R1]
         { []
         }
     {offset
       caU5a: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caU5Y; else goto caU5X;
       caU5Y: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caU5X: // global
           I64[Hp - 48] = sat_saU0d_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saU0a_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caU5a_info" {
     block_caU5a_info:
         const _caU5a;
         const 1;
         const 4294967326;
         const SaU13_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.430260466 UTC

[section ""data" . GHC.Conc.IO.threadWaitWriteSTM_closure" {
     GHC.Conc.IO.threadWaitWriteSTM_closure:
         const GHC.Conc.IO.threadWaitWriteSTM_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitWriteSTM_entry() //  [R2]
         { []
         }
     {offset
       caU7m: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitWriteSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitWriteSTM_info" {
     GHC.Conc.IO.threadWaitWriteSTM_info:
         const GHC.Conc.IO.threadWaitWriteSTM_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SaU13_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.435477901 UTC

[section ""data" . GHC.Conc.IO.threadWaitRead1_closure" {
     GHC.Conc.IO.threadWaitRead1_closure:
         const GHC.Conc.IO.threadWaitRead1_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitRead1_entry() //  [R2]
         { []
         }
     {offset
       caU7C: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU7D; else goto caU7E;
       caU7D: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitRead1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caU7E: // global
           (_saU0k::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saU0k::I64 == 0) goto caU7B; else goto caU7A;
       caU7B: // global
           I64[Sp - 8] = block_caU7H_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uaU7Q; else goto caU7I;
       uaU7Q: // global
           call _caU7H(R1) args: 0, res: 0, upd: 0;
       caU7I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       caU7A: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitRead1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitRead1_info" {
     GHC.Conc.IO.threadWaitRead1_info:
         const GHC.Conc.IO.threadWaitRead1_entry;
         const 0;
         const 828928688142;
         const 8589934597;
         const SaU13_srt+88;
 },
 _caU7H() //  [R1]
         { []
         }
     {offset
       caU7H: // global
           I64[Sp] = block_caU7M_info;
           R1 = I64[R1 + 7];
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caU7H_info" {
     block_caU7H_info:
         const _caU7H;
         const 0;
         const 30;
 },
 _caU7M() //  []
         { []
         }
     {offset
       caU7M: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caU7M_info" {
     block_caU7M_info:
         const _caU7M;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.442278209 UTC

[section ""data" . GHC.Conc.IO.threadWaitRead_closure" {
     GHC.Conc.IO.threadWaitRead_closure:
         const GHC.Conc.IO.threadWaitRead_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitRead_entry() //  [R2]
         { []
         }
     {offset
       caU8b: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitRead1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitRead_info" {
     GHC.Conc.IO.threadWaitRead_info:
         const GHC.Conc.IO.threadWaitRead_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SaU13_srt+144;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.449922651 UTC

[section ""data" . GHC.Conc.IO.threadWaitReadSTM1_closure" {
     GHC.Conc.IO.threadWaitReadSTM1_closure:
         const GHC.Conc.IO.threadWaitReadSTM1_info;
         const 0;
 },
 sat_saU0G_entry() //  [R1]
         { []
         }
     {offset
       caU8Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU8R; else goto caU8S;
       caU8R: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU8S: // global
           I64[Sp - 8] = block_caU8O_info;
           R2 = GHC.Types.True_closure+2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_writeTVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saU0G_info" {
     sat_saU0G_info:
         const sat_saU0G_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _caU8O() //  []
         { []
         }
     {offset
       caU8O: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caU8O_info" {
     block_caU8O_info:
         const _caU8O;
         const 0;
         const 30;
 },
 sat_saU0H_entry() //  [R1]
         { []
         }
     {offset
       caU8U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caU8V; else goto caU8W;
       caU8V: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU8W: // global
           I64[Sp - 16] = block_caU8C_info;
           _saU0y::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saU0y::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uaU91; else goto caU8D;
       uaU91: // global
           call _caU8C(R1) args: 0, res: 0, upd: 0;
       caU8D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saU0H_info" {
     sat_saU0H_info:
         const sat_saU0H_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _caU8C() //  [R1]
         { []
         }
     {offset
       caU8C: // global
           I64[Sp] = block_caU8H_info;
           R1 = I64[R1 + 7];
           call stg_waitRead#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caU8C_info" {
     block_caU8C_info:
         const _caU8C;
         const 1;
         const 30;
 },
 _caU8H() //  []
         { []
         }
     {offset
       caU8H: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto caU90; else goto caU8Z;
       caU90: // global
           HpAlloc = 16;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       caU8Z: // global
           I64[Hp - 8] = sat_saU0G_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_atomically#(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caU8H_info" {
     block_caU8H_info:
         const _caU8H;
         const 1;
         const 30;
 },
 sat_saU0I_entry() //  [R1]
         { []
         }
     {offset
       caU92: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caU96; else goto caU95;
       caU96: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU95: // global
           _saU0p::P64 = P64[R1 + 7];
           _saU0y::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_saU0H_info;
           P64[Hp - 8] = _saU0p::P64;
           P64[Hp] = _saU0y::P64;
           R2 = GHC.Conc.Sync.forkIO2_closure+2;
           R1 = Hp - 15;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_saU0I_info" {
     sat_saU0I_info:
         const sat_saU0I_entry;
         const 2;
         const 4294967307;
         const 4294967299;
         const SaU13_srt+104;
 },
 sat_saU0U_entry() //  [R1]
         { []
         }
     {offset
       caU9g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU9h; else goto caU9i;
       caU9h: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU9i: // global
           I64[Sp - 8] = block_caU9e_info;
           R2 = GHC.Conc.Sync.killThread2_closure;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saU0U_info" {
     sat_saU0U_info:
         const sat_saU0U_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const SaU13_srt+112;
 },
 _caU9e() //  []
         { []
         }
     {offset
       caU9e: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caU9e_info" {
     block_caU9e_info:
         const _caU9e;
         const 0;
         const 30;
 },
 sat_saU0R_entry() //  [R1]
         { []
         }
     {offset
       caU9y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto caU9z; else goto caU9A;
       caU9z: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caU9A: // global
           I64[Sp - 8] = block_caU9p_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_readTVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_saU0R_info" {
     sat_saU0R_info:
         const sat_saU0R_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 _caU9p() //  [R1]
         { []
         }
     {offset
       caU9p: // global
           I64[Sp] = block_caU9r_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uaU9I; else goto caU9s;
       uaU9I: // global
           call _caU9r(R1) args: 0, res: 0, upd: 0;
       caU9s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caU9p_info" {
     block_caU9p_info:
         const _caU9p;
         const 0;
         const 30;
 },
 _caU9r() //  [R1]
         { []
         }
     {offset
       caU9r: // global
           if (R1 & 7 == 1) goto caU9v; else goto caU9w;
       caU9v: // global
           Sp = Sp + 8;
           call stg_retry#() args: 8, res: 0, upd: 8;
       caU9w: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caU9r_info" {
     block_caU9r_info:
         const _caU9r;
         const 0;
         const 30;
 },
 GHC.Conc.IO.threadWaitReadSTM1_entry() //  [R2]
         { []
         }
     {offset
       caU9M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto caU9N; else goto caU9O;
       caU9N: // global
           R2 = R2;
           R1 = GHC.Conc.IO.threadWaitReadSTM1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caU9O: // global
           (_saU0u::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] rtsSupportsBoundThreads();
           if (_saU0u::I64 == 0) goto caU9L; else goto caU9K;
       caU9L: // global
           I64[Sp - 16] = block_caU8q_info;
           R1 = GHC.Types.False_closure+1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newTVar#(R1) args: 8, res: 8, upd: 8;
       caU9K: // global
           R3 = R2;
           R2 = GHC.Event.Internal.evtRead_closure;
           call GHC.Event.Thread.threadWaitReadSTM1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitReadSTM1_info" {
     GHC.Conc.IO.threadWaitReadSTM1_info:
         const GHC.Conc.IO.threadWaitReadSTM1_entry;
         const 0;
         const 373662154766;
         const 8589934597;
         const SaU13_srt+104;
 },
 _caU8q() //  [R1]
         { []
         }
     {offset
       caU8q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto caU9S; else goto caU9R;
       caU9S: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caU9R: // global
           I64[Hp - 16] = sat_saU0I_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           I64[Sp] = block_caU97_info;
           _saU0y::P64 = R1;
           R1 = Hp - 15;
           P64[Sp + 8] = _saU0y::P64;
           call stg_fork#(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_caU8q_info" {
     block_caU8q_info:
         const _caU8q;
         const 1;
         const 12884901918;
         const SaU13_srt+104;
 },
 _caU97() //  [R1]
         { []
         }
     {offset
       caU97: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto caU9V; else goto caU9U;
       caU9V: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       caU9U: // global
           I64[Hp - 48] = sat_saU0U_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = sat_saU0R_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_caU97_info" {
     block_caU97_info:
         const _caU97;
         const 1;
         const 4294967326;
         const SaU13_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.475886045 UTC

[section ""data" . GHC.Conc.IO.threadWaitReadSTM_closure" {
     GHC.Conc.IO.threadWaitReadSTM_closure:
         const GHC.Conc.IO.threadWaitReadSTM_info;
         const 0;
 },
 GHC.Conc.IO.threadWaitReadSTM_entry() //  [R2]
         { []
         }
     {offset
       caUbj: // global
           R2 = R2;
           call GHC.Conc.IO.threadWaitReadSTM1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Conc.IO.threadWaitReadSTM_info" {
     GHC.Conc.IO.threadWaitReadSTM_info:
         const GHC.Conc.IO.threadWaitReadSTM_entry;
         const 0;
         const 4294967310;
         const 8589934597;
         const SaU13_srt+152;
 }]


==================== Raw Cmm ====================
2018-03-16 16:05:54.47905964 UTC

[section ""relreadonly" . SaU13_srt" {
     SaU13_srt:
         const GHC.Event.Thread.ensureIOManagerIsRunning1_closure;
         const GHC.Event.Thread.ioManagerCapabilitiesChanged1_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Event.Thread.registerDelay1_closure;
         const GHC.Conc.IO.registerDelay2_closure;
         const GHC.Conc.IO.registerDelay1_closure;
         const GHC.Event.Thread.threadDelay1_closure;
         const GHC.Conc.IO.threadDelay1_closure;
         const GHC.Event.Thread.closeFdWith1_closure;
         const GHC.Conc.IO.closeFdWith1_closure;
         const GHC.Event.Internal.evtWrite_closure;
         const GHC.Event.Thread.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitWrite1_closure;
         const GHC.Conc.Sync.forkIO2_closure;
         const GHC.Conc.Sync.killThread2_closure;
         const GHC.Event.Thread.threadWaitReadSTM1_closure;
         const GHC.Conc.IO.threadWaitWriteSTM1_closure;
         const GHC.Event.Internal.evtRead_closure;
         const GHC.Conc.IO.threadWaitRead1_closure;
         const GHC.Conc.IO.threadWaitReadSTM1_closure;
 }]

