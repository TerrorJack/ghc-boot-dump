
==================== Output Cmm ====================
2018-03-16 16:11:14.354428633 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:14.3550361 UTC

[section ""cstring" . loc_rfwqJ_bytes" {
     loc_rfwqJ_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.356057982 UTC

[section ""data" . loc1_rfwta_closure" {
     loc1_rfwta_closure:
         const loc1_rfwta_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_rfwta_entry() //  [R1]
         { info_tbl: [(cfwtY,
                       label: loc1_rfwta_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwtY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwtZ; else goto cfwu0;
       cfwtZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwu0: // global
           (_cfwtV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwtV::I64 == 0) goto cfwtX; else goto cfwtW;
       cfwtX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwtW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwtV::I64;
           R2 = loc_rfwqJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.357113208 UTC

[section ""cstring" . loc2_rfwtb_bytes" {
     loc2_rfwtb_bytes:
         I8[] [71,72,67,46,83,116,97,116,105,99,80,116,114,46,73,110,116,101,114,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.35794206 UTC

[section ""data" . loc3_rfwtc_closure" {
     loc3_rfwtc_closure:
         const loc3_rfwtc_info;
         const 0;
         const 0;
         const 0;
 },
 loc3_rfwtc_entry() //  [R1]
         { info_tbl: [(cfwu7,
                       label: loc3_rfwtc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwu7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwu8; else goto cfwu9;
       cfwu8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwu9: // global
           (_cfwu4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwu4::I64 == 0) goto cfwu6; else goto cfwu5;
       cfwu6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwu5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwu4::I64;
           R2 = loc2_rfwtb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.358959281 UTC

[section ""cstring" . loc4_rfwtd_bytes" {
     loc4_rfwtd_bytes:
         I8[] [46,47,71,72,67,47,83,116,97,116,105,99,80,116,114,47,73,110,116,101,114,110,97,108,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.359751492 UTC

[section ""data" . loc5_rfwte_closure" {
     loc5_rfwte_closure:
         const loc5_rfwte_info;
         const 0;
         const 0;
         const 0;
 },
 loc5_rfwte_entry() //  [R1]
         { info_tbl: [(cfwug,
                       label: loc5_rfwte_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwug: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwuh; else goto cfwui;
       cfwuh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwui: // global
           (_cfwud::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwud::I64 == 0) goto cfwuf; else goto cfwue;
       cfwuf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwue: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwud::I64;
           R2 = loc4_rfwtd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.3607796 UTC

[section ""data" . loc6_rfwtf_closure" {
     loc6_rfwtf_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.361424203 UTC

[section ""data" . loc7_rfwtg_closure" {
     loc7_rfwtg_closure:
         const GHC.Types.I#_con_info;
         const 5;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.36207534 UTC

[section ""data" . loc8_rfwth_closure" {
     loc8_rfwth_closure:
         const GHC.Types.I#_con_info;
         const 27;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.362708081 UTC

[section ""data" . loc9_rfwti_closure" {
     loc9_rfwti_closure:
         const GHC.Types.I#_con_info;
         const 59;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.363357065 UTC

[section ""cstring" . $dIP_rfwtj_bytes" {
     $dIP_rfwtj_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.364184565 UTC

[section ""data" . $dIP1_rfwtk_closure" {
     $dIP1_rfwtk_closure:
         const $dIP1_rfwtk_info;
         const 0;
         const 0;
         const 0;
 },
 $dIP1_rfwtk_entry() //  [R1]
         { info_tbl: [(cfwup,
                       label: $dIP1_rfwtk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwup: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwuq; else goto cfwur;
       cfwuq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwur: // global
           (_cfwum::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwum::I64 == 0) goto cfwuo; else goto cfwun;
       cfwuo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwun: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwum::I64;
           R2 = $dIP_rfwtj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.365216869 UTC

[section ""data" . $dIP2_rfwtl_closure" {
     $dIP2_rfwtl_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc1_rfwta_closure;
         const loc3_rfwtc_closure;
         const loc5_rfwte_closure;
         const loc6_rfwtf_closure+1;
         const loc7_rfwtg_closure+1;
         const loc8_rfwth_closure+1;
         const loc9_rfwti_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.365889512 UTC

[section ""data" . $dIP3_rfwtm_closure" {
     $dIP3_rfwtm_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_rfwtk_closure;
         const $dIP2_rfwtl_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.366549442 UTC

[section ""cstring" . lvl_rfwtn_bytes" {
     lvl_rfwtn_bytes:
         I8[] [71,72,67,32,98,117,103,32,45,32,109,97,107,101,83,116,97,116,105,99,58,32,85,110,114,101,115,111,108,118,101,100,32,115,116,97,116,105,99,32,102,111,114,109,32,97,116,32,108,105,110,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.367176146 UTC

[section ""cstring" . lvl1_rfwto_bytes" {
     lvl1_rfwto_bytes:
         I8[] [44,32,99,111,108,117,109,110,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.367759483 UTC

[section ""cstring" . lvl2_rfwtp_bytes" {
     lvl2_rfwtp_bytes:
         I8[] [46]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.368624598 UTC

[section ""data" . lvl3_rfwtq_closure" {
     lvl3_rfwtq_closure:
         const lvl3_rfwtq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rfwtq_entry() //  [R1]
         { info_tbl: [(cfwuy,
                       label: lvl3_rfwtq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwuy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwuz; else goto cfwuA;
       cfwuz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwuA: // global
           (_cfwuv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwuv::I64 == 0) goto cfwux; else goto cfwuw;
       cfwux: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwuw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwuv::I64;
           R2 = lvl2_rfwtp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.370710586 UTC

[section ""data" . $wlvl_rfwtr_closure" {
     $wlvl_rfwtr_closure:
         const $wlvl_rfwtr_info;
         const 0;
 },
 sat_sfwtF_entry() //  [R1]
         { info_tbl: [(cfwuW,
                       label: sat_sfwtF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwuW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfwuX; else goto cfwuY;
       cfwuX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwuY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cfwuT_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfwuT() //  [R1, R2]
         { info_tbl: [(cfwuT,
                       label: block_cfwuT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwuT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfwv1; else goto cfwv0;
       cfwv1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cfwv0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl3_rfwtq_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfwtG_entry() //  [R1]
         { info_tbl: [(cfwv2,
                       label: sat_sfwtG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwv2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfwv6; else goto cfwv5;
       cfwv6: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwv5: // global
           _sfwtv::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_sfwtF_info;
           I64[Hp] = _sfwtv::I64;
           R3 = Hp - 16;
           R2 = lvl1_rfwto_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfwtH_entry() //  [R1]
         { info_tbl: [(cfwv8,
                       label: sat_sfwtH_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwv8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfwv9; else goto cfwva;
       cfwv9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwva: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cfwuJ_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfwuJ() //  [R1, R2]
         { info_tbl: [(cfwuJ,
                       label: block_cfwuJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwuJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfwvd; else goto cfwvc;
       cfwvd: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cfwvc: // global
           I64[Hp - 40] = sat_sfwtG_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_rfwtr_entry() //  [R2, R3]
         { info_tbl: [(cfwvg,
                       label: $wlvl_rfwtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwvg: // global
           _sfwtw::I64 = R3;
           _sfwtv::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cfwvh; else goto cfwvi;
       cfwvi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfwvk; else goto cfwvj;
       cfwvk: // global
           HpAlloc = 32;
           goto cfwvh;
       cfwvh: // global
           R3 = _sfwtw::I64;
           R2 = _sfwtv::I64;
           R1 = $wlvl_rfwtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwvj: // global
           I64[Hp - 24] = sat_sfwtH_info;
           I64[Hp - 8] = _sfwtv::I64;
           I64[Hp] = _sfwtw::I64;
           I64[Sp - 8] = block_cfwve_info;
           R3 = Hp - 24;
           R2 = lvl_rfwtn_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfwve() //  [R1]
         { info_tbl: [(cfwve,
                       label: block_cfwve_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwve: // global
           R3 = R1;
           R2 = $dIP3_rfwtm_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.373988239 UTC

[section ""data" . GHC.StaticPtr.Internal.makeStatic_closure" {
     GHC.StaticPtr.Internal.makeStatic_closure:
         const GHC.StaticPtr.Internal.makeStatic_info;
         const 0;
 },
 GHC.StaticPtr.Internal.makeStatic_entry() //  [R2, R3]
         { info_tbl: [(cfwvw,
                       label: GHC.StaticPtr.Internal.makeStatic_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwvw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwvF; else goto cfwvG;
       cfwvF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.Internal.makeStatic_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwvG: // global
           I64[Sp - 8] = block_cfwvt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwvP; else goto cfwvu;
       ufwvP: // global
           call _cfwvt(R1) args: 0, res: 0, upd: 0;
       cfwvu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwvt() //  [R1]
         { info_tbl: [(cfwvt,
                       label: block_cfwvt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwvt: // global
           I64[Sp - 8] = block_cfwvz_info;
           _sfwtN::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sfwtN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwvO; else goto cfwvA;
       ufwvO: // global
           call _cfwvz(R1) args: 0, res: 0, upd: 0;
       cfwvA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwvz() //  [R1]
         { info_tbl: [(cfwvz,
                       label: block_cfwvz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwvz: // global
           I64[Sp] = block_cfwvE_info;
           _sfwtP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sfwtP::I64;
           if (R1 & 7 != 0) goto ufwvQ; else goto cfwvJ;
       ufwvQ: // global
           call _cfwvE(R1) args: 0, res: 0, upd: 0;
       cfwvJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwvE() //  [R1]
         { info_tbl: [(cfwvE,
                       label: block_cfwvE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwvE: // global
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call $wlvl_rfwtr_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.375601084 UTC

[section ""data" . $trModule1_rfwts_closure" {
     $trModule1_rfwts_closure:
         const GHC.Types.TrNameS_con_info;
         const loc_rfwqJ_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.376274451 UTC

[section ""data" . $trModule2_rfwtt_closure" {
     $trModule2_rfwtt_closure:
         const GHC.Types.TrNameS_con_info;
         const loc2_rfwtb_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.376981546 UTC

[section ""data" . GHC.StaticPtr.Internal.$trModule_closure" {
     GHC.StaticPtr.Internal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const $trModule1_rfwts_closure+1;
         const $trModule2_rfwtt_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.377691466 UTC

[section ""relreadonly" . Sfwvo_srt" {
     Sfwvo_srt:
         const lvl3_rfwtq_closure;
         const GHC.Err.error_closure;
         const $dIP3_rfwtm_closure;
         const $wlvl_rfwtr_closure;
         const GHC.StaticPtr.Internal.makeStatic_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.378343393 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:14.378932981 UTC

[section ""cstring" . loc_rfwqJ_bytes" {
     loc_rfwqJ_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.379824983 UTC

[section ""data" . loc1_rfwta_closure" {
     loc1_rfwta_closure:
         const loc1_rfwta_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_rfwta_entry() //  [R1]
         { info_tbl: [(cfwvX,
                       label: loc1_rfwta_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwvX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwvY; else goto cfwvZ;
       cfwvY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwvZ: // global
           (_cfwvU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwvU::I64 == 0) goto cfwvW; else goto cfwvV;
       cfwvW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwvV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwvU::I64;
           R2 = loc_rfwqJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.380890171 UTC

[section ""cstring" . loc2_rfwtb_bytes" {
     loc2_rfwtb_bytes:
         I8[] [71,72,67,46,83,116,97,116,105,99,80,116,114,46,73,110,116,101,114,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.381729033 UTC

[section ""data" . loc3_rfwtc_closure" {
     loc3_rfwtc_closure:
         const loc3_rfwtc_info;
         const 0;
         const 0;
         const 0;
 },
 loc3_rfwtc_entry() //  [R1]
         { info_tbl: [(cfww6,
                       label: loc3_rfwtc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfww6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfww7; else goto cfww8;
       cfww7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfww8: // global
           (_cfww3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfww3::I64 == 0) goto cfww5; else goto cfww4;
       cfww5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfww4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfww3::I64;
           R2 = loc2_rfwtb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.382749051 UTC

[section ""cstring" . loc4_rfwtd_bytes" {
     loc4_rfwtd_bytes:
         I8[] [46,47,71,72,67,47,83,116,97,116,105,99,80,116,114,47,73,110,116,101,114,110,97,108,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.383615524 UTC

[section ""data" . loc5_rfwte_closure" {
     loc5_rfwte_closure:
         const loc5_rfwte_info;
         const 0;
         const 0;
         const 0;
 },
 loc5_rfwte_entry() //  [R1]
         { info_tbl: [(cfwwf,
                       label: loc5_rfwte_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwwf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwwg; else goto cfwwh;
       cfwwg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwwh: // global
           (_cfwwc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwwc::I64 == 0) goto cfwwe; else goto cfwwd;
       cfwwe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwwd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwwc::I64;
           R2 = loc4_rfwtd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.384629108 UTC

[section ""data" . loc6_rfwtf_closure" {
     loc6_rfwtf_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.385741887 UTC

[section ""data" . loc7_rfwtg_closure" {
     loc7_rfwtg_closure:
         const GHC.Types.I#_con_info;
         const 5;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.386463736 UTC

[section ""data" . loc8_rfwth_closure" {
     loc8_rfwth_closure:
         const GHC.Types.I#_con_info;
         const 27;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.387163535 UTC

[section ""data" . loc9_rfwti_closure" {
     loc9_rfwti_closure:
         const GHC.Types.I#_con_info;
         const 59;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.387846665 UTC

[section ""cstring" . $dIP_rfwtj_bytes" {
     $dIP_rfwtj_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.388705466 UTC

[section ""data" . $dIP1_rfwtk_closure" {
     $dIP1_rfwtk_closure:
         const $dIP1_rfwtk_info;
         const 0;
         const 0;
         const 0;
 },
 $dIP1_rfwtk_entry() //  [R1]
         { info_tbl: [(cfwwo,
                       label: $dIP1_rfwtk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwwo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwwp; else goto cfwwq;
       cfwwp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwwq: // global
           (_cfwwl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwwl::I64 == 0) goto cfwwn; else goto cfwwm;
       cfwwn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwwm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwwl::I64;
           R2 = $dIP_rfwtj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.389794711 UTC

[section ""data" . $dIP2_rfwtl_closure" {
     $dIP2_rfwtl_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc1_rfwta_closure;
         const loc3_rfwtc_closure;
         const loc5_rfwte_closure;
         const loc6_rfwtf_closure+1;
         const loc7_rfwtg_closure+1;
         const loc8_rfwth_closure+1;
         const loc9_rfwti_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.390583729 UTC

[section ""data" . $dIP3_rfwtm_closure" {
     $dIP3_rfwtm_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_rfwtk_closure;
         const $dIP2_rfwtl_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.392557253 UTC

[section ""cstring" . lvl_rfwtn_bytes" {
     lvl_rfwtn_bytes:
         I8[] [71,72,67,32,98,117,103,32,45,32,109,97,107,101,83,116,97,116,105,99,58,32,85,110,114,101,115,111,108,118,101,100,32,115,116,97,116,105,99,32,102,111,114,109,32,97,116,32,108,105,110,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.393170794 UTC

[section ""cstring" . lvl1_rfwto_bytes" {
     lvl1_rfwto_bytes:
         I8[] [44,32,99,111,108,117,109,110,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.393826201 UTC

[section ""cstring" . lvl2_rfwtp_bytes" {
     lvl2_rfwtp_bytes:
         I8[] [46]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.394629029 UTC

[section ""data" . lvl3_rfwtq_closure" {
     lvl3_rfwtq_closure:
         const lvl3_rfwtq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rfwtq_entry() //  [R1]
         { info_tbl: [(cfwwx,
                       label: lvl3_rfwtq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwwx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwwy; else goto cfwwz;
       cfwwy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwwz: // global
           (_cfwwu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwwu::I64 == 0) goto cfwww; else goto cfwwv;
       cfwww: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwwv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwwu::I64;
           R2 = lvl2_rfwtp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.396615603 UTC

[section ""data" . $wlvl_rfwtr_closure" {
     $wlvl_rfwtr_closure:
         const $wlvl_rfwtr_info;
         const 0;
 },
 sat_sfwtF_entry() //  [R1]
         { info_tbl: [(cfwwV,
                       label: sat_sfwtF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwwV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfwwW; else goto cfwwX;
       cfwwW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwwX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cfwwS_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfwwS() //  [R1, R2]
         { info_tbl: [(cfwwS,
                       label: block_cfwwS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwwS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfwx0; else goto cfwwZ;
       cfwx0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cfwwZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl3_rfwtq_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfwtG_entry() //  [R1]
         { info_tbl: [(cfwx1,
                       label: sat_sfwtG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwx1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfwx5; else goto cfwx4;
       cfwx5: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwx4: // global
           _sfwtv::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_sfwtF_info;
           I64[Hp] = _sfwtv::I64;
           R3 = Hp - 16;
           R2 = lvl1_rfwto_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfwtH_entry() //  [R1]
         { info_tbl: [(cfwx7,
                       label: sat_sfwtH_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwx7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfwx8; else goto cfwx9;
       cfwx8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwx9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cfwwI_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfwwI() //  [R1, R2]
         { info_tbl: [(cfwwI,
                       label: block_cfwwI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwwI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfwxc; else goto cfwxb;
       cfwxc: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cfwxb: // global
           I64[Hp - 40] = sat_sfwtG_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_rfwtr_entry() //  [R2, R3]
         { info_tbl: [(cfwxf,
                       label: $wlvl_rfwtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwxf: // global
           _sfwtw::I64 = R3;
           _sfwtv::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cfwxg; else goto cfwxh;
       cfwxh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfwxj; else goto cfwxi;
       cfwxj: // global
           HpAlloc = 32;
           goto cfwxg;
       cfwxg: // global
           R3 = _sfwtw::I64;
           R2 = _sfwtv::I64;
           R1 = $wlvl_rfwtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwxi: // global
           I64[Hp - 24] = sat_sfwtH_info;
           I64[Hp - 8] = _sfwtv::I64;
           I64[Hp] = _sfwtw::I64;
           I64[Sp - 8] = block_cfwxd_info;
           R3 = Hp - 24;
           R2 = lvl_rfwtn_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfwxd() //  [R1]
         { info_tbl: [(cfwxd,
                       label: block_cfwxd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwxd: // global
           R3 = R1;
           R2 = $dIP3_rfwtm_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.399639959 UTC

[section ""data" . GHC.StaticPtr.Internal.makeStatic_closure" {
     GHC.StaticPtr.Internal.makeStatic_closure:
         const GHC.StaticPtr.Internal.makeStatic_info;
         const 0;
 },
 GHC.StaticPtr.Internal.makeStatic_entry() //  [R2, R3]
         { info_tbl: [(cfwxu,
                       label: GHC.StaticPtr.Internal.makeStatic_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwxu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwxD; else goto cfwxE;
       cfwxD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.Internal.makeStatic_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwxE: // global
           I64[Sp - 8] = block_cfwxr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwxN; else goto cfwxs;
       ufwxN: // global
           call _cfwxr(R1) args: 0, res: 0, upd: 0;
       cfwxs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwxr() //  [R1]
         { info_tbl: [(cfwxr,
                       label: block_cfwxr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwxr: // global
           I64[Sp - 8] = block_cfwxx_info;
           _sfwtN::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sfwtN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwxM; else goto cfwxy;
       ufwxM: // global
           call _cfwxx(R1) args: 0, res: 0, upd: 0;
       cfwxy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwxx() //  [R1]
         { info_tbl: [(cfwxx,
                       label: block_cfwxx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwxx: // global
           I64[Sp] = block_cfwxC_info;
           _sfwtP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sfwtP::I64;
           if (R1 & 7 != 0) goto ufwxO; else goto cfwxH;
       ufwxO: // global
           call _cfwxC(R1) args: 0, res: 0, upd: 0;
       cfwxH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwxC() //  [R1]
         { info_tbl: [(cfwxC,
                       label: block_cfwxC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwxC: // global
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call $wlvl_rfwtr_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.401144325 UTC

[section ""data" . $trModule1_rfwts_closure" {
     $trModule1_rfwts_closure:
         const GHC.Types.TrNameS_con_info;
         const loc_rfwqJ_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.401785918 UTC

[section ""data" . $trModule2_rfwtt_closure" {
     $trModule2_rfwtt_closure:
         const GHC.Types.TrNameS_con_info;
         const loc2_rfwtb_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.402399805 UTC

[section ""data" . GHC.StaticPtr.Internal.$trModule_closure" {
     GHC.StaticPtr.Internal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const $trModule1_rfwts_closure+1;
         const $trModule2_rfwtt_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.403040978 UTC

[section ""relreadonly" . Sfwvo_srt" {
     Sfwvo_srt:
         const lvl3_rfwtq_closure;
         const GHC.Err.error_closure;
         const $dIP3_rfwtm_closure;
         const $wlvl_rfwtr_closure;
         const GHC.StaticPtr.Internal.makeStatic_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.403941806 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:14.40522694 UTC

[section ""cstring" . loc_rfwqJ_bytes" {
     loc_rfwqJ_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.407800612 UTC

[section ""data" . loc1_rfwta_closure" {
     loc1_rfwta_closure:
         const loc1_rfwta_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_rfwta_entry() //  [R1]
         { info_tbl: [(cfwxW,
                       label: loc1_rfwta_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwxW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwxX; else goto cfwxY;
       cfwxX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwxY: // global
           (_cfwxT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwxT::I64 == 0) goto cfwxV; else goto cfwxU;
       cfwxV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwxU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwxT::I64;
           R2 = loc_rfwqJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.412201589 UTC

[section ""cstring" . loc2_rfwtb_bytes" {
     loc2_rfwtb_bytes:
         I8[] [71,72,67,46,83,116,97,116,105,99,80,116,114,46,73,110,116,101,114,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.414580501 UTC

[section ""data" . loc3_rfwtc_closure" {
     loc3_rfwtc_closure:
         const loc3_rfwtc_info;
         const 0;
         const 0;
         const 0;
 },
 loc3_rfwtc_entry() //  [R1]
         { info_tbl: [(cfwyd,
                       label: loc3_rfwtc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwyd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwye; else goto cfwyf;
       cfwye: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwyf: // global
           (_cfwya::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwya::I64 == 0) goto cfwyc; else goto cfwyb;
       cfwyc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwyb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwya::I64;
           R2 = loc2_rfwtb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.418842777 UTC

[section ""cstring" . loc4_rfwtd_bytes" {
     loc4_rfwtd_bytes:
         I8[] [46,47,71,72,67,47,83,116,97,116,105,99,80,116,114,47,73,110,116,101,114,110,97,108,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.420985144 UTC

[section ""data" . loc5_rfwte_closure" {
     loc5_rfwte_closure:
         const loc5_rfwte_info;
         const 0;
         const 0;
         const 0;
 },
 loc5_rfwte_entry() //  [R1]
         { info_tbl: [(cfwyu,
                       label: loc5_rfwte_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwyu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwyv; else goto cfwyw;
       cfwyv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwyw: // global
           (_cfwyr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwyr::I64 == 0) goto cfwyt; else goto cfwys;
       cfwyt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwys: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwyr::I64;
           R2 = loc4_rfwtd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.425539595 UTC

[section ""data" . loc6_rfwtf_closure" {
     loc6_rfwtf_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.427495741 UTC

[section ""data" . loc7_rfwtg_closure" {
     loc7_rfwtg_closure:
         const GHC.Types.I#_con_info;
         const 5;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.430537014 UTC

[section ""data" . loc8_rfwth_closure" {
     loc8_rfwth_closure:
         const GHC.Types.I#_con_info;
         const 27;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.432334714 UTC

[section ""data" . loc9_rfwti_closure" {
     loc9_rfwti_closure:
         const GHC.Types.I#_con_info;
         const 59;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.434232897 UTC

[section ""cstring" . $dIP_rfwtj_bytes" {
     $dIP_rfwtj_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.436440892 UTC

[section ""data" . $dIP1_rfwtk_closure" {
     $dIP1_rfwtk_closure:
         const $dIP1_rfwtk_info;
         const 0;
         const 0;
         const 0;
 },
 $dIP1_rfwtk_entry() //  [R1]
         { info_tbl: [(cfwyP,
                       label: $dIP1_rfwtk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwyP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwyQ; else goto cfwyR;
       cfwyQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwyR: // global
           (_cfwyM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwyM::I64 == 0) goto cfwyO; else goto cfwyN;
       cfwyO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwyN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwyM::I64;
           R2 = $dIP_rfwtj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.441197515 UTC

[section ""data" . $dIP2_rfwtl_closure" {
     $dIP2_rfwtl_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc1_rfwta_closure;
         const loc3_rfwtc_closure;
         const loc5_rfwte_closure;
         const loc6_rfwtf_closure+1;
         const loc7_rfwtg_closure+1;
         const loc8_rfwth_closure+1;
         const loc9_rfwti_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.443174895 UTC

[section ""data" . $dIP3_rfwtm_closure" {
     $dIP3_rfwtm_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_rfwtk_closure;
         const $dIP2_rfwtl_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.44502554 UTC

[section ""cstring" . lvl_rfwtn_bytes" {
     lvl_rfwtn_bytes:
         I8[] [71,72,67,32,98,117,103,32,45,32,109,97,107,101,83,116,97,116,105,99,58,32,85,110,114,101,115,111,108,118,101,100,32,115,116,97,116,105,99,32,102,111,114,109,32,97,116,32,108,105,110,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.446859069 UTC

[section ""cstring" . lvl1_rfwto_bytes" {
     lvl1_rfwto_bytes:
         I8[] [44,32,99,111,108,117,109,110,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.448634081 UTC

[section ""cstring" . lvl2_rfwtp_bytes" {
     lvl2_rfwtp_bytes:
         I8[] [46]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.451318843 UTC

[section ""data" . lvl3_rfwtq_closure" {
     lvl3_rfwtq_closure:
         const lvl3_rfwtq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rfwtq_entry() //  [R1]
         { info_tbl: [(cfwza,
                       label: lvl3_rfwtq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwza: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwzb; else goto cfwzc;
       cfwzb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwzc: // global
           (_cfwz7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwz7::I64 == 0) goto cfwz9; else goto cfwz8;
       cfwz9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwz8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwz7::I64;
           R2 = lvl2_rfwtp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.45692758 UTC

[section ""data" . $wlvl_rfwtr_closure" {
     $wlvl_rfwtr_closure:
         const $wlvl_rfwtr_info;
         const 0;
 },
 sat_sfwtF_entry() //  [R1]
         { info_tbl: [(cfwzF,
                       label: sat_sfwtF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwzF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfwzG; else goto cfwzH;
       cfwzG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwzH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cfwzC_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfwzC() //  [R1, R2]
         { info_tbl: [(cfwzC,
                       label: block_cfwzC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwzC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfwzK; else goto cfwzJ;
       cfwzK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cfwzJ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl3_rfwtq_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfwtG_entry() //  [R1]
         { info_tbl: [(cfwzL,
                       label: sat_sfwtG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwzL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfwzP; else goto cfwzO;
       cfwzP: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwzO: // global
           _sfwtv::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_sfwtF_info;
           I64[Hp] = _sfwtv::I64;
           R3 = Hp - 16;
           R2 = lvl1_rfwto_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfwtH_entry() //  [R1]
         { info_tbl: [(cfwzR,
                       label: sat_sfwtH_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwzR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfwzS; else goto cfwzT;
       cfwzS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwzT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cfwzs_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfwzs() //  [R1, R2]
         { info_tbl: [(cfwzs,
                       label: block_cfwzs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwzs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfwzW; else goto cfwzV;
       cfwzW: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cfwzV: // global
           I64[Hp - 40] = sat_sfwtG_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_rfwtr_entry() //  [R2, R3]
         { info_tbl: [(cfwzZ,
                       label: $wlvl_rfwtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwzZ: // global
           _sfwtw::I64 = R3;
           _sfwtv::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cfwA0; else goto cfwA1;
       cfwA1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfwA3; else goto cfwA2;
       cfwA3: // global
           HpAlloc = 32;
           goto cfwA0;
       cfwA0: // global
           R3 = _sfwtw::I64;
           R2 = _sfwtv::I64;
           R1 = $wlvl_rfwtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwA2: // global
           I64[Hp - 24] = sat_sfwtH_info;
           I64[Hp - 8] = _sfwtv::I64;
           I64[Hp] = _sfwtw::I64;
           I64[Sp - 8] = block_cfwzX_info;
           R3 = Hp - 24;
           R2 = lvl_rfwtn_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfwzX() //  [R1]
         { info_tbl: [(cfwzX,
                       label: block_cfwzX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwzX: // global
           R3 = R1;
           R2 = $dIP3_rfwtm_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.475588741 UTC

[section ""data" . GHC.StaticPtr.Internal.makeStatic_closure" {
     GHC.StaticPtr.Internal.makeStatic_closure:
         const GHC.StaticPtr.Internal.makeStatic_info;
         const 0;
 },
 GHC.StaticPtr.Internal.makeStatic_entry() //  [R2, R3]
         { info_tbl: [(cfwAF,
                       label: GHC.StaticPtr.Internal.makeStatic_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwAF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwAO; else goto cfwAP;
       cfwAO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.Internal.makeStatic_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwAP: // global
           I64[Sp - 8] = block_cfwAC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwAY; else goto cfwAD;
       ufwAY: // global
           call _cfwAC(R1) args: 0, res: 0, upd: 0;
       cfwAD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwAC() //  [R1]
         { info_tbl: [(cfwAC,
                       label: block_cfwAC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwAC: // global
           I64[Sp - 8] = block_cfwAI_info;
           _sfwtN::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sfwtN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwAX; else goto cfwAJ;
       ufwAX: // global
           call _cfwAI(R1) args: 0, res: 0, upd: 0;
       cfwAJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwAI() //  [R1]
         { info_tbl: [(cfwAI,
                       label: block_cfwAI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwAI: // global
           I64[Sp] = block_cfwAN_info;
           _sfwtP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sfwtP::I64;
           if (R1 & 7 != 0) goto ufwAZ; else goto cfwAS;
       ufwAZ: // global
           call _cfwAN(R1) args: 0, res: 0, upd: 0;
       cfwAS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwAN() //  [R1]
         { info_tbl: [(cfwAN,
                       label: block_cfwAN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwAN: // global
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call $wlvl_rfwtr_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.485178999 UTC

[section ""data" . $trModule1_rfwts_closure" {
     $trModule1_rfwts_closure:
         const GHC.Types.TrNameS_con_info;
         const loc_rfwqJ_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.487024575 UTC

[section ""data" . $trModule2_rfwtt_closure" {
     $trModule2_rfwtt_closure:
         const GHC.Types.TrNameS_con_info;
         const loc2_rfwtb_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.488846666 UTC

[section ""data" . GHC.StaticPtr.Internal.$trModule_closure" {
     GHC.StaticPtr.Internal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const $trModule1_rfwts_closure+1;
         const $trModule2_rfwtt_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.490839624 UTC

[section ""relreadonly" . Sfwvo_srt" {
     Sfwvo_srt:
         const lvl3_rfwtq_closure;
         const GHC.Err.error_closure;
         const $dIP3_rfwtm_closure;
         const $wlvl_rfwtr_closure;
         const GHC.StaticPtr.Internal.makeStatic_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.596384937 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:14.597617536 UTC

[section ""cstring" . loc_rfwqJ_bytes" {
     loc_rfwqJ_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.599828987 UTC

[section ""data" . loc1_rfwta_closure" {
     loc1_rfwta_closure:
         const loc1_rfwta_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_rfwta_entry() //  [R1]
         { info_tbl: [(cfwBP,
                       label: loc1_rfwta_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwBP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwBQ; else goto cfwBR;
       cfwBQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwBR: // global
           (_cfwBM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwBM::I64 == 0) goto cfwBO; else goto cfwBN;
       cfwBO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwBN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwBM::I64;
           R2 = loc_rfwqJ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.604398877 UTC

[section ""cstring" . loc2_rfwtb_bytes" {
     loc2_rfwtb_bytes:
         I8[] [71,72,67,46,83,116,97,116,105,99,80,116,114,46,73,110,116,101,114,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.606633106 UTC

[section ""data" . loc3_rfwtc_closure" {
     loc3_rfwtc_closure:
         const loc3_rfwtc_info;
         const 0;
         const 0;
         const 0;
 },
 loc3_rfwtc_entry() //  [R1]
         { info_tbl: [(cfwC7,
                       label: loc3_rfwtc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwC7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwC8; else goto cfwC9;
       cfwC8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwC9: // global
           (_cfwC4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwC4::I64 == 0) goto cfwC6; else goto cfwC5;
       cfwC6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwC5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwC4::I64;
           R2 = loc2_rfwtb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.611249192 UTC

[section ""cstring" . loc4_rfwtd_bytes" {
     loc4_rfwtd_bytes:
         I8[] [46,47,71,72,67,47,83,116,97,116,105,99,80,116,114,47,73,110,116,101,114,110,97,108,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.614178388 UTC

[section ""data" . loc5_rfwte_closure" {
     loc5_rfwte_closure:
         const loc5_rfwte_info;
         const 0;
         const 0;
         const 0;
 },
 loc5_rfwte_entry() //  [R1]
         { info_tbl: [(cfwCp,
                       label: loc5_rfwte_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwCp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwCq; else goto cfwCr;
       cfwCq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwCr: // global
           (_cfwCm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwCm::I64 == 0) goto cfwCo; else goto cfwCn;
       cfwCo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwCn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwCm::I64;
           R2 = loc4_rfwtd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.618549801 UTC

[section ""data" . loc6_rfwtf_closure" {
     loc6_rfwtf_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.620517991 UTC

[section ""data" . loc7_rfwtg_closure" {
     loc7_rfwtg_closure:
         const GHC.Types.I#_con_info;
         const 5;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.622499824 UTC

[section ""data" . loc8_rfwth_closure" {
     loc8_rfwth_closure:
         const GHC.Types.I#_con_info;
         const 27;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.624374778 UTC

[section ""data" . loc9_rfwti_closure" {
     loc9_rfwti_closure:
         const GHC.Types.I#_con_info;
         const 59;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.626295668 UTC

[section ""cstring" . $dIP_rfwtj_bytes" {
     $dIP_rfwtj_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.628549972 UTC

[section ""data" . $dIP1_rfwtk_closure" {
     $dIP1_rfwtk_closure:
         const $dIP1_rfwtk_info;
         const 0;
         const 0;
         const 0;
 },
 $dIP1_rfwtk_entry() //  [R1]
         { info_tbl: [(cfwCL,
                       label: $dIP1_rfwtk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwCL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwCM; else goto cfwCN;
       cfwCM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwCN: // global
           (_cfwCI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwCI::I64 == 0) goto cfwCK; else goto cfwCJ;
       cfwCK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwCJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwCI::I64;
           R2 = $dIP_rfwtj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.633003597 UTC

[section ""data" . $dIP2_rfwtl_closure" {
     $dIP2_rfwtl_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const loc1_rfwta_closure;
         const loc3_rfwtc_closure;
         const loc5_rfwte_closure;
         const loc6_rfwtf_closure+1;
         const loc7_rfwtg_closure+1;
         const loc8_rfwth_closure+1;
         const loc9_rfwti_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.636303074 UTC

[section ""data" . $dIP3_rfwtm_closure" {
     $dIP3_rfwtm_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const $dIP1_rfwtk_closure;
         const $dIP2_rfwtl_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.639010875 UTC

[section ""cstring" . lvl_rfwtn_bytes" {
     lvl_rfwtn_bytes:
         I8[] [71,72,67,32,98,117,103,32,45,32,109,97,107,101,83,116,97,116,105,99,58,32,85,110,114,101,115,111,108,118,101,100,32,115,116,97,116,105,99,32,102,111,114,109,32,97,116,32,108,105,110,101,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.641718141 UTC

[section ""cstring" . lvl1_rfwto_bytes" {
     lvl1_rfwto_bytes:
         I8[] [44,32,99,111,108,117,109,110,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.644344327 UTC

[section ""cstring" . lvl2_rfwtp_bytes" {
     lvl2_rfwtp_bytes:
         I8[] [46]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.648215222 UTC

[section ""data" . lvl3_rfwtq_closure" {
     lvl3_rfwtq_closure:
         const lvl3_rfwtq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rfwtq_entry() //  [R1]
         { info_tbl: [(cfwD7,
                       label: lvl3_rfwtq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwD7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwD8; else goto cfwD9;
       cfwD8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwD9: // global
           (_cfwD4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfwD4::I64 == 0) goto cfwD6; else goto cfwD5;
       cfwD6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfwD5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfwD4::I64;
           R2 = lvl2_rfwtp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.654880435 UTC

[section ""data" . $wlvl_rfwtr_closure" {
     $wlvl_rfwtr_closure:
         const $wlvl_rfwtr_info;
         const 0;
 },
 sat_sfwBv_entry() //  [R1]
         { info_tbl: [(cfwDD,
                       label: sat_sfwBv_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwDD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfwDE; else goto cfwDF;
       cfwDE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwDF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cfwDA_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfwDA() //  [R1, R2]
         { info_tbl: [(cfwDA,
                       label: block_cfwDA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwDA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfwDI; else goto cfwDH;
       cfwDI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cfwDH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl3_rfwtq_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfwBw_entry() //  [R1]
         { info_tbl: [(cfwDJ,
                       label: sat_sfwBw_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwDJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfwDN; else goto cfwDM;
       cfwDN: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwDM: // global
           _sfwBl::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_sfwBv_info;
           I64[Hp] = _sfwBl::I64;
           R3 = Hp - 16;
           R2 = lvl1_rfwto_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sfwBx_entry() //  [R1]
         { info_tbl: [(cfwDP,
                       label: sat_sfwBx_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwDP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfwDQ; else goto cfwDR;
       cfwDQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfwDR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cfwDq_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cfwDq() //  [R1, R2]
         { info_tbl: [(cfwDq,
                       label: block_cfwDq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwDq: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfwDU; else goto cfwDT;
       cfwDU: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cfwDT: // global
           I64[Hp - 40] = sat_sfwBw_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_rfwtr_entry() //  [R2, R3]
         { info_tbl: [(cfwDX,
                       label: $wlvl_rfwtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwDX: // global
           _sfwBm::I64 = R3;
           _sfwBl::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cfwDY; else goto cfwDZ;
       cfwDZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfwE1; else goto cfwE0;
       cfwE1: // global
           HpAlloc = 32;
           goto cfwDY;
       cfwDY: // global
           R3 = _sfwBm::I64;
           R2 = _sfwBl::I64;
           R1 = $wlvl_rfwtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwE0: // global
           I64[Hp - 24] = sat_sfwBx_info;
           I64[Hp - 8] = _sfwBl::I64;
           I64[Hp] = _sfwBm::I64;
           I64[Sp - 8] = block_cfwDV_info;
           R3 = Hp - 24;
           R2 = lvl_rfwtn_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfwDV() //  [R1]
         { info_tbl: [(cfwDV,
                       label: block_cfwDV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwDV: // global
           R3 = R1;
           R2 = $dIP3_rfwtm_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.670772785 UTC

[section ""data" . GHC.StaticPtr.Internal.makeStatic_closure" {
     GHC.StaticPtr.Internal.makeStatic_closure:
         const GHC.StaticPtr.Internal.makeStatic_info;
         const 0;
 },
 GHC.StaticPtr.Internal.makeStatic_entry() //  [R2, R3]
         { info_tbl: [(cfwEQ,
                       label: GHC.StaticPtr.Internal.makeStatic_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwEQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfwEZ; else goto cfwF0;
       cfwEZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.StaticPtr.Internal.makeStatic_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwF0: // global
           I64[Sp - 8] = block_cfwEN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwF9; else goto cfwEO;
       ufwF9: // global
           call _cfwEN(R1) args: 0, res: 0, upd: 0;
       cfwEO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwEN() //  [R1]
         { info_tbl: [(cfwEN,
                       label: block_cfwEN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwEN: // global
           I64[Sp - 8] = block_cfwET_info;
           _sfwBD::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sfwBD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufwF8; else goto cfwEU;
       ufwF8: // global
           call _cfwET(R1) args: 0, res: 0, upd: 0;
       cfwEU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwET() //  [R1]
         { info_tbl: [(cfwET,
                       label: block_cfwET_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwET: // global
           I64[Sp] = block_cfwEY_info;
           _sfwBF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sfwBF::I64;
           if (R1 & 7 != 0) goto ufwFa; else goto cfwF3;
       ufwFa: // global
           call _cfwEY(R1) args: 0, res: 0, upd: 0;
       cfwF3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfwEY() //  [R1]
         { info_tbl: [(cfwEY,
                       label: block_cfwEY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfwEY: // global
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call $wlvl_rfwtr_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.679723589 UTC

[section ""data" . $trModule1_rfwts_closure" {
     $trModule1_rfwts_closure:
         const GHC.Types.TrNameS_con_info;
         const loc_rfwqJ_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.681587653 UTC

[section ""data" . $trModule2_rfwtt_closure" {
     $trModule2_rfwtt_closure:
         const GHC.Types.TrNameS_con_info;
         const loc2_rfwtb_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.683383197 UTC

[section ""data" . GHC.StaticPtr.Internal.$trModule_closure" {
     GHC.StaticPtr.Internal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const $trModule1_rfwts_closure+1;
         const $trModule2_rfwtt_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:14.68531833 UTC

[section ""relreadonly" . SfwE5_srt" {
     SfwE5_srt:
         const lvl3_rfwtq_closure;
         const GHC.Err.error_closure;
         const $dIP3_rfwtm_closure;
         const $wlvl_rfwtr_closure;
         const GHC.StaticPtr.Internal.makeStatic_closure;
 }]

