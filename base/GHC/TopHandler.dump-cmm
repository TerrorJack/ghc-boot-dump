
==================== Output Cmm ====================
2018-03-16 16:09:05.413051378 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:05.413721269 UTC

[section ""cstring" . GHC.TopHandler.$trModule4_bytes" {
     GHC.TopHandler.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.414301424 UTC

[section ""data" . GHC.TopHandler.$trModule3_closure" {
     GHC.TopHandler.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.TopHandler.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.41487385 UTC

[section ""cstring" . GHC.TopHandler.$trModule2_bytes" {
     GHC.TopHandler.$trModule2_bytes:
         I8[] [71,72,67,46,84,111,112,72,97,110,100,108,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.41542459 UTC

[section ""data" . GHC.TopHandler.$trModule1_closure" {
     GHC.TopHandler.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.TopHandler.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.41596825 UTC

[section ""data" . GHC.TopHandler.$trModule_closure" {
     GHC.TopHandler.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.TopHandler.$trModule3_closure+1;
         const GHC.TopHandler.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.417392557 UTC

[section ""data" . GHC.TopHandler.runMainIO2_closure" {
     GHC.TopHandler.runMainIO2_closure:
         const GHC.TopHandler.runMainIO2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.TopHandler.runMainIO2_entry() //  [R1]
         { info_tbl: [(cdQrF,
                       label: GHC.TopHandler.runMainIO2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQrF: // global
           if ((Sp + -104) < SpLim) (likely: False) goto cdQrG; else goto cdQrH;
       cdQrG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQrH: // global
           (_cdQrs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQrs::I64 == 0) goto cdQru; else goto cdQrt;
       cdQru: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQrt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQrs::I64;
           I64[Sp - 24] = block_cdQrv_info;
           R6 = 0;
           R5 = GHC.Types.$tcIO1_closure;
           R4 = GHC.Types.$trModule_closure;
           R3 = 14006894820825784566;
           R2 = 11571292540224541508;
           P64[Sp - 40] = GHC.Types.krep$*Arr*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cdQrv() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdQrv,
                       label: block_cdQrv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQrv: // global
           I64[Sp - 40] = block_cdQrz_info;
           R6 = 0;
           _sdQmd::P64 = R5;
           R5 = GHC.Tuple.$tc()1_closure;
           _sdQmc::P64 = R4;
           R4 = GHC.Tuple.$trModule_closure;
           _sdQmb::P64 = R3;
           R3 = 14290630168515401665;
           _sdQma::I64 = R2;
           R2 = 2684808367141291271;
           P64[Sp - 56] = GHC.Types.krep$*_closure;
           P64[Sp - 48] = GHC.Types.[]_closure+1;
           I64[Sp - 32] = _sdQma::I64;
           P64[Sp - 24] = _sdQmb::P64;
           P64[Sp - 16] = _sdQmc::P64;
           P64[Sp - 8] = _sdQmd::P64;
           I64[Sp] = R1;
           Sp = Sp - 56;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cdQrz() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdQrz,
                       label: block_cdQrz_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQrz: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cdQrA() args: 0, res: 0, upd: 0;
     }
 },
 _cdQrA() //  []
         { info_tbl: [(cdQrA,
                       label: block_cdQrA_info
                       rep:StackRep [True, False, False, False, True, True, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQrA: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdQrL; else goto cdQrK;
       cdQrL: // global
           HpAlloc = 96;
           I64[Sp] = block_cdQrA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cdQrK: // global
           I64[Hp - 88] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = P64[Sp + 24];
           P64[Hp - 64] = P64[Sp + 32];
           I64[Hp - 56] = I64[Sp + 40];
           I64[Hp - 48] = I64[Sp + 8];
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 56];
           P64[Hp - 24] = P64[Sp + 64];
           P64[Hp - 16] = P64[Sp + 72];
           I64[Hp - 8] = I64[Sp + 80];
           I64[Hp] = I64[Sp + 48];
           R3 = Hp - 86;
           R2 = Hp - 38;
           Sp = Sp + 88;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.419353257 UTC

[section ""cstring" . unreachable_rdQlR_bytes" {
     unreachable_rdQlR_bytes:
         I8[] [73,102,32,121,111,117,32,99,97,110,32,114,101,97,100,32,116,104,105,115,44,32,115,104,117,116,100,111,119,110,72,97,115,107,101,108,108,65,110,100,69,120,105,116,32,100,105,100,32,110,111,116,32,101,120,105,116,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.420010934 UTC

[section ""data" . unreachable1_rdQlS_closure" {
     unreachable1_rdQlS_closure:
         const unreachable1_rdQlS_info;
         const 0;
         const 0;
         const 0;
 },
 unreachable1_rdQlS_entry() //  [R1]
         { info_tbl: [(cdQrV,
                       label: unreachable1_rdQlS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQrV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQrW; else goto cdQrX;
       cdQrW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQrX: // global
           (_cdQrS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQrS::I64 == 0) goto cdQrU; else goto cdQrT;
       cdQrU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQrT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQrS::I64;
           R2 = unreachable_rdQlR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.421038148 UTC

[section ""data" . GHC.TopHandler.flushStdHandles2_closure" {
     GHC.TopHandler.flushStdHandles2_closure:
         const GHC.TopHandler.flushStdHandles2_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles2_entry() //  []
         { info_tbl: [(cdQs2,
                       label: GHC.TopHandler.flushStdHandles2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQs2: // global
           R4 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure+2;
           R3 = GHC.IO.Handle.FD.stderr_closure;
           R2 = GHC.IO.Handle.hFlush2_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.422057017 UTC

[section ""data" . GHC.TopHandler.flushStdHandles3_closure" {
     GHC.TopHandler.flushStdHandles3_closure:
         const GHC.TopHandler.flushStdHandles3_info;
 },
 GHC.TopHandler.flushStdHandles3_entry() //  [R2]
         { info_tbl: [(cdQsc,
                       label: GHC.TopHandler.flushStdHandles3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQsc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQsd; else goto cdQse;
       cdQsd: // global
           R2 = R2;
           R1 = GHC.TopHandler.flushStdHandles3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQse: // global
           I64[Sp - 8] = block_cdQs9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQsi; else goto cdQsa;
       udQsi: // global
           call _cdQs9() args: 0, res: 0, upd: 0;
       cdQsa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQs9() //  []
         { info_tbl: [(cdQs9,
                       label: block_cdQs9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQs9: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.423185392 UTC

[section ""data" . GHC.TopHandler.flushStdHandles4_closure" {
     GHC.TopHandler.flushStdHandles4_closure:
         const GHC.TopHandler.flushStdHandles4_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles4_entry() //  []
         { info_tbl: [(cdQsn,
                       label: GHC.TopHandler.flushStdHandles4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQsn: // global
           R4 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure+2;
           R3 = GHC.IO.Handle.FD.stdout_closure;
           R2 = GHC.IO.Handle.hFlush2_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.424105367 UTC

[section ""data" . GHC.TopHandler.flushStdHandles1_closure" {
     GHC.TopHandler.flushStdHandles1_closure:
         const GHC.TopHandler.flushStdHandles1_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles1_entry() //  []
         { info_tbl: [(cdQsw,
                       label: GHC.TopHandler.flushStdHandles1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQsw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQsx; else goto cdQsy;
       cdQsx: // global
           R1 = GHC.TopHandler.flushStdHandles1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQsy: // global
           I64[Sp - 8] = block_cdQsu_info;
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles4_closure+1;
           Sp = Sp - 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQsu() //  []
         { info_tbl: [(cdQsu,
                       label: block_cdQsu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQsu: // global
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles2_closure+1;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.425193084 UTC

[section ""data" . GHC.TopHandler.flushStdHandles_closure" {
     GHC.TopHandler.flushStdHandles_closure:
         const GHC.TopHandler.flushStdHandles_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles_entry() //  []
         { info_tbl: [(cdQsE,
                       label: GHC.TopHandler.flushStdHandles_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQsE: // global
           call GHC.TopHandler.flushStdHandles1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.427669794 UTC

[section ""data" . $wexitHelper_rdQlT_closure" {
     $wexitHelper_rdQlT_closure:
         const $wexitHelper_rdQlT_info;
         const 0;
 },
 sat_sdQmF_entry() //  [R1]
         { info_tbl: [(cdQt3,
                       label: sat_sdQmF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQt3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQt4; else goto cdQt5;
       cdQt4: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQt5: // global
           I64[Sp - 8] = block_cdQt0_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQtp; else goto cdQt1;
       udQtp: // global
           call _cdQt0(R1) args: 0, res: 0, upd: 0;
       cdQt1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQt0() //  [R1]
         { info_tbl: [(cdQt0,
                       label: block_cdQt0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQt0: // global
           I64[Sp] = block_cdQtc_info;
           _cdQtb::I64 = I64[R1 + 7];
           _udQth::P64 = CurrentTSO;
           I64[I64[_udQth::P64 + 24] + 16] = Sp;
           _udQti::I64 = CurrentNursery;
           P64[_udQti::I64 + 8] = Hp + 8;
           I64[_udQth::P64 + 104] = I64[_udQth::P64 + 104] - ((Hp + 8) - I64[_udQti::I64]);
           (_udQtf::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [‘signed’,
                                     ‘signed’]  result hints:  [] shutdownHaskellAndExit(255, _cdQtb::I64);
           (_udQtg::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udQtf::I64);
           BaseReg = _udQtg::I64;
           _udQtj::P64 = CurrentTSO;
           _udQtk::P64 = I64[_udQtj::P64 + 24];
           Sp = I64[_udQtk::P64 + 16];
           SpLim = _udQtk::P64 + 192;
           HpAlloc = 0;
           _udQtl::I64 = CurrentNursery;
           _udQtm::I64 = I64[_udQtl::I64 + 8];
           Hp = _udQtm::I64 - 8;
           _udQtn::I64 = I64[_udQtl::I64];
           HpLim = _udQtn::I64 + ((%MO_SS_Conv_W32_W64(I32[_udQtl::I64 + 48]) << 12) - 1);
           I64[_udQtj::P64 + 104] = I64[_udQtj::P64 + 104] + (_udQtm::I64 - _udQtn::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdQtc() //  []
         { info_tbl: [(cdQtc,
                       label: block_cdQtc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQtc: // global
           R2 = unreachable1_rdQlS_closure;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQmQ_entry() //  [R1]
         { info_tbl: [(cdQtG,
                       label: sat_sdQmQ_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQtG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQtH; else goto cdQtI;
       cdQtH: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQtI: // global
           I64[Sp - 16] = block_cdQtD_info;
           _sdQmw::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _sdQmw::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udQu8; else goto cdQtE;
       udQu8: // global
           call _cdQtD(R1) args: 0, res: 0, upd: 0;
       cdQtE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQtD() //  [R1]
         { info_tbl: [(cdQtD,
                       label: block_cdQtD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQtD: // global
           _cdQtT::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-I64[Sp + 8]));
           I64[Sp + 8] = block_cdQtV_info;
           Sp = Sp + 8;
           _cdQtU::I64 = I64[R1 + 7];
           _udQu0::P64 = CurrentTSO;
           I64[I64[_udQu0::P64 + 24] + 16] = Sp;
           _udQu1::I64 = CurrentNursery;
           P64[_udQu1::I64 + 8] = Hp + 8;
           I64[_udQu0::P64 + 104] = I64[_udQu0::P64 + 104] - ((Hp + 8) - I64[_udQu1::I64]);
           (_udQtY::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [‘signed’,
                                     ‘signed’]  result hints:  [] shutdownHaskellAndSignal(_cdQtT::I64, _cdQtU::I64);
           (_udQtZ::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udQtY::I64);
           BaseReg = _udQtZ::I64;
           _udQu2::P64 = CurrentTSO;
           _udQu3::P64 = I64[_udQu2::P64 + 24];
           Sp = I64[_udQu3::P64 + 16];
           SpLim = _udQu3::P64 + 192;
           HpAlloc = 0;
           _udQu4::I64 = CurrentNursery;
           _udQu5::I64 = I64[_udQu4::I64 + 8];
           Hp = _udQu5::I64 - 8;
           _udQu6::I64 = I64[_udQu4::I64];
           HpLim = _udQu6::I64 + ((%MO_SS_Conv_W32_W64(I32[_udQu4::I64 + 48]) << 12) - 1);
           I64[_udQu2::P64 + 104] = I64[_udQu2::P64 + 104] + (_udQu5::I64 - _udQu6::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdQtV() //  []
         { info_tbl: [(cdQtV,
                       label: block_cdQtV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQtV: // global
           R2 = unreachable1_rdQlS_closure;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQn0_entry() //  [R1]
         { info_tbl: [(cdQup,
                       label: sat_sdQn0_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQup: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQuq; else goto cdQur;
       cdQuq: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQur: // global
           I64[Sp - 16] = block_cdQum_info;
           _sdQmw::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _sdQmw::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udQuO; else goto cdQun;
       udQuO: // global
           call _cdQum(R1) args: 0, res: 0, upd: 0;
       cdQun: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQum() //  [R1]
         { info_tbl: [(cdQum,
                       label: block_cdQum_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQum: // global
           _cdQuz::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8]));
           I64[Sp + 8] = block_cdQuB_info;
           Sp = Sp + 8;
           _cdQuA::I64 = I64[R1 + 7];
           _udQuG::P64 = CurrentTSO;
           I64[I64[_udQuG::P64 + 24] + 16] = Sp;
           _udQuH::I64 = CurrentNursery;
           P64[_udQuH::I64 + 8] = Hp + 8;
           I64[_udQuG::P64 + 104] = I64[_udQuG::P64 + 104] - ((Hp + 8) - I64[_udQuH::I64]);
           (_udQuE::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [‘signed’,
                                     ‘signed’]  result hints:  [] shutdownHaskellAndExit(_cdQuz::I64, _cdQuA::I64);
           (_udQuF::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udQuE::I64);
           BaseReg = _udQuF::I64;
           _udQuI::P64 = CurrentTSO;
           _udQuJ::P64 = I64[_udQuI::P64 + 24];
           Sp = I64[_udQuJ::P64 + 16];
           SpLim = _udQuJ::P64 + 192;
           HpAlloc = 0;
           _udQuK::I64 = CurrentNursery;
           _udQuL::I64 = I64[_udQuK::I64 + 8];
           Hp = _udQuL::I64 - 8;
           _udQuM::I64 = I64[_udQuK::I64];
           HpLim = _udQuM::I64 + ((%MO_SS_Conv_W32_W64(I32[_udQuK::I64 + 48]) << 12) - 1);
           I64[_udQuI::P64 + 104] = I64[_udQuI::P64 + 104] + (_udQuL::I64 - _udQuM::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdQuB() //  []
         { info_tbl: [(cdQuB,
                       label: block_cdQuB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQuB: // global
           R2 = unreachable1_rdQlS_closure;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $wexitHelper_rdQlT_entry() //  [R2, R3]
         { info_tbl: [(cdQuS,
                       label: $wexitHelper_rdQlT_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQuS: // global
           _sdQmw::I64 = R3;
           _sdQmv::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdQuT; else goto cdQuU;
       cdQuU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQuW; else goto cdQuV;
       cdQuW: // global
           HpAlloc = 24;
           goto cdQuT;
       cdQuT: // global
           R3 = _sdQmw::I64;
           R2 = _sdQmv::P64;
           R1 = $wexitHelper_rdQlT_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdQuV: // global
           if (%MO_S_Lt_W64(_sdQmw::I64, 0)) goto cdQva; else goto cdQuR;
       cdQuR: // global
           if (%MO_S_Gt_W64(_sdQmw::I64, 255)) goto cdQva; else goto cdQvb;
       cdQva: // global
           Hp = Hp - 24;
           P64[Sp - 16] = _sdQmv::P64;
           I64[Sp - 8] = _sdQmw::I64;
           Sp = Sp - 24;
           call _cdQsO() args: 0, res: 0, upd: 0;
       cdQvb: // global
           I64[Hp - 16] = sat_sdQn0_info;
           P64[Hp - 8] = _sdQmv::P64;
           I64[Hp] = _sdQmw::I64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdQsO() //  []
         { info_tbl: [(cdQsO,
                       label: block_cdQsO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQsO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQuZ; else goto cdQuY;
       cdQuZ: // global
           HpAlloc = 24;
           I64[Sp] = block_cdQsO_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdQuY: // global
           _sdQmw::I64 = I64[Sp + 16];
           if (%MO_S_Lt_W64(_sdQmw::I64, (-127))) goto cdQv6; else goto cdQv8;
       cdQv8: // global
           if (%MO_S_Gt_W64(_sdQmw::I64, (-1))) goto cdQv6; else goto cdQv7;
       cdQv6: // global
           Hp = Hp - 24;
           call _cdQsT() args: 0, res: 0, upd: 0;
       cdQv7: // global
           I64[Hp - 16] = sat_sdQmQ_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = _sdQmw::I64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdQsT() //  []
         { info_tbl: [(cdQsT,
                       label: block_cdQsT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQsT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQv2; else goto cdQv1;
       cdQv2: // global
           HpAlloc = 16;
           I64[Sp] = block_cdQsT_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdQv1: // global
           I64[Hp - 8] = sat_sdQmF_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.432017412 UTC

[section ""data" . safeExit1_rdQlU_closure" {
     safeExit1_rdQlU_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.432793861 UTC

[section ""data" . safeExit_rdPtY_closure" {
     safeExit_rdPtY_closure:
         const safeExit_rdPtY_info;
         const 0;
 },
 safeExit_rdPtY_entry() //  [R2]
         { info_tbl: [(cdQvm,
                       label: safeExit_rdPtY_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQvm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQvn; else goto cdQvo;
       cdQvn: // global
           R2 = R2;
           R1 = safeExit_rdPtY_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQvo: // global
           I64[Sp - 8] = block_cdQvj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQvs; else goto cdQvk;
       udQvs: // global
           call _cdQvj(R1) args: 0, res: 0, upd: 0;
       cdQvk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQvj() //  [R1]
         { info_tbl: [(cdQvj,
                       label: block_cdQvj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQvj: // global
           R3 = I64[R1 + 7];
           R2 = safeExit1_rdQlU_closure+1;
           Sp = Sp + 8;
           call $wexitHelper_rdQlT_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.434054121 UTC

[section ""data" . exitInterrupted_rdPu2_closure" {
     exitInterrupted_rdPu2_closure:
         const exitInterrupted_rdPu2_info;
         const 0;
         const 0;
         const 0;
 },
 exitInterrupted_rdPu2_entry() //  [R1]
         { info_tbl: [(cdQvz,
                       label: exitInterrupted_rdPu2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQvz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQvA; else goto cdQvB;
       cdQvA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQvB: // global
           (_cdQvw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQvw::I64 == 0) goto cdQvy; else goto cdQvx;
       cdQvy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQvx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQvw::I64;
           R3 = (-2);
           R2 = safeExit1_rdQlU_closure+1;
           Sp = Sp - 16;
           call $wexitHelper_rdQlT_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.435049357 UTC

[section ""data" . lvl_rdQlV_closure" {
     lvl_rdQlV_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.43563524 UTC

[section ""data" . lvl1_rdQlW_closure" {
     lvl1_rdQlW_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.436211274 UTC

[section ""cstring" . msgStr_rdQlX_bytes" {
     msgStr_rdQlX_bytes:
         I8[] [101,110,99,111,117,110,116,101,114,101,100,32,97,110,32,101,120,99,101,112,116,105,111,110,32,119,104,105,108,101,32,116,114,121,105,110,103,32,116,111,32,114,101,112,111,114,116,32,97,110,32,101,120,99,101,112,116,105,111,110,46,10,79,110,101,32,112,111,115,115,105,98,108,101,32,114,101,97,115,111,110,32,102,111,114,32,116,104,105,115,32,105,115,32,116,104,97,116,32,119,101,32,102,97,105,108,101,100,32,119,104,105,108,101,32,116,114,121,105,110,103,32,116,111,32,101,110,99,111,100,101,32,97,110,32,101,114,114,111,114,32,109,101,115,115,97,103,101,46,32,67,104,101,99,107,32,116,104,97,116,32,121,111,117,114,32,108,111,99,97,108,101,32,105,115,32,99,111,110,102,105,103,117,114,101,100,32,112,114,111,112,101,114,108,121,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.436977921 UTC

[section ""data" . msgStr1_rdQlY_closure" {
     msgStr1_rdQlY_closure:
         const msgStr1_rdQlY_info;
         const 0;
         const 0;
         const 0;
 },
 msgStr1_rdQlY_entry() //  [R1]
         { info_tbl: [(cdQvI,
                       label: msgStr1_rdQlY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQvI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQvJ; else goto cdQvK;
       cdQvJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQvK: // global
           (_cdQvF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQvF::I64 == 0) goto cdQvH; else goto cdQvG;
       cdQvH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQvG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQvF::I64;
           R2 = msgStr_rdQlX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.43809961 UTC

[section ""cstring" . str_rdQlZ_bytes" {
     str_rdQlZ_bytes:
         I8[] [37,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.438784658 UTC

[section ""data" . str1_rdQm0_closure" {
     str1_rdQm0_closure:
         const str1_rdQm0_info;
         const 0;
         const 0;
         const 0;
 },
 str1_rdQm0_entry() //  [R1]
         { info_tbl: [(cdQvR,
                       label: str1_rdQm0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQvR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQvS; else goto cdQvT;
       cdQvS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQvT: // global
           (_cdQvO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQvO::I64 == 0) goto cdQvQ; else goto cdQvP;
       cdQvQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQvP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQvO::I64;
           R2 = str_rdQlZ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.44000688 UTC

[section ""data" . lvl2_rdQm1_closure" {
     lvl2_rdQm1_closure:
         const lvl2_rdQm1_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdQm1_entry() //  [R1]
         { info_tbl: [(cdQw2,
                       label: lvl2_rdQm1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQw2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQw6; else goto cdQw7;
       cdQw6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQw7: // global
           (_cdQvX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQvX::I64 == 0) goto cdQvZ; else goto cdQvY;
       cdQvZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQvY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQvX::I64;
           I64[Sp - 24] = block_cdQw0_info;
           R3 = 0;
           R2 = msgStr1_rdQlY_closure;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdQw0() //  [R1]
         { info_tbl: [(cdQw0,
                       label: block_cdQw0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQw0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQwa; else goto cdQw9;
       cdQwa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cdQw9: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.441385183 UTC

[section ""data" . lvl3_rdQm2_closure" {
     lvl3_rdQm2_closure:
         const lvl3_rdQm2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdQm2_entry() //  [R1]
         { info_tbl: [(cdQwj,
                       label: lvl3_rdQm2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQwj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQwn; else goto cdQwo;
       cdQwn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQwo: // global
           (_cdQwe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQwe::I64 == 0) goto cdQwg; else goto cdQwf;
       cdQwg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQwf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQwe::I64;
           I64[Sp - 24] = block_cdQwh_info;
           R3 = 0;
           R2 = str1_rdQm0_closure;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdQwh() //  [R1]
         { info_tbl: [(cdQwh,
                       label: block_cdQwh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQwh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQwr; else goto cdQwq;
       cdQwr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cdQwq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.442505995 UTC

[section ""data" . lvl4_rdQm3_closure" {
     lvl4_rdQm3_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.443096606 UTC

[section ""data" . lvl5_rdQm4_closure" {
     lvl5_rdQm4_closure:
         const GHC.Types.I#_con_info;
         const 251;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.44998535 UTC

[section ""data" . real_handler_rdQm5_closure" {
     real_handler_rdQm5_closure:
         const real_handler_rdQm5_info;
         const 0;
 },
 sat_sdQq4_entry() //  [R1, R2]
         { info_tbl: [(cdQx0,
                       label: sat_sdQq4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQx0: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdQx4; else goto cdQx5;
       cdQx4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQx5: // global
           I64[Sp - 16] = block_cdQwX_info;
           _sdQn6::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sdQn6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udQzh; else goto cdQwY;
       udQzh: // global
           call _cdQwX(R1) args: 0, res: 0, upd: 0;
       cdQwY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQwX() //  [R1]
         { info_tbl: [(cdQwX,
                       label: block_cdQwX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQwX: // global
           I64[Sp - 8] = block_cdQx3_info;
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQx3() //  [R1]
         { info_tbl: [(cdQx3,
                       label: block_cdQx3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQx3: // global
           I64[Sp] = block_cdQxa_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQxa() //  [R1]
         { info_tbl: [(cdQxa,
                       label: block_cdQxa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQxa: // global
           if (R1 & 7 == 1) goto cdQxh; else goto cdQxm;
       cdQxh: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdQxm: // global
           I64[Sp + 8] = block_cdQxk_info;
           R1 = lvl3_rdQm2_closure;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udQzi; else goto cdQxn;
       udQzi: // global
           call _cdQxk(R1) args: 0, res: 0, upd: 0;
       cdQxn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQxk() //  [R1]
         { info_tbl: [(cdQxk,
                       label: block_cdQxk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQxk: // global
           I64[Sp] = block_cdQxv_info;
           R2 = 1;
           R1 = I64[R1 + 7] + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQxv() //  [R1]
         { info_tbl: [(cdQxv,
                       label: block_cdQxv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQxv: // global
           P64[Sp - 24] = R1 + 16;
           P64[Sp - 16] = str1_rdQm0_closure;
           I64[Sp - 8] = 0;
           P64[Sp] = R1;
           Sp = Sp - 24;
           call _cdQyy() args: 0, res: 0, upd: 0;
     }
 },
 _cdQyy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQyy: // global
           I64[Sp - 8] = block_cdQyB_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQzo; else goto cdQyD;
       udQzo: // global
           call _cdQyB(R1) args: 0, res: 0, upd: 0;
       cdQyD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQyB() //  [R1]
         { info_tbl: [(cdQyB,
                       label: block_cdQyB_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQyB: // global
           if (R1 & 7 == 1) goto cdQyJ; else goto cdQyO;
       cdQyJ: // global
           I8[I64[Sp + 8] + I64[Sp + 24]] = 0 :: W8;
           I64[Sp] = block_cdQxG_info;
           R1 = lvl2_rdQm1_closure;
           if (R1 & 7 != 0) goto udQzp; else goto cdQxI;
       udQzp: // global
           call _cdQxG(R1) args: 0, res: 0, upd: 0;
       cdQxI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdQyO: // global
           I64[Sp] = block_cdQyM_info;
           _sdQpX::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdQpX::P64;
           if (R1 & 7 != 0) goto udQzq; else goto cdQyP;
       udQzq: // global
           call _cdQyM(R1) args: 0, res: 0, upd: 0;
       cdQyP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQxG() //  [R1]
         { info_tbl: [(cdQxG,
                       label: block_cdQxG_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQxG: // global
           I64[Sp] = block_cdQxQ_info;
           R2 = 1;
           R1 = I64[R1 + 7] + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQxQ() //  [R1]
         { info_tbl: [(cdQxQ,
                       label: block_cdQxQ_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQxQ: // global
           I64[Sp - 8] = 0;
           P64[Sp] = msgStr1_rdQlY_closure;
           P64[Sp + 16] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call _cdQya() args: 0, res: 0, upd: 0;
     }
 },
 _cdQya() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQya: // global
           I64[Sp - 8] = block_cdQyd_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQzl; else goto cdQyf;
       udQzl: // global
           call _cdQyd(R1) args: 0, res: 0, upd: 0;
       cdQyf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQyd() //  [R1]
         { info_tbl: [(cdQyd,
                       label: block_cdQyd_info
                       rep:StackRep [True, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQyd: // global
           if (R1 & 7 == 1) goto cdQyl; else goto cdQyq;
       cdQyl: // global
           _sdQn6::P64 = P64[Sp + 56];
           _sdQpd::I64 = I64[Sp + 24];
           _sdQpr::I64 = I64[Sp + 32];
           I8[_sdQpr::I64 + I64[Sp + 8]] = 0 :: W8;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] errorBelch2(_sdQpd::I64, _sdQpr::I64);
           I64[Sp + 32] = block_cdQy4_info;
           R2 = lvl_rdQlV_closure+1;
           R1 = _sdQn6::P64;
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       cdQyq: // global
           I64[Sp] = block_cdQyo_info;
           _sdQpK::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdQpK::P64;
           if (R1 & 7 != 0) goto udQzm; else goto cdQyr;
       udQzm: // global
           call _cdQyo(R1) args: 0, res: 0, upd: 0;
       cdQyr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQy4() //  [R1]
         { info_tbl: [(cdQy4,
                       label: block_cdQy4_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQy4: // global
           _sdQpc::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_sdQpc::P64);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdQyo() //  [R1]
         { info_tbl: [(cdQyo,
                       label: block_cdQyo_info
                       rep:StackRep [True, False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQyo: // global
           _sdQpG::I64 = I64[Sp + 8];
           _sdQpK::P64 = P64[Sp + 16];
           I8[I64[Sp + 32] + _sdQpG::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 16] = _sdQpK::P64;
           I64[Sp + 8] = _sdQpG::I64 + 1;
           Sp = Sp + 8;
           call _cdQya() args: 0, res: 0, upd: 0;
     }
 },
 _cdQyM() //  [R1]
         { info_tbl: [(cdQyM,
                       label: block_cdQyM_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQyM: // global
           _sdQpT::I64 = I64[Sp + 24];
           _sdQpX::P64 = P64[Sp + 16];
           I8[I64[Sp + 8] + _sdQpT::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 16] = _sdQpX::P64;
           I64[Sp + 24] = _sdQpT::I64 + 1;
           Sp = Sp + 8;
           call _cdQyy() args: 0, res: 0, upd: 0;
     }
 },
 sat_sdQnx_entry() //  [R1]
         { info_tbl: [(cdQzM,
                       label: sat_sdQnx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQzM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQzQ; else goto cdQzR;
       cdQzQ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQzR: // global
           I64[Sp - 24] = block_cdQzJ_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udQzV; else goto cdQzK;
       udQzV: // global
           call _cdQzJ(R1) args: 0, res: 0, upd: 0;
       cdQzK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQzJ() //  [R1]
         { info_tbl: [(cdQzJ,
                       label: block_cdQzJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQzJ: // global
           _sdQnt::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdQzP_info;
           R2 = P64[Sp + 16];
           R1 = _sdQnt::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQzP() //  []
         { info_tbl: [(cdQzP,
                       label: block_cdQzP_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQzP: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQnP_entry() //  [R1]
         { info_tbl: [(cdQAf,
                       label: sat_sdQnP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQAf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQAj; else goto cdQAk;
       cdQAj: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQAk: // global
           I64[Sp - 24] = block_cdQAc_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udQAo; else goto cdQAd;
       udQAo: // global
           call _cdQAc(R1) args: 0, res: 0, upd: 0;
       cdQAd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQAc() //  [R1]
         { info_tbl: [(cdQAc,
                       label: block_cdQAc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQAc: // global
           _sdQnL::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdQAi_info;
           R2 = P64[Sp + 16];
           R1 = _sdQnL::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQAi() //  []
         { info_tbl: [(cdQAi,
                       label: block_cdQAi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQAi: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQo0_entry() //  [R1]
         { info_tbl: [(cdQAE,
                       label: sat_sdQo0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQAE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQAI; else goto cdQAJ;
       cdQAI: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQAJ: // global
           I64[Sp - 24] = block_cdQAB_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udQAN; else goto cdQAC;
       udQAN: // global
           call _cdQAB(R1) args: 0, res: 0, upd: 0;
       cdQAC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQAB() //  [R1]
         { info_tbl: [(cdQAB,
                       label: block_cdQAB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQAB: // global
           _sdQnW::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdQAH_info;
           R2 = P64[Sp + 16];
           R1 = _sdQnW::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQAH() //  []
         { info_tbl: [(cdQAH,
                       label: block_cdQAH_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQAH: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQoc_entry() //  [R1]
         { info_tbl: [(cdQB3,
                       label: sat_sdQoc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQB3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQB7; else goto cdQB8;
       cdQB7: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQB8: // global
           I64[Sp - 24] = block_cdQB0_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udQBc; else goto cdQB1;
       udQBc: // global
           call _cdQB0(R1) args: 0, res: 0, upd: 0;
       cdQB1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQB0() //  [R1]
         { info_tbl: [(cdQB0,
                       label: block_cdQB0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQB0: // global
           _sdQo8::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdQB6_info;
           R2 = P64[Sp + 16];
           R1 = _sdQo8::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQB6() //  []
         { info_tbl: [(cdQB6,
                       label: block_cdQB6_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQB6: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQoq_entry() //  [R1]
         { info_tbl: [(cdQBu,
                       label: sat_sdQoq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQBu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQBy; else goto cdQBz;
       cdQBy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQBz: // global
           I64[Sp - 24] = block_cdQBr_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udQBD; else goto cdQBs;
       udQBD: // global
           call _cdQBr(R1) args: 0, res: 0, upd: 0;
       cdQBs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQBr() //  [R1]
         { info_tbl: [(cdQBr,
                       label: block_cdQBr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQBr: // global
           _sdQom::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdQBx_info;
           R2 = P64[Sp + 16];
           R1 = _sdQom::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQBx() //  []
         { info_tbl: [(cdQBx,
                       label: block_cdQBx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQBx: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQoB_entry() //  [R1]
         { info_tbl: [(cdQBS,
                       label: sat_sdQoB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQBS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQBW; else goto cdQBX;
       cdQBW: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQBX: // global
           I64[Sp - 24] = block_cdQBP_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udQC1; else goto cdQBQ;
       udQC1: // global
           call _cdQBP(R1) args: 0, res: 0, upd: 0;
       cdQBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQBP() //  [R1]
         { info_tbl: [(cdQBP,
                       label: block_cdQBP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQBP: // global
           _sdQox::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdQBV_info;
           R2 = P64[Sp + 16];
           R1 = _sdQox::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQBV() //  []
         { info_tbl: [(cdQBV,
                       label: block_cdQBV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQBV: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQoW_entry() //  [R1]
         { info_tbl: [(cdQC2,
                       label: sat_sdQoW_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQC2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdQC3; else goto cdQC4;
       cdQC3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQC4: // global
           I64[Sp - 32] = block_cdQzw_info;
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 16];
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 40];
           Sp = Sp - 32;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQzw() //  [R1]
         { info_tbl: [(cdQzw,
                       label: block_cdQzw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQzw: // global
           I64[Sp] = block_cdQzA_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQzA() //  [R1]
         { info_tbl: [(cdQzA,
                       label: block_cdQzA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQzA: // global
           if (R1 & 7 == 1) goto cdQC7; else goto cdQCc;
       cdQC7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQCa; else goto cdQC9;
       cdQCa: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQC9: // global
           I64[Hp - 16] = sat_sdQnx_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdQCc: // global
           I64[Sp] = block_cdQzY_info;
           R1 = P64[Sp + 24];
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQzY() //  [R1]
         { info_tbl: [(cdQzY,
                       label: block_cdQzY_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQzY: // global
           I64[Sp - 8] = block_cdQA2_info;
           _sdQnz::P64 = P64[R1 + 7];
           _sdQnD::P64 = P64[R1 + 39];
           R1 = P64[R1 + 15];
           P64[Sp] = _sdQnD::P64;
           P64[Sp + 24] = _sdQnz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQDV; else goto cdQA3;
       udQDV: // global
           call _cdQA2(R1) args: 0, res: 0, upd: 0;
       cdQA3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQA2() //  [R1]
         { info_tbl: [(cdQA2,
                       label: block_cdQA2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQA2: // global
           if (I32[I64[R1 - 1] + 20] == 17 :: W32) goto cdQCk; else goto cdQCf;
       cdQCk: // global
           _sdQnD::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdQAr_info;
           R1 = _sdQnD::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udQDW; else goto cdQAs;
       udQDW: // global
           call _cdQAr(R1) args: 0, res: 0, upd: 0;
       cdQAs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdQCf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQCi; else goto cdQCh;
       cdQCi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQCh: // global
           I64[Hp - 16] = sat_sdQnP_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdQAr() //  [R1]
         { info_tbl: [(cdQAr,
                       label: block_cdQAr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQAr: // global
           if (R1 & 7 == 1) goto cdQCm; else goto cdQCr;
       cdQCm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQCp; else goto cdQCo;
       cdQCp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQCo: // global
           I64[Hp - 16] = sat_sdQo0_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdQCr: // global
           I64[Sp] = block_cdQAQ_info;
           _sdQo1::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sdQo1::P64;
           if (R1 & 7 != 0) goto udQDX; else goto cdQAR;
       udQDX: // global
           call _cdQAQ(R1) args: 0, res: 0, upd: 0;
       cdQAR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQAQ() //  [R1]
         { info_tbl: [(cdQAQ,
                       label: block_cdQAQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQAQ: // global
           if (R1 & 7 == 1) goto cdQCt; else goto cdQCy;
       cdQCt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQCw; else goto cdQCv;
       cdQCw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQCv: // global
           I64[Hp - 16] = sat_sdQoc_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdQCy: // global
           I64[Sp] = block_cdQBf_info;
           _sdQod::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sdQod::P64;
           if (R1 & 7 != 0) goto udQDY; else goto cdQBg;
       udQDY: // global
           call _cdQBf(R1) args: 0, res: 0, upd: 0;
       cdQBg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQBf() //  [R1]
         { info_tbl: [(cdQBf,
                       label: block_cdQBf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQBf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQCB; else goto cdQCA;
       cdQCB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQCA: // global
           if (I64[R1 + 7] == 32) goto cdQCI; else goto cdQCD;
       cdQCI: // global
           Hp = Hp - 24;
           I64[Sp] = block_cdQCE_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto udQDZ; else goto cdQCJ;
       udQDZ: // global
           call _cdQCE(R1) args: 0, res: 0, upd: 0;
       cdQCJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdQCD: // global
           I64[Hp - 16] = sat_sdQoq_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdQCE() //  [R1]
         { info_tbl: [(cdQCE,
                       label: block_cdQCE_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQCE: // global
           if (R1 & 7 == 1) goto cdQCQ; else goto cdQDl;
       cdQCQ: // global
           I64[Sp] = block_cdQCN_info;
           _sdQoE::P64 = P64[R1 + 15];
           R1 = GHC.IO.Handle.FD.stdout_closure;
           P64[Sp + 24] = _sdQoE::P64;
           if (R1 & 7 != 0) goto udQE0; else goto cdQCR;
       udQE0: // global
           call _cdQCN(R1) args: 0, res: 0, upd: 0;
       cdQCR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdQDl: // global
           I64[Sp] = block_cdQDj_info;
           _sdQoN::P64 = P64[R1 + 14];
           R1 = GHC.IO.Handle.FD.stdout_closure;
           P64[Sp + 24] = _sdQoN::P64;
           if (R1 & 7 != 0) goto udQE1; else goto cdQDm;
       udQE1: // global
           call _cdQDj(R1) args: 0, res: 0, upd: 0;
       cdQDm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQCN() //  [R1]
         { info_tbl: [(cdQCN,
                       label: block_cdQCN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQCN: // global
           if (R1 & 7 != 1) goto udQE3; else goto cdQDc;
       cdQDc: // global
           if (P64[Sp + 24] != P64[R1 + 15]) goto udQE3; else goto udQDU;
       udQE3: // global
           call _cdQBI() args: 0, res: 0, upd: 0;
       udQDU: // global
           Sp = Sp + 8;
           call _cdQDH() args: 0, res: 0, upd: 0;
     }
 },
 _cdQDj() //  [R1]
         { info_tbl: [(cdQDj,
                       label: block_cdQDj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQDj: // global
           if (R1 & 7 == 1) goto udQE6; else goto cdQDL;
       cdQDL: // global
           if (P64[Sp + 24] != P64[R1 + 14]) goto udQE6; else goto udQDT;
       udQE6: // global
           call _cdQBI() args: 0, res: 0, upd: 0;
       udQDT: // global
           Sp = Sp + 8;
           call _cdQDH() args: 0, res: 0, upd: 0;
     }
 },
 _cdQDH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQDH: // global
           R2 = lvl1_rdQlW_closure+1;
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdQBI() //  []
         { info_tbl: [(cdQBI,
                       label: block_cdQBI_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQBI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQCH; else goto cdQCG;
       cdQCH: // global
           HpAlloc = 24;
           I64[Sp] = block_cdQBI_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdQCG: // global
           I64[Hp - 16] = sat_sdQoB_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 real_handler_rdQm5_entry() //  [R2, R3]
         { info_tbl: [(cdQEe,
                       label: real_handler_rdQm5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQEe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdQEf; else goto cdQEg;
       cdQEf: // global
           R3 = R3;
           R2 = R2;
           R1 = real_handler_rdQm5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdQEg: // global
           I64[Sp - 24] = block_cdQww_info;
           _sdQn6::P64 = R2;
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles4_closure+1;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQww() //  []
         { info_tbl: [(cdQww,
                       label: block_cdQww_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQww: // global
           I64[Sp] = block_cdQwy_info;
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles2_closure+1;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQwy() //  []
         { info_tbl: [(cdQwy,
                       label: block_cdQwy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQwy: // global
           I64[Sp] = block_cdQE8_info;
           R2 = P64[Sp + 16];
           call GHC.IO.Exception.$fExceptionAsyncException_$cfromException_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQE8() //  [R1]
         { info_tbl: [(cdQE8,
                       label: block_cdQE8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQE8: // global
           if (R1 & 7 == 1) goto udQFe; else goto cdQEc;
       udQFe: // global
           Sp = Sp + 8;
           call _sdQnf() args: 0, res: 0, upd: 0;
       cdQEc: // global
           I64[Sp] = block_cdQEL_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto udQFg; else goto cdQEN;
       udQFg: // global
           call _cdQEL(R1) args: 0, res: 0, upd: 0;
       cdQEN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQEL() //  [R1]
         { info_tbl: [(cdQEL,
                       label: block_cdQEL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQEL: // global
           _cdQF6::P64 = R1 & 7;
           if (_cdQF6::P64 < 3) goto udQFc; else goto udQFd;
       udQFc: // global
           _sdQn6::P64 = P64[Sp + 8];
           if (_cdQF6::P64 < 2) goto cdQET; else goto cdQEX;
       cdQET: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] reportStackOverflow(CurrentTSO);
           R2 = lvl4_rdQm3_closure+1;
           R1 = _sdQn6::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdQEX: // global
           call "ccall" arg hints:  []  result hints:  [] reportHeapOverflow();
           R2 = lvl5_rdQm4_closure+1;
           R1 = _sdQn6::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       udQFd: // global
           if (_cdQF6::P64 < 4) goto udQFf; else goto cdQF5;
       udQFf: // global
           Sp = Sp + 8;
           call _sdQnf() args: 0, res: 0, upd: 0;
       cdQF5: // global
           R1 = exitInterrupted_rdPu2_closure;
           Sp = Sp + 24;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _sdQnf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sdQnf: // global
           I64[Sp - 8] = block_cdQwF_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQFj; else goto cdQwG;
       udQFj: // global
           call _cdQwF(R1) args: 0, res: 0, upd: 0;
       cdQwG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQwF() //  [R1]
         { info_tbl: [(cdQwF,
                       label: block_cdQwF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQwF: // global
           I64[Sp - 16] = block_cdQwK_info;
           _sdQni::P64 = P64[R1 + 7];
           R2 = _sdQni::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _sdQni::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQwK() //  [R1]
         { info_tbl: [(cdQwK,
                       label: block_cdQwK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQwK: // global
           I64[Sp] = block_cdQwO_info;
           R3 = GHC.IO.Exception.$fExceptionExitCode4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQwO() //  [R1]
         { info_tbl: [(cdQwO,
                       label: block_cdQwO_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQwO: // global
           _sdQnj::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdQEn; else goto cdQEv;
       cdQEn: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdQEq; else goto cdQEp;
       cdQEq: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQEp: // global
           I64[Hp - 56] = sat_sdQq4_info;
           _sdQn6::P64 = P64[Sp + 24];
           P64[Hp - 48] = _sdQn6::P64;
           I64[Hp - 40] = sat_sdQoW_info;
           P64[Hp - 24] = _sdQn6::P64;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdQnj::P64;
           R2 = Hp - 54;
           R1 = Hp - 40;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
       cdQEv: // global
           I64[Sp + 16] = block_cdQEt_info;
           R1 = _sdQnj::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQEt() //  [R1]
         { info_tbl: [(cdQEt,
                       label: block_cdQEt_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQEt: // global
           _sdQn6::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdQEB; else goto cdQEF;
       cdQEB: // global
           R2 = lvl1_rdQlW_closure+1;
           R1 = _sdQn6::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdQEF: // global
           R2 = P64[R1 + 6];
           R1 = _sdQn6::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.463701954 UTC

[section ""data" . GHC.TopHandler.runIO2_closure" {
     GHC.TopHandler.runIO2_closure:
         const GHC.TopHandler.runIO2_info;
         const 0;
 },
 GHC.TopHandler.runIO2_entry() //  [R2]
         { info_tbl: [(cdQFo,
                       label: GHC.TopHandler.runIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQFo: // global
           R2 = R2;
           call GHC.TopHandler.runIO3_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.TopHandler.runIO3_closure" {
     GHC.TopHandler.runIO3_closure:
         const GHC.TopHandler.runIO3_info;
         const 0;
 },
 sat_sdQqn_entry() //  [R1]
         { info_tbl: [(cdQFA,
                       label: sat_sdQqn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQFA: // global
           R3 = P64[R1 + 7];
           R2 = safeExit_rdPtY_closure+1;
           call real_handler_rdQm5_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runIO3_entry() //  [R2]
         { info_tbl: [(cdQFD,
                       label: GHC.TopHandler.runIO3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQFD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQFH; else goto cdQFG;
       cdQFH: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.TopHandler.runIO3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQFG: // global
           I64[Hp - 8] = sat_sdQqn_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.46511574 UTC

[section ""data" . GHC.TopHandler.topHandler_closure" {
     GHC.TopHandler.topHandler_closure:
         const GHC.TopHandler.topHandler_info;
         const 0;
 },
 GHC.TopHandler.topHandler_entry() //  [R2]
         { info_tbl: [(cdQFM,
                       label: GHC.TopHandler.topHandler_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQFM: // global
           R2 = R2;
           call GHC.TopHandler.runIO3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.466326117 UTC

[section ""data" . GHC.TopHandler.runNonIO1_closure" {
     GHC.TopHandler.runNonIO1_closure:
         const GHC.TopHandler.runNonIO1_info;
         const 0;
 },
 sat_sdQqs_entry() //  [R1]
         { info_tbl: [(cdQG4,
                       label: sat_sdQqs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQG4: // global
           R1 = P64[R1 + 7];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQqt_entry() //  [R1]
         { info_tbl: [(cdQG7,
                       label: sat_sdQqt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQG7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQG8; else goto cdQG9;
       cdQG8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQG9: // global
           I64[Sp - 8] = block_cdQFX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQFX() //  [R1]
         { info_tbl: [(cdQFX,
                       label: block_cdQFX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQFX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQGc; else goto cdQGb;
       cdQGc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQGb: // global
           I64[Hp - 8] = sat_sdQqs_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runNonIO1_entry() //  [R2]
         { info_tbl: [(cdQGd,
                       label: GHC.TopHandler.runNonIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQGd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQGh; else goto cdQGg;
       cdQGh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.TopHandler.runNonIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQGg: // global
           I64[Hp - 16] = sat_sdQqt_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.467896619 UTC

[section ""data" . GHC.TopHandler.runNonIO_closure" {
     GHC.TopHandler.runNonIO_closure:
         const GHC.TopHandler.runNonIO_info;
         const 0;
 },
 GHC.TopHandler.runNonIO_entry() //  [R2]
         { info_tbl: [(cdQGm,
                       label: GHC.TopHandler.runNonIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQGm: // global
           R2 = R2;
           call GHC.TopHandler.runNonIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.468720551 UTC

[section ""data" . GHC.TopHandler.runIO1_closure" {
     GHC.TopHandler.runIO1_closure:
         const GHC.TopHandler.runIO1_info;
         const 0;
 },
 GHC.TopHandler.runIO1_entry() //  [R2]
         { info_tbl: [(cdQGt,
                       label: GHC.TopHandler.runIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQGt: // global
           _sdQqu::P64 = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = _sdQqu::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.469938989 UTC

[section ""data" . GHC.TopHandler.runIO_closure" {
     GHC.TopHandler.runIO_closure:
         const GHC.TopHandler.runIO_info;
         const 0;
 },
 GHC.TopHandler.runIO_entry() //  [R2]
         { info_tbl: [(cdQGA,
                       label: GHC.TopHandler.runIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQGA: // global
           R2 = R2;
           call GHC.TopHandler.runIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.470734854 UTC

[section ""data" . fastExit1_rdQm6_closure" {
     fastExit1_rdQm6_closure:
         const GHC.Int.I32#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.471513287 UTC

[section ""data" . fastExit_rdPtZ_closure" {
     fastExit_rdPtZ_closure:
         const fastExit_rdPtZ_info;
         const 0;
 },
 fastExit_rdPtZ_entry() //  [R2]
         { info_tbl: [(cdQGK,
                       label: fastExit_rdPtZ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQGK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQGL; else goto cdQGM;
       cdQGL: // global
           R2 = R2;
           R1 = fastExit_rdPtZ_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQGM: // global
           I64[Sp - 8] = block_cdQGH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQGQ; else goto cdQGI;
       udQGQ: // global
           call _cdQGH(R1) args: 0, res: 0, upd: 0;
       cdQGI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQGH() //  [R1]
         { info_tbl: [(cdQGH,
                       label: block_cdQGH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQGH: // global
           R3 = I64[R1 + 7];
           R2 = fastExit1_rdQm6_closure+1;
           Sp = Sp + 8;
           call $wexitHelper_rdQlT_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.473015731 UTC

[section ""data" . GHC.TopHandler.runIOFastExit2_closure" {
     GHC.TopHandler.runIOFastExit2_closure:
         const GHC.TopHandler.runIOFastExit2_info;
         const 0;
 },
 GHC.TopHandler.runIOFastExit2_entry() //  [R2]
         { info_tbl: [(cdQGV,
                       label: GHC.TopHandler.runIOFastExit2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQGV: // global
           R2 = R2;
           call GHC.TopHandler.runIOFastExit3_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.TopHandler.runIOFastExit3_closure" {
     GHC.TopHandler.runIOFastExit3_closure:
         const GHC.TopHandler.runIOFastExit3_info;
         const 0;
 },
 sat_sdQqD_entry() //  [R1]
         { info_tbl: [(cdQH7,
                       label: sat_sdQqD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQH7: // global
           R3 = P64[R1 + 7];
           R2 = fastExit_rdPtZ_closure+1;
           call real_handler_rdQm5_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runIOFastExit3_entry() //  [R2]
         { info_tbl: [(cdQHa,
                       label: GHC.TopHandler.runIOFastExit3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQHa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQHe; else goto cdQHd;
       cdQHe: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.TopHandler.runIOFastExit3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQHd: // global
           I64[Hp - 8] = sat_sdQqD_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIOFastExit2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.474500764 UTC

[section ""data" . GHC.TopHandler.topHandlerFastExit_closure" {
     GHC.TopHandler.topHandlerFastExit_closure:
         const GHC.TopHandler.topHandlerFastExit_info;
         const 0;
 },
 GHC.TopHandler.topHandlerFastExit_entry() //  [R2]
         { info_tbl: [(cdQHj,
                       label: GHC.TopHandler.topHandlerFastExit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQHj: // global
           R2 = R2;
           call GHC.TopHandler.runIOFastExit3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.475420285 UTC

[section ""data" . GHC.TopHandler.runIOFastExit1_closure" {
     GHC.TopHandler.runIOFastExit1_closure:
         const GHC.TopHandler.runIOFastExit1_info;
         const 0;
 },
 GHC.TopHandler.runIOFastExit1_entry() //  [R2]
         { info_tbl: [(cdQHq,
                       label: GHC.TopHandler.runIOFastExit1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQHq: // global
           _sdQqE::P64 = R2;
           R2 = GHC.TopHandler.runIOFastExit2_closure+2;
           R1 = _sdQqE::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.478730933 UTC

[section ""data" . GHC.TopHandler.runIOFastExit_closure" {
     GHC.TopHandler.runIOFastExit_closure:
         const GHC.TopHandler.runIOFastExit_info;
         const 0;
 },
 GHC.TopHandler.runIOFastExit_entry() //  [R2]
         { info_tbl: [(cdQHx,
                       label: GHC.TopHandler.runIOFastExit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQHx: // global
           R2 = R2;
           call GHC.TopHandler.runIOFastExit1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.47963991 UTC

[section ""data" . GHC.TopHandler.runMainIO3_closure" {
     GHC.TopHandler.runMainIO3_closure:
         const GHC.TopHandler.runMainIO3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.TopHandler.runMainIO3_entry() //  [R1]
         { info_tbl: [(cdQHG,
                       label: GHC.TopHandler.runMainIO3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQHG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQHH; else goto cdQHI;
       cdQHH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQHI: // global
           (_cdQHD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQHD::I64 == 0) goto cdQHF; else goto cdQHE;
       cdQHF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQHE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQHD::I64;
           R2 = GHC.IO.Exception.UserInterrupt_closure+4;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.480907338 UTC

[section ""data" . GHC.TopHandler.runMainIO4_closure" {
     GHC.TopHandler.runMainIO4_closure:
         const GHC.Int.I32#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.482909179 UTC

[section ""data" . GHC.TopHandler.runMainIO1_closure" {
     GHC.TopHandler.runMainIO1_closure:
         const GHC.TopHandler.runMainIO1_info;
         const 0;
 },
 sat_sdQrd_entry() //  [R1]
         { info_tbl: [(cdQIa,
                       label: sat_sdQrd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQIa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQIb; else goto cdQIc;
       cdQIb: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQIc: // global
           I64[Sp - 8] = block_cdQI2_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_deRefWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQI2() //  [R1, R2]
         { info_tbl: [(cdQI2,
                       label: block_cdQI2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQI2: // global
           if (R1 == 0) goto udQIo; else goto cdQI8;
       udQIo: // global
           call _cdQI9() args: 0, res: 0, upd: 0;
       cdQI8: // global
           I64[Sp] = block_cdQIf_info;
           R1 = R2;
           if (R1 & 7 != 0) goto udQIp; else goto cdQIg;
       udQIp: // global
           call _cdQIf(R1) args: 0, res: 0, upd: 0;
       cdQIg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQIf() //  [R1]
         { info_tbl: [(cdQIf,
                       label: block_cdQIf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQIf: // global
           I64[Sp] = block_cdQI9_info;
           R2 = GHC.TopHandler.runMainIO3_closure;
           R1 = P64[R1 + 7];
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQI9() //  []
         { info_tbl: [(cdQI9,
                       label: block_cdQI9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQI9: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQr3_entry() //  [R1, R2]
         { info_tbl: [(cdQIE,
                       label: sat_sdQr3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQIE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQIF; else goto cdQIG;
       cdQIF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQIG: // global
           I64[Sp - 8] = block_cdQIw_info;
           R1 = P64[R1 + 6];
           Sp = Sp - 8;
           call stg_deRefWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQIw() //  [R1, R2]
         { info_tbl: [(cdQIw,
                       label: block_cdQIw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQIw: // global
           if (R1 == 0) goto udQIS; else goto cdQIC;
       udQIS: // global
           call _cdQID() args: 0, res: 0, upd: 0;
       cdQIC: // global
           I64[Sp] = block_cdQIJ_info;
           R1 = R2;
           if (R1 & 7 != 0) goto udQIT; else goto cdQIK;
       udQIT: // global
           call _cdQIJ(R1) args: 0, res: 0, upd: 0;
       cdQIK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQIJ() //  [R1]
         { info_tbl: [(cdQIJ,
                       label: block_cdQIJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQIJ: // global
           I64[Sp] = block_cdQID_info;
           R2 = GHC.TopHandler.runMainIO3_closure;
           R1 = P64[R1 + 7];
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQID() //  []
         { info_tbl: [(cdQID,
                       label: block_cdQID_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQID: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQro_entry() //  [R1]
         { info_tbl: [(cdQJ2,
                       label: sat_sdQro_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQJ2: // global
           _sdQro::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdQJ3; else goto cdQJ4;
       cdQJ4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQJ6; else goto cdQJ5;
       cdQJ6: // global
           HpAlloc = 16;
           goto cdQJ3;
       cdQJ3: // global
           R1 = _sdQro::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQJ5: // global
           _sdQqG::P64 = P64[_sdQro::P64 + 7];
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           _sdQqL::P64 = CurrentTSO;
           P64[Hp] = _sdQqL::P64;
           I64[Sp - 16] = block_cdQHT_info;
           R2 = Hp - 7;
           R1 = _sdQqL::P64;
           P64[Sp - 8] = _sdQqG::P64;
           Sp = Sp - 16;
           call stg_mkWeakNoFinalizer#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQHT() //  [R1]
         { info_tbl: [(cdQHT,
                       label: block_cdQHT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQHT: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdQJ9; else goto cdQJ8;
       cdQJ9: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQJ8: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] rts_setMainThread(R1);
           I64[Hp - 88] = sat_sdQrd_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = Data.Dynamic.Dynamic_con_info;
           P64[Hp - 64] = GHC.TopHandler.runMainIO2_closure;
           P64[Hp - 56] = Hp - 87;
           I64[Hp - 48] = sat_sdQr3_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 46;
           P64[Hp - 16] = Hp - 71;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cdQIW_info;
           R3 = Hp - 6;
           R2 = GHC.TopHandler.runMainIO4_closure+1;
           call GHC.Conc.Signal.setHandler1_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQIW() //  []
         { info_tbl: [(cdQIW,
                       label: block_cdQIW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQIW: // global
           _sdQqG::P64 = P64[Sp + 8];
           (_sdQrn::I64) = call "ccall" arg hints:  [‘signed’, ‘signed’,
                                                     PtrHint]  result hints:  [‘signed’] stg_sig_install(2, (-5), 0);
           R1 = _sdQqG::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runMainIO1_entry() //  [R2]
         { info_tbl: [(cdQJb,
                       label: GHC.TopHandler.runMainIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQJb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQJf; else goto cdQJe;
       cdQJf: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.TopHandler.runMainIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQJe: // global
           I64[Hp - 8] = sat_sdQro_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.486248309 UTC

[section ""data" . GHC.TopHandler.runMainIO_closure" {
     GHC.TopHandler.runMainIO_closure:
         const GHC.TopHandler.runMainIO_info;
         const 0;
 },
 GHC.TopHandler.runMainIO_entry() //  [R2]
         { info_tbl: [(cdQJk,
                       label: GHC.TopHandler.runMainIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQJk: // global
           R2 = R2;
           call GHC.TopHandler.runMainIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.487041783 UTC

[section ""relreadonly" . SdQrO_srt" {
     SdQrO_srt:
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const GHC.IO.Handle.FD.stderr_closure;
         const GHC.IO.Handle.hFlush2_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.TopHandler.flushStdHandles1_closure;
         const GHC.TopHandler.flushStdHandles2_closure;
         const GHC.TopHandler.flushStdHandles4_closure;
         const GHC.IO.failIO1_closure;
         const unreachable1_rdQlS_closure;
         const $wexitHelper_rdQlT_closure;
         const safeExit_rdPtY_closure;
         const msgStr1_rdQlY_closure;
         const str1_rdQm0_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const lvl2_rdQm1_closure;
         const lvl3_rdQm2_closure;
         const GHC.Conc.Sync.uncaughtExceptionHandler_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionExitCode4_closure;
         const exitInterrupted_rdPu2_closure;
         const real_handler_rdQm5_closure;
         const GHC.TopHandler.runIO3_closure;
         const GHC.TopHandler.runIO2_closure;
         const GHC.TopHandler.runNonIO1_closure;
         const GHC.TopHandler.runIO1_closure;
         const fastExit_rdPtZ_closure;
         const GHC.TopHandler.runIOFastExit3_closure;
         const GHC.TopHandler.runIOFastExit2_closure;
         const GHC.TopHandler.runIOFastExit1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
         const GHC.TopHandler.runMainIO3_closure;
         const GHC.Conc.Signal.setHandler1_closure;
         const GHC.TopHandler.runMainIO2_closure;
         const GHC.TopHandler.runMainIO1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.487814789 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:05.488349316 UTC

[section ""cstring" . GHC.TopHandler.$trModule4_bytes" {
     GHC.TopHandler.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.488901853 UTC

[section ""data" . GHC.TopHandler.$trModule3_closure" {
     GHC.TopHandler.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.TopHandler.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.489795455 UTC

[section ""cstring" . GHC.TopHandler.$trModule2_bytes" {
     GHC.TopHandler.$trModule2_bytes:
         I8[] [71,72,67,46,84,111,112,72,97,110,100,108,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.490303198 UTC

[section ""data" . GHC.TopHandler.$trModule1_closure" {
     GHC.TopHandler.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.TopHandler.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.490838182 UTC

[section ""data" . GHC.TopHandler.$trModule_closure" {
     GHC.TopHandler.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.TopHandler.$trModule3_closure+1;
         const GHC.TopHandler.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.492168478 UTC

[section ""data" . GHC.TopHandler.runMainIO2_closure" {
     GHC.TopHandler.runMainIO2_closure:
         const GHC.TopHandler.runMainIO2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.TopHandler.runMainIO2_entry() //  [R1]
         { info_tbl: [(cdQJD,
                       label: GHC.TopHandler.runMainIO2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQJD: // global
           if ((Sp + -104) < SpLim) (likely: False) goto cdQJE; else goto cdQJF;
       cdQJE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQJF: // global
           (_cdQJq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQJq::I64 == 0) goto cdQJs; else goto cdQJr;
       cdQJs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQJr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQJq::I64;
           I64[Sp - 24] = block_cdQJt_info;
           R6 = 0;
           R5 = GHC.Types.$tcIO1_closure;
           R4 = GHC.Types.$trModule_closure;
           R3 = 14006894820825784566;
           R2 = 11571292540224541508;
           P64[Sp - 40] = GHC.Types.krep$*Arr*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cdQJt() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdQJt,
                       label: block_cdQJt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQJt: // global
           I64[Sp - 40] = block_cdQJx_info;
           R6 = 0;
           _sdQmd::P64 = R5;
           R5 = GHC.Tuple.$tc()1_closure;
           _sdQmc::P64 = R4;
           R4 = GHC.Tuple.$trModule_closure;
           _sdQmb::P64 = R3;
           R3 = 14290630168515401665;
           _sdQma::I64 = R2;
           R2 = 2684808367141291271;
           P64[Sp - 56] = GHC.Types.krep$*_closure;
           P64[Sp - 48] = GHC.Types.[]_closure+1;
           I64[Sp - 32] = _sdQma::I64;
           P64[Sp - 24] = _sdQmb::P64;
           P64[Sp - 16] = _sdQmc::P64;
           P64[Sp - 8] = _sdQmd::P64;
           I64[Sp] = R1;
           Sp = Sp - 56;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cdQJx() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdQJx,
                       label: block_cdQJx_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQJx: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cdQJy() args: 0, res: 0, upd: 0;
     }
 },
 _cdQJy() //  []
         { info_tbl: [(cdQJy,
                       label: block_cdQJy_info
                       rep:StackRep [True, False, False, False, True, True, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQJy: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdQJJ; else goto cdQJI;
       cdQJJ: // global
           HpAlloc = 96;
           I64[Sp] = block_cdQJy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cdQJI: // global
           I64[Hp - 88] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = P64[Sp + 24];
           P64[Hp - 64] = P64[Sp + 32];
           I64[Hp - 56] = I64[Sp + 40];
           I64[Hp - 48] = I64[Sp + 8];
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 56];
           P64[Hp - 24] = P64[Sp + 64];
           P64[Hp - 16] = P64[Sp + 72];
           I64[Hp - 8] = I64[Sp + 80];
           I64[Hp] = I64[Sp + 48];
           R3 = Hp - 86;
           R2 = Hp - 38;
           Sp = Sp + 88;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.494162811 UTC

[section ""cstring" . unreachable_rdQlR_bytes" {
     unreachable_rdQlR_bytes:
         I8[] [73,102,32,121,111,117,32,99,97,110,32,114,101,97,100,32,116,104,105,115,44,32,115,104,117,116,100,111,119,110,72,97,115,107,101,108,108,65,110,100,69,120,105,116,32,100,105,100,32,110,111,116,32,101,120,105,116,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.494956761 UTC

[section ""data" . unreachable1_rdQlS_closure" {
     unreachable1_rdQlS_closure:
         const unreachable1_rdQlS_info;
         const 0;
         const 0;
         const 0;
 },
 unreachable1_rdQlS_entry() //  [R1]
         { info_tbl: [(cdQJS,
                       label: unreachable1_rdQlS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQJS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQJT; else goto cdQJU;
       cdQJT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQJU: // global
           (_cdQJP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQJP::I64 == 0) goto cdQJR; else goto cdQJQ;
       cdQJR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQJQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQJP::I64;
           R2 = unreachable_rdQlR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.49605309 UTC

[section ""data" . GHC.TopHandler.flushStdHandles2_closure" {
     GHC.TopHandler.flushStdHandles2_closure:
         const GHC.TopHandler.flushStdHandles2_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles2_entry() //  []
         { info_tbl: [(cdQJZ,
                       label: GHC.TopHandler.flushStdHandles2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQJZ: // global
           R4 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure+2;
           R3 = GHC.IO.Handle.FD.stderr_closure;
           R2 = GHC.IO.Handle.hFlush2_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.497027584 UTC

[section ""data" . GHC.TopHandler.flushStdHandles3_closure" {
     GHC.TopHandler.flushStdHandles3_closure:
         const GHC.TopHandler.flushStdHandles3_info;
 },
 GHC.TopHandler.flushStdHandles3_entry() //  [R2]
         { info_tbl: [(cdQK9,
                       label: GHC.TopHandler.flushStdHandles3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQK9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQKa; else goto cdQKb;
       cdQKa: // global
           R2 = R2;
           R1 = GHC.TopHandler.flushStdHandles3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQKb: // global
           I64[Sp - 8] = block_cdQK6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQKf; else goto cdQK7;
       udQKf: // global
           call _cdQK6() args: 0, res: 0, upd: 0;
       cdQK7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQK6() //  []
         { info_tbl: [(cdQK6,
                       label: block_cdQK6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQK6: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.498149607 UTC

[section ""data" . GHC.TopHandler.flushStdHandles4_closure" {
     GHC.TopHandler.flushStdHandles4_closure:
         const GHC.TopHandler.flushStdHandles4_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles4_entry() //  []
         { info_tbl: [(cdQKk,
                       label: GHC.TopHandler.flushStdHandles4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQKk: // global
           R4 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure+2;
           R3 = GHC.IO.Handle.FD.stdout_closure;
           R2 = GHC.IO.Handle.hFlush2_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.499075149 UTC

[section ""data" . GHC.TopHandler.flushStdHandles1_closure" {
     GHC.TopHandler.flushStdHandles1_closure:
         const GHC.TopHandler.flushStdHandles1_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles1_entry() //  []
         { info_tbl: [(cdQKt,
                       label: GHC.TopHandler.flushStdHandles1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQKt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQKu; else goto cdQKv;
       cdQKu: // global
           R1 = GHC.TopHandler.flushStdHandles1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQKv: // global
           I64[Sp - 8] = block_cdQKr_info;
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles4_closure+1;
           Sp = Sp - 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQKr() //  []
         { info_tbl: [(cdQKr,
                       label: block_cdQKr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQKr: // global
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles2_closure+1;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.50009916 UTC

[section ""data" . GHC.TopHandler.flushStdHandles_closure" {
     GHC.TopHandler.flushStdHandles_closure:
         const GHC.TopHandler.flushStdHandles_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles_entry() //  []
         { info_tbl: [(cdQKB,
                       label: GHC.TopHandler.flushStdHandles_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQKB: // global
           call GHC.TopHandler.flushStdHandles1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.502806171 UTC

[section ""data" . $wexitHelper_rdQlT_closure" {
     $wexitHelper_rdQlT_closure:
         const $wexitHelper_rdQlT_info;
         const 0;
 },
 sat_sdQmF_entry() //  [R1]
         { info_tbl: [(cdQL0,
                       label: sat_sdQmF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQL0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQL1; else goto cdQL2;
       cdQL1: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQL2: // global
           I64[Sp - 8] = block_cdQKX_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQLm; else goto cdQKY;
       udQLm: // global
           call _cdQKX(R1) args: 0, res: 0, upd: 0;
       cdQKY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQKX() //  [R1]
         { info_tbl: [(cdQKX,
                       label: block_cdQKX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQKX: // global
           I64[Sp] = block_cdQL9_info;
           _cdQL8::I64 = I64[R1 + 7];
           _udQLe::P64 = CurrentTSO;
           I64[I64[_udQLe::P64 + 24] + 16] = Sp;
           _udQLf::I64 = CurrentNursery;
           P64[_udQLf::I64 + 8] = Hp + 8;
           I64[_udQLe::P64 + 104] = I64[_udQLe::P64 + 104] - ((Hp + 8) - I64[_udQLf::I64]);
           (_udQLc::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [‘signed’,
                                     ‘signed’]  result hints:  [] shutdownHaskellAndExit(255, _cdQL8::I64);
           (_udQLd::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udQLc::I64);
           BaseReg = _udQLd::I64;
           _udQLg::P64 = CurrentTSO;
           _udQLh::P64 = I64[_udQLg::P64 + 24];
           Sp = I64[_udQLh::P64 + 16];
           SpLim = _udQLh::P64 + 192;
           HpAlloc = 0;
           _udQLi::I64 = CurrentNursery;
           _udQLj::I64 = I64[_udQLi::I64 + 8];
           Hp = _udQLj::I64 - 8;
           _udQLk::I64 = I64[_udQLi::I64];
           HpLim = _udQLk::I64 + ((%MO_SS_Conv_W32_W64(I32[_udQLi::I64 + 48]) << 12) - 1);
           I64[_udQLg::P64 + 104] = I64[_udQLg::P64 + 104] + (_udQLj::I64 - _udQLk::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdQL9() //  []
         { info_tbl: [(cdQL9,
                       label: block_cdQL9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQL9: // global
           R2 = unreachable1_rdQlS_closure;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQmQ_entry() //  [R1]
         { info_tbl: [(cdQLD,
                       label: sat_sdQmQ_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQLD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQLE; else goto cdQLF;
       cdQLE: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQLF: // global
           I64[Sp - 16] = block_cdQLA_info;
           _sdQmw::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _sdQmw::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udQM5; else goto cdQLB;
       udQM5: // global
           call _cdQLA(R1) args: 0, res: 0, upd: 0;
       cdQLB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQLA() //  [R1]
         { info_tbl: [(cdQLA,
                       label: block_cdQLA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQLA: // global
           _cdQLQ::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-I64[Sp + 8]));
           I64[Sp + 8] = block_cdQLS_info;
           Sp = Sp + 8;
           _cdQLR::I64 = I64[R1 + 7];
           _udQLX::P64 = CurrentTSO;
           I64[I64[_udQLX::P64 + 24] + 16] = Sp;
           _udQLY::I64 = CurrentNursery;
           P64[_udQLY::I64 + 8] = Hp + 8;
           I64[_udQLX::P64 + 104] = I64[_udQLX::P64 + 104] - ((Hp + 8) - I64[_udQLY::I64]);
           (_udQLV::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [‘signed’,
                                     ‘signed’]  result hints:  [] shutdownHaskellAndSignal(_cdQLQ::I64, _cdQLR::I64);
           (_udQLW::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udQLV::I64);
           BaseReg = _udQLW::I64;
           _udQLZ::P64 = CurrentTSO;
           _udQM0::P64 = I64[_udQLZ::P64 + 24];
           Sp = I64[_udQM0::P64 + 16];
           SpLim = _udQM0::P64 + 192;
           HpAlloc = 0;
           _udQM1::I64 = CurrentNursery;
           _udQM2::I64 = I64[_udQM1::I64 + 8];
           Hp = _udQM2::I64 - 8;
           _udQM3::I64 = I64[_udQM1::I64];
           HpLim = _udQM3::I64 + ((%MO_SS_Conv_W32_W64(I32[_udQM1::I64 + 48]) << 12) - 1);
           I64[_udQLZ::P64 + 104] = I64[_udQLZ::P64 + 104] + (_udQM2::I64 - _udQM3::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdQLS() //  []
         { info_tbl: [(cdQLS,
                       label: block_cdQLS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQLS: // global
           R2 = unreachable1_rdQlS_closure;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQn0_entry() //  [R1]
         { info_tbl: [(cdQMm,
                       label: sat_sdQn0_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQMm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQMn; else goto cdQMo;
       cdQMn: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQMo: // global
           I64[Sp - 16] = block_cdQMj_info;
           _sdQmw::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _sdQmw::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udQML; else goto cdQMk;
       udQML: // global
           call _cdQMj(R1) args: 0, res: 0, upd: 0;
       cdQMk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQMj() //  [R1]
         { info_tbl: [(cdQMj,
                       label: block_cdQMj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQMj: // global
           _cdQMw::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8]));
           I64[Sp + 8] = block_cdQMy_info;
           Sp = Sp + 8;
           _cdQMx::I64 = I64[R1 + 7];
           _udQMD::P64 = CurrentTSO;
           I64[I64[_udQMD::P64 + 24] + 16] = Sp;
           _udQME::I64 = CurrentNursery;
           P64[_udQME::I64 + 8] = Hp + 8;
           I64[_udQMD::P64 + 104] = I64[_udQMD::P64 + 104] - ((Hp + 8) - I64[_udQME::I64]);
           (_udQMB::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [‘signed’,
                                     ‘signed’]  result hints:  [] shutdownHaskellAndExit(_cdQMw::I64, _cdQMx::I64);
           (_udQMC::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udQMB::I64);
           BaseReg = _udQMC::I64;
           _udQMF::P64 = CurrentTSO;
           _udQMG::P64 = I64[_udQMF::P64 + 24];
           Sp = I64[_udQMG::P64 + 16];
           SpLim = _udQMG::P64 + 192;
           HpAlloc = 0;
           _udQMH::I64 = CurrentNursery;
           _udQMI::I64 = I64[_udQMH::I64 + 8];
           Hp = _udQMI::I64 - 8;
           _udQMJ::I64 = I64[_udQMH::I64];
           HpLim = _udQMJ::I64 + ((%MO_SS_Conv_W32_W64(I32[_udQMH::I64 + 48]) << 12) - 1);
           I64[_udQMF::P64 + 104] = I64[_udQMF::P64 + 104] + (_udQMI::I64 - _udQMJ::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdQMy() //  []
         { info_tbl: [(cdQMy,
                       label: block_cdQMy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQMy: // global
           R2 = unreachable1_rdQlS_closure;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $wexitHelper_rdQlT_entry() //  [R2, R3]
         { info_tbl: [(cdQMP,
                       label: $wexitHelper_rdQlT_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQMP: // global
           _sdQmw::I64 = R3;
           _sdQmv::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdQMQ; else goto cdQMR;
       cdQMR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQMT; else goto cdQMS;
       cdQMT: // global
           HpAlloc = 24;
           goto cdQMQ;
       cdQMQ: // global
           R3 = _sdQmw::I64;
           R2 = _sdQmv::P64;
           R1 = $wexitHelper_rdQlT_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdQMS: // global
           if (%MO_S_Lt_W64(_sdQmw::I64, 0)) goto cdQN7; else goto cdQMO;
       cdQMO: // global
           if (%MO_S_Gt_W64(_sdQmw::I64, 255)) goto cdQN7; else goto cdQN8;
       cdQN7: // global
           Hp = Hp - 24;
           P64[Sp - 16] = _sdQmv::P64;
           I64[Sp - 8] = _sdQmw::I64;
           Sp = Sp - 24;
           call _cdQKL() args: 0, res: 0, upd: 0;
       cdQN8: // global
           I64[Hp - 16] = sat_sdQn0_info;
           P64[Hp - 8] = _sdQmv::P64;
           I64[Hp] = _sdQmw::I64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdQKL() //  []
         { info_tbl: [(cdQKL,
                       label: block_cdQKL_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQKL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQMW; else goto cdQMV;
       cdQMW: // global
           HpAlloc = 24;
           I64[Sp] = block_cdQKL_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdQMV: // global
           _sdQmw::I64 = I64[Sp + 16];
           if (%MO_S_Lt_W64(_sdQmw::I64, (-127))) goto cdQN3; else goto cdQN5;
       cdQN5: // global
           if (%MO_S_Gt_W64(_sdQmw::I64, (-1))) goto cdQN3; else goto cdQN4;
       cdQN3: // global
           Hp = Hp - 24;
           call _cdQKQ() args: 0, res: 0, upd: 0;
       cdQN4: // global
           I64[Hp - 16] = sat_sdQmQ_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = _sdQmw::I64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdQKQ() //  []
         { info_tbl: [(cdQKQ,
                       label: block_cdQKQ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQKQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQMZ; else goto cdQMY;
       cdQMZ: // global
           HpAlloc = 16;
           I64[Sp] = block_cdQKQ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdQMY: // global
           I64[Hp - 8] = sat_sdQmF_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.507210825 UTC

[section ""data" . safeExit1_rdQlU_closure" {
     safeExit1_rdQlU_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.508019984 UTC

[section ""data" . safeExit_rdPtY_closure" {
     safeExit_rdPtY_closure:
         const safeExit_rdPtY_info;
         const 0;
 },
 safeExit_rdPtY_entry() //  [R2]
         { info_tbl: [(cdQNj,
                       label: safeExit_rdPtY_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQNj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQNk; else goto cdQNl;
       cdQNk: // global
           R2 = R2;
           R1 = safeExit_rdPtY_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQNl: // global
           I64[Sp - 8] = block_cdQNg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQNp; else goto cdQNh;
       udQNp: // global
           call _cdQNg(R1) args: 0, res: 0, upd: 0;
       cdQNh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQNg() //  [R1]
         { info_tbl: [(cdQNg,
                       label: block_cdQNg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQNg: // global
           R3 = I64[R1 + 7];
           R2 = safeExit1_rdQlU_closure+1;
           Sp = Sp + 8;
           call $wexitHelper_rdQlT_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.509150574 UTC

[section ""data" . exitInterrupted_rdPu2_closure" {
     exitInterrupted_rdPu2_closure:
         const exitInterrupted_rdPu2_info;
         const 0;
         const 0;
         const 0;
 },
 exitInterrupted_rdPu2_entry() //  [R1]
         { info_tbl: [(cdQNw,
                       label: exitInterrupted_rdPu2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQNw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQNx; else goto cdQNy;
       cdQNx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQNy: // global
           (_cdQNt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQNt::I64 == 0) goto cdQNv; else goto cdQNu;
       cdQNv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQNu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQNt::I64;
           R3 = (-2);
           R2 = safeExit1_rdQlU_closure+1;
           Sp = Sp - 16;
           call $wexitHelper_rdQlT_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.510091484 UTC

[section ""data" . lvl_rdQlV_closure" {
     lvl_rdQlV_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.510654731 UTC

[section ""data" . lvl1_rdQlW_closure" {
     lvl1_rdQlW_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.511243118 UTC

[section ""cstring" . msgStr_rdQlX_bytes" {
     msgStr_rdQlX_bytes:
         I8[] [101,110,99,111,117,110,116,101,114,101,100,32,97,110,32,101,120,99,101,112,116,105,111,110,32,119,104,105,108,101,32,116,114,121,105,110,103,32,116,111,32,114,101,112,111,114,116,32,97,110,32,101,120,99,101,112,116,105,111,110,46,10,79,110,101,32,112,111,115,115,105,98,108,101,32,114,101,97,115,111,110,32,102,111,114,32,116,104,105,115,32,105,115,32,116,104,97,116,32,119,101,32,102,97,105,108,101,100,32,119,104,105,108,101,32,116,114,121,105,110,103,32,116,111,32,101,110,99,111,100,101,32,97,110,32,101,114,114,111,114,32,109,101,115,115,97,103,101,46,32,67,104,101,99,107,32,116,104,97,116,32,121,111,117,114,32,108,111,99,97,108,101,32,105,115,32,99,111,110,102,105,103,117,114,101,100,32,112,114,111,112,101,114,108,121,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.512008867 UTC

[section ""data" . msgStr1_rdQlY_closure" {
     msgStr1_rdQlY_closure:
         const msgStr1_rdQlY_info;
         const 0;
         const 0;
         const 0;
 },
 msgStr1_rdQlY_entry() //  [R1]
         { info_tbl: [(cdQNF,
                       label: msgStr1_rdQlY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQNF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQNG; else goto cdQNH;
       cdQNG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQNH: // global
           (_cdQNC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQNC::I64 == 0) goto cdQNE; else goto cdQND;
       cdQNE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQND: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQNC::I64;
           R2 = msgStr_rdQlX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.512903515 UTC

[section ""cstring" . str_rdQlZ_bytes" {
     str_rdQlZ_bytes:
         I8[] [37,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.513879612 UTC

[section ""data" . str1_rdQm0_closure" {
     str1_rdQm0_closure:
         const str1_rdQm0_info;
         const 0;
         const 0;
         const 0;
 },
 str1_rdQm0_entry() //  [R1]
         { info_tbl: [(cdQNO,
                       label: str1_rdQm0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQNO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQNP; else goto cdQNQ;
       cdQNP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQNQ: // global
           (_cdQNL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQNL::I64 == 0) goto cdQNN; else goto cdQNM;
       cdQNN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQNM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQNL::I64;
           R2 = str_rdQlZ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.515063781 UTC

[section ""data" . lvl2_rdQm1_closure" {
     lvl2_rdQm1_closure:
         const lvl2_rdQm1_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdQm1_entry() //  [R1]
         { info_tbl: [(cdQNZ,
                       label: lvl2_rdQm1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQNZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQO3; else goto cdQO4;
       cdQO3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQO4: // global
           (_cdQNU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQNU::I64 == 0) goto cdQNW; else goto cdQNV;
       cdQNW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQNV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQNU::I64;
           I64[Sp - 24] = block_cdQNX_info;
           R3 = 0;
           R2 = msgStr1_rdQlY_closure;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdQNX() //  [R1]
         { info_tbl: [(cdQNX,
                       label: block_cdQNX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQNX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQO7; else goto cdQO6;
       cdQO7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cdQO6: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.516487176 UTC

[section ""data" . lvl3_rdQm2_closure" {
     lvl3_rdQm2_closure:
         const lvl3_rdQm2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdQm2_entry() //  [R1]
         { info_tbl: [(cdQOg,
                       label: lvl3_rdQm2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQOg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQOk; else goto cdQOl;
       cdQOk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQOl: // global
           (_cdQOb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQOb::I64 == 0) goto cdQOd; else goto cdQOc;
       cdQOd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQOc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQOb::I64;
           I64[Sp - 24] = block_cdQOe_info;
           R3 = 0;
           R2 = str1_rdQm0_closure;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdQOe() //  [R1]
         { info_tbl: [(cdQOe,
                       label: block_cdQOe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQOe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQOo; else goto cdQOn;
       cdQOo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cdQOn: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.517652805 UTC

[section ""data" . lvl4_rdQm3_closure" {
     lvl4_rdQm3_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.51821772 UTC

[section ""data" . lvl5_rdQm4_closure" {
     lvl5_rdQm4_closure:
         const GHC.Types.I#_con_info;
         const 251;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.524808235 UTC

[section ""data" . real_handler_rdQm5_closure" {
     real_handler_rdQm5_closure:
         const real_handler_rdQm5_info;
         const 0;
 },
 sat_sdQq4_entry() //  [R1, R2]
         { info_tbl: [(cdQOX,
                       label: sat_sdQq4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQOX: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdQP1; else goto cdQP2;
       cdQP1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQP2: // global
           I64[Sp - 16] = block_cdQOU_info;
           _sdQn6::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sdQn6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udQRe; else goto cdQOV;
       udQRe: // global
           call _cdQOU(R1) args: 0, res: 0, upd: 0;
       cdQOV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQOU() //  [R1]
         { info_tbl: [(cdQOU,
                       label: block_cdQOU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQOU: // global
           I64[Sp - 8] = block_cdQP0_info;
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQP0() //  [R1]
         { info_tbl: [(cdQP0,
                       label: block_cdQP0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQP0: // global
           I64[Sp] = block_cdQP7_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQP7() //  [R1]
         { info_tbl: [(cdQP7,
                       label: block_cdQP7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQP7: // global
           if (R1 & 7 == 1) goto cdQPe; else goto cdQPj;
       cdQPe: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdQPj: // global
           I64[Sp + 8] = block_cdQPh_info;
           R1 = lvl3_rdQm2_closure;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udQRf; else goto cdQPk;
       udQRf: // global
           call _cdQPh(R1) args: 0, res: 0, upd: 0;
       cdQPk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQPh() //  [R1]
         { info_tbl: [(cdQPh,
                       label: block_cdQPh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQPh: // global
           I64[Sp] = block_cdQPs_info;
           R2 = 1;
           R1 = I64[R1 + 7] + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQPs() //  [R1]
         { info_tbl: [(cdQPs,
                       label: block_cdQPs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQPs: // global
           P64[Sp - 24] = R1 + 16;
           P64[Sp - 16] = str1_rdQm0_closure;
           I64[Sp - 8] = 0;
           P64[Sp] = R1;
           Sp = Sp - 24;
           call _cdQQv() args: 0, res: 0, upd: 0;
     }
 },
 _cdQQv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQQv: // global
           I64[Sp - 8] = block_cdQQy_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQRl; else goto cdQQA;
       udQRl: // global
           call _cdQQy(R1) args: 0, res: 0, upd: 0;
       cdQQA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQQy() //  [R1]
         { info_tbl: [(cdQQy,
                       label: block_cdQQy_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQQy: // global
           if (R1 & 7 == 1) goto cdQQG; else goto cdQQL;
       cdQQG: // global
           I8[I64[Sp + 8] + I64[Sp + 24]] = 0 :: W8;
           I64[Sp] = block_cdQPD_info;
           R1 = lvl2_rdQm1_closure;
           if (R1 & 7 != 0) goto udQRm; else goto cdQPF;
       udQRm: // global
           call _cdQPD(R1) args: 0, res: 0, upd: 0;
       cdQPF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdQQL: // global
           I64[Sp] = block_cdQQJ_info;
           _sdQpX::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdQpX::P64;
           if (R1 & 7 != 0) goto udQRn; else goto cdQQM;
       udQRn: // global
           call _cdQQJ(R1) args: 0, res: 0, upd: 0;
       cdQQM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQPD() //  [R1]
         { info_tbl: [(cdQPD,
                       label: block_cdQPD_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQPD: // global
           I64[Sp] = block_cdQPN_info;
           R2 = 1;
           R1 = I64[R1 + 7] + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQPN() //  [R1]
         { info_tbl: [(cdQPN,
                       label: block_cdQPN_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQPN: // global
           I64[Sp - 8] = 0;
           P64[Sp] = msgStr1_rdQlY_closure;
           P64[Sp + 16] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call _cdQQ7() args: 0, res: 0, upd: 0;
     }
 },
 _cdQQ7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQQ7: // global
           I64[Sp - 8] = block_cdQQa_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQRi; else goto cdQQc;
       udQRi: // global
           call _cdQQa(R1) args: 0, res: 0, upd: 0;
       cdQQc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQQa() //  [R1]
         { info_tbl: [(cdQQa,
                       label: block_cdQQa_info
                       rep:StackRep [True, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQQa: // global
           if (R1 & 7 == 1) goto cdQQi; else goto cdQQn;
       cdQQi: // global
           _sdQn6::P64 = P64[Sp + 56];
           _sdQpd::I64 = I64[Sp + 24];
           _sdQpr::I64 = I64[Sp + 32];
           I8[_sdQpr::I64 + I64[Sp + 8]] = 0 :: W8;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] errorBelch2(_sdQpd::I64, _sdQpr::I64);
           I64[Sp + 32] = block_cdQQ1_info;
           R2 = lvl_rdQlV_closure+1;
           R1 = _sdQn6::P64;
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       cdQQn: // global
           I64[Sp] = block_cdQQl_info;
           _sdQpK::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdQpK::P64;
           if (R1 & 7 != 0) goto udQRj; else goto cdQQo;
       udQRj: // global
           call _cdQQl(R1) args: 0, res: 0, upd: 0;
       cdQQo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQQ1() //  [R1]
         { info_tbl: [(cdQQ1,
                       label: block_cdQQ1_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQQ1: // global
           _sdQpc::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_sdQpc::P64);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdQQl() //  [R1]
         { info_tbl: [(cdQQl,
                       label: block_cdQQl_info
                       rep:StackRep [True, False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQQl: // global
           _sdQpG::I64 = I64[Sp + 8];
           _sdQpK::P64 = P64[Sp + 16];
           I8[I64[Sp + 32] + _sdQpG::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 16] = _sdQpK::P64;
           I64[Sp + 8] = _sdQpG::I64 + 1;
           Sp = Sp + 8;
           call _cdQQ7() args: 0, res: 0, upd: 0;
     }
 },
 _cdQQJ() //  [R1]
         { info_tbl: [(cdQQJ,
                       label: block_cdQQJ_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQQJ: // global
           _sdQpT::I64 = I64[Sp + 24];
           _sdQpX::P64 = P64[Sp + 16];
           I8[I64[Sp + 8] + _sdQpT::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 16] = _sdQpX::P64;
           I64[Sp + 24] = _sdQpT::I64 + 1;
           Sp = Sp + 8;
           call _cdQQv() args: 0, res: 0, upd: 0;
     }
 },
 sat_sdQnx_entry() //  [R1]
         { info_tbl: [(cdQRJ,
                       label: sat_sdQnx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQRJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQRN; else goto cdQRO;
       cdQRN: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQRO: // global
           I64[Sp - 24] = block_cdQRG_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udQRS; else goto cdQRH;
       udQRS: // global
           call _cdQRG(R1) args: 0, res: 0, upd: 0;
       cdQRH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQRG() //  [R1]
         { info_tbl: [(cdQRG,
                       label: block_cdQRG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQRG: // global
           _sdQnt::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdQRM_info;
           R2 = P64[Sp + 16];
           R1 = _sdQnt::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQRM() //  []
         { info_tbl: [(cdQRM,
                       label: block_cdQRM_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQRM: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQnP_entry() //  [R1]
         { info_tbl: [(cdQSc,
                       label: sat_sdQnP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQSc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQSg; else goto cdQSh;
       cdQSg: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQSh: // global
           I64[Sp - 24] = block_cdQS9_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udQSl; else goto cdQSa;
       udQSl: // global
           call _cdQS9(R1) args: 0, res: 0, upd: 0;
       cdQSa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQS9() //  [R1]
         { info_tbl: [(cdQS9,
                       label: block_cdQS9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQS9: // global
           _sdQnL::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdQSf_info;
           R2 = P64[Sp + 16];
           R1 = _sdQnL::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQSf() //  []
         { info_tbl: [(cdQSf,
                       label: block_cdQSf_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQSf: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQo0_entry() //  [R1]
         { info_tbl: [(cdQSB,
                       label: sat_sdQo0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQSB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQSF; else goto cdQSG;
       cdQSF: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQSG: // global
           I64[Sp - 24] = block_cdQSy_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udQSK; else goto cdQSz;
       udQSK: // global
           call _cdQSy(R1) args: 0, res: 0, upd: 0;
       cdQSz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQSy() //  [R1]
         { info_tbl: [(cdQSy,
                       label: block_cdQSy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQSy: // global
           _sdQnW::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdQSE_info;
           R2 = P64[Sp + 16];
           R1 = _sdQnW::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQSE() //  []
         { info_tbl: [(cdQSE,
                       label: block_cdQSE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQSE: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQoc_entry() //  [R1]
         { info_tbl: [(cdQT0,
                       label: sat_sdQoc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQT0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQT4; else goto cdQT5;
       cdQT4: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQT5: // global
           I64[Sp - 24] = block_cdQSX_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udQT9; else goto cdQSY;
       udQT9: // global
           call _cdQSX(R1) args: 0, res: 0, upd: 0;
       cdQSY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQSX() //  [R1]
         { info_tbl: [(cdQSX,
                       label: block_cdQSX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQSX: // global
           _sdQo8::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdQT3_info;
           R2 = P64[Sp + 16];
           R1 = _sdQo8::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQT3() //  []
         { info_tbl: [(cdQT3,
                       label: block_cdQT3_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQT3: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQoq_entry() //  [R1]
         { info_tbl: [(cdQTr,
                       label: sat_sdQoq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQTr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQTv; else goto cdQTw;
       cdQTv: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQTw: // global
           I64[Sp - 24] = block_cdQTo_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udQTA; else goto cdQTp;
       udQTA: // global
           call _cdQTo(R1) args: 0, res: 0, upd: 0;
       cdQTp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQTo() //  [R1]
         { info_tbl: [(cdQTo,
                       label: block_cdQTo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQTo: // global
           _sdQom::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdQTu_info;
           R2 = P64[Sp + 16];
           R1 = _sdQom::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQTu() //  []
         { info_tbl: [(cdQTu,
                       label: block_cdQTu_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQTu: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQoB_entry() //  [R1]
         { info_tbl: [(cdQTP,
                       label: sat_sdQoB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQTP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdQTT; else goto cdQTU;
       cdQTT: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdQTU: // global
           I64[Sp - 24] = block_cdQTM_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udQTY; else goto cdQTN;
       udQTY: // global
           call _cdQTM(R1) args: 0, res: 0, upd: 0;
       cdQTN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQTM() //  [R1]
         { info_tbl: [(cdQTM,
                       label: block_cdQTM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQTM: // global
           _sdQox::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdQTS_info;
           R2 = P64[Sp + 16];
           R1 = _sdQox::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQTS() //  []
         { info_tbl: [(cdQTS,
                       label: block_cdQTS_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQTS: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQoW_entry() //  [R1]
         { info_tbl: [(cdQTZ,
                       label: sat_sdQoW_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQTZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdQU0; else goto cdQU1;
       cdQU0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQU1: // global
           I64[Sp - 32] = block_cdQRt_info;
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 16];
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 40];
           Sp = Sp - 32;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQRt() //  [R1]
         { info_tbl: [(cdQRt,
                       label: block_cdQRt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQRt: // global
           I64[Sp] = block_cdQRx_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQRx() //  [R1]
         { info_tbl: [(cdQRx,
                       label: block_cdQRx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQRx: // global
           if (R1 & 7 == 1) goto cdQU4; else goto cdQU9;
       cdQU4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQU7; else goto cdQU6;
       cdQU7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQU6: // global
           I64[Hp - 16] = sat_sdQnx_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdQU9: // global
           I64[Sp] = block_cdQRV_info;
           R1 = P64[Sp + 24];
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQRV() //  [R1]
         { info_tbl: [(cdQRV,
                       label: block_cdQRV_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQRV: // global
           I64[Sp - 8] = block_cdQRZ_info;
           _sdQnz::P64 = P64[R1 + 7];
           _sdQnD::P64 = P64[R1 + 39];
           R1 = P64[R1 + 15];
           P64[Sp] = _sdQnD::P64;
           P64[Sp + 24] = _sdQnz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQVS; else goto cdQS0;
       udQVS: // global
           call _cdQRZ(R1) args: 0, res: 0, upd: 0;
       cdQS0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQRZ() //  [R1]
         { info_tbl: [(cdQRZ,
                       label: block_cdQRZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQRZ: // global
           if (I32[I64[R1 - 1] + 20] == 17 :: W32) goto cdQUh; else goto cdQUc;
       cdQUh: // global
           _sdQnD::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdQSo_info;
           R1 = _sdQnD::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udQVT; else goto cdQSp;
       udQVT: // global
           call _cdQSo(R1) args: 0, res: 0, upd: 0;
       cdQSp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdQUc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQUf; else goto cdQUe;
       cdQUf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQUe: // global
           I64[Hp - 16] = sat_sdQnP_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdQSo() //  [R1]
         { info_tbl: [(cdQSo,
                       label: block_cdQSo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQSo: // global
           if (R1 & 7 == 1) goto cdQUj; else goto cdQUo;
       cdQUj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQUm; else goto cdQUl;
       cdQUm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQUl: // global
           I64[Hp - 16] = sat_sdQo0_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdQUo: // global
           I64[Sp] = block_cdQSN_info;
           _sdQo1::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sdQo1::P64;
           if (R1 & 7 != 0) goto udQVU; else goto cdQSO;
       udQVU: // global
           call _cdQSN(R1) args: 0, res: 0, upd: 0;
       cdQSO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQSN() //  [R1]
         { info_tbl: [(cdQSN,
                       label: block_cdQSN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQSN: // global
           if (R1 & 7 == 1) goto cdQUq; else goto cdQUv;
       cdQUq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQUt; else goto cdQUs;
       cdQUt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQUs: // global
           I64[Hp - 16] = sat_sdQoc_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdQUv: // global
           I64[Sp] = block_cdQTc_info;
           _sdQod::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sdQod::P64;
           if (R1 & 7 != 0) goto udQVV; else goto cdQTd;
       udQVV: // global
           call _cdQTc(R1) args: 0, res: 0, upd: 0;
       cdQTd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQTc() //  [R1]
         { info_tbl: [(cdQTc,
                       label: block_cdQTc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQTc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQUy; else goto cdQUx;
       cdQUy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQUx: // global
           if (I64[R1 + 7] == 32) goto cdQUF; else goto cdQUA;
       cdQUF: // global
           Hp = Hp - 24;
           I64[Sp] = block_cdQUB_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto udQVW; else goto cdQUG;
       udQVW: // global
           call _cdQUB(R1) args: 0, res: 0, upd: 0;
       cdQUG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdQUA: // global
           I64[Hp - 16] = sat_sdQoq_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdQUB() //  [R1]
         { info_tbl: [(cdQUB,
                       label: block_cdQUB_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQUB: // global
           if (R1 & 7 == 1) goto cdQUN; else goto cdQVi;
       cdQUN: // global
           I64[Sp] = block_cdQUK_info;
           _sdQoE::P64 = P64[R1 + 15];
           R1 = GHC.IO.Handle.FD.stdout_closure;
           P64[Sp + 24] = _sdQoE::P64;
           if (R1 & 7 != 0) goto udQVX; else goto cdQUO;
       udQVX: // global
           call _cdQUK(R1) args: 0, res: 0, upd: 0;
       cdQUO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdQVi: // global
           I64[Sp] = block_cdQVg_info;
           _sdQoN::P64 = P64[R1 + 14];
           R1 = GHC.IO.Handle.FD.stdout_closure;
           P64[Sp + 24] = _sdQoN::P64;
           if (R1 & 7 != 0) goto udQVY; else goto cdQVj;
       udQVY: // global
           call _cdQVg(R1) args: 0, res: 0, upd: 0;
       cdQVj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQUK() //  [R1]
         { info_tbl: [(cdQUK,
                       label: block_cdQUK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQUK: // global
           if (R1 & 7 != 1) goto udQW0; else goto cdQV9;
       cdQV9: // global
           if (P64[Sp + 24] != P64[R1 + 15]) goto udQW0; else goto udQVR;
       udQW0: // global
           call _cdQTF() args: 0, res: 0, upd: 0;
       udQVR: // global
           Sp = Sp + 8;
           call _cdQVE() args: 0, res: 0, upd: 0;
     }
 },
 _cdQVg() //  [R1]
         { info_tbl: [(cdQVg,
                       label: block_cdQVg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQVg: // global
           if (R1 & 7 == 1) goto udQW3; else goto cdQVI;
       cdQVI: // global
           if (P64[Sp + 24] != P64[R1 + 14]) goto udQW3; else goto udQVQ;
       udQW3: // global
           call _cdQTF() args: 0, res: 0, upd: 0;
       udQVQ: // global
           Sp = Sp + 8;
           call _cdQVE() args: 0, res: 0, upd: 0;
     }
 },
 _cdQVE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQVE: // global
           R2 = lvl1_rdQlW_closure+1;
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdQTF() //  []
         { info_tbl: [(cdQTF,
                       label: block_cdQTF_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQTF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQUE; else goto cdQUD;
       cdQUE: // global
           HpAlloc = 24;
           I64[Sp] = block_cdQTF_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdQUD: // global
           I64[Hp - 16] = sat_sdQoB_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 real_handler_rdQm5_entry() //  [R2, R3]
         { info_tbl: [(cdQWb,
                       label: real_handler_rdQm5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQWb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdQWc; else goto cdQWd;
       cdQWc: // global
           R3 = R3;
           R2 = R2;
           R1 = real_handler_rdQm5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdQWd: // global
           I64[Sp - 24] = block_cdQOt_info;
           _sdQn6::P64 = R2;
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles4_closure+1;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQOt() //  []
         { info_tbl: [(cdQOt,
                       label: block_cdQOt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQOt: // global
           I64[Sp] = block_cdQOv_info;
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles2_closure+1;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQOv() //  []
         { info_tbl: [(cdQOv,
                       label: block_cdQOv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQOv: // global
           I64[Sp] = block_cdQW5_info;
           R2 = P64[Sp + 16];
           call GHC.IO.Exception.$fExceptionAsyncException_$cfromException_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQW5() //  [R1]
         { info_tbl: [(cdQW5,
                       label: block_cdQW5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQW5: // global
           if (R1 & 7 == 1) goto udQXb; else goto cdQW9;
       udQXb: // global
           Sp = Sp + 8;
           call _sdQnf() args: 0, res: 0, upd: 0;
       cdQW9: // global
           I64[Sp] = block_cdQWI_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto udQXd; else goto cdQWK;
       udQXd: // global
           call _cdQWI(R1) args: 0, res: 0, upd: 0;
       cdQWK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQWI() //  [R1]
         { info_tbl: [(cdQWI,
                       label: block_cdQWI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQWI: // global
           _cdQX3::P64 = R1 & 7;
           if (_cdQX3::P64 < 3) goto udQX9; else goto udQXa;
       udQX9: // global
           _sdQn6::P64 = P64[Sp + 8];
           if (_cdQX3::P64 < 2) goto cdQWQ; else goto cdQWU;
       cdQWQ: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] reportStackOverflow(CurrentTSO);
           R2 = lvl4_rdQm3_closure+1;
           R1 = _sdQn6::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdQWU: // global
           call "ccall" arg hints:  []  result hints:  [] reportHeapOverflow();
           R2 = lvl5_rdQm4_closure+1;
           R1 = _sdQn6::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       udQXa: // global
           if (_cdQX3::P64 < 4) goto udQXc; else goto cdQX2;
       udQXc: // global
           Sp = Sp + 8;
           call _sdQnf() args: 0, res: 0, upd: 0;
       cdQX2: // global
           R1 = exitInterrupted_rdPu2_closure;
           Sp = Sp + 24;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _sdQnf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sdQnf: // global
           I64[Sp - 8] = block_cdQOC_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQXg; else goto cdQOD;
       udQXg: // global
           call _cdQOC(R1) args: 0, res: 0, upd: 0;
       cdQOD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQOC() //  [R1]
         { info_tbl: [(cdQOC,
                       label: block_cdQOC_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQOC: // global
           I64[Sp - 16] = block_cdQOH_info;
           _sdQni::P64 = P64[R1 + 7];
           R2 = _sdQni::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _sdQni::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQOH() //  [R1]
         { info_tbl: [(cdQOH,
                       label: block_cdQOH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQOH: // global
           I64[Sp] = block_cdQOL_info;
           R3 = GHC.IO.Exception.$fExceptionExitCode4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdQOL() //  [R1]
         { info_tbl: [(cdQOL,
                       label: block_cdQOL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQOL: // global
           _sdQnj::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdQWk; else goto cdQWs;
       cdQWk: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdQWn; else goto cdQWm;
       cdQWn: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQWm: // global
           I64[Hp - 56] = sat_sdQq4_info;
           _sdQn6::P64 = P64[Sp + 24];
           P64[Hp - 48] = _sdQn6::P64;
           I64[Hp - 40] = sat_sdQoW_info;
           P64[Hp - 24] = _sdQn6::P64;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdQnj::P64;
           R2 = Hp - 54;
           R1 = Hp - 40;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
       cdQWs: // global
           I64[Sp + 16] = block_cdQWq_info;
           R1 = _sdQnj::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQWq() //  [R1]
         { info_tbl: [(cdQWq,
                       label: block_cdQWq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQWq: // global
           _sdQn6::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdQWy; else goto cdQWC;
       cdQWy: // global
           R2 = lvl1_rdQlW_closure+1;
           R1 = _sdQn6::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdQWC: // global
           R2 = P64[R1 + 6];
           R1 = _sdQn6::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.538516675 UTC

[section ""data" . GHC.TopHandler.runIO2_closure" {
     GHC.TopHandler.runIO2_closure:
         const GHC.TopHandler.runIO2_info;
         const 0;
 },
 GHC.TopHandler.runIO2_entry() //  [R2]
         { info_tbl: [(cdQXl,
                       label: GHC.TopHandler.runIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQXl: // global
           R2 = R2;
           call GHC.TopHandler.runIO3_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.TopHandler.runIO3_closure" {
     GHC.TopHandler.runIO3_closure:
         const GHC.TopHandler.runIO3_info;
         const 0;
 },
 sat_sdQqn_entry() //  [R1]
         { info_tbl: [(cdQXx,
                       label: sat_sdQqn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQXx: // global
           R3 = P64[R1 + 7];
           R2 = safeExit_rdPtY_closure+1;
           call real_handler_rdQm5_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runIO3_entry() //  [R2]
         { info_tbl: [(cdQXA,
                       label: GHC.TopHandler.runIO3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQXA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQXE; else goto cdQXD;
       cdQXE: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.TopHandler.runIO3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQXD: // global
           I64[Hp - 8] = sat_sdQqn_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.539824783 UTC

[section ""data" . GHC.TopHandler.topHandler_closure" {
     GHC.TopHandler.topHandler_closure:
         const GHC.TopHandler.topHandler_info;
         const 0;
 },
 GHC.TopHandler.topHandler_entry() //  [R2]
         { info_tbl: [(cdQXJ,
                       label: GHC.TopHandler.topHandler_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQXJ: // global
           R2 = R2;
           call GHC.TopHandler.runIO3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.541018824 UTC

[section ""data" . GHC.TopHandler.runNonIO1_closure" {
     GHC.TopHandler.runNonIO1_closure:
         const GHC.TopHandler.runNonIO1_info;
         const 0;
 },
 sat_sdQqs_entry() //  [R1]
         { info_tbl: [(cdQY1,
                       label: sat_sdQqs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQY1: // global
           R1 = P64[R1 + 7];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQqt_entry() //  [R1]
         { info_tbl: [(cdQY4,
                       label: sat_sdQqt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQY4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQY5; else goto cdQY6;
       cdQY5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQY6: // global
           I64[Sp - 8] = block_cdQXU_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQXU() //  [R1]
         { info_tbl: [(cdQXU,
                       label: block_cdQXU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQXU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQY9; else goto cdQY8;
       cdQY9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdQY8: // global
           I64[Hp - 8] = sat_sdQqs_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runNonIO1_entry() //  [R2]
         { info_tbl: [(cdQYa,
                       label: GHC.TopHandler.runNonIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQYa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQYe; else goto cdQYd;
       cdQYe: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.TopHandler.runNonIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQYd: // global
           I64[Hp - 16] = sat_sdQqt_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.542706422 UTC

[section ""data" . GHC.TopHandler.runNonIO_closure" {
     GHC.TopHandler.runNonIO_closure:
         const GHC.TopHandler.runNonIO_info;
         const 0;
 },
 GHC.TopHandler.runNonIO_entry() //  [R2]
         { info_tbl: [(cdQYj,
                       label: GHC.TopHandler.runNonIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQYj: // global
           R2 = R2;
           call GHC.TopHandler.runNonIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.543532817 UTC

[section ""data" . GHC.TopHandler.runIO1_closure" {
     GHC.TopHandler.runIO1_closure:
         const GHC.TopHandler.runIO1_info;
         const 0;
 },
 GHC.TopHandler.runIO1_entry() //  [R2]
         { info_tbl: [(cdQYq,
                       label: GHC.TopHandler.runIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQYq: // global
           _sdQqu::P64 = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = _sdQqu::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.544392287 UTC

[section ""data" . GHC.TopHandler.runIO_closure" {
     GHC.TopHandler.runIO_closure:
         const GHC.TopHandler.runIO_info;
         const 0;
 },
 GHC.TopHandler.runIO_entry() //  [R2]
         { info_tbl: [(cdQYx,
                       label: GHC.TopHandler.runIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQYx: // global
           R2 = R2;
           call GHC.TopHandler.runIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.545148622 UTC

[section ""data" . fastExit1_rdQm6_closure" {
     fastExit1_rdQm6_closure:
         const GHC.Int.I32#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.548487476 UTC

[section ""data" . fastExit_rdPtZ_closure" {
     fastExit_rdPtZ_closure:
         const fastExit_rdPtZ_info;
         const 0;
 },
 fastExit_rdPtZ_entry() //  [R2]
         { info_tbl: [(cdQYH,
                       label: fastExit_rdPtZ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQYH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdQYI; else goto cdQYJ;
       cdQYI: // global
           R2 = R2;
           R1 = fastExit_rdPtZ_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQYJ: // global
           I64[Sp - 8] = block_cdQYE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udQYN; else goto cdQYF;
       udQYN: // global
           call _cdQYE(R1) args: 0, res: 0, upd: 0;
       cdQYF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQYE() //  [R1]
         { info_tbl: [(cdQYE,
                       label: block_cdQYE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQYE: // global
           R3 = I64[R1 + 7];
           R2 = fastExit1_rdQm6_closure+1;
           Sp = Sp + 8;
           call $wexitHelper_rdQlT_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.549952912 UTC

[section ""data" . GHC.TopHandler.runIOFastExit2_closure" {
     GHC.TopHandler.runIOFastExit2_closure:
         const GHC.TopHandler.runIOFastExit2_info;
         const 0;
 },
 GHC.TopHandler.runIOFastExit2_entry() //  [R2]
         { info_tbl: [(cdQYS,
                       label: GHC.TopHandler.runIOFastExit2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQYS: // global
           R2 = R2;
           call GHC.TopHandler.runIOFastExit3_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.TopHandler.runIOFastExit3_closure" {
     GHC.TopHandler.runIOFastExit3_closure:
         const GHC.TopHandler.runIOFastExit3_info;
         const 0;
 },
 sat_sdQqD_entry() //  [R1]
         { info_tbl: [(cdQZ4,
                       label: sat_sdQqD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQZ4: // global
           R3 = P64[R1 + 7];
           R2 = fastExit_rdPtZ_closure+1;
           call real_handler_rdQm5_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runIOFastExit3_entry() //  [R2]
         { info_tbl: [(cdQZ7,
                       label: GHC.TopHandler.runIOFastExit3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQZ7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdQZb; else goto cdQZa;
       cdQZb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.TopHandler.runIOFastExit3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdQZa: // global
           I64[Hp - 8] = sat_sdQqD_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIOFastExit2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.551186442 UTC

[section ""data" . GHC.TopHandler.topHandlerFastExit_closure" {
     GHC.TopHandler.topHandlerFastExit_closure:
         const GHC.TopHandler.topHandlerFastExit_info;
         const 0;
 },
 GHC.TopHandler.topHandlerFastExit_entry() //  [R2]
         { info_tbl: [(cdQZg,
                       label: GHC.TopHandler.topHandlerFastExit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQZg: // global
           R2 = R2;
           call GHC.TopHandler.runIOFastExit3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.55199354 UTC

[section ""data" . GHC.TopHandler.runIOFastExit1_closure" {
     GHC.TopHandler.runIOFastExit1_closure:
         const GHC.TopHandler.runIOFastExit1_info;
         const 0;
 },
 GHC.TopHandler.runIOFastExit1_entry() //  [R2]
         { info_tbl: [(cdQZn,
                       label: GHC.TopHandler.runIOFastExit1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQZn: // global
           _sdQqE::P64 = R2;
           R2 = GHC.TopHandler.runIOFastExit2_closure+2;
           R1 = _sdQqE::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.5527935 UTC

[section ""data" . GHC.TopHandler.runIOFastExit_closure" {
     GHC.TopHandler.runIOFastExit_closure:
         const GHC.TopHandler.runIOFastExit_info;
         const 0;
 },
 GHC.TopHandler.runIOFastExit_entry() //  [R2]
         { info_tbl: [(cdQZu,
                       label: GHC.TopHandler.runIOFastExit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQZu: // global
           R2 = R2;
           call GHC.TopHandler.runIOFastExit1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.553663211 UTC

[section ""data" . GHC.TopHandler.runMainIO3_closure" {
     GHC.TopHandler.runMainIO3_closure:
         const GHC.TopHandler.runMainIO3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.TopHandler.runMainIO3_entry() //  [R1]
         { info_tbl: [(cdQZD,
                       label: GHC.TopHandler.runMainIO3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQZD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQZE; else goto cdQZF;
       cdQZE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdQZF: // global
           (_cdQZA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdQZA::I64 == 0) goto cdQZC; else goto cdQZB;
       cdQZC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdQZB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdQZA::I64;
           R2 = GHC.IO.Exception.UserInterrupt_closure+4;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.554539265 UTC

[section ""data" . GHC.TopHandler.runMainIO4_closure" {
     GHC.TopHandler.runMainIO4_closure:
         const GHC.Int.I32#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.55636313 UTC

[section ""data" . GHC.TopHandler.runMainIO1_closure" {
     GHC.TopHandler.runMainIO1_closure:
         const GHC.TopHandler.runMainIO1_info;
         const 0;
 },
 sat_sdQrd_entry() //  [R1]
         { info_tbl: [(cdR07,
                       label: sat_sdQrd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR07: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdR08; else goto cdR09;
       cdR08: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdR09: // global
           I64[Sp - 8] = block_cdQZZ_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_deRefWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQZZ() //  [R1, R2]
         { info_tbl: [(cdQZZ,
                       label: block_cdQZZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQZZ: // global
           if (R1 == 0) goto udR0l; else goto cdR05;
       udR0l: // global
           call _cdR06() args: 0, res: 0, upd: 0;
       cdR05: // global
           I64[Sp] = block_cdR0c_info;
           R1 = R2;
           if (R1 & 7 != 0) goto udR0m; else goto cdR0d;
       udR0m: // global
           call _cdR0c(R1) args: 0, res: 0, upd: 0;
       cdR0d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdR0c() //  [R1]
         { info_tbl: [(cdR0c,
                       label: block_cdR0c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR0c: // global
           I64[Sp] = block_cdR06_info;
           R2 = GHC.TopHandler.runMainIO3_closure;
           R1 = P64[R1 + 7];
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdR06() //  []
         { info_tbl: [(cdR06,
                       label: block_cdR06_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR06: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQr3_entry() //  [R1, R2]
         { info_tbl: [(cdR0B,
                       label: sat_sdQr3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR0B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdR0C; else goto cdR0D;
       cdR0C: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdR0D: // global
           I64[Sp - 8] = block_cdR0t_info;
           R1 = P64[R1 + 6];
           Sp = Sp - 8;
           call stg_deRefWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdR0t() //  [R1, R2]
         { info_tbl: [(cdR0t,
                       label: block_cdR0t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR0t: // global
           if (R1 == 0) goto udR0P; else goto cdR0z;
       udR0P: // global
           call _cdR0A() args: 0, res: 0, upd: 0;
       cdR0z: // global
           I64[Sp] = block_cdR0G_info;
           R1 = R2;
           if (R1 & 7 != 0) goto udR0Q; else goto cdR0H;
       udR0Q: // global
           call _cdR0G(R1) args: 0, res: 0, upd: 0;
       cdR0H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdR0G() //  [R1]
         { info_tbl: [(cdR0G,
                       label: block_cdR0G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR0G: // global
           I64[Sp] = block_cdR0A_info;
           R2 = GHC.TopHandler.runMainIO3_closure;
           R1 = P64[R1 + 7];
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdR0A() //  []
         { info_tbl: [(cdR0A,
                       label: block_cdR0A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR0A: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQro_entry() //  [R1]
         { info_tbl: [(cdR0Z,
                       label: sat_sdQro_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR0Z: // global
           _sdQro::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdR10; else goto cdR11;
       cdR11: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdR13; else goto cdR12;
       cdR13: // global
           HpAlloc = 16;
           goto cdR10;
       cdR10: // global
           R1 = _sdQro::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdR12: // global
           _sdQqG::P64 = P64[_sdQro::P64 + 7];
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           _sdQqL::P64 = CurrentTSO;
           P64[Hp] = _sdQqL::P64;
           I64[Sp - 16] = block_cdQZQ_info;
           R2 = Hp - 7;
           R1 = _sdQqL::P64;
           P64[Sp - 8] = _sdQqG::P64;
           Sp = Sp - 16;
           call stg_mkWeakNoFinalizer#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdQZQ() //  [R1]
         { info_tbl: [(cdQZQ,
                       label: block_cdQZQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdQZQ: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdR16; else goto cdR15;
       cdR16: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdR15: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] rts_setMainThread(R1);
           I64[Hp - 88] = sat_sdQrd_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = Data.Dynamic.Dynamic_con_info;
           P64[Hp - 64] = GHC.TopHandler.runMainIO2_closure;
           P64[Hp - 56] = Hp - 87;
           I64[Hp - 48] = sat_sdQr3_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 46;
           P64[Hp - 16] = Hp - 71;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cdR0T_info;
           R3 = Hp - 6;
           R2 = GHC.TopHandler.runMainIO4_closure+1;
           call GHC.Conc.Signal.setHandler1_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdR0T() //  []
         { info_tbl: [(cdR0T,
                       label: block_cdR0T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR0T: // global
           _sdQqG::P64 = P64[Sp + 8];
           (_sdQrn::I64) = call "ccall" arg hints:  [‘signed’, ‘signed’,
                                                     PtrHint]  result hints:  [‘signed’] stg_sig_install(2, (-5), 0);
           R1 = _sdQqG::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runMainIO1_entry() //  [R2]
         { info_tbl: [(cdR18,
                       label: GHC.TopHandler.runMainIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR18: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdR1c; else goto cdR1b;
       cdR1c: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.TopHandler.runMainIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdR1b: // global
           I64[Hp - 8] = sat_sdQro_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.559549181 UTC

[section ""data" . GHC.TopHandler.runMainIO_closure" {
     GHC.TopHandler.runMainIO_closure:
         const GHC.TopHandler.runMainIO_info;
         const 0;
 },
 GHC.TopHandler.runMainIO_entry() //  [R2]
         { info_tbl: [(cdR1h,
                       label: GHC.TopHandler.runMainIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR1h: // global
           R2 = R2;
           call GHC.TopHandler.runMainIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.56028655 UTC

[section ""relreadonly" . SdQrO_srt" {
     SdQrO_srt:
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const GHC.IO.Handle.FD.stderr_closure;
         const GHC.IO.Handle.hFlush2_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.TopHandler.flushStdHandles1_closure;
         const GHC.TopHandler.flushStdHandles2_closure;
         const GHC.TopHandler.flushStdHandles4_closure;
         const GHC.IO.failIO1_closure;
         const unreachable1_rdQlS_closure;
         const $wexitHelper_rdQlT_closure;
         const safeExit_rdPtY_closure;
         const msgStr1_rdQlY_closure;
         const str1_rdQm0_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const lvl2_rdQm1_closure;
         const lvl3_rdQm2_closure;
         const GHC.Conc.Sync.uncaughtExceptionHandler_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionExitCode4_closure;
         const exitInterrupted_rdPu2_closure;
         const real_handler_rdQm5_closure;
         const GHC.TopHandler.runIO3_closure;
         const GHC.TopHandler.runIO2_closure;
         const GHC.TopHandler.runNonIO1_closure;
         const GHC.TopHandler.runIO1_closure;
         const fastExit_rdPtZ_closure;
         const GHC.TopHandler.runIOFastExit3_closure;
         const GHC.TopHandler.runIOFastExit2_closure;
         const GHC.TopHandler.runIOFastExit1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
         const GHC.TopHandler.runMainIO3_closure;
         const GHC.Conc.Signal.setHandler1_closure;
         const GHC.TopHandler.runMainIO2_closure;
         const GHC.TopHandler.runMainIO1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.561380328 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:05.562600689 UTC

[section ""cstring" . GHC.TopHandler.$trModule4_bytes" {
     GHC.TopHandler.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.58077582 UTC

[section ""data" . GHC.TopHandler.$trModule3_closure" {
     GHC.TopHandler.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.TopHandler.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.584021959 UTC

[section ""cstring" . GHC.TopHandler.$trModule2_bytes" {
     GHC.TopHandler.$trModule2_bytes:
         I8[] [71,72,67,46,84,111,112,72,97,110,100,108,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.587159806 UTC

[section ""data" . GHC.TopHandler.$trModule1_closure" {
     GHC.TopHandler.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.TopHandler.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.590194476 UTC

[section ""data" . GHC.TopHandler.$trModule_closure" {
     GHC.TopHandler.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.TopHandler.$trModule3_closure+1;
         const GHC.TopHandler.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.594483094 UTC

[section ""data" . GHC.TopHandler.runMainIO2_closure" {
     GHC.TopHandler.runMainIO2_closure:
         const GHC.TopHandler.runMainIO2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.TopHandler.runMainIO2_entry() //  [R1]
         { info_tbl: [(cdR1F,
                       label: GHC.TopHandler.runMainIO2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR1F: // global
           if ((Sp + -104) < SpLim) (likely: False) goto cdR1G; else goto cdR1H;
       cdR1G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdR1H: // global
           (_cdR1s::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdR1s::I64 == 0) goto cdR1u; else goto cdR1t;
       cdR1u: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdR1t: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdR1s::I64;
           I64[Sp - 24] = block_cdR1v_info;
           R6 = 0;
           R5 = GHC.Types.$tcIO1_closure;
           R4 = GHC.Types.$trModule_closure;
           R3 = 14006894820825784566;
           R2 = 11571292540224541508;
           P64[Sp - 40] = GHC.Types.krep$*Arr*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cdR1v() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdR1v,
                       label: block_cdR1v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR1v: // global
           I64[Sp - 40] = block_cdR1z_info;
           R6 = 0;
           _sdQmd::P64 = R5;
           R5 = GHC.Tuple.$tc()1_closure;
           _sdQmc::P64 = R4;
           R4 = GHC.Tuple.$trModule_closure;
           _sdQmb::P64 = R3;
           R3 = 14290630168515401665;
           _sdQma::I64 = R2;
           R2 = 2684808367141291271;
           P64[Sp - 56] = GHC.Types.krep$*_closure;
           P64[Sp - 48] = GHC.Types.[]_closure+1;
           I64[Sp - 32] = _sdQma::I64;
           P64[Sp - 24] = _sdQmb::P64;
           P64[Sp - 16] = _sdQmc::P64;
           P64[Sp - 8] = _sdQmd::P64;
           I64[Sp] = R1;
           Sp = Sp - 56;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cdR1z() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdR1z,
                       label: block_cdR1z_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR1z: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cdR1A() args: 0, res: 0, upd: 0;
     }
 },
 _cdR1A() //  []
         { info_tbl: [(cdR1A,
                       label: block_cdR1A_info
                       rep:StackRep [True, False, False, False, True, True, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR1A: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdR1L; else goto cdR1K;
       cdR1L: // global
           HpAlloc = 96;
           I64[Sp] = block_cdR1A_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cdR1K: // global
           I64[Hp - 88] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = P64[Sp + 24];
           P64[Hp - 64] = P64[Sp + 32];
           I64[Hp - 56] = I64[Sp + 40];
           I64[Hp - 48] = I64[Sp + 8];
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 56];
           P64[Hp - 24] = P64[Sp + 64];
           P64[Hp - 16] = P64[Sp + 72];
           I64[Hp - 8] = I64[Sp + 80];
           I64[Hp] = I64[Sp + 48];
           R3 = Hp - 86;
           R2 = Hp - 38;
           Sp = Sp + 88;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.61481129 UTC

[section ""cstring" . unreachable_rdQlR_bytes" {
     unreachable_rdQlR_bytes:
         I8[] [73,102,32,121,111,117,32,99,97,110,32,114,101,97,100,32,116,104,105,115,44,32,115,104,117,116,100,111,119,110,72,97,115,107,101,108,108,65,110,100,69,120,105,116,32,100,105,100,32,110,111,116,32,101,120,105,116,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.618198383 UTC

[section ""data" . unreachable1_rdQlS_closure" {
     unreachable1_rdQlS_closure:
         const unreachable1_rdQlS_info;
         const 0;
         const 0;
         const 0;
 },
 unreachable1_rdQlS_entry() //  [R1]
         { info_tbl: [(cdR2l,
                       label: unreachable1_rdQlS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR2l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdR2m; else goto cdR2n;
       cdR2m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdR2n: // global
           (_cdR2i::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdR2i::I64 == 0) goto cdR2k; else goto cdR2j;
       cdR2k: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdR2j: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdR2i::I64;
           R2 = unreachable_rdQlR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.625226445 UTC

[section ""data" . GHC.TopHandler.flushStdHandles2_closure" {
     GHC.TopHandler.flushStdHandles2_closure:
         const GHC.TopHandler.flushStdHandles2_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles2_entry() //  []
         { info_tbl: [(cdR2z,
                       label: GHC.TopHandler.flushStdHandles2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR2z: // global
           R4 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure+2;
           R3 = GHC.IO.Handle.FD.stderr_closure;
           R2 = GHC.IO.Handle.hFlush2_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.629599105 UTC

[section ""data" . GHC.TopHandler.flushStdHandles3_closure" {
     GHC.TopHandler.flushStdHandles3_closure:
         const GHC.TopHandler.flushStdHandles3_info;
 },
 GHC.TopHandler.flushStdHandles3_entry() //  [R2]
         { info_tbl: [(cdR2N,
                       label: GHC.TopHandler.flushStdHandles3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR2N: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdR2O; else goto cdR2P;
       cdR2O: // global
           R2 = R2;
           R1 = GHC.TopHandler.flushStdHandles3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdR2P: // global
           I64[Sp - 8] = block_cdR2K_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udR2T; else goto cdR2L;
       udR2T: // global
           call _cdR2K() args: 0, res: 0, upd: 0;
       cdR2L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdR2K() //  []
         { info_tbl: [(cdR2K,
                       label: block_cdR2K_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR2K: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.63502301 UTC

[section ""data" . GHC.TopHandler.flushStdHandles4_closure" {
     GHC.TopHandler.flushStdHandles4_closure:
         const GHC.TopHandler.flushStdHandles4_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles4_entry() //  []
         { info_tbl: [(cdR38,
                       label: GHC.TopHandler.flushStdHandles4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR38: // global
           R4 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure+2;
           R3 = GHC.IO.Handle.FD.stdout_closure;
           R2 = GHC.IO.Handle.hFlush2_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.638601643 UTC

[section ""data" . GHC.TopHandler.flushStdHandles1_closure" {
     GHC.TopHandler.flushStdHandles1_closure:
         const GHC.TopHandler.flushStdHandles1_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles1_entry() //  []
         { info_tbl: [(cdR3l,
                       label: GHC.TopHandler.flushStdHandles1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR3l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdR3m; else goto cdR3n;
       cdR3m: // global
           R1 = GHC.TopHandler.flushStdHandles1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdR3n: // global
           I64[Sp - 8] = block_cdR3j_info;
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles4_closure+1;
           Sp = Sp - 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdR3j() //  []
         { info_tbl: [(cdR3j,
                       label: block_cdR3j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR3j: // global
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles2_closure+1;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.644145695 UTC

[section ""data" . GHC.TopHandler.flushStdHandles_closure" {
     GHC.TopHandler.flushStdHandles_closure:
         const GHC.TopHandler.flushStdHandles_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles_entry() //  []
         { info_tbl: [(cdR3B,
                       label: GHC.TopHandler.flushStdHandles_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR3B: // global
           call GHC.TopHandler.flushStdHandles1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.649348377 UTC

[section ""data" . $wexitHelper_rdQlT_closure" {
     $wexitHelper_rdQlT_closure:
         const $wexitHelper_rdQlT_info;
         const 0;
 },
 sat_sdQmF_entry() //  [R1]
         { info_tbl: [(cdR44,
                       label: sat_sdQmF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR44: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdR45; else goto cdR46;
       cdR45: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdR46: // global
           I64[Sp - 8] = block_cdR41_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udR4q; else goto cdR42;
       udR4q: // global
           call _cdR41(R1) args: 0, res: 0, upd: 0;
       cdR42: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdR41() //  [R1]
         { info_tbl: [(cdR41,
                       label: block_cdR41_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR41: // global
           I64[Sp] = block_cdR4d_info;
           _cdR4c::I64 = I64[R1 + 7];
           _udR4i::P64 = CurrentTSO;
           I64[I64[_udR4i::P64 + 24] + 16] = Sp;
           _udR4j::I64 = CurrentNursery;
           P64[_udR4j::I64 + 8] = Hp + 8;
           I64[_udR4i::P64 + 104] = I64[_udR4i::P64 + 104] - ((Hp + 8) - I64[_udR4j::I64]);
           (_udR4g::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [‘signed’,
                                     ‘signed’]  result hints:  [] shutdownHaskellAndExit(255, _cdR4c::I64);
           (_udR4h::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udR4g::I64);
           BaseReg = _udR4h::I64;
           _udR4k::P64 = CurrentTSO;
           _udR4l::P64 = I64[_udR4k::P64 + 24];
           Sp = I64[_udR4l::P64 + 16];
           SpLim = _udR4l::P64 + 192;
           HpAlloc = 0;
           _udR4m::I64 = CurrentNursery;
           _udR4n::I64 = I64[_udR4m::I64 + 8];
           Hp = _udR4n::I64 - 8;
           _udR4o::I64 = I64[_udR4m::I64];
           HpLim = _udR4o::I64 + ((%MO_SS_Conv_W32_W64(I32[_udR4m::I64 + 48]) << 12) - 1);
           I64[_udR4k::P64 + 104] = I64[_udR4k::P64 + 104] + (_udR4n::I64 - _udR4o::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdR4d() //  []
         { info_tbl: [(cdR4d,
                       label: block_cdR4d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR4d: // global
           R2 = unreachable1_rdQlS_closure;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQmQ_entry() //  [R1]
         { info_tbl: [(cdR4H,
                       label: sat_sdQmQ_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR4H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdR4I; else goto cdR4J;
       cdR4I: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdR4J: // global
           I64[Sp - 16] = block_cdR4E_info;
           _sdQmw::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _sdQmw::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udR59; else goto cdR4F;
       udR59: // global
           call _cdR4E(R1) args: 0, res: 0, upd: 0;
       cdR4F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdR4E() //  [R1]
         { info_tbl: [(cdR4E,
                       label: block_cdR4E_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR4E: // global
           _cdR4U::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-I64[Sp + 8]));
           I64[Sp + 8] = block_cdR4W_info;
           Sp = Sp + 8;
           _cdR4V::I64 = I64[R1 + 7];
           _udR51::P64 = CurrentTSO;
           I64[I64[_udR51::P64 + 24] + 16] = Sp;
           _udR52::I64 = CurrentNursery;
           P64[_udR52::I64 + 8] = Hp + 8;
           I64[_udR51::P64 + 104] = I64[_udR51::P64 + 104] - ((Hp + 8) - I64[_udR52::I64]);
           (_udR4Z::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [‘signed’,
                                     ‘signed’]  result hints:  [] shutdownHaskellAndSignal(_cdR4U::I64, _cdR4V::I64);
           (_udR50::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udR4Z::I64);
           BaseReg = _udR50::I64;
           _udR53::P64 = CurrentTSO;
           _udR54::P64 = I64[_udR53::P64 + 24];
           Sp = I64[_udR54::P64 + 16];
           SpLim = _udR54::P64 + 192;
           HpAlloc = 0;
           _udR55::I64 = CurrentNursery;
           _udR56::I64 = I64[_udR55::I64 + 8];
           Hp = _udR56::I64 - 8;
           _udR57::I64 = I64[_udR55::I64];
           HpLim = _udR57::I64 + ((%MO_SS_Conv_W32_W64(I32[_udR55::I64 + 48]) << 12) - 1);
           I64[_udR53::P64 + 104] = I64[_udR53::P64 + 104] + (_udR56::I64 - _udR57::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdR4W() //  []
         { info_tbl: [(cdR4W,
                       label: block_cdR4W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR4W: // global
           R2 = unreachable1_rdQlS_closure;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQn0_entry() //  [R1]
         { info_tbl: [(cdR5q,
                       label: sat_sdQn0_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR5q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdR5r; else goto cdR5s;
       cdR5r: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdR5s: // global
           I64[Sp - 16] = block_cdR5n_info;
           _sdQmw::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _sdQmw::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udR5P; else goto cdR5o;
       udR5P: // global
           call _cdR5n(R1) args: 0, res: 0, upd: 0;
       cdR5o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdR5n() //  [R1]
         { info_tbl: [(cdR5n,
                       label: block_cdR5n_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR5n: // global
           _cdR5A::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8]));
           I64[Sp + 8] = block_cdR5C_info;
           Sp = Sp + 8;
           _cdR5B::I64 = I64[R1 + 7];
           _udR5H::P64 = CurrentTSO;
           I64[I64[_udR5H::P64 + 24] + 16] = Sp;
           _udR5I::I64 = CurrentNursery;
           P64[_udR5I::I64 + 8] = Hp + 8;
           I64[_udR5H::P64 + 104] = I64[_udR5H::P64 + 104] - ((Hp + 8) - I64[_udR5I::I64]);
           (_udR5F::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [‘signed’,
                                     ‘signed’]  result hints:  [] shutdownHaskellAndExit(_cdR5A::I64, _cdR5B::I64);
           (_udR5G::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udR5F::I64);
           BaseReg = _udR5G::I64;
           _udR5J::P64 = CurrentTSO;
           _udR5K::P64 = I64[_udR5J::P64 + 24];
           Sp = I64[_udR5K::P64 + 16];
           SpLim = _udR5K::P64 + 192;
           HpAlloc = 0;
           _udR5L::I64 = CurrentNursery;
           _udR5M::I64 = I64[_udR5L::I64 + 8];
           Hp = _udR5M::I64 - 8;
           _udR5N::I64 = I64[_udR5L::I64];
           HpLim = _udR5N::I64 + ((%MO_SS_Conv_W32_W64(I32[_udR5L::I64 + 48]) << 12) - 1);
           I64[_udR5J::P64 + 104] = I64[_udR5J::P64 + 104] + (_udR5M::I64 - _udR5N::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdR5C() //  []
         { info_tbl: [(cdR5C,
                       label: block_cdR5C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR5C: // global
           R2 = unreachable1_rdQlS_closure;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $wexitHelper_rdQlT_entry() //  [R2, R3]
         { info_tbl: [(cdR5T,
                       label: $wexitHelper_rdQlT_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR5T: // global
           _sdQmw::I64 = R3;
           _sdQmv::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdR5U; else goto cdR5V;
       cdR5V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdR5X; else goto cdR5W;
       cdR5X: // global
           HpAlloc = 24;
           goto cdR5U;
       cdR5U: // global
           R3 = _sdQmw::I64;
           R2 = _sdQmv::P64;
           R1 = $wexitHelper_rdQlT_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdR5W: // global
           if (%MO_S_Lt_W64(_sdQmw::I64, 0)) goto cdR6b; else goto cdR5S;
       cdR5S: // global
           if (%MO_S_Gt_W64(_sdQmw::I64, 255)) goto cdR6b; else goto cdR6c;
       cdR6b: // global
           Hp = Hp - 24;
           P64[Sp - 16] = _sdQmv::P64;
           I64[Sp - 8] = _sdQmw::I64;
           Sp = Sp - 24;
           call _cdR3P() args: 0, res: 0, upd: 0;
       cdR6c: // global
           I64[Hp - 16] = sat_sdQn0_info;
           P64[Hp - 8] = _sdQmv::P64;
           I64[Hp] = _sdQmw::I64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdR3P() //  []
         { info_tbl: [(cdR3P,
                       label: block_cdR3P_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR3P: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdR60; else goto cdR5Z;
       cdR60: // global
           HpAlloc = 24;
           I64[Sp] = block_cdR3P_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdR5Z: // global
           _sdQmw::I64 = I64[Sp + 16];
           if (%MO_S_Lt_W64(_sdQmw::I64, (-127))) goto cdR67; else goto cdR69;
       cdR69: // global
           if (%MO_S_Gt_W64(_sdQmw::I64, (-1))) goto cdR67; else goto cdR68;
       cdR67: // global
           Hp = Hp - 24;
           call _cdR3U() args: 0, res: 0, upd: 0;
       cdR68: // global
           I64[Hp - 16] = sat_sdQmQ_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = _sdQmw::I64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdR3U() //  []
         { info_tbl: [(cdR3U,
                       label: block_cdR3U_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR3U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdR63; else goto cdR62;
       cdR63: // global
           HpAlloc = 16;
           I64[Sp] = block_cdR3U_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdR62: // global
           I64[Hp - 8] = sat_sdQmF_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.678060516 UTC

[section ""data" . safeExit1_rdQlU_closure" {
     safeExit1_rdQlU_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.680115755 UTC

[section ""data" . safeExit_rdPtY_closure" {
     safeExit_rdPtY_closure:
         const safeExit_rdPtY_info;
         const 0;
 },
 safeExit_rdPtY_entry() //  [R2]
         { info_tbl: [(cdR7Y,
                       label: safeExit_rdPtY_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR7Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdR7Z; else goto cdR80;
       cdR7Z: // global
           R2 = R2;
           R1 = safeExit_rdPtY_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdR80: // global
           I64[Sp - 8] = block_cdR7V_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udR84; else goto cdR7W;
       udR84: // global
           call _cdR7V(R1) args: 0, res: 0, upd: 0;
       cdR7W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdR7V() //  [R1]
         { info_tbl: [(cdR7V,
                       label: block_cdR7V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR7V: // global
           R3 = I64[R1 + 7];
           R2 = safeExit1_rdQlU_closure+1;
           Sp = Sp + 8;
           call $wexitHelper_rdQlT_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.6857444 UTC

[section ""data" . exitInterrupted_rdPu2_closure" {
     exitInterrupted_rdPu2_closure:
         const exitInterrupted_rdPu2_info;
         const 0;
         const 0;
         const 0;
 },
 exitInterrupted_rdPu2_entry() //  [R1]
         { info_tbl: [(cdR8k,
                       label: exitInterrupted_rdPu2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR8k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdR8l; else goto cdR8m;
       cdR8l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdR8m: // global
           (_cdR8h::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdR8h::I64 == 0) goto cdR8j; else goto cdR8i;
       cdR8j: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdR8i: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdR8h::I64;
           R3 = (-2);
           R2 = safeExit1_rdQlU_closure+1;
           Sp = Sp - 16;
           call $wexitHelper_rdQlT_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.689787526 UTC

[section ""data" . lvl_rdQlV_closure" {
     lvl_rdQlV_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.691475362 UTC

[section ""data" . lvl1_rdQlW_closure" {
     lvl1_rdQlW_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.693110007 UTC

[section ""cstring" . msgStr_rdQlX_bytes" {
     msgStr_rdQlX_bytes:
         I8[] [101,110,99,111,117,110,116,101,114,101,100,32,97,110,32,101,120,99,101,112,116,105,111,110,32,119,104,105,108,101,32,116,114,121,105,110,103,32,116,111,32,114,101,112,111,114,116,32,97,110,32,101,120,99,101,112,116,105,111,110,46,10,79,110,101,32,112,111,115,115,105,98,108,101,32,114,101,97,115,111,110,32,102,111,114,32,116,104,105,115,32,105,115,32,116,104,97,116,32,119,101,32,102,97,105,108,101,100,32,119,104,105,108,101,32,116,114,121,105,110,103,32,116,111,32,101,110,99,111,100,101,32,97,110,32,101,114,114,111,114,32,109,101,115,115,97,103,101,46,32,67,104,101,99,107,32,116,104,97,116,32,121,111,117,114,32,108,111,99,97,108,101,32,105,115,32,99,111,110,102,105,103,117,114,101,100,32,112,114,111,112,101,114,108,121,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.695229243 UTC

[section ""data" . msgStr1_rdQlY_closure" {
     msgStr1_rdQlY_closure:
         const msgStr1_rdQlY_info;
         const 0;
         const 0;
         const 0;
 },
 msgStr1_rdQlY_entry() //  [R1]
         { info_tbl: [(cdR8D,
                       label: msgStr1_rdQlY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR8D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdR8E; else goto cdR8F;
       cdR8E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdR8F: // global
           (_cdR8A::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdR8A::I64 == 0) goto cdR8C; else goto cdR8B;
       cdR8C: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdR8B: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdR8A::I64;
           R2 = msgStr_rdQlX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.699862628 UTC

[section ""cstring" . str_rdQlZ_bytes" {
     str_rdQlZ_bytes:
         I8[] [37,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.701747099 UTC

[section ""data" . str1_rdQm0_closure" {
     str1_rdQm0_closure:
         const str1_rdQm0_info;
         const 0;
         const 0;
         const 0;
 },
 str1_rdQm0_entry() //  [R1]
         { info_tbl: [(cdR8U,
                       label: str1_rdQm0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR8U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdR8V; else goto cdR8W;
       cdR8V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdR8W: // global
           (_cdR8R::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdR8R::I64 == 0) goto cdR8T; else goto cdR8S;
       cdR8T: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdR8S: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdR8R::I64;
           R2 = str_rdQlZ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.70643155 UTC

[section ""data" . lvl2_rdQm1_closure" {
     lvl2_rdQm1_closure:
         const lvl2_rdQm1_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdQm1_entry() //  [R1]
         { info_tbl: [(cdR9c,
                       label: lvl2_rdQm1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR9c: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdR9g; else goto cdR9h;
       cdR9g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdR9h: // global
           (_cdR97::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdR97::I64 == 0) goto cdR99; else goto cdR98;
       cdR99: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdR98: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdR97::I64;
           I64[Sp - 24] = block_cdR9a_info;
           R3 = 0;
           R2 = msgStr1_rdQlY_closure;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdR9a() //  [R1]
         { info_tbl: [(cdR9a,
                       label: block_cdR9a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR9a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdR9k; else goto cdR9j;
       cdR9k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cdR9j: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.712505665 UTC

[section ""data" . lvl3_rdQm2_closure" {
     lvl3_rdQm2_closure:
         const lvl3_rdQm2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdQm2_entry() //  [R1]
         { info_tbl: [(cdR9E,
                       label: lvl3_rdQm2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR9E: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdR9I; else goto cdR9J;
       cdR9I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdR9J: // global
           (_cdR9z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdR9z::I64 == 0) goto cdR9B; else goto cdR9A;
       cdR9B: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdR9A: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdR9z::I64;
           I64[Sp - 24] = block_cdR9C_info;
           R3 = 0;
           R2 = str1_rdQm0_closure;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdR9C() //  [R1]
         { info_tbl: [(cdR9C,
                       label: block_cdR9C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdR9C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdR9M; else goto cdR9L;
       cdR9M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cdR9L: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.718332432 UTC

[section ""data" . lvl4_rdQm3_closure" {
     lvl4_rdQm3_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.720012482 UTC

[section ""data" . lvl5_rdQm4_closure" {
     lvl5_rdQm4_closure:
         const GHC.Types.I#_con_info;
         const 251;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.728820492 UTC

[section ""data" . real_handler_rdQm5_closure" {
     real_handler_rdQm5_closure:
         const real_handler_rdQm5_info;
         const 0;
 },
 sat_sdQq4_entry() //  [R1, R2]
         { info_tbl: [(cdRay,
                       label: sat_sdQq4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRay: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdRaC; else goto cdRaD;
       cdRaC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRaD: // global
           I64[Sp - 16] = block_cdRav_info;
           _sdQn6::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sdQn6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udRcP; else goto cdRaw;
       udRcP: // global
           call _cdRav(R1) args: 0, res: 0, upd: 0;
       cdRaw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRav() //  [R1]
         { info_tbl: [(cdRav,
                       label: block_cdRav_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRav: // global
           I64[Sp - 8] = block_cdRaB_info;
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRaB() //  [R1]
         { info_tbl: [(cdRaB,
                       label: block_cdRaB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRaB: // global
           I64[Sp] = block_cdRaI_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRaI() //  [R1]
         { info_tbl: [(cdRaI,
                       label: block_cdRaI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRaI: // global
           if (R1 & 7 == 1) goto cdRaP; else goto cdRaU;
       cdRaP: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdRaU: // global
           I64[Sp + 8] = block_cdRaS_info;
           R1 = lvl3_rdQm2_closure;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udRcQ; else goto cdRaV;
       udRcQ: // global
           call _cdRaS(R1) args: 0, res: 0, upd: 0;
       cdRaV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRaS() //  [R1]
         { info_tbl: [(cdRaS,
                       label: block_cdRaS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRaS: // global
           I64[Sp] = block_cdRb3_info;
           R2 = 1;
           R1 = I64[R1 + 7] + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRb3() //  [R1]
         { info_tbl: [(cdRb3,
                       label: block_cdRb3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRb3: // global
           P64[Sp - 24] = R1 + 16;
           P64[Sp - 16] = str1_rdQm0_closure;
           I64[Sp - 8] = 0;
           P64[Sp] = R1;
           Sp = Sp - 24;
           call _cdRc6() args: 0, res: 0, upd: 0;
     }
 },
 _cdRc6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRc6: // global
           I64[Sp - 8] = block_cdRc9_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udRcW; else goto cdRcb;
       udRcW: // global
           call _cdRc9(R1) args: 0, res: 0, upd: 0;
       cdRcb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRc9() //  [R1]
         { info_tbl: [(cdRc9,
                       label: block_cdRc9_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRc9: // global
           if (R1 & 7 == 1) goto cdRch; else goto cdRcm;
       cdRch: // global
           I8[I64[Sp + 8] + I64[Sp + 24]] = 0 :: W8;
           I64[Sp] = block_cdRbe_info;
           R1 = lvl2_rdQm1_closure;
           if (R1 & 7 != 0) goto udRcX; else goto cdRbg;
       udRcX: // global
           call _cdRbe(R1) args: 0, res: 0, upd: 0;
       cdRbg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdRcm: // global
           I64[Sp] = block_cdRck_info;
           _sdQpX::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdQpX::P64;
           if (R1 & 7 != 0) goto udRcY; else goto cdRcn;
       udRcY: // global
           call _cdRck(R1) args: 0, res: 0, upd: 0;
       cdRcn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRbe() //  [R1]
         { info_tbl: [(cdRbe,
                       label: block_cdRbe_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRbe: // global
           I64[Sp] = block_cdRbo_info;
           R2 = 1;
           R1 = I64[R1 + 7] + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRbo() //  [R1]
         { info_tbl: [(cdRbo,
                       label: block_cdRbo_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRbo: // global
           I64[Sp - 8] = 0;
           P64[Sp] = msgStr1_rdQlY_closure;
           P64[Sp + 16] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call _cdRbI() args: 0, res: 0, upd: 0;
     }
 },
 _cdRbI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRbI: // global
           I64[Sp - 8] = block_cdRbL_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udRcT; else goto cdRbN;
       udRcT: // global
           call _cdRbL(R1) args: 0, res: 0, upd: 0;
       cdRbN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRbL() //  [R1]
         { info_tbl: [(cdRbL,
                       label: block_cdRbL_info
                       rep:StackRep [True, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRbL: // global
           if (R1 & 7 == 1) goto cdRbT; else goto cdRbY;
       cdRbT: // global
           _sdQn6::P64 = P64[Sp + 56];
           _sdQpd::I64 = I64[Sp + 24];
           _sdQpr::I64 = I64[Sp + 32];
           I8[_sdQpr::I64 + I64[Sp + 8]] = 0 :: W8;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] errorBelch2(_sdQpd::I64, _sdQpr::I64);
           I64[Sp + 32] = block_cdRbC_info;
           R2 = lvl_rdQlV_closure+1;
           R1 = _sdQn6::P64;
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       cdRbY: // global
           I64[Sp] = block_cdRbW_info;
           _sdQpK::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdQpK::P64;
           if (R1 & 7 != 0) goto udRcU; else goto cdRbZ;
       udRcU: // global
           call _cdRbW(R1) args: 0, res: 0, upd: 0;
       cdRbZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRbC() //  [R1]
         { info_tbl: [(cdRbC,
                       label: block_cdRbC_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRbC: // global
           _sdQpc::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_sdQpc::P64);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdRbW() //  [R1]
         { info_tbl: [(cdRbW,
                       label: block_cdRbW_info
                       rep:StackRep [True, False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRbW: // global
           _sdQpG::I64 = I64[Sp + 8];
           _sdQpK::P64 = P64[Sp + 16];
           I8[I64[Sp + 32] + _sdQpG::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 16] = _sdQpK::P64;
           I64[Sp + 8] = _sdQpG::I64 + 1;
           Sp = Sp + 8;
           call _cdRbI() args: 0, res: 0, upd: 0;
     }
 },
 _cdRck() //  [R1]
         { info_tbl: [(cdRck,
                       label: block_cdRck_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRck: // global
           _sdQpT::I64 = I64[Sp + 24];
           _sdQpX::P64 = P64[Sp + 16];
           I8[I64[Sp + 8] + _sdQpT::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 16] = _sdQpX::P64;
           I64[Sp + 24] = _sdQpT::I64 + 1;
           Sp = Sp + 8;
           call _cdRc6() args: 0, res: 0, upd: 0;
     }
 },
 sat_sdQnx_entry() //  [R1]
         { info_tbl: [(cdRdk,
                       label: sat_sdQnx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRdk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRdo; else goto cdRdp;
       cdRdo: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRdp: // global
           I64[Sp - 24] = block_cdRdh_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udRdt; else goto cdRdi;
       udRdt: // global
           call _cdRdh(R1) args: 0, res: 0, upd: 0;
       cdRdi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRdh() //  [R1]
         { info_tbl: [(cdRdh,
                       label: block_cdRdh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRdh: // global
           _sdQnt::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdRdn_info;
           R2 = P64[Sp + 16];
           R1 = _sdQnt::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRdn() //  []
         { info_tbl: [(cdRdn,
                       label: block_cdRdn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRdn: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQnP_entry() //  [R1]
         { info_tbl: [(cdRdN,
                       label: sat_sdQnP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRdN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRdR; else goto cdRdS;
       cdRdR: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRdS: // global
           I64[Sp - 24] = block_cdRdK_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udRdW; else goto cdRdL;
       udRdW: // global
           call _cdRdK(R1) args: 0, res: 0, upd: 0;
       cdRdL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRdK() //  [R1]
         { info_tbl: [(cdRdK,
                       label: block_cdRdK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRdK: // global
           _sdQnL::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdRdQ_info;
           R2 = P64[Sp + 16];
           R1 = _sdQnL::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRdQ() //  []
         { info_tbl: [(cdRdQ,
                       label: block_cdRdQ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRdQ: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQo0_entry() //  [R1]
         { info_tbl: [(cdRec,
                       label: sat_sdQo0_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRec: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdReg; else goto cdReh;
       cdReg: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdReh: // global
           I64[Sp - 24] = block_cdRe9_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udRel; else goto cdRea;
       udRel: // global
           call _cdRe9(R1) args: 0, res: 0, upd: 0;
       cdRea: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRe9() //  [R1]
         { info_tbl: [(cdRe9,
                       label: block_cdRe9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRe9: // global
           _sdQnW::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdRef_info;
           R2 = P64[Sp + 16];
           R1 = _sdQnW::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRef() //  []
         { info_tbl: [(cdRef,
                       label: block_cdRef_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRef: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQoc_entry() //  [R1]
         { info_tbl: [(cdReB,
                       label: sat_sdQoc_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdReB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdReF; else goto cdReG;
       cdReF: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdReG: // global
           I64[Sp - 24] = block_cdRey_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udReK; else goto cdRez;
       udReK: // global
           call _cdRey(R1) args: 0, res: 0, upd: 0;
       cdRez: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRey() //  [R1]
         { info_tbl: [(cdRey,
                       label: block_cdRey_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRey: // global
           _sdQo8::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdReE_info;
           R2 = P64[Sp + 16];
           R1 = _sdQo8::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdReE() //  []
         { info_tbl: [(cdReE,
                       label: block_cdReE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdReE: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQoq_entry() //  [R1]
         { info_tbl: [(cdRf2,
                       label: sat_sdQoq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRf2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRf6; else goto cdRf7;
       cdRf6: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRf7: // global
           I64[Sp - 24] = block_cdReZ_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udRfb; else goto cdRf0;
       udRfb: // global
           call _cdReZ(R1) args: 0, res: 0, upd: 0;
       cdRf0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdReZ() //  [R1]
         { info_tbl: [(cdReZ,
                       label: block_cdReZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdReZ: // global
           _sdQom::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdRf5_info;
           R2 = P64[Sp + 16];
           R1 = _sdQom::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRf5() //  []
         { info_tbl: [(cdRf5,
                       label: block_cdRf5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRf5: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQoB_entry() //  [R1]
         { info_tbl: [(cdRfq,
                       label: sat_sdQoB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRfq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRfu; else goto cdRfv;
       cdRfu: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRfv: // global
           I64[Sp - 24] = block_cdRfn_info;
           _sdQn6::P64 = P64[R1 + 7];
           _sdQnh::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = _sdQnh::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udRfz; else goto cdRfo;
       udRfz: // global
           call _cdRfn(R1) args: 0, res: 0, upd: 0;
       cdRfo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRfn() //  [R1]
         { info_tbl: [(cdRfn,
                       label: block_cdRfn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRfn: // global
           _sdQox::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdRft_info;
           R2 = P64[Sp + 16];
           R1 = _sdQox::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRft() //  []
         { info_tbl: [(cdRft,
                       label: block_cdRft_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRft: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQoW_entry() //  [R1]
         { info_tbl: [(cdRfA,
                       label: sat_sdQoW_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRfA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdRfB; else goto cdRfC;
       cdRfB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRfC: // global
           I64[Sp - 32] = block_cdRd4_info;
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 16];
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 40];
           Sp = Sp - 32;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRd4() //  [R1]
         { info_tbl: [(cdRd4,
                       label: block_cdRd4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRd4: // global
           I64[Sp] = block_cdRd8_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRd8() //  [R1]
         { info_tbl: [(cdRd8,
                       label: block_cdRd8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRd8: // global
           if (R1 & 7 == 1) goto cdRfF; else goto cdRfK;
       cdRfF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRfI; else goto cdRfH;
       cdRfI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRfH: // global
           I64[Hp - 16] = sat_sdQnx_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdRfK: // global
           I64[Sp] = block_cdRdw_info;
           R1 = P64[Sp + 24];
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRdw() //  [R1]
         { info_tbl: [(cdRdw,
                       label: block_cdRdw_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRdw: // global
           I64[Sp - 8] = block_cdRdA_info;
           _sdQnz::P64 = P64[R1 + 7];
           _sdQnD::P64 = P64[R1 + 39];
           R1 = P64[R1 + 15];
           P64[Sp] = _sdQnD::P64;
           P64[Sp + 24] = _sdQnz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udRht; else goto cdRdB;
       udRht: // global
           call _cdRdA(R1) args: 0, res: 0, upd: 0;
       cdRdB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRdA() //  [R1]
         { info_tbl: [(cdRdA,
                       label: block_cdRdA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRdA: // global
           if (I32[I64[R1 - 1] + 20] == 17 :: W32) goto cdRfS; else goto cdRfN;
       cdRfS: // global
           _sdQnD::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdRdZ_info;
           R1 = _sdQnD::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udRhu; else goto cdRe0;
       udRhu: // global
           call _cdRdZ(R1) args: 0, res: 0, upd: 0;
       cdRe0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdRfN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRfQ; else goto cdRfP;
       cdRfQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRfP: // global
           I64[Hp - 16] = sat_sdQnP_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdRdZ() //  [R1]
         { info_tbl: [(cdRdZ,
                       label: block_cdRdZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRdZ: // global
           if (R1 & 7 == 1) goto cdRfU; else goto cdRfZ;
       cdRfU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRfX; else goto cdRfW;
       cdRfX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRfW: // global
           I64[Hp - 16] = sat_sdQo0_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdRfZ: // global
           I64[Sp] = block_cdReo_info;
           _sdQo1::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sdQo1::P64;
           if (R1 & 7 != 0) goto udRhv; else goto cdRep;
       udRhv: // global
           call _cdReo(R1) args: 0, res: 0, upd: 0;
       cdRep: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdReo() //  [R1]
         { info_tbl: [(cdReo,
                       label: block_cdReo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdReo: // global
           if (R1 & 7 == 1) goto cdRg1; else goto cdRg6;
       cdRg1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRg4; else goto cdRg3;
       cdRg4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRg3: // global
           I64[Hp - 16] = sat_sdQoc_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdRg6: // global
           I64[Sp] = block_cdReN_info;
           _sdQod::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sdQod::P64;
           if (R1 & 7 != 0) goto udRhw; else goto cdReO;
       udRhw: // global
           call _cdReN(R1) args: 0, res: 0, upd: 0;
       cdReO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdReN() //  [R1]
         { info_tbl: [(cdReN,
                       label: block_cdReN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdReN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRg9; else goto cdRg8;
       cdRg9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRg8: // global
           if (I64[R1 + 7] == 32) goto cdRgg; else goto cdRgb;
       cdRgg: // global
           Hp = Hp - 24;
           I64[Sp] = block_cdRgc_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto udRhx; else goto cdRgh;
       udRhx: // global
           call _cdRgc(R1) args: 0, res: 0, upd: 0;
       cdRgh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdRgb: // global
           I64[Hp - 16] = sat_sdQoq_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdRgc() //  [R1]
         { info_tbl: [(cdRgc,
                       label: block_cdRgc_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRgc: // global
           if (R1 & 7 == 1) goto cdRgo; else goto cdRgT;
       cdRgo: // global
           I64[Sp] = block_cdRgl_info;
           _sdQoE::P64 = P64[R1 + 15];
           R1 = GHC.IO.Handle.FD.stdout_closure;
           P64[Sp + 24] = _sdQoE::P64;
           if (R1 & 7 != 0) goto udRhy; else goto cdRgp;
       udRhy: // global
           call _cdRgl(R1) args: 0, res: 0, upd: 0;
       cdRgp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdRgT: // global
           I64[Sp] = block_cdRgR_info;
           _sdQoN::P64 = P64[R1 + 14];
           R1 = GHC.IO.Handle.FD.stdout_closure;
           P64[Sp + 24] = _sdQoN::P64;
           if (R1 & 7 != 0) goto udRhz; else goto cdRgU;
       udRhz: // global
           call _cdRgR(R1) args: 0, res: 0, upd: 0;
       cdRgU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRgl() //  [R1]
         { info_tbl: [(cdRgl,
                       label: block_cdRgl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRgl: // global
           if (R1 & 7 != 1) goto udRhB; else goto cdRgK;
       cdRgK: // global
           if (P64[Sp + 24] != P64[R1 + 15]) goto udRhB; else goto udRhs;
       udRhB: // global
           call _cdRfg() args: 0, res: 0, upd: 0;
       udRhs: // global
           Sp = Sp + 8;
           call _cdRhf() args: 0, res: 0, upd: 0;
     }
 },
 _cdRgR() //  [R1]
         { info_tbl: [(cdRgR,
                       label: block_cdRgR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRgR: // global
           if (R1 & 7 == 1) goto udRhE; else goto cdRhj;
       cdRhj: // global
           if (P64[Sp + 24] != P64[R1 + 14]) goto udRhE; else goto udRhr;
       udRhE: // global
           call _cdRfg() args: 0, res: 0, upd: 0;
       udRhr: // global
           Sp = Sp + 8;
           call _cdRhf() args: 0, res: 0, upd: 0;
     }
 },
 _cdRhf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRhf: // global
           R2 = lvl1_rdQlW_closure+1;
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdRfg() //  []
         { info_tbl: [(cdRfg,
                       label: block_cdRfg_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRfg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRgf; else goto cdRge;
       cdRgf: // global
           HpAlloc = 24;
           I64[Sp] = block_cdRfg_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdRge: // global
           I64[Hp - 16] = sat_sdQoB_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 real_handler_rdQm5_entry() //  [R2, R3]
         { info_tbl: [(cdRhM,
                       label: real_handler_rdQm5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRhM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdRhN; else goto cdRhO;
       cdRhN: // global
           R3 = R3;
           R2 = R2;
           R1 = real_handler_rdQm5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdRhO: // global
           I64[Sp - 24] = block_cdRa4_info;
           _sdQn6::P64 = R2;
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles4_closure+1;
           P64[Sp - 16] = _sdQn6::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRa4() //  []
         { info_tbl: [(cdRa4,
                       label: block_cdRa4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRa4: // global
           I64[Sp] = block_cdRa6_info;
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles2_closure+1;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRa6() //  []
         { info_tbl: [(cdRa6,
                       label: block_cdRa6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRa6: // global
           I64[Sp] = block_cdRhG_info;
           R2 = P64[Sp + 16];
           call GHC.IO.Exception.$fExceptionAsyncException_$cfromException_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRhG() //  [R1]
         { info_tbl: [(cdRhG,
                       label: block_cdRhG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRhG: // global
           if (R1 & 7 == 1) goto udRiM; else goto cdRhK;
       udRiM: // global
           Sp = Sp + 8;
           call _sdQnf() args: 0, res: 0, upd: 0;
       cdRhK: // global
           I64[Sp] = block_cdRij_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto udRiO; else goto cdRil;
       udRiO: // global
           call _cdRij(R1) args: 0, res: 0, upd: 0;
       cdRil: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRij() //  [R1]
         { info_tbl: [(cdRij,
                       label: block_cdRij_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRij: // global
           _cdRiE::P64 = R1 & 7;
           if (_cdRiE::P64 < 3) goto udRiK; else goto udRiL;
       udRiK: // global
           _sdQn6::P64 = P64[Sp + 8];
           if (_cdRiE::P64 < 2) goto cdRir; else goto cdRiv;
       cdRir: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] reportStackOverflow(CurrentTSO);
           R2 = lvl4_rdQm3_closure+1;
           R1 = _sdQn6::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdRiv: // global
           call "ccall" arg hints:  []  result hints:  [] reportHeapOverflow();
           R2 = lvl5_rdQm4_closure+1;
           R1 = _sdQn6::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       udRiL: // global
           if (_cdRiE::P64 < 4) goto udRiN; else goto cdRiD;
       udRiN: // global
           Sp = Sp + 8;
           call _sdQnf() args: 0, res: 0, upd: 0;
       cdRiD: // global
           R1 = exitInterrupted_rdPu2_closure;
           Sp = Sp + 24;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _sdQnf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sdQnf: // global
           I64[Sp - 8] = block_cdRad_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udRiR; else goto cdRae;
       udRiR: // global
           call _cdRad(R1) args: 0, res: 0, upd: 0;
       cdRae: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRad() //  [R1]
         { info_tbl: [(cdRad,
                       label: block_cdRad_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRad: // global
           I64[Sp - 16] = block_cdRai_info;
           _sdQni::P64 = P64[R1 + 7];
           R2 = _sdQni::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _sdQni::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRai() //  [R1]
         { info_tbl: [(cdRai,
                       label: block_cdRai_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRai: // global
           I64[Sp] = block_cdRam_info;
           R3 = GHC.IO.Exception.$fExceptionExitCode4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRam() //  [R1]
         { info_tbl: [(cdRam,
                       label: block_cdRam_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRam: // global
           _sdQnj::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdRhV; else goto cdRi3;
       cdRhV: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdRhY; else goto cdRhX;
       cdRhY: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRhX: // global
           I64[Hp - 56] = sat_sdQq4_info;
           _sdQn6::P64 = P64[Sp + 24];
           P64[Hp - 48] = _sdQn6::P64;
           I64[Hp - 40] = sat_sdQoW_info;
           P64[Hp - 24] = _sdQn6::P64;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdQnj::P64;
           R2 = Hp - 54;
           R1 = Hp - 40;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
       cdRi3: // global
           I64[Sp + 16] = block_cdRi1_info;
           R1 = _sdQnj::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRi1() //  [R1]
         { info_tbl: [(cdRi1,
                       label: block_cdRi1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRi1: // global
           _sdQn6::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdRi9; else goto cdRid;
       cdRi9: // global
           R2 = lvl1_rdQlW_closure+1;
           R1 = _sdQn6::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdRid: // global
           R2 = P64[R1 + 6];
           R1 = _sdQn6::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.844542115 UTC

[section ""data" . GHC.TopHandler.runIO2_closure" {
     GHC.TopHandler.runIO2_closure:
         const GHC.TopHandler.runIO2_info;
         const 0;
 },
 GHC.TopHandler.runIO2_entry() //  [R2]
         { info_tbl: [(cdRnh,
                       label: GHC.TopHandler.runIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRnh: // global
           R2 = R2;
           call GHC.TopHandler.runIO3_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.TopHandler.runIO3_closure" {
     GHC.TopHandler.runIO3_closure:
         const GHC.TopHandler.runIO3_info;
         const 0;
 },
 sat_sdQqn_entry() //  [R1]
         { info_tbl: [(cdRnt,
                       label: sat_sdQqn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRnt: // global
           R3 = P64[R1 + 7];
           R2 = safeExit_rdPtY_closure+1;
           call real_handler_rdQm5_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runIO3_entry() //  [R2]
         { info_tbl: [(cdRnw,
                       label: GHC.TopHandler.runIO3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRnw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdRnA; else goto cdRnz;
       cdRnA: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.TopHandler.runIO3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRnz: // global
           I64[Hp - 8] = sat_sdQqn_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.852674544 UTC

[section ""data" . GHC.TopHandler.topHandler_closure" {
     GHC.TopHandler.topHandler_closure:
         const GHC.TopHandler.topHandler_info;
         const 0;
 },
 GHC.TopHandler.topHandler_entry() //  [R2]
         { info_tbl: [(cdRnQ,
                       label: GHC.TopHandler.topHandler_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRnQ: // global
           R2 = R2;
           call GHC.TopHandler.runIO3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.856626678 UTC

[section ""data" . GHC.TopHandler.runNonIO1_closure" {
     GHC.TopHandler.runNonIO1_closure:
         const GHC.TopHandler.runNonIO1_info;
         const 0;
 },
 sat_sdQqs_entry() //  [R1]
         { info_tbl: [(cdRoc,
                       label: sat_sdQqs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRoc: // global
           R1 = P64[R1 + 7];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQqt_entry() //  [R1]
         { info_tbl: [(cdRof,
                       label: sat_sdQqt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRof: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdRog; else goto cdRoh;
       cdRog: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRoh: // global
           I64[Sp - 8] = block_cdRo5_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRo5() //  [R1]
         { info_tbl: [(cdRo5,
                       label: block_cdRo5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRo5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdRok; else goto cdRoj;
       cdRok: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRoj: // global
           I64[Hp - 8] = sat_sdQqs_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runNonIO1_entry() //  [R2]
         { info_tbl: [(cdRol,
                       label: GHC.TopHandler.runNonIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRol: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRop; else goto cdRoo;
       cdRop: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.TopHandler.runNonIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRoo: // global
           I64[Hp - 16] = sat_sdQqt_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.865971762 UTC

[section ""data" . GHC.TopHandler.runNonIO_closure" {
     GHC.TopHandler.runNonIO_closure:
         const GHC.TopHandler.runNonIO_info;
         const 0;
 },
 GHC.TopHandler.runNonIO_entry() //  [R2]
         { info_tbl: [(cdRoK,
                       label: GHC.TopHandler.runNonIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRoK: // global
           R2 = R2;
           call GHC.TopHandler.runNonIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.87076822 UTC

[section ""data" . GHC.TopHandler.runIO1_closure" {
     GHC.TopHandler.runIO1_closure:
         const GHC.TopHandler.runIO1_info;
         const 0;
 },
 GHC.TopHandler.runIO1_entry() //  [R2]
         { info_tbl: [(cdRoV,
                       label: GHC.TopHandler.runIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRoV: // global
           _sdQqu::P64 = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = _sdQqu::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.87458999 UTC

[section ""data" . GHC.TopHandler.runIO_closure" {
     GHC.TopHandler.runIO_closure:
         const GHC.TopHandler.runIO_info;
         const 0;
 },
 GHC.TopHandler.runIO_entry() //  [R2]
         { info_tbl: [(cdRp6,
                       label: GHC.TopHandler.runIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRp6: // global
           R2 = R2;
           call GHC.TopHandler.runIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.879133673 UTC

[section ""data" . fastExit1_rdQm6_closure" {
     fastExit1_rdQm6_closure:
         const GHC.Int.I32#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.881841412 UTC

[section ""data" . fastExit_rdPtZ_closure" {
     fastExit_rdPtZ_closure:
         const fastExit_rdPtZ_info;
         const 0;
 },
 fastExit_rdPtZ_entry() //  [R2]
         { info_tbl: [(cdRpl,
                       label: fastExit_rdPtZ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRpl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdRpm; else goto cdRpn;
       cdRpm: // global
           R2 = R2;
           R1 = fastExit_rdPtZ_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRpn: // global
           I64[Sp - 8] = block_cdRpi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udRpr; else goto cdRpj;
       udRpr: // global
           call _cdRpi(R1) args: 0, res: 0, upd: 0;
       cdRpj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRpi() //  [R1]
         { info_tbl: [(cdRpi,
                       label: block_cdRpi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRpi: // global
           R3 = I64[R1 + 7];
           R2 = fastExit1_rdQm6_closure+1;
           Sp = Sp + 8;
           call $wexitHelper_rdQlT_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.891030566 UTC

[section ""data" . GHC.TopHandler.runIOFastExit2_closure" {
     GHC.TopHandler.runIOFastExit2_closure:
         const GHC.TopHandler.runIOFastExit2_info;
         const 0;
 },
 GHC.TopHandler.runIOFastExit2_entry() //  [R2]
         { info_tbl: [(cdRpF,
                       label: GHC.TopHandler.runIOFastExit2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRpF: // global
           R2 = R2;
           call GHC.TopHandler.runIOFastExit3_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.TopHandler.runIOFastExit3_closure" {
     GHC.TopHandler.runIOFastExit3_closure:
         const GHC.TopHandler.runIOFastExit3_info;
         const 0;
 },
 sat_sdQqD_entry() //  [R1]
         { info_tbl: [(cdRpR,
                       label: sat_sdQqD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRpR: // global
           R3 = P64[R1 + 7];
           R2 = fastExit_rdPtZ_closure+1;
           call real_handler_rdQm5_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runIOFastExit3_entry() //  [R2]
         { info_tbl: [(cdRpU,
                       label: GHC.TopHandler.runIOFastExit3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRpU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdRpY; else goto cdRpX;
       cdRpY: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.TopHandler.runIOFastExit3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRpX: // global
           I64[Hp - 8] = sat_sdQqD_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIOFastExit2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.903401821 UTC

[section ""data" . GHC.TopHandler.topHandlerFastExit_closure" {
     GHC.TopHandler.topHandlerFastExit_closure:
         const GHC.TopHandler.topHandlerFastExit_info;
         const 0;
 },
 GHC.TopHandler.topHandlerFastExit_entry() //  [R2]
         { info_tbl: [(cdRqe,
                       label: GHC.TopHandler.topHandlerFastExit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRqe: // global
           R2 = R2;
           call GHC.TopHandler.runIOFastExit3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.908829624 UTC

[section ""data" . GHC.TopHandler.runIOFastExit1_closure" {
     GHC.TopHandler.runIOFastExit1_closure:
         const GHC.TopHandler.runIOFastExit1_info;
         const 0;
 },
 GHC.TopHandler.runIOFastExit1_entry() //  [R2]
         { info_tbl: [(cdRqp,
                       label: GHC.TopHandler.runIOFastExit1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRqp: // global
           _sdQqE::P64 = R2;
           R2 = GHC.TopHandler.runIOFastExit2_closure+2;
           R1 = _sdQqE::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.915210598 UTC

[section ""data" . GHC.TopHandler.runIOFastExit_closure" {
     GHC.TopHandler.runIOFastExit_closure:
         const GHC.TopHandler.runIOFastExit_info;
         const 0;
 },
 GHC.TopHandler.runIOFastExit_entry() //  [R2]
         { info_tbl: [(cdRqA,
                       label: GHC.TopHandler.runIOFastExit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRqA: // global
           R2 = R2;
           call GHC.TopHandler.runIOFastExit1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.921022086 UTC

[section ""data" . GHC.TopHandler.runMainIO3_closure" {
     GHC.TopHandler.runMainIO3_closure:
         const GHC.TopHandler.runMainIO3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.TopHandler.runMainIO3_entry() //  [R1]
         { info_tbl: [(cdRqN,
                       label: GHC.TopHandler.runMainIO3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRqN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdRqO; else goto cdRqP;
       cdRqO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRqP: // global
           (_cdRqK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdRqK::I64 == 0) goto cdRqM; else goto cdRqL;
       cdRqM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdRqL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdRqK::I64;
           R2 = GHC.IO.Exception.UserInterrupt_closure+4;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.926806174 UTC

[section ""data" . GHC.TopHandler.runMainIO4_closure" {
     GHC.TopHandler.runMainIO4_closure:
         const GHC.Int.I32#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.93136119 UTC

[section ""data" . GHC.TopHandler.runMainIO1_closure" {
     GHC.TopHandler.runMainIO1_closure:
         const GHC.TopHandler.runMainIO1_info;
         const 0;
 },
 sat_sdQrd_entry() //  [R1]
         { info_tbl: [(cdRrp,
                       label: sat_sdQrd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRrp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdRrq; else goto cdRrr;
       cdRrq: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRrr: // global
           I64[Sp - 8] = block_cdRrh_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_deRefWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRrh() //  [R1, R2]
         { info_tbl: [(cdRrh,
                       label: block_cdRrh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRrh: // global
           if (R1 == 0) goto udRrD; else goto cdRrn;
       udRrD: // global
           call _cdRro() args: 0, res: 0, upd: 0;
       cdRrn: // global
           I64[Sp] = block_cdRru_info;
           R1 = R2;
           if (R1 & 7 != 0) goto udRrE; else goto cdRrv;
       udRrE: // global
           call _cdRru(R1) args: 0, res: 0, upd: 0;
       cdRrv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRru() //  [R1]
         { info_tbl: [(cdRru,
                       label: block_cdRru_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRru: // global
           I64[Sp] = block_cdRro_info;
           R2 = GHC.TopHandler.runMainIO3_closure;
           R1 = P64[R1 + 7];
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRro() //  []
         { info_tbl: [(cdRro,
                       label: block_cdRro_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRro: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQr3_entry() //  [R1, R2]
         { info_tbl: [(cdRrT,
                       label: sat_sdQr3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRrT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdRrU; else goto cdRrV;
       cdRrU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRrV: // global
           I64[Sp - 8] = block_cdRrL_info;
           R1 = P64[R1 + 6];
           Sp = Sp - 8;
           call stg_deRefWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRrL() //  [R1, R2]
         { info_tbl: [(cdRrL,
                       label: block_cdRrL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRrL: // global
           if (R1 == 0) goto udRs7; else goto cdRrR;
       udRs7: // global
           call _cdRrS() args: 0, res: 0, upd: 0;
       cdRrR: // global
           I64[Sp] = block_cdRrY_info;
           R1 = R2;
           if (R1 & 7 != 0) goto udRs8; else goto cdRrZ;
       udRs8: // global
           call _cdRrY(R1) args: 0, res: 0, upd: 0;
       cdRrZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRrY() //  [R1]
         { info_tbl: [(cdRrY,
                       label: block_cdRrY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRrY: // global
           I64[Sp] = block_cdRrS_info;
           R2 = GHC.TopHandler.runMainIO3_closure;
           R1 = P64[R1 + 7];
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRrS() //  []
         { info_tbl: [(cdRrS,
                       label: block_cdRrS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRrS: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdQro_entry() //  [R1]
         { info_tbl: [(cdRsh,
                       label: sat_sdQro_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRsh: // global
           _sdQro::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdRsi; else goto cdRsj;
       cdRsj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdRsl; else goto cdRsk;
       cdRsl: // global
           HpAlloc = 16;
           goto cdRsi;
       cdRsi: // global
           R1 = _sdQro::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRsk: // global
           _sdQqG::P64 = P64[_sdQro::P64 + 7];
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           _sdQqL::P64 = CurrentTSO;
           P64[Hp] = _sdQqL::P64;
           I64[Sp - 16] = block_cdRr8_info;
           R2 = Hp - 7;
           R1 = _sdQqL::P64;
           P64[Sp - 8] = _sdQqG::P64;
           Sp = Sp - 16;
           call stg_mkWeakNoFinalizer#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRr8() //  [R1]
         { info_tbl: [(cdRr8,
                       label: block_cdRr8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRr8: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdRso; else goto cdRsn;
       cdRso: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRsn: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] rts_setMainThread(R1);
           I64[Hp - 88] = sat_sdQrd_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = Data.Dynamic.Dynamic_con_info;
           P64[Hp - 64] = GHC.TopHandler.runMainIO2_closure;
           P64[Hp - 56] = Hp - 87;
           I64[Hp - 48] = sat_sdQr3_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 46;
           P64[Hp - 16] = Hp - 71;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cdRsb_info;
           R3 = Hp - 6;
           R2 = GHC.TopHandler.runMainIO4_closure+1;
           call GHC.Conc.Signal.setHandler1_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRsb() //  []
         { info_tbl: [(cdRsb,
                       label: block_cdRsb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRsb: // global
           _sdQqG::P64 = P64[Sp + 8];
           (_sdQrn::I64) = call "ccall" arg hints:  [‘signed’, ‘signed’,
                                                     PtrHint]  result hints:  [‘signed’] stg_sig_install(2, (-5), 0);
           R1 = _sdQqG::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runMainIO1_entry() //  [R2]
         { info_tbl: [(cdRsq,
                       label: GHC.TopHandler.runMainIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRsq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdRsu; else goto cdRst;
       cdRsu: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.TopHandler.runMainIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRst: // global
           I64[Hp - 8] = sat_sdQro_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.95990952 UTC

[section ""data" . GHC.TopHandler.runMainIO_closure" {
     GHC.TopHandler.runMainIO_closure:
         const GHC.TopHandler.runMainIO_info;
         const 0;
 },
 GHC.TopHandler.runMainIO_entry() //  [R2]
         { info_tbl: [(cdRtl,
                       label: GHC.TopHandler.runMainIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRtl: // global
           R2 = R2;
           call GHC.TopHandler.runMainIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:05.965134631 UTC

[section ""relreadonly" . SdQrO_srt" {
     SdQrO_srt:
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const GHC.IO.Handle.FD.stderr_closure;
         const GHC.IO.Handle.hFlush2_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.TopHandler.flushStdHandles1_closure;
         const GHC.TopHandler.flushStdHandles2_closure;
         const GHC.TopHandler.flushStdHandles4_closure;
         const GHC.IO.failIO1_closure;
         const unreachable1_rdQlS_closure;
         const $wexitHelper_rdQlT_closure;
         const safeExit_rdPtY_closure;
         const msgStr1_rdQlY_closure;
         const str1_rdQm0_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const lvl2_rdQm1_closure;
         const lvl3_rdQm2_closure;
         const GHC.Conc.Sync.uncaughtExceptionHandler_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionExitCode4_closure;
         const exitInterrupted_rdPu2_closure;
         const real_handler_rdQm5_closure;
         const GHC.TopHandler.runIO3_closure;
         const GHC.TopHandler.runIO2_closure;
         const GHC.TopHandler.runNonIO1_closure;
         const GHC.TopHandler.runIO1_closure;
         const fastExit_rdPtZ_closure;
         const GHC.TopHandler.runIOFastExit3_closure;
         const GHC.TopHandler.runIOFastExit2_closure;
         const GHC.TopHandler.runIOFastExit1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
         const GHC.TopHandler.runMainIO3_closure;
         const GHC.Conc.Signal.setHandler1_closure;
         const GHC.TopHandler.runMainIO2_closure;
         const GHC.TopHandler.runMainIO1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.075140716 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:09:07.076391925 UTC

[section ""cstring" . GHC.TopHandler.$trModule4_bytes" {
     GHC.TopHandler.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.07831215 UTC

[section ""data" . GHC.TopHandler.$trModule3_closure" {
     GHC.TopHandler.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.TopHandler.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.080049299 UTC

[section ""cstring" . GHC.TopHandler.$trModule2_bytes" {
     GHC.TopHandler.$trModule2_bytes:
         I8[] [71,72,67,46,84,111,112,72,97,110,100,108,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.081955029 UTC

[section ""data" . GHC.TopHandler.$trModule1_closure" {
     GHC.TopHandler.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.TopHandler.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.083867043 UTC

[section ""data" . GHC.TopHandler.$trModule_closure" {
     GHC.TopHandler.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.TopHandler.$trModule3_closure+1;
         const GHC.TopHandler.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.086913926 UTC

[section ""data" . GHC.TopHandler.runMainIO2_closure" {
     GHC.TopHandler.runMainIO2_closure:
         const GHC.TopHandler.runMainIO2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.TopHandler.runMainIO2_entry() //  [R1]
         { info_tbl: [(cdRz5,
                       label: GHC.TopHandler.runMainIO2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRz5: // global
           if ((Sp + -104) < SpLim) (likely: False) goto cdRz6; else goto cdRz7;
       cdRz6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRz7: // global
           (_cdRyS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdRyS::I64 == 0) goto cdRyU; else goto cdRyT;
       cdRyU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdRyT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdRyS::I64;
           I64[Sp - 24] = block_cdRyV_info;
           R6 = 0;
           R5 = GHC.Types.$tcIO1_closure;
           R4 = GHC.Types.$trModule_closure;
           R3 = 14006894820825784566;
           R2 = 11571292540224541508;
           P64[Sp - 40] = GHC.Types.krep$*Arr*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cdRyV() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdRyV,
                       label: block_cdRyV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRyV: // global
           I64[Sp - 40] = block_cdRyZ_info;
           R6 = 0;
           _sdRty::P64 = R5;
           R5 = GHC.Tuple.$tc()1_closure;
           _sdRtx::P64 = R4;
           R4 = GHC.Tuple.$trModule_closure;
           _sdRtw::P64 = R3;
           R3 = 14290630168515401665;
           _sdRtv::I64 = R2;
           R2 = 2684808367141291271;
           P64[Sp - 56] = GHC.Types.krep$*_closure;
           P64[Sp - 48] = GHC.Types.[]_closure+1;
           I64[Sp - 32] = _sdRtv::I64;
           P64[Sp - 24] = _sdRtw::P64;
           P64[Sp - 16] = _sdRtx::P64;
           P64[Sp - 8] = _sdRty::P64;
           I64[Sp] = R1;
           Sp = Sp - 56;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cdRyZ() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cdRyZ,
                       label: block_cdRyZ_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRyZ: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cdRz0() args: 0, res: 0, upd: 0;
     }
 },
 _cdRz0() //  []
         { info_tbl: [(cdRz0,
                       label: block_cdRz0_info
                       rep:StackRep [True, False, False, False, True, True, False, False,
                                     False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRz0: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdRzb; else goto cdRza;
       cdRzb: // global
           HpAlloc = 96;
           I64[Sp] = block_cdRz0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cdRza: // global
           I64[Hp - 88] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = P64[Sp + 24];
           P64[Hp - 64] = P64[Sp + 32];
           I64[Hp - 56] = I64[Sp + 40];
           I64[Hp - 48] = I64[Sp + 8];
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 56];
           P64[Hp - 24] = P64[Sp + 64];
           P64[Hp - 16] = P64[Sp + 72];
           I64[Hp - 8] = I64[Sp + 80];
           I64[Hp] = I64[Sp + 48];
           R3 = Hp - 86;
           R2 = Hp - 38;
           Sp = Sp + 88;
           call Data.Typeable.Internal.mkTrApp_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.10206151 UTC

[section ""cstring" . unreachable_rdQlR_bytes" {
     unreachable_rdQlR_bytes:
         I8[] [73,102,32,121,111,117,32,99,97,110,32,114,101,97,100,32,116,104,105,115,44,32,115,104,117,116,100,111,119,110,72,97,115,107,101,108,108,65,110,100,69,120,105,116,32,100,105,100,32,110,111,116,32,101,120,105,116,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.105167999 UTC

[section ""data" . unreachable1_rdQlS_closure" {
     unreachable1_rdQlS_closure:
         const unreachable1_rdQlS_info;
         const 0;
         const 0;
         const 0;
 },
 unreachable1_rdQlS_entry() //  [R1]
         { info_tbl: [(cdRzY,
                       label: unreachable1_rdQlS_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRzY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdRzZ; else goto cdRA0;
       cdRzZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRA0: // global
           (_cdRzV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdRzV::I64 == 0) goto cdRzX; else goto cdRzW;
       cdRzX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdRzW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdRzV::I64;
           R2 = unreachable_rdQlR_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.112148486 UTC

[section ""data" . GHC.TopHandler.flushStdHandles2_closure" {
     GHC.TopHandler.flushStdHandles2_closure:
         const GHC.TopHandler.flushStdHandles2_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles2_entry() //  []
         { info_tbl: [(cdRAd,
                       label: GHC.TopHandler.flushStdHandles2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRAd: // global
           R4 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure+2;
           R3 = GHC.IO.Handle.FD.stderr_closure;
           R2 = GHC.IO.Handle.hFlush2_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.117572919 UTC

[section ""data" . GHC.TopHandler.flushStdHandles3_closure" {
     GHC.TopHandler.flushStdHandles3_closure:
         const GHC.TopHandler.flushStdHandles3_info;
 },
 GHC.TopHandler.flushStdHandles3_entry() //  [R2]
         { info_tbl: [(cdRAs,
                       label: GHC.TopHandler.flushStdHandles3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRAs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdRAt; else goto cdRAu;
       cdRAt: // global
           R2 = R2;
           R1 = GHC.TopHandler.flushStdHandles3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRAu: // global
           I64[Sp - 8] = block_cdRAp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udRAy; else goto cdRAq;
       udRAy: // global
           call _cdRAp() args: 0, res: 0, upd: 0;
       cdRAq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRAp() //  []
         { info_tbl: [(cdRAp,
                       label: block_cdRAp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRAp: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.127952537 UTC

[section ""data" . GHC.TopHandler.flushStdHandles4_closure" {
     GHC.TopHandler.flushStdHandles4_closure:
         const GHC.TopHandler.flushStdHandles4_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles4_entry() //  []
         { info_tbl: [(cdRAP,
                       label: GHC.TopHandler.flushStdHandles4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRAP: // global
           R4 = GHC.IO.Handle.Internals.flushWriteBuffer1_closure+2;
           R3 = GHC.IO.Handle.FD.stdout_closure;
           R2 = GHC.IO.Handle.hFlush2_closure;
           call GHC.IO.Handle.Internals.wantWritableHandle1_entry(R4,
                                                                  R3,
                                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.132561353 UTC

[section ""data" . GHC.TopHandler.flushStdHandles1_closure" {
     GHC.TopHandler.flushStdHandles1_closure:
         const GHC.TopHandler.flushStdHandles1_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles1_entry() //  []
         { info_tbl: [(cdRB3,
                       label: GHC.TopHandler.flushStdHandles1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRB3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdRB4; else goto cdRB5;
       cdRB4: // global
           R1 = GHC.TopHandler.flushStdHandles1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRB5: // global
           I64[Sp - 8] = block_cdRB1_info;
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles4_closure+1;
           Sp = Sp - 8;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRB1() //  []
         { info_tbl: [(cdRB1,
                       label: block_cdRB1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRB1: // global
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles2_closure+1;
           Sp = Sp + 8;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.138827955 UTC

[section ""data" . GHC.TopHandler.flushStdHandles_closure" {
     GHC.TopHandler.flushStdHandles_closure:
         const GHC.TopHandler.flushStdHandles_info;
         const 0;
 },
 GHC.TopHandler.flushStdHandles_entry() //  []
         { info_tbl: [(cdRBk,
                       label: GHC.TopHandler.flushStdHandles_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRBk: // global
           call GHC.TopHandler.flushStdHandles1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.144492226 UTC

[section ""data" . $wexitHelper_rdQlT_closure" {
     $wexitHelper_rdQlT_closure:
         const $wexitHelper_rdQlT_info;
         const 0;
 },
 sat_sdRu0_entry() //  [R1]
         { info_tbl: [(cdRBN,
                       label: sat_sdRu0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRBN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdRBO; else goto cdRBP;
       cdRBO: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRBP: // global
           I64[Sp - 8] = block_cdRBK_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udRC9; else goto cdRBL;
       udRC9: // global
           call _cdRBK(R1) args: 0, res: 0, upd: 0;
       cdRBL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRBK() //  [R1]
         { info_tbl: [(cdRBK,
                       label: block_cdRBK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRBK: // global
           I64[Sp] = block_cdRBW_info;
           _cdRBV::I64 = I64[R1 + 7];
           _udRC1::P64 = CurrentTSO;
           I64[I64[_udRC1::P64 + 24] + 16] = Sp;
           _udRC2::I64 = CurrentNursery;
           P64[_udRC2::I64 + 8] = Hp + 8;
           I64[_udRC1::P64 + 104] = I64[_udRC1::P64 + 104] - ((Hp + 8) - I64[_udRC2::I64]);
           (_udRBZ::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [‘signed’,
                                     ‘signed’]  result hints:  [] shutdownHaskellAndExit(255, _cdRBV::I64);
           (_udRC0::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udRBZ::I64);
           BaseReg = _udRC0::I64;
           _udRC3::P64 = CurrentTSO;
           _udRC4::P64 = I64[_udRC3::P64 + 24];
           Sp = I64[_udRC4::P64 + 16];
           SpLim = _udRC4::P64 + 192;
           HpAlloc = 0;
           _udRC5::I64 = CurrentNursery;
           _udRC6::I64 = I64[_udRC5::I64 + 8];
           Hp = _udRC6::I64 - 8;
           _udRC7::I64 = I64[_udRC5::I64];
           HpLim = _udRC7::I64 + ((%MO_SS_Conv_W32_W64(I32[_udRC5::I64 + 48]) << 12) - 1);
           I64[_udRC3::P64 + 104] = I64[_udRC3::P64 + 104] + (_udRC6::I64 - _udRC7::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdRBW() //  []
         { info_tbl: [(cdRBW,
                       label: block_cdRBW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRBW: // global
           R2 = unreachable1_rdQlS_closure;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdRub_entry() //  [R1]
         { info_tbl: [(cdRCq,
                       label: sat_sdRub_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRCq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdRCr; else goto cdRCs;
       cdRCr: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRCs: // global
           I64[Sp - 16] = block_cdRCn_info;
           _sdRtR::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _sdRtR::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udRCS; else goto cdRCo;
       udRCS: // global
           call _cdRCn(R1) args: 0, res: 0, upd: 0;
       cdRCo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRCn() //  [R1]
         { info_tbl: [(cdRCn,
                       label: block_cdRCn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRCn: // global
           _cdRCD::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(-I64[Sp + 8]));
           I64[Sp + 8] = block_cdRCF_info;
           Sp = Sp + 8;
           _cdRCE::I64 = I64[R1 + 7];
           _udRCK::P64 = CurrentTSO;
           I64[I64[_udRCK::P64 + 24] + 16] = Sp;
           _udRCL::I64 = CurrentNursery;
           P64[_udRCL::I64 + 8] = Hp + 8;
           I64[_udRCK::P64 + 104] = I64[_udRCK::P64 + 104] - ((Hp + 8) - I64[_udRCL::I64]);
           (_udRCI::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [‘signed’,
                                     ‘signed’]  result hints:  [] shutdownHaskellAndSignal(_cdRCD::I64, _cdRCE::I64);
           (_udRCJ::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udRCI::I64);
           BaseReg = _udRCJ::I64;
           _udRCM::P64 = CurrentTSO;
           _udRCN::P64 = I64[_udRCM::P64 + 24];
           Sp = I64[_udRCN::P64 + 16];
           SpLim = _udRCN::P64 + 192;
           HpAlloc = 0;
           _udRCO::I64 = CurrentNursery;
           _udRCP::I64 = I64[_udRCO::I64 + 8];
           Hp = _udRCP::I64 - 8;
           _udRCQ::I64 = I64[_udRCO::I64];
           HpLim = _udRCQ::I64 + ((%MO_SS_Conv_W32_W64(I32[_udRCO::I64 + 48]) << 12) - 1);
           I64[_udRCM::P64 + 104] = I64[_udRCM::P64 + 104] + (_udRCP::I64 - _udRCQ::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdRCF() //  []
         { info_tbl: [(cdRCF,
                       label: block_cdRCF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRCF: // global
           R2 = unreachable1_rdQlS_closure;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdRul_entry() //  [R1]
         { info_tbl: [(cdRD9,
                       label: sat_sdRul_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRD9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdRDa; else goto cdRDb;
       cdRDa: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRDb: // global
           I64[Sp - 16] = block_cdRD6_info;
           _sdRtR::I64 = I64[R1 + 15];
           R1 = P64[R1 + 7];
           I64[Sp - 8] = _sdRtR::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udRDy; else goto cdRD7;
       udRDy: // global
           call _cdRD6(R1) args: 0, res: 0, upd: 0;
       cdRD7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRD6() //  [R1]
         { info_tbl: [(cdRD6,
                       label: block_cdRD6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRD6: // global
           _cdRDj::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8]));
           I64[Sp + 8] = block_cdRDl_info;
           Sp = Sp + 8;
           _cdRDk::I64 = I64[R1 + 7];
           _udRDq::P64 = CurrentTSO;
           I64[I64[_udRDq::P64 + 24] + 16] = Sp;
           _udRDr::I64 = CurrentNursery;
           P64[_udRDr::I64 + 8] = Hp + 8;
           I64[_udRDq::P64 + 104] = I64[_udRDq::P64 + 104] - ((Hp + 8) - I64[_udRDr::I64]);
           (_udRDo::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  [‘signed’,
                                     ‘signed’]  result hints:  [] shutdownHaskellAndExit(_cdRDj::I64, _cdRDk::I64);
           (_udRDp::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_udRDo::I64);
           BaseReg = _udRDp::I64;
           _udRDs::P64 = CurrentTSO;
           _udRDt::P64 = I64[_udRDs::P64 + 24];
           Sp = I64[_udRDt::P64 + 16];
           SpLim = _udRDt::P64 + 192;
           HpAlloc = 0;
           _udRDu::I64 = CurrentNursery;
           _udRDv::I64 = I64[_udRDu::I64 + 8];
           Hp = _udRDv::I64 - 8;
           _udRDw::I64 = I64[_udRDu::I64];
           HpLim = _udRDw::I64 + ((%MO_SS_Conv_W32_W64(I32[_udRDu::I64 + 48]) << 12) - 1);
           I64[_udRDs::P64 + 104] = I64[_udRDs::P64 + 104] + (_udRDv::I64 - _udRDw::I64);
           call (I64[I64[Sp]])() args: 8, res: 8, upd: 8;
     }
 },
 _cdRDl() //  []
         { info_tbl: [(cdRDl,
                       label: block_cdRDl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRDl: // global
           R2 = unreachable1_rdQlS_closure;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 $wexitHelper_rdQlT_entry() //  [R2, R3]
         { info_tbl: [(cdRDC,
                       label: $wexitHelper_rdQlT_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRDC: // global
           _sdRtR::I64 = R3;
           _sdRtQ::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdRDD; else goto cdRDE;
       cdRDE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRDG; else goto cdRDF;
       cdRDG: // global
           HpAlloc = 24;
           goto cdRDD;
       cdRDD: // global
           R3 = _sdRtR::I64;
           R2 = _sdRtQ::P64;
           R1 = $wexitHelper_rdQlT_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdRDF: // global
           if (%MO_S_Lt_W64(_sdRtR::I64, 0)) goto cdRDU; else goto cdRDB;
       cdRDB: // global
           if (%MO_S_Gt_W64(_sdRtR::I64, 255)) goto cdRDU; else goto cdRDV;
       cdRDU: // global
           Hp = Hp - 24;
           P64[Sp - 16] = _sdRtQ::P64;
           I64[Sp - 8] = _sdRtR::I64;
           Sp = Sp - 24;
           call _cdRBy() args: 0, res: 0, upd: 0;
       cdRDV: // global
           I64[Hp - 16] = sat_sdRul_info;
           P64[Hp - 8] = _sdRtQ::P64;
           I64[Hp] = _sdRtR::I64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdRBy() //  []
         { info_tbl: [(cdRBy,
                       label: block_cdRBy_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRBy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRDJ; else goto cdRDI;
       cdRDJ: // global
           HpAlloc = 24;
           I64[Sp] = block_cdRBy_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdRDI: // global
           _sdRtR::I64 = I64[Sp + 16];
           if (%MO_S_Lt_W64(_sdRtR::I64, (-127))) goto cdRDQ; else goto cdRDS;
       cdRDS: // global
           if (%MO_S_Gt_W64(_sdRtR::I64, (-1))) goto cdRDQ; else goto cdRDR;
       cdRDQ: // global
           Hp = Hp - 24;
           call _cdRBD() args: 0, res: 0, upd: 0;
       cdRDR: // global
           I64[Hp - 16] = sat_sdRub_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = _sdRtR::I64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdRBD() //  []
         { info_tbl: [(cdRBD,
                       label: block_cdRBD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRBD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdRDM; else goto cdRDL;
       cdRDM: // global
           HpAlloc = 16;
           I64[Sp] = block_cdRBD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdRDL: // global
           I64[Hp - 8] = sat_sdRu0_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.187847162 UTC

[section ""data" . safeExit1_rdQlU_closure" {
     safeExit1_rdQlU_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.191046141 UTC

[section ""data" . safeExit_rdPtY_closure" {
     safeExit_rdPtY_closure:
         const safeExit_rdPtY_info;
         const 0;
 },
 safeExit_rdPtY_entry() //  [R2]
         { info_tbl: [(cdRFS,
                       label: safeExit_rdPtY_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRFS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdRFT; else goto cdRFU;
       cdRFT: // global
           R2 = R2;
           R1 = safeExit_rdPtY_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRFU: // global
           I64[Sp - 8] = block_cdRFP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udRFY; else goto cdRFQ;
       udRFY: // global
           call _cdRFP(R1) args: 0, res: 0, upd: 0;
       cdRFQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRFP() //  [R1]
         { info_tbl: [(cdRFP,
                       label: block_cdRFP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRFP: // global
           R3 = I64[R1 + 7];
           R2 = safeExit1_rdQlU_closure+1;
           Sp = Sp + 8;
           call $wexitHelper_rdQlT_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.200077116 UTC

[section ""data" . exitInterrupted_rdPu2_closure" {
     exitInterrupted_rdPu2_closure:
         const exitInterrupted_rdPu2_info;
         const 0;
         const 0;
         const 0;
 },
 exitInterrupted_rdPu2_entry() //  [R1]
         { info_tbl: [(cdRGf,
                       label: exitInterrupted_rdPu2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRGf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdRGg; else goto cdRGh;
       cdRGg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRGh: // global
           (_cdRGc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdRGc::I64 == 0) goto cdRGe; else goto cdRGd;
       cdRGe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdRGd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdRGc::I64;
           R3 = (-2);
           R2 = safeExit1_rdQlU_closure+1;
           Sp = Sp - 16;
           call $wexitHelper_rdQlT_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.206444513 UTC

[section ""data" . lvl_rdQlV_closure" {
     lvl_rdQlV_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.209157933 UTC

[section ""data" . lvl1_rdQlW_closure" {
     lvl1_rdQlW_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.211831308 UTC

[section ""cstring" . msgStr_rdQlX_bytes" {
     msgStr_rdQlX_bytes:
         I8[] [101,110,99,111,117,110,116,101,114,101,100,32,97,110,32,101,120,99,101,112,116,105,111,110,32,119,104,105,108,101,32,116,114,121,105,110,103,32,116,111,32,114,101,112,111,114,116,32,97,110,32,101,120,99,101,112,116,105,111,110,46,10,79,110,101,32,112,111,115,115,105,98,108,101,32,114,101,97,115,111,110,32,102,111,114,32,116,104,105,115,32,105,115,32,116,104,97,116,32,119,101,32,102,97,105,108,101,100,32,119,104,105,108,101,32,116,114,121,105,110,103,32,116,111,32,101,110,99,111,100,101,32,97,110,32,101,114,114,111,114,32,109,101,115,115,97,103,101,46,32,67,104,101,99,107,32,116,104,97,116,32,121,111,117,114,32,108,111,99,97,108,101,32,105,115,32,99,111,110,102,105,103,117,114,101,100,32,112,114,111,112,101,114,108,121,46]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.215289976 UTC

[section ""data" . msgStr1_rdQlY_closure" {
     msgStr1_rdQlY_closure:
         const msgStr1_rdQlY_info;
         const 0;
         const 0;
         const 0;
 },
 msgStr1_rdQlY_entry() //  [R1]
         { info_tbl: [(cdRGz,
                       label: msgStr1_rdQlY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRGz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdRGA; else goto cdRGB;
       cdRGA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRGB: // global
           (_cdRGw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdRGw::I64 == 0) goto cdRGy; else goto cdRGx;
       cdRGy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdRGx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdRGw::I64;
           R2 = msgStr_rdQlX_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.221639795 UTC

[section ""cstring" . str_rdQlZ_bytes" {
     str_rdQlZ_bytes:
         I8[] [37,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.224556968 UTC

[section ""data" . str1_rdQm0_closure" {
     str1_rdQm0_closure:
         const str1_rdQm0_info;
         const 0;
         const 0;
         const 0;
 },
 str1_rdQm0_entry() //  [R1]
         { info_tbl: [(cdRGR,
                       label: str1_rdQm0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRGR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdRGS; else goto cdRGT;
       cdRGS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRGT: // global
           (_cdRGO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdRGO::I64 == 0) goto cdRGQ; else goto cdRGP;
       cdRGQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdRGP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdRGO::I64;
           R2 = str_rdQlZ_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.23225846 UTC

[section ""data" . lvl2_rdQm1_closure" {
     lvl2_rdQm1_closure:
         const lvl2_rdQm1_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rdQm1_entry() //  [R1]
         { info_tbl: [(cdRHa,
                       label: lvl2_rdQm1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRHa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRHe; else goto cdRHf;
       cdRHe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRHf: // global
           (_cdRH5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdRH5::I64 == 0) goto cdRH7; else goto cdRH6;
       cdRH7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdRH6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdRH5::I64;
           I64[Sp - 24] = block_cdRH8_info;
           R3 = 0;
           R2 = msgStr1_rdQlY_closure;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdRH8() //  [R1]
         { info_tbl: [(cdRH8,
                       label: block_cdRH8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRH8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdRHi; else goto cdRHh;
       cdRHi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cdRHh: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.241890883 UTC

[section ""data" . lvl3_rdQm2_closure" {
     lvl3_rdQm2_closure:
         const lvl3_rdQm2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rdQm2_entry() //  [R1]
         { info_tbl: [(cdRHF,
                       label: lvl3_rdQm2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRHF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRHJ; else goto cdRHK;
       cdRHJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRHK: // global
           (_cdRHA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdRHA::I64 == 0) goto cdRHC; else goto cdRHB;
       cdRHC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdRHB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdRHA::I64;
           I64[Sp - 24] = block_cdRHD_info;
           R3 = 0;
           R2 = str1_rdQm0_closure;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdRHD() //  [R1]
         { info_tbl: [(cdRHD,
                       label: block_cdRHD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRHD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdRHN; else goto cdRHM;
       cdRHN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       cdRHM: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.249842686 UTC

[section ""data" . lvl4_rdQm3_closure" {
     lvl4_rdQm3_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.252156229 UTC

[section ""data" . lvl5_rdQm4_closure" {
     lvl5_rdQm4_closure:
         const GHC.Types.I#_con_info;
         const 251;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.265546481 UTC

[section ""data" . real_handler_rdQm5_closure" {
     real_handler_rdQm5_closure:
         const real_handler_rdQm5_info;
         const 0;
 },
 sat_sdRxp_entry() //  [R1, R2]
         { info_tbl: [(cdRIC,
                       label: sat_sdRxp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRIC: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cdRIG; else goto cdRIH;
       cdRIG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRIH: // global
           I64[Sp - 16] = block_cdRIz_info;
           _sdRur::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _sdRur::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udRKT; else goto cdRIA;
       udRKT: // global
           call _cdRIz(R1) args: 0, res: 0, upd: 0;
       cdRIA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRIz() //  [R1]
         { info_tbl: [(cdRIz,
                       label: block_cdRIz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRIz: // global
           I64[Sp - 8] = block_cdRIF_info;
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRIF() //  [R1]
         { info_tbl: [(cdRIF,
                       label: block_cdRIF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRIF: // global
           I64[Sp] = block_cdRIM_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRIM() //  [R1]
         { info_tbl: [(cdRIM,
                       label: block_cdRIM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRIM: // global
           if (R1 & 7 == 1) goto cdRIT; else goto cdRIY;
       cdRIT: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cdRIY: // global
           I64[Sp + 8] = block_cdRIW_info;
           R1 = lvl3_rdQm2_closure;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udRKU; else goto cdRIZ;
       udRKU: // global
           call _cdRIW(R1) args: 0, res: 0, upd: 0;
       cdRIZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRIW() //  [R1]
         { info_tbl: [(cdRIW,
                       label: block_cdRIW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRIW: // global
           I64[Sp] = block_cdRJ7_info;
           R2 = 1;
           R1 = I64[R1 + 7] + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRJ7() //  [R1]
         { info_tbl: [(cdRJ7,
                       label: block_cdRJ7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRJ7: // global
           P64[Sp - 24] = R1 + 16;
           P64[Sp - 16] = str1_rdQm0_closure;
           I64[Sp - 8] = 0;
           P64[Sp] = R1;
           Sp = Sp - 24;
           call _cdRKa() args: 0, res: 0, upd: 0;
     }
 },
 _cdRKa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRKa: // global
           I64[Sp - 8] = block_cdRKd_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udRL0; else goto cdRKf;
       udRL0: // global
           call _cdRKd(R1) args: 0, res: 0, upd: 0;
       cdRKf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRKd() //  [R1]
         { info_tbl: [(cdRKd,
                       label: block_cdRKd_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRKd: // global
           if (R1 & 7 == 1) goto cdRKl; else goto cdRKq;
       cdRKl: // global
           I8[I64[Sp + 8] + I64[Sp + 24]] = 0 :: W8;
           I64[Sp] = block_cdRJi_info;
           R1 = lvl2_rdQm1_closure;
           if (R1 & 7 != 0) goto udRL1; else goto cdRJk;
       udRL1: // global
           call _cdRJi(R1) args: 0, res: 0, upd: 0;
       cdRJk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdRKq: // global
           I64[Sp] = block_cdRKo_info;
           _sdRxi::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdRxi::P64;
           if (R1 & 7 != 0) goto udRL2; else goto cdRKr;
       udRL2: // global
           call _cdRKo(R1) args: 0, res: 0, upd: 0;
       cdRKr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRJi() //  [R1]
         { info_tbl: [(cdRJi,
                       label: block_cdRJi_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRJi: // global
           I64[Sp] = block_cdRJs_info;
           R2 = 1;
           R1 = I64[R1 + 7] + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRJs() //  [R1]
         { info_tbl: [(cdRJs,
                       label: block_cdRJs_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRJs: // global
           I64[Sp - 8] = 0;
           P64[Sp] = msgStr1_rdQlY_closure;
           P64[Sp + 16] = R1 + 16;
           P64[Sp + 24] = R1;
           Sp = Sp - 8;
           call _cdRJM() args: 0, res: 0, upd: 0;
     }
 },
 _cdRJM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRJM: // global
           I64[Sp - 8] = block_cdRJP_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udRKX; else goto cdRJR;
       udRKX: // global
           call _cdRJP(R1) args: 0, res: 0, upd: 0;
       cdRJR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRJP() //  [R1]
         { info_tbl: [(cdRJP,
                       label: block_cdRJP_info
                       rep:StackRep [True, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRJP: // global
           if (R1 & 7 == 1) goto cdRJX; else goto cdRK2;
       cdRJX: // global
           _sdRur::P64 = P64[Sp + 56];
           _sdRwy::I64 = I64[Sp + 24];
           _sdRwM::I64 = I64[Sp + 32];
           I8[_sdRwM::I64 + I64[Sp + 8]] = 0 :: W8;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] errorBelch2(_sdRwy::I64, _sdRwM::I64);
           I64[Sp + 32] = block_cdRJG_info;
           R2 = lvl_rdQlV_closure+1;
           R1 = _sdRur::P64;
           Sp = Sp + 32;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
       cdRK2: // global
           I64[Sp] = block_cdRK0_info;
           _sdRx5::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdRx5::P64;
           if (R1 & 7 != 0) goto udRKY; else goto cdRK3;
       udRKY: // global
           call _cdRK0(R1) args: 0, res: 0, upd: 0;
       cdRK3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRJG() //  [R1]
         { info_tbl: [(cdRJG,
                       label: block_cdRJG_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRJG: // global
           _sdRwx::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_sdRwx::P64);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdRK0() //  [R1]
         { info_tbl: [(cdRK0,
                       label: block_cdRK0_info
                       rep:StackRep [True, False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRK0: // global
           _sdRx1::I64 = I64[Sp + 8];
           _sdRx5::P64 = P64[Sp + 16];
           I8[I64[Sp + 32] + _sdRx1::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 16] = _sdRx5::P64;
           I64[Sp + 8] = _sdRx1::I64 + 1;
           Sp = Sp + 8;
           call _cdRJM() args: 0, res: 0, upd: 0;
     }
 },
 _cdRKo() //  [R1]
         { info_tbl: [(cdRKo,
                       label: block_cdRKo_info
                       rep:StackRep [True, False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRKo: // global
           _sdRxe::I64 = I64[Sp + 24];
           _sdRxi::P64 = P64[Sp + 16];
           I8[I64[Sp + 8] + _sdRxe::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 16] = _sdRxi::P64;
           I64[Sp + 24] = _sdRxe::I64 + 1;
           Sp = Sp + 8;
           call _cdRKa() args: 0, res: 0, upd: 0;
     }
 },
 sat_sdRuS_entry() //  [R1]
         { info_tbl: [(cdRLo,
                       label: sat_sdRuS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRLo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRLs; else goto cdRLt;
       cdRLs: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRLt: // global
           I64[Sp - 24] = block_cdRLl_info;
           _sdRur::P64 = P64[R1 + 7];
           _sdRuC::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdRur::P64;
           P64[Sp - 8] = _sdRuC::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udRLx; else goto cdRLm;
       udRLx: // global
           call _cdRLl(R1) args: 0, res: 0, upd: 0;
       cdRLm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRLl() //  [R1]
         { info_tbl: [(cdRLl,
                       label: block_cdRLl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRLl: // global
           _sdRuO::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdRLr_info;
           R2 = P64[Sp + 16];
           R1 = _sdRuO::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRLr() //  []
         { info_tbl: [(cdRLr,
                       label: block_cdRLr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRLr: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdRva_entry() //  [R1]
         { info_tbl: [(cdRLR,
                       label: sat_sdRva_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRLR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRLV; else goto cdRLW;
       cdRLV: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRLW: // global
           I64[Sp - 24] = block_cdRLO_info;
           _sdRur::P64 = P64[R1 + 7];
           _sdRuC::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdRur::P64;
           P64[Sp - 8] = _sdRuC::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udRM0; else goto cdRLP;
       udRM0: // global
           call _cdRLO(R1) args: 0, res: 0, upd: 0;
       cdRLP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRLO() //  [R1]
         { info_tbl: [(cdRLO,
                       label: block_cdRLO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRLO: // global
           _sdRv6::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdRLU_info;
           R2 = P64[Sp + 16];
           R1 = _sdRv6::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRLU() //  []
         { info_tbl: [(cdRLU,
                       label: block_cdRLU_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRLU: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdRvl_entry() //  [R1]
         { info_tbl: [(cdRMg,
                       label: sat_sdRvl_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRMg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRMk; else goto cdRMl;
       cdRMk: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRMl: // global
           I64[Sp - 24] = block_cdRMd_info;
           _sdRur::P64 = P64[R1 + 7];
           _sdRuC::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdRur::P64;
           P64[Sp - 8] = _sdRuC::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udRMp; else goto cdRMe;
       udRMp: // global
           call _cdRMd(R1) args: 0, res: 0, upd: 0;
       cdRMe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRMd() //  [R1]
         { info_tbl: [(cdRMd,
                       label: block_cdRMd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRMd: // global
           _sdRvh::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdRMj_info;
           R2 = P64[Sp + 16];
           R1 = _sdRvh::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRMj() //  []
         { info_tbl: [(cdRMj,
                       label: block_cdRMj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRMj: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdRvx_entry() //  [R1]
         { info_tbl: [(cdRMF,
                       label: sat_sdRvx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRMF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRMJ; else goto cdRMK;
       cdRMJ: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRMK: // global
           I64[Sp - 24] = block_cdRMC_info;
           _sdRur::P64 = P64[R1 + 7];
           _sdRuC::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdRur::P64;
           P64[Sp - 8] = _sdRuC::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udRMO; else goto cdRMD;
       udRMO: // global
           call _cdRMC(R1) args: 0, res: 0, upd: 0;
       cdRMD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRMC() //  [R1]
         { info_tbl: [(cdRMC,
                       label: block_cdRMC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRMC: // global
           _sdRvt::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdRMI_info;
           R2 = P64[Sp + 16];
           R1 = _sdRvt::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRMI() //  []
         { info_tbl: [(cdRMI,
                       label: block_cdRMI_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRMI: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdRvL_entry() //  [R1]
         { info_tbl: [(cdRN6,
                       label: sat_sdRvL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRN6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRNa; else goto cdRNb;
       cdRNa: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRNb: // global
           I64[Sp - 24] = block_cdRN3_info;
           _sdRur::P64 = P64[R1 + 7];
           _sdRuC::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdRur::P64;
           P64[Sp - 8] = _sdRuC::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udRNf; else goto cdRN4;
       udRNf: // global
           call _cdRN3(R1) args: 0, res: 0, upd: 0;
       cdRN4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRN3() //  [R1]
         { info_tbl: [(cdRN3,
                       label: block_cdRN3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRN3: // global
           _sdRvH::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdRN9_info;
           R2 = P64[Sp + 16];
           R1 = _sdRvH::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRN9() //  []
         { info_tbl: [(cdRN9,
                       label: block_cdRN9_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRN9: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdRvW_entry() //  [R1]
         { info_tbl: [(cdRNu,
                       label: sat_sdRvW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRNu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRNy; else goto cdRNz;
       cdRNy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdRNz: // global
           I64[Sp - 24] = block_cdRNr_info;
           _sdRur::P64 = P64[R1 + 7];
           _sdRuC::P64 = P64[R1 + 15];
           R1 = GHC.Conc.Sync.uncaughtExceptionHandler_closure;
           P64[Sp - 16] = _sdRur::P64;
           P64[Sp - 8] = _sdRuC::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udRND; else goto cdRNs;
       udRND: // global
           call _cdRNr(R1) args: 0, res: 0, upd: 0;
       cdRNs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRNr() //  [R1]
         { info_tbl: [(cdRNr,
                       label: block_cdRNr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRNr: // global
           _sdRvS::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = block_cdRNx_info;
           R2 = P64[Sp + 16];
           R1 = _sdRvS::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRNx() //  []
         { info_tbl: [(cdRNx,
                       label: block_cdRNx_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRNx: // global
           R2 = lvl_rdQlV_closure+1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdRwh_entry() //  [R1]
         { info_tbl: [(cdRNE,
                       label: sat_sdRwh_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRNE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdRNF; else goto cdRNG;
       cdRNF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRNG: // global
           I64[Sp - 32] = block_cdRL8_info;
           R2 = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 16];
           P64[Sp - 16] = P64[R1 + 24];
           P64[Sp - 8] = P64[R1 + 40];
           Sp = Sp - 32;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRL8() //  [R1]
         { info_tbl: [(cdRL8,
                       label: block_cdRL8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRL8: // global
           I64[Sp] = block_cdRLc_info;
           R3 = GHC.IO.Exception.$fExceptionIOException4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRLc() //  [R1]
         { info_tbl: [(cdRLc,
                       label: block_cdRLc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRLc: // global
           if (R1 & 7 == 1) goto cdRNJ; else goto cdRNO;
       cdRNJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRNM; else goto cdRNL;
       cdRNM: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRNL: // global
           I64[Hp - 16] = sat_sdRuS_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdRNO: // global
           I64[Sp] = block_cdRLA_info;
           R1 = P64[Sp + 24];
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRLA() //  [R1]
         { info_tbl: [(cdRLA,
                       label: block_cdRLA_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRLA: // global
           I64[Sp - 8] = block_cdRLE_info;
           _sdRuU::P64 = P64[R1 + 7];
           _sdRuY::P64 = P64[R1 + 39];
           R1 = P64[R1 + 15];
           P64[Sp] = _sdRuY::P64;
           P64[Sp + 24] = _sdRuU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udRPx; else goto cdRLF;
       udRPx: // global
           call _cdRLE(R1) args: 0, res: 0, upd: 0;
       cdRLF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRLE() //  [R1]
         { info_tbl: [(cdRLE,
                       label: block_cdRLE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRLE: // global
           if (I32[I64[R1 - 1] + 20] == 17 :: W32) goto cdRNW; else goto cdRNR;
       cdRNW: // global
           _sdRuY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdRM3_info;
           R1 = _sdRuY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udRPy; else goto cdRM4;
       udRPy: // global
           call _cdRM3(R1) args: 0, res: 0, upd: 0;
       cdRM4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdRNR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRNU; else goto cdRNT;
       cdRNU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRNT: // global
           I64[Hp - 16] = sat_sdRva_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdRM3() //  [R1]
         { info_tbl: [(cdRM3,
                       label: block_cdRM3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRM3: // global
           if (R1 & 7 == 1) goto cdRNY; else goto cdRO3;
       cdRNY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRO1; else goto cdRO0;
       cdRO1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRO0: // global
           I64[Hp - 16] = sat_sdRvl_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdRO3: // global
           I64[Sp] = block_cdRMs_info;
           _sdRvm::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sdRvm::P64;
           if (R1 & 7 != 0) goto udRPz; else goto cdRMt;
       udRPz: // global
           call _cdRMs(R1) args: 0, res: 0, upd: 0;
       cdRMt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRMs() //  [R1]
         { info_tbl: [(cdRMs,
                       label: block_cdRMs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRMs: // global
           if (R1 & 7 == 1) goto cdRO5; else goto cdROa;
       cdRO5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRO8; else goto cdRO7;
       cdRO8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRO7: // global
           I64[Hp - 16] = sat_sdRvx_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdROa: // global
           I64[Sp] = block_cdRMR_info;
           _sdRvy::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sdRvy::P64;
           if (R1 & 7 != 0) goto udRPA; else goto cdRMS;
       udRPA: // global
           call _cdRMR(R1) args: 0, res: 0, upd: 0;
       cdRMS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRMR() //  [R1]
         { info_tbl: [(cdRMR,
                       label: block_cdRMR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRMR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdROd; else goto cdROc;
       cdROd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdROc: // global
           if (I64[R1 + 7] == 32) goto cdROk; else goto cdROf;
       cdROk: // global
           Hp = Hp - 24;
           I64[Sp] = block_cdROg_info;
           R1 = P64[Sp + 24];
           if (R1 & 7 != 0) goto udRPB; else goto cdROl;
       udRPB: // global
           call _cdROg(R1) args: 0, res: 0, upd: 0;
       cdROl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdROf: // global
           I64[Hp - 16] = sat_sdRvL_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdROg() //  [R1]
         { info_tbl: [(cdROg,
                       label: block_cdROg_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdROg: // global
           if (R1 & 7 == 1) goto cdROs; else goto cdROX;
       cdROs: // global
           I64[Sp] = block_cdROp_info;
           _sdRvZ::P64 = P64[R1 + 15];
           R1 = GHC.IO.Handle.FD.stdout_closure;
           P64[Sp + 24] = _sdRvZ::P64;
           if (R1 & 7 != 0) goto udRPC; else goto cdROt;
       udRPC: // global
           call _cdROp(R1) args: 0, res: 0, upd: 0;
       cdROt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdROX: // global
           I64[Sp] = block_cdROV_info;
           _sdRw8::P64 = P64[R1 + 14];
           R1 = GHC.IO.Handle.FD.stdout_closure;
           P64[Sp + 24] = _sdRw8::P64;
           if (R1 & 7 != 0) goto udRPD; else goto cdROY;
       udRPD: // global
           call _cdROV(R1) args: 0, res: 0, upd: 0;
       cdROY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdROp() //  [R1]
         { info_tbl: [(cdROp,
                       label: block_cdROp_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdROp: // global
           if (R1 & 7 != 1) goto udRPF; else goto cdROO;
       cdROO: // global
           if (P64[Sp + 24] != P64[R1 + 15]) goto udRPF; else goto udRPw;
       udRPF: // global
           call _cdRNk() args: 0, res: 0, upd: 0;
       udRPw: // global
           Sp = Sp + 8;
           call _cdRPj() args: 0, res: 0, upd: 0;
     }
 },
 _cdROV() //  [R1]
         { info_tbl: [(cdROV,
                       label: block_cdROV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdROV: // global
           if (R1 & 7 == 1) goto udRPI; else goto cdRPn;
       cdRPn: // global
           if (P64[Sp + 24] != P64[R1 + 14]) goto udRPI; else goto udRPv;
       udRPI: // global
           call _cdRNk() args: 0, res: 0, upd: 0;
       udRPv: // global
           Sp = Sp + 8;
           call _cdRPj() args: 0, res: 0, upd: 0;
     }
 },
 _cdRPj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRPj: // global
           R2 = lvl1_rdQlW_closure+1;
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdRNk() //  []
         { info_tbl: [(cdRNk,
                       label: block_cdRNk_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRNk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdROj; else goto cdROi;
       cdROj: // global
           HpAlloc = 24;
           I64[Sp] = block_cdRNk_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cdROi: // global
           I64[Hp - 16] = sat_sdRvW_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 real_handler_rdQm5_entry() //  [R2, R3]
         { info_tbl: [(cdRPQ,
                       label: real_handler_rdQm5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRPQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdRPR; else goto cdRPS;
       cdRPR: // global
           R3 = R3;
           R2 = R2;
           R1 = real_handler_rdQm5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdRPS: // global
           I64[Sp - 24] = block_cdRI8_info;
           _sdRur::P64 = R2;
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles4_closure+1;
           P64[Sp - 16] = _sdRur::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRI8() //  []
         { info_tbl: [(cdRI8,
                       label: block_cdRI8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRI8: // global
           I64[Sp] = block_cdRIa_info;
           R2 = GHC.TopHandler.flushStdHandles3_closure+2;
           R1 = GHC.TopHandler.flushStdHandles2_closure+1;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRIa() //  []
         { info_tbl: [(cdRIa,
                       label: block_cdRIa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRIa: // global
           I64[Sp] = block_cdRPK_info;
           R2 = P64[Sp + 16];
           call GHC.IO.Exception.$fExceptionAsyncException_$cfromException_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRPK() //  [R1]
         { info_tbl: [(cdRPK,
                       label: block_cdRPK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRPK: // global
           if (R1 & 7 == 1) goto udRQQ; else goto cdRPO;
       udRQQ: // global
           Sp = Sp + 8;
           call _sdRuA() args: 0, res: 0, upd: 0;
       cdRPO: // global
           I64[Sp] = block_cdRQn_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto udRQS; else goto cdRQp;
       udRQS: // global
           call _cdRQn(R1) args: 0, res: 0, upd: 0;
       cdRQp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRQn() //  [R1]
         { info_tbl: [(cdRQn,
                       label: block_cdRQn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRQn: // global
           _cdRQI::P64 = R1 & 7;
           if (_cdRQI::P64 < 3) goto udRQO; else goto udRQP;
       udRQO: // global
           _sdRur::P64 = P64[Sp + 8];
           if (_cdRQI::P64 < 2) goto cdRQv; else goto cdRQz;
       cdRQv: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] reportStackOverflow(CurrentTSO);
           R2 = lvl4_rdQm3_closure+1;
           R1 = _sdRur::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdRQz: // global
           call "ccall" arg hints:  []  result hints:  [] reportHeapOverflow();
           R2 = lvl5_rdQm4_closure+1;
           R1 = _sdRur::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       udRQP: // global
           if (_cdRQI::P64 < 4) goto udRQR; else goto cdRQH;
       udRQR: // global
           Sp = Sp + 8;
           call _sdRuA() args: 0, res: 0, upd: 0;
       cdRQH: // global
           R1 = exitInterrupted_rdPu2_closure;
           Sp = Sp + 24;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _sdRuA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sdRuA: // global
           I64[Sp - 8] = block_cdRIh_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udRQV; else goto cdRIi;
       udRQV: // global
           call _cdRIh(R1) args: 0, res: 0, upd: 0;
       cdRIi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRIh() //  [R1]
         { info_tbl: [(cdRIh,
                       label: block_cdRIh_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRIh: // global
           I64[Sp - 16] = block_cdRIm_info;
           _sdRuD::P64 = P64[R1 + 7];
           R2 = _sdRuD::P64;
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = _sdRuD::P64;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRIm() //  [R1]
         { info_tbl: [(cdRIm,
                       label: block_cdRIm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRIm: // global
           I64[Sp] = block_cdRIq_info;
           R3 = GHC.IO.Exception.$fExceptionExitCode4_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdRIq() //  [R1]
         { info_tbl: [(cdRIq,
                       label: block_cdRIq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRIq: // global
           _sdRuE::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdRPZ; else goto cdRQ7;
       cdRPZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdRQ2; else goto cdRQ1;
       cdRQ2: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRQ1: // global
           I64[Hp - 56] = sat_sdRxp_info;
           _sdRur::P64 = P64[Sp + 24];
           P64[Hp - 48] = _sdRur::P64;
           I64[Hp - 40] = sat_sdRwh_info;
           P64[Hp - 24] = _sdRur::P64;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdRuE::P64;
           R2 = Hp - 54;
           R1 = Hp - 40;
           Sp = Sp + 40;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
       cdRQ7: // global
           I64[Sp + 16] = block_cdRQ5_info;
           R1 = _sdRuE::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRQ5() //  [R1]
         { info_tbl: [(cdRQ5,
                       label: block_cdRQ5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRQ5: // global
           _sdRur::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdRQd; else goto cdRQh;
       cdRQd: // global
           R2 = lvl1_rdQlW_closure+1;
           R1 = _sdRur::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
       cdRQh: // global
           R2 = P64[R1 + 6];
           R1 = _sdRur::P64;
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.378928766 UTC

[section ""data" . GHC.TopHandler.runIO2_closure" {
     GHC.TopHandler.runIO2_closure:
         const GHC.TopHandler.runIO2_info;
         const 0;
 },
 GHC.TopHandler.runIO2_entry() //  [R2]
         { info_tbl: [(cdRWc,
                       label: GHC.TopHandler.runIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRWc: // global
           R2 = R2;
           call GHC.TopHandler.runIO3_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.TopHandler.runIO3_closure" {
     GHC.TopHandler.runIO3_closure:
         const GHC.TopHandler.runIO3_info;
         const 0;
 },
 sat_sdRxI_entry() //  [R1]
         { info_tbl: [(cdRWo,
                       label: sat_sdRxI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRWo: // global
           R3 = P64[R1 + 7];
           R2 = safeExit_rdPtY_closure+1;
           call real_handler_rdQm5_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runIO3_entry() //  [R2]
         { info_tbl: [(cdRWr,
                       label: GHC.TopHandler.runIO3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRWr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdRWv; else goto cdRWu;
       cdRWv: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.TopHandler.runIO3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRWu: // global
           I64[Hp - 8] = sat_sdRxI_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.387709137 UTC

[section ""data" . GHC.TopHandler.topHandler_closure" {
     GHC.TopHandler.topHandler_closure:
         const GHC.TopHandler.topHandler_info;
         const 0;
 },
 GHC.TopHandler.topHandler_entry() //  [R2]
         { info_tbl: [(cdRWM,
                       label: GHC.TopHandler.topHandler_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRWM: // global
           R2 = R2;
           call GHC.TopHandler.runIO3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.391889026 UTC

[section ""data" . GHC.TopHandler.runNonIO1_closure" {
     GHC.TopHandler.runNonIO1_closure:
         const GHC.TopHandler.runNonIO1_info;
         const 0;
 },
 sat_sdRxN_entry() //  [R1]
         { info_tbl: [(cdRX8,
                       label: sat_sdRxN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRX8: // global
           R1 = P64[R1 + 7];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdRxO_entry() //  [R1]
         { info_tbl: [(cdRXb,
                       label: sat_sdRxO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRXb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdRXc; else goto cdRXd;
       cdRXc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRXd: // global
           I64[Sp - 8] = block_cdRX1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRX1() //  [R1]
         { info_tbl: [(cdRX1,
                       label: block_cdRX1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRX1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdRXg; else goto cdRXf;
       cdRXg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRXf: // global
           I64[Hp - 8] = sat_sdRxN_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runNonIO1_entry() //  [R2]
         { info_tbl: [(cdRXh,
                       label: GHC.TopHandler.runNonIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRXh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdRXl; else goto cdRXk;
       cdRXl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.TopHandler.runNonIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRXk: // global
           I64[Hp - 16] = sat_sdRxO_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = Hp - 16;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.401837677 UTC

[section ""data" . GHC.TopHandler.runNonIO_closure" {
     GHC.TopHandler.runNonIO_closure:
         const GHC.TopHandler.runNonIO_info;
         const 0;
 },
 GHC.TopHandler.runNonIO_entry() //  [R2]
         { info_tbl: [(cdRXJ,
                       label: GHC.TopHandler.runNonIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRXJ: // global
           R2 = R2;
           call GHC.TopHandler.runNonIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.405682999 UTC

[section ""data" . GHC.TopHandler.runIO1_closure" {
     GHC.TopHandler.runIO1_closure:
         const GHC.TopHandler.runIO1_info;
         const 0;
 },
 GHC.TopHandler.runIO1_entry() //  [R2]
         { info_tbl: [(cdRXU,
                       label: GHC.TopHandler.runIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRXU: // global
           _sdRxP::P64 = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = _sdRxP::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.409582144 UTC

[section ""data" . GHC.TopHandler.runIO_closure" {
     GHC.TopHandler.runIO_closure:
         const GHC.TopHandler.runIO_info;
         const 0;
 },
 GHC.TopHandler.runIO_entry() //  [R2]
         { info_tbl: [(cdRY5,
                       label: GHC.TopHandler.runIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRY5: // global
           R2 = R2;
           call GHC.TopHandler.runIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.414275729 UTC

[section ""data" . fastExit1_rdQm6_closure" {
     fastExit1_rdQm6_closure:
         const GHC.Int.I32#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.416569214 UTC

[section ""data" . fastExit_rdPtZ_closure" {
     fastExit_rdPtZ_closure:
         const fastExit_rdPtZ_info;
         const 0;
 },
 fastExit_rdPtZ_entry() //  [R2]
         { info_tbl: [(cdRYk,
                       label: fastExit_rdPtZ_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRYk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdRYl; else goto cdRYm;
       cdRYl: // global
           R2 = R2;
           R1 = fastExit_rdPtZ_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRYm: // global
           I64[Sp - 8] = block_cdRYh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udRYq; else goto cdRYi;
       udRYq: // global
           call _cdRYh(R1) args: 0, res: 0, upd: 0;
       cdRYi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdRYh() //  [R1]
         { info_tbl: [(cdRYh,
                       label: block_cdRYh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRYh: // global
           R3 = I64[R1 + 7];
           R2 = fastExit1_rdQm6_closure+1;
           Sp = Sp + 8;
           call $wexitHelper_rdQlT_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.423117916 UTC

[section ""data" . GHC.TopHandler.runIOFastExit2_closure" {
     GHC.TopHandler.runIOFastExit2_closure:
         const GHC.TopHandler.runIOFastExit2_info;
         const 0;
 },
 GHC.TopHandler.runIOFastExit2_entry() //  [R2]
         { info_tbl: [(cdRYF,
                       label: GHC.TopHandler.runIOFastExit2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRYF: // global
           R2 = R2;
           call GHC.TopHandler.runIOFastExit3_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.TopHandler.runIOFastExit3_closure" {
     GHC.TopHandler.runIOFastExit3_closure:
         const GHC.TopHandler.runIOFastExit3_info;
         const 0;
 },
 sat_sdRxY_entry() //  [R1]
         { info_tbl: [(cdRYR,
                       label: sat_sdRxY_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRYR: // global
           R3 = P64[R1 + 7];
           R2 = fastExit_rdPtZ_closure+1;
           call real_handler_rdQm5_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runIOFastExit3_entry() //  [R2]
         { info_tbl: [(cdRYU,
                       label: GHC.TopHandler.runIOFastExit3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRYU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdRYY; else goto cdRYX;
       cdRYY: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.TopHandler.runIOFastExit3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdRYX: // global
           I64[Hp - 8] = sat_sdRxY_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIOFastExit2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.431534819 UTC

[section ""data" . GHC.TopHandler.topHandlerFastExit_closure" {
     GHC.TopHandler.topHandlerFastExit_closure:
         const GHC.TopHandler.topHandlerFastExit_info;
         const 0;
 },
 GHC.TopHandler.topHandlerFastExit_entry() //  [R2]
         { info_tbl: [(cdRZf,
                       label: GHC.TopHandler.topHandlerFastExit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRZf: // global
           R2 = R2;
           call GHC.TopHandler.runIOFastExit3_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.435217759 UTC

[section ""data" . GHC.TopHandler.runIOFastExit1_closure" {
     GHC.TopHandler.runIOFastExit1_closure:
         const GHC.TopHandler.runIOFastExit1_info;
         const 0;
 },
 GHC.TopHandler.runIOFastExit1_entry() //  [R2]
         { info_tbl: [(cdRZq,
                       label: GHC.TopHandler.runIOFastExit1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRZq: // global
           _sdRxZ::P64 = R2;
           R2 = GHC.TopHandler.runIOFastExit2_closure+2;
           R1 = _sdRxZ::P64;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.439717977 UTC

[section ""data" . GHC.TopHandler.runIOFastExit_closure" {
     GHC.TopHandler.runIOFastExit_closure:
         const GHC.TopHandler.runIOFastExit_info;
         const 0;
 },
 GHC.TopHandler.runIOFastExit_entry() //  [R2]
         { info_tbl: [(cdRZB,
                       label: GHC.TopHandler.runIOFastExit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRZB: // global
           R2 = R2;
           call GHC.TopHandler.runIOFastExit1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.443469216 UTC

[section ""data" . GHC.TopHandler.runMainIO3_closure" {
     GHC.TopHandler.runMainIO3_closure:
         const GHC.TopHandler.runMainIO3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.TopHandler.runMainIO3_entry() //  [R1]
         { info_tbl: [(cdRZO,
                       label: GHC.TopHandler.runMainIO3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdRZO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdRZP; else goto cdRZQ;
       cdRZP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRZQ: // global
           (_cdRZL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdRZL::I64 == 0) goto cdRZN; else goto cdRZM;
       cdRZN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdRZM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdRZL::I64;
           R2 = GHC.IO.Exception.UserInterrupt_closure+4;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionAsyncException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.448127279 UTC

[section ""data" . GHC.TopHandler.runMainIO4_closure" {
     GHC.TopHandler.runMainIO4_closure:
         const GHC.Int.I32#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.451360243 UTC

[section ""data" . GHC.TopHandler.runMainIO1_closure" {
     GHC.TopHandler.runMainIO1_closure:
         const GHC.TopHandler.runMainIO1_info;
         const 0;
 },
 sat_sdRyy_entry() //  [R1]
         { info_tbl: [(cdS0s,
                       label: sat_sdRyy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdS0s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdS0t; else goto cdS0u;
       cdS0t: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdS0u: // global
           I64[Sp - 8] = block_cdS0k_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_deRefWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdS0k() //  [R1, R2]
         { info_tbl: [(cdS0k,
                       label: block_cdS0k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdS0k: // global
           if (R1 == 0) goto udS0G; else goto cdS0q;
       udS0G: // global
           call _cdS0r() args: 0, res: 0, upd: 0;
       cdS0q: // global
           I64[Sp] = block_cdS0x_info;
           R1 = R2;
           if (R1 & 7 != 0) goto udS0H; else goto cdS0y;
       udS0H: // global
           call _cdS0x(R1) args: 0, res: 0, upd: 0;
       cdS0y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdS0x() //  [R1]
         { info_tbl: [(cdS0x,
                       label: block_cdS0x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdS0x: // global
           I64[Sp] = block_cdS0r_info;
           R2 = GHC.TopHandler.runMainIO3_closure;
           R1 = P64[R1 + 7];
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdS0r() //  []
         { info_tbl: [(cdS0r,
                       label: block_cdS0r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdS0r: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdRyo_entry() //  [R1, R2]
         { info_tbl: [(cdS0W,
                       label: sat_sdRyo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdS0W: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdS0X; else goto cdS0Y;
       cdS0X: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdS0Y: // global
           I64[Sp - 8] = block_cdS0O_info;
           R1 = P64[R1 + 6];
           Sp = Sp - 8;
           call stg_deRefWeak#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdS0O() //  [R1, R2]
         { info_tbl: [(cdS0O,
                       label: block_cdS0O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdS0O: // global
           if (R1 == 0) goto udS1a; else goto cdS0U;
       udS1a: // global
           call _cdS0V() args: 0, res: 0, upd: 0;
       cdS0U: // global
           I64[Sp] = block_cdS11_info;
           R1 = R2;
           if (R1 & 7 != 0) goto udS1b; else goto cdS12;
       udS1b: // global
           call _cdS11(R1) args: 0, res: 0, upd: 0;
       cdS12: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdS11() //  [R1]
         { info_tbl: [(cdS11,
                       label: block_cdS11_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdS11: // global
           I64[Sp] = block_cdS0V_info;
           R2 = GHC.TopHandler.runMainIO3_closure;
           R1 = P64[R1 + 7];
           call stg_killThread#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdS0V() //  []
         { info_tbl: [(cdS0V,
                       label: block_cdS0V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdS0V: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdRyJ_entry() //  [R1]
         { info_tbl: [(cdS1k,
                       label: sat_sdRyJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdS1k: // global
           _sdRyJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdS1l; else goto cdS1m;
       cdS1m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdS1o; else goto cdS1n;
       cdS1o: // global
           HpAlloc = 16;
           goto cdS1l;
       cdS1l: // global
           R1 = _sdRyJ::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdS1n: // global
           _sdRy1::P64 = P64[_sdRyJ::P64 + 7];
           I64[Hp - 8] = GHC.Conc.Sync.ThreadId_con_info;
           _sdRy6::P64 = CurrentTSO;
           P64[Hp] = _sdRy6::P64;
           I64[Sp - 16] = block_cdS0b_info;
           R2 = Hp - 7;
           R1 = _sdRy6::P64;
           P64[Sp - 8] = _sdRy1::P64;
           Sp = Sp - 16;
           call stg_mkWeakNoFinalizer#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdS0b() //  [R1]
         { info_tbl: [(cdS0b,
                       label: block_cdS0b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdS0b: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdS1r; else goto cdS1q;
       cdS1r: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdS1q: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] rts_setMainThread(R1);
           I64[Hp - 88] = sat_sdRyy_info;
           P64[Hp - 80] = R1;
           I64[Hp - 72] = Data.Dynamic.Dynamic_con_info;
           P64[Hp - 64] = GHC.TopHandler.runMainIO2_closure;
           P64[Hp - 56] = Hp - 87;
           I64[Hp - 48] = sat_sdRyo_info;
           P64[Hp - 40] = R1;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 46;
           P64[Hp - 16] = Hp - 71;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           I64[Sp] = block_cdS1e_info;
           R3 = Hp - 6;
           R2 = GHC.TopHandler.runMainIO4_closure+1;
           call GHC.Conc.Signal.setHandler1_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdS1e() //  []
         { info_tbl: [(cdS1e,
                       label: block_cdS1e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdS1e: // global
           _sdRy1::P64 = P64[Sp + 8];
           (_sdRyI::I64) = call "ccall" arg hints:  [‘signed’, ‘signed’,
                                                     PtrHint]  result hints:  [‘signed’] stg_sig_install(2, (-5), 0);
           R1 = _sdRy1::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.TopHandler.runMainIO1_entry() //  [R2]
         { info_tbl: [(cdS1t,
                       label: GHC.TopHandler.runMainIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdS1t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdS1x; else goto cdS1w;
       cdS1x: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.TopHandler.runMainIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdS1w: // global
           I64[Hp - 8] = sat_sdRyJ_info;
           P64[Hp] = R2;
           R2 = GHC.TopHandler.runIO2_closure+2;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.474997529 UTC

[section ""data" . GHC.TopHandler.runMainIO_closure" {
     GHC.TopHandler.runMainIO_closure:
         const GHC.TopHandler.runMainIO_info;
         const 0;
 },
 GHC.TopHandler.runMainIO_entry() //  [R2]
         { info_tbl: [(cdS2G,
                       label: GHC.TopHandler.runMainIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdS2G: // global
           R2 = R2;
           call GHC.TopHandler.runMainIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:09:07.478186137 UTC

[section ""relreadonly" . SdRze_srt" {
     SdRze_srt:
         const Data.Typeable.Internal.mkTrApp_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const GHC.IO.Handle.Internals.wantWritableHandle1_closure;
         const GHC.IO.Handle.FD.stderr_closure;
         const GHC.IO.Handle.hFlush2_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.TopHandler.flushStdHandles1_closure;
         const GHC.TopHandler.flushStdHandles2_closure;
         const GHC.TopHandler.flushStdHandles4_closure;
         const GHC.IO.failIO1_closure;
         const unreachable1_rdQlS_closure;
         const $wexitHelper_rdQlT_closure;
         const safeExit_rdPtY_closure;
         const msgStr1_rdQlY_closure;
         const str1_rdQm0_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionIOException4_closure;
         const lvl2_rdQm1_closure;
         const lvl3_rdQm2_closure;
         const GHC.Conc.Sync.uncaughtExceptionHandler_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$cfromException_closure;
         const GHC.IO.Exception.$fExceptionExitCode4_closure;
         const exitInterrupted_rdPu2_closure;
         const real_handler_rdQm5_closure;
         const GHC.TopHandler.runIO3_closure;
         const GHC.TopHandler.runIO2_closure;
         const GHC.TopHandler.runNonIO1_closure;
         const GHC.TopHandler.runIO1_closure;
         const fastExit_rdPtZ_closure;
         const GHC.TopHandler.runIOFastExit3_closure;
         const GHC.TopHandler.runIOFastExit2_closure;
         const GHC.TopHandler.runIOFastExit1_closure;
         const GHC.IO.Exception.$fExceptionAsyncException_$ctoException_closure;
         const GHC.TopHandler.runMainIO3_closure;
         const GHC.Conc.Signal.setHandler1_closure;
         const GHC.TopHandler.runMainIO2_closure;
         const GHC.TopHandler.runMainIO1_closure;
 }]

