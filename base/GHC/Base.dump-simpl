
==================== Tidy Core ====================
2018-03-16 15:54:41.898852675 UTC

Result size of Tidy Core
  = {terms: 5,827, types: 12,401, coercions: 555, joins: 1/95}

-- RHS size: {terms: 6, types: 41, coercions: 0, joins: 0/0}
GHC.Base.$p1Monad :: forall (m :: * -> *). Monad m => Applicative m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>,
 RULES: Built in rule for GHC.Base.$p1Monad: "Class op $p1Monad"]
GHC.Base.$p1Monad
  = \ (@ (m_a37u :: * -> *)) (v_B1 :: Monad m_a37u) ->
      case v_B1 of v_B1 { GHC.Base.C:Monad v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 41, coercions: 0, joins: 0/0}
>>=
  :: forall (m :: * -> *).
     Monad m =>
     forall a b. m a -> (a -> m b) -> m b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>,
 RULES: Built in rule for >>=: "Class op >>="]
>>=
  = \ (@ (m_a37u :: * -> *)) (v_B1 :: Monad m_a37u) ->
      case v_B1 of v_B1 { GHC.Base.C:Monad v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 41, coercions: 0, joins: 0/0}
>>
  :: forall (m :: * -> *). Monad m => forall a b. m a -> m b -> m b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>,
 RULES: Built in rule for >>: "Class op >>"]
>>
  = \ (@ (m_a37u :: * -> *)) (v_B1 :: Monad m_a37u) ->
      case v_B1 of v_B1 { GHC.Base.C:Monad v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 41, coercions: 0, joins: 0/0}
return :: forall (m :: * -> *). Monad m => forall a. a -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>,
 RULES: Built in rule for return: "Class op return"]
return
  = \ (@ (m_a37u :: * -> *)) (v_B1 :: Monad m_a37u) ->
      case v_B1 of v_B1 { GHC.Base.C:Monad v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 41, coercions: 0, joins: 0/0}
fail :: forall (m :: * -> *). Monad m => forall a. String -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>,
 RULES: Built in rule for fail: "Class op fail"]
fail
  = \ (@ (m_a37u :: * -> *)) (v_B1 :: Monad m_a37u) ->
      case v_B1 of v_B1 { GHC.Base.C:Monad v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B6
      }

-- RHS size: {terms: 6, types: 27, coercions: 0, joins: 0/0}
fmap
  :: forall (f :: * -> *).
     Functor f =>
     forall a b. (a -> b) -> f a -> f b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),U(U,A)>,
 RULES: Built in rule for fmap: "Class op fmap"]
fmap
  = \ (@ (f_a37T :: * -> *)) (v_B1 :: Functor f_a37T) ->
      case v_B1 of v_B1 { GHC.Base.C:Functor v_B2 v_B3 -> v_B2 }

-- RHS size: {terms: 6, types: 27, coercions: 0, joins: 0/0}
<$
  :: forall (f :: * -> *). Functor f => forall a b. a -> f b -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),U(A,U)>,
 RULES: Built in rule for <$: "Class op <$"]
<$
  = \ (@ (f_a37T :: * -> *)) (v_B1 :: Functor f_a37T) ->
      case v_B1 of v_B1 { GHC.Base.C:Functor v_B2 v_B3 -> v_B3 }

-- RHS size: {terms: 6, types: 61, coercions: 0, joins: 0/0}
GHC.Base.$p1Applicative
  :: forall (f :: * -> *). Applicative f => Functor f
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLL),U(U,A,A,A,A,A)>,
 RULES: Built in rule for GHC.Base.$p1Applicative: "Class op $p1Applicative"]
GHC.Base.$p1Applicative
  = \ (@ (f_a37E :: * -> *)) (v_B1 :: Applicative f_a37E) ->
      case v_B1 of v_B1
      { GHC.Base.C:Applicative v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 61, coercions: 0, joins: 0/0}
pure :: forall (f :: * -> *). Applicative f => forall a. a -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLL),U(A,U,A,A,A,A)>,
 RULES: Built in rule for pure: "Class op pure"]
pure
  = \ (@ (f_a37E :: * -> *)) (v_B1 :: Applicative f_a37E) ->
      case v_B1 of v_B1
      { GHC.Base.C:Applicative v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 61, coercions: 0, joins: 0/0}
<*>
  :: forall (f :: * -> *).
     Applicative f =>
     forall a b. f (a -> b) -> f a -> f b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLL),U(A,A,U,A,A,A)>,
 RULES: Built in rule for <*>: "Class op <*>"]
<*>
  = \ (@ (f_a37E :: * -> *)) (v_B1 :: Applicative f_a37E) ->
      case v_B1 of v_B1
      { GHC.Base.C:Applicative v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 61, coercions: 0, joins: 0/0}
liftA2
  :: forall (f :: * -> *).
     Applicative f =>
     forall a b c. (a -> b -> c) -> f a -> f b -> f c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLL),U(A,A,A,U,A,A)>,
 RULES: Built in rule for liftA2: "Class op liftA2"]
liftA2
  = \ (@ (f_a37E :: * -> *)) (v_B1 :: Applicative f_a37E) ->
      case v_B1 of v_B1
      { GHC.Base.C:Applicative v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 61, coercions: 0, joins: 0/0}
*>
  :: forall (f :: * -> *).
     Applicative f =>
     forall a b. f a -> f b -> f b
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSL),U(A,A,A,A,U,A)>,
 RULES: Built in rule for *>: "Class op *>"]
*>
  = \ (@ (f_a37E :: * -> *)) (v_B1 :: Applicative f_a37E) ->
      case v_B1 of v_B1
      { GHC.Base.C:Applicative v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B6
      }

-- RHS size: {terms: 6, types: 61, coercions: 0, joins: 0/0}
<*
  :: forall (f :: * -> *).
     Applicative f =>
     forall a b. f a -> f b -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLS),U(A,A,A,A,A,U)>,
 RULES: Built in rule for <*: "Class op <*"]
<*
  = \ (@ (f_a37E :: * -> *)) (v_B1 :: Applicative f_a37E) ->
      case v_B1 of v_B1
      { GHC.Base.C:Applicative v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 ->
      v_B7
      }

-- RHS size: {terms: 6, types: 19, coercions: 0, joins: 0/0}
<> :: forall a. Semigroup a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLL),U(U,A,A)>,
 RULES: Built in rule for <>: "Class op <>"]
<>
  = \ (@ a_a37Z) (v_B1 :: Semigroup a_a37Z) ->
      case v_B1 of v_B1 { GHC.Base.C:Semigroup v_B2 v_B3 v_B4 -> v_B2 }

-- RHS size: {terms: 6, types: 19, coercions: 0, joins: 0/0}
sconcat :: forall a. Semigroup a => NonEmpty a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSL),U(A,U,A)>,
 RULES: Built in rule for sconcat: "Class op sconcat"]
sconcat
  = \ (@ a_a37Z) (v_B1 :: Semigroup a_a37Z) ->
      case v_B1 of v_B1 { GHC.Base.C:Semigroup v_B2 v_B3 v_B4 -> v_B3 }

-- RHS size: {terms: 6, types: 19, coercions: 0, joins: 0/0}
stimes
  :: forall a. Semigroup a => forall b. Integral b => b -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLS),U(A,A,U)>,
 RULES: Built in rule for stimes: "Class op stimes"]
stimes
  = \ (@ a_a37Z) (v_B1 :: Semigroup a_a37Z) ->
      case v_B1 of v_B1 { GHC.Base.C:Semigroup v_B2 v_B3 v_B4 -> v_B4 }

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
GHC.Base.$p1Monoid :: forall a. Monoid a => Semigroup a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>,
 RULES: Built in rule for GHC.Base.$p1Monoid: "Class op $p1Monoid"]
GHC.Base.$p1Monoid
  = \ (@ a_a37Y) (v_B1 :: Monoid a_a37Y) ->
      case v_B1 of v_B1 { GHC.Base.C:Monoid v_B2 v_B3 v_B4 v_B5 -> v_B2 }

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
mempty :: forall a. Monoid a => a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>,
 RULES: Built in rule for mempty: "Class op mempty"]
mempty
  = \ (@ a_a37Y) (v_B1 :: Monoid a_a37Y) ->
      case v_B1 of v_B1 { GHC.Base.C:Monoid v_B2 v_B3 v_B4 v_B5 -> v_B3 }

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
mappend :: forall a. Monoid a => a -> a -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>,
 RULES: Built in rule for mappend: "Class op mappend"]
mappend
  = \ (@ a_a37Y) (v_B1 :: Monoid a_a37Y) ->
      case v_B1 of v_B1 { GHC.Base.C:Monoid v_B2 v_B3 v_B4 v_B5 -> v_B4 }

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
mconcat :: forall a. Monoid a => [a] -> a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>,
 RULES: Built in rule for mconcat: "Class op mconcat"]
mconcat
  = \ (@ a_a37Y) (v_B1 :: Monoid a_a37Y) ->
      case v_B1 of v_B1 { GHC.Base.C:Monoid v_B2 v_B3 v_B4 v_B5 -> v_B5 }

-- RHS size: {terms: 6, types: 24, coercions: 0, joins: 0/0}
GHC.Base.$p1MonadPlus
  :: forall (m :: * -> *). MonadPlus m => Alternative m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>,
 RULES: Built in rule for GHC.Base.$p1MonadPlus: "Class op $p1MonadPlus"]
GHC.Base.$p1MonadPlus
  = \ (@ (m_a37g :: * -> *)) (v_B1 :: MonadPlus m_a37g) ->
      case v_B1 of v_B1 { GHC.Base.C:MonadPlus v_B2 v_B3 v_B4 v_B5 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 24, coercions: 0, joins: 0/0}
GHC.Base.$p2MonadPlus
  :: forall (m :: * -> *). MonadPlus m => Monad m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>,
 RULES: Built in rule for GHC.Base.$p2MonadPlus: "Class op $p2MonadPlus"]
GHC.Base.$p2MonadPlus
  = \ (@ (m_a37g :: * -> *)) (v_B1 :: MonadPlus m_a37g) ->
      case v_B1 of v_B1 { GHC.Base.C:MonadPlus v_B2 v_B3 v_B4 v_B5 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 24, coercions: 0, joins: 0/0}
mzero :: forall (m :: * -> *). MonadPlus m => forall a. m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>,
 RULES: Built in rule for mzero: "Class op mzero"]
mzero
  = \ (@ (m_a37g :: * -> *)) (v_B1 :: MonadPlus m_a37g) ->
      case v_B1 of v_B1 { GHC.Base.C:MonadPlus v_B2 v_B3 v_B4 v_B5 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 24, coercions: 0, joins: 0/0}
mplus
  :: forall (m :: * -> *). MonadPlus m => forall a. m a -> m a -> m a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>,
 RULES: Built in rule for mplus: "Class op mplus"]
mplus
  = \ (@ (m_a37g :: * -> *)) (v_B1 :: MonadPlus m_a37g) ->
      case v_B1 of v_B1 { GHC.Base.C:MonadPlus v_B2 v_B3 v_B4 v_B5 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 36, coercions: 0, joins: 0/0}
GHC.Base.$p1Alternative
  :: forall (f :: * -> *). Alternative f => Applicative f
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLL),U(U,A,A,A,A)>,
 RULES: Built in rule for GHC.Base.$p1Alternative: "Class op $p1Alternative"]
GHC.Base.$p1Alternative
  = \ (@ (f_a37j :: * -> *)) (v_B1 :: Alternative f_a37j) ->
      case v_B1 of v_B1
      { GHC.Base.C:Alternative v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 36, coercions: 0, joins: 0/0}
empty :: forall (f :: * -> *). Alternative f => forall a. f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLL),U(A,U,A,A,A)>,
 RULES: Built in rule for empty: "Class op empty"]
empty
  = \ (@ (f_a37j :: * -> *)) (v_B1 :: Alternative f_a37j) ->
      case v_B1 of v_B1
      { GHC.Base.C:Alternative v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 36, coercions: 0, joins: 0/0}
<|>
  :: forall (f :: * -> *).
     Alternative f =>
     forall a. f a -> f a -> f a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLL),U(A,A,U,A,A)>,
 RULES: Built in rule for <|>: "Class op <|>"]
<|>
  = \ (@ (f_a37j :: * -> *)) (v_B1 :: Alternative f_a37j) ->
      case v_B1 of v_B1
      { GHC.Base.C:Alternative v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 36, coercions: 0, joins: 0/0}
some
  :: forall (f :: * -> *). Alternative f => forall a. f a -> f [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSL),U(A,A,A,U,A)>,
 RULES: Built in rule for some: "Class op some"]
some
  = \ (@ (f_a37j :: * -> *)) (v_B1 :: Alternative f_a37j) ->
      case v_B1 of v_B1
      { GHC.Base.C:Alternative v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 36, coercions: 0, joins: 0/0}
many
  :: forall (f :: * -> *). Alternative f => forall a. f a -> f [a]
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLS),U(A,A,A,A,U)>,
 RULES: Built in rule for many: "Class op many"]
many
  = \ (@ (f_a37j :: * -> *)) (v_B1 :: Alternative f_a37j) ->
      case v_B1 of v_B1
      { GHC.Base.C:Alternative v_B2 v_B3 v_B4 v_B5 v_B6 ->
      v_B6
      }

Rec {
-- RHS size: {terms: 33, types: 24, coercions: 0, joins: 0/0}
eqString [Occ=LoopBreaker] :: String -> String -> Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []]
eqString
  = \ (ds_d506 :: [Char]) (ds1_d507 :: [Char]) ->
      case ds_d506 of {
        [] ->
          case ds1_d507 of {
            [] -> GHC.Types.True;
            : ipv_s5i8 ipv1_s5i9 -> GHC.Types.False
          };
        : c1_a3eP cs1_a3eQ ->
          case ds1_d507 of {
            [] -> GHC.Types.False;
            : c2_a3eR cs2_a3eS ->
              case c1_a3eP of { C# x_a5ih ->
              case c2_a3eR of { C# y_a5il ->
              case eqChar# x_a5ih y_a5il of {
                __DEFAULT -> GHC.Types.False;
                1# -> eqString cs1_a3eQ cs2_a3eS
              }
              }
              }
          }
      }
end Rec }

-- RHS size: {terms: 12, types: 13, coercions: 2, joins: 0/0}
GHC.Base.when2
  :: Bool -> IO () -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a3dI [Occ=Once!] :: Bool)
                 (s_a3dJ [Occ=Once] :: IO ())
                 (eta_B1 [Occ=Once*] :: State# RealWorld) ->
                 case p_a3dI of {
                   False -> (# eta_B1, GHC.Tuple.() #);
                   True ->
                     (s_a3dJ
                      `cast` (GHC.Types.N:IO[0] <()>_R
                              :: (IO () :: *)
                                 ~R# (State# RealWorld -> (# State# RealWorld, () #) :: *)))
                       eta_B1
                 }}]
GHC.Base.when2
  = \ (p_a3dI :: Bool)
      (s_a3dJ :: IO ())
      (eta_B1 :: State# RealWorld) ->
      case p_a3dI of {
        False -> (# eta_B1, GHC.Tuple.() #);
        True ->
          (s_a3dJ
           `cast` (GHC.Types.N:IO[0] <()>_R
                   :: (IO () :: *)
                      ~R# (State# RealWorld -> (# State# RealWorld, () #) :: *)))
            eta_B1
      }

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
GHC.Base.when_$swhen1 [InlPrag=INLINABLE] :: Bool -> IO () -> IO ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.when2
               `cast` (<Bool>_R ->_R <IO ()>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                       :: (Bool
                           -> IO () -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                          ~R# (Bool -> IO () -> IO () :: *))}]
GHC.Base.when_$swhen1
  = GHC.Base.when2
    `cast` (<Bool>_R ->_R <IO ()>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (Bool
                -> IO () -> State# RealWorld -> (# State# RealWorld, () #) :: *)
               ~R# (Bool -> IO () -> IO () :: *))

-- RHS size: {terms: 13, types: 28, coercions: 2, joins: 0/0}
GHC.Base.$fFunctorIO2
  :: forall a b.
     (a -> b) -> IO a -> State# RealWorld -> (# State# RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4qJ)
                 (@ b_a4qK)
                 (f_a38a [Occ=Once!] :: a_a4qJ -> b_a4qK)
                 (x_a38b [Occ=Once] :: IO a_a4qJ)
                 (s_a3fi [Occ=Once] :: State# RealWorld) ->
                 case (x_a38b
                       `cast` (GHC.Types.N:IO[0] <a_a4qJ>_R
                               :: (IO a_a4qJ :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a_a4qJ #) :: *)))
                        s_a3fi
                 of
                 { (# ipv_s5fT [Occ=Once], ipv1_s5fU [Occ=Once] #) ->
                 (# ipv_s5fT, f_a38a ipv1_s5fU #)
                 }}]
GHC.Base.$fFunctorIO2
  = \ (@ a_a4qJ)
      (@ b_a4qK)
      (f_a38a :: a_a4qJ -> b_a4qK)
      (x_a38b :: IO a_a4qJ)
      (s_a3fi :: State# RealWorld) ->
      case (x_a38b
            `cast` (GHC.Types.N:IO[0] <a_a4qJ>_R
                    :: (IO a_a4qJ :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_a4qJ #) :: *)))
             s_a3fi
      of
      { (# ipv_s5fT, ipv1_s5fU #) ->
      (# ipv_s5fT, f_a38a ipv1_s5fU #)
      }

-- RHS size: {terms: 12, types: 27, coercions: 2, joins: 0/0}
GHC.Base.$fFunctorIO1
  :: forall a b.
     a -> IO b -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><C(S(SL)),1*C1(U(U,A))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4r0)
                 (@ b_a4r1)
                 (x_a3f1 [Occ=Once] :: a_a4r0)
                 (eta_B2 [Occ=Once] :: IO b_a4r1)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case (eta_B2
                       `cast` (GHC.Types.N:IO[0] <b_a4r1>_R
                               :: (IO b_a4r1 :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, b_a4r1 #) :: *)))
                        eta1_B1
                 of
                 { (# ipv_s5fT [Occ=Once], _ [Occ=Dead] #) ->
                 (# ipv_s5fT, x_a3f1 #)
                 }}]
GHC.Base.$fFunctorIO1
  = \ (@ a_a4r0)
      (@ b_a4r1)
      (x_a3f1 :: a_a4r0)
      (eta_B2 :: IO b_a4r1)
      (eta1_B1 :: State# RealWorld) ->
      case (eta_B2
            `cast` (GHC.Types.N:IO[0] <b_a4r1>_R
                    :: (IO b_a4r1 :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, b_a4r1 #) :: *)))
             eta1_B1
      of
      { (# ipv_s5fT, ipv1_s5fU #) ->
      (# ipv_s5fT, x_a3f1 #)
      }

-- RHS size: {terms: 3, types: 1, coercions: 29, joins: 0/0}
GHC.Base.$fFunctorIO [InlPrag=NOUSERINLINE CONLIKE] :: Functor IO
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: IO
                          GHC.Base.$fFunctorIO2
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a -> b>_R ->_R <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                                  :: (forall a b.
                                      (a -> b)
                                      -> IO a -> State# RealWorld -> (# State# RealWorld, b #) :: *)
                                     ~R# (forall a b. (a -> b) -> IO a -> IO b :: *))
                          GHC.Base.$fFunctorIO1
                          `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                  <a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                                  :: (forall a b.
                                      a
                                      -> IO b -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                                     ~R# (forall a b. a -> IO b -> IO a :: *))]
GHC.Base.$fFunctorIO
  = GHC.Base.C:Functor
      @ IO
      (GHC.Base.$fFunctorIO2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a -> b>_R ->_R <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
               :: (forall a b.
                   (a -> b)
                   -> IO a -> State# RealWorld -> (# State# RealWorld, b #) :: *)
                  ~R# (forall a b. (a -> b) -> IO a -> IO b :: *)))
      (GHC.Base.$fFunctorIO1
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
               :: (forall a b.
                   a -> IO b -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                  ~R# (forall a b. a -> IO b -> IO a :: *)))

-- RHS size: {terms: 3, types: 5, coercions: 0, joins: 0/0}
GHC.Base.$fAlternativeMaybe1 :: forall a. Maybe [a]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$fAlternativeMaybe1
  = \ (@ a_a4IZ) -> GHC.Base.Just @ [a_a4IZ] (GHC.Types.[] @ a_a4IZ)

-- RHS size: {terms: 18, types: 20, coercions: 0, joins: 0/1}
GHC.Base.$fAlternativeMaybe_$cmany
  :: forall a. Maybe a -> Maybe [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4IZ) (v_a37r [Occ=Once!] :: Maybe a_a4IZ) ->
                 letrec {
                   many_v_s5vK [Occ=LoopBreaker] :: Maybe [a_a4IZ]
                   [LclId]
                   many_v_s5vK
                     = case v_a37r of {
                         Nothing -> GHC.Base.$fAlternativeMaybe1 @ a_a4IZ;
                         Just x_a38Q [Occ=Once] ->
                           case many_v_s5vK of {
                             Nothing -> GHC.Base.$fAlternativeMaybe1 @ a_a4IZ;
                             Just y_a38R [Occ=Once] ->
                               GHC.Base.Just @ [a_a4IZ] (GHC.Types.: @ a_a4IZ x_a38Q y_a38R)
                           }
                       }; } in
                 many_v_s5vK}]
GHC.Base.$fAlternativeMaybe_$cmany
  = \ (@ a_a4IZ) (v_a37r :: Maybe a_a4IZ) ->
      letrec {
        many_v_s5vK [Occ=LoopBreaker] :: Maybe [a_a4IZ]
        [LclId]
        many_v_s5vK
          = case v_a37r of {
              Nothing -> GHC.Base.$fAlternativeMaybe1 @ a_a4IZ;
              Just x_a38Q ->
                case many_v_s5vK of {
                  Nothing -> GHC.Base.$fAlternativeMaybe1 @ a_a4IZ;
                  Just y_a38R ->
                    GHC.Base.Just @ [a_a4IZ] (GHC.Types.: @ a_a4IZ x_a38Q y_a38R)
                }
            }; } in
      many_v_s5vK

-- RHS size: {terms: 21, types: 24, coercions: 0, joins: 0/1}
GHC.Base.$fAlternativeMaybe_$csome
  :: forall a. Maybe a -> Maybe [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30] 90 0}]
GHC.Base.$fAlternativeMaybe_$csome
  = \ (@ a_a4IR) (v_a37o :: Maybe a_a4IR) ->
      letrec {
        some_v_s5vI [Occ=LoopBreaker] :: Maybe [a_a4IR]
        [LclId]
        some_v_s5vI
          = case v_a37o of {
              Nothing -> GHC.Base.Nothing @ [a_a4IR];
              Just x_a38Q ->
                case some_v_s5vI of {
                  Nothing ->
                    GHC.Base.Just
                      @ [a_a4IR] (GHC.Types.: @ a_a4IR x_a38Q (GHC.Types.[] @ a_a4IR));
                  Just ipv_s5cx ->
                    GHC.Base.Just @ [a_a4IR] (GHC.Types.: @ a_a4IR x_a38Q ipv_s5cx)
                }
            }; } in
      some_v_s5vI

-- RHS size: {terms: 17, types: 20, coercions: 0, joins: 0/0}
GHC.Base.ap_$sap [InlPrag=INLINABLE]
  :: forall a b. Maybe (a -> b) -> Maybe a -> Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a446)
                 (@ b_a447)
                 (m1_a3eq [Occ=Once!] :: Maybe (a_a446 -> b_a447))
                 (m2_a3er [Occ=Once!] :: Maybe a_a446) ->
                 case m1_a3eq of {
                   Nothing -> GHC.Base.Nothing @ b_a447;
                   Just x_a38K [Occ=Once!] ->
                     case m2_a3er of {
                       Nothing -> GHC.Base.Nothing @ b_a447;
                       Just x1_X3jW [Occ=Once] -> GHC.Base.Just @ b_a447 (x_a38K x1_X3jW)
                     }
                 }}]
GHC.Base.ap_$sap
  = \ (@ a_a446)
      (@ b_a447)
      (m1_a3eq :: Maybe (a_a446 -> b_a447))
      (m2_a3er :: Maybe a_a446) ->
      case m1_a3eq of {
        Nothing -> GHC.Base.Nothing @ b_a447;
        Just x_a38K ->
          case m2_a3er of {
            Nothing -> GHC.Base.Nothing @ b_a447;
            Just x1_X3jW -> GHC.Base.Just @ b_a447 (x_a38K x1_X3jW)
          }
      }

-- RHS size: {terms: 44, types: 49, coercions: 0, joins: 0/0}
GHC.Base.liftM5_$sliftM5 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> Maybe a1
     -> Maybe a2
     -> Maybe a3
     -> Maybe a4
     -> Maybe a5
     -> Maybe r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><S,1*U><L,1*U><L,1*U><L,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 30 30 30 30 30] 170 70}]
GHC.Base.liftM5_$sliftM5
  = \ (@ a1_a46v)
      (@ a2_a46w)
      (@ a3_a46x)
      (@ a4_a46y)
      (@ a5_a46z)
      (@ r_a46A)
      (f_a3ef
         :: a1_a46v -> a2_a46w -> a3_a46x -> a4_a46y -> a5_a46z -> r_a46A)
      (m1_a3eg :: Maybe a1_a46v)
      (m2_a3eh :: Maybe a2_a46w)
      (m3_a3ei :: Maybe a3_a46x)
      (m4_a3ej :: Maybe a4_a46y)
      (m5_a3ek :: Maybe a5_a46z) ->
      case m1_a3eg of {
        Nothing -> GHC.Base.Nothing @ r_a46A;
        Just x_a38K ->
          case m2_a3eh of {
            Nothing -> GHC.Base.Nothing @ r_a46A;
            Just x1_X3k5 ->
              case m3_a3ei of {
                Nothing -> GHC.Base.Nothing @ r_a46A;
                Just x2_X3kb ->
                  case m4_a3ej of {
                    Nothing -> GHC.Base.Nothing @ r_a46A;
                    Just x3_X3kh ->
                      case m5_a3ek of {
                        Nothing -> GHC.Base.Nothing @ r_a46A;
                        Just x4_X3kn ->
                          GHC.Base.Just
                            @ r_a46A (f_a3ef x_a38K x1_X3k5 x2_X3kb x3_X3kh x4_X3kn)
                      }
                  }
              }
          }
      }

-- RHS size: {terms: 36, types: 40, coercions: 0, joins: 0/0}
GHC.Base.liftM4_$sliftM4 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> Maybe a1 -> Maybe a2 -> Maybe a3 -> Maybe a4 -> Maybe r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><S,1*U><L,1*U><L,1*U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 30 30 30 30] 140 60}]
GHC.Base.liftM4_$sliftM4
  = \ (@ a1_a48H)
      (@ a2_a48I)
      (@ a3_a48J)
      (@ a4_a48K)
      (@ r_a48L)
      (f_a3e6 :: a1_a48H -> a2_a48I -> a3_a48J -> a4_a48K -> r_a48L)
      (m1_a3e7 :: Maybe a1_a48H)
      (m2_a3e8 :: Maybe a2_a48I)
      (m3_a3e9 :: Maybe a3_a48J)
      (m4_a3ea :: Maybe a4_a48K) ->
      case m1_a3e7 of {
        Nothing -> GHC.Base.Nothing @ r_a48L;
        Just x_a38K ->
          case m2_a3e8 of {
            Nothing -> GHC.Base.Nothing @ r_a48L;
            Just x1_X3k4 ->
              case m3_a3e9 of {
                Nothing -> GHC.Base.Nothing @ r_a48L;
                Just x2_X3ka ->
                  case m4_a3ea of {
                    Nothing -> GHC.Base.Nothing @ r_a48L;
                    Just x3_X3kg ->
                      GHC.Base.Just @ r_a48L (f_a3e6 x_a38K x1_X3k4 x2_X3ka x3_X3kg)
                  }
              }
          }
      }

-- RHS size: {terms: 28, types: 31, coercions: 0, joins: 0/0}
GHC.Base.liftM3_$sliftM3 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> Maybe a1 -> Maybe a2 -> Maybe a3 -> Maybe r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a1_a4aw)
                 (@ a2_a4ax)
                 (@ a3_a4ay)
                 (@ r_a4az)
                 (f_a3dZ [Occ=Once!] :: a1_a4aw -> a2_a4ax -> a3_a4ay -> r_a4az)
                 (m1_a3e0 [Occ=Once!] :: Maybe a1_a4aw)
                 (m2_a3e1 [Occ=Once!] :: Maybe a2_a4ax)
                 (m3_a3e2 [Occ=Once!] :: Maybe a3_a4ay) ->
                 case m1_a3e0 of {
                   Nothing -> GHC.Base.Nothing @ r_a4az;
                   Just x_a38K [Occ=Once] ->
                     case m2_a3e1 of {
                       Nothing -> GHC.Base.Nothing @ r_a4az;
                       Just x1_X3k3 [Occ=Once] ->
                         case m3_a3e2 of {
                           Nothing -> GHC.Base.Nothing @ r_a4az;
                           Just x2_X3k9 [Occ=Once] ->
                             GHC.Base.Just @ r_a4az (f_a3dZ x_a38K x1_X3k3 x2_X3k9)
                         }
                     }
                 }}]
GHC.Base.liftM3_$sliftM3
  = \ (@ a1_a4aw)
      (@ a2_a4ax)
      (@ a3_a4ay)
      (@ r_a4az)
      (f_a3dZ :: a1_a4aw -> a2_a4ax -> a3_a4ay -> r_a4az)
      (m1_a3e0 :: Maybe a1_a4aw)
      (m2_a3e1 :: Maybe a2_a4ax)
      (m3_a3e2 :: Maybe a3_a4ay) ->
      case m1_a3e0 of {
        Nothing -> GHC.Base.Nothing @ r_a4az;
        Just x_a38K ->
          case m2_a3e1 of {
            Nothing -> GHC.Base.Nothing @ r_a4az;
            Just x1_X3k3 ->
              case m3_a3e2 of {
                Nothing -> GHC.Base.Nothing @ r_a4az;
                Just x2_X3k9 ->
                  GHC.Base.Just @ r_a4az (f_a3dZ x_a38K x1_X3k3 x2_X3k9)
              }
          }
      }

-- RHS size: {terms: 20, types: 22, coercions: 0, joins: 0/0}
GHC.Base.liftM2_$sliftM2 [InlPrag=INLINABLE]
  :: forall a1 a2 r.
     (a1 -> a2 -> r) -> Maybe a1 -> Maybe a2 -> Maybe r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a1_a4bY)
                 (@ a2_a4bZ)
                 (@ r_a4c0)
                 (f_a3dU [Occ=Once!] :: a1_a4bY -> a2_a4bZ -> r_a4c0)
                 (m1_a3dV [Occ=Once!] :: Maybe a1_a4bY)
                 (m2_a3dW [Occ=Once!] :: Maybe a2_a4bZ) ->
                 case m1_a3dV of {
                   Nothing -> GHC.Base.Nothing @ r_a4c0;
                   Just x_a38K [Occ=Once] ->
                     case m2_a3dW of {
                       Nothing -> GHC.Base.Nothing @ r_a4c0;
                       Just x1_X3k2 [Occ=Once] ->
                         GHC.Base.Just @ r_a4c0 (f_a3dU x_a38K x1_X3k2)
                     }
                 }}]
GHC.Base.liftM2_$sliftM2
  = \ (@ a1_a4bY)
      (@ a2_a4bZ)
      (@ r_a4c0)
      (f_a3dU :: a1_a4bY -> a2_a4bZ -> r_a4c0)
      (m1_a3dV :: Maybe a1_a4bY)
      (m2_a3dW :: Maybe a2_a4bZ) ->
      case m1_a3dV of {
        Nothing -> GHC.Base.Nothing @ r_a4c0;
        Just x_a38K ->
          case m2_a3dW of {
            Nothing -> GHC.Base.Nothing @ r_a4c0;
            Just x1_X3k2 -> GHC.Base.Just @ r_a4c0 (f_a3dU x_a38K x1_X3k2)
          }
      }

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
GHC.Base.liftM_$sliftM [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> Maybe a1 -> Maybe r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a1_a4d3)
                 (@ r_a4d4)
                 (f_a3dR [Occ=Once!] :: a1_a4d3 -> r_a4d4)
                 (m1_a3dS [Occ=Once!] :: Maybe a1_a4d3) ->
                 case m1_a3dS of {
                   Nothing -> GHC.Base.Nothing @ r_a4d4;
                   Just x_a38K [Occ=Once] -> GHC.Base.Just @ r_a4d4 (f_a3dR x_a38K)
                 }}]
GHC.Base.liftM_$sliftM
  = \ (@ a1_a4d3)
      (@ r_a4d4)
      (f_a3dR :: a1_a4d3 -> r_a4d4)
      (m1_a3dS :: Maybe a1_a4d3) ->
      case m1_a3dS of {
        Nothing -> GHC.Base.Nothing @ r_a4d4;
        Just x_a38K -> GHC.Base.Just @ r_a4d4 (f_a3dR x_a38K)
      }

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
GHC.Base.when1 :: Maybe ()
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.when1 = GHC.Base.Just @ () GHC.Tuple.()

-- RHS size: {terms: 8, types: 4, coercions: 0, joins: 0/0}
GHC.Base.when_$swhen [InlPrag=INLINABLE]
  :: Bool -> Maybe () -> Maybe ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_X3kf [Occ=Once!] :: Bool)
                 (s_X3kh [Occ=Once] :: Maybe ()) ->
                 case p_X3kf of {
                   False -> GHC.Base.when1;
                   True -> s_X3kh
                 }}]
GHC.Base.when_$swhen
  = \ (p_X3kf :: Bool) (s_X3kh :: Maybe ()) ->
      case p_X3kf of {
        False -> GHC.Base.when1;
        True -> s_X3kh
      }

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/0}
when [InlPrag=INLINABLE]
  :: forall (f :: * -> *). Applicative f => Bool -> f () -> f ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(U),A,A,A,A)><S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a4dW :: * -> *))
                 ($dApplicative_a4dY [Occ=Once] :: Applicative f_a4dW)
                 (p_X3kj [Occ=Once!] :: Bool)
                 (s_X3kl [Occ=Once] :: f_a4dW ()) ->
                 case p_X3kj of {
                   False -> pure @ f_a4dW $dApplicative_a4dY @ () GHC.Tuple.();
                   True -> s_X3kl
                 }}]
when
  = \ (@ (f_a4dW :: * -> *))
      ($dApplicative_a4dY :: Applicative f_a4dW)
      (p_X3kj :: Bool)
      (s_X3kl :: f_a4dW ()) ->
      case p_X3kj of {
        False -> pure @ f_a4dW $dApplicative_a4dY @ () GHC.Tuple.();
        True -> s_X3kl
      }

-- RHS size: {terms: 15, types: 16, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeMaybe_$c<*
  :: forall a b. Maybe a -> Maybe b -> Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Ln)
                 (@ b_a4Lo)
                 (ds_d5br [Occ=Once!] :: Maybe a_a4Ln)
                 (ds1_d5bs [Occ=Once!] :: Maybe b_a4Lo) ->
                 case ds_d5br of {
                   Nothing -> GHC.Base.Nothing @ a_a4Ln;
                   Just x_a38Q [Occ=Once] ->
                     case ds1_d5bs of {
                       Nothing -> GHC.Base.Nothing @ a_a4Ln;
                       Just _ [Occ=Dead] -> GHC.Base.Just @ a_a4Ln x_a38Q
                     }
                 }}]
GHC.Base.$fApplicativeMaybe_$c<*
  = \ (@ a_a4Ln)
      (@ b_a4Lo)
      (ds_d5br :: Maybe a_a4Ln)
      (ds1_d5bs :: Maybe b_a4Lo) ->
      case ds_d5br of wild_X5M {
        Nothing -> GHC.Base.Nothing @ a_a4Ln;
        Just x_a38Q ->
          case ds1_d5bs of {
            Nothing -> GHC.Base.Nothing @ a_a4Ln;
            Just y_a38R -> wild_X5M
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'O3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Base.$tc'O3 = "'O"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'O2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tc'O2 = GHC.Types.TrNameS GHC.Base.$tc'O3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcOpaque2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Base.$tcOpaque2 = "Opaque"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcOpaque1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tcOpaque1 = GHC.Types.TrNameS GHC.Base.$tcOpaque2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcMonadPlus2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Base.$tcMonadPlus2 = "MonadPlus"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcMonadPlus1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tcMonadPlus1 = GHC.Types.TrNameS GHC.Base.$tcMonadPlus2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcMonad2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Base.$tcMonad2 = "Monad"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcMonad1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tcMonad1 = GHC.Types.TrNameS GHC.Base.$tcMonad2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'C:Monoid3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Base.$tc'C:Monoid3 = "'C:Monoid"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'C:Monoid2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tc'C:Monoid2 = GHC.Types.TrNameS GHC.Base.$tc'C:Monoid3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcMonoid3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Base.$tcMonoid3 = "Monoid"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcMonoid2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tcMonoid2 = GHC.Types.TrNameS GHC.Base.$tcMonoid3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcSemigroup2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Base.$tcSemigroup2 = "Semigroup"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcSemigroup1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tcSemigroup1 = GHC.Types.TrNameS GHC.Base.$tcSemigroup2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc':|3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Base.$tc':|3 = "':|"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc':|2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tc':|2 = GHC.Types.TrNameS GHC.Base.$tc':|3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcNonEmpty2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Base.$tcNonEmpty2 = "NonEmpty"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcNonEmpty1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tcNonEmpty1 = GHC.Types.TrNameS GHC.Base.$tcNonEmpty2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcAlternative3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Base.$tcAlternative3 = "Alternative"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcAlternative2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tcAlternative2
  = GHC.Types.TrNameS GHC.Base.$tcAlternative3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcApplicative2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
GHC.Base.$tcApplicative2 = "Applicative"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcApplicative1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tcApplicative1
  = GHC.Types.TrNameS GHC.Base.$tcApplicative2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcFunctor2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Base.$tcFunctor2 = "Functor"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcFunctor1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tcFunctor1 = GHC.Types.TrNameS GHC.Base.$tcFunctor2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'Just3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Base.$tc'Just3 = "'Just"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'Just2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tc'Just2 = GHC.Types.TrNameS GHC.Base.$tc'Just3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'Nothing3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Base.$tc'Nothing3 = "'Nothing"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'Nothing2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tc'Nothing2 = GHC.Types.TrNameS GHC.Base.$tc'Nothing3

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcMaybe2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Base.$tcMaybe2 = "Maybe"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcMaybe1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$tcMaybe1 = GHC.Types.TrNameS GHC.Base.$tcMaybe2

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep_r7Pr :: KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep_r7Pr = GHC.Types.KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep1_r7Ps :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep1_r7Ps = GHC.Types.KindRepFun $krep_r7Pr $krep_r7Pr

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep2_r7Pt :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep2_r7Pt = GHC.Types.KindRepFun $krep_r7Pr $krep1_r7Ps

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep3_r7Pu :: [KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []]
$krep3_r7Pu
  = GHC.Types.: @ KindRep $krep_r7Pr (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep4_r7Pv :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep4_r7Pv = GHC.Types.KindRepTyConApp GHC.Types.$tc[] $krep3_r7Pu

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep5_r7Pw :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep5_r7Pw = GHC.Types.KindRepFun $krep4_r7Pv $krep_r7Pr

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep6_r7Px :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep6_r7Px
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcMonoid1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Base.$tcMonoid1
  = GHC.Types.KindRepFun GHC.Types.krep$* $krep6_r7Px

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcAlternative1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Base.$tcAlternative1
  = GHC.Types.KindRepFun GHC.Types.krep$*Arr* $krep6_r7Px

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Base.$trModule2 = "GHC.Base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$trModule1 = GHC.Types.TrNameS GHC.Base.$trModule2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Base.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Base.$trModule3 = GHC.Types.TrNameS GHC.Base.$trModule4

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Base.$trModule
  = GHC.Types.Module GHC.Base.$trModule3 GHC.Base.$trModule1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcMaybe :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tcMaybe
  = GHC.Types.TyCon
      625655543500963593##
      6391758309165051762##
      GHC.Base.$trModule
      GHC.Base.$tcMaybe1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'Nothing1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
GHC.Base.$tc'Nothing1
  = GHC.Types.KindRepTyConApp GHC.Base.$tcMaybe $krep3_r7Pu

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'Just1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Base.$tc'Just1
  = GHC.Types.KindRepFun $krep_r7Pr GHC.Base.$tc'Nothing1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'Nothing :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tc'Nothing
  = GHC.Types.TyCon
      14633289528184412192##
      12773126156421542470##
      GHC.Base.$trModule
      GHC.Base.$tc'Nothing2
      1#
      GHC.Base.$tc'Nothing1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'Just :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tc'Just
  = GHC.Types.TyCon
      5794512144280699493##
      9434423460978218117##
      GHC.Base.$trModule
      GHC.Base.$tc'Just2
      1#
      GHC.Base.$tc'Just1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcFunctor :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tcFunctor
  = GHC.Types.TyCon
      211182333006544237##
      5556320544348084514##
      GHC.Base.$trModule
      GHC.Base.$tcFunctor1
      0#
      GHC.Base.$tcAlternative1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcApplicative :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tcApplicative
  = GHC.Types.TyCon
      12705055220831243597##
      2963353171490466073##
      GHC.Base.$trModule
      GHC.Base.$tcApplicative1
      0#
      GHC.Base.$tcAlternative1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcAlternative :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tcAlternative
  = GHC.Types.TyCon
      1073491102990665358##
      14320772755704808948##
      GHC.Base.$trModule
      GHC.Base.$tcAlternative2
      0#
      GHC.Base.$tcAlternative1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcNonEmpty :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tcNonEmpty
  = GHC.Types.TyCon
      13207016872645468285##
      3455542966739695982##
      GHC.Base.$trModule
      GHC.Base.$tcNonEmpty1
      0#
      GHC.Types.krep$*Arr*

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep7_r7Py :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep7_r7Py
  = GHC.Types.KindRepTyConApp GHC.Base.$tcNonEmpty $krep3_r7Pu

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep8_r7Pz :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep8_r7Pz = GHC.Types.KindRepFun $krep4_r7Pv $krep7_r7Py

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc':|1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Base.$tc':|1 = GHC.Types.KindRepFun $krep_r7Pr $krep8_r7Pz

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc':| :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tc':|
  = GHC.Types.TyCon
      9440832435183810765##
      3053237465234607583##
      GHC.Base.$trModule
      GHC.Base.$tc':|2
      1#
      GHC.Base.$tc':|1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcSemigroup :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tcSemigroup
  = GHC.Types.TyCon
      16195352186364298277##
      3285685594139281062##
      GHC.Base.$trModule
      GHC.Base.$tcSemigroup1
      0#
      GHC.Base.$tcMonoid1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9_r7PA :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep9_r7PA
  = GHC.Types.KindRepTyConApp GHC.Base.$tcSemigroup $krep3_r7Pu

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcMonoid :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tcMonoid
  = GHC.Types.TyCon
      13838560045895743776##
      1291018260833769143##
      GHC.Base.$trModule
      GHC.Base.$tcMonoid2
      0#
      GHC.Base.$tcMonoid1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10_r7PB :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep10_r7PB
  = GHC.Types.KindRepTyConApp GHC.Base.$tcMonoid $krep3_r7Pu

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep11_r7PC :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep11_r7PC = GHC.Types.KindRepFun $krep5_r7Pw $krep10_r7PB

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep12_r7PD :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep12_r7PD = GHC.Types.KindRepFun $krep2_r7Pt $krep11_r7PC

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep13_r7PE :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
$krep13_r7PE = GHC.Types.KindRepFun $krep_r7Pr $krep12_r7PD

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'C:Monoid1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Base.$tc'C:Monoid1
  = GHC.Types.KindRepFun $krep9_r7PA $krep13_r7PE

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'C:Monoid :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tc'C:Monoid
  = GHC.Types.TyCon
      16099296089107510343##
      5895832073319104984##
      GHC.Base.$trModule
      GHC.Base.$tc'C:Monoid2
      1#
      GHC.Base.$tc'C:Monoid1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcMonad :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tcMonad
  = GHC.Types.TyCon
      3168880480603756299##
      8398240611646296094##
      GHC.Base.$trModule
      GHC.Base.$tcMonad1
      0#
      GHC.Base.$tcAlternative1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcMonadPlus :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tcMonadPlus
  = GHC.Types.TyCon
      14115673251620372550##
      14155357326069389390##
      GHC.Base.$trModule
      GHC.Base.$tcMonadPlus1
      0#
      GHC.Base.$tcAlternative1

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tcOpaque :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tcOpaque
  = GHC.Types.TyCon
      9339725405829241186##
      15550233501624900571##
      GHC.Base.$trModule
      GHC.Base.$tcOpaque1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep14_r7PF :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep14_r7PF
  = GHC.Types.KindRepTyConApp
      GHC.Base.$tcOpaque (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'O1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
GHC.Base.$tc'O1 = GHC.Types.KindRepFun $krep_r7Pr $krep14_r7PF

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$tc'O :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
GHC.Base.$tc'O
  = GHC.Types.TyCon
      12551274612394834805##
      13000664474148134329##
      GHC.Base.$trModule
      GHC.Base.$tc'O2
      1#
      GHC.Base.$tc'O1

-- RHS size: {terms: 18, types: 15, coercions: 0, joins: 0/0}
quotRemInt :: Int -> Int -> (Int, Int)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4Yj [Occ=Once!] :: Int)
                 (ds1_d4Yk [Occ=Once!] :: Int) ->
                 case ds_d4Yj of { I# x_a3fz [Occ=Once] ->
                 case ds1_d4Yk of { I# y_a3fA [Occ=Once] ->
                 case quotRemInt# x_a3fz y_a3fA of
                 { (# ipv_s5gi [Occ=Once], ipv1_s5gj [Occ=Once] #) ->
                 (GHC.Types.I# ipv_s5gi, GHC.Types.I# ipv1_s5gj)
                 }
                 }
                 }}]
quotRemInt
  = \ (ds_d4Yj :: Int) (ds1_d4Yk :: Int) ->
      case ds_d4Yj of { I# x_a3fz ->
      case ds1_d4Yk of { I# y_a3fA ->
      case quotRemInt# x_a3fz y_a3fA of { (# ipv_s5gi, ipv1_s5gj #) ->
      (GHC.Types.I# ipv_s5gi, GHC.Types.I# ipv1_s5gj)
      }
      }
      }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
modInt :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4Yv [Occ=Once!] :: Int)
                 (ds1_d4Yw [Occ=Once!] :: Int) ->
                 case ds_d4Yv of { I# x_a3fx [Occ=Once] ->
                 case ds1_d4Yw of { I# y_a3fy [Occ=Once] ->
                 case modInt# x_a3fx y_a3fy of wild2_X3O { __DEFAULT ->
                 GHC.Types.I# wild2_X3O
                 }
                 }
                 }}]
modInt
  = \ (ds_d4Yv :: Int) (ds1_d4Yw :: Int) ->
      case ds_d4Yv of { I# x_a3fx ->
      case ds1_d4Yw of { I# y_a3fy ->
      case modInt# x_a3fx y_a3fy of wild2_X3O { __DEFAULT ->
      GHC.Types.I# wild2_X3O
      }
      }
      }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
divInt :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d4YO [Occ=Once!] :: Int)
                 (ds1_d4YP [Occ=Once!] :: Int) ->
                 case ds_d4YO of { I# x_a3fv [Occ=Once] ->
                 case ds1_d4YP of { I# y_a3fw [Occ=Once] ->
                 case divInt# x_a3fv y_a3fw of wild2_X3N { __DEFAULT ->
                 GHC.Types.I# wild2_X3N
                 }
                 }
                 }}]
divInt
  = \ (ds_d4YO :: Int) (ds1_d4YP :: Int) ->
      case ds_d4YO of { I# x_a3fv ->
      case ds1_d4YP of { I# y_a3fw ->
      case divInt# x_a3fv y_a3fw of wild2_X3N { __DEFAULT ->
      GHC.Types.I# wild2_X3N
      }
      }
      }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
remInt [InlPrag=INLINE (sat-args=2)] :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4Z6 [Occ=Once!] :: Int)
                 (ds1_d4Z7 [Occ=Once!] :: Int) ->
                 case ds_d4Z6 of { I# x_a3ft [Occ=Once] ->
                 case ds1_d4Z7 of { I# y_a3fu [Occ=Once] ->
                 case remInt# x_a3ft y_a3fu of wild2_X7 { __DEFAULT ->
                 GHC.Types.I# wild2_X7
                 }
                 }
                 }}]
remInt
  = \ (ds_d4Z6 :: Int) (ds1_d4Z7 :: Int) ->
      case ds_d4Z6 of { I# x_a3ft ->
      case ds1_d4Z7 of { I# y_a3fu ->
      case remInt# x_a3ft y_a3fu of wild2_X3M { __DEFAULT ->
      GHC.Types.I# wild2_X3M
      }
      }
      }

-- RHS size: {terms: 15, types: 7, coercions: 0, joins: 0/0}
quotInt [InlPrag=INLINE (sat-args=2)] :: Int -> Int -> Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_d4Zd [Occ=Once!] :: Int)
                 (ds1_d4Ze [Occ=Once!] :: Int) ->
                 case ds_d4Zd of { I# x_a3fr [Occ=Once] ->
                 case ds1_d4Ze of { I# y_a3fs [Occ=Once] ->
                 case quotInt# x_a3fr y_a3fs of wild2_X7 { __DEFAULT ->
                 GHC.Types.I# wild2_X7
                 }
                 }
                 }}]
quotInt
  = \ (ds_d4Zd :: Int) (ds1_d4Ze :: Int) ->
      case ds_d4Zd of { I# x_a3fr ->
      case ds1_d4Ze of { I# y_a3fs ->
      case quotInt# x_a3fr y_a3fs of wild2_X3L { __DEFAULT ->
      GHC.Types.I# wild2_X3L
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
getTag [InlPrag=INLINE (sat-args=1)] :: forall a. a -> Int#
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a40P) (x_a3fq [Occ=Once] :: a_a40P) ->
                 case x_a3fq of x1_X3ft { __DEFAULT ->
                 dataToTag# @ a_a40P x1_X3ft
                 }}]
getTag = dataToTag#

-- RHS size: {terms: 12, types: 22, coercions: 4, joins: 0/0}
GHC.Base.$fMonadIO1
  :: forall a b.
     IO a
     -> (a -> IO b) -> State# RealWorld -> (# State# RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a412)
                 (@ b_a413)
                 (ds_d4ZC [Occ=Once] :: IO a_a412)
                 (k_a3fh [Occ=Once!] :: a_a412 -> IO b_a413)
                 (s_a3fi [Occ=Once] :: State# RealWorld) ->
                 case (ds_d4ZC
                       `cast` (GHC.Types.N:IO[0] <a_a412>_R
                               :: (IO a_a412 :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a_a412 #) :: *)))
                        s_a3fi
                 of
                 { (# ipv_s5fT [Occ=Once], ipv1_s5fU [Occ=Once] #) ->
                 ((k_a3fh ipv1_s5fU)
                  `cast` (GHC.Types.N:IO[0] <b_a413>_R
                          :: (IO b_a413 :: *)
                             ~R# (State# RealWorld -> (# State# RealWorld, b_a413 #) :: *)))
                   ipv_s5fT
                 }}]
GHC.Base.$fMonadIO1
  = \ (@ a_a412)
      (@ b_a413)
      (ds_d4ZC :: IO a_a412)
      (k_a3fh :: a_a412 -> IO b_a413)
      (s_a3fi :: State# RealWorld) ->
      case (ds_d4ZC
            `cast` (GHC.Types.N:IO[0] <a_a412>_R
                    :: (IO a_a412 :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_a412 #) :: *)))
             s_a3fi
      of
      { (# ipv_s5fT, ipv1_s5fU #) ->
      ((k_a3fh ipv1_s5fU)
       `cast` (GHC.Types.N:IO[0] <b_a413>_R
               :: (IO b_a413 :: *)
                  ~R# (State# RealWorld -> (# State# RealWorld, b_a413 #) :: *)))
        ipv_s5fT
      }

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
bindIO :: forall a b. IO a -> (a -> IO b) -> IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.$fMonadIO1
               `cast` (forall (a :: <*>_N) (b :: <*>_N).
                       <IO a>_R ->_R <a -> IO b>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                       :: (forall a b.
                           IO a
                           -> (a -> IO b)
                           -> State# RealWorld
                           -> (# State# RealWorld, b #) :: *)
                          ~R# (forall a b. IO a -> (a -> IO b) -> IO b :: *))}]
bindIO
  = GHC.Base.$fMonadIO1
    `cast` (forall (a :: <*>_N) (b :: <*>_N).
            <IO a>_R ->_R <a -> IO b>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
            :: (forall a b.
                IO a
                -> (a -> IO b)
                -> State# RealWorld
                -> (# State# RealWorld, b #) :: *)
               ~R# (forall a b. IO a -> (a -> IO b) -> IO b :: *))

-- RHS size: {terms: 11, types: 21, coercions: 4, joins: 0/0}
GHC.Base.$fApplicativeIO2
  :: forall a b.
     IO a -> IO b -> State# RealWorld -> (# State# RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a40V)
                 (@ b_a40W)
                 (ds_d4Zp [Occ=Once] :: IO a_a40V)
                 (k_a3fm [Occ=Once] :: IO b_a40W)
                 (s_a3fn [Occ=Once] :: State# RealWorld) ->
                 case (ds_d4Zp
                       `cast` (GHC.Types.N:IO[0] <a_a40V>_R
                               :: (IO a_a40V :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a_a40V #) :: *)))
                        s_a3fn
                 of
                 { (# ipv_s5fO [Occ=Once], _ [Occ=Dead] #) ->
                 (k_a3fm
                  `cast` (GHC.Types.N:IO[0] <b_a40W>_R
                          :: (IO b_a40W :: *)
                             ~R# (State# RealWorld -> (# State# RealWorld, b_a40W #) :: *)))
                   ipv_s5fO
                 }}]
GHC.Base.$fApplicativeIO2
  = \ (@ a_a40V)
      (@ b_a40W)
      (ds_d4Zp :: IO a_a40V)
      (k_a3fm :: IO b_a40W)
      (s_a3fn :: State# RealWorld) ->
      case (ds_d4Zp
            `cast` (GHC.Types.N:IO[0] <a_a40V>_R
                    :: (IO a_a40V :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_a40V #) :: *)))
             s_a3fn
      of
      { (# ipv_s5fO, ipv1_s5fP #) ->
      (k_a3fm
       `cast` (GHC.Types.N:IO[0] <b_a40W>_R
               :: (IO b_a40W :: *)
                  ~R# (State# RealWorld -> (# State# RealWorld, b_a40W #) :: *)))
        ipv_s5fO
      }

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
thenIO :: forall a b. IO a -> IO b -> IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,A))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.$fApplicativeIO2
               `cast` (forall (a :: <*>_N) (b :: <*>_N).
                       <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                       :: (forall a b.
                           IO a -> IO b -> State# RealWorld -> (# State# RealWorld, b #) :: *)
                          ~R# (forall a b. IO a -> IO b -> IO b :: *))}]
thenIO
  = GHC.Base.$fApplicativeIO2
    `cast` (forall (a :: <*>_N) (b :: <*>_N).
            <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
            :: (forall a b.
                IO a -> IO b -> State# RealWorld -> (# State# RealWorld, b #) :: *)
               ~R# (forall a b. IO a -> IO b -> IO b :: *))

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
GHC.Base.unIO1 :: forall a. IO a -> IO a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a40S) (ds_d4Zl [Occ=Once] :: IO a_a40S) -> ds_d4Zl}]
GHC.Base.unIO1 = \ (@ a_a40S) (ds_d4Zl :: IO a_a40S) -> ds_d4Zl

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
unIO
  :: forall a. IO a -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.unIO1
               `cast` (forall (a :: <*>_N). <IO a>_R ->_R GHC.Types.N:IO[0] <a>_R
                       :: (forall a. IO a -> IO a :: *)
                          ~R# (forall a.
                               IO a -> State# RealWorld -> (# State# RealWorld, a #) :: *))}]
unIO
  = GHC.Base.unIO1
    `cast` (forall (a :: <*>_N). <IO a>_R ->_R GHC.Types.N:IO[0] <a>_R
            :: (forall a. IO a -> IO a :: *)
               ~R# (forall a.
                    IO a -> State# RealWorld -> (# State# RealWorld, a #) :: *))

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeIO4
  :: forall a. a -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a419)
                 (x_a3fe [Occ=Once] :: a_a419)
                 (s_a3ff [Occ=Once] :: State# RealWorld) ->
                 (# s_a3ff, x_a3fe #)}]
GHC.Base.$fApplicativeIO4
  = \ (@ a_a419) (x_a3fe :: a_a419) (s_a3ff :: State# RealWorld) ->
      (# s_a3ff, x_a3fe #)

-- RHS size: {terms: 1, types: 0, coercions: 8, joins: 0/0}
returnIO :: forall a. a -> IO a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.$fApplicativeIO4
               `cast` (forall (a :: <*>_N).
                       <a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                       :: (forall a.
                           a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                          ~R# (forall a. a -> IO a :: *))}]
returnIO
  = GHC.Base.$fApplicativeIO4
    `cast` (forall (a :: <*>_N).
            <a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a.
                a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a. a -> IO a :: *))

-- RHS size: {terms: 17, types: 42, coercions: 5, joins: 0/0}
GHC.Base.$fApplicativeIO3
  :: forall b a.
     IO (a -> b)
     -> IO a -> State# RealWorld -> (# State# RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Jk)
                 (@ a_a4Jj)
                 (m1_X3C3 [Occ=Once] :: IO (a_a4Jj -> b_a4Jk))
                 (m2_X3C6 [Occ=Once] :: IO a_a4Jj)
                 (s_a3fi [Occ=Once] :: State# RealWorld) ->
                 case (m1_X3C3
                       `cast` (GHC.Types.N:IO[0] <a_a4Jj -> b_a4Jk>_R
                               :: (IO (a_a4Jj -> b_a4Jk) :: *)
                                  ~R# (State# RealWorld
                                       -> (# State# RealWorld, a_a4Jj -> b_a4Jk #) :: *)))
                        s_a3fi
                 of
                 { (# ipv_s5fT [Occ=Once], ipv1_s5fU [Occ=Once!] #) ->
                 case (m2_X3C6
                       `cast` (GHC.Types.N:IO[0] <a_a4Jj>_R
                               :: (IO a_a4Jj :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a_a4Jj #) :: *)))
                        ipv_s5fT
                 of
                 { (# ipv2_X5rR [Occ=Once], ipv3_X5rT [Occ=Once] #) ->
                 (# ipv2_X5rR, ipv1_s5fU ipv3_X5rT #)
                 }
                 }}]
GHC.Base.$fApplicativeIO3
  = \ (@ b_a4Jk)
      (@ a_a4Jj)
      (m1_X3C3 :: IO (a_a4Jj -> b_a4Jk))
      (m2_X3C6 :: IO a_a4Jj)
      (s_a3fi :: State# RealWorld) ->
      case (m1_X3C3
            `cast` (GHC.Types.N:IO[0] <a_a4Jj -> b_a4Jk>_R
                    :: (IO (a_a4Jj -> b_a4Jk) :: *)
                       ~R# (State# RealWorld
                            -> (# State# RealWorld, a_a4Jj -> b_a4Jk #) :: *)))
             s_a3fi
      of
      { (# ipv_s5fT, ipv1_s5fU #) ->
      case (m2_X3C6
            `cast` (GHC.Types.N:IO[0] <a_a4Jj>_R
                    :: (IO a_a4Jj :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_a4Jj #) :: *)))
             ipv_s5fT
      of
      { (# ipv2_X5rR, ipv3_X5rT #) ->
      (# ipv2_X5rR, ipv1_s5fU ipv3_X5rT #)
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
GHC.Base.liftA_$sliftA1 [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> IO a1 -> IO r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.$fFunctorIO2
               `cast` (forall (a1 :: <*>_N) (r :: <*>_N).
                       <a1 -> r>_R ->_R <IO a1>_R ->_R Sym (GHC.Types.N:IO[0] <r>_R)
                       :: (forall a1 r.
                           (a1 -> r)
                           -> IO a1 -> State# RealWorld -> (# State# RealWorld, r #) :: *)
                          ~R# (forall a1 r. (a1 -> r) -> IO a1 -> IO r :: *))}]
GHC.Base.liftA_$sliftA1
  = GHC.Base.$fFunctorIO2
    `cast` (forall (a1 :: <*>_N) (r :: <*>_N).
            <a1 -> r>_R ->_R <IO a1>_R ->_R Sym (GHC.Types.N:IO[0] <r>_R)
            :: (forall a1 r.
                (a1 -> r)
                -> IO a1 -> State# RealWorld -> (# State# RealWorld, r #) :: *)
               ~R# (forall a1 r. (a1 -> r) -> IO a1 -> IO r :: *))

-- RHS size: {terms: 17, types: 42, coercions: 5, joins: 0/0}
GHC.Base.ap1
  :: forall a b.
     IO (a -> b)
     -> IO a -> State# RealWorld -> (# State# RealWorld, b #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a43G)
                 (@ b_a43H)
                 (m1_a3eq [Occ=Once] :: IO (a_a43G -> b_a43H))
                 (m2_a3er [Occ=Once] :: IO a_a43G)
                 (s_a3fi [Occ=Once] :: State# RealWorld) ->
                 case (m1_a3eq
                       `cast` (GHC.Types.N:IO[0] <a_a43G -> b_a43H>_R
                               :: (IO (a_a43G -> b_a43H) :: *)
                                  ~R# (State# RealWorld
                                       -> (# State# RealWorld, a_a43G -> b_a43H #) :: *)))
                        s_a3fi
                 of
                 { (# ipv_s5fT [Occ=Once], ipv1_s5fU [Occ=Once!] #) ->
                 case (m2_a3er
                       `cast` (GHC.Types.N:IO[0] <a_a43G>_R
                               :: (IO a_a43G :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a_a43G #) :: *)))
                        ipv_s5fT
                 of
                 { (# ipv2_X5rK [Occ=Once], ipv3_X5rM [Occ=Once] #) ->
                 (# ipv2_X5rK, ipv1_s5fU ipv3_X5rM #)
                 }
                 }}]
GHC.Base.ap1
  = \ (@ a_a43G)
      (@ b_a43H)
      (m1_a3eq :: IO (a_a43G -> b_a43H))
      (m2_a3er :: IO a_a43G)
      (s_a3fi :: State# RealWorld) ->
      case (m1_a3eq
            `cast` (GHC.Types.N:IO[0] <a_a43G -> b_a43H>_R
                    :: (IO (a_a43G -> b_a43H) :: *)
                       ~R# (State# RealWorld
                            -> (# State# RealWorld, a_a43G -> b_a43H #) :: *)))
             s_a3fi
      of
      { (# ipv_s5fT, ipv1_s5fU #) ->
      case (m2_a3er
            `cast` (GHC.Types.N:IO[0] <a_a43G>_R
                    :: (IO a_a43G :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_a43G #) :: *)))
             ipv_s5fT
      of
      { (# ipv2_X5rK, ipv3_X5rM #) ->
      (# ipv2_X5rK, ipv1_s5fU ipv3_X5rM #)
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 16, joins: 0/0}
GHC.Base.ap_$sap1 [InlPrag=INLINABLE]
  :: forall a b. IO (a -> b) -> IO a -> IO b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,1*C1(U)))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.ap1
               `cast` (forall (a :: <*>_N) (b :: <*>_N).
                       <IO (a -> b)>_R ->_R <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                       :: (forall a b.
                           IO (a -> b)
                           -> IO a -> State# RealWorld -> (# State# RealWorld, b #) :: *)
                          ~R# (forall a b. IO (a -> b) -> IO a -> IO b :: *))}]
GHC.Base.ap_$sap1
  = GHC.Base.ap1
    `cast` (forall (a :: <*>_N) (b :: <*>_N).
            <IO (a -> b)>_R ->_R <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
            :: (forall a b.
                IO (a -> b)
                -> IO a -> State# RealWorld -> (# State# RealWorld, b #) :: *)
               ~R# (forall a b. IO (a -> b) -> IO a -> IO b :: *))

-- RHS size: {terms: 18, types: 27, coercions: 0, joins: 0/0}
ap [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a b. Monad m => m (a -> b) -> m a -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 0 0] 150 0
         Tmpl= \ (@ (m_a436 :: * -> *))
                 (@ a_a437)
                 (@ b_a438)
                 ($dMonad_a43a :: Monad m_a436)
                 (m1_a3eq [Occ=Once] :: m_a436 (a_a437 -> b_a438))
                 (m2_a3er [Occ=OnceL] :: m_a436 a_a437) ->
                 >>=
                   @ m_a436
                   $dMonad_a43a
                   @ (a_a437 -> b_a438)
                   @ b_a438
                   m1_a3eq
                   (\ (x1_a3es [Occ=OnceL!] :: a_a437 -> b_a438) ->
                      >>=
                        @ m_a436
                        $dMonad_a43a
                        @ a_a437
                        @ b_a438
                        m2_a3er
                        (\ (x2_a3et [Occ=Once] :: a_a437) ->
                           return @ m_a436 $dMonad_a43a @ b_a438 (x1_a3es x2_a3et)))}]
ap
  = \ (@ (m_a436 :: * -> *))
      (@ a_a437)
      (@ b_a438)
      ($dMonad_a43a :: Monad m_a436)
      (m1_a3eq :: m_a436 (a_a437 -> b_a438))
      (m2_a3er :: m_a436 a_a437) ->
      >>=
        @ m_a436
        $dMonad_a43a
        @ (a_a437 -> b_a438)
        @ b_a438
        m1_a3eq
        (\ (x1_a3es :: a_a437 -> b_a438) ->
           >>=
             @ m_a436
             $dMonad_a43a
             @ a_a437
             @ b_a438
             m2_a3er
             (\ (x2_a3et :: a_a437) ->
                return @ m_a436 $dMonad_a43a @ b_a438 (x1_a3es x2_a3et)))

-- RHS size: {terms: 20, types: 44, coercions: 4, joins: 0/0}
GHC.Base.liftM1
  :: forall a1 a2 r.
     (a1 -> a2 -> r)
     -> IO a1 -> IO a2 -> State# RealWorld -> (# State# RealWorld, r #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a1_a4bp)
                 (@ a2_a4bq)
                 (@ r_a4br)
                 (f_a3dU [Occ=Once!] :: a1_a4bp -> a2_a4bq -> r_a4br)
                 (m1_a3dV [Occ=Once] :: IO a1_a4bp)
                 (m2_a3dW [Occ=Once] :: IO a2_a4bq)
                 (s_a3fi [Occ=Once] :: State# RealWorld) ->
                 case (m1_a3dV
                       `cast` (GHC.Types.N:IO[0] <a1_a4bp>_R
                               :: (IO a1_a4bp :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a1_a4bp #) :: *)))
                        s_a3fi
                 of
                 { (# ipv_s5fT [Occ=Once], ipv1_s5fU [Occ=Once] #) ->
                 case (m2_a3dW
                       `cast` (GHC.Types.N:IO[0] <a2_a4bq>_R
                               :: (IO a2_a4bq :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a2_a4bq #) :: *)))
                        ipv_s5fT
                 of
                 { (# ipv2_X5rE [Occ=Once], ipv3_X5rG [Occ=Once] #) ->
                 (# ipv2_X5rE, f_a3dU ipv1_s5fU ipv3_X5rG #)
                 }
                 }}]
GHC.Base.liftM1
  = \ (@ a1_a4bp)
      (@ a2_a4bq)
      (@ r_a4br)
      (f_a3dU :: a1_a4bp -> a2_a4bq -> r_a4br)
      (m1_a3dV :: IO a1_a4bp)
      (m2_a3dW :: IO a2_a4bq)
      (s_a3fi :: State# RealWorld) ->
      case (m1_a3dV
            `cast` (GHC.Types.N:IO[0] <a1_a4bp>_R
                    :: (IO a1_a4bp :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a1_a4bp #) :: *)))
             s_a3fi
      of
      { (# ipv_s5fT, ipv1_s5fU #) ->
      case (m2_a3dW
            `cast` (GHC.Types.N:IO[0] <a2_a4bq>_R
                    :: (IO a2_a4bq :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a2_a4bq #) :: *)))
             ipv_s5fT
      of
      { (# ipv2_X5rE, ipv3_X5rG #) ->
      (# ipv2_X5rE, f_a3dU ipv1_s5fU ipv3_X5rG #)
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 22, joins: 0/0}
GHC.Base.liftM2_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 r. (a1 -> a2 -> r) -> IO a1 -> IO a2 -> IO r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.liftM1
               `cast` (forall (a1 :: <*>_N) (a2 :: <*>_N) (r :: <*>_N).
                       <a1 -> a2 -> r>_R
                       ->_R <IO a1>_R
                       ->_R <IO a2>_R
                       ->_R Sym (GHC.Types.N:IO[0] <r>_R)
                       :: (forall a1 a2 r.
                           (a1 -> a2 -> r)
                           -> IO a1
                           -> IO a2
                           -> State# RealWorld
                           -> (# State# RealWorld, r #) :: *)
                          ~R# (forall a1 a2 r.
                               (a1 -> a2 -> r) -> IO a1 -> IO a2 -> IO r :: *))}]
GHC.Base.liftM2_$sliftM1
  = GHC.Base.liftM1
    `cast` (forall (a1 :: <*>_N) (a2 :: <*>_N) (r :: <*>_N).
            <a1 -> a2 -> r>_R
            ->_R <IO a1>_R
            ->_R <IO a2>_R
            ->_R Sym (GHC.Types.N:IO[0] <r>_R)
            :: (forall a1 a2 r.
                (a1 -> a2 -> r)
                -> IO a1
                -> IO a2
                -> State# RealWorld
                -> (# State# RealWorld, r #) :: *)
               ~R# (forall a1 a2 r.
                    (a1 -> a2 -> r) -> IO a1 -> IO a2 -> IO r :: *))

-- RHS size: {terms: 21, types: 29, coercions: 0, joins: 0/0}
liftM2 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 r.
     Monad m =>
     (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [90 60 0 0] 160 0
         Tmpl= \ (@ (m_a4aH :: * -> *))
                 (@ a1_a4aI)
                 (@ a2_a4aJ)
                 (@ r_a4aK)
                 ($dMonad_a4aM :: Monad m_a4aH)
                 (f_a3dU [Occ=OnceL!] :: a1_a4aI -> a2_a4aJ -> r_a4aK)
                 (m1_a3dV [Occ=Once] :: m_a4aH a1_a4aI)
                 (m2_a3dW [Occ=OnceL] :: m_a4aH a2_a4aJ) ->
                 >>=
                   @ m_a4aH
                   $dMonad_a4aM
                   @ a1_a4aI
                   @ r_a4aK
                   m1_a3dV
                   (\ (x1_a3dX [Occ=OnceL] :: a1_a4aI) ->
                      >>=
                        @ m_a4aH
                        $dMonad_a4aM
                        @ a2_a4aJ
                        @ r_a4aK
                        m2_a3dW
                        (\ (x2_a3dY [Occ=Once] :: a2_a4aJ) ->
                           return @ m_a4aH $dMonad_a4aM @ r_a4aK (f_a3dU x1_a3dX x2_a3dY)))}]
liftM2
  = \ (@ (m_a4aH :: * -> *))
      (@ a1_a4aI)
      (@ a2_a4aJ)
      (@ r_a4aK)
      ($dMonad_a4aM :: Monad m_a4aH)
      (f_a3dU :: a1_a4aI -> a2_a4aJ -> r_a4aK)
      (m1_a3dV :: m_a4aH a1_a4aI)
      (m2_a3dW :: m_a4aH a2_a4aJ) ->
      >>=
        @ m_a4aH
        $dMonad_a4aM
        @ a1_a4aI
        @ r_a4aK
        m1_a3dV
        (\ (x1_a3dX :: a1_a4aI) ->
           >>=
             @ m_a4aH
             $dMonad_a4aM
             @ a2_a4aJ
             @ r_a4aK
             m2_a3dW
             (\ (x2_a3dY :: a2_a4aJ) ->
                return @ m_a4aH $dMonad_a4aM @ r_a4aK (f_a3dU x1_a3dX x2_a3dY)))

-- RHS size: {terms: 20, types: 44, coercions: 4, joins: 0/0}
$cliftA2_r7PG
  :: forall c b a.
     (a -> b -> c)
     -> IO a -> IO b -> State# RealWorld -> (# State# RealWorld, c #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []]
$cliftA2_r7PG
  = \ (@ c_a4Jw)
      (@ b_a4Jv)
      (@ a_a4Ju)
      (f_X3pn :: a_a4Ju -> b_a4Jv -> c_a4Jw)
      (m1_X3pp :: IO a_a4Ju)
      (m2_X3pr :: IO b_a4Jv)
      (s_a3fi :: State# RealWorld) ->
      case (m1_X3pp
            `cast` (GHC.Types.N:IO[0] <a_a4Ju>_R
                    :: (IO a_a4Ju :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_a4Ju #) :: *)))
             s_a3fi
      of
      { (# ipv_s5fT, ipv1_s5fU #) ->
      case (m2_X3pr
            `cast` (GHC.Types.N:IO[0] <b_a4Jv>_R
                    :: (IO b_a4Jv :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, b_a4Jv #) :: *)))
             ipv_s5fT
      of
      { (# ipv2_X5ru, ipv3_X5rw #) ->
      (# ipv2_X5ru, f_X3pn ipv1_s5fU ipv3_X5rw #)
      }
      }

-- RHS size: {terms: 4, types: 9, coercions: 22, joins: 0/0}
GHC.Base.$fApplicativeIO_$cliftA2 [InlPrag=INLINE (sat-args=0)]
  :: forall a b c. (a -> b -> c) -> IO a -> IO b -> IO c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=False)
         Tmpl= (\ (@ a_a4Ju)
                  (@ b_a4Jv)
                  (@ c_a4Jw)
                  (f_a3dU [Occ=Once!] :: a_a4Ju -> b_a4Jv -> c_a4Jw)
                  (m1_a3dV [Occ=Once] :: IO a_a4Ju)
                  (m2_a3dW [Occ=Once] :: IO b_a4Jv)
                  (s_a3fi [Occ=Once] :: State# RealWorld) ->
                  case (m1_a3dV
                        `cast` (GHC.Types.N:IO[0] <a_a4Ju>_R
                                :: (IO a_a4Ju :: *)
                                   ~R# (State# RealWorld -> (# State# RealWorld, a_a4Ju #) :: *)))
                         s_a3fi
                  of
                  { (# ipv_s5fT [Occ=Once], ipv1_s5fU [Occ=Once] #) ->
                  case (m2_a3dW
                        `cast` (GHC.Types.N:IO[0] <b_a4Jv>_R
                                :: (IO b_a4Jv :: *)
                                   ~R# (State# RealWorld -> (# State# RealWorld, b_a4Jv #) :: *)))
                         ipv_s5fT
                  of
                  { (# ipv2_X5rv [Occ=Once], ipv3_X5rx [Occ=Once] #) ->
                  (# ipv2_X5rv, f_a3dU ipv1_s5fU ipv3_X5rx #)
                  }
                  })
               `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                       <a -> b -> c>_R
                       ->_R <IO a>_R
                       ->_R <IO b>_R
                       ->_R Sym (GHC.Types.N:IO[0] <c>_R)
                       :: (forall a b c.
                           (a -> b -> c)
                           -> IO a
                           -> IO b
                           -> State# RealWorld
                           -> (# State# RealWorld, c #) :: *)
                          ~R# (forall a b c. (a -> b -> c) -> IO a -> IO b -> IO c :: *))}]
GHC.Base.$fApplicativeIO_$cliftA2
  = (\ (@ a_a4Ju) (@ b_a4Jv) (@ c_a4Jw) ->
       $cliftA2_r7PG @ c_a4Jw @ b_a4Jv @ a_a4Ju)
    `cast` (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
            <a -> b -> c>_R
            ->_R <IO a>_R
            ->_R <IO b>_R
            ->_R Sym (GHC.Types.N:IO[0] <c>_R)
            :: (forall a b c.
                (a -> b -> c)
                -> IO a
                -> IO b
                -> State# RealWorld
                -> (# State# RealWorld, c #) :: *)
               ~R# (forall a b c. (a -> b -> c) -> IO a -> IO b -> IO c :: *))

-- RHS size: {terms: 27, types: 60, coercions: 6, joins: 0/0}
GHC.Base.liftA1
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> IO a1
     -> IO a2
     -> IO a3
     -> State# RealWorld
     -> (# State# RealWorld, r #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a1_a4fX)
                 (@ a2_a4fY)
                 (@ a3_a4fZ)
                 (@ r_a4g0)
                 (f_a3dB [Occ=Once!] :: a1_a4fX -> a2_a4fY -> a3_a4fZ -> r_a4g0)
                 (a_a3dC [Occ=Once] :: IO a1_a4fX)
                 (b_a3dD [Occ=Once] :: IO a2_a4fY)
                 (c_a3dE [Occ=Once] :: IO a3_a4fZ)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case (a_a3dC
                       `cast` (GHC.Types.N:IO[0] <a1_a4fX>_R
                               :: (IO a1_a4fX :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a1_a4fX #) :: *)))
                        eta_B1
                 of
                 { (# ipv_s5fT [Occ=Once], ipv1_s5fU [Occ=Once] #) ->
                 case (b_a3dD
                       `cast` (GHC.Types.N:IO[0] <a2_a4fY>_R
                               :: (IO a2_a4fY :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a2_a4fY #) :: *)))
                        ipv_s5fT
                 of
                 { (# ipv2_X5rv [Occ=Once], ipv3_X5rx [Occ=Once] #) ->
                 case (c_a3dE
                       `cast` (GHC.Types.N:IO[0] <a3_a4fZ>_R
                               :: (IO a3_a4fZ :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a3_a4fZ #) :: *)))
                        ipv2_X5rv
                 of
                 { (# ipv4_X5rR [Occ=Once], ipv5_X5rT [Occ=Once] #) ->
                 (# ipv4_X5rR, f_a3dB ipv1_s5fU ipv3_X5rx ipv5_X5rT #)
                 }
                 }
                 }}]
GHC.Base.liftA1
  = \ (@ a1_a4fX)
      (@ a2_a4fY)
      (@ a3_a4fZ)
      (@ r_a4g0)
      (f_a3dB :: a1_a4fX -> a2_a4fY -> a3_a4fZ -> r_a4g0)
      (a_a3dC :: IO a1_a4fX)
      (b_a3dD :: IO a2_a4fY)
      (c_a3dE :: IO a3_a4fZ)
      (eta_B1 :: State# RealWorld) ->
      case (a_a3dC
            `cast` (GHC.Types.N:IO[0] <a1_a4fX>_R
                    :: (IO a1_a4fX :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a1_a4fX #) :: *)))
             eta_B1
      of
      { (# ipv_s5fT, ipv1_s5fU #) ->
      case (b_a3dD
            `cast` (GHC.Types.N:IO[0] <a2_a4fY>_R
                    :: (IO a2_a4fY :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a2_a4fY #) :: *)))
             ipv_s5fT
      of
      { (# ipv2_X5rv, ipv3_X5rx #) ->
      case (c_a3dE
            `cast` (GHC.Types.N:IO[0] <a3_a4fZ>_R
                    :: (IO a3_a4fZ :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a3_a4fZ #) :: *)))
             ipv2_X5rv
      of
      { (# ipv4_X5rR, ipv5_X5rT #) ->
      (# ipv4_X5rR, f_a3dB ipv1_s5fU ipv3_X5rx ipv5_X5rT #)
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 29, joins: 0/0}
GHC.Base.liftA3_$sliftA1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r) -> IO a1 -> IO a2 -> IO a3 -> IO r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.liftA1
               `cast` (forall (a1 :: <*>_N) (a2 :: <*>_N) (a3 :: <*>_N) (r :: <*>_N).
                       <a1 -> a2 -> a3 -> r>_R
                       ->_R <IO a1>_R
                       ->_R <IO a2>_R
                       ->_R <IO a3>_R
                       ->_R Sym (GHC.Types.N:IO[0] <r>_R)
                       :: (forall a1 a2 a3 r.
                           (a1 -> a2 -> a3 -> r)
                           -> IO a1
                           -> IO a2
                           -> IO a3
                           -> State# RealWorld
                           -> (# State# RealWorld, r #) :: *)
                          ~R# (forall a1 a2 a3 r.
                               (a1 -> a2 -> a3 -> r) -> IO a1 -> IO a2 -> IO a3 -> IO r :: *))}]
GHC.Base.liftA3_$sliftA1
  = GHC.Base.liftA1
    `cast` (forall (a1 :: <*>_N) (a2 :: <*>_N) (a3 :: <*>_N) (r :: <*>_N).
            <a1 -> a2 -> a3 -> r>_R
            ->_R <IO a1>_R
            ->_R <IO a2>_R
            ->_R <IO a3>_R
            ->_R Sym (GHC.Types.N:IO[0] <r>_R)
            :: (forall a1 a2 a3 r.
                (a1 -> a2 -> a3 -> r)
                -> IO a1
                -> IO a2
                -> IO a3
                -> State# RealWorld
                -> (# State# RealWorld, r #) :: *)
               ~R# (forall a1 a2 a3 r.
                    (a1 -> a2 -> a3 -> r) -> IO a1 -> IO a2 -> IO a3 -> IO r :: *))

-- RHS size: {terms: 19, types: 40, coercions: 4, joins: 0/0}
GHC.Base.$fSemigroupIO2
  :: forall a.
     Semigroup a =>
     IO a -> IO a -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Al)
                 ($dSemigroup_a4Am [Occ=Once] :: Semigroup a_a4Al)
                 (eta_B3 [Occ=Once] :: IO a_a4Al)
                 (eta1_X8C [Occ=Once] :: IO a_a4Al)
                 (eta2_B1 [Occ=Once] :: State# RealWorld) ->
                 case (eta_B3
                       `cast` (GHC.Types.N:IO[0] <a_a4Al>_R
                               :: (IO a_a4Al :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a_a4Al #) :: *)))
                        eta2_B1
                 of
                 { (# ipv_s5fT [Occ=Once], ipv1_s5fU [Occ=Once] #) ->
                 case (eta1_X8C
                       `cast` (GHC.Types.N:IO[0] <a_a4Al>_R
                               :: (IO a_a4Al :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a_a4Al #) :: *)))
                        ipv_s5fT
                 of
                 { (# ipv2_X5rv [Occ=Once], ipv3_X5rx [Occ=Once] #) ->
                 (# ipv2_X5rv, <> @ a_a4Al $dSemigroup_a4Am ipv1_s5fU ipv3_X5rx #)
                 }
                 }}]
GHC.Base.$fSemigroupIO2
  = \ (@ a_a4Al)
      ($dSemigroup_a4Am :: Semigroup a_a4Al)
      (eta_B3 :: IO a_a4Al)
      (eta1_X8C :: IO a_a4Al)
      (eta2_B1 :: State# RealWorld) ->
      case (eta_B3
            `cast` (GHC.Types.N:IO[0] <a_a4Al>_R
                    :: (IO a_a4Al :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_a4Al #) :: *)))
             eta2_B1
      of
      { (# ipv_s5fT, ipv1_s5fU #) ->
      case (eta1_X8C
            `cast` (GHC.Types.N:IO[0] <a_a4Al>_R
                    :: (IO a_a4Al :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_a4Al #) :: *)))
             ipv_s5fT
      of
      { (# ipv2_X5rv, ipv3_X5rx #) ->
      (# ipv2_X5rv, <> @ a_a4Al $dSemigroup_a4Am ipv1_s5fU ipv3_X5rx #)
      }
      }

-- RHS size: {terms: 35, types: 71, coercions: 4, joins: 0/1}
GHC.Base.$w$csconcat4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Semigroup a =>
     IO a -> [IO a] -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><C(S),1*C1(U(U,U))><S,1*U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0 0] 190 0}]
GHC.Base.$w$csconcat4
  = \ (@ a_s6Fu)
      (w_s6Fv :: Semigroup a_s6Fu)
      (ww_s6FA :: IO a_s6Fu)
      (ww1_s6FB :: [IO a_s6Fu])
      (w1_s6Fx :: State# RealWorld) ->
      letrec {
        go_s5vG [Occ=LoopBreaker]
          :: IO a_s6Fu
             -> [IO a_s6Fu]
             -> State# RealWorld
             -> (# State# RealWorld, a_s6Fu #)
        [LclId,
         Arity=3,
         Str=<C(S),1*C1(U(U,U))><S,1*U><S,U>,
         Unf=OtherCon []]
        go_s5vG
          = \ (b_a384 :: IO a_s6Fu)
              (ds_d548 :: [IO a_s6Fu])
              (eta_X8R :: State# RealWorld) ->
              case ds_d548 of {
                [] ->
                  (b_a384
                   `cast` (GHC.Types.N:IO[0] <a_s6Fu>_R
                           :: (IO a_s6Fu :: *)
                              ~R# (State# RealWorld -> (# State# RealWorld, a_s6Fu #) :: *)))
                    eta_X8R;
                : c_a385 cs_a386 ->
                  case (b_a384
                        `cast` (GHC.Types.N:IO[0] <a_s6Fu>_R
                                :: (IO a_s6Fu :: *)
                                   ~R# (State# RealWorld -> (# State# RealWorld, a_s6Fu #) :: *)))
                         eta_X8R
                  of
                  { (# ipv_s5fT, ipv1_s5fU #) ->
                  case go_s5vG c_a385 cs_a386 ipv_s5fT of
                  { (# ipv2_X5rv, ipv3_X5rx #) ->
                  (# ipv2_X5rv, <> @ a_s6Fu w_s6Fv ipv1_s5fU ipv3_X5rx #)
                  }
                  }
              }; } in
      go_s5vG ww_s6FA ww1_s6FB w1_s6Fx

-- RHS size: {terms: 12, types: 18, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroupIO1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Semigroup a =>
     NonEmpty (IO a) -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(C(S)S),1*U(1*C1(U(U,U)),1*U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6Fu)
                 (w_s6Fv [Occ=Once] :: Semigroup a_s6Fu)
                 (w1_s6Fw [Occ=Once!] :: NonEmpty (IO a_s6Fu))
                 (w2_s6Fx [Occ=Once] :: State# RealWorld) ->
                 case w1_s6Fw of { :| ww1_s6FA [Occ=Once] ww2_s6FB [Occ=Once] ->
                 GHC.Base.$w$csconcat4 @ a_s6Fu w_s6Fv ww1_s6FA ww2_s6FB w2_s6Fx
                 }}]
GHC.Base.$fSemigroupIO1
  = \ (@ a_s6Fu)
      (w_s6Fv :: Semigroup a_s6Fu)
      (w1_s6Fw :: NonEmpty (IO a_s6Fu))
      (w2_s6Fx :: State# RealWorld) ->
      case w1_s6Fw of { :| ww1_s6FA ww2_s6FB ->
      GHC.Base.$w$csconcat4 @ a_s6Fu w_s6Fv ww1_s6FA ww2_s6FB w2_s6Fx
      }

Rec {
-- RHS size: {terms: 9, types: 9, coercions: 16, joins: 0/0}
GHC.Base.$fSemigroupIO [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup a => Semigroup (IO a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(C(C1(U)),A,A)>m,
 Unf=DFun: \ (@ a_a39f) (v_B1 :: Semigroup a_a39f) ->
       GHC.Base.C:Semigroup TYPE: IO a_a39f
                            (GHC.Base.$fSemigroupIO2 @ a_a39f v_B1)
                            `cast` (<IO a_a39f>_R
                                    ->_R <IO a_a39f>_R
                                    ->_R Sym (GHC.Types.N:IO[0] <a_a39f>_R)
                                    :: (IO a_a39f
                                        -> IO a_a39f
                                        -> State# RealWorld
                                        -> (# State# RealWorld, a_a39f #) :: *)
                                       ~R# (IO a_a39f -> IO a_a39f -> IO a_a39f :: *))
                            (GHC.Base.$fSemigroupIO1 @ a_a39f v_B1)
                            `cast` (<NonEmpty (IO a_a39f)>_R
                                    ->_R Sym (GHC.Types.N:IO[0] <a_a39f>_R)
                                    :: (NonEmpty (IO a_a39f)
                                        -> State# RealWorld -> (# State# RealWorld, a_a39f #) :: *)
                                       ~R# (NonEmpty (IO a_a39f) -> IO a_a39f :: *))
                            GHC.Base.$fSemigroupIO_$cstimes @ a_a39f v_B1]
GHC.Base.$fSemigroupIO
  = \ (@ a_X4J3) ($dSemigroup_X4J5 :: Semigroup a_X4J3) ->
      GHC.Base.C:Semigroup
        @ (IO a_X4J3)
        ((GHC.Base.$fSemigroupIO2 @ a_X4J3 $dSemigroup_X4J5)
         `cast` (<IO a_X4J3>_R
                 ->_R <IO a_X4J3>_R
                 ->_R Sym (GHC.Types.N:IO[0] <a_X4J3>_R)
                 :: (IO a_X4J3
                     -> IO a_X4J3
                     -> State# RealWorld
                     -> (# State# RealWorld, a_X4J3 #) :: *)
                    ~R# (IO a_X4J3 -> IO a_X4J3 -> IO a_X4J3 :: *)))
        ((GHC.Base.$fSemigroupIO1 @ a_X4J3 $dSemigroup_X4J5)
         `cast` (<NonEmpty (IO a_X4J3)>_R
                 ->_R Sym (GHC.Types.N:IO[0] <a_X4J3>_R)
                 :: (NonEmpty (IO a_X4J3)
                     -> State# RealWorld -> (# State# RealWorld, a_X4J3 #) :: *)
                    ~R# (NonEmpty (IO a_X4J3) -> IO a_X4J3 :: *)))
        (GHC.Base.$fSemigroupIO_$cstimes @ a_X4J3 $dSemigroup_X4J5)

-- RHS size: {terms: 8, types: 12, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroupIO_$cstimes [Occ=LoopBreaker]
  :: forall a.
     Semigroup a =>
     forall b. Integral b => b -> IO a -> IO a
[GblId, Arity=2, Str=<L,U(C(C1(U)),A,A)><L,U>, Unf=OtherCon []]
GHC.Base.$fSemigroupIO_$cstimes
  = \ (@ a_X4J4)
      ($dSemigroup_X4J6 :: Semigroup a_X4J4)
      (@ b_a4AG)
      ($dIntegral_a4AI :: Integral b_a4AG) ->
      stimesDefault
        @ b_a4AG
        @ (IO a_X4J4)
        $dIntegral_a4AI
        (GHC.Base.$fSemigroupIO @ a_X4J4 $dSemigroup_X4J6)
end Rec }

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
GHC.Base.$fMonoidIO_$cp1Monoid
  :: forall a. Monoid a => Semigroup (IO a)
[GblId,
 Arity=1,
 Str=<L,1*U(1*U(C(C1(U)),A,A),A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X4I6) ($dMonoid_X4I8 [Occ=Once] :: Monoid a_X4I6) ->
                 GHC.Base.$fSemigroupIO
                   @ a_X4I6 (GHC.Base.$p1Monoid @ a_X4I6 $dMonoid_X4I8)}]
GHC.Base.$fMonoidIO_$cp1Monoid
  = \ (@ a_X4I6) ($dMonoid_X4I8 :: Monoid a_X4I6) ->
      GHC.Base.$fSemigroupIO
        @ a_X4I6 (GHC.Base.$p1Monoid @ a_X4I6 $dMonoid_X4I8)

-- RHS size: {terms: 20, types: 41, coercions: 4, joins: 0/0}
$cmappend_r7PH
  :: forall a.
     Monoid a =>
     IO a -> IO a -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=OtherCon []]
$cmappend_r7PH
  = \ (@ a_X4I8)
      ($dMonoid_X4Ia :: Monoid a_X4I8)
      (eta_X8Q :: IO a_X4I8)
      (eta1_XhE :: IO a_X4I8)
      (eta2_B1 :: State# RealWorld) ->
      case (eta_X8Q
            `cast` (GHC.Types.N:IO[0] <a_X4I8>_R
                    :: (IO a_X4I8 :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_X4I8 #) :: *)))
             eta2_B1
      of
      { (# ipv_s5fT, ipv1_s5fU #) ->
      case (eta1_XhE
            `cast` (GHC.Types.N:IO[0] <a_X4I8>_R
                    :: (IO a_X4I8 :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_X4I8 #) :: *)))
             ipv_s5fT
      of
      { (# ipv2_X5rv, ipv3_X5rx #) ->
      (# ipv2_X5rv,
         <>
           @ a_X4I8
           (GHC.Base.$p1Monoid @ a_X4I8 $dMonoid_X4Ia)
           ipv1_s5fU
           ipv3_X5rx #)
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
GHC.Base.$fMonoidIO_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a. Monoid a => IO a -> IO a -> IO a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_X4QY) ($dMonoid_X4R1 [Occ=OnceL] :: Monoid a_X4QY) ->
                 let {
                   $dSemigroup_X4Je [Occ=OnceL] :: Semigroup a_X4QY
                   [LclId]
                   $dSemigroup_X4Je = GHC.Base.$p1Monoid @ a_X4QY $dMonoid_X4R1 } in
                 (\ (eta_X8X [Occ=Once] :: IO a_X4QY)
                    (eta1_XhS [Occ=Once] :: IO a_X4QY)
                    (eta2_B1 [Occ=Once] :: State# RealWorld) ->
                    case (eta_X8X
                          `cast` (GHC.Types.N:IO[0] <a_X4QY>_R
                                  :: (IO a_X4QY :: *)
                                     ~R# (State# RealWorld -> (# State# RealWorld, a_X4QY #) :: *)))
                           eta2_B1
                    of
                    { (# ipv_s5fT [Occ=Once], ipv1_s5fU [Occ=Once] #) ->
                    case (eta1_XhS
                          `cast` (GHC.Types.N:IO[0] <a_X4QY>_R
                                  :: (IO a_X4QY :: *)
                                     ~R# (State# RealWorld -> (# State# RealWorld, a_X4QY #) :: *)))
                           ipv_s5fT
                    of
                    { (# ipv2_X5rv [Occ=Once], ipv3_X5rx [Occ=Once] #) ->
                    (# ipv2_X5rv, <> @ a_X4QY $dSemigroup_X4Je ipv1_s5fU ipv3_X5rx #)
                    }
                    })
                 `cast` (<IO a_X4QY>_R
                         ->_R <IO a_X4QY>_R
                         ->_R Sym (GHC.Types.N:IO[0] <a_X4QY>_R)
                         :: (IO a_X4QY
                             -> IO a_X4QY
                             -> State# RealWorld
                             -> (# State# RealWorld, a_X4QY #) :: *)
                            ~R# (IO a_X4QY -> IO a_X4QY -> IO a_X4QY :: *))}]
GHC.Base.$fMonoidIO_$cmappend
  = $cmappend_r7PH
    `cast` (forall (a :: <*>_N).
            <Monoid a>_R
            ->_R <IO a>_R
            ->_R <IO a>_R
            ->_R Sym (GHC.Types.N:IO[0] <a>_R)
            :: (forall a.
                Monoid a =>
                IO a -> IO a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
               ~R# (forall a. Monoid a => IO a -> IO a -> IO a :: *))

-- RHS size: {terms: 5, types: 13, coercions: 0, joins: 0/0}
GHC.Base.$fAlternativeIO1
  :: forall a. State# RealWorld -> (# State# RealWorld, [a] #)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4HN) (s_a3ff [Occ=Once] :: State# RealWorld) ->
                 (# s_a3ff, GHC.Types.[] @ a_a4HN #)}]
GHC.Base.$fAlternativeIO1
  = \ (@ a_a4HN) (s_a3ff :: State# RealWorld) ->
      (# s_a3ff, GHC.Types.[] @ a_a4HN #)

-- RHS size: {terms: 22, types: 55, coercions: 13, joins: 0/1}
GHC.Base.$fAlternativeIO2
  :: forall a.
     IO a -> State# RealWorld -> (# State# RealWorld, [a] #)
[GblId,
 Arity=2,
 Str=<C(S(SL)),C(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4HN)
                 (v_a37o [Occ=Once] :: IO a_a4HN)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 letrec {
                   some_v_s5vE [Occ=LoopBreaker]
                     :: State# RealWorld -> (# State# RealWorld, [a_a4HN] #)
                   [LclId, Arity=1, Unf=OtherCon []]
                   some_v_s5vE
                     = \ (s_a3fi [Occ=Once] :: State# RealWorld) ->
                         case (v_a37o
                               `cast` (GHC.Types.N:IO[0] <a_a4HN>_R
                                       :: (IO a_a4HN :: *)
                                          ~R# (State# RealWorld
                                               -> (# State# RealWorld, a_a4HN #) :: *)))
                                s_a3fi
                         of
                         { (# ipv_s5fT [Occ=Once], ipv1_s5fU [Occ=Once] #) ->
                         case ((mplusIO
                                  @ [a_a4HN]
                                  (some_v_s5vE
                                   `cast` (Sym (GHC.Types.N:IO[0] <[a_a4HN]>_R)
                                           :: (State# RealWorld
                                               -> (# State# RealWorld, [a_a4HN] #) :: *)
                                              ~R# (IO [a_a4HN] :: *)))
                                  ((GHC.Base.$fAlternativeIO1 @ a_a4HN)
                                   `cast` (Sym (GHC.Types.N:IO[0] <[a_a4HN]>_R)
                                           :: (State# RealWorld
                                               -> (# State# RealWorld, [a_a4HN] #) :: *)
                                              ~R# (IO [a_a4HN] :: *))))
                               `cast` (GHC.Types.N:IO[0] <[a_a4HN]>_R
                                       :: (IO [a_a4HN] :: *)
                                          ~R# (State# RealWorld
                                               -> (# State# RealWorld, [a_a4HN] #) :: *)))
                                ipv_s5fT
                         of
                         { (# ipv2_X5rv [Occ=Once], ipv3_X5rx [Occ=Once] #) ->
                         (# ipv2_X5rv, GHC.Types.: @ a_a4HN ipv1_s5fU ipv3_X5rx #)
                         }
                         }; } in
                 some_v_s5vE eta_B1}]
GHC.Base.$fAlternativeIO2
  = \ (@ a_a4HN)
      (v_a37o :: IO a_a4HN)
      (eta_B1 :: State# RealWorld) ->
      letrec {
        some_v_s5vE [Occ=LoopBreaker]
          :: State# RealWorld -> (# State# RealWorld, [a_a4HN] #)
        [LclId, Arity=1, Str=<S,U>, Unf=OtherCon []]
        some_v_s5vE
          = \ (s_a3fi :: State# RealWorld) ->
              case (v_a37o
                    `cast` (GHC.Types.N:IO[0] <a_a4HN>_R
                            :: (IO a_a4HN :: *)
                               ~R# (State# RealWorld -> (# State# RealWorld, a_a4HN #) :: *)))
                     s_a3fi
              of
              { (# ipv_s5fT, ipv1_s5fU #) ->
              case ((mplusIO
                       @ [a_a4HN]
                       (some_v_s5vE
                        `cast` (Sym (GHC.Types.N:IO[0] <[a_a4HN]>_R)
                                :: (State# RealWorld -> (# State# RealWorld, [a_a4HN] #) :: *)
                                   ~R# (IO [a_a4HN] :: *)))
                       ((GHC.Base.$fAlternativeIO1 @ a_a4HN)
                        `cast` (Sym (GHC.Types.N:IO[0] <[a_a4HN]>_R)
                                :: (State# RealWorld -> (# State# RealWorld, [a_a4HN] #) :: *)
                                   ~R# (IO [a_a4HN] :: *))))
                    `cast` (GHC.Types.N:IO[0] <[a_a4HN]>_R
                            :: (IO [a_a4HN] :: *)
                               ~R# (State# RealWorld -> (# State# RealWorld, [a_a4HN] #) :: *)))
                     ipv_s5fT
              of
              { (# ipv2_X5rv, ipv3_X5rx #) ->
              (# ipv2_X5rv, GHC.Types.: @ a_a4HN ipv1_s5fU ipv3_X5rx #)
              }
              }; } in
      some_v_s5vE eta_B1

-- RHS size: {terms: 20, types: 45, coercions: 13, joins: 0/1}
GHC.Base.$fAlternativeIO_$cmany :: forall a. IO a -> IO [a]
[GblId,
 Arity=1,
 Str=<L,C(U(U,U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60] 90 0}]
GHC.Base.$fAlternativeIO_$cmany
  = \ (@ a_a4HV) (v_a37r :: IO a_a4HV) ->
      letrec {
        many_v_s5vC [Occ=LoopBreaker] :: IO [a_a4HV]
        [LclId]
        many_v_s5vC
          = mplusIO
              @ [a_a4HV]
              ((\ (s_a3fi :: State# RealWorld) ->
                  case (v_a37r
                        `cast` (GHC.Types.N:IO[0] <a_a4HV>_R
                                :: (IO a_a4HV :: *)
                                   ~R# (State# RealWorld -> (# State# RealWorld, a_a4HV #) :: *)))
                         s_a3fi
                  of
                  { (# ipv_s5fT, ipv1_s5fU #) ->
                  case (many_v_s5vC
                        `cast` (GHC.Types.N:IO[0] <[a_a4HV]>_R
                                :: (IO [a_a4HV] :: *)
                                   ~R# (State# RealWorld -> (# State# RealWorld, [a_a4HV] #) :: *)))
                         ipv_s5fT
                  of
                  { (# ipv2_X5rv, ipv3_X5rx #) ->
                  (# ipv2_X5rv, GHC.Types.: @ a_a4HV ipv1_s5fU ipv3_X5rx #)
                  }
                  })
               `cast` (Sym (GHC.Types.N:IO[0] <[a_a4HV]>_R)
                       :: (State# RealWorld -> (# State# RealWorld, [a_a4HV] #) :: *)
                          ~R# (IO [a_a4HV] :: *)))
              ((GHC.Base.$fAlternativeIO1 @ a_a4HV)
               `cast` (Sym (GHC.Types.N:IO[0] <[a_a4HV]>_R)
                       :: (State# RealWorld -> (# State# RealWorld, [a_a4HV] #) :: *)
                          ~R# (IO [a_a4HV] :: *))); } in
      many_v_s5vC

-- RHS size: {terms: 41, types: 92, coercions: 10, joins: 0/0}
GHC.Base.liftM9
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> IO a1
     -> IO a2
     -> IO a3
     -> IO a4
     -> IO a5
     -> State# RealWorld
     -> (# State# RealWorld, r #)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 60 60 60 60 0] 160 30}]
GHC.Base.liftM9
  = \ (@ a1_a45v)
      (@ a2_a45w)
      (@ a3_a45x)
      (@ a4_a45y)
      (@ a5_a45z)
      (@ r_a45A)
      (f_a3ef
         :: a1_a45v -> a2_a45w -> a3_a45x -> a4_a45y -> a5_a45z -> r_a45A)
      (m1_a3eg :: IO a1_a45v)
      (m2_a3eh :: IO a2_a45w)
      (m3_a3ei :: IO a3_a45x)
      (m4_a3ej :: IO a4_a45y)
      (m5_a3ek :: IO a5_a45z)
      (s_a3fi :: State# RealWorld) ->
      case (m1_a3eg
            `cast` (GHC.Types.N:IO[0] <a1_a45v>_R
                    :: (IO a1_a45v :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a1_a45v #) :: *)))
             s_a3fi
      of
      { (# ipv_s5fT, ipv1_s5fU #) ->
      case (m2_a3eh
            `cast` (GHC.Types.N:IO[0] <a2_a45w>_R
                    :: (IO a2_a45w :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a2_a45w #) :: *)))
             ipv_s5fT
      of
      { (# ipv2_X5sa, ipv3_X5sc #) ->
      case (m3_a3ei
            `cast` (GHC.Types.N:IO[0] <a3_a45x>_R
                    :: (IO a3_a45x :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a3_a45x #) :: *)))
             ipv2_X5sa
      of
      { (# ipv4_X5sg, ipv5_X5si #) ->
      case (m4_a3ej
            `cast` (GHC.Types.N:IO[0] <a4_a45y>_R
                    :: (IO a4_a45y :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a4_a45y #) :: *)))
             ipv4_X5sg
      of
      { (# ipv6_X5sm, ipv7_X5so #) ->
      case (m5_a3ek
            `cast` (GHC.Types.N:IO[0] <a5_a45z>_R
                    :: (IO a5_a45z :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a5_a45z #) :: *)))
             ipv6_X5sm
      of
      { (# ipv8_X5ss, ipv9_X5su #) ->
      (# ipv8_X5ss,
         f_a3ef ipv1_s5fU ipv3_X5sc ipv5_X5si ipv7_X5so ipv9_X5su #)
      }
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 43, joins: 0/0}
GHC.Base.liftM5_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 a5 r.
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> IO a1 -> IO a2 -> IO a3 -> IO a4 -> IO a5 -> IO r
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(C1(U)))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.liftM9
               `cast` (forall (a1 :: <*>_N) (a2 :: <*>_N) (a3 :: <*>_N) (a4 :: <*>_N) (a5 :: <*>_N) (r :: <*>_N).
                       <a1 -> a2 -> a3 -> a4 -> a5 -> r>_R
                       ->_R <IO a1>_R
                       ->_R <IO a2>_R
                       ->_R <IO a3>_R
                       ->_R <IO a4>_R
                       ->_R <IO a5>_R
                       ->_R Sym (GHC.Types.N:IO[0] <r>_R)
                       :: (forall a1 a2 a3 a4 a5 r.
                           (a1 -> a2 -> a3 -> a4 -> a5 -> r)
                           -> IO a1
                           -> IO a2
                           -> IO a3
                           -> IO a4
                           -> IO a5
                           -> State# RealWorld
                           -> (# State# RealWorld, r #) :: *)
                          ~R# (forall a1 a2 a3 a4 a5 r.
                               (a1 -> a2 -> a3 -> a4 -> a5 -> r)
                               -> IO a1 -> IO a2 -> IO a3 -> IO a4 -> IO a5 -> IO r :: *))}]
GHC.Base.liftM5_$sliftM1
  = GHC.Base.liftM9
    `cast` (forall (a1 :: <*>_N) (a2 :: <*>_N) (a3 :: <*>_N) (a4 :: <*>_N) (a5 :: <*>_N) (r :: <*>_N).
            <a1 -> a2 -> a3 -> a4 -> a5 -> r>_R
            ->_R <IO a1>_R
            ->_R <IO a2>_R
            ->_R <IO a3>_R
            ->_R <IO a4>_R
            ->_R <IO a5>_R
            ->_R Sym (GHC.Types.N:IO[0] <r>_R)
            :: (forall a1 a2 a3 a4 a5 r.
                (a1 -> a2 -> a3 -> a4 -> a5 -> r)
                -> IO a1
                -> IO a2
                -> IO a3
                -> IO a4
                -> IO a5
                -> State# RealWorld
                -> (# State# RealWorld, r #) :: *)
               ~R# (forall a1 a2 a3 a4 a5 r.
                    (a1 -> a2 -> a3 -> a4 -> a5 -> r)
                    -> IO a1 -> IO a2 -> IO a3 -> IO a4 -> IO a5 -> IO r :: *))

-- RHS size: {terms: 42, types: 56, coercions: 0, joins: 0/0}
liftM5 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 a4 a5 r.
     Monad m =>
     (a1 -> a2 -> a3 -> a4 -> a5 -> r)
     -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(C1(C1(U)))))><L,U><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [180 60 0 0 0 0 0] 340 0
         Tmpl= \ (@ (m_a44d :: * -> *))
                 (@ a1_a44e)
                 (@ a2_a44f)
                 (@ a3_a44g)
                 (@ a4_a44h)
                 (@ a5_a44i)
                 (@ r_a44j)
                 ($dMonad_a44l :: Monad m_a44d)
                 (f_X3qy [Occ=OnceL!]
                    :: a1_a44e -> a2_a44f -> a3_a44g -> a4_a44h -> a5_a44i -> r_a44j)
                 (m1_X3qA [Occ=Once] :: m_a44d a1_a44e)
                 (m2_X3qC [Occ=OnceL] :: m_a44d a2_a44f)
                 (m3_X3qE [Occ=OnceL] :: m_a44d a3_a44g)
                 (m4_X3qG [Occ=OnceL] :: m_a44d a4_a44h)
                 (m5_X3qI [Occ=OnceL] :: m_a44d a5_a44i) ->
                 >>=
                   @ m_a44d
                   $dMonad_a44l
                   @ a1_a44e
                   @ r_a44j
                   m1_X3qA
                   (\ (x1_a3el [Occ=OnceL] :: a1_a44e) ->
                      >>=
                        @ m_a44d
                        $dMonad_a44l
                        @ a2_a44f
                        @ r_a44j
                        m2_X3qC
                        (\ (x2_a3em [Occ=OnceL] :: a2_a44f) ->
                           >>=
                             @ m_a44d
                             $dMonad_a44l
                             @ a3_a44g
                             @ r_a44j
                             m3_X3qE
                             (\ (x3_a3en [Occ=OnceL] :: a3_a44g) ->
                                >>=
                                  @ m_a44d
                                  $dMonad_a44l
                                  @ a4_a44h
                                  @ r_a44j
                                  m4_X3qG
                                  (\ (x4_a3eo [Occ=OnceL] :: a4_a44h) ->
                                     >>=
                                       @ m_a44d
                                       $dMonad_a44l
                                       @ a5_a44i
                                       @ r_a44j
                                       m5_X3qI
                                       (\ (x5_a3ep [Occ=Once] :: a5_a44i) ->
                                          return
                                            @ m_a44d
                                            $dMonad_a44l
                                            @ r_a44j
                                            (f_X3qy x1_a3el x2_a3em x3_a3en x4_a3eo x5_a3ep))))))}]
liftM5
  = \ (@ (m_a44d :: * -> *))
      (@ a1_a44e)
      (@ a2_a44f)
      (@ a3_a44g)
      (@ a4_a44h)
      (@ a5_a44i)
      (@ r_a44j)
      ($dMonad_a44l :: Monad m_a44d)
      (f_X3qy
         :: a1_a44e -> a2_a44f -> a3_a44g -> a4_a44h -> a5_a44i -> r_a44j)
      (m1_X3qA :: m_a44d a1_a44e)
      (m2_X3qC :: m_a44d a2_a44f)
      (m3_X3qE :: m_a44d a3_a44g)
      (m4_X3qG :: m_a44d a4_a44h)
      (m5_X3qI :: m_a44d a5_a44i) ->
      >>=
        @ m_a44d
        $dMonad_a44l
        @ a1_a44e
        @ r_a44j
        m1_X3qA
        (\ (x1_a3el :: a1_a44e) ->
           >>=
             @ m_a44d
             $dMonad_a44l
             @ a2_a44f
             @ r_a44j
             m2_X3qC
             (\ (x2_a3em :: a2_a44f) ->
                >>=
                  @ m_a44d
                  $dMonad_a44l
                  @ a3_a44g
                  @ r_a44j
                  m3_X3qE
                  (\ (x3_a3en :: a3_a44g) ->
                     >>=
                       @ m_a44d
                       $dMonad_a44l
                       @ a4_a44h
                       @ r_a44j
                       m4_X3qG
                       (\ (x4_a3eo :: a4_a44h) ->
                          >>=
                            @ m_a44d
                            $dMonad_a44l
                            @ a5_a44i
                            @ r_a44j
                            m5_X3qI
                            (\ (x5_a3ep :: a5_a44i) ->
                               return
                                 @ m_a44d
                                 $dMonad_a44l
                                 @ r_a44j
                                 (f_X3qy x1_a3el x2_a3em x3_a3en x4_a3eo x5_a3ep))))))

-- RHS size: {terms: 34, types: 76, coercions: 8, joins: 0/0}
GHC.Base.liftM8
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> IO a1
     -> IO a2
     -> IO a3
     -> IO a4
     -> State# RealWorld
     -> (# State# RealWorld, r #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a1_a47Q)
                 (@ a2_a47R)
                 (@ a3_a47S)
                 (@ a4_a47T)
                 (@ r_a47U)
                 (f_a3e6 [Occ=Once!]
                    :: a1_a47Q -> a2_a47R -> a3_a47S -> a4_a47T -> r_a47U)
                 (m1_a3e7 [Occ=Once] :: IO a1_a47Q)
                 (m2_a3e8 [Occ=Once] :: IO a2_a47R)
                 (m3_a3e9 [Occ=Once] :: IO a3_a47S)
                 (m4_a3ea [Occ=Once] :: IO a4_a47T)
                 (s_a3fi [Occ=Once] :: State# RealWorld) ->
                 case (m1_a3e7
                       `cast` (GHC.Types.N:IO[0] <a1_a47Q>_R
                               :: (IO a1_a47Q :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a1_a47Q #) :: *)))
                        s_a3fi
                 of
                 { (# ipv_s5fT [Occ=Once], ipv1_s5fU [Occ=Once] #) ->
                 case (m2_a3e8
                       `cast` (GHC.Types.N:IO[0] <a2_a47R>_R
                               :: (IO a2_a47R :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a2_a47R #) :: *)))
                        ipv_s5fT
                 of
                 { (# ipv2_X5so [Occ=Once], ipv3_X5sq [Occ=Once] #) ->
                 case (m3_a3e9
                       `cast` (GHC.Types.N:IO[0] <a3_a47S>_R
                               :: (IO a3_a47S :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a3_a47S #) :: *)))
                        ipv2_X5so
                 of
                 { (# ipv4_X5su [Occ=Once], ipv5_X5sw [Occ=Once] #) ->
                 case (m4_a3ea
                       `cast` (GHC.Types.N:IO[0] <a4_a47T>_R
                               :: (IO a4_a47T :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a4_a47T #) :: *)))
                        ipv4_X5su
                 of
                 { (# ipv6_X5sA [Occ=Once], ipv7_X5sC [Occ=Once] #) ->
                 (# ipv6_X5sA, f_a3e6 ipv1_s5fU ipv3_X5sq ipv5_X5sw ipv7_X5sC #)
                 }
                 }
                 }
                 }}]
GHC.Base.liftM8
  = \ (@ a1_a47Q)
      (@ a2_a47R)
      (@ a3_a47S)
      (@ a4_a47T)
      (@ r_a47U)
      (f_a3e6 :: a1_a47Q -> a2_a47R -> a3_a47S -> a4_a47T -> r_a47U)
      (m1_a3e7 :: IO a1_a47Q)
      (m2_a3e8 :: IO a2_a47R)
      (m3_a3e9 :: IO a3_a47S)
      (m4_a3ea :: IO a4_a47T)
      (s_a3fi :: State# RealWorld) ->
      case (m1_a3e7
            `cast` (GHC.Types.N:IO[0] <a1_a47Q>_R
                    :: (IO a1_a47Q :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a1_a47Q #) :: *)))
             s_a3fi
      of
      { (# ipv_s5fT, ipv1_s5fU #) ->
      case (m2_a3e8
            `cast` (GHC.Types.N:IO[0] <a2_a47R>_R
                    :: (IO a2_a47R :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a2_a47R #) :: *)))
             ipv_s5fT
      of
      { (# ipv2_X5so, ipv3_X5sq #) ->
      case (m3_a3e9
            `cast` (GHC.Types.N:IO[0] <a3_a47S>_R
                    :: (IO a3_a47S :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a3_a47S #) :: *)))
             ipv2_X5so
      of
      { (# ipv4_X5su, ipv5_X5sw #) ->
      case (m4_a3ea
            `cast` (GHC.Types.N:IO[0] <a4_a47T>_R
                    :: (IO a4_a47T :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a4_a47T #) :: *)))
             ipv4_X5su
      of
      { (# ipv6_X5sA, ipv7_X5sC #) ->
      (# ipv6_X5sA, f_a3e6 ipv1_s5fU ipv3_X5sq ipv5_X5sw ipv7_X5sC #)
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 36, joins: 0/0}
GHC.Base.liftM4_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 a4 r.
     (a1 -> a2 -> a3 -> a4 -> r)
     -> IO a1 -> IO a2 -> IO a3 -> IO a4 -> IO r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(C1(U))))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.liftM8
               `cast` (forall (a1 :: <*>_N) (a2 :: <*>_N) (a3 :: <*>_N) (a4 :: <*>_N) (r :: <*>_N).
                       <a1 -> a2 -> a3 -> a4 -> r>_R
                       ->_R <IO a1>_R
                       ->_R <IO a2>_R
                       ->_R <IO a3>_R
                       ->_R <IO a4>_R
                       ->_R Sym (GHC.Types.N:IO[0] <r>_R)
                       :: (forall a1 a2 a3 a4 r.
                           (a1 -> a2 -> a3 -> a4 -> r)
                           -> IO a1
                           -> IO a2
                           -> IO a3
                           -> IO a4
                           -> State# RealWorld
                           -> (# State# RealWorld, r #) :: *)
                          ~R# (forall a1 a2 a3 a4 r.
                               (a1 -> a2 -> a3 -> a4 -> r)
                               -> IO a1 -> IO a2 -> IO a3 -> IO a4 -> IO r :: *))}]
GHC.Base.liftM4_$sliftM1
  = GHC.Base.liftM8
    `cast` (forall (a1 :: <*>_N) (a2 :: <*>_N) (a3 :: <*>_N) (a4 :: <*>_N) (r :: <*>_N).
            <a1 -> a2 -> a3 -> a4 -> r>_R
            ->_R <IO a1>_R
            ->_R <IO a2>_R
            ->_R <IO a3>_R
            ->_R <IO a4>_R
            ->_R Sym (GHC.Types.N:IO[0] <r>_R)
            :: (forall a1 a2 a3 a4 r.
                (a1 -> a2 -> a3 -> a4 -> r)
                -> IO a1
                -> IO a2
                -> IO a3
                -> IO a4
                -> State# RealWorld
                -> (# State# RealWorld, r #) :: *)
               ~R# (forall a1 a2 a3 a4 r.
                    (a1 -> a2 -> a3 -> a4 -> r)
                    -> IO a1 -> IO a2 -> IO a3 -> IO a4 -> IO r :: *))

-- RHS size: {terms: 35, types: 47, coercions: 0, joins: 0/0}
liftM4 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 a4 r.
     Monad m =>
     (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(C1(U))))><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [150 60 0 0 0 0] 280 0
         Tmpl= \ (@ (m_a46K :: * -> *))
                 (@ a1_a46L)
                 (@ a2_a46M)
                 (@ a3_a46N)
                 (@ a4_a46O)
                 (@ r_a46P)
                 ($dMonad_a46R :: Monad m_a46K)
                 (f_X3qC [Occ=OnceL!]
                    :: a1_a46L -> a2_a46M -> a3_a46N -> a4_a46O -> r_a46P)
                 (m1_X3qE [Occ=Once] :: m_a46K a1_a46L)
                 (m2_X3qG [Occ=OnceL] :: m_a46K a2_a46M)
                 (m3_X3qI [Occ=OnceL] :: m_a46K a3_a46N)
                 (m4_X3qK [Occ=OnceL] :: m_a46K a4_a46O) ->
                 >>=
                   @ m_a46K
                   $dMonad_a46R
                   @ a1_a46L
                   @ r_a46P
                   m1_X3qE
                   (\ (x1_a3eb [Occ=OnceL] :: a1_a46L) ->
                      >>=
                        @ m_a46K
                        $dMonad_a46R
                        @ a2_a46M
                        @ r_a46P
                        m2_X3qG
                        (\ (x2_a3ec [Occ=OnceL] :: a2_a46M) ->
                           >>=
                             @ m_a46K
                             $dMonad_a46R
                             @ a3_a46N
                             @ r_a46P
                             m3_X3qI
                             (\ (x3_a3ed [Occ=OnceL] :: a3_a46N) ->
                                >>=
                                  @ m_a46K
                                  $dMonad_a46R
                                  @ a4_a46O
                                  @ r_a46P
                                  m4_X3qK
                                  (\ (x4_a3ee [Occ=Once] :: a4_a46O) ->
                                     return
                                       @ m_a46K
                                       $dMonad_a46R
                                       @ r_a46P
                                       (f_X3qC x1_a3eb x2_a3ec x3_a3ed x4_a3ee)))))}]
liftM4
  = \ (@ (m_a46K :: * -> *))
      (@ a1_a46L)
      (@ a2_a46M)
      (@ a3_a46N)
      (@ a4_a46O)
      (@ r_a46P)
      ($dMonad_a46R :: Monad m_a46K)
      (f_X3qC :: a1_a46L -> a2_a46M -> a3_a46N -> a4_a46O -> r_a46P)
      (m1_X3qE :: m_a46K a1_a46L)
      (m2_X3qG :: m_a46K a2_a46M)
      (m3_X3qI :: m_a46K a3_a46N)
      (m4_X3qK :: m_a46K a4_a46O) ->
      >>=
        @ m_a46K
        $dMonad_a46R
        @ a1_a46L
        @ r_a46P
        m1_X3qE
        (\ (x1_a3eb :: a1_a46L) ->
           >>=
             @ m_a46K
             $dMonad_a46R
             @ a2_a46M
             @ r_a46P
             m2_X3qG
             (\ (x2_a3ec :: a2_a46M) ->
                >>=
                  @ m_a46K
                  $dMonad_a46R
                  @ a3_a46N
                  @ r_a46P
                  m3_X3qI
                  (\ (x3_a3ed :: a3_a46N) ->
                     >>=
                       @ m_a46K
                       $dMonad_a46R
                       @ a4_a46O
                       @ r_a46P
                       m4_X3qK
                       (\ (x4_a3ee :: a4_a46O) ->
                          return
                            @ m_a46K
                            $dMonad_a46R
                            @ r_a46P
                            (f_X3qC x1_a3eb x2_a3ec x3_a3ed x4_a3ee)))))

-- RHS size: {terms: 1, types: 0, coercions: 29, joins: 0/0}
GHC.Base.liftM3_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r) -> IO a1 -> IO a2 -> IO a3 -> IO r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,U))><L,1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.liftA1
               `cast` (forall (a1 :: <*>_N) (a2 :: <*>_N) (a3 :: <*>_N) (r :: <*>_N).
                       <a1 -> a2 -> a3 -> r>_R
                       ->_R <IO a1>_R
                       ->_R <IO a2>_R
                       ->_R <IO a3>_R
                       ->_R Sym (GHC.Types.N:IO[0] <r>_R)
                       :: (forall a1 a2 a3 r.
                           (a1 -> a2 -> a3 -> r)
                           -> IO a1
                           -> IO a2
                           -> IO a3
                           -> State# RealWorld
                           -> (# State# RealWorld, r #) :: *)
                          ~R# (forall a1 a2 a3 r.
                               (a1 -> a2 -> a3 -> r) -> IO a1 -> IO a2 -> IO a3 -> IO r :: *))}]
GHC.Base.liftM3_$sliftM1
  = GHC.Base.liftA1
    `cast` (forall (a1 :: <*>_N) (a2 :: <*>_N) (a3 :: <*>_N) (r :: <*>_N).
            <a1 -> a2 -> a3 -> r>_R
            ->_R <IO a1>_R
            ->_R <IO a2>_R
            ->_R <IO a3>_R
            ->_R Sym (GHC.Types.N:IO[0] <r>_R)
            :: (forall a1 a2 a3 r.
                (a1 -> a2 -> a3 -> r)
                -> IO a1
                -> IO a2
                -> IO a3
                -> State# RealWorld
                -> (# State# RealWorld, r #) :: *)
               ~R# (forall a1 a2 a3 r.
                    (a1 -> a2 -> a3 -> r) -> IO a1 -> IO a2 -> IO a3 -> IO r :: *))

-- RHS size: {terms: 28, types: 38, coercions: 0, joins: 0/0}
liftM3 [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 a2 a3 r.
     Monad m =>
     (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,C(C1(C1(U)))><L,U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [120 60 0 0 0] 220 0
         Tmpl= \ (@ (m_a48U :: * -> *))
                 (@ a1_a48V)
                 (@ a2_a48W)
                 (@ a3_a48X)
                 (@ r_a48Y)
                 ($dMonad_a490 :: Monad m_a48U)
                 (f_X3qG [Occ=OnceL!] :: a1_a48V -> a2_a48W -> a3_a48X -> r_a48Y)
                 (m1_X3qI [Occ=Once] :: m_a48U a1_a48V)
                 (m2_X3qK [Occ=OnceL] :: m_a48U a2_a48W)
                 (m3_X3qM [Occ=OnceL] :: m_a48U a3_a48X) ->
                 >>=
                   @ m_a48U
                   $dMonad_a490
                   @ a1_a48V
                   @ r_a48Y
                   m1_X3qI
                   (\ (x1_a3e3 [Occ=OnceL] :: a1_a48V) ->
                      >>=
                        @ m_a48U
                        $dMonad_a490
                        @ a2_a48W
                        @ r_a48Y
                        m2_X3qK
                        (\ (x2_a3e4 [Occ=OnceL] :: a2_a48W) ->
                           >>=
                             @ m_a48U
                             $dMonad_a490
                             @ a3_a48X
                             @ r_a48Y
                             m3_X3qM
                             (\ (x3_a3e5 [Occ=Once] :: a3_a48X) ->
                                return
                                  @ m_a48U
                                  $dMonad_a490
                                  @ r_a48Y
                                  (f_X3qG x1_a3e3 x2_a3e4 x3_a3e5))))}]
liftM3
  = \ (@ (m_a48U :: * -> *))
      (@ a1_a48V)
      (@ a2_a48W)
      (@ a3_a48X)
      (@ r_a48Y)
      ($dMonad_a490 :: Monad m_a48U)
      (f_X3qG :: a1_a48V -> a2_a48W -> a3_a48X -> r_a48Y)
      (m1_X3qI :: m_a48U a1_a48V)
      (m2_X3qK :: m_a48U a2_a48W)
      (m3_X3qM :: m_a48U a3_a48X) ->
      >>=
        @ m_a48U
        $dMonad_a490
        @ a1_a48V
        @ r_a48Y
        m1_X3qI
        (\ (x1_a3e3 :: a1_a48V) ->
           >>=
             @ m_a48U
             $dMonad_a490
             @ a2_a48W
             @ r_a48Y
             m2_X3qK
             (\ (x2_a3e4 :: a2_a48W) ->
                >>=
                  @ m_a48U
                  $dMonad_a490
                  @ a3_a48X
                  @ r_a48Y
                  m3_X3qM
                  (\ (x3_a3e5 :: a3_a48X) ->
                     return
                       @ m_a48U $dMonad_a490 @ r_a48Y (f_X3qG x1_a3e3 x2_a3e4 x3_a3e5))))

-- RHS size: {terms: 1, types: 0, coercions: 15, joins: 0/0}
GHC.Base.liftM_$sliftM1 [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> IO a1 -> IO r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(S(SL)),1*C1(U(U,U))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.$fFunctorIO2
               `cast` (forall (a1 :: <*>_N) (r :: <*>_N).
                       <a1 -> r>_R ->_R <IO a1>_R ->_R Sym (GHC.Types.N:IO[0] <r>_R)
                       :: (forall a1 r.
                           (a1 -> r)
                           -> IO a1 -> State# RealWorld -> (# State# RealWorld, r #) :: *)
                          ~R# (forall a1 r. (a1 -> r) -> IO a1 -> IO r :: *))}]
GHC.Base.liftM_$sliftM1
  = GHC.Base.$fFunctorIO2
    `cast` (forall (a1 :: <*>_N) (r :: <*>_N).
            <a1 -> r>_R ->_R <IO a1>_R ->_R Sym (GHC.Types.N:IO[0] <r>_R)
            :: (forall a1 r.
                (a1 -> r)
                -> IO a1 -> State# RealWorld -> (# State# RealWorld, r #) :: *)
               ~R# (forall a1 r. (a1 -> r) -> IO a1 -> IO r :: *))

-- RHS size: {terms: 14, types: 20, coercions: 0, joins: 0/0}
liftM [InlPrag=INLINABLE]
  :: forall (m :: * -> *) a1 r. Monad m => (a1 -> r) -> m a1 -> m r
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,C(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_a4c7 :: * -> *))
                 (@ a1_a4c8)
                 (@ r_a4c9)
                 ($dMonad_a4cb :: Monad m_a4c7)
                 (f_X3qO [Occ=OnceL!] :: a1_a4c8 -> r_a4c9)
                 (m1_X3qQ [Occ=Once] :: m_a4c7 a1_a4c8) ->
                 >>=
                   @ m_a4c7
                   $dMonad_a4cb
                   @ a1_a4c8
                   @ r_a4c9
                   m1_X3qQ
                   (\ (x1_a3dT [Occ=Once] :: a1_a4c8) ->
                      return @ m_a4c7 $dMonad_a4cb @ r_a4c9 (f_X3qO x1_a3dT))}]
liftM
  = \ (@ (m_a4c7 :: * -> *))
      (@ a1_a4c8)
      (@ r_a4c9)
      ($dMonad_a4cb :: Monad m_a4c7)
      (f_X3qO :: a1_a4c8 -> r_a4c9)
      (m1_X3qQ :: m_a4c7 a1_a4c8) ->
      >>=
        @ m_a4c7
        $dMonad_a4cb
        @ a1_a4c8
        @ r_a4c9
        m1_X3qQ
        (\ (x1_a3dT :: a1_a4c8) ->
           return @ m_a4c7 $dMonad_a4cb @ r_a4c9 (f_X3qO x1_a3dT))

-- RHS size: {terms: 10, types: 9, coercions: 0, joins: 0/0}
$! :: forall a (b :: TYPE r). (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (r_a41c :: RuntimeRep))
                 (@ a_a41d)
                 (@ (b_a41e :: TYPE r_a41c))
                 (f_a3f7 [Occ=Once!] :: a_a41d -> b_a41e)
                 (x_a3f8 [Occ=Once] :: a_a41d) ->
                 case x_a3f8 of vx_a3f9 { __DEFAULT -> f_a3f7 vx_a3f9 }}]
$!
  = \ (@ (r_a41c :: RuntimeRep))
      (@ a_a41d)
      (@ (b_a41e :: TYPE r_a41c))
      (f_a3f7 :: a_a41d -> b_a41e)
      (x_a3f8 :: a_a41d) ->
      case x_a3f8 of vx_a3f9 { __DEFAULT -> f_a3f7 vx_a3f9 }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
$ [InlPrag=INLINE (sat-args=2)]
  :: forall a (b :: TYPE r). (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ (r_a41n :: RuntimeRep))
                 (@ a_a41o)
                 (@ (b_a41p :: TYPE r_a41n))
                 (f_a3f5 [Occ=Once!] :: a_a41o -> b_a41p)
                 (x_a3f6 [Occ=Once] :: a_a41o) ->
                 f_a3f5 x_a3f6}]
$ = \ (@ (r_a41n :: RuntimeRep))
      (@ a_a41o)
      (@ (b_a41p :: TYPE r_a41n))
      (f_a3f5 :: a_a41o -> b_a41p)
      (x_a3f6 :: a_a41o) ->
      f_a3f5 x_a3f6

-- RHS size: {terms: 9, types: 11, coercions: 0, joins: 0/0}
flip :: forall a b c. (a -> b -> c) -> b -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a41r)
                 (@ b_a41s)
                 (@ c_a41t)
                 (f_a3f2 [Occ=Once!] :: a_a41r -> b_a41s -> c_a41t)
                 (x_a3f3 [Occ=Once] :: b_a41s)
                 (y_a3f4 [Occ=Once] :: a_a41r) ->
                 f_a3f2 y_a3f4 x_a3f3}]
flip
  = \ (@ a_a41r)
      (@ b_a41s)
      (@ c_a41t)
      (f_a3f2 :: a_a41r -> b_a41s -> c_a41t)
      (x_a3f3 :: b_a41s)
      (y_a3f4 :: a_a41r) ->
      f_a3f2 y_a3f4 x_a3f3

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
GHC.Base.$fMonad(->)_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall r a b. (r -> a) -> (r -> b) -> r -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ r_a4tI)
                 (@ a_a4tW)
                 (@ b_a4tX)
                 _ [Occ=Dead]
                 (k_a37C [Occ=Once!] :: r_a4tI -> b_a4tX)
                 (r1_a394 [Occ=Once] :: r_a4tI) ->
                 k_a37C r1_a394}]
GHC.Base.$fMonad(->)_$c>>
  = \ (@ r_a4tI)
      (@ a_a4tW)
      (@ b_a4tX)
      _ [Occ=Dead]
      (eta1_B1 :: r_a4tI -> b_a4tX)
      (r1_a394 :: r_a4tI) ->
      eta1_B1 r1_a394

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
GHC.Base.$fApplicative(->)_$c<*
  :: forall a1 a2 b. (a1 -> a2) -> (a1 -> b) -> a1 -> a2
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,A><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a4Lw)
                 (@ a1_a4M8)
                 (@ b_a4M9)
                 (f_a39a [Occ=Once!] :: a_a4Lw -> a1_a4M8)
                 _ [Occ=Dead]
                 (x_a39c [Occ=Once] :: a_a4Lw) ->
                 f_a39a x_a39c}]
GHC.Base.$fApplicative(->)_$c<*
  = \ (@ a_a4Lw)
      (@ a1_a4M8)
      (@ b_a4M9)
      (f_a39a :: a_a4Lw -> a1_a4M8)
      _ [Occ=Dead]
      (x_a39c :: a_a4Lw) ->
      f_a39a x_a39c

-- RHS size: {terms: 19, types: 28, coercions: 0, joins: 0/0}
GHC.Base.$fMonad(,)_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a. Monoid a => forall a1 b. (a, a1) -> (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,A)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4ul)
                 ($dMonoid_a4um [Occ=Once] :: Monoid a_a4ul)
                 (@ a1_a4uF)
                 (@ b_a4uG)
                 (m_a37B [Occ=Once!] :: (a_a4ul, a1_a4uF))
                 (k_a37C [Occ=Once!] :: (a_a4ul, b_a4uG)) ->
                 case m_a37B of { (u_a39h [Occ=Once], _ [Occ=Dead]) ->
                 case k_a37C of { (v_a39k [Occ=Once], b1_a39l [Occ=Once]) ->
                 (<>
                    @ a_a4ul (GHC.Base.$p1Monoid @ a_a4ul $dMonoid_a4um) u_a39h v_a39k,
                  b1_a39l)
                 }
                 }}]
GHC.Base.$fMonad(,)_$c>>
  = \ (@ a_a4ul)
      ($dMonoid_a4um :: Monoid a_a4ul)
      (@ a1_a4uF)
      (@ b_a4uG)
      (eta_X9o :: (a_a4ul, a1_a4uF))
      (eta1_B1 :: (a_a4ul, b_a4uG)) ->
      case eta_X9o of { (u_a39h, a2_a39i) ->
      case eta1_B1 of { (v_a39k, b1_a39l) ->
      (<>
         @ a_a4ul (GHC.Base.$p1Monoid @ a_a4ul $dMonoid_a4um) u_a39h v_a39k,
       b1_a39l)
      }
      }

-- RHS size: {terms: 19, types: 28, coercions: 0, joins: 0/0}
GHC.Base.$fApplicative(,)_$c<*
  :: forall a. Monoid a => forall a1 b. (a, a1) -> (a, b) -> (a, a1)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><S,1*U(U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4vv)
                 ($dMonoid_a4vw [Occ=Once] :: Monoid a_a4vv)
                 (@ a1_a4wf)
                 (@ b_a4wg)
                 (eta_X9r [Occ=Once!] :: (a_a4vv, a1_a4wf))
                 (eta1_B1 [Occ=Once!] :: (a_a4vv, b_a4wg)) ->
                 case eta_X9r of { (u_a39t [Occ=Once], x_a39u [Occ=Once]) ->
                 case eta1_B1 of { (v_a39v [Occ=Once], _ [Occ=Dead]) ->
                 (<>
                    @ a_a4vv (GHC.Base.$p1Monoid @ a_a4vv $dMonoid_a4vw) u_a39t v_a39v,
                  x_a39u)
                 }
                 }}]
GHC.Base.$fApplicative(,)_$c<*
  = \ (@ a_a4vv)
      ($dMonoid_a4vw :: Monoid a_a4vv)
      (@ a1_a4wf)
      (@ b_a4wg)
      (eta_X9r :: (a_a4vv, a1_a4wf))
      (eta1_B1 :: (a_a4vv, b_a4wg)) ->
      case eta_X9r of { (u_a39t, x_a39u) ->
      case eta1_B1 of { (v_a39v, y_a39w) ->
      (<>
         @ a_a4vv (GHC.Base.$p1Monoid @ a_a4vv $dMonoid_a4vw) u_a39t v_a39v,
       x_a39u)
      }
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
GHC.Base.$fFunctor(,)_$c<$
  :: forall a1 a2 b. a2 -> (a1, b) -> (a1, a2)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U(U,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4MV)
                 (@ a1_a4N5)
                 (@ b_a4N6)
                 (x_X3oq [Occ=Once] :: a1_a4N5)
                 (ds_d5bV [Occ=Once!] :: (a_a4MV, b_a4N6)) ->
                 case ds_d5bV of { (x1_a38Z [Occ=Once], _ [Occ=Dead]) ->
                 (x1_a38Z, x_X3oq)
                 }}]
GHC.Base.$fFunctor(,)_$c<$
  = \ (@ a_a4MV)
      (@ a1_a4N5)
      (@ b_a4N6)
      (x_X3oq :: a1_a4N5)
      (ds_d5bV :: (a_a4MV, b_a4N6)) ->
      case ds_d5bV of { (x1_a38Z, y_a390) -> (x1_a38Z, x_X3oq) }

-- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
GHC.Base.$fFunctorMaybe_$c<$ :: forall a b. a -> Maybe b -> Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4MM)
                 (@ b_a4MN)
                 (x_X3oq [Occ=Once] :: a_a4MM)
                 (ds_d5bP [Occ=Once!] :: Maybe b_a4MN) ->
                 case ds_d5bP of {
                   Nothing -> GHC.Base.Nothing @ a_a4MM;
                   Just _ [Occ=Dead] -> GHC.Base.Just @ a_a4MM x_X3oq
                 }}]
GHC.Base.$fFunctorMaybe_$c<$
  = \ (@ a_a4MM)
      (@ b_a4MN)
      (x_X3oq :: a_a4MM)
      (ds_d5bP :: Maybe b_a4MN) ->
      case ds_d5bP of {
        Nothing -> GHC.Base.Nothing @ a_a4MM;
        Just a1_a38W -> GHC.Base.Just @ a_a4MM x_X3oq
      }

-- RHS size: {terms: 9, types: 15, coercions: 0, joins: 0/0}
GHC.Base.$dm<$
  :: forall (f :: * -> *). Functor f => forall a b. a -> f b -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(C(S)L),1*U(1*C1(U),A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a37T :: * -> *))
                 ($dFunctor_a4ii [Occ=OnceL] :: Functor f_a37T)
                 (@ a_a4ik)
                 (@ b_a4il) ->
                 let {
                   f1_a3eZ [Occ=OnceL!]
                     :: (b_a4il -> a_a4ik) -> f_a37T b_a4il -> f_a37T a_a4ik
                   [LclId]
                   f1_a3eZ = fmap @ f_a37T $dFunctor_a4ii @ b_a4il @ a_a4ik } in
                 \ (x_X3ow [Occ=OnceL] :: a_a4ik) ->
                   f1_a3eZ (\ _ [Occ=Dead] -> x_X3ow)}]
GHC.Base.$dm<$
  = \ (@ (f_a37T :: * -> *))
      ($dFunctor_a4ii :: Functor f_a37T)
      (@ a_a4ik)
      (@ b_a4il)
      (eta_B1 :: a_a4ik) ->
      fmap
        @ f_a37T
        $dFunctor_a4ii
        @ b_a4il
        @ a_a4ik
        (\ _ [Occ=Dead] -> eta_B1)

-- RHS size: {terms: 13, types: 13, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(->)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall b a. Monoid b => (a -> b) -> (a -> b) -> a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ b_a4zA)
                 (@ a_a4zB)
                 ($dMonoid_a4zC [Occ=OnceL] :: Monoid b_a4zA) ->
                 let {
                   $dSemigroup_a4EX [Occ=OnceL] :: Semigroup b_a4zA
                   [LclId]
                   $dSemigroup_a4EX = GHC.Base.$p1Monoid @ b_a4zA $dMonoid_a4zC } in
                 \ (f_a3aU [Occ=Once!] :: a_a4zB -> b_a4zA)
                   (g_a3aV [Occ=Once!] :: a_a4zB -> b_a4zA)
                   (x_a3aW :: a_a4zB) ->
                   <> @ b_a4zA $dSemigroup_a4EX (f_a3aU x_a3aW) (g_a3aV x_a3aW)}]
GHC.Base.$fMonoid(->)_$cmappend
  = \ (@ b_a4zA)
      (@ a_a4zB)
      ($dMonoid_a4zC :: Monoid b_a4zA)
      (eta_X9w :: a_a4zB -> b_a4zA)
      (eta1_Xj0 :: a_a4zB -> b_a4zA)
      (eta2_B1 :: a_a4zB) ->
      <>
        @ b_a4zA
        (GHC.Base.$p1Monoid @ b_a4zA $dMonoid_a4zC)
        (eta_X9w eta2_B1)
        (eta1_Xj0 eta2_B1)

-- RHS size: {terms: 23, types: 30, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b. (Monoid a, Monoid b) => (a, b) -> (a, b) -> (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4yP)
                 (@ b_a4yQ)
                 ($dMonoid_a4yR [Occ=OnceL] :: Monoid a_a4yP)
                 ($dMonoid1_a4yS [Occ=OnceL] :: Monoid b_a4yQ) ->
                 let {
                   $dSemigroup_a4E8 [Occ=OnceL] :: Semigroup a_a4yP
                   [LclId]
                   $dSemigroup_a4E8 = GHC.Base.$p1Monoid @ a_a4yP $dMonoid_a4yR } in
                 let {
                   $dSemigroup1_a4E9 [Occ=OnceL] :: Semigroup b_a4yQ
                   [LclId]
                   $dSemigroup1_a4E9 = GHC.Base.$p1Monoid @ b_a4yQ $dMonoid1_a4yS } in
                 \ (ds_d59g [Occ=Once!] :: (a_a4yP, b_a4yQ))
                   (ds1_d59h [Occ=Once!] :: (a_a4yP, b_a4yQ)) ->
                   case ds_d59g of { (a1_a3aJ [Occ=Once], b1_a3aK [Occ=Once]) ->
                   case ds1_d59h of { (a'_a3aL [Occ=Once], b'_a3aM [Occ=Once]) ->
                   (<> @ a_a4yP $dSemigroup_a4E8 a1_a3aJ a'_a3aL,
                    <> @ b_a4yQ $dSemigroup1_a4E9 b1_a3aK b'_a3aM)
                   }
                   }}]
GHC.Base.$fMonoid(,)_$cmappend
  = \ (@ a_a4yP)
      (@ b_a4yQ)
      ($dMonoid_a4yR :: Monoid a_a4yP)
      ($dMonoid1_a4yS :: Monoid b_a4yQ)
      (eta_X9x :: (a_a4yP, b_a4yQ))
      (eta1_B1 :: (a_a4yP, b_a4yQ)) ->
      case eta_X9x of { (a1_a3aJ, b1_a3aK) ->
      case eta1_B1 of { (a'_a3aL, b'_a3aM) ->
      (<>
         @ a_a4yP
         (GHC.Base.$p1Monoid @ a_a4yP $dMonoid_a4yR)
         a1_a3aJ
         a'_a3aL,
       <>
         @ b_a4yQ
         (GHC.Base.$p1Monoid @ b_a4yQ $dMonoid1_a4yS)
         b1_a3aK
         b'_a3aM)
      }
      }

Rec {
-- RHS size: {terms: 17, types: 9, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroupOrdering_go [Occ=LoopBreaker]
  :: Ordering -> [Ordering] -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []]
GHC.Base.$fSemigroupOrdering_go
  = \ (b_a384 :: Ordering) (ds_d548 :: [Ordering]) ->
      case ds_d548 of {
        [] -> b_a384;
        : c_a385 cs_a386 ->
          case b_a384 of {
            LT -> GHC.Types.LT;
            EQ -> GHC.Base.$fSemigroupOrdering_go c_a385 cs_a386;
            GT -> GHC.Types.GT
          }
      }
end Rec }

-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroupOrdering_$csconcat
  :: NonEmpty Ordering -> Ordering
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_X5dv [Occ=Once!] :: NonEmpty Ordering) ->
                 case ds_X5dv of { :| a_a381 [Occ=Once] as_a382 [Occ=Once] ->
                 GHC.Base.$fSemigroupOrdering_go a_a381 as_a382
                 }}]
GHC.Base.$fSemigroupOrdering_$csconcat
  = \ (ds_X5dv :: NonEmpty Ordering) ->
      case ds_X5dv of { :| a_a381 as_a382 ->
      GHC.Base.$fSemigroupOrdering_go a_a381 as_a382
      }

-- RHS size: {terms: 9, types: 11, coercions: 0, joins: 0/0}
. [InlPrag=INLINE (sat-args=2)]
  :: forall b c a. (b -> c) -> (a -> b) -> a -> c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ b_a41v)
                 (@ c_a41w)
                 (@ a_a41x)
                 (f_a3eZ [Occ=Once!] :: b_a41v -> c_a41w)
                 (g_a3f0 [Occ=Once!] :: a_a41x -> b_a41v)
                 (x_X3oz [Occ=Once] :: a_a41x) ->
                 f_a3eZ (g_a3f0 x_X3oz)}]
. = \ (@ b_a41v)
      (@ c_a41w)
      (@ a_a41x)
      (f_a3eZ :: b_a41v -> c_a41w)
      (g_a3f0 :: a_a41x -> b_a41v)
      (x_X3oz :: a_a41x) ->
      f_a3eZ (g_a3f0 x_X3oz)

Rec {
-- RHS size: {terms: 11, types: 13, coercions: 0, joins: 0/0}
mapFB [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall elt lst a.
     (elt -> lst -> lst) -> (a -> elt) -> a -> lst -> lst
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ elt_a42v)
                 (@ lst_a42w)
                 (@ a_a42x)
                 (c_a3eF [Occ=Once!] :: elt_a42v -> lst_a42w -> lst_a42w)
                 (f_a3eG [Occ=Once!] :: a_a42x -> elt_a42v)
                 (x_a3eH [Occ=Once] :: a_a42x)
                 (ys_a3eI [Occ=Once] :: lst_a42w) ->
                 c_a3eF (f_a3eG x_a3eH) ys_a3eI}]
mapFB
  = \ (@ elt_a42v)
      (@ lst_a42w)
      (@ a_a42x)
      (c_a3eF :: elt_a42v -> lst_a42w -> lst_a42w)
      (f_a3eG :: a_a42x -> elt_a42v)
      (x_a3eH :: a_a42x)
      (ys_a3eI :: lst_a42w) ->
      c_a3eF (f_a3eG x_a3eH) ys_a3eI
end Rec }

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
GHC.Base.$fFunctor(->)_$c<$
  :: forall r a b. a -> (r -> b) -> r -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ r_a4Ne)
                 (@ a_a4Nr)
                 (@ b_a4Ns)
                 (x_X3oA [Occ=Once] :: a_a4Nr)
                 _ [Occ=Dead]
                 _ [Occ=Dead] ->
                 x_X3oA}]
GHC.Base.$fFunctor(->)_$c<$
  = \ (@ r_a4Ne)
      (@ a_a4Nr)
      (@ b_a4Ns)
      (x_X3oA :: a_a4Nr)
      _ [Occ=Dead]
      _ [Occ=Dead] ->
      x_X3oA

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
GHC.Base.$fFunctor(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall r. Functor ((->) r)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ r_a39d) ->
       GHC.Base.C:Functor TYPE: (->) r_a39d
                          \ (@ a_a4Ni) (@ b_a4Nj) -> . @ a_a4Ni @ b_a4Nj @ r_a39d
                          GHC.Base.$fFunctor(->)_$c<$ @ r_a39d]
GHC.Base.$fFunctor(->)
  = \ (@ r_a4Ne) ->
      GHC.Base.C:Functor
        @ ((->) r_a4Ne)
        (\ (@ a_a4Ni) (@ b_a4Nj) -> . @ a_a4Ni @ b_a4Nj @ r_a4Ne)
        (GHC.Base.$fFunctor(->)_$c<$ @ r_a4Ne)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
const :: forall a b. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a41z)
                 (@ b_a41A)
                 (x_a3eY [Occ=Once] :: a_a41z)
                 _ [Occ=Dead] ->
                 x_a3eY}]
const
  = \ (@ a_a41z) (@ b_a41A) (x_a3eY :: a_a41z) _ [Occ=Dead] -> x_a3eY

-- RHS size: {terms: 2, types: 4, coercions: 0, joins: 0/0}
asTypeOf :: forall a. a -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a41C) -> const @ a_a41C @ a_a41C}]
asTypeOf = \ (@ a_a41C) -> const @ a_a41C @ a_a41C

-- RHS size: {terms: 7, types: 16, coercions: 0, joins: 0/0}
GHC.Base.$dm<*
  :: forall (f :: * -> *).
     Applicative f =>
     forall a b. f a -> f b -> f a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a37E :: * -> *))
                 ($dApplicative_a4iy [Occ=Once] :: Applicative f_a37E)
                 (@ a_a4jg)
                 (@ b_a4jh) ->
                 liftA2
                   @ f_a37E
                   $dApplicative_a4iy
                   @ a_a4jg
                   @ b_a4jh
                   @ a_a4jg
                   (const @ a_a4jg @ b_a4jh)}]
GHC.Base.$dm<*
  = \ (@ (f_a37E :: * -> *))
      ($dApplicative_a4iy :: Applicative f_a37E)
      (@ a_a4jg)
      (@ b_a4jh) ->
      liftA2
        @ f_a37E
        $dApplicative_a4iy
        @ a_a4jg
        @ b_a4jh
        @ a_a4jg
        (const @ a_a4jg @ b_a4jh)

-- RHS size: {terms: 16, types: 39, coercions: 4, joins: 0/0}
GHC.Base.$fApplicativeIO1
  :: forall a b.
     IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S(SL)),1*C1(U(U,U))><L,1*C1(U(U,A))><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4JP)
                 (@ b_a4JQ)
                 (m1_X3nE [Occ=Once] :: IO a_a4JP)
                 (m2_X3nG [Occ=Once] :: IO b_a4JQ)
                 (s_X3p3 [Occ=Once] :: State# RealWorld) ->
                 case (m1_X3nE
                       `cast` (GHC.Types.N:IO[0] <a_a4JP>_R
                               :: (IO a_a4JP :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, a_a4JP #) :: *)))
                        s_X3p3
                 of
                 { (# ipv_s5fT [Occ=Once], ipv1_s5fU [Occ=Once] #) ->
                 case (m2_X3nG
                       `cast` (GHC.Types.N:IO[0] <b_a4JQ>_R
                               :: (IO b_a4JQ :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, b_a4JQ #) :: *)))
                        ipv_s5fT
                 of
                 { (# ipv2_X5rv [Occ=Once], _ [Occ=Dead] #) ->
                 (# ipv2_X5rv, ipv1_s5fU #)
                 }
                 }}]
GHC.Base.$fApplicativeIO1
  = \ (@ a_a4JP)
      (@ b_a4JQ)
      (m1_X3nE :: IO a_a4JP)
      (m2_X3nG :: IO b_a4JQ)
      (s_X3p3 :: State# RealWorld) ->
      case (m1_X3nE
            `cast` (GHC.Types.N:IO[0] <a_a4JP>_R
                    :: (IO a_a4JP :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_a4JP #) :: *)))
             s_X3p3
      of
      { (# ipv_s5fT, ipv1_s5fU #) ->
      case (m2_X3nG
            `cast` (GHC.Types.N:IO[0] <b_a4JQ>_R
                    :: (IO b_a4JQ :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, b_a4JQ #) :: *)))
             ipv_s5fT
      of
      { (# ipv2_X5rv, ipv3_X5rx #) ->
      (# ipv2_X5rv, ipv1_s5fU #)
      }
      }

-- RHS size: {terms: 9, types: 7, coercions: 54, joins: 0/0}
GHC.Base.$fApplicativeIO [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative IO
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: IO
                              GHC.Base.$fFunctorIO
                              GHC.Base.$fApplicativeIO4
                              `cast` (forall (a :: <*>_N).
                                      <a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                                      :: (forall a.
                                          a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                                         ~R# (forall a. a -> IO a :: *))
                              (\ (@ a_a4Jj) (@ b_a4Jk) ->
                                 GHC.Base.$fApplicativeIO3 @ b_a4Jk @ a_a4Jj)
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <IO (a -> b)>_R
                                      ->_R <IO a>_R
                                      ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                                      :: (forall a b.
                                          IO (a -> b)
                                          -> IO a
                                          -> State# RealWorld
                                          -> (# State# RealWorld, b #) :: *)
                                         ~R# (forall a b. IO (a -> b) -> IO a -> IO b :: *))
                              GHC.Base.$fApplicativeIO_$cliftA2
                              GHC.Base.$fApplicativeIO2
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                                      :: (forall a b.
                                          IO a
                                          -> IO b
                                          -> State# RealWorld
                                          -> (# State# RealWorld, b #) :: *)
                                         ~R# (forall a b. IO a -> IO b -> IO b :: *))
                              GHC.Base.$fApplicativeIO1
                              `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                      <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                                      :: (forall a b.
                                          IO a
                                          -> IO b
                                          -> State# RealWorld
                                          -> (# State# RealWorld, a #) :: *)
                                         ~R# (forall a b. IO a -> IO b -> IO a :: *))]
GHC.Base.$fApplicativeIO
  = GHC.Base.C:Applicative
      @ IO
      GHC.Base.$fFunctorIO
      (GHC.Base.$fApplicativeIO4
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
               :: (forall a.
                   a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                  ~R# (forall a. a -> IO a :: *)))
      ((\ (@ a_a4Jj) (@ b_a4Jk) ->
          GHC.Base.$fApplicativeIO3 @ b_a4Jk @ a_a4Jj)
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <IO (a -> b)>_R ->_R <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
               :: (forall a b.
                   IO (a -> b)
                   -> IO a -> State# RealWorld -> (# State# RealWorld, b #) :: *)
                  ~R# (forall a b. IO (a -> b) -> IO a -> IO b :: *)))
      GHC.Base.$fApplicativeIO_$cliftA2
      (GHC.Base.$fApplicativeIO2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
               :: (forall a b.
                   IO a -> IO b -> State# RealWorld -> (# State# RealWorld, b #) :: *)
                  ~R# (forall a b. IO a -> IO b -> IO b :: *)))
      (GHC.Base.$fApplicativeIO1
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
               :: (forall a b.
                   IO a -> IO b -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                  ~R# (forall a b. IO a -> IO b -> IO a :: *)))

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
breakpointCond :: forall a. Bool -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a41G) _ [Occ=Dead] (r_a3eX [Occ=Once] :: a_a41G) ->
                 r_a3eX}]
breakpointCond
  = \ (@ a_a41G) _ [Occ=Dead] (r_a3eX :: a_a41G) -> r_a3eX

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
breakpoint :: forall a. a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a41I) (r_a3eW [Occ=Once] :: a_a41I) -> r_a3eW}]
breakpoint = \ (@ a_a41I) (r_a3eW :: a_a41I) -> r_a3eW

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
assert :: forall a. Bool -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a41K) _ [Occ=Dead] (r_a3eV [Occ=Once] :: a_a41K) ->
                 r_a3eV}]
assert = breakpointCond

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
id :: forall a. a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a41M) (x_a3eT [Occ=Once] :: a_a41M) -> x_a3eT}]
id = breakpoint

-- RHS size: {terms: 8, types: 17, coercions: 0, joins: 0/0}
join :: forall (m :: * -> *) a. Monad m => m (m a) -> m a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_a4eZ :: * -> *))
                 (@ a_a4f0)
                 ($dMonad_a4f2 [Occ=Once] :: Monad m_a4eZ)
                 (x_a3dF [Occ=Once] :: m_a4eZ (m_a4eZ a_a4f0)) ->
                 >>=
                   @ m_a4eZ
                   $dMonad_a4f2
                   @ (m_a4eZ a_a4f0)
                   @ a_a4f0
                   x_a3dF
                   (breakpoint @ (m_a4eZ a_a4f0))}]
join
  = \ (@ (m_a4eZ :: * -> *))
      (@ a_a4f0)
      ($dMonad_a4f2 :: Monad m_a4eZ)
      (x_a3dF :: m_a4eZ (m_a4eZ a_a4f0)) ->
      >>=
        @ m_a4eZ
        $dMonad_a4f2
        @ (m_a4eZ a_a4f0)
        @ a_a4f0
        x_a3dF
        (breakpoint @ (m_a4eZ a_a4f0))

-- RHS size: {terms: 7, types: 17, coercions: 0, joins: 0/0}
GHC.Base.$dm<*>
  :: forall (f :: * -> *).
     Applicative f =>
     forall a b. f (a -> b) -> f a -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a37E :: * -> *))
                 ($dApplicative_a4iy [Occ=Once] :: Applicative f_a37E)
                 (@ a_a4iA)
                 (@ b_a4iB) ->
                 liftA2
                   @ f_a37E
                   $dApplicative_a4iy
                   @ (a_a4iA -> b_a4iB)
                   @ a_a4iA
                   @ b_a4iB
                   (breakpoint @ (a_a4iA -> b_a4iB))}]
GHC.Base.$dm<*>
  = \ (@ (f_a37E :: * -> *))
      ($dApplicative_a4iy :: Applicative f_a37E)
      (@ a_a4iA)
      (@ b_a4iB) ->
      liftA2
        @ f_a37E
        $dApplicative_a4iy
        @ (a_a4iA -> b_a4iB)
        @ a_a4iA
        @ b_a4iB
        (breakpoint @ (a_a4iA -> b_a4iB))

-- RHS size: {terms: 14, types: 23, coercions: 0, joins: 0/0}
GHC.Base.$dm*>
  :: forall (f :: * -> *).
     Applicative f =>
     forall a b. f a -> f b -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(1*U(A,1*C1(C1(U))),A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a37E :: * -> *))
                 ($dApplicative_a4iy :: Applicative f_a37E)
                 (@ a_a4j1)
                 (@ b_a4j2) ->
                 let {
                   $dFunctor_a4j9 [Occ=OnceL] :: Functor f_a37E
                   [LclId]
                   $dFunctor_a4j9
                     = GHC.Base.$p1Applicative @ f_a37E $dApplicative_a4iy } in
                 \ (a1_a37R [Occ=Once] :: f_a37E a_a4j1)
                   (a2_a37S [Occ=Once] :: f_a37E b_a4j2) ->
                   <*>
                     @ f_a37E
                     $dApplicative_a4iy
                     @ b_a4j2
                     @ b_a4j2
                     (<$
                        @ f_a37E
                        $dFunctor_a4j9
                        @ (b_a4j2 -> b_a4j2)
                        @ a_a4j1
                        (breakpoint @ b_a4j2)
                        a1_a37R)
                     a2_a37S}]
GHC.Base.$dm*>
  = \ (@ (f_a37E :: * -> *))
      ($dApplicative_a4iy :: Applicative f_a37E)
      (@ a_a4j1)
      (@ b_a4j2)
      (eta_X9R :: f_a37E a_a4j1)
      (eta1_B1 :: f_a37E b_a4j2) ->
      <*>
        @ f_a37E
        $dApplicative_a4iy
        @ b_a4j2
        @ b_a4j2
        (<$
           @ f_a37E
           (GHC.Base.$p1Applicative @ f_a37E $dApplicative_a4iy)
           @ (b_a4j2 -> b_a4j2)
           @ a_a4j1
           (breakpoint @ b_a4j2)
           eta_X9R)
        eta1_B1

-- RHS size: {terms: 8, types: 11, coercions: 0, joins: 0/0}
GHC.Base.$fApplicative(->)_$c*>
  :: forall a1 a2 b. (a1 -> a2) -> (a1 -> b) -> a1 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a4Lw)
                 (@ a1_a4LY)
                 (@ b_a4LZ)
                 _ [Occ=Dead]
                 (a3_a37S [Occ=Once!] :: a_a4Lw -> b_a4LZ)
                 (x_a398 [Occ=Once] :: a_a4Lw) ->
                 a3_a37S x_a398}]
GHC.Base.$fApplicative(->)_$c*>
  = \ (@ a_a4Lw)
      (@ a1_a4LY)
      (@ b_a4LZ)
      _ [Occ=Dead]
      (a3_a37S :: a_a4Lw -> b_a4LZ)
      (x_a398 :: a_a4Lw) ->
      a3_a37S x_a398

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
maxInt :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
maxInt = GHC.Types.I# 9223372036854775807#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
minInt :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
minInt = GHC.Types.I# -9223372036854775808#

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
ord :: Char -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d50p [Occ=Once!] :: Char) ->
                 case ds_d50p of { C# c#_a3eO [Occ=Once] ->
                 GHC.Types.I# (ord# c#_a3eO)
                 }}]
ord
  = \ (ds_d50p :: Char) ->
      case ds_d50p of { C# c#_a3eO -> GHC.Types.I# (ord# c#_a3eO) }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
unsafeChr :: Int -> Char
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d50t [Occ=Once!] :: Int) ->
                 case ds_d50t of { I# i#_a3eN [Occ=Once] ->
                 GHC.Types.C# (chr# i#_a3eN)
                 }}]
unsafeChr
  = \ (ds_d50t :: Int) ->
      case ds_d50t of { I# i#_a3eN -> GHC.Types.C# (chr# i#_a3eN) }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
otherwise :: Bool
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Types.True}]
otherwise = GHC.Types.True

-- RHS size: {terms: 17, types: 11, coercions: 0, joins: 1/1}
until :: forall a. (a -> Bool) -> (a -> a) -> a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><L,C(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a41W)
                 (p_a3fa [Occ=OnceL!] :: a_a41W -> Bool)
                 (f_a3fb [Occ=OnceL!] :: a_a41W -> a_a41W)
                 (eta_B1 [Occ=Once] :: a_a41W) ->
                 joinrec {
                   go_s5vy [Occ=LoopBreakerT[1]] :: a_a41W -> a_a41W
                   [LclId[JoinId(1)], Arity=1, Unf=OtherCon []]
                   go_s5vy (x_a3fd :: a_a41W)
                     = case p_a3fa x_a3fd of {
                         False -> jump go_s5vy (f_a3fb x_a3fd);
                         True -> x_a3fd
                       }; } in
                 jump go_s5vy eta_B1}]
until
  = \ (@ a_a41W)
      (p_a3fa :: a_a41W -> Bool)
      (f_a3fb :: a_a41W -> a_a41W)
      (eta_B1 :: a_a41W) ->
      joinrec {
        go_s5vy [Occ=LoopBreaker] :: a_a41W -> a_a41W
        [LclId[JoinId(1)], Arity=1, Str=<L,U>, Unf=OtherCon []]
        go_s5vy (x_a3fd :: a_a41W)
          = case p_a3fa x_a3fd of {
              False -> jump go_s5vy (f_a3fb x_a3fd);
              True -> x_a3fd
            }; } in
      jump go_s5vy eta_B1

-- RHS size: {terms: 98, types: 41, coercions: 0, joins: 0/0}
divModInt# :: Int# -> Int# -> (# Int#, Int# #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 145 90}]
divModInt#
  = \ (x#_a3fH :: Int#) (y#_a3fI :: Int#) ->
      case ># x#_a3fH 0# of {
        __DEFAULT ->
          case <# x#_a3fH 0# of {
            __DEFAULT -> quotRemInt# x#_a3fH y#_a3fI;
            1# ->
              case ># y#_a3fI 0# of {
                __DEFAULT -> quotRemInt# x#_a3fH y#_a3fI;
                1# ->
                  case quotRemInt# (+# x#_a3fH 1#) y#_a3fI of
                  { (# ipv_s5eJ, ipv1_s5eK #) ->
                  (# -# ipv_s5eJ 1#, -# (+# ipv1_s5eK y#_a3fI) 1# #)
                  }
              }
          };
        1# ->
          case <# y#_a3fI 0# of {
            __DEFAULT ->
              case <# x#_a3fH 0# of {
                __DEFAULT -> quotRemInt# x#_a3fH y#_a3fI;
                1# ->
                  case ># y#_a3fI 0# of {
                    __DEFAULT -> quotRemInt# x#_a3fH y#_a3fI;
                    1# ->
                      case quotRemInt# (+# x#_a3fH 1#) y#_a3fI of
                      { (# ipv_s5eJ, ipv1_s5eK #) ->
                      (# -# ipv_s5eJ 1#, -# (+# ipv1_s5eK y#_a3fI) 1# #)
                      }
                  }
              };
            1# ->
              case quotRemInt# (-# x#_a3fH 1#) y#_a3fI of
              { (# ipv_s5eN, ipv1_s5eO #) ->
              (# -# ipv_s5eN 1#, +# (+# ipv1_s5eO y#_a3fI) 1# #)
              }
          }
      }

-- RHS size: {terms: 138, types: 75, coercions: 0, joins: 0/0}
divModInt [InlPrag=NOUSERINLINE[0]] :: Int -> Int -> (Int, Int)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s6GD [Occ=Once!] :: Int) (w1_s6GE [Occ=Once!] :: Int) ->
                 case w_s6GD of { I# ww1_s6GH ->
                 case w1_s6GE of { I# ww3_s6GL ->
                 case ># ww1_s6GH 0# of {
                   __DEFAULT ->
                     case <# ww1_s6GH 0# of {
                       __DEFAULT ->
                         case quotRemInt# ww1_s6GH ww3_s6GL of
                         { (# ipv_s5eT [Occ=Once], ipv1_s5eU [Occ=Once] #) ->
                         (GHC.Types.I# ipv_s5eT, GHC.Types.I# ipv1_s5eU)
                         };
                       1# ->
                         case ># ww3_s6GL 0# of {
                           __DEFAULT ->
                             case quotRemInt# ww1_s6GH ww3_s6GL of
                             { (# ipv_s5eT [Occ=Once], ipv1_s5eU [Occ=Once] #) ->
                             (GHC.Types.I# ipv_s5eT, GHC.Types.I# ipv1_s5eU)
                             };
                           1# ->
                             case quotRemInt# (+# ww1_s6GH 1#) ww3_s6GL of
                             { (# ipv_s5eJ [Occ=Once], ipv1_s5eK [Occ=Once] #) ->
                             (GHC.Types.I# (-# ipv_s5eJ 1#),
                              GHC.Types.I# (-# (+# ipv1_s5eK ww3_s6GL) 1#))
                             }
                         }
                     };
                   1# ->
                     case <# ww3_s6GL 0# of {
                       __DEFAULT ->
                         case <# ww1_s6GH 0# of {
                           __DEFAULT ->
                             case quotRemInt# ww1_s6GH ww3_s6GL of
                             { (# ipv_s5eT [Occ=Once], ipv1_s5eU [Occ=Once] #) ->
                             (GHC.Types.I# ipv_s5eT, GHC.Types.I# ipv1_s5eU)
                             };
                           1# ->
                             case ># ww3_s6GL 0# of {
                               __DEFAULT ->
                                 case quotRemInt# ww1_s6GH ww3_s6GL of
                                 { (# ipv_s5eT [Occ=Once], ipv1_s5eU [Occ=Once] #) ->
                                 (GHC.Types.I# ipv_s5eT, GHC.Types.I# ipv1_s5eU)
                                 };
                               1# ->
                                 case quotRemInt# (+# ww1_s6GH 1#) ww3_s6GL of
                                 { (# ipv_s5eJ [Occ=Once], ipv1_s5eK [Occ=Once] #) ->
                                 (GHC.Types.I# (-# ipv_s5eJ 1#),
                                  GHC.Types.I# (-# (+# ipv1_s5eK ww3_s6GL) 1#))
                                 }
                             }
                         };
                       1# ->
                         case quotRemInt# (-# ww1_s6GH 1#) ww3_s6GL of
                         { (# ipv_s5eN [Occ=Once], ipv1_s5eO [Occ=Once] #) ->
                         (GHC.Types.I# (-# ipv_s5eN 1#),
                          GHC.Types.I# (+# (+# ipv1_s5eO ww3_s6GL) 1#))
                         }
                     }
                 }
                 }
                 }}]
divModInt
  = \ (w_s6GD :: Int) (w1_s6GE :: Int) ->
      case w_s6GD of { I# ww1_s6GH ->
      case w1_s6GE of { I# ww3_s6GL ->
      case ># ww1_s6GH 0# of {
        __DEFAULT ->
          case <# ww1_s6GH 0# of {
            __DEFAULT ->
              case quotRemInt# ww1_s6GH ww3_s6GL of
              { (# ipv_s5eT, ipv1_s5eU #) ->
              (GHC.Types.I# ipv_s5eT, GHC.Types.I# ipv1_s5eU)
              };
            1# ->
              case ># ww3_s6GL 0# of {
                __DEFAULT ->
                  case quotRemInt# ww1_s6GH ww3_s6GL of
                  { (# ipv_s5eT, ipv1_s5eU #) ->
                  (GHC.Types.I# ipv_s5eT, GHC.Types.I# ipv1_s5eU)
                  };
                1# ->
                  case quotRemInt# (+# ww1_s6GH 1#) ww3_s6GL of
                  { (# ipv_s5eJ, ipv1_s5eK #) ->
                  (GHC.Types.I# (-# ipv_s5eJ 1#),
                   GHC.Types.I# (-# (+# ipv1_s5eK ww3_s6GL) 1#))
                  }
              }
          };
        1# ->
          case <# ww3_s6GL 0# of {
            __DEFAULT ->
              case <# ww1_s6GH 0# of {
                __DEFAULT ->
                  case quotRemInt# ww1_s6GH ww3_s6GL of
                  { (# ipv_s5eT, ipv1_s5eU #) ->
                  (GHC.Types.I# ipv_s5eT, GHC.Types.I# ipv1_s5eU)
                  };
                1# ->
                  case ># ww3_s6GL 0# of {
                    __DEFAULT ->
                      case quotRemInt# ww1_s6GH ww3_s6GL of
                      { (# ipv_s5eT, ipv1_s5eU #) ->
                      (GHC.Types.I# ipv_s5eT, GHC.Types.I# ipv1_s5eU)
                      };
                    1# ->
                      case quotRemInt# (+# ww1_s6GH 1#) ww3_s6GL of
                      { (# ipv_s5eJ, ipv1_s5eK #) ->
                      (GHC.Types.I# (-# ipv_s5eJ 1#),
                       GHC.Types.I# (-# (+# ipv1_s5eK ww3_s6GL) 1#))
                      }
                  }
              };
            1# ->
              case quotRemInt# (-# ww1_s6GH 1#) ww3_s6GL of
              { (# ipv_s5eN, ipv1_s5eO #) ->
              (GHC.Types.I# (-# ipv_s5eN 1#),
               GHC.Types.I# (+# (+# ipv1_s5eO ww3_s6GL) 1#))
              }
          }
      }
      }
      }

-- RHS size: {terms: 12, types: 3, coercions: 0, joins: 0/0}
shiftL# :: Word# -> Int# -> Word#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_a3fN [Occ=Once] :: Word#) (b_a3fO :: Int#) ->
                 case >=# b_a3fO 64# of {
                   __DEFAULT -> uncheckedShiftL# a_a3fN b_a3fO;
                   1# -> 0##
                 }}]
shiftL#
  = \ (a_a3fN :: Word#) (b_a3fO :: Int#) ->
      case >=# b_a3fO 64# of {
        __DEFAULT -> uncheckedShiftL# a_a3fN b_a3fO;
        1# -> 0##
      }

-- RHS size: {terms: 12, types: 3, coercions: 0, joins: 0/0}
shiftRL# :: Word# -> Int# -> Word#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_a3fP [Occ=Once] :: Word#) (b_a3fQ :: Int#) ->
                 case >=# b_a3fQ 64# of {
                   __DEFAULT -> uncheckedShiftRL# a_a3fP b_a3fQ;
                   1# -> 0##
                 }}]
shiftRL#
  = \ (a_a3fP :: Word#) (b_a3fQ :: Int#) ->
      case >=# b_a3fQ 64# of {
        __DEFAULT -> uncheckedShiftRL# a_a3fP b_a3fQ;
        1# -> 0##
      }

-- RHS size: {terms: 12, types: 3, coercions: 0, joins: 0/0}
iShiftL# :: Int# -> Int# -> Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_a3fR [Occ=Once] :: Int#) (b_a3fS :: Int#) ->
                 case >=# b_a3fS 64# of {
                   __DEFAULT -> uncheckedIShiftL# a_a3fR b_a3fS;
                   1# -> 0#
                 }}]
iShiftL#
  = \ (a_a3fR :: Int#) (b_a3fS :: Int#) ->
      case >=# b_a3fS 64# of {
        __DEFAULT -> uncheckedIShiftL# a_a3fR b_a3fS;
        1# -> 0#
      }

-- RHS size: {terms: 19, types: 4, coercions: 0, joins: 0/0}
iShiftRA# :: Int# -> Int# -> Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_a3fT [Occ=Once*] :: Int#) (b_a3fU :: Int#) ->
                 case >=# b_a3fU 64# of {
                   __DEFAULT -> uncheckedIShiftRA# a_a3fT b_a3fU;
                   1# ->
                     case <# a_a3fT 0# of {
                       __DEFAULT -> 0#;
                       1# -> -1#
                     }
                 }}]
iShiftRA#
  = \ (a_a3fT :: Int#) (b_a3fU :: Int#) ->
      case >=# b_a3fU 64# of {
        __DEFAULT -> uncheckedIShiftRA# a_a3fT b_a3fU;
        1# ->
          case <# a_a3fT 0# of {
            __DEFAULT -> 0#;
            1# -> -1#
          }
      }

-- RHS size: {terms: 12, types: 3, coercions: 0, joins: 0/0}
iShiftRL# :: Int# -> Int# -> Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (a_a3fV [Occ=Once] :: Int#) (b_a3fW :: Int#) ->
                 case >=# b_a3fW 64# of {
                   __DEFAULT -> uncheckedIShiftRL# a_a3fV b_a3fW;
                   1# -> 0#
                 }}]
iShiftRL#
  = \ (a_a3fV :: Int#) (b_a3fW :: Int#) ->
      case >=# b_a3fW 64# of {
        __DEFAULT -> uncheckedIShiftRL# a_a3fV b_a3fW;
        1# -> 0#
      }

-- RHS size: {terms: 5, types: 13, coercions: 0, joins: 0/0}
build [InlPrag=INLINE[1] (sat-args=1)]
  :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a42J)
                 (g_a3ez [Occ=Once!] :: forall b. (a_a42J -> b -> b) -> b -> b) ->
                 g_a3ez @ [a_a42J] (GHC.Types.: @ a_a42J) (GHC.Types.[] @ a_a42J)}]
build
  = \ (@ a_a42J)
      (g_a3ez :: forall b. (a_a42J -> b -> b) -> b -> b) ->
      g_a3ez @ [a_a42J] (GHC.Types.: @ a_a42J) (GHC.Types.[] @ a_a42J)

-- RHS size: {terms: 5, types: 5, coercions: 0, joins: 0/0}
GHC.Base.$fApplicative[]_$cpure [InlPrag=INLINE (sat-args=1)]
  :: forall a. a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m2,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4K5) (x_a38g [Occ=Once] :: a_a4K5) ->
                 build
                   @ a_a4K5
                   (\ (@ a1_d5aJ)
                      (c_d5aK [Occ=Once!, OS=OneShot] :: a_a4K5 -> a1_d5aJ -> a1_d5aJ)
                      (n_d5aL [Occ=Once, OS=OneShot] :: a1_d5aJ) ->
                      c_d5aK x_a38g n_d5aL)}]
GHC.Base.$fApplicative[]_$cpure
  = \ (@ a_a4K5) (x_a38g :: a_a4K5) ->
      GHC.Types.: @ a_a4K5 x_a38g (GHC.Types.[] @ a_a4K5)

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
augment [InlPrag=INLINE[1] (sat-args=2)]
  :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ a_a42F)
                 (g_a3eA [Occ=Once!] :: forall b. (a_a42F -> b -> b) -> b -> b)
                 (xs_a3eB [Occ=Once] :: [a_a42F]) ->
                 g_a3eA @ [a_a42F] (GHC.Types.: @ a_a42F) xs_a3eB}]
augment
  = \ (@ a_a42F)
      (g_a3eA :: forall b. (a_a42F -> b -> b) -> b -> b)
      (xs_a3eB :: [a_a42F]) ->
      g_a3eA @ [a_a42F] (GHC.Types.: @ a_a42F) xs_a3eB

Rec {
-- RHS size: {terms: 13, types: 13, coercions: 0, joins: 0/0}
++ [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. [a] -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []]
++
  = \ (@ a_a42r) (ds_d51i :: [a_a42r]) (ys_a3eJ :: [a_a42r]) ->
      case ds_d51i of {
        [] -> ys_a3eJ;
        : x_a3eK xs_a3eL ->
          GHC.Types.: @ a_a42r x_a3eK (++ @ a_a42r xs_a3eL ys_a3eJ)
      }

-- RHS size: {terms: 18, types: 20, coercions: 0, joins: 0/1}
foldr [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a42N)
                 (@ b_a42O)
                 (k_a3eu [Occ=OnceL!] :: a_a42N -> b_a42O -> b_a42O)
                 (z_a3ev [Occ=OnceL] :: b_a42O) ->
                 letrec {
                   go_X4cd [Occ=LoopBreaker] :: [a_a42N] -> b_a42O
                   [LclId, Arity=1, Unf=OtherCon []]
                   go_X4cd
                     = \ (ds_d51B [Occ=Once!] :: [a_a42N]) ->
                         case ds_d51B of {
                           [] -> z_a3ev;
                           : y_a3ex [Occ=Once] ys_a3ey [Occ=Once] ->
                             k_a3eu y_a3ex (go_X4cd ys_a3ey)
                         }; } in
                 go_X4cd}]
foldr
  = \ (@ a_a42N)
      (@ b_a42O)
      (k_a3eu :: a_a42N -> b_a42O -> b_a42O)
      (z_a3ev :: b_a42O)
      (eta_B1 :: [a_a42N]) ->
      letrec {
        go_s5vw [Occ=LoopBreaker] :: [a_a42N] -> b_a42O
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_s5vw
          = \ (ds_d51B :: [a_a42N]) ->
              case ds_d51B of {
                [] -> z_a3ev;
                : y_a3ex ys_a3ey -> k_a3eu y_a3ex (go_s5vw ys_a3ey)
              }; } in
      go_s5vw eta_B1

-- RHS size: {terms: 15, types: 17, coercions: 0, joins: 0/0}
map [InlPrag=NOINLINE[0], Occ=LoopBreaker]
  :: forall a b. (a -> b) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []]
map
  = \ (@ a_a42z)
      (@ b_a42A)
      (ds_d51q :: a_a42z -> b_a42A)
      (ds1_d51r :: [a_a42z]) ->
      case ds1_d51r of {
        [] -> GHC.Types.[] @ b_a42A;
        : x_a3eD xs_a3eE ->
          GHC.Types.:
            @ b_a42A (ds_d51q x_a3eD) (map @ a_a42z @ b_a42A ds_d51q xs_a3eE)
      }
end Rec }

-- RHS size: {terms: 19, types: 24, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroupNonEmpty_$c<>
  :: forall a. NonEmpty a -> NonEmpty a -> NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,1*U)><L,U(1*U,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Fm)
                 (ds_d59K [Occ=Once!] :: NonEmpty a_a4Fm)
                 (ds1_d59L :: NonEmpty a_a4Fm) ->
                 case ds_d59K of { :| a1_a3b1 [Occ=Once] as_a3b2 [Occ=Once] ->
                 GHC.Base.:|
                   @ a_a4Fm
                   a1_a3b1
                   (augment
                      @ a_a4Fm
                      (\ (@ b_a4Om)
                         (c_a3g3 [Occ=Once, OS=OneShot] :: a_a4Fm -> b_a4Om -> b_a4Om)
                         (n_a3g4 [Occ=Once, OS=OneShot] :: b_a4Om) ->
                         foldr @ a_a4Fm @ b_a4Om c_a3g3 n_a3g4 as_a3b2)
                      (GHC.Types.:
                         @ a_a4Fm
                         (case ds1_d59L of { :| b_a3b3 [Occ=Once] _ [Occ=Dead] -> b_a3b3 })
                         (case ds1_d59L of { :| _ [Occ=Dead] bs_a3b4 [Occ=Once] ->
                          bs_a3b4
                          })))
                 }}]
GHC.Base.$fSemigroupNonEmpty_$c<>
  = \ (@ a_a4Fm)
      (ds_d59K :: NonEmpty a_a4Fm)
      (ds1_d59L :: NonEmpty a_a4Fm) ->
      case ds_d59K of { :| a1_a3b1 as_a3b2 ->
      GHC.Base.:|
        @ a_a4Fm
        a1_a3b1
        (++
           @ a_a4Fm
           as_a3b2
           (GHC.Types.:
              @ a_a4Fm
              (case ds1_d59L of { :| b_a3b3 bs_a3b4 -> b_a3b3 })
              (case ds1_d59L of { :| b_a3b3 bs_a3b4 -> bs_a3b4 })))
      }

Rec {
-- RHS size: {terms: 37, types: 56, coercions: 0, joins: 0/1}
GHC.Base.$wpoly_go [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. a -> [a] -> [NonEmpty a] -> (# a, [a] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U><L,U><S,1*U>,
 Unf=OtherCon []]
GHC.Base.$wpoly_go
  = \ (@ a_s6GZ)
      (ww_s6H4 :: a_s6GZ)
      (ww1_s6H5 :: [a_s6GZ])
      (w_s6H1 :: [NonEmpty a_s6GZ]) ->
      case w_s6H1 of {
        [] -> (# ww_s6H4, ww1_s6H5 #);
        : c_a385 cs_a386 ->
          (# ww_s6H4,
             let {
               ds_d59L [Dmd=<L,U(1*U,1*U)>] :: NonEmpty a_s6GZ
               [LclId]
               ds_d59L
                 = case c_a385 of { :| ww3_X6R9 ww4_X6Rb ->
                   case GHC.Base.$wpoly_go @ a_s6GZ ww3_X6R9 ww4_X6Rb cs_a386 of
                   { (# ww6_s6RC, ww7_s6RD #) ->
                   GHC.Base.:| @ a_s6GZ ww6_s6RC ww7_s6RD
                   }
                   } } in
             ++
               @ a_s6GZ
               ww1_s6H5
               (GHC.Types.:
                  @ a_s6GZ
                  (case ds_d59L of { :| b_a3b3 bs_a3b4 -> b_a3b3 })
                  (case ds_d59L of { :| b_a3b3 bs_a3b4 -> bs_a3b4 })) #)
      }
end Rec }

-- RHS size: {terms: 15, types: 23, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroupNonEmpty1 [InlPrag=NOUSERINLINE[0]]
  :: forall a. NonEmpty a -> [NonEmpty a] -> NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U(U,U)><S,1*U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6GZ)
                 (w_s6H0 [Occ=Once!] :: NonEmpty a_s6GZ)
                 (w1_s6H1 [Occ=Once] :: [NonEmpty a_s6GZ]) ->
                 case w_s6H0 of { :| ww1_s6H4 [Occ=Once] ww2_s6H5 [Occ=Once] ->
                 case GHC.Base.$wpoly_go @ a_s6GZ ww1_s6H4 ww2_s6H5 w1_s6H1 of
                 { (# ww4_s6RC [Occ=Once], ww5_s6RD [Occ=Once] #) ->
                 GHC.Base.:| @ a_s6GZ ww4_s6RC ww5_s6RD
                 }
                 }}]
GHC.Base.$fSemigroupNonEmpty1
  = \ (@ a_s6GZ)
      (w_s6H0 :: NonEmpty a_s6GZ)
      (w1_s6H1 :: [NonEmpty a_s6GZ]) ->
      case w_s6H0 of { :| ww1_s6H4 ww2_s6H5 ->
      case GHC.Base.$wpoly_go @ a_s6GZ ww1_s6H4 ww2_s6H5 w1_s6H1 of
      { (# ww4_s6RC, ww5_s6RD #) ->
      GHC.Base.:| @ a_s6GZ ww4_s6RC ww5_s6RD
      }
      }

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroupNonEmpty_$csconcat
  :: forall a. NonEmpty (NonEmpty a) -> NonEmpty a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U(U,U),1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Fm)
                 (ds_X5ei [Occ=Once!] :: NonEmpty (NonEmpty a_a4Fm)) ->
                 case ds_X5ei of { :| a1_a381 [Occ=Once] as_a382 [Occ=Once] ->
                 GHC.Base.$fSemigroupNonEmpty1 @ a_a4Fm a1_a381 as_a382
                 }}]
GHC.Base.$fSemigroupNonEmpty_$csconcat
  = \ (@ a_a4Fm) (ds_X5ei :: NonEmpty (NonEmpty a_a4Fm)) ->
      case ds_X5ei of { :| a1_a381 as_a382 ->
      GHC.Base.$fSemigroupNonEmpty1 @ a_a4Fm a1_a381 as_a382
      }

Rec {
-- RHS size: {terms: 5, types: 7, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroupNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup (NonEmpty a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_a3b0) ->
       GHC.Base.C:Semigroup TYPE: NonEmpty a_a3b0
                            GHC.Base.$fSemigroupNonEmpty_$c<> @ a_a3b0
                            GHC.Base.$fSemigroupNonEmpty_$csconcat @ a_a3b0
                            GHC.Base.$fSemigroupNonEmpty_$cstimes @ a_a3b0]
GHC.Base.$fSemigroupNonEmpty
  = \ (@ a_a4Fm) ->
      GHC.Base.C:Semigroup
        @ (NonEmpty a_a4Fm)
        (GHC.Base.$fSemigroupNonEmpty_$c<> @ a_a4Fm)
        (GHC.Base.$fSemigroupNonEmpty_$csconcat @ a_a4Fm)
        (GHC.Base.$fSemigroupNonEmpty_$cstimes @ a_a4Fm)

-- RHS size: {terms: 6, types: 10, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroupNonEmpty_$cstimes [Occ=LoopBreaker]
  :: forall a b. Integral b => b -> NonEmpty a -> NonEmpty a
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []]
GHC.Base.$fSemigroupNonEmpty_$cstimes
  = \ (@ a_a4Fm) (@ b_a4FC) ($dIntegral_a4FE :: Integral b_a4FC) ->
      stimesDefault
        @ b_a4FC
        @ (NonEmpty a_a4Fm)
        $dIntegral_a4FE
        (GHC.Base.$fSemigroupNonEmpty @ a_a4Fm)
end Rec }

Rec {
-- RHS size: {terms: 13, types: 17, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup[]1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []]
GHC.Base.$fSemigroup[]1
  = \ (@ a_a4FL) (b_a384 :: [a_a4FL]) (ds_d548 :: [[a_a4FL]]) ->
      case ds_d548 of {
        [] -> b_a384;
        : c_a385 cs_a386 ->
          ++
            @ a_a4FL b_a384 (GHC.Base.$fSemigroup[]1 @ a_a4FL c_a385 cs_a386)
      }
end Rec }

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup[]_$csconcat :: forall a. NonEmpty [a] -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4FL) (ds_X5el [Occ=Once!] :: NonEmpty [a_a4FL]) ->
                 case ds_X5el of { :| a1_a381 [Occ=Once] as_a382 [Occ=Once] ->
                 GHC.Base.$fSemigroup[]1 @ a_a4FL a1_a381 as_a382
                 }}]
GHC.Base.$fSemigroup[]_$csconcat
  = \ (@ a_a4FL) (ds_X5el :: NonEmpty [a_a4FL]) ->
      case ds_X5el of { :| a1_a381 as_a382 ->
      GHC.Base.$fSemigroup[]1 @ a_a4FL a1_a381 as_a382
      }

-- RHS size: {terms: 36, types: 53, coercions: 0, joins: 0/3}
mapM [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *) a b. Monad m => (a -> m b) -> [a] -> m [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)><L,C(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_a4da :: * -> *))
                 (@ a_a4db)
                 (@ b_a4dc)
                 ($dMonad_a4de :: Monad m_a4da)
                 (f_a3dK [Occ=OnceL!] :: a_a4db -> m_a4da b_a4dc)
                 (as_a3dL [Occ=Once] :: [a_a4db]) ->
                 foldr
                   @ a_a4db
                   @ (m_a4da [b_a4dc])
                   (\ (a1_a3dN [Occ=Once] :: a_a4db)
                      (r_a3dO [Occ=OnceL, OS=OneShot] :: m_a4da [b_a4dc]) ->
                      >>=
                        @ m_a4da
                        $dMonad_a4de
                        @ b_a4dc
                        @ [b_a4dc]
                        (f_a3dK a1_a3dN)
                        (\ (x_a3dP [Occ=OnceL] :: b_a4dc) ->
                           >>=
                             @ m_a4da
                             $dMonad_a4de
                             @ [b_a4dc]
                             @ [b_a4dc]
                             r_a3dO
                             (\ (xs_a3dQ [Occ=Once] :: [b_a4dc]) ->
                                return
                                  @ m_a4da
                                  $dMonad_a4de
                                  @ [b_a4dc]
                                  (GHC.Types.: @ b_a4dc x_a3dP xs_a3dQ))))
                   (return @ m_a4da $dMonad_a4de @ [b_a4dc] (GHC.Types.[] @ b_a4dc))
                   as_a3dL}]
mapM
  = \ (@ (m_a4da :: * -> *))
      (@ a_a4db)
      (@ b_a4dc)
      ($dMonad_a4de :: Monad m_a4da)
      (eta_Xao :: a_a4db -> m_a4da b_a4dc)
      (eta1_B1 :: [a_a4db]) ->
      let {
        z_a3ev :: m_a4da [b_a4dc]
        [LclId]
        z_a3ev
          = return
              @ m_a4da $dMonad_a4de @ [b_a4dc] (GHC.Types.[] @ b_a4dc) } in
      letrec {
        go_X4cq [Occ=LoopBreaker] :: [a_a4db] -> m_a4da [b_a4dc]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_X4cq
          = \ (ds_d51B :: [a_a4db]) ->
              case ds_d51B of {
                [] -> z_a3ev;
                : y_a3ex ys_a3ey ->
                  let {
                    r_a3dO :: m_a4da [b_a4dc]
                    [LclId]
                    r_a3dO = go_X4cq ys_a3ey } in
                  >>=
                    @ m_a4da
                    $dMonad_a4de
                    @ b_a4dc
                    @ [b_a4dc]
                    (eta_Xao y_a3ex)
                    (\ (x_a3dP :: b_a4dc) ->
                       >>=
                         @ m_a4da
                         $dMonad_a4de
                         @ [b_a4dc]
                         @ [b_a4dc]
                         r_a3dO
                         (\ (xs_a3dQ :: [b_a4dc]) ->
                            return
                              @ m_a4da
                              $dMonad_a4de
                              @ [b_a4dc]
                              (GHC.Types.: @ b_a4dc x_a3dP xs_a3dQ)))
              }; } in
      go_X4cq eta1_B1

-- RHS size: {terms: 6, types: 14, coercions: 0, joins: 0/0}
sequence [InlPrag=INLINE (sat-args=0)]
  :: forall (m :: * -> *) a. Monad m => [m a] -> m [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)),A,C(U),A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (m_a4dM :: * -> *))
                 (@ a_a4dN)
                 ($dMonad_a4dP [Occ=Once] :: Monad m_a4dM) ->
                 mapM
                   @ m_a4dM
                   @ (m_a4dM a_a4dN)
                   @ a_a4dN
                   $dMonad_a4dP
                   (breakpoint @ (m_a4dM a_a4dN))}]
sequence
  = \ (@ (m_a4dM :: * -> *))
      (@ a_a4dN)
      ($dMonad_a4dP :: Monad m_a4dM) ->
      mapM
        @ m_a4dM
        @ (m_a4dM a_a4dN)
        @ a_a4dN
        $dMonad_a4dP
        (breakpoint @ (m_a4dM a_a4dN))

-- RHS size: {terms: 20, types: 19, coercions: 0, joins: 0/2}
GHC.Base.$dmmconcat :: forall a. Monoid a => [a] -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a37Y) ($dMonoid_a4le :: Monoid a_a37Y) ->
                 foldr
                   @ a_a37Y
                   @ a_a37Y
                   (mappend @ a_a37Y $dMonoid_a4le)
                   (mempty @ a_a37Y $dMonoid_a4le)}]
GHC.Base.$dmmconcat
  = \ (@ a_a37Y)
      ($dMonoid_a4le :: Monoid a_a37Y)
      (eta_B1 :: [a_a37Y]) ->
      let {
        z_a3ev :: a_a37Y
        [LclId]
        z_a3ev = mempty @ a_a37Y $dMonoid_a4le } in
      letrec {
        go_X4cr [Occ=LoopBreaker] :: [a_a37Y] -> a_a37Y
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_X4cr
          = \ (ds_d51B :: [a_a37Y]) ->
              case ds_d51B of {
                [] -> z_a3ev;
                : y_a3ex ys_a3ey ->
                  mappend @ a_a37Y $dMonoid_a4le y_a3ex (go_X4cr ys_a3ey)
              }; } in
      go_X4cr eta_B1

-- RHS size: {terms: 29, types: 33, coercions: 0, joins: 0/3}
GHC.Base.$fMonoid(->)_$cmconcat
  :: forall b a. Monoid b => [a -> b] -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 230 0}]
GHC.Base.$fMonoid(->)_$cmconcat
  = \ (@ b_a4zA)
      (@ a_a4zB)
      ($dMonoid_a4zC :: Monoid b_a4zA)
      (eta_B1 :: [a_a4zB -> b_a4zA])
      (eta1_X2 :: a_a4zB) ->
      let {
        lvl3_s5w0 :: b_a4zA
        [LclId]
        lvl3_s5w0 = mempty @ b_a4zA $dMonoid_a4zC } in
      let {
        $dSemigroup_s5vq [Dmd=<L,U(C(C1(U)),A,A)>] :: Semigroup b_a4zA
        [LclId]
        $dSemigroup_s5vq = GHC.Base.$p1Monoid @ b_a4zA $dMonoid_a4zC } in
      letrec {
        go_X4cu [Occ=LoopBreaker] :: [a_a4zB -> b_a4zA] -> a_a4zB -> b_a4zA
        [LclId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []]
        go_X4cu
          = \ (ds_d51B :: [a_a4zB -> b_a4zA]) (eta2_X9F :: a_a4zB) ->
              case ds_d51B of {
                [] -> lvl3_s5w0;
                : y_a3ex ys_a3ey ->
                  <>
                    @ b_a4zA
                    $dSemigroup_s5vq
                    (y_a3ex eta2_X9F)
                    (go_X4cu ys_a3ey eta2_X9F)
              }; } in
      go_X4cu eta_B1 eta1_X2

-- RHS size: {terms: 38, types: 77, coercions: 2, joins: 0/3}
GHC.Base.$fMonoidIO1
  :: forall a.
     Monoid a =>
     [IO a] -> State# RealWorld -> (# State# RealWorld, a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 210 0}]
GHC.Base.$fMonoidIO1
  = \ (@ a_X4I9)
      ($dMonoid_X4Ib :: Monoid a_X4I9)
      (eta_B1 :: [IO a_X4I9])
      (eta1_X2 :: State# RealWorld) ->
      let {
        $dSemigroup_s5vo [Dmd=<L,U(C(C1(U)),A,A)>] :: Semigroup a_X4I9
        [LclId]
        $dSemigroup_s5vo = GHC.Base.$p1Monoid @ a_X4I9 $dMonoid_X4Ib } in
      let {
        lvl3_s7sG :: a_X4I9
        [LclId]
        lvl3_s7sG = mempty @ a_X4I9 $dMonoid_X4Ib } in
      letrec {
        go_s6bU [Occ=LoopBreaker]
          :: [IO a_X4I9]
             -> State# RealWorld -> (# State# RealWorld, a_X4I9 #)
        [LclId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []]
        go_s6bU
          = \ (ds_d51B :: [IO a_X4I9]) (eta2_X9F :: State# RealWorld) ->
              case ds_d51B of {
                [] -> (# eta2_X9F, lvl3_s7sG #);
                : y_a3ex ys_a3ey ->
                  case (y_a3ex
                        `cast` (GHC.Types.N:IO[0] <a_X4I9>_R
                                :: (IO a_X4I9 :: *)
                                   ~R# (State# RealWorld -> (# State# RealWorld, a_X4I9 #) :: *)))
                         eta2_X9F
                  of
                  { (# ipv_s5fT, ipv1_s5fU #) ->
                  case go_s6bU ys_a3ey ipv_s5fT of { (# ipv2_X5rv, ipv3_X5rx #) ->
                  (# ipv2_X5rv, <> @ a_X4I9 $dSemigroup_s5vo ipv1_s5fU ipv3_X5rx #)
                  }
                  }
              }; } in
      go_s6bU eta_B1 eta1_X2

-- RHS size: {terms: 14, types: 19, coercions: 10, joins: 0/0}
GHC.Base.$fMonoidIO [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Monoid a => Monoid (IO a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(C(C1(U)),A,A),U,A,A)>m,
 Unf=DFun: \ (@ a_a39e) (v_X9B :: Monoid a_a39e) ->
       GHC.Base.C:Monoid TYPE: IO a_a39e
                         GHC.Base.$fMonoidIO_$cp1Monoid @ a_a39e v_X9B
                         (\ (s_a3ff [Occ=Once] :: State# RealWorld) ->
                            (# s_a3ff, mempty @ a_a39e v_X9B #))
                         `cast` (Sym (GHC.Types.N:IO[0] <a_a39e>_R)
                                 :: (State# RealWorld -> (# State# RealWorld, a_a39e #) :: *)
                                    ~R# (IO a_a39e :: *))
                         GHC.Base.$fMonoidIO_$cmappend @ a_a39e v_X9B
                         (GHC.Base.$fMonoidIO1 @ a_a39e v_X9B)
                         `cast` (<[IO a_a39e]>_R ->_R Sym (GHC.Types.N:IO[0] <a_a39e>_R)
                                 :: ([IO a_a39e]
                                     -> State# RealWorld -> (# State# RealWorld, a_a39e #) :: *)
                                    ~R# ([IO a_a39e] -> IO a_a39e :: *))]
GHC.Base.$fMonoidIO
  = \ (@ a_X4I7) ($dMonoid_X4RJ :: Monoid a_X4I7) ->
      GHC.Base.C:Monoid
        @ (IO a_X4I7)
        (GHC.Base.$fMonoidIO_$cp1Monoid @ a_X4I7 $dMonoid_X4RJ)
        ((\ (s_a3ff :: State# RealWorld) ->
            (# s_a3ff, mempty @ a_X4I7 $dMonoid_X4RJ #))
         `cast` (Sym (GHC.Types.N:IO[0] <a_X4I7>_R)
                 :: (State# RealWorld -> (# State# RealWorld, a_X4I7 #) :: *)
                    ~R# (IO a_X4I7 :: *)))
        (GHC.Base.$fMonoidIO_$cmappend @ a_X4I7 $dMonoid_X4RJ)
        ((GHC.Base.$fMonoidIO1 @ a_X4I7 $dMonoid_X4RJ)
         `cast` (<[IO a_X4I7]>_R ->_R Sym (GHC.Types.N:IO[0] <a_X4I7>_R)
                 :: ([IO a_X4I7]
                     -> State# RealWorld -> (# State# RealWorld, a_X4I7 #) :: *)
                    ~R# ([IO a_X4I7] -> IO a_X4I7 :: *)))

-- RHS size: {terms: 8, types: 10, coercions: 0, joins: 0/0}
GHC.Base.$fFunctor[]_$c<$ :: forall a b. a -> [b] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Ms)
                 (@ b_a4Mt)
                 (x_X3pr [Occ=OnceL] :: a_a4Ms)
                 (eta_X9E [Occ=Once] :: [b_a4Mt]) ->
                 build
                   @ a_a4Ms
                   (\ (@ b1_a4OW)
                      (c_a3g7 [Occ=Once, OS=OneShot] :: a_a4Ms -> b1_a4OW -> b1_a4OW)
                      (n_a3g8 [Occ=Once, OS=OneShot] :: b1_a4OW) ->
                      foldr
                        @ b_a4Mt
                        @ b1_a4OW
                        (mapFB
                           @ a_a4Ms @ b1_a4OW @ b_a4Mt c_a3g7 (\ _ [Occ=Dead] -> x_X3pr))
                        n_a3g8
                        eta_X9E)}]
GHC.Base.$fFunctor[]_$c<$
  = \ (@ a_a4Ms)
      (@ b_a4Mt)
      (x_X3pr :: a_a4Ms)
      (eta_X9E :: [b_a4Mt]) ->
      map @ b_a4Mt @ a_a4Ms (\ _ [Occ=Dead] -> x_X3pr) eta_X9E

-- RHS size: {terms: 13, types: 16, coercions: 0, joins: 0/0}
GHC.Base.$fFunctorNonEmpty_$c<$
  :: forall a b. a -> NonEmpty b -> NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,1*U(A,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Hj)
                 (@ b_a4Hk)
                 (b1_a38G :: a_a4Hj)
                 (ds_d5ah [Occ=Once!] :: NonEmpty b_a4Hk) ->
                 GHC.Base.:|
                   @ a_a4Hj
                   b1_a38G
                   (case ds_d5ah of { :| _ [Occ=Dead] as_a38H [Occ=Once] ->
                    build
                      @ a_a4Hj
                      (\ (@ b2_a4OW)
                         (c_a3g7 [Occ=Once, OS=OneShot] :: a_a4Hj -> b2_a4OW -> b2_a4OW)
                         (n_a3g8 [Occ=Once, OS=OneShot] :: b2_a4OW) ->
                         foldr
                           @ b_a4Hk
                           @ b2_a4OW
                           (mapFB
                              @ a_a4Hj @ b2_a4OW @ b_a4Hk c_a3g7 (\ _ [Occ=Dead] -> b1_a38G))
                           n_a3g8
                           as_a38H)
                    })}]
GHC.Base.$fFunctorNonEmpty_$c<$
  = \ (@ a_a4Hj)
      (@ b_a4Hk)
      (b1_a38G :: a_a4Hj)
      (ds_d5ah :: NonEmpty b_a4Hk) ->
      GHC.Base.:|
        @ a_a4Hj
        b1_a38G
        (case ds_d5ah of { :| ds1_d5aq as_a38H ->
         map @ b_a4Hk @ a_a4Hj (\ _ [Occ=Dead] -> b1_a38G) as_a38H
         })

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fFunctor[] [InlPrag=NOUSERINLINE CONLIKE] :: Functor []
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: [] map GHC.Base.$fFunctor[]_$c<$]
GHC.Base.$fFunctor[]
  = GHC.Base.C:Functor @ [] map GHC.Base.$fFunctor[]_$c<$

-- RHS size: {terms: 18, types: 22, coercions: 0, joins: 0/1}
GHC.Base.$fMonad[]_$c>>= [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a] -> (a -> [b]) -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,C(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4rg)
                 (@ b_a4rh)
                 (xs_a38c [Occ=Once] :: [a_a4rg])
                 (f_a38d [Occ=OnceL!] :: a_a4rg -> [b_a4rh]) ->
                 build
                   @ b_a4rh
                   (\ (@ a1_d55G)
                      (c_d55H [Occ=OnceL!, OS=OneShot] :: b_a4rh -> a1_d55G -> a1_d55G)
                      (n_d55I [Occ=Once, OS=OneShot] :: a1_d55G) ->
                      foldr
                        @ a_a4rg
                        @ a1_d55G
                        (\ (ds_d55K [Occ=Once] :: a_a4rg)
                           (ds1_d55J [Occ=Once, OS=OneShot] :: a1_d55G) ->
                           foldr
                             @ b_a4rh
                             @ a1_d55G
                             (\ (ds2_d55M [Occ=Once] :: b_a4rh)
                                (ds3_d55L [Occ=Once, OS=OneShot] :: a1_d55G) ->
                                c_d55H ds2_d55M ds3_d55L)
                             ds1_d55J
                             (f_a38d ds_d55K))
                        n_d55I
                        xs_a38c)}]
GHC.Base.$fMonad[]_$c>>=
  = \ (@ a_a4rg)
      (@ b_a4rh)
      (xs_a38c :: [a_a4rg])
      (f_a38d :: a_a4rg -> [b_a4rh]) ->
      letrec {
        go_X4cz [Occ=LoopBreaker] :: [a_a4rg] -> [b_a4rh]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_X4cz
          = \ (ds_d51B :: [a_a4rg]) ->
              case ds_d51B of {
                [] -> GHC.Types.[] @ b_a4rh;
                : y_a3ex ys_a3ey -> ++ @ b_a4rh (f_a38d y_a3ex) (go_X4cz ys_a3ey)
              }; } in
      go_X4cz xs_a38c

-- RHS size: {terms: 7, types: 11, coercions: 0, joins: 0/0}
GHC.Base.=<<_$s=<< :: forall a b. (a -> [b]) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a4eS)
                 (@ b_a4eT)
                 (f_a3dG [Occ=Once] :: a_a4eS -> [b_a4eT])
                 (x_a3dH [Occ=Once] :: [a_a4eS]) ->
                 GHC.Base.$fMonad[]_$c>>= @ a_a4eS @ b_a4eT x_a3dH f_a3dG}]
GHC.Base.=<<_$s=<<
  = \ (@ a_a4eS)
      (@ b_a4eT)
      (f_a3dG :: a_a4eS -> [b_a4eT])
      (x_a3dH :: [a_a4eS]) ->
      GHC.Base.$fMonad[]_$c>>= @ a_a4eS @ b_a4eT x_a3dH f_a3dG

-- RHS size: {terms: 10, types: 18, coercions: 0, joins: 0/0}
=<<
  :: forall (m :: * -> *) a b. Monad m => (a -> m b) -> m a -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_a4ep :: * -> *))
                 (@ a_a4eq)
                 (@ b_a4er)
                 ($dMonad_a4et [Occ=Once] :: Monad m_a4ep)
                 (f_a3dG [Occ=Once] :: a_a4eq -> m_a4ep b_a4er)
                 (x_a3dH [Occ=Once] :: m_a4ep a_a4eq) ->
                 >>= @ m_a4ep $dMonad_a4et @ a_a4eq @ b_a4er x_a3dH f_a3dG}]
=<<
  = \ (@ (m_a4ep :: * -> *))
      (@ a_a4eq)
      (@ b_a4er)
      ($dMonad_a4et :: Monad m_a4ep)
      (f_a3dG :: a_a4eq -> m_a4ep b_a4er)
      (x_a3dH :: m_a4ep a_a4eq) ->
      >>= @ m_a4ep $dMonad_a4et @ a_a4eq @ b_a4er x_a3dH f_a3dG

Rec {
-- RHS size: {terms: 11, types: 16, coercions: 0, joins: 0/0}
poly_go_r7PI :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
poly_go_r7PI
  = \ (@ a_a4zZ) (ds_d51B :: [[a_a4zZ]]) ->
      case ds_d51B of {
        [] -> GHC.Types.[] @ a_a4zZ;
        : y_a3ex ys_a3ey ->
          ++ @ a_a4zZ y_a3ex (poly_go_r7PI @ a_a4zZ ys_a3ey)
      }
end Rec }

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid[]_$cmconcat [InlPrag=INLINE (sat-args=1)]
  :: forall a. [[a]] -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4zZ) (xss_a3b6 [Occ=Once] :: [[a_a4zZ]]) ->
                 build
                   @ a_a4zZ
                   (\ (@ a1_d57J)
                      (c_d57K [Occ=OnceL!, OS=OneShot] :: a_a4zZ -> a1_d57J -> a1_d57J)
                      (n_d57L [Occ=Once, OS=OneShot] :: a1_d57J) ->
                      foldr
                        @ [a_a4zZ]
                        @ a1_d57J
                        (\ (ds_d57N [Occ=Once] :: [a_a4zZ])
                           (ds1_d57M [Occ=Once, OS=OneShot] :: a1_d57J) ->
                           foldr
                             @ a_a4zZ
                             @ a1_d57J
                             (\ (ds2_d57P [Occ=Once] :: a_a4zZ)
                                (ds3_d57O [Occ=Once, OS=OneShot] :: a1_d57J) ->
                                c_d57K ds2_d57P ds3_d57O)
                             ds1_d57M
                             ds_d57N)
                        n_d57L
                        xss_a3b6)}]
GHC.Base.$fMonoid[]_$cmconcat
  = \ (@ a_a4zZ) (xss_a3b6 :: [[a_a4zZ]]) ->
      poly_go_r7PI @ a_a4zZ xss_a3b6

-- RHS size: {terms: 30, types: 40, coercions: 0, joins: 0/3}
GHC.Base.$fApplicative[]_$c<*> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a -> b] -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4Ka)
                 (@ b_a4Kb)
                 (fs_a38h [Occ=Once] :: [a_a4Ka -> b_a4Kb])
                 (xs_a38i [Occ=OnceL] :: [a_a4Ka]) ->
                 build
                   @ b_a4Kb
                   (\ (@ a1_d5aO)
                      (c_d5aP [Occ=OnceL!, OS=OneShot] :: b_a4Kb -> a1_d5aO -> a1_d5aO)
                      (n_d5aQ [Occ=Once, OS=OneShot] :: a1_d5aO) ->
                      foldr
                        @ (a_a4Ka -> b_a4Kb)
                        @ a1_d5aO
                        (\ (ds_d5aS [Occ=OnceL!] :: a_a4Ka -> b_a4Kb)
                           (ds1_d5aR [Occ=Once, OS=OneShot] :: a1_d5aO) ->
                           foldr
                             @ a_a4Ka
                             @ a1_d5aO
                             (\ (ds2_d5aU [Occ=Once] :: a_a4Ka)
                                (ds3_d5aT [Occ=Once, OS=OneShot] :: a1_d5aO) ->
                                c_d5aP (ds_d5aS ds2_d5aU) ds3_d5aT)
                             ds1_d5aR
                             xs_a38i)
                        n_d5aQ
                        fs_a38h)}]
GHC.Base.$fApplicative[]_$c<*>
  = \ (@ a_a4Ka)
      (@ b_a4Kb)
      (fs_a38h :: [a_a4Ka -> b_a4Kb])
      (xs_a38i :: [a_a4Ka]) ->
      letrec {
        go_X4cE [Occ=LoopBreaker] :: [a_a4Ka -> b_a4Kb] -> [b_a4Kb]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_X4cE
          = \ (ds_d51B :: [a_a4Ka -> b_a4Kb]) ->
              case ds_d51B of {
                [] -> GHC.Types.[] @ b_a4Kb;
                : y_a3ex ys_a3ey ->
                  let {
                    z_X3on :: [b_a4Kb]
                    [LclId]
                    z_X3on = go_X4cE ys_a3ey } in
                  letrec {
                    go1_X4cM [Occ=LoopBreaker] :: [a_a4Ka] -> [b_a4Kb]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                    go1_X4cM
                      = \ (ds1_X5bw :: [a_a4Ka]) ->
                          case ds1_X5bw of {
                            [] -> z_X3on;
                            : y1_X3ov ys1_X3ox ->
                              GHC.Types.: @ b_a4Kb (y_a3ex y1_X3ov) (go1_X4cM ys1_X3ox)
                          }; } in
                  go1_X4cM xs_a38i
              }; } in
      go_X4cE fs_a38h

-- RHS size: {terms: 33, types: 39, coercions: 0, joins: 0/3}
GHC.Base.$fApplicative[]_$cliftA2 [InlPrag=INLINE (sat-args=3)]
  :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4Ki)
                 (@ b_a4Kj)
                 (@ c_a4Kk)
                 (f_a38l [Occ=OnceL!] :: a_a4Ki -> b_a4Kj -> c_a4Kk)
                 (xs_a38m [Occ=Once] :: [a_a4Ki])
                 (ys_a38n [Occ=OnceL] :: [b_a4Kj]) ->
                 build
                   @ c_a4Kk
                   (\ (@ a1_d5aZ)
                      (c1_d5b0 [Occ=OnceL!, OS=OneShot] :: c_a4Kk -> a1_d5aZ -> a1_d5aZ)
                      (n_d5b1 [Occ=Once, OS=OneShot] :: a1_d5aZ) ->
                      foldr
                        @ a_a4Ki
                        @ a1_d5aZ
                        (\ (ds_d5b3 [Occ=OnceL] :: a_a4Ki)
                           (ds1_d5b2 [Occ=Once, OS=OneShot] :: a1_d5aZ) ->
                           foldr
                             @ b_a4Kj
                             @ a1_d5aZ
                             (\ (ds2_d5b5 [Occ=Once] :: b_a4Kj)
                                (ds3_d5b4 [Occ=Once, OS=OneShot] :: a1_d5aZ) ->
                                c1_d5b0 (f_a38l ds_d5b3 ds2_d5b5) ds3_d5b4)
                             ds1_d5b2
                             ys_a38n)
                        n_d5b1
                        xs_a38m)}]
GHC.Base.$fApplicative[]_$cliftA2
  = \ (@ a_a4Ki)
      (@ b_a4Kj)
      (@ c_a4Kk)
      (f_a38l :: a_a4Ki -> b_a4Kj -> c_a4Kk)
      (xs_a38m :: [a_a4Ki])
      (ys_a38n :: [b_a4Kj]) ->
      letrec {
        go_X4cH [Occ=LoopBreaker] :: [a_a4Ki] -> [c_a4Kk]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_X4cH
          = \ (ds_d51B :: [a_a4Ki]) ->
              case ds_d51B of {
                [] -> GHC.Types.[] @ c_a4Kk;
                : y_a3ex ys1_a3ey ->
                  let {
                    z_X3oq :: [c_a4Kk]
                    [LclId]
                    z_X3oq = go_X4cH ys1_a3ey } in
                  letrec {
                    go1_X4cP [Occ=LoopBreaker] :: [b_a4Kj] -> [c_a4Kk]
                    [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                    go1_X4cP
                      = \ (ds1_X5bz :: [b_a4Kj]) ->
                          case ds1_X5bz of {
                            [] -> z_X3oq;
                            : y1_X3oy ys2_X3oA ->
                              GHC.Types.: @ c_a4Kk (f_a38l y_a3ex y1_X3oy) (go1_X4cP ys2_X3oA)
                          }; } in
                  go1_X4cP ys_a38n
              }; } in
      go_X4cH xs_a38m

-- RHS size: {terms: 4, types: 9, coercions: 0, joins: 0/0}
GHC.Base.$fApplicative[]_$c<* :: forall a b. [a] -> [b] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 60}]
GHC.Base.$fApplicative[]_$c<*
  = \ (@ a_a4Kz) (@ b_a4KA) ->
      GHC.Base.$fApplicative[]_$cliftA2
        @ a_a4Kz @ b_a4KA @ a_a4Kz (const @ a_a4Kz @ b_a4KA)

-- RHS size: {terms: 17, types: 21, coercions: 0, joins: 0/1}
GHC.Base.$fApplicative[]_$c*> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. [a] -> [b] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4Kr)
                 (@ b_a4Ks)
                 (xs_a38q [Occ=Once] :: [a_a4Kr])
                 (ys_a38r [Occ=OnceL] :: [b_a4Ks]) ->
                 build
                   @ b_a4Ks
                   (\ (@ a1_d5ba)
                      (c_d5bb [Occ=OnceL!, OS=OneShot] :: b_a4Ks -> a1_d5ba -> a1_d5ba)
                      (n_d5bc [Occ=Once, OS=OneShot] :: a1_d5ba) ->
                      foldr
                        @ a_a4Kr
                        @ a1_d5ba
                        (\ _ [Occ=Dead] (ds1_d5bd [Occ=Once, OS=OneShot] :: a1_d5ba) ->
                           foldr
                             @ b_a4Ks
                             @ a1_d5ba
                             (\ (ds2_d5bg [Occ=Once] :: b_a4Ks)
                                (ds3_d5bf [Occ=Once, OS=OneShot] :: a1_d5ba) ->
                                c_d5bb ds2_d5bg ds3_d5bf)
                             ds1_d5bd
                             ys_a38r)
                        n_d5bc
                        xs_a38q)}]
GHC.Base.$fApplicative[]_$c*>
  = \ (@ a_a4Kr)
      (@ b_a4Ks)
      (xs_a38q :: [a_a4Kr])
      (ys_a38r :: [b_a4Ks]) ->
      letrec {
        go_X4cH [Occ=LoopBreaker] :: [a_a4Kr] -> [b_a4Ks]
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_X4cH
          = \ (ds_d51B :: [a_a4Kr]) ->
              case ds_d51B of {
                [] -> GHC.Types.[] @ b_a4Ks;
                : y_a3ex ys1_a3ey -> ++ @ b_a4Ks ys_a38r (go_X4cH ys1_a3ey)
              }; } in
      go_X4cH xs_a38q

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fApplicative[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative []
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: []
                              GHC.Base.$fFunctor[]
                              GHC.Base.$fApplicative[]_$cpure
                              GHC.Base.$fApplicative[]_$c<*>
                              GHC.Base.$fApplicative[]_$cliftA2
                              GHC.Base.$fApplicative[]_$c*>
                              GHC.Base.$fApplicative[]_$c<*]
GHC.Base.$fApplicative[]
  = GHC.Base.C:Applicative
      @ []
      GHC.Base.$fFunctor[]
      GHC.Base.$fApplicative[]_$cpure
      GHC.Base.$fApplicative[]_$c<*>
      GHC.Base.$fApplicative[]_$cliftA2
      GHC.Base.$fApplicative[]_$c*>
      GHC.Base.$fApplicative[]_$c<*

-- RHS size: {terms: 16, types: 21, coercions: 0, joins: 0/0}
GHC.Base.$fFunctorNonEmpty_$cfmap
  :: forall a b. (a -> b) -> NonEmpty a -> NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4H7)
                 (@ b_a4H8)
                 (f_a38D :: a_a4H7 -> b_a4H8)
                 (ds_d5a5 :: NonEmpty a_a4H7) ->
                 GHC.Base.:|
                   @ b_a4H8
                   (f_a38D
                      (case ds_d5a5 of { :| a1_a38E [Occ=Once] _ [Occ=Dead] ->
                       a1_a38E
                       }))
                   (case ds_d5a5 of { :| _ [Occ=Dead] as_a38F [Occ=Once] ->
                    build
                      @ b_a4H8
                      (\ (@ b1_a4OW)
                         (c_a3g7 [Occ=Once, OS=OneShot] :: b_a4H8 -> b1_a4OW -> b1_a4OW)
                         (n_a3g8 [Occ=Once, OS=OneShot] :: b1_a4OW) ->
                         foldr
                           @ a_a4H7
                           @ b1_a4OW
                           (mapFB @ b_a4H8 @ b1_a4OW @ a_a4H7 c_a3g7 f_a38D)
                           n_a3g8
                           as_a38F)
                    })}]
GHC.Base.$fFunctorNonEmpty_$cfmap
  = \ (@ a_a4H7)
      (@ b_a4H8)
      (f_a38D :: a_a4H7 -> b_a4H8)
      (ds_d5a5 :: NonEmpty a_a4H7) ->
      GHC.Base.:|
        @ b_a4H8
        (f_a38D (case ds_d5a5 of { :| a1_a38E as_a38F -> a1_a38E }))
        (case ds_d5a5 of { :| a1_a38E as_a38F ->
         map @ a_a4H7 @ b_a4H8 f_a38D as_a38F
         })

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fFunctorNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor NonEmpty
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: NonEmpty
                          GHC.Base.$fFunctorNonEmpty_$cfmap
                          GHC.Base.$fFunctorNonEmpty_$c<$]
GHC.Base.$fFunctorNonEmpty
  = GHC.Base.C:Functor
      @ NonEmpty
      GHC.Base.$fFunctorNonEmpty_$cfmap
      GHC.Base.$fFunctorNonEmpty_$c<$

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
GHC.Base.$fAlternative[]1 :: forall a. [[a]]
[GblId,
 Caf=NoCafRefs,
 Str=m2,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Base.$fAlternative[]1
  = \ (@ a_a4Ik) ->
      GHC.Types.:
        @ [a_a4Ik] (GHC.Types.[] @ a_a4Ik) (GHC.Types.[] @ [a_a4Ik])

-- RHS size: {terms: 35, types: 50, coercions: 0, joins: 0/5}
GHC.Base.$fAlternative[]_$csome :: forall a. [a] -> [[a]]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 240 0}]
GHC.Base.$fAlternative[]_$csome
  = \ (@ a_a4Ik) (v_X3i2 :: [a_a4Ik]) ->
      letrec {
        some_v_s5vg [Occ=LoopBreaker] :: [[a_a4Ik]]
        [LclId]
        some_v_s5vg
          = let {
              ys_s5vi :: [[a_a4Ik]]
              [LclId]
              ys_s5vi
                = ++
                    @ [a_a4Ik] some_v_s5vg (GHC.Base.$fAlternative[]1 @ a_a4Ik) } in
            letrec {
              go_X4cM [Occ=LoopBreaker] :: [a_a4Ik] -> [[a_a4Ik]]
              [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
              go_X4cM
                = \ (ds_d51B :: [a_a4Ik]) ->
                    case ds_d51B of {
                      [] -> GHC.Types.[] @ [a_a4Ik];
                      : y_a3ex ys1_a3ey ->
                        let {
                          z_X3ov :: [[a_a4Ik]]
                          [LclId]
                          z_X3ov = go_X4cM ys1_a3ey } in
                        letrec {
                          go1_X4cU [Occ=LoopBreaker] :: [[a_a4Ik]] -> [[a_a4Ik]]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                          go1_X4cU
                            = \ (ds1_X5bE :: [[a_a4Ik]]) ->
                                case ds1_X5bE of {
                                  [] -> z_X3ov;
                                  : y1_X3oD ys2_X3oF ->
                                    GHC.Types.:
                                      @ [a_a4Ik]
                                      (GHC.Types.: @ a_a4Ik y_a3ex y1_X3oD)
                                      (go1_X4cU ys2_X3oF)
                                }; } in
                        go1_X4cU ys_s5vi
                    }; } in
            go_X4cM v_X3i2; } in
      some_v_s5vg

-- RHS size: {terms: 33, types: 47, coercions: 0, joins: 0/4}
GHC.Base.$fAlternative[]_$cmany :: forall a. [a] -> [[a]]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 230 0}]
GHC.Base.$fAlternative[]_$cmany
  = \ (@ a_a4Is) (v_a37r :: [a_a4Is]) ->
      letrec {
        many_v_s5vc [Occ=LoopBreaker] :: [[a_a4Is]]
        [LclId]
        many_v_s5vc
          = letrec {
              go_X4cL [Occ=LoopBreaker] :: [a_a4Is] -> [[a_a4Is]]
              [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
              go_X4cL
                = \ (ds_d51B :: [a_a4Is]) ->
                    case ds_d51B of {
                      [] -> GHC.Types.[] @ [a_a4Is];
                      : y_a3ex ys_a3ey ->
                        let {
                          z_X3ou :: [[a_a4Is]]
                          [LclId]
                          z_X3ou = go_X4cL ys_a3ey } in
                        letrec {
                          go1_X4cT [Occ=LoopBreaker] :: [[a_a4Is]] -> [[a_a4Is]]
                          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
                          go1_X4cT
                            = \ (ds1_X5bD :: [[a_a4Is]]) ->
                                case ds1_X5bD of {
                                  [] -> z_X3ou;
                                  : y1_X3oC ys1_X3oE ->
                                    GHC.Types.:
                                      @ [a_a4Is]
                                      (GHC.Types.: @ a_a4Is y_a3ex y1_X3oC)
                                      (go1_X4cT ys1_X3oE)
                                }; } in
                        go1_X4cT many_v_s5vc
                    }; } in
            ++
              @ [a_a4Is]
              (go_X4cL v_a37r)
              (GHC.Base.$fAlternative[]1 @ a_a4Is); } in
      many_v_s5vc

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fAlternative[] [InlPrag=NOUSERINLINE CONLIKE]
  :: Alternative []
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Alternative TYPE: []
                              GHC.Base.$fApplicative[]
                              GHC.Types.[]
                              ++
                              GHC.Base.$fAlternative[]_$csome
                              GHC.Base.$fAlternative[]_$cmany]
GHC.Base.$fAlternative[]
  = GHC.Base.C:Alternative
      @ []
      GHC.Base.$fApplicative[]
      GHC.Types.[]
      ++
      GHC.Base.$fAlternative[]_$csome
      GHC.Base.$fAlternative[]_$cmany

-- RHS size: {terms: 47, types: 63, coercions: 0, joins: 0/3}
GHC.Base.$w$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a b. NonEmpty a -> (a -> NonEmpty b) -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,C(U(1*U,1*U))>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [40 60] 270 30}]
GHC.Base.$w$c>>=
  = \ (@ a_s6HM)
      (@ b_s6HN)
      (w_s6HO :: NonEmpty a_s6HM)
      (w1_s6HP :: a_s6HM -> NonEmpty b_s6HN) ->
      let {
        ds_s5v8 [Dmd=<L,U(1*U,1*U)>] :: NonEmpty b_s6HN
        [LclId]
        ds_s5v8
          = w1_s6HP (case w_s6HO of { :| a1_a38t as_a38u -> a1_a38t }) } in
      (# case ds_s5v8 of { :| b1_a4sv bs_a4sx -> b1_a4sv },
         case ds_s5v8 of { :| b1_a4sv bs_a4sx ->
         ++
           @ b_s6HN
           bs_a4sx
           (case w_s6HO of { :| a1_a38t as_a38u ->
            letrec {
              go_X4cQ [Occ=LoopBreaker] :: [a_s6HM] -> [b_s6HN]
              [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
              go_X4cQ
                = \ (ds1_d51B :: [a_s6HM]) ->
                    case ds1_d51B of {
                      [] -> GHC.Types.[] @ b_s6HN;
                      : y_a3ex ys_a3ey ->
                        let {
                          ds2_s5va [Dmd=<L,U(1*U,1*U)>] :: NonEmpty b_s6HN
                          [LclId]
                          ds2_s5va = w1_s6HP y_a3ex } in
                        ++
                          @ b_s6HN
                          (GHC.Types.:
                             @ b_s6HN
                             (case ds2_s5va of { :| c_a38A cs_a38B -> c_a38A })
                             (case ds2_s5va of { :| c_a38A cs_a38B -> cs_a38B }))
                          (go_X4cQ ys_a3ey)
                    }; } in
            go_X4cQ as_a38u
            })
         } #)

-- RHS size: {terms: 12, types: 21, coercions: 0, joins: 0/0}
GHC.Base.$fMonadNonEmpty_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a b. NonEmpty a -> (a -> NonEmpty b) -> NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,C(U(1*U,1*U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6HM)
                 (@ b_s6HN)
                 (w_s6HO [Occ=Once] :: NonEmpty a_s6HM)
                 (w1_s6HP [Occ=Once] :: a_s6HM -> NonEmpty b_s6HN) ->
                 case GHC.Base.$w$c>>= @ a_s6HM @ b_s6HN w_s6HO w1_s6HP of
                 { (# ww1_s6RF [Occ=Once], ww2_s6RG [Occ=Once] #) ->
                 GHC.Base.:| @ b_s6HN ww1_s6RF ww2_s6RG
                 }}]
GHC.Base.$fMonadNonEmpty_$c>>=
  = \ (@ a_s6HM)
      (@ b_s6HN)
      (w_s6HO :: NonEmpty a_s6HM)
      (w1_s6HP :: a_s6HM -> NonEmpty b_s6HN) ->
      case GHC.Base.$w$c>>= @ a_s6HM @ b_s6HN w_s6HO w1_s6HP of
      { (# ww1_s6RF, ww2_s6RG #) ->
      GHC.Base.:| @ b_s6HN ww1_s6RF ww2_s6RG
      }

-- RHS size: {terms: 13, types: 21, coercions: 0, joins: 0/0}
GHC.Base.$fMonadNonEmpty_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b. NonEmpty a -> NonEmpty b -> NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4sH)
                 (@ b_a4sI)
                 (m_a37B [Occ=Once] :: NonEmpty a_a4sH)
                 (k_a37C [Occ=OnceL] :: NonEmpty b_a4sI) ->
                 GHC.Base.$fMonadNonEmpty_$c>>=
                   @ a_a4sH @ b_a4sI m_a37B (\ _ [Occ=Dead] -> k_a37C)}]
GHC.Base.$fMonadNonEmpty_$c>>
  = \ (@ a_a4sH)
      (@ b_a4sI)
      (eta_XaL :: NonEmpty a_a4sH)
      (eta1_X9X :: NonEmpty b_a4sI) ->
      case GHC.Base.$w$c>>=
             @ a_a4sH @ b_a4sI eta_XaL (\ _ [Occ=Dead] -> eta1_X9X)
      of
      { (# ww1_s6RF, ww2_s6RG #) ->
      GHC.Base.:| @ b_a4sI ww1_s6RF ww2_s6RG
      }

-- RHS size: {terms: 6, types: 7, coercions: 0, joins: 0/0}
GHC.Base.<**>1 :: forall a b. a -> (a -> b) -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a4hU)
                 (@ b_a4hV)
                 (a1_a3dx [Occ=Once] :: a_a4hU)
                 (f_a3dy [Occ=Once!] :: a_a4hU -> b_a4hV) ->
                 f_a3dy a1_a3dx}]
GHC.Base.<**>1
  = \ (@ a_a4hU)
      (@ b_a4hV)
      (a1_a3dx :: a_a4hU)
      (f_a3dy :: a_a4hU -> b_a4hV) ->
      f_a3dy a1_a3dx

-- RHS size: {terms: 7, types: 17, coercions: 0, joins: 0/0}
<**>
  :: forall (f :: * -> *) a b.
     Applicative f =>
     f a -> f (a -> b) -> f b
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLC(S)LL),1*U(A,A,A,1*C1(U),A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a4hT :: * -> *))
                 (@ a_a4hU)
                 (@ b_a4hV)
                 ($dApplicative_a4hX [Occ=Once] :: Applicative f_a4hT) ->
                 liftA2
                   @ f_a4hT
                   $dApplicative_a4hX
                   @ a_a4hU
                   @ (a_a4hU -> b_a4hV)
                   @ b_a4hV
                   (GHC.Base.<**>1 @ a_a4hU @ b_a4hV)}]
<**>
  = \ (@ (f_a4hT :: * -> *))
      (@ a_a4hU)
      (@ b_a4hV)
      ($dApplicative_a4hX :: Applicative f_a4hT) ->
      liftA2
        @ f_a4hT
        $dApplicative_a4hX
        @ a_a4hU
        @ (a_a4hU -> b_a4hV)
        @ b_a4hV
        (GHC.Base.<**>1 @ a_a4hU @ b_a4hV)

-- RHS size: {terms: 14, types: 25, coercions: 0, joins: 0/0}
GHC.Base.$dmliftA2
  :: forall (f :: * -> *).
     Applicative f =>
     forall a b c. (a -> b -> c) -> f a -> f b -> f c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(S)LLL),U(1*U(1*C1(C1(U)),A),A,1*C1(U),A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a37E :: * -> *))
                 ($dApplicative_a4iy :: Applicative f_a37E)
                 (@ a_a4iM)
                 (@ b_a4iN)
                 (@ c_a4iO) ->
                 let {
                   $dFunctor_a4iV [Occ=OnceL] :: Functor f_a37E
                   [LclId]
                   $dFunctor_a4iV
                     = GHC.Base.$p1Applicative @ f_a37E $dApplicative_a4iy } in
                 \ (f1_a37P [Occ=Once] :: a_a4iM -> b_a4iN -> c_a4iO)
                   (x_a37Q [Occ=Once] :: f_a37E a_a4iM) ->
                   <*>
                     @ f_a37E
                     $dApplicative_a4iy
                     @ b_a4iN
                     @ c_a4iO
                     (fmap
                        @ f_a37E
                        $dFunctor_a4iV
                        @ a_a4iM
                        @ (b_a4iN -> c_a4iO)
                        f1_a37P
                        x_a37Q)}]
GHC.Base.$dmliftA2
  = \ (@ (f_a37E :: * -> *))
      ($dApplicative_a4iy :: Applicative f_a37E)
      (@ a_a4iM)
      (@ b_a4iN)
      (@ c_a4iO)
      (eta_XaQ :: a_a4iM -> b_a4iN -> c_a4iO)
      (eta1_Xa3 :: f_a37E a_a4iM) ->
      <*>
        @ f_a37E
        $dApplicative_a4iy
        @ b_a4iN
        @ c_a4iO
        (fmap
           @ f_a37E
           (GHC.Base.$p1Applicative @ f_a37E $dApplicative_a4iy)
           @ a_a4iM
           @ (b_a4iN -> c_a4iO)
           eta_XaQ
           eta1_Xa3)

-- RHS size: {terms: 19, types: 30, coercions: 0, joins: 0/2}
GHC.Base.$dmsome
  :: forall (f :: * -> *). Alternative f => forall a. f a -> f [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a37j :: * -> *))
                 ($dAlternative_a4js :: Alternative f_a37j) ->
                 let {
                   $dApplicative_a4WE :: Applicative f_a37j
                   [LclId]
                   $dApplicative_a4WE
                     = GHC.Base.$p1Alternative @ f_a37j $dAlternative_a4js } in
                 \ (@ a_a4ju) (v_X3id [Occ=Once] :: f_a37j a_a4ju) ->
                   letrec {
                     some_v_a4jB [Occ=LoopBreaker] :: f_a37j [a_a4ju]
                     [LclId]
                     some_v_a4jB
                       = liftA2
                           @ f_a37j
                           $dApplicative_a4WE
                           @ a_a4ju
                           @ [a_a4ju]
                           @ [a_a4ju]
                           (GHC.Types.: @ a_a4ju)
                           v_X3id
                           (<|>
                              @ f_a37j
                              $dAlternative_a4js
                              @ [a_a4ju]
                              some_v_a4jB
                              (pure
                                 @ f_a37j
                                 $dApplicative_a4WE
                                 @ [a_a4ju]
                                 (GHC.Types.[] @ a_a4ju))); } in
                   some_v_a4jB}]
GHC.Base.$dmsome
  = \ (@ (f_a37j :: * -> *))
      ($dAlternative_a4js :: Alternative f_a37j)
      (@ a_a4ju)
      (eta_Xa1 :: f_a37j a_a4ju) ->
      letrec {
        some_v_s5v1 [Occ=LoopBreaker] :: f_a37j [a_a4ju]
        [LclId]
        some_v_s5v1
          = let {
              $dApplicative_s5v2 [Dmd=<S(LLLC(C(C(S)))LL),U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                :: Applicative f_a37j
              [LclId]
              $dApplicative_s5v2
                = GHC.Base.$p1Alternative @ f_a37j $dAlternative_a4js } in
            liftA2
              @ f_a37j
              $dApplicative_s5v2
              @ a_a4ju
              @ [a_a4ju]
              @ [a_a4ju]
              (GHC.Types.: @ a_a4ju)
              eta_Xa1
              (<|>
                 @ f_a37j
                 $dAlternative_a4js
                 @ [a_a4ju]
                 some_v_s5v1
                 (pure
                    @ f_a37j
                    $dApplicative_s5v2
                    @ [a_a4ju]
                    (GHC.Types.[] @ a_a4ju))); } in
      some_v_s5v1

-- RHS size: {terms: 19, types: 30, coercions: 0, joins: 0/2}
GHC.Base.$dmmany
  :: forall (f :: * -> *). Alternative f => forall a. f a -> f [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LL),U(U(A,C(U),A,C(C1(C1(U))),A,A),A,C(C1(U)),A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a37j :: * -> *))
                 ($dAlternative_a4js :: Alternative f_a37j) ->
                 let {
                   $dApplicative_a4WG :: Applicative f_a37j
                   [LclId]
                   $dApplicative_a4WG
                     = GHC.Base.$p1Alternative @ f_a37j $dAlternative_a4js } in
                 \ (@ a_a4jX) (v_a37r [Occ=Once] :: f_a37j a_a4jX) ->
                   letrec {
                     many_v_a4k1 [Occ=LoopBreaker] :: f_a37j [a_a4jX]
                     [LclId]
                     many_v_a4k1
                       = <|>
                           @ f_a37j
                           $dAlternative_a4js
                           @ [a_a4jX]
                           (liftA2
                              @ f_a37j
                              $dApplicative_a4WG
                              @ a_a4jX
                              @ [a_a4jX]
                              @ [a_a4jX]
                              (GHC.Types.: @ a_a4jX)
                              v_a37r
                              many_v_a4k1)
                           (pure
                              @ f_a37j
                              $dApplicative_a4WG
                              @ [a_a4jX]
                              (GHC.Types.[] @ a_a4jX)); } in
                   many_v_a4k1}]
GHC.Base.$dmmany
  = \ (@ (f_a37j :: * -> *))
      ($dAlternative_a4js :: Alternative f_a37j)
      (@ a_a4jX)
      (eta_Xa2 :: f_a37j a_a4jX) ->
      letrec {
        many_v_s5uX [Occ=LoopBreaker] :: f_a37j [a_a4jX]
        [LclId]
        many_v_s5uX
          = let {
              $dApplicative_s5uY [Dmd=<L,U(A,1*C1(U),A,1*C1(C1(C1(U))),A,A)>]
                :: Applicative f_a37j
              [LclId]
              $dApplicative_s5uY
                = GHC.Base.$p1Alternative @ f_a37j $dAlternative_a4js } in
            <|>
              @ f_a37j
              $dAlternative_a4js
              @ [a_a4jX]
              (liftA2
                 @ f_a37j
                 $dApplicative_s5uY
                 @ a_a4jX
                 @ [a_a4jX]
                 @ [a_a4jX]
                 (GHC.Types.: @ a_a4jX)
                 eta_Xa2
                 many_v_s5uX)
              (pure
                 @ f_a37j
                 $dApplicative_s5uY
                 @ [a_a4jX]
                 (GHC.Types.[] @ a_a4jX)); } in
      many_v_s5uX

-- RHS size: {terms: 27, types: 35, coercions: 0, joins: 0/2}
GHC.Base.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall b a. Semigroup b => (a -> b) -> [a -> b] -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 210 0}]
GHC.Base.$w$csconcat3
  = \ (@ b_s6HW)
      (@ a_s6HX)
      (w_s6HY :: Semigroup b_s6HW)
      (ww_s6I2 :: a_s6HX -> b_s6HW)
      (ww1_s6I3 :: [a_s6HX -> b_s6HW]) ->
      letrec {
        go_s5uS [Occ=LoopBreaker]
          :: (a_s6HX -> b_s6HW) -> [a_s6HX -> b_s6HW] -> a_s6HX -> b_s6HW
        [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []]
        go_s5uS
          = \ (b1_a384 :: a_s6HX -> b_s6HW)
              (ds_d548 :: [a_s6HX -> b_s6HW]) ->
              case ds_d548 of {
                [] -> b1_a384;
                : c_a385 cs_a386 ->
                  let {
                    g_s5uU [Dmd=<L,C(U)>] :: a_s6HX -> b_s6HW
                    [LclId]
                    g_s5uU = go_s5uS c_a385 cs_a386 } in
                  \ (x_a3aW :: a_s6HX) ->
                    <> @ b_s6HW w_s6HY (b1_a384 x_a3aW) (g_s5uU x_a3aW)
              }; } in
      go_s5uS ww_s6I2 ww1_s6I3

-- RHS size: {terms: 11, types: 19, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(->)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall b a. Semigroup b => NonEmpty (a -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_s6HW)
                 (@ a_s6HX)
                 (w_s6HY [Occ=Once] :: Semigroup b_s6HW)
                 (w1_s6HZ [Occ=Once!] :: NonEmpty (a_s6HX -> b_s6HW)) ->
                 case w1_s6HZ of { :| ww1_s6I2 [Occ=Once] ww2_s6I3 [Occ=Once] ->
                 GHC.Base.$w$csconcat3 @ b_s6HW @ a_s6HX w_s6HY ww1_s6I2 ww2_s6I3
                 }}]
GHC.Base.$fSemigroup(->)_$csconcat
  = \ (@ b_s6HW)
      (@ a_s6HX)
      (w_s6HY :: Semigroup b_s6HW)
      (w1_s6HZ :: NonEmpty (a_s6HX -> b_s6HW)) ->
      case w1_s6HZ of { :| ww1_s6I2 ww2_s6I3 ->
      GHC.Base.$w$csconcat3 @ b_s6HW @ a_s6HX w_s6HY ww1_s6I2 ww2_s6I3
      }

-- RHS size: {terms: 40, types: 64, coercions: 0, joins: 0/1}
GHC.Base.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Semigroup a, Semigroup b) =>
     a -> b -> [(a, b)] -> (# a, b #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 0 0 0] 240 0}]
GHC.Base.$w$csconcat
  = \ (@ a_s6Ih)
      (@ b_s6Ii)
      (w_s6Ij :: Semigroup a_s6Ih)
      (w1_s6Ik :: Semigroup b_s6Ii)
      (ww_s6Ir :: a_s6Ih)
      (ww1_s6Is :: b_s6Ii)
      (ww2_s6Iu :: [(a_s6Ih, b_s6Ii)]) ->
      letrec {
        $wgo_s6Ig [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
          :: a_s6Ih -> b_s6Ii -> [(a_s6Ih, b_s6Ii)] -> (# a_s6Ih, b_s6Ii #)
        [LclId, Arity=3, Str=<L,U><L,U><S,1*U>, Unf=OtherCon []]
        $wgo_s6Ig
          = \ (ww3_s6Ia :: a_s6Ih)
              (ww4_s6Ib :: b_s6Ii)
              (w2_s6I7 :: [(a_s6Ih, b_s6Ii)]) ->
              case w2_s6I7 of {
                [] -> (# ww3_s6Ia, ww4_s6Ib #);
                : c_a385 cs_a386 ->
                  case c_a385 of { (ww6_X6T5, ww7_X6T7) ->
                  case $wgo_s6Ig ww6_X6T5 ww7_X6T7 cs_a386 of
                  { (# ww9_s6RI, ww10_s6RJ #) ->
                  (# <> @ a_s6Ih w_s6Ij ww3_s6Ia ww9_s6RI,
                     <> @ b_s6Ii w1_s6Ik ww4_s6Ib ww10_s6RJ #)
                  }
                  }
              }; } in
      $wgo_s6Ig ww_s6Ir ww1_s6Is ww2_s6Iu

-- RHS size: {terms: 22, types: 39, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (Semigroup a, Semigroup b) =>
     NonEmpty (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U),1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6Ih)
                 (@ b_s6Ii)
                 (w_s6Ij [Occ=Once] :: Semigroup a_s6Ih)
                 (w1_s6Ik [Occ=Once] :: Semigroup b_s6Ii)
                 (w2_s6Il [Occ=Once!] :: NonEmpty (a_s6Ih, b_s6Ii)) ->
                 case w2_s6Il of { :| ww1_s6Io [Occ=Once!] ww2_s6Iu [Occ=Once] ->
                 case ww1_s6Io of { (ww4_s6Ir [Occ=Once], ww5_s6Is [Occ=Once]) ->
                 case GHC.Base.$w$csconcat
                        @ a_s6Ih @ b_s6Ii w_s6Ij w1_s6Ik ww4_s6Ir ww5_s6Is ww2_s6Iu
                 of
                 { (# ww7_s6RL [Occ=Once], ww8_s6RM [Occ=Once] #) ->
                 (ww7_s6RL, ww8_s6RM)
                 }
                 }
                 }}]
GHC.Base.$fSemigroup(,)_$csconcat
  = \ (@ a_s6Ih)
      (@ b_s6Ii)
      (w_s6Ij :: Semigroup a_s6Ih)
      (w1_s6Ik :: Semigroup b_s6Ii)
      (w2_s6Il :: NonEmpty (a_s6Ih, b_s6Ii)) ->
      case w2_s6Il of { :| ww1_s6Io ww2_s6Iu ->
      case ww1_s6Io of { (ww4_s6Ir, ww5_s6Is) ->
      case GHC.Base.$w$csconcat
             @ a_s6Ih @ b_s6Ii w_s6Ij w1_s6Ik ww4_s6Ir ww5_s6Is ww2_s6Iu
      of
      { (# ww7_s6RL, ww8_s6RM #) ->
      (ww7_s6RL, ww8_s6RM)
      }
      }
      }

-- RHS size: {terms: 23, types: 24, coercions: 0, joins: 0/1}
GHC.Base.$dmsconcat :: forall a. Semigroup a => NonEmpty a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a37Z)
                 ($dSemigroup_a4kp [Occ=OnceL] :: Semigroup a_a37Z)
                 (ds_X5eT [Occ=Once!] :: NonEmpty a_a37Z) ->
                 case ds_X5eT of { :| a1_a381 [Occ=Once] as_a382 [Occ=Once] ->
                 letrec {
                   go_a4ku [Occ=LoopBreaker] :: a_a37Z -> [a_a37Z] -> a_a37Z
                   [LclId, Arity=2, Unf=OtherCon []]
                   go_a4ku
                     = \ (b_a384 [Occ=Once*] :: a_a37Z)
                         (ds1_d548 [Occ=Once!] :: [a_a37Z]) ->
                         case ds1_d548 of {
                           [] -> b_a384;
                           : c_a385 [Occ=Once] cs_a386 [Occ=Once] ->
                             <> @ a_a37Z $dSemigroup_a4kp b_a384 (go_a4ku c_a385 cs_a386)
                         }; } in
                 go_a4ku a1_a381 as_a382
                 }}]
GHC.Base.$dmsconcat
  = \ (@ a_a37Z)
      ($dSemigroup_a4kp :: Semigroup a_a37Z)
      (ds_X5eT :: NonEmpty a_a37Z) ->
      case ds_X5eT of { :| a1_a381 as_a382 ->
      letrec {
        go_s5uO [Occ=LoopBreaker] :: a_a37Z -> [a_a37Z] -> a_a37Z
        [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []]
        go_s5uO
          = \ (b_a384 :: a_a37Z) (ds1_d548 :: [a_a37Z]) ->
              case ds1_d548 of {
                [] -> b_a384;
                : c_a385 cs_a386 ->
                  <> @ a_a37Z $dSemigroup_a4kp b_a384 (go_s5uO c_a385 cs_a386)
              }; } in
      go_s5uO a1_a381 as_a382
      }

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
GHC.Base.$dmstimes
  :: forall a. Semigroup a => forall b. Integral b => b -> a -> a
[GblId,
 Arity=2,
 Str=<L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a37Z)
                 ($dSemigroup_a4kp [Occ=Once] :: Semigroup a_a37Z)
                 (@ b_a4l3)
                 ($dIntegral_a4l5 [Occ=Once] :: Integral b_a4l3) ->
                 stimesDefault @ b_a4l3 @ a_a37Z $dIntegral_a4l5 $dSemigroup_a4kp}]
GHC.Base.$dmstimes
  = \ (@ a_a37Z)
      ($dSemigroup_a4kp :: Semigroup a_a37Z)
      (@ b_a4l3)
      ($dIntegral_a4l5 :: Integral b_a4l3) ->
      stimesDefault @ b_a4l3 @ a_a37Z $dIntegral_a4l5 $dSemigroup_a4kp

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
GHC.Base.$dmmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a. Monoid a => a -> a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(SLL)LLL),1*U(1*U(1*U,A,A),A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a37Y) ($dMonoid_a4le [Occ=Once] :: Monoid a_a37Y) ->
                 <> @ a_a37Y (GHC.Base.$p1Monoid @ a_a37Y $dMonoid_a4le)}]
GHC.Base.$dmmappend
  = \ (@ a_a37Y) ($dMonoid_a4le :: Monoid a_a37Y) ->
      <> @ a_a37Y (GHC.Base.$p1Monoid @ a_a37Y $dMonoid_a4le)

-- RHS size: {terms: 11, types: 18, coercions: 0, joins: 0/0}
GHC.Base.$dm>> [InlPrag=INLINE (sat-args=2)]
  :: forall (m :: * -> *). Monad m => forall a b. m a -> m b -> m b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_a37u :: * -> *))
                 ($dMonad_a4lt [Occ=Once] :: Monad m_a37u)
                 (@ a_a4lv)
                 (@ b_a4lw)
                 (m1_a37B [Occ=Once] :: m_a37u a_a4lv)
                 (k_a37C [Occ=OnceL] :: m_a37u b_a4lw) ->
                 >>=
                   @ m_a37u
                   $dMonad_a4lt
                   @ a_a4lv
                   @ b_a4lw
                   m1_a37B
                   (\ _ [Occ=Dead] -> k_a37C)}]
GHC.Base.$dm>>
  = \ (@ (m_a37u :: * -> *))
      ($dMonad_a4lt :: Monad m_a37u)
      (@ a_a4lv)
      (@ b_a4lw)
      (m1_a37B :: m_a37u a_a4lv)
      (k_a37C :: m_a37u b_a4lw) ->
      >>=
        @ m_a37u
        $dMonad_a4lt
        @ a_a4lv
        @ b_a4lw
        m1_a37B
        (\ _ [Occ=Dead] -> k_a37C)

-- RHS size: {terms: 6, types: 11, coercions: 0, joins: 0/0}
GHC.Base.$dmreturn
  :: forall (m :: * -> *). Monad m => forall a. a -> m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LSLLLL)LLLL),1*U(1*U(A,1*U,A,A,A,A),A,A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_a37u :: * -> *))
                 ($dMonad_a4lt [Occ=Once] :: Monad m_a37u)
                 (@ a_a4lF) ->
                 pure @ m_a37u (GHC.Base.$p1Monad @ m_a37u $dMonad_a4lt) @ a_a4lF}]
GHC.Base.$dmreturn
  = \ (@ (m_a37u :: * -> *))
      ($dMonad_a4lt :: Monad m_a37u)
      (@ a_a4lF) ->
      pure @ m_a37u (GHC.Base.$p1Monad @ m_a37u $dMonad_a4lt) @ a_a4lF

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
GHC.Base.$dmfail
  :: forall (m :: * -> *). Monad m => forall a. String -> m a
[GblId,
 Arity=2,
 Str=<B,A><B,U>x,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ (m_a37u :: * -> *))
                 _ [Occ=Dead]
                 (@ a_a4lN)
                 (s_a37D [Occ=Once] :: String) ->
                 errorWithoutStackTrace @ 'LiftedRep @ (m_a37u a_a4lN) s_a37D}]
GHC.Base.$dmfail
  = \ (@ (m_a37u :: * -> *))
      _ [Occ=Dead]
      (@ a_a4lN)
      (s_a37D :: String) ->
      errorWithoutStackTrace @ 'LiftedRep @ (m_a37u a_a4lN) s_a37D

-- RHS size: {terms: 6, types: 11, coercions: 0, joins: 0/0}
GHC.Base.$dmmzero
  :: forall (m :: * -> *). MonadPlus m => forall a. m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LSLLL)LLL),1*U(1*U(A,1*U,A,A,A),A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_a37g :: * -> *))
                 ($dMonadPlus_a4lS [Occ=Once] :: MonadPlus m_a37g)
                 (@ a_a4lU) ->
                 empty
                   @ m_a37g
                   (GHC.Base.$p1MonadPlus @ m_a37g $dMonadPlus_a4lS)
                   @ a_a4lU}]
GHC.Base.$dmmzero
  = \ (@ (m_a37g :: * -> *))
      ($dMonadPlus_a4lS :: MonadPlus m_a37g)
      (@ a_a4lU) ->
      empty
        @ m_a37g (GHC.Base.$p1MonadPlus @ m_a37g $dMonadPlus_a4lS) @ a_a4lU

-- RHS size: {terms: 6, types: 11, coercions: 0, joins: 0/0}
GHC.Base.$dmmplus
  :: forall (m :: * -> *). MonadPlus m => forall a. m a -> m a -> m a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S(LLSLL)LLL),1*U(1*U(A,A,1*U,A,A),A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (m_a37g :: * -> *))
                 ($dMonadPlus_a4lS [Occ=Once] :: MonadPlus m_a37g)
                 (@ a_a4m2) ->
                 <|>
                   @ m_a37g
                   (GHC.Base.$p1MonadPlus @ m_a37g $dMonadPlus_a4lS)
                   @ a_a4m2}]
GHC.Base.$dmmplus
  = \ (@ (m_a37g :: * -> *))
      ($dMonadPlus_a4lS :: MonadPlus m_a37g)
      (@ a_a4m2) ->
      <|>
        @ m_a37g (GHC.Base.$p1MonadPlus @ m_a37g $dMonadPlus_a4lS) @ a_a4m2

-- RHS size: {terms: 23, types: 18, coercions: 0, joins: 0/0}
GHC.Base.$fEqMaybe_$c==
  :: forall a. Eq a => Maybe a -> Maybe a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4m9)
                 ($dEq_a4ma [Occ=Once] :: Eq a_a4m9)
                 (ds_d54L [Occ=Once!] :: Maybe a_a4m9)
                 (ds1_d54M [Occ=Once*!] :: Maybe a_a4m9) ->
                 case ds_d54L of {
                   Nothing ->
                     case ds1_d54M of {
                       Nothing -> GHC.Types.True;
                       Just _ [Occ=Dead] -> GHC.Types.False
                     };
                   Just a1_a3Kp [Occ=Once] ->
                     case ds1_d54M of {
                       Nothing -> GHC.Types.False;
                       Just b1_a3Kq [Occ=Once] -> == @ a_a4m9 $dEq_a4ma a1_a3Kp b1_a3Kq
                     }
                 }}]
GHC.Base.$fEqMaybe_$c==
  = \ (@ a_a4m9)
      ($dEq_a4ma :: Eq a_a4m9)
      (ds_d54L :: Maybe a_a4m9)
      (ds1_d54M :: Maybe a_a4m9) ->
      case ds_d54L of {
        Nothing ->
          case ds1_d54M of {
            Nothing -> GHC.Types.True;
            Just ipv_s5dY -> GHC.Types.False
          };
        Just a1_a3Kp ->
          case ds1_d54M of {
            Nothing -> GHC.Types.False;
            Just b1_a3Kq -> == @ a_a4m9 $dEq_a4ma a1_a3Kp b1_a3Kq
          }
      }

-- RHS size: {terms: 28, types: 19, coercions: 0, joins: 0/0}
GHC.Base.$fEqMaybe_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a. Eq a => Maybe a -> Maybe a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4m9)
                 ($dEq_a4ma [Occ=Once] :: Eq a_a4m9)
                 (x_a22b [Occ=Once!] :: Maybe a_a4m9)
                 (y_a22c [Occ=Once*!] :: Maybe a_a4m9) ->
                 case x_a22b of {
                   Nothing ->
                     case y_a22c of {
                       Nothing -> GHC.Types.False;
                       Just _ [Occ=Dead] -> GHC.Types.True
                     };
                   Just a1_a3Kp [Occ=Once] ->
                     case y_a22c of {
                       Nothing -> GHC.Types.True;
                       Just b1_a3Kq [Occ=Once] ->
                         case == @ a_a4m9 $dEq_a4ma a1_a3Kp b1_a3Kq of {
                           False -> GHC.Types.True;
                           True -> GHC.Types.False
                         }
                     }
                 }}]
GHC.Base.$fEqMaybe_$c/=
  = \ (@ a_a4m9)
      ($dEq_a4ma :: Eq a_a4m9)
      (eta_Xb1 :: Maybe a_a4m9)
      (eta1_Xae :: Maybe a_a4m9) ->
      case eta_Xb1 of {
        Nothing ->
          case eta1_Xae of {
            Nothing -> GHC.Types.False;
            Just ipv_s5dY -> GHC.Types.True
          };
        Just a1_a3Kp ->
          case eta1_Xae of {
            Nothing -> GHC.Types.True;
            Just b1_a3Kq ->
              case == @ a_a4m9 $dEq_a4ma a1_a3Kp b1_a3Kq of {
                False -> GHC.Types.True;
                True -> GHC.Types.False
              }
          }
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Base.$fEqMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq a => Eq (Maybe a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_11) (v_Xad :: Eq a_11) ->
       GHC.Classes.C:Eq TYPE: Maybe a_11
                        GHC.Base.$fEqMaybe_$c== @ a_11 v_Xad
                        GHC.Base.$fEqMaybe_$c/= @ a_11 v_Xad]
GHC.Base.$fEqMaybe
  = \ (@ a_a4m9) ($dEq_a4ma :: Eq a_a4m9) ->
      GHC.Classes.C:Eq
        @ (Maybe a_a4m9)
        (GHC.Base.$fEqMaybe_$c== @ a_a4m9 $dEq_a4ma)
        (GHC.Base.$fEqMaybe_$c/= @ a_a4m9 $dEq_a4ma)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
GHC.Base.$fOrdMaybe_$cp1Ord :: forall a. Ord a => Eq (Maybe a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4mo) ($dOrd_a4mp [Occ=Once] :: Ord a_a4mo) ->
                 GHC.Base.$fEqMaybe
                   @ a_a4mo (GHC.Classes.$p1Ord @ a_a4mo $dOrd_a4mp)}]
GHC.Base.$fOrdMaybe_$cp1Ord
  = \ (@ a_a4mo) ($dOrd_a4mp :: Ord a_a4mo) ->
      GHC.Base.$fEqMaybe
        @ a_a4mo (GHC.Classes.$p1Ord @ a_a4mo $dOrd_a4mp)

-- RHS size: {terms: 23, types: 18, coercions: 0, joins: 0/0}
GHC.Base.$fOrdMaybe_$ccompare
  :: forall a. Ord a => Maybe a -> Maybe a -> Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4mo)
                 ($dOrd_a4mp [Occ=Once] :: Ord a_a4mo)
                 (a1_a3Kr [Occ=Once!] :: Maybe a_a4mo)
                 (b_a3Ks [Occ=Once*!] :: Maybe a_a4mo) ->
                 case a1_a3Kr of {
                   Nothing ->
                     case b_a3Ks of {
                       Nothing -> GHC.Types.EQ;
                       Just _ [Occ=Dead] -> GHC.Types.LT
                     };
                   Just a2_a3Kt [Occ=Once] ->
                     case b_a3Ks of {
                       Nothing -> GHC.Types.GT;
                       Just b1_a3Ku [Occ=Once] ->
                         compare @ a_a4mo $dOrd_a4mp a2_a3Kt b1_a3Ku
                     }
                 }}]
GHC.Base.$fOrdMaybe_$ccompare
  = \ (@ a_a4mo)
      ($dOrd_a4mp :: Ord a_a4mo)
      (a1_a3Kr :: Maybe a_a4mo)
      (b_a3Ks :: Maybe a_a4mo) ->
      case a1_a3Kr of {
        Nothing ->
          case b_a3Ks of {
            Nothing -> GHC.Types.EQ;
            Just ipv_s5dS -> GHC.Types.LT
          };
        Just a2_a3Kt ->
          case b_a3Ks of {
            Nothing -> GHC.Types.GT;
            Just b1_a3Ku -> compare @ a_a4mo $dOrd_a4mp a2_a3Kt b1_a3Ku
          }
      }

-- RHS size: {terms: 23, types: 18, coercions: 0, joins: 0/0}
GHC.Base.$fOrdMaybe_$c<
  :: forall a. Ord a => Maybe a -> Maybe a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4mo)
                 ($dOrd_a4mp [Occ=Once] :: Ord a_a4mo)
                 (a1_a3Kv [Occ=Once!] :: Maybe a_a4mo)
                 (b_a3Kw [Occ=Once*!] :: Maybe a_a4mo) ->
                 case a1_a3Kv of {
                   Nothing ->
                     case b_a3Kw of {
                       Nothing -> GHC.Types.False;
                       Just _ [Occ=Dead] -> GHC.Types.True
                     };
                   Just a2_a3Kx [Occ=Once] ->
                     case b_a3Kw of {
                       Nothing -> GHC.Types.False;
                       Just b1_a3Ky [Occ=Once] -> < @ a_a4mo $dOrd_a4mp a2_a3Kx b1_a3Ky
                     }
                 }}]
GHC.Base.$fOrdMaybe_$c<
  = \ (@ a_a4mo)
      ($dOrd_a4mp :: Ord a_a4mo)
      (a1_a3Kv :: Maybe a_a4mo)
      (b_a3Kw :: Maybe a_a4mo) ->
      case a1_a3Kv of {
        Nothing ->
          case b_a3Kw of {
            Nothing -> GHC.Types.False;
            Just ipv_s5dM -> GHC.Types.True
          };
        Just a2_a3Kx ->
          case b_a3Kw of {
            Nothing -> GHC.Types.False;
            Just b1_a3Ky -> < @ a_a4mo $dOrd_a4mp a2_a3Kx b1_a3Ky
          }
      }

-- RHS size: {terms: 28, types: 19, coercions: 0, joins: 0/0}
GHC.Base.$fOrdMaybe_$c<=
  :: forall a. Ord a => Maybe a -> Maybe a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 60 50] 120 50}]
GHC.Base.$fOrdMaybe_$c<=
  = \ (@ a_a4mo)
      ($dOrd_a4mp :: Ord a_a4mo)
      (a1_a3Kz :: Maybe a_a4mo)
      (b_a3KA :: Maybe a_a4mo) ->
      case b_a3KA of {
        Nothing ->
          case a1_a3Kz of {
            Nothing -> GHC.Types.True;
            Just ipv_s5dM -> GHC.Types.False
          };
        Just a2_a3Kx ->
          case a1_a3Kz of {
            Nothing -> GHC.Types.True;
            Just b1_a3Ky ->
              case < @ a_a4mo $dOrd_a4mp a2_a3Kx b1_a3Ky of {
                False -> GHC.Types.True;
                True -> GHC.Types.False
              }
          }
      }

-- RHS size: {terms: 23, types: 16, coercions: 0, joins: 0/0}
GHC.Base.$fOrdMaybe_$cmax
  :: forall a. Ord a => Maybe a -> Maybe a -> Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4mo)
                 ($dOrd_a4mp [Occ=Once] :: Ord a_a4mo)
                 (x_a55d [Occ=Once*] :: Maybe a_a4mo)
                 (y_a55e [Occ=Once!] :: Maybe a_a4mo) ->
                 case y_a55e of wild_X6x {
                   Nothing -> x_a55d;
                   Just a1_a3Kx [Occ=Once] ->
                     case x_a55d of wild1_X11 {
                       Nothing -> wild_X6x;
                       Just b1_a3Ky [Occ=Once] ->
                         case < @ a_a4mo $dOrd_a4mp a1_a3Kx b1_a3Ky of {
                           False -> wild_X6x;
                           True -> wild1_X11
                         }
                     }
                 }}]
GHC.Base.$fOrdMaybe_$cmax
  = \ (@ a_a4mo)
      ($dOrd_a4mp :: Ord a_a4mo)
      (x_a55d :: Maybe a_a4mo)
      (y_a55e :: Maybe a_a4mo) ->
      case y_a55e of wild_X6x {
        Nothing -> x_a55d;
        Just a1_a3Kx ->
          case x_a55d of wild1_X11 {
            Nothing -> wild_X6x;
            Just b1_a3Ky ->
              case < @ a_a4mo $dOrd_a4mp a1_a3Kx b1_a3Ky of {
                False -> wild_X6x;
                True -> wild1_X11
              }
          }
      }

-- RHS size: {terms: 26, types: 20, coercions: 0, joins: 0/0}
GHC.Base.$fOrdMaybe_$cmin
  :: forall a. Ord a => Maybe a -> Maybe a -> Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 50 40] 110 20}]
GHC.Base.$fOrdMaybe_$cmin
  = \ (@ a_a4mo)
      ($dOrd_a4mp :: Ord a_a4mo)
      (x_a55m :: Maybe a_a4mo)
      (y_a55n :: Maybe a_a4mo) ->
      case y_a55n of wild_X6x {
        Nothing ->
          case x_a55m of { __DEFAULT -> GHC.Base.Nothing @ a_a4mo };
        Just a1_a3Kx ->
          case x_a55m of wild1_X11 {
            Nothing -> GHC.Base.Nothing @ a_a4mo;
            Just b1_a3Ky ->
              case < @ a_a4mo $dOrd_a4mp a1_a3Kx b1_a3Ky of {
                False -> wild1_X11;
                True -> wild_X6x
              }
          }
      }

-- RHS size: {terms: 28, types: 19, coercions: 0, joins: 0/0}
GHC.Base.$fOrdMaybe_$c>=
  :: forall a. Ord a => Maybe a -> Maybe a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 50 60] 120 50}]
GHC.Base.$fOrdMaybe_$c>=
  = \ (@ a_a4mo)
      ($dOrd_a4mp :: Ord a_a4mo)
      (a1_a3KD :: Maybe a_a4mo)
      (b_a3KE :: Maybe a_a4mo) ->
      case a1_a3KD of {
        Nothing ->
          case b_a3KE of {
            Nothing -> GHC.Types.True;
            Just ipv_s5dM -> GHC.Types.False
          };
        Just a2_a3Kx ->
          case b_a3KE of {
            Nothing -> GHC.Types.True;
            Just b1_a3Ky ->
              case < @ a_a4mo $dOrd_a4mp a2_a3Kx b1_a3Ky of {
                False -> GHC.Types.True;
                True -> GHC.Types.False
              }
          }
      }

-- RHS size: {terms: 23, types: 18, coercions: 0, joins: 0/0}
GHC.Base.$fOrdMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord (Maybe a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_11) (v_Xal :: Ord a_11) ->
       GHC.Classes.C:Ord TYPE: Maybe a_11
                         GHC.Base.$fOrdMaybe_$cp1Ord @ a_11 v_Xal
                         GHC.Base.$fOrdMaybe_$ccompare @ a_11 v_Xal
                         GHC.Base.$fOrdMaybe_$c< @ a_11 v_Xal
                         GHC.Base.$fOrdMaybe_$c<= @ a_11 v_Xal
                         \ (a1_a3KB [Occ=Once] :: Maybe a_11)
                           (b_a3KC [Occ=Once] :: Maybe a_11) ->
                           GHC.Base.$fOrdMaybe_$c< @ a_11 v_Xal b_a3KC a1_a3KB
                         GHC.Base.$fOrdMaybe_$c>= @ a_11 v_Xal
                         GHC.Base.$fOrdMaybe_$cmax @ a_11 v_Xal
                         GHC.Base.$fOrdMaybe_$cmin @ a_11 v_Xal]
GHC.Base.$fOrdMaybe
  = \ (@ a_a4mo) ($dOrd_a4mp :: Ord a_a4mo) ->
      GHC.Classes.C:Ord
        @ (Maybe a_a4mo)
        (GHC.Base.$fOrdMaybe_$cp1Ord @ a_a4mo $dOrd_a4mp)
        (GHC.Base.$fOrdMaybe_$ccompare @ a_a4mo $dOrd_a4mp)
        (GHC.Base.$fOrdMaybe_$c< @ a_a4mo $dOrd_a4mp)
        (GHC.Base.$fOrdMaybe_$c<= @ a_a4mo $dOrd_a4mp)
        (\ (a1_a3KB :: Maybe a_a4mo) (b_a3KC :: Maybe a_a4mo) ->
           GHC.Base.$fOrdMaybe_$c< @ a_a4mo $dOrd_a4mp b_a3KC a1_a3KB)
        (GHC.Base.$fOrdMaybe_$c>= @ a_a4mo $dOrd_a4mp)
        (GHC.Base.$fOrdMaybe_$cmax @ a_a4mo $dOrd_a4mp)
        (GHC.Base.$fOrdMaybe_$cmin @ a_a4mo $dOrd_a4mp)

-- RHS size: {terms: 27, types: 22, coercions: 0, joins: 0/0}
GHC.Base.$fEqNonEmpty_$c/= [InlPrag=INLINE (sat-args=2)]
  :: forall a. Eq a => NonEmpty a -> NonEmpty a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4nu)
                 ($dEq_a4nv :: Eq a_a4nu)
                 (x_a22b [Occ=Once!] :: NonEmpty a_a4nu)
                 (y_a22c [Occ=Once!] :: NonEmpty a_a4nu) ->
                 case x_a22b of { :| a1_a3KF [Occ=Once] a2_a3KG [Occ=Once] ->
                 case y_a22c of { :| b1_a3KH [Occ=Once] b2_a3KI [Occ=Once] ->
                 case == @ a_a4nu $dEq_a4nv a1_a3KF b1_a3KH of {
                   False -> GHC.Types.True;
                   True ->
                     case GHC.Classes.$fEq[]_$c== @ a_a4nu $dEq_a4nv a2_a3KG b2_a3KI
                     of {
                       False -> GHC.Types.True;
                       True -> GHC.Types.False
                     }
                 }
                 }
                 }}]
GHC.Base.$fEqNonEmpty_$c/=
  = \ (@ a_a4nu)
      ($dEq_a4nv :: Eq a_a4nu)
      (eta_Xbc :: NonEmpty a_a4nu)
      (eta1_Xao :: NonEmpty a_a4nu) ->
      case eta_Xbc of { :| a1_a3KF a2_a3KG ->
      case eta1_Xao of { :| b1_a3KH b2_a3KI ->
      case == @ a_a4nu $dEq_a4nv a1_a3KF b1_a3KH of {
        False -> GHC.Types.True;
        True ->
          case GHC.Classes.$fEq[]_$c== @ a_a4nu $dEq_a4nv a2_a3KG b2_a3KI
          of {
            False -> GHC.Types.True;
            True -> GHC.Types.False
          }
      }
      }
      }

-- RHS size: {terms: 18, types: 13, coercions: 0, joins: 0/0}
GHC.Base.$w$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a. Eq a => a -> [a] -> a -> [a] -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 100 10}]
GHC.Base.$w$c==
  = \ (@ a_s6IO)
      (w_s6IP :: Eq a_s6IO)
      (ww_s6IU :: a_s6IO)
      (ww1_s6IV :: [a_s6IO])
      (ww2_s6IZ :: a_s6IO)
      (ww3_s6J0 :: [a_s6IO]) ->
      case == @ a_s6IO w_s6IP ww_s6IU ww2_s6IZ of {
        False -> GHC.Types.False;
        True -> GHC.Classes.$fEq[]_$c== @ a_s6IO w_s6IP ww1_s6IV ww3_s6J0
      }

-- RHS size: {terms: 16, types: 19, coercions: 0, joins: 0/0}
GHC.Base.$fEqNonEmpty_$c== [InlPrag=NOUSERINLINE[0]]
  :: forall a. Eq a => NonEmpty a -> NonEmpty a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(C(C(S))L),U(C(C1(U)),A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6IO)
                 (w_s6IP [Occ=Once] :: Eq a_s6IO)
                 (w1_s6IQ [Occ=Once!] :: NonEmpty a_s6IO)
                 (w2_s6IR [Occ=Once!] :: NonEmpty a_s6IO) ->
                 case w1_s6IQ of { :| ww1_s6IU [Occ=Once] ww2_s6IV [Occ=Once] ->
                 case w2_s6IR of { :| ww4_s6IZ [Occ=Once] ww5_s6J0 [Occ=Once] ->
                 GHC.Base.$w$c== @ a_s6IO w_s6IP ww1_s6IU ww2_s6IV ww4_s6IZ ww5_s6J0
                 }
                 }}]
GHC.Base.$fEqNonEmpty_$c==
  = \ (@ a_s6IO)
      (w_s6IP :: Eq a_s6IO)
      (w1_s6IQ :: NonEmpty a_s6IO)
      (w2_s6IR :: NonEmpty a_s6IO) ->
      case w1_s6IQ of { :| ww1_s6IU ww2_s6IV ->
      case w2_s6IR of { :| ww4_s6IZ ww5_s6J0 ->
      GHC.Base.$w$c== @ a_s6IO w_s6IP ww1_s6IU ww2_s6IV ww4_s6IZ ww5_s6J0
      }
      }

-- RHS size: {terms: 7, types: 8, coercions: 0, joins: 0/0}
GHC.Base.$fEqNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Eq a => Eq (NonEmpty a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)>m,
 Unf=DFun: \ (@ a_a37f) (v_Xao :: Eq a_a37f) ->
       GHC.Classes.C:Eq TYPE: NonEmpty a_a37f
                        GHC.Base.$fEqNonEmpty_$c== @ a_a37f v_Xao
                        GHC.Base.$fEqNonEmpty_$c/= @ a_a37f v_Xao]
GHC.Base.$fEqNonEmpty
  = \ (@ a_a4nu) ($dEq_a4nv :: Eq a_a4nu) ->
      GHC.Classes.C:Eq
        @ (NonEmpty a_a4nu)
        (GHC.Base.$fEqNonEmpty_$c== @ a_a4nu $dEq_a4nv)
        (GHC.Base.$fEqNonEmpty_$c/= @ a_a4nu $dEq_a4nv)

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
GHC.Base.$fOrdNonEmpty_$cp1Ord
  :: forall a. Ord a => Eq (NonEmpty a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4nL) ($dOrd_a4nM [Occ=Once] :: Ord a_a4nL) ->
                 GHC.Base.$fEqNonEmpty
                   @ a_a4nL (GHC.Classes.$p1Ord @ a_a4nL $dOrd_a4nM)}]
GHC.Base.$fOrdNonEmpty_$cp1Ord
  = \ (@ a_a4nL) ($dOrd_a4nM :: Ord a_a4nL) ->
      GHC.Base.$fEqNonEmpty
        @ a_a4nL (GHC.Classes.$p1Ord @ a_a4nL $dOrd_a4nM)

-- RHS size: {terms: 20, types: 13, coercions: 0, joins: 0/0}
GHC.Base.$w$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => a -> [a] -> a -> [a] -> Ordering
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 110 20}]
GHC.Base.$w$ccompare
  = \ (@ a_s6J3)
      (w_s6J4 :: Ord a_s6J3)
      (ww_s6J9 :: a_s6J3)
      (ww1_s6Ja :: [a_s6J3])
      (ww2_s6Je :: a_s6J3)
      (ww3_s6Jf :: [a_s6J3]) ->
      case compare @ a_s6J3 w_s6J4 ww_s6J9 ww2_s6Je of {
        LT -> GHC.Types.LT;
        EQ ->
          GHC.Classes.$fOrd[]_$ccompare @ a_s6J3 w_s6J4 ww1_s6Ja ww3_s6Jf;
        GT -> GHC.Types.GT
      }

-- RHS size: {terms: 16, types: 19, coercions: 0, joins: 0/0}
GHC.Base.$fOrdNonEmpty_$ccompare [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => NonEmpty a -> NonEmpty a -> Ordering
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6J3)
                 (w_s6J4 [Occ=Once] :: Ord a_s6J3)
                 (w1_s6J5 [Occ=Once!] :: NonEmpty a_s6J3)
                 (w2_s6J6 [Occ=Once!] :: NonEmpty a_s6J3) ->
                 case w1_s6J5 of { :| ww1_s6J9 [Occ=Once] ww2_s6Ja [Occ=Once] ->
                 case w2_s6J6 of { :| ww4_s6Je [Occ=Once] ww5_s6Jf [Occ=Once] ->
                 GHC.Base.$w$ccompare
                   @ a_s6J3 w_s6J4 ww1_s6J9 ww2_s6Ja ww4_s6Je ww5_s6Jf
                 }
                 }}]
GHC.Base.$fOrdNonEmpty_$ccompare
  = \ (@ a_s6J3)
      (w_s6J4 :: Ord a_s6J3)
      (w1_s6J5 :: NonEmpty a_s6J3)
      (w2_s6J6 :: NonEmpty a_s6J3) ->
      case w1_s6J5 of { :| ww1_s6J9 ww2_s6Ja ->
      case w2_s6J6 of { :| ww4_s6Je ww5_s6Jf ->
      GHC.Base.$w$ccompare
        @ a_s6J3 w_s6J4 ww1_s6J9 ww2_s6Ja ww4_s6Je ww5_s6Jf
      }
      }

-- RHS size: {terms: 20, types: 13, coercions: 0, joins: 0/0}
GHC.Base.$w$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => a -> [a] -> a -> [a] -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 110 20}]
GHC.Base.$w$c<
  = \ (@ a_s6Ji)
      (w_s6Jj :: Ord a_s6Ji)
      (ww_s6Jo :: a_s6Ji)
      (ww1_s6Jp :: [a_s6Ji])
      (ww2_s6Jt :: a_s6Ji)
      (ww3_s6Ju :: [a_s6Ji]) ->
      case compare @ a_s6Ji w_s6Jj ww_s6Jo ww2_s6Jt of {
        LT -> GHC.Types.True;
        EQ -> GHC.Classes.$fOrd[]_$c< @ a_s6Ji w_s6Jj ww1_s6Jp ww3_s6Ju;
        GT -> GHC.Types.False
      }

-- RHS size: {terms: 16, types: 19, coercions: 0, joins: 0/0}
GHC.Base.$fOrdNonEmpty_$c< [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => NonEmpty a -> NonEmpty a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6Ji)
                 (w_s6Jj [Occ=Once] :: Ord a_s6Ji)
                 (w1_s6Jk [Occ=Once!] :: NonEmpty a_s6Ji)
                 (w2_s6Jl [Occ=Once!] :: NonEmpty a_s6Ji) ->
                 case w1_s6Jk of { :| ww1_s6Jo [Occ=Once] ww2_s6Jp [Occ=Once] ->
                 case w2_s6Jl of { :| ww4_s6Jt [Occ=Once] ww5_s6Ju [Occ=Once] ->
                 GHC.Base.$w$c< @ a_s6Ji w_s6Jj ww1_s6Jo ww2_s6Jp ww4_s6Jt ww5_s6Ju
                 }
                 }}]
GHC.Base.$fOrdNonEmpty_$c<
  = \ (@ a_s6Ji)
      (w_s6Jj :: Ord a_s6Ji)
      (w1_s6Jk :: NonEmpty a_s6Ji)
      (w2_s6Jl :: NonEmpty a_s6Ji) ->
      case w1_s6Jk of { :| ww1_s6Jo ww2_s6Jp ->
      case w2_s6Jl of { :| ww4_s6Jt ww5_s6Ju ->
      GHC.Base.$w$c< @ a_s6Ji w_s6Jj ww1_s6Jo ww2_s6Jp ww4_s6Jt ww5_s6Ju
      }
      }

-- RHS size: {terms: 25, types: 14, coercions: 0, joins: 0/0}
GHC.Base.$w$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => a -> [a] -> a -> [a] -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 130 40}]
GHC.Base.$w$c<=
  = \ (@ a_s6Jx)
      (w_s6Jy :: Ord a_s6Jx)
      (ww_s6JD :: a_s6Jx)
      (ww1_s6JE :: [a_s6Jx])
      (ww2_s6JI :: a_s6Jx)
      (ww3_s6JJ :: [a_s6Jx]) ->
      case compare @ a_s6Jx w_s6Jy ww2_s6JI ww_s6JD of {
        LT -> GHC.Types.False;
        EQ ->
          case GHC.Classes.$fOrd[]_$ccompare
                 @ a_s6Jx w_s6Jy ww3_s6JJ ww1_s6JE
          of {
            __DEFAULT -> GHC.Types.True;
            LT -> GHC.Types.False
          };
        GT -> GHC.Types.True
      }

-- RHS size: {terms: 16, types: 19, coercions: 0, joins: 0/0}
GHC.Base.$fOrdNonEmpty_$c<= [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => NonEmpty a -> NonEmpty a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6Jx)
                 (w_s6Jy [Occ=Once] :: Ord a_s6Jx)
                 (w1_s6Jz [Occ=Once!] :: NonEmpty a_s6Jx)
                 (w2_s6JA [Occ=Once!] :: NonEmpty a_s6Jx) ->
                 case w1_s6Jz of { :| ww1_s6JD [Occ=Once] ww2_s6JE [Occ=Once] ->
                 case w2_s6JA of { :| ww4_s6JI [Occ=Once] ww5_s6JJ [Occ=Once] ->
                 GHC.Base.$w$c<= @ a_s6Jx w_s6Jy ww1_s6JD ww2_s6JE ww4_s6JI ww5_s6JJ
                 }
                 }}]
GHC.Base.$fOrdNonEmpty_$c<=
  = \ (@ a_s6Jx)
      (w_s6Jy :: Ord a_s6Jx)
      (w1_s6Jz :: NonEmpty a_s6Jx)
      (w2_s6JA :: NonEmpty a_s6Jx) ->
      case w1_s6Jz of { :| ww1_s6JD ww2_s6JE ->
      case w2_s6JA of { :| ww4_s6JI ww5_s6JJ ->
      GHC.Base.$w$c<= @ a_s6Jx w_s6Jy ww1_s6JD ww2_s6JE ww4_s6JI ww5_s6JJ
      }
      }

-- RHS size: {terms: 29, types: 22, coercions: 0, joins: 0/0}
GHC.Base.$fOrdNonEmpty_$cmax [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => NonEmpty a -> NonEmpty a -> NonEmpty a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6JM)
                 (w_s6JN :: Ord a_s6JM)
                 (w1_s6JO [Occ=Once!] :: NonEmpty a_s6JM)
                 (w2_s6JP [Occ=Once!] :: NonEmpty a_s6JM) ->
                 case w1_s6JO of { :| ww1_s6JS ww2_s6JT ->
                 case w2_s6JP of { :| ww4_s6JX ww5_s6JY ->
                 case compare @ a_s6JM w_s6JN ww4_s6JX ww1_s6JS of {
                   LT -> GHC.Base.:| @ a_s6JM ww1_s6JS ww2_s6JT;
                   EQ ->
                     case GHC.Classes.$fOrd[]_$ccompare
                            @ a_s6JM w_s6JN ww5_s6JY ww2_s6JT
                     of {
                       __DEFAULT -> GHC.Base.:| @ a_s6JM ww4_s6JX ww5_s6JY;
                       LT -> GHC.Base.:| @ a_s6JM ww1_s6JS ww2_s6JT
                     };
                   GT -> GHC.Base.:| @ a_s6JM ww4_s6JX ww5_s6JY
                 }
                 }
                 }}]
GHC.Base.$fOrdNonEmpty_$cmax
  = \ (@ a_s6JM)
      (w_s6JN :: Ord a_s6JM)
      (w1_s6JO :: NonEmpty a_s6JM)
      (w2_s6JP :: NonEmpty a_s6JM) ->
      case w1_s6JO of ww_s6JR { :| ww1_s6JS ww2_s6JT ->
      case w2_s6JP of ww3_s6JW { :| ww4_s6JX ww5_s6JY ->
      case compare @ a_s6JM w_s6JN ww4_s6JX ww1_s6JS of {
        LT -> ww_s6JR;
        EQ ->
          case GHC.Classes.$fOrd[]_$ccompare
                 @ a_s6JM w_s6JN ww5_s6JY ww2_s6JT
          of {
            __DEFAULT -> ww3_s6JW;
            LT -> ww_s6JR
          };
        GT -> ww3_s6JW
      }
      }
      }

-- RHS size: {terms: 29, types: 22, coercions: 0, joins: 0/0}
GHC.Base.$fOrdNonEmpty_$cmin [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => NonEmpty a -> NonEmpty a -> NonEmpty a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6K4)
                 (w_s6K5 :: Ord a_s6K4)
                 (w1_s6K6 [Occ=Once!] :: NonEmpty a_s6K4)
                 (w2_s6K7 [Occ=Once!] :: NonEmpty a_s6K4) ->
                 case w1_s6K6 of { :| ww1_s6Ka ww2_s6Kb ->
                 case w2_s6K7 of { :| ww4_s6Kf ww5_s6Kg ->
                 case compare @ a_s6K4 w_s6K5 ww4_s6Kf ww1_s6Ka of {
                   LT -> GHC.Base.:| @ a_s6K4 ww4_s6Kf ww5_s6Kg;
                   EQ ->
                     case GHC.Classes.$fOrd[]_$ccompare
                            @ a_s6K4 w_s6K5 ww5_s6Kg ww2_s6Kb
                     of {
                       __DEFAULT -> GHC.Base.:| @ a_s6K4 ww1_s6Ka ww2_s6Kb;
                       LT -> GHC.Base.:| @ a_s6K4 ww4_s6Kf ww5_s6Kg
                     };
                   GT -> GHC.Base.:| @ a_s6K4 ww1_s6Ka ww2_s6Kb
                 }
                 }
                 }}]
GHC.Base.$fOrdNonEmpty_$cmin
  = \ (@ a_s6K4)
      (w_s6K5 :: Ord a_s6K4)
      (w1_s6K6 :: NonEmpty a_s6K4)
      (w2_s6K7 :: NonEmpty a_s6K4) ->
      case w1_s6K6 of ww_s6K9 { :| ww1_s6Ka ww2_s6Kb ->
      case w2_s6K7 of ww3_s6Ke { :| ww4_s6Kf ww5_s6Kg ->
      case compare @ a_s6K4 w_s6K5 ww4_s6Kf ww1_s6Ka of {
        LT -> ww3_s6Ke;
        EQ ->
          case GHC.Classes.$fOrd[]_$ccompare
                 @ a_s6K4 w_s6K5 ww5_s6Kg ww2_s6Kb
          of {
            __DEFAULT -> ww_s6K9;
            LT -> ww3_s6Ke
          };
        GT -> ww_s6K9
      }
      }
      }

-- RHS size: {terms: 25, types: 14, coercions: 0, joins: 0/0}
GHC.Base.$w$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => a -> [a] -> a -> [a] -> Bool
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><L,U><L,1*U><L,U><L,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 0 0 0 0] 130 40}]
GHC.Base.$w$c>=
  = \ (@ a_s6Km)
      (w_s6Kn :: Ord a_s6Km)
      (ww_s6Ks :: a_s6Km)
      (ww1_s6Kt :: [a_s6Km])
      (ww2_s6Kx :: a_s6Km)
      (ww3_s6Ky :: [a_s6Km]) ->
      case compare @ a_s6Km w_s6Kn ww_s6Ks ww2_s6Kx of {
        LT -> GHC.Types.False;
        EQ ->
          case GHC.Classes.$fOrd[]_$ccompare
                 @ a_s6Km w_s6Kn ww1_s6Kt ww3_s6Ky
          of {
            __DEFAULT -> GHC.Types.True;
            LT -> GHC.Types.False
          };
        GT -> GHC.Types.True
      }

-- RHS size: {terms: 16, types: 19, coercions: 0, joins: 0/0}
GHC.Base.$fOrdNonEmpty_$c>= [InlPrag=NOUSERINLINE[0]]
  :: forall a. Ord a => NonEmpty a -> NonEmpty a -> Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LC(C(S))LLLLLL),U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U(U,1*U)><S,1*U(U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6Km)
                 (w_s6Kn [Occ=Once] :: Ord a_s6Km)
                 (w1_s6Ko [Occ=Once!] :: NonEmpty a_s6Km)
                 (w2_s6Kp [Occ=Once!] :: NonEmpty a_s6Km) ->
                 case w1_s6Ko of { :| ww1_s6Ks [Occ=Once] ww2_s6Kt [Occ=Once] ->
                 case w2_s6Kp of { :| ww4_s6Kx [Occ=Once] ww5_s6Ky [Occ=Once] ->
                 GHC.Base.$w$c>= @ a_s6Km w_s6Kn ww1_s6Ks ww2_s6Kt ww4_s6Kx ww5_s6Ky
                 }
                 }}]
GHC.Base.$fOrdNonEmpty_$c>=
  = \ (@ a_s6Km)
      (w_s6Kn :: Ord a_s6Km)
      (w1_s6Ko :: NonEmpty a_s6Km)
      (w2_s6Kp :: NonEmpty a_s6Km) ->
      case w1_s6Ko of { :| ww1_s6Ks ww2_s6Kt ->
      case w2_s6Kp of { :| ww4_s6Kx ww5_s6Ky ->
      GHC.Base.$w$c>= @ a_s6Km w_s6Kn ww1_s6Ks ww2_s6Kt ww4_s6Kx ww5_s6Ky
      }
      }

-- RHS size: {terms: 23, types: 18, coercions: 0, joins: 0/0}
GHC.Base.$fOrdNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Ord a => Ord (NonEmpty a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_a37f) (v_Xaw :: Ord a_a37f) ->
       GHC.Classes.C:Ord TYPE: NonEmpty a_a37f
                         GHC.Base.$fOrdNonEmpty_$cp1Ord @ a_a37f v_Xaw
                         GHC.Base.$fOrdNonEmpty_$ccompare @ a_a37f v_Xaw
                         GHC.Base.$fOrdNonEmpty_$c< @ a_a37f v_Xaw
                         GHC.Base.$fOrdNonEmpty_$c<= @ a_a37f v_Xaw
                         \ (a1_a3KX [Occ=Once] :: NonEmpty a_a37f)
                           (b_a3KY [Occ=Once] :: NonEmpty a_a37f) ->
                           GHC.Base.$fOrdNonEmpty_$c< @ a_a37f v_Xaw b_a3KY a1_a3KX
                         GHC.Base.$fOrdNonEmpty_$c>= @ a_a37f v_Xaw
                         GHC.Base.$fOrdNonEmpty_$cmax @ a_a37f v_Xaw
                         GHC.Base.$fOrdNonEmpty_$cmin @ a_a37f v_Xaw]
GHC.Base.$fOrdNonEmpty
  = \ (@ a_a4nL) ($dOrd_a4nM :: Ord a_a4nL) ->
      GHC.Classes.C:Ord
        @ (NonEmpty a_a4nL)
        (GHC.Base.$fOrdNonEmpty_$cp1Ord @ a_a4nL $dOrd_a4nM)
        (GHC.Base.$fOrdNonEmpty_$ccompare @ a_a4nL $dOrd_a4nM)
        (GHC.Base.$fOrdNonEmpty_$c< @ a_a4nL $dOrd_a4nM)
        (GHC.Base.$fOrdNonEmpty_$c<= @ a_a4nL $dOrd_a4nM)
        (\ (a1_a3KX :: NonEmpty a_a4nL) (b_a3KY :: NonEmpty a_a4nL) ->
           GHC.Base.$fOrdNonEmpty_$c< @ a_a4nL $dOrd_a4nM b_a3KY a1_a3KX)
        (GHC.Base.$fOrdNonEmpty_$c>= @ a_a4nL $dOrd_a4nM)
        (GHC.Base.$fOrdNonEmpty_$cmax @ a_a4nL $dOrd_a4nM)
        (GHC.Base.$fOrdNonEmpty_$cmin @ a_a4nL $dOrd_a4nM)

-- RHS size: {terms: 4, types: 4, coercions: 0, joins: 0/0}
GHC.Base.$fMonadIO_$cfail :: forall a. String -> IO a
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a4qB) (s_a389 [Occ=Once] :: String) ->
                 failIO @ a_a4qB s_a389}]
GHC.Base.$fMonadIO_$cfail
  = \ (@ a_a4qB) (s_a389 :: String) -> failIO @ a_a4qB s_a389

-- RHS size: {terms: 6, types: 1, coercions: 39, joins: 0/0}
GHC.Base.$fMonadIO [InlPrag=NOUSERINLINE CONLIKE] :: Monad IO
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: IO
                        GHC.Base.$fApplicativeIO
                        GHC.Base.$fMonadIO1
                        `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                <IO a>_R ->_R <a -> IO b>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                                :: (forall a b.
                                    IO a
                                    -> (a -> IO b)
                                    -> State# RealWorld
                                    -> (# State# RealWorld, b #) :: *)
                                   ~R# (forall a b. IO a -> (a -> IO b) -> IO b :: *))
                        GHC.Base.$fApplicativeIO2
                        `cast` (forall (a :: <*>_N) (b :: <*>_N).
                                <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
                                :: (forall a b.
                                    IO a
                                    -> IO b -> State# RealWorld -> (# State# RealWorld, b #) :: *)
                                   ~R# (forall a b. IO a -> IO b -> IO b :: *))
                        GHC.Base.$fApplicativeIO4
                        `cast` (forall (a :: <*>_N).
                                <a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
                                :: (forall a.
                                    a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                                   ~R# (forall a. a -> IO a :: *))
                        GHC.Base.$fMonadIO_$cfail]
GHC.Base.$fMonadIO
  = GHC.Base.C:Monad
      @ IO
      GHC.Base.$fApplicativeIO
      (GHC.Base.$fMonadIO1
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <IO a>_R ->_R <a -> IO b>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
               :: (forall a b.
                   IO a
                   -> (a -> IO b)
                   -> State# RealWorld
                   -> (# State# RealWorld, b #) :: *)
                  ~R# (forall a b. IO a -> (a -> IO b) -> IO b :: *)))
      (GHC.Base.$fApplicativeIO2
       `cast` (forall (a :: <*>_N) (b :: <*>_N).
               <IO a>_R ->_R <IO b>_R ->_R Sym (GHC.Types.N:IO[0] <b>_R)
               :: (forall a b.
                   IO a -> IO b -> State# RealWorld -> (# State# RealWorld, b #) :: *)
                  ~R# (forall a b. IO a -> IO b -> IO b :: *)))
      (GHC.Base.$fApplicativeIO4
       `cast` (forall (a :: <*>_N).
               <a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)
               :: (forall a.
                   a -> State# RealWorld -> (# State# RealWorld, a #) :: *)
                  ~R# (forall a. a -> IO a :: *)))
      GHC.Base.$fMonadIO_$cfail

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
GHC.Base.$fMonad[]_$cfail [InlPrag=INLINE (sat-args=1)]
  :: forall a. String -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ a_a4rH) _ [Occ=Dead] -> GHC.Types.[] @ a_a4rH}]
GHC.Base.$fMonad[]_$cfail
  = \ (@ a_a4rH) _ [Occ=Dead] -> GHC.Types.[] @ a_a4rH

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fMonad[] [InlPrag=NOUSERINLINE CONLIKE] :: Monad []
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: []
                        GHC.Base.$fApplicative[]
                        GHC.Base.$fMonad[]_$c>>=
                        GHC.Base.$fApplicative[]_$c*>
                        GHC.Base.$fApplicative[]_$cpure
                        GHC.Base.$fMonad[]_$cfail]
GHC.Base.$fMonad[]
  = GHC.Base.C:Monad
      @ []
      GHC.Base.$fApplicative[]
      GHC.Base.$fMonad[]_$c>>=
      GHC.Base.$fApplicative[]_$c*>
      GHC.Base.$fApplicative[]_$cpure
      GHC.Base.$fMonad[]_$cfail

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fMonadPlus[] [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadPlus []
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:MonadPlus TYPE: []
                            GHC.Base.$fAlternative[]
                            GHC.Base.$fMonad[]
                            GHC.Types.[]
                            ++]
GHC.Base.$fMonadPlus[]
  = GHC.Base.C:MonadPlus
      @ [] GHC.Base.$fAlternative[] GHC.Base.$fMonad[] GHC.Types.[] ++

-- RHS size: {terms: 11, types: 13, coercions: 0, joins: 0/0}
GHC.Base.$fMonadMaybe_$c>>=
  :: forall a b. Maybe a -> (a -> Maybe b) -> Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4td)
                 (@ b_a4te)
                 (ds_d56t [Occ=Once!] :: Maybe a_a4td)
                 (k_a38L [Occ=Once!] :: a_a4td -> Maybe b_a4te) ->
                 case ds_d56t of {
                   Nothing -> GHC.Base.Nothing @ b_a4te;
                   Just x_a38K [Occ=Once] -> k_a38L x_a38K
                 }}]
GHC.Base.$fMonadMaybe_$c>>=
  = \ (@ a_a4td)
      (@ b_a4te)
      (ds_d56t :: Maybe a_a4td)
      (k_a38L :: a_a4td -> Maybe b_a4te) ->
      case ds_d56t of {
        Nothing -> GHC.Base.Nothing @ b_a4te;
        Just x_a38K -> k_a38L x_a38K
      }

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
GHC.Base.$fMonadMaybe_$cfail :: forall a. String -> Maybe a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a4tD) _ [Occ=Dead] -> GHC.Base.Nothing @ a_a4tD}]
GHC.Base.$fMonadMaybe_$cfail
  = \ (@ a_a4tD) _ [Occ=Dead] -> GHC.Base.Nothing @ a_a4tD

-- RHS size: {terms: 10, types: 12, coercions: 0, joins: 0/0}
GHC.Base.$fMonad(->)_$c>>=
  :: forall r a b. (r -> a) -> (a -> r -> b) -> r -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><C(C(S)),1*C1(C1(U))><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ r_a4tI)
                 (@ a_a4tQ)
                 (@ b_a4tR)
                 (f_a392 [Occ=Once!] :: r_a4tI -> a_a4tQ)
                 (k_a393 [Occ=Once!] :: a_a4tQ -> r_a4tI -> b_a4tR)
                 (r1_a394 :: r_a4tI) ->
                 k_a393 (f_a392 r1_a394) r1_a394}]
GHC.Base.$fMonad(->)_$c>>=
  = \ (@ r_a4tI)
      (@ a_a4tQ)
      (@ b_a4tR)
      (f_a392 :: r_a4tI -> a_a4tQ)
      (k_a393 :: a_a4tQ -> r_a4tI -> b_a4tR)
      (r1_a394 :: r_a4tI) ->
      k_a393 (f_a392 r1_a394) r1_a394

-- RHS size: {terms: 20, types: 29, coercions: 0, joins: 0/0}
GHC.Base.$fMonad(,)_$c>>= [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Monoid a =>
     forall a1 b. (a, a1) -> (a1 -> (a, b)) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U)><C(S),1*C1(U(U,U))>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6KB)
                 (w_s6KC [Occ=Once] :: Monoid a_s6KB)
                 (@ a1_s6KD)
                 (@ b_s6KE)
                 (w1_s6KF [Occ=Once!] :: (a_s6KB, a1_s6KD))
                 (w2_s6KG [Occ=Once!] :: a1_s6KD -> (a_s6KB, b_s6KE)) ->
                 case w1_s6KF of { (ww1_s6KJ [Occ=Once], ww2_s6KK [Occ=Once]) ->
                 case w2_s6KG ww2_s6KK of
                 { (v_a39k [Occ=Once], b1_a39l [Occ=Once]) ->
                 (<> @ a_s6KB (GHC.Base.$p1Monoid @ a_s6KB w_s6KC) ww1_s6KJ v_a39k,
                  b1_a39l)
                 }
                 }}]
GHC.Base.$fMonad(,)_$c>>=
  = \ (@ a_s6KB)
      (w_s6KC :: Monoid a_s6KB)
      (@ a1_s6KD)
      (@ b_s6KE)
      (w1_s6KF :: (a_s6KB, a1_s6KD))
      (w2_s6KG :: a1_s6KD -> (a_s6KB, b_s6KE)) ->
      case w1_s6KF of { (ww1_s6KJ, ww2_s6KK) ->
      case w2_s6KG ww2_s6KK of { (v_a39k, b1_a39l) ->
      (<> @ a_s6KB (GHC.Base.$p1Monoid @ a_s6KB w_s6KC) ww1_s6KJ v_a39k,
       b1_a39l)
      }
      }

-- RHS size: {terms: 20, types: 31, coercions: 0, joins: 0/0}
GHC.Base.$fApplicative(,)_$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Monoid a =>
     forall a1 b. (a, a1 -> b) -> (a, a1) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,1*C1(U))><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6KQ)
                 (w_s6KR [Occ=Once] :: Monoid a_s6KQ)
                 (@ a1_s6KS)
                 (@ b_s6KT)
                 (w1_s6KU [Occ=Once!] :: (a_s6KQ, a1_s6KS -> b_s6KT))
                 (w2_s6KV [Occ=Once!] :: (a_s6KQ, a1_s6KS)) ->
                 case w1_s6KU of { (ww1_s6KY [Occ=Once], ww2_s6KZ [Occ=Once!]) ->
                 case w2_s6KV of { (ww4_s6L3 [Occ=Once], ww5_s6L4 [Occ=Once]) ->
                 (<>
                    @ a_s6KQ (GHC.Base.$p1Monoid @ a_s6KQ w_s6KR) ww1_s6KY ww4_s6L3,
                  ww2_s6KZ ww5_s6L4)
                 }
                 }}]
GHC.Base.$fApplicative(,)_$c<*>
  = \ (@ a_s6KQ)
      (w_s6KR :: Monoid a_s6KQ)
      (@ a1_s6KS)
      (@ b_s6KT)
      (w1_s6KU :: (a_s6KQ, a1_s6KS -> b_s6KT))
      (w2_s6KV :: (a_s6KQ, a1_s6KS)) ->
      case w1_s6KU of { (ww1_s6KY, ww2_s6KZ) ->
      case w2_s6KV of { (ww4_s6L3, ww5_s6L4) ->
      (<>
         @ a_s6KQ (GHC.Base.$p1Monoid @ a_s6KQ w_s6KR) ww1_s6KY ww4_s6L3,
       ww2_s6KZ ww5_s6L4)
      }
      }

-- RHS size: {terms: 19, types: 28, coercions: 0, joins: 0/0}
GHC.Base.$fApplicative(,)_$c*>
  :: forall a. Monoid a => forall a1 b. (a, a1) -> (a, b) -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,A)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4vv)
                 ($dMonoid_a4vw [Occ=Once] :: Monoid a_a4vv)
                 (@ a1_a4w5)
                 (@ b_a4w6)
                 (a2_a37R [Occ=Once!] :: (a_a4vv, a1_a4w5))
                 (a3_a37S [Occ=Once!] :: (a_a4vv, b_a4w6)) ->
                 case a2_a37R of { (x_a38Z [Occ=Once], _ [Occ=Dead]) ->
                 case a3_a37S of { (v_a39q [Occ=Once], x1_a39r [Occ=Once]) ->
                 (<>
                    @ a_a4vv (GHC.Base.$p1Monoid @ a_a4vv $dMonoid_a4vw) x_a38Z v_a39q,
                  x1_a39r)
                 }
                 }}]
GHC.Base.$fApplicative(,)_$c*>
  = \ (@ a_a4vv)
      ($dMonoid_a4vw :: Monoid a_a4vv)
      (@ a1_a4w5)
      (@ b_a4w6)
      (a2_a37R :: (a_a4vv, a1_a4w5))
      (a3_a37S :: (a_a4vv, b_a4w6)) ->
      case a2_a37R of { (x_a38Z, y_a390) ->
      case a3_a37S of { (v_a39q, x1_a39r) ->
      (<>
         @ a_a4vv (GHC.Base.$p1Monoid @ a_a4vv $dMonoid_a4vw) x_a38Z v_a39q,
       x1_a39r)
      }
      }

-- RHS size: {terms: 23, types: 33, coercions: 0, joins: 0/0}
GHC.Base.$fApplicative(,)_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Monoid a =>
     forall a1 b c. (a1 -> b -> c) -> (a, a1) -> (a, b) -> (a, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*C1(C1(U))><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6La)
                 (w_s6Lb [Occ=Once] :: Monoid a_s6La)
                 (@ a1_s6Lc)
                 (@ b_s6Ld)
                 (@ c_s6Le)
                 (w1_s6Lf [Occ=Once!] :: a1_s6Lc -> b_s6Ld -> c_s6Le)
                 (w2_s6Lg [Occ=Once!] :: (a_s6La, a1_s6Lc))
                 (w3_s6Lh [Occ=Once!] :: (a_s6La, b_s6Ld)) ->
                 case w2_s6Lg of { (ww1_s6Lk [Occ=Once], ww2_s6Ll [Occ=Once]) ->
                 case w3_s6Lh of { (ww4_s6Lp [Occ=Once], ww5_s6Lq [Occ=Once]) ->
                 (<>
                    @ a_s6La (GHC.Base.$p1Monoid @ a_s6La w_s6Lb) ww1_s6Lk ww4_s6Lp,
                  w1_s6Lf ww2_s6Ll ww5_s6Lq)
                 }
                 }}]
GHC.Base.$fApplicative(,)_$cliftA2
  = \ (@ a_s6La)
      (w_s6Lb :: Monoid a_s6La)
      (@ a1_s6Lc)
      (@ b_s6Ld)
      (@ c_s6Le)
      (w1_s6Lf :: a1_s6Lc -> b_s6Ld -> c_s6Le)
      (w2_s6Lg :: (a_s6La, a1_s6Lc))
      (w3_s6Lh :: (a_s6La, b_s6Ld)) ->
      case w2_s6Lg of { (ww1_s6Lk, ww2_s6Ll) ->
      case w3_s6Lh of { (ww4_s6Lp, ww5_s6Lq) ->
      (<>
         @ a_s6La (GHC.Base.$p1Monoid @ a_s6La w_s6Lb) ww1_s6Lk ww4_s6Lp,
       w1_s6Lf ww2_s6Ll ww5_s6Lq)
      }
      }

-- RHS size: {terms: 21, types: 30, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,,,)_$cmempty
  :: forall a b c d e.
     (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =>
     (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4x5)
                 (@ b_a4x6)
                 (@ c_a4x7)
                 (@ d_a4x8)
                 (@ e_a4x9)
                 ($dMonoid_a4xa [Occ=Once] :: Monoid a_a4x5)
                 ($dMonoid1_a4xb [Occ=Once] :: Monoid b_a4x6)
                 ($dMonoid2_a4xc [Occ=Once] :: Monoid c_a4x7)
                 ($dMonoid3_a4xd [Occ=Once] :: Monoid d_a4x8)
                 ($dMonoid4_a4xe [Occ=Once] :: Monoid e_a4x9) ->
                 (mempty @ a_a4x5 $dMonoid_a4xa, mempty @ b_a4x6 $dMonoid1_a4xb,
                  mempty @ c_a4x7 $dMonoid2_a4xc, mempty @ d_a4x8 $dMonoid3_a4xd,
                  mempty @ e_a4x9 $dMonoid4_a4xe)}]
GHC.Base.$fMonoid(,,,,)_$cmempty
  = \ (@ a_a4x5)
      (@ b_a4x6)
      (@ c_a4x7)
      (@ d_a4x8)
      (@ e_a4x9)
      ($dMonoid_a4xa :: Monoid a_a4x5)
      ($dMonoid1_a4xb :: Monoid b_a4x6)
      ($dMonoid2_a4xc :: Monoid c_a4x7)
      ($dMonoid3_a4xd :: Monoid d_a4x8)
      ($dMonoid4_a4xe :: Monoid e_a4x9) ->
      (mempty @ a_a4x5 $dMonoid_a4xa, mempty @ b_a4x6 $dMonoid1_a4xb,
       mempty @ c_a4x7 $dMonoid2_a4xc, mempty @ d_a4x8 $dMonoid3_a4xd,
       mempty @ e_a4x9 $dMonoid4_a4xe)

-- RHS size: {terms: 17, types: 24, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,,)_$cmempty
  :: forall a b c d.
     (Monoid a, Monoid b, Monoid c, Monoid d) =>
     (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4xJ)
                 (@ b_a4xK)
                 (@ c_a4xL)
                 (@ d_a4xM)
                 ($dMonoid_a4xN [Occ=Once] :: Monoid a_a4xJ)
                 ($dMonoid1_a4xO [Occ=Once] :: Monoid b_a4xK)
                 ($dMonoid2_a4xP [Occ=Once] :: Monoid c_a4xL)
                 ($dMonoid3_a4xQ [Occ=Once] :: Monoid d_a4xM) ->
                 (mempty @ a_a4xJ $dMonoid_a4xN, mempty @ b_a4xK $dMonoid1_a4xO,
                  mempty @ c_a4xL $dMonoid2_a4xP, mempty @ d_a4xM $dMonoid3_a4xQ)}]
GHC.Base.$fMonoid(,,,)_$cmempty
  = \ (@ a_a4xJ)
      (@ b_a4xK)
      (@ c_a4xL)
      (@ d_a4xM)
      ($dMonoid_a4xN :: Monoid a_a4xJ)
      ($dMonoid1_a4xO :: Monoid b_a4xK)
      ($dMonoid2_a4xP :: Monoid c_a4xL)
      ($dMonoid3_a4xQ :: Monoid d_a4xM) ->
      (mempty @ a_a4xJ $dMonoid_a4xN, mempty @ b_a4xK $dMonoid1_a4xO,
       mempty @ c_a4xL $dMonoid2_a4xP, mempty @ d_a4xM $dMonoid3_a4xQ)

-- RHS size: {terms: 13, types: 18, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,)_$cmempty
  :: forall a b c. (Monoid a, Monoid b, Monoid c) => (a, b, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4yj)
                 (@ b_a4yk)
                 (@ c_a4yl)
                 ($dMonoid_a4ym [Occ=Once] :: Monoid a_a4yj)
                 ($dMonoid1_a4yn [Occ=Once] :: Monoid b_a4yk)
                 ($dMonoid2_a4yo [Occ=Once] :: Monoid c_a4yl) ->
                 (mempty @ a_a4yj $dMonoid_a4ym, mempty @ b_a4yk $dMonoid1_a4yn,
                  mempty @ c_a4yl $dMonoid2_a4yo)}]
GHC.Base.$fMonoid(,,)_$cmempty
  = \ (@ a_a4yj)
      (@ b_a4yk)
      (@ c_a4yl)
      ($dMonoid_a4ym :: Monoid a_a4yj)
      ($dMonoid1_a4yn :: Monoid b_a4yk)
      ($dMonoid2_a4yo :: Monoid c_a4yl) ->
      (mempty @ a_a4yj $dMonoid_a4ym, mempty @ b_a4yk $dMonoid1_a4yn,
       mempty @ c_a4yl $dMonoid2_a4yo)

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,)_$cmempty
  :: forall a b. (Monoid a, Monoid b) => (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U,A,A)><L,1*U(A,1*U,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4yP)
                 (@ b_a4yQ)
                 ($dMonoid_a4yR [Occ=Once] :: Monoid a_a4yP)
                 ($dMonoid1_a4yS [Occ=Once] :: Monoid b_a4yQ) ->
                 (mempty @ a_a4yP $dMonoid_a4yR, mempty @ b_a4yQ $dMonoid1_a4yS)}]
GHC.Base.$fMonoid(,)_$cmempty
  = \ (@ a_a4yP)
      (@ b_a4yQ)
      ($dMonoid_a4yR :: Monoid a_a4yP)
      ($dMonoid1_a4yS :: Monoid b_a4yQ) ->
      (mempty @ a_a4yP $dMonoid_a4yR, mempty @ b_a4yQ $dMonoid1_a4yS)

-- RHS size: {terms: 46, types: 63, coercions: 0, joins: 0/6}
GHC.Base.$fMonoid(,)_$cmconcat
  :: forall a b. (Monoid a, Monoid b) => [(a, b)] -> (a, b)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 60 0] 330 0}]
GHC.Base.$fMonoid(,)_$cmconcat
  = \ (@ a_a4yP)
      (@ b_a4yQ)
      ($dMonoid_a4yR :: Monoid a_a4yP)
      ($dMonoid1_a4yS :: Monoid b_a4yQ)
      (eta_XaQ :: [(a_a4yP, b_a4yQ)]) ->
      let {
        $dSemigroup_a4E8 [Dmd=<L,U(C(C1(U)),A,A)>] :: Semigroup a_a4yP
        [LclId]
        $dSemigroup_a4E8 = GHC.Base.$p1Monoid @ a_a4yP $dMonoid_a4yR } in
      let {
        $dSemigroup1_a4E9 [Dmd=<L,U(C(C1(U)),A,A)>] :: Semigroup b_a4yQ
        [LclId]
        $dSemigroup1_a4E9 = GHC.Base.$p1Monoid @ b_a4yQ $dMonoid1_a4yS } in
      let {
        z_s687 :: a_a4yP
        [LclId]
        z_s687 = mempty @ a_a4yP $dMonoid_a4yR } in
      let {
        z1_s688 :: b_a4yQ
        [LclId]
        z1_s688 = mempty @ b_a4yQ $dMonoid1_a4yS } in
      let {
        z2_a3ev [Dmd=<S,U(U,U)>] :: (a_a4yP, b_a4yQ)
        [LclId, Unf=OtherCon []]
        z2_a3ev = (z_s687, z1_s688) } in
      letrec {
        go_X4dS [Occ=LoopBreaker] :: [(a_a4yP, b_a4yQ)] -> (a_a4yP, b_a4yQ)
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_X4dS
          = \ (ds_d51B :: [(a_a4yP, b_a4yQ)]) ->
              case ds_d51B of {
                [] -> z2_a3ev;
                : y_a3ex ys_a3ey ->
                  case y_a3ex of { (a1_a3aJ, b1_a3aK) ->
                  case go_X4dS ys_a3ey of { (a'_a3aL, b'_a3aM) ->
                  (<> @ a_a4yP $dSemigroup_a4E8 a1_a3aJ a'_a3aL,
                   <> @ b_a4yQ $dSemigroup1_a4E9 b1_a3aK b'_a3aM)
                  }
                  }
              }; } in
      go_X4dS eta_XaQ

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid()_$cmconcat :: [()] -> ()
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Tuple.()}]
GHC.Base.$fMonoid()_$cmconcat = \ _ [Occ=Dead] -> GHC.Tuple.()

-- RHS size: {terms: 19, types: 16, coercions: 0, joins: 0/0}
GHC.Base.$fMonoidMaybe_$c<>
  :: forall a. Semigroup a => Maybe a -> Maybe a -> Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4AP)
                 ($dSemigroup_a4AQ [Occ=Once] :: Semigroup a_a4AP)
                 (ds_d57U [Occ=Once!] :: Maybe a_a4AP)
                 (b_a39z [Occ=Once*] :: Maybe a_a4AP) ->
                 case ds_d57U of wild_X65 {
                   Nothing -> b_a39z;
                   Just ipv_s5cN [Occ=Once] ->
                     case b_a39z of {
                       Nothing -> wild_X65;
                       Just ipv1_s5cQ [Occ=Once] ->
                         GHC.Base.Just
                           @ a_a4AP (<> @ a_a4AP $dSemigroup_a4AQ ipv_s5cN ipv1_s5cQ)
                     }
                 }}]
GHC.Base.$fMonoidMaybe_$c<>
  = \ (@ a_a4AP)
      ($dSemigroup_a4AQ :: Semigroup a_a4AP)
      (ds_d57U :: Maybe a_a4AP)
      (b_a39z :: Maybe a_a4AP) ->
      case ds_d57U of wild_X65 {
        Nothing -> b_a39z;
        Just ipv_s5cN ->
          case b_a39z of {
            Nothing -> wild_X65;
            Just ipv1_s5cQ ->
              GHC.Base.Just
                @ a_a4AP (<> @ a_a4AP $dSemigroup_a4AQ ipv_s5cN ipv1_s5cQ)
          }
      }

-- RHS size: {terms: 34, types: 37, coercions: 0, joins: 0/1}
GHC.Base.$w$csconcat5 [InlPrag=NOUSERINLINE[0]]
  :: forall a. Semigroup a => Maybe a -> [Maybe a] -> Maybe a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0 0] 230 0}]
GHC.Base.$w$csconcat5
  = \ (@ a_s6LE)
      (w_s6LF :: Semigroup a_s6LE)
      (ww_s6LJ :: Maybe a_s6LE)
      (ww1_s6LK :: [Maybe a_s6LE]) ->
      letrec {
        go_s5uM [Occ=LoopBreaker]
          :: Maybe a_s6LE -> [Maybe a_s6LE] -> Maybe a_s6LE
        [LclId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []]
        go_s5uM
          = \ (b_a384 :: Maybe a_s6LE) (ds_d548 :: [Maybe a_s6LE]) ->
              case ds_d548 of {
                [] -> b_a384;
                : c_a385 cs_a386 ->
                  case b_a384 of wild1_X65 {
                    Nothing -> go_s5uM c_a385 cs_a386;
                    Just ipv_s5cN ->
                      case go_s5uM c_a385 cs_a386 of {
                        Nothing -> wild1_X65;
                        Just ipv1_s5cQ ->
                          GHC.Base.Just @ a_s6LE (<> @ a_s6LE w_s6LF ipv_s5cN ipv1_s5cQ)
                      }
                  }
              }; } in
      go_s5uM ww_s6LJ ww1_s6LK

-- RHS size: {terms: 10, types: 16, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroupMaybe_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a. Semigroup a => NonEmpty (Maybe a) -> Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6LE)
                 (w_s6LF [Occ=Once] :: Semigroup a_s6LE)
                 (w1_s6LG [Occ=Once!] :: NonEmpty (Maybe a_s6LE)) ->
                 case w1_s6LG of { :| ww1_s6LJ [Occ=Once] ww2_s6LK [Occ=Once] ->
                 GHC.Base.$w$csconcat5 @ a_s6LE w_s6LF ww1_s6LJ ww2_s6LK
                 }}]
GHC.Base.$fSemigroupMaybe_$csconcat
  = \ (@ a_s6LE)
      (w_s6LF :: Semigroup a_s6LE)
      (w1_s6LG :: NonEmpty (Maybe a_s6LE)) ->
      case w1_s6LG of { :| ww1_s6LJ ww2_s6LK ->
      GHC.Base.$w$csconcat5 @ a_s6LE w_s6LF ww1_s6LJ ww2_s6LK
      }

-- RHS size: {terms: 12, types: 14, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroupMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup a => Semigroup (Maybe a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U)>m,
 Unf=DFun: \ (@ a_a39y) (v_XaR :: Semigroup a_a39y) ->
       GHC.Base.C:Semigroup TYPE: Maybe a_a39y
                            GHC.Base.$fMonoidMaybe_$c<> @ a_a39y v_XaR
                            GHC.Base.$fSemigroupMaybe_$csconcat @ a_a39y v_XaR
                            \ (@ b_a4B6) ($dIntegral_a4B8 [Occ=Once] :: Integral b_a4B6) ->
                              stimesMaybe @ b_a4B6 @ a_a39y $dIntegral_a4B8 v_XaR]
GHC.Base.$fSemigroupMaybe
  = \ (@ a_a4AP) ($dSemigroup_a4AQ :: Semigroup a_a4AP) ->
      GHC.Base.C:Semigroup
        @ (Maybe a_a4AP)
        (GHC.Base.$fMonoidMaybe_$c<> @ a_a4AP $dSemigroup_a4AQ)
        (GHC.Base.$fSemigroupMaybe_$csconcat @ a_a4AP $dSemigroup_a4AQ)
        (\ (@ b_a4B6) ($dIntegral_a4B8 :: Integral b_a4B6) ->
           stimesMaybe @ b_a4B6 @ a_a4AP $dIntegral_a4B8 $dSemigroup_a4AQ)

-- RHS size: {terms: 29, types: 32, coercions: 0, joins: 0/1}
GHC.Base.$fMonoidMaybe_$cmconcat
  :: forall a. Semigroup a => [Maybe a] -> Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 0] 190 0}]
GHC.Base.$fMonoidMaybe_$cmconcat
  = \ (@ a_a4wo)
      ($dSemigroup_a4wp :: Semigroup a_a4wo)
      (eta_XaT :: [Maybe a_a4wo]) ->
      letrec {
        go_X4dL [Occ=LoopBreaker] :: [Maybe a_a4wo] -> Maybe a_a4wo
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_X4dL
          = \ (ds_d51B :: [Maybe a_a4wo]) ->
              case ds_d51B of {
                [] -> GHC.Base.Nothing @ a_a4wo;
                : y_a3ex ys_a3ey ->
                  case y_a3ex of wild1_X65 {
                    Nothing -> go_X4dL ys_a3ey;
                    Just ipv_s5cN ->
                      case go_X4dL ys_a3ey of {
                        Nothing -> wild1_X65;
                        Just ipv1_s5cQ ->
                          GHC.Base.Just
                            @ a_a4wo (<> @ a_a4wo $dSemigroup_a4wp ipv_s5cN ipv1_s5cQ)
                      }
                  }
              }; } in
      go_X4dL eta_XaT

-- RHS size: {terms: 10, types: 10, coercions: 0, joins: 0/0}
GHC.Base.$fMonoidMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup a => Monoid (Maybe a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U,U,U)>m,
 Unf=DFun: \ (@ a_a39x) (v_XaT :: Semigroup a_a39x) ->
       GHC.Base.C:Monoid TYPE: Maybe a_a39x
                         GHC.Base.$fSemigroupMaybe @ a_a39x v_XaT
                         GHC.Base.Nothing @ a_a39x
                         GHC.Base.$fMonoidMaybe_$c<> @ a_a39x v_XaT
                         GHC.Base.$fMonoidMaybe_$cmconcat @ a_a39x v_XaT]
GHC.Base.$fMonoidMaybe
  = \ (@ a_a4wo) ($dSemigroup_a4wp :: Semigroup a_a4wo) ->
      GHC.Base.C:Monoid
        @ (Maybe a_a4wo)
        (GHC.Base.$fSemigroupMaybe @ a_a4wo $dSemigroup_a4wp)
        (GHC.Base.Nothing @ a_a4wo)
        (GHC.Base.$fMonoidMaybe_$c<> @ a_a4wo $dSemigroup_a4wp)
        (GHC.Base.$fMonoidMaybe_$cmconcat @ a_a4wo $dSemigroup_a4wp)

-- RHS size: {terms: 10, types: 3, coercions: 0, joins: 0/0}
GHC.Base.$fMonoidOrdering_$c<> :: Ordering -> Ordering -> Ordering
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_d589 [Occ=Once!] :: Ordering)
                 (ds1_d58a [Occ=Once] :: Ordering) ->
                 case ds_d589 of {
                   LT -> GHC.Types.LT;
                   EQ -> ds1_d58a;
                   GT -> GHC.Types.GT
                 }}]
GHC.Base.$fMonoidOrdering_$c<>
  = \ (ds_d589 :: Ordering) (ds1_d58a :: Ordering) ->
      case ds_d589 of {
        LT -> GHC.Types.LT;
        EQ -> ds1_d58a;
        GT -> GHC.Types.GT
      }

Rec {
-- RHS size: {terms: 15, types: 8, coercions: 0, joins: 0/0}
GHC.Base.$fMonoidOrdering_go [Occ=LoopBreaker]
  :: [Ordering] -> Ordering
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []]
GHC.Base.$fMonoidOrdering_go
  = \ (ds_d51B :: [Ordering]) ->
      case ds_d51B of {
        [] -> GHC.Types.EQ;
        : y_a3ex ys_a3ey ->
          case y_a3ex of {
            LT -> GHC.Types.LT;
            EQ -> GHC.Base.$fMonoidOrdering_go ys_a3ey;
            GT -> GHC.Types.GT
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroupOrdering [InlPrag=NOUSERINLINE CONLIKE]
  :: Semigroup Ordering
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Semigroup TYPE: Ordering
                            GHC.Base.$fMonoidOrdering_$c<>
                            GHC.Base.$fSemigroupOrdering_$csconcat
                            GHC.Base.$fSemigroupOrdering_$cstimes]
GHC.Base.$fSemigroupOrdering
  = GHC.Base.C:Semigroup
      @ Ordering
      GHC.Base.$fMonoidOrdering_$c<>
      GHC.Base.$fSemigroupOrdering_$csconcat
      GHC.Base.$fSemigroupOrdering_$cstimes

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fMonoidOrdering [InlPrag=NOUSERINLINE CONLIKE]
  :: Monoid Ordering
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monoid TYPE: Ordering
                         GHC.Base.$fSemigroupOrdering
                         GHC.Types.EQ
                         GHC.Base.$fMonoidOrdering_$c<>
                         GHC.Base.$fMonoidOrdering_go]
GHC.Base.$fMonoidOrdering
  = GHC.Base.C:Monoid
      @ Ordering
      GHC.Base.$fSemigroupOrdering
      GHC.Types.EQ
      GHC.Base.$fMonoidOrdering_$c<>
      GHC.Base.$fMonoidOrdering_go

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroupOrdering_$cstimes [Occ=LoopBreaker]
  :: forall b. Integral b => b -> Ordering -> Ordering
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []]
GHC.Base.$fSemigroupOrdering_$cstimes
  = \ (@ b_a4Bu) ($dIntegral_a4Bw :: Integral b_a4Bu) ->
      stimesIdempotentMonoid
        @ b_a4Bu @ Ordering $dIntegral_a4Bw GHC.Base.$fMonoidOrdering
end Rec }

-- RHS size: {terms: 39, types: 64, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,,,)_$c<>
  :: forall a b c d e.
     (Semigroup a, Semigroup b, Semigroup c, Semigroup d,
      Semigroup e) =>
     (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U,U,U)><S,1*U(U,U,U,U,U)>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 20 20] 230 60}]
GHC.Base.$fMonoid(,,,,)_$c<>
  = \ (@ a_a4BG)
      (@ b_a4BH)
      (@ c_a4BI)
      (@ d_a4BJ)
      (@ e_a4BK)
      ($dSemigroup_a4BL :: Semigroup a_a4BG)
      ($dSemigroup1_a4BM :: Semigroup b_a4BH)
      ($dSemigroup2_a4BN :: Semigroup c_a4BI)
      ($dSemigroup3_a4BO :: Semigroup d_a4BJ)
      ($dSemigroup4_a4BP :: Semigroup e_a4BK)
      (ds_d58i :: (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK))
      (ds1_d58j :: (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)) ->
      case ds_d58i of { (a1_a39O, b1_a39P, c1_a39Q, d1_a39R, e1_a39S) ->
      case ds1_d58j of { (a'_a39T, b'_a39U, c'_a39V, d'_a39W, e'_a39X) ->
      (<> @ a_a4BG $dSemigroup_a4BL a1_a39O a'_a39T,
       <> @ b_a4BH $dSemigroup1_a4BM b1_a39P b'_a39U,
       <> @ c_a4BI $dSemigroup2_a4BN c1_a39Q c'_a39V,
       <> @ d_a4BJ $dSemigroup3_a4BO d1_a39R d'_a39W,
       <> @ e_a4BK $dSemigroup4_a4BP e1_a39S e'_a39X)
      }
      }

-- RHS size: {terms: 82, types: 186, coercions: 0, joins: 0/1}
GHC.Base.$fMonoid(,,,,)_$csconcat
  :: forall a b c d e.
     (Semigroup a, Semigroup b, Semigroup c, Semigroup d,
      Semigroup e) =>
     NonEmpty (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U,U,U),1*U)>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 20] 490 60}]
GHC.Base.$fMonoid(,,,,)_$csconcat
  = \ (@ a_a4BG)
      (@ b_a4BH)
      (@ c_a4BI)
      (@ d_a4BJ)
      (@ e_a4BK)
      ($dSemigroup_a4BL :: Semigroup a_a4BG)
      ($dSemigroup1_a4BM :: Semigroup b_a4BH)
      ($dSemigroup2_a4BN :: Semigroup c_a4BI)
      ($dSemigroup3_a4BO :: Semigroup d_a4BJ)
      ($dSemigroup4_a4BP :: Semigroup e_a4BK)
      (ds_X5g2 :: NonEmpty (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)) ->
      case ds_X5g2 of { :| a1_a381 as_a382 ->
      case a1_a381 of
      { (ww1_s6Mt, ww2_s6Mu, ww3_s6Mv, ww4_s6Mw, ww5_s6Mx) ->
      letrec {
        $wgo_s6MC [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
          :: a_a4BG
             -> b_a4BH
             -> c_a4BI
             -> d_a4BJ
             -> e_a4BK
             -> [(a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)]
             -> (# a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK #)
        [LclId,
         Arity=6,
         Str=<L,U><L,U><L,U><L,U><L,U><S,1*U>,
         Unf=OtherCon []]
        $wgo_s6MC
          = \ (ww6_X6Ye :: a_a4BG)
              (ww7_X6Yg :: b_a4BH)
              (ww8_X6Yi :: c_a4BI)
              (ww9_X6Yk :: d_a4BJ)
              (ww10_X6Ym :: e_a4BK)
              (w_s6Mq :: [(a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)]) ->
              case w_s6Mq of {
                [] -> (# ww6_X6Ye, ww7_X6Yg, ww8_X6Yi, ww9_X6Yk, ww10_X6Ym #);
                : c1_a385 cs_a386 ->
                  case c1_a385 of
                  { (ww12_X6YK, ww13_X6YM, ww14_X6YO, ww15_X6YQ, ww16_X6YS) ->
                  case $wgo_s6MC
                         ww12_X6YK ww13_X6YM ww14_X6YO ww15_X6YQ ww16_X6YS cs_a386
                  of
                  { (# ww18_s6S3, ww19_s6S4, ww20_s6S5, ww21_s6S6, ww22_s6S7 #) ->
                  (# <> @ a_a4BG $dSemigroup_a4BL ww6_X6Ye ww18_s6S3,
                     <> @ b_a4BH $dSemigroup1_a4BM ww7_X6Yg ww19_s6S4,
                     <> @ c_a4BI $dSemigroup2_a4BN ww8_X6Yi ww20_s6S5,
                     <> @ d_a4BJ $dSemigroup3_a4BO ww9_X6Yk ww21_s6S6,
                     <> @ e_a4BK $dSemigroup4_a4BP ww10_X6Ym ww22_s6S7 #)
                  }
                  }
              }; } in
      case $wgo_s6MC ww1_s6Mt ww2_s6Mu ww3_s6Mv ww4_s6Mw ww5_s6Mx as_a382
      of
      { (# ww7_s6S3, ww8_s6S4, ww9_s6S5, ww10_s6S6, ww11_s6S7 #) ->
      (ww7_s6S3, ww8_s6S4, ww9_s6S5, ww10_s6S6, ww11_s6S7)
      }
      }
      }

-- RHS size: {terms: 43, types: 57, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,,,)_$cstimes
  :: forall a b c d e.
     (Semigroup a, Semigroup b, Semigroup c, Semigroup d,
      Semigroup e) =>
     forall b1. Integral b1 => b1 -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U,U,U)>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30 0 0 20] 270 60}]
GHC.Base.$fMonoid(,,,,)_$cstimes
  = \ (@ a_a4BG)
      (@ b_a4BH)
      (@ c_a4BI)
      (@ d_a4BJ)
      (@ e_a4BK)
      ($dSemigroup_a4BL :: Semigroup a_a4BG)
      ($dSemigroup1_a4BM :: Semigroup b_a4BH)
      ($dSemigroup2_a4BN :: Semigroup c_a4BI)
      ($dSemigroup3_a4BO :: Semigroup d_a4BJ)
      ($dSemigroup4_a4BP :: Semigroup e_a4BK)
      (@ b1_a4Cc)
      ($dIntegral_a4Ce :: Integral b1_a4Cc)
      (n_a39Y :: b1_a4Cc)
      (ds_d58x :: (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)) ->
      case ds_d58x of { (a1_a39Z, b2_a3a0, c1_a3a1, d1_a3a2, e1_a3a3) ->
      (stimes
         @ a_a4BG $dSemigroup_a4BL @ b1_a4Cc $dIntegral_a4Ce n_a39Y a1_a39Z,
       stimes
         @ b_a4BH
         $dSemigroup1_a4BM
         @ b1_a4Cc
         $dIntegral_a4Ce
         n_a39Y
         b2_a3a0,
       stimes
         @ c_a4BI
         $dSemigroup2_a4BN
         @ b1_a4Cc
         $dIntegral_a4Ce
         n_a39Y
         c1_a3a1,
       stimes
         @ d_a4BJ
         $dSemigroup3_a4BO
         @ b1_a4Cc
         $dIntegral_a4Ce
         n_a39Y
         d1_a3a2,
       stimes
         @ e_a4BK
         $dSemigroup4_a4BP
         @ b1_a4Cc
         $dIntegral_a4Ce
         n_a39Y
         e1_a3a3)
      }

-- RHS size: {terms: 29, types: 41, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e.
     (Semigroup a, Semigroup b, Semigroup c, Semigroup d,
      Semigroup e) =>
     Semigroup (a, b, c, d, e)
[GblId[DFunId],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m,
 Unf=DFun: \ (@ a_a39J)
             (@ b_a39K)
             (@ c_a39L)
             (@ d_a39M)
             (@ e_a39N)
             (v_Xb6 :: Semigroup a_a39J)
             (v1_XbZ :: Semigroup b_a39K)
             (v2_Xc1 :: Semigroup c_a39L)
             (v3_B4 :: Semigroup d_a39M)
             (v4_B5 :: Semigroup e_a39N) ->
       GHC.Base.C:Semigroup TYPE: (a_a39J, b_a39K, c_a39L, d_a39M, e_a39N)
                            GHC.Base.$fMonoid(,,,,)_$c<>
                              @ a_a39J
                              @ b_a39K
                              @ c_a39L
                              @ d_a39M
                              @ e_a39N
                              v_Xb6
                              v1_XbZ
                              v2_Xc1
                              v3_B4
                              v4_B5
                            GHC.Base.$fMonoid(,,,,)_$csconcat
                              @ a_a39J
                              @ b_a39K
                              @ c_a39L
                              @ d_a39M
                              @ e_a39N
                              v_Xb6
                              v1_XbZ
                              v2_Xc1
                              v3_B4
                              v4_B5
                            GHC.Base.$fMonoid(,,,,)_$cstimes
                              @ a_a39J
                              @ b_a39K
                              @ c_a39L
                              @ d_a39M
                              @ e_a39N
                              v_Xb6
                              v1_XbZ
                              v2_Xc1
                              v3_B4
                              v4_B5]
GHC.Base.$fSemigroup(,,,,)
  = \ (@ a_a4BG)
      (@ b_a4BH)
      (@ c_a4BI)
      (@ d_a4BJ)
      (@ e_a4BK)
      ($dSemigroup_a4BL :: Semigroup a_a4BG)
      ($dSemigroup1_a4BM :: Semigroup b_a4BH)
      ($dSemigroup2_a4BN :: Semigroup c_a4BI)
      ($dSemigroup3_a4BO :: Semigroup d_a4BJ)
      ($dSemigroup4_a4BP :: Semigroup e_a4BK) ->
      GHC.Base.C:Semigroup
        @ (a_a4BG, b_a4BH, c_a4BI, d_a4BJ, e_a4BK)
        (GHC.Base.$fMonoid(,,,,)_$c<>
           @ a_a4BG
           @ b_a4BH
           @ c_a4BI
           @ d_a4BJ
           @ e_a4BK
           $dSemigroup_a4BL
           $dSemigroup1_a4BM
           $dSemigroup2_a4BN
           $dSemigroup3_a4BO
           $dSemigroup4_a4BP)
        (GHC.Base.$fMonoid(,,,,)_$csconcat
           @ a_a4BG
           @ b_a4BH
           @ c_a4BI
           @ d_a4BJ
           @ e_a4BK
           $dSemigroup_a4BL
           $dSemigroup1_a4BM
           $dSemigroup2_a4BN
           $dSemigroup3_a4BO
           $dSemigroup4_a4BP)
        (GHC.Base.$fMonoid(,,,,)_$cstimes
           @ a_a4BG
           @ b_a4BH
           @ c_a4BI
           @ d_a4BJ
           @ e_a4BK
           $dSemigroup_a4BL
           $dSemigroup1_a4BM
           $dSemigroup2_a4BN
           $dSemigroup3_a4BO
           $dSemigroup4_a4BP)

-- RHS size: {terms: 44, types: 101, coercions: 0, joins: 0/0}
GHC.Base.$w$cp1Monoid1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e.
     (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =>
     (# (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e),
        NonEmpty (a, b, c, d, e) -> (a, b, c, d, e),
        forall b1.
        Integral b1 =>
        b1 -> (a, b, c, d, e) -> (a, b, c, d, e) #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [90 90 90 90 90] 480 40}]
GHC.Base.$w$cp1Monoid1
  = \ (@ a_s6Nt)
      (@ b_s6Nu)
      (@ c_s6Nv)
      (@ d_s6Nw)
      (@ e_s6Nx)
      (w_s6Ny :: Monoid a_s6Nt)
      (w1_s6Nz :: Monoid b_s6Nu)
      (w2_s6NA :: Monoid c_s6Nv)
      (w3_s6NB :: Monoid d_s6Nw)
      (w4_s6NC :: Monoid e_s6Nx) ->
      (# GHC.Base.$fMonoid(,,,,)_$c<>
           @ a_s6Nt
           @ b_s6Nu
           @ c_s6Nv
           @ d_s6Nw
           @ e_s6Nx
           (GHC.Base.$p1Monoid @ a_s6Nt w_s6Ny)
           (GHC.Base.$p1Monoid @ b_s6Nu w1_s6Nz)
           (GHC.Base.$p1Monoid @ c_s6Nv w2_s6NA)
           (GHC.Base.$p1Monoid @ d_s6Nw w3_s6NB)
           (GHC.Base.$p1Monoid @ e_s6Nx w4_s6NC),
         GHC.Base.$fMonoid(,,,,)_$csconcat
           @ a_s6Nt
           @ b_s6Nu
           @ c_s6Nv
           @ d_s6Nw
           @ e_s6Nx
           (GHC.Base.$p1Monoid @ a_s6Nt w_s6Ny)
           (GHC.Base.$p1Monoid @ b_s6Nu w1_s6Nz)
           (GHC.Base.$p1Monoid @ c_s6Nv w2_s6NA)
           (GHC.Base.$p1Monoid @ d_s6Nw w3_s6NB)
           (GHC.Base.$p1Monoid @ e_s6Nx w4_s6NC),
         GHC.Base.$fMonoid(,,,,)_$cstimes
           @ a_s6Nt
           @ b_s6Nu
           @ c_s6Nv
           @ d_s6Nw
           @ e_s6Nx
           (GHC.Base.$p1Monoid @ a_s6Nt w_s6Ny)
           (GHC.Base.$p1Monoid @ b_s6Nu w1_s6Nz)
           (GHC.Base.$p1Monoid @ c_s6Nv w2_s6NA)
           (GHC.Base.$p1Monoid @ d_s6Nw w3_s6NB)
           (GHC.Base.$p1Monoid @ e_s6Nx w4_s6NC) #)

-- RHS size: {terms: 22, types: 131, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,,,)_$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d e.
     (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =>
     Semigroup (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6Nt)
                 (@ b_s6Nu)
                 (@ c_s6Nv)
                 (@ d_s6Nw)
                 (@ e_s6Nx)
                 (w_s6Ny [Occ=Once] :: Monoid a_s6Nt)
                 (w1_s6Nz [Occ=Once] :: Monoid b_s6Nu)
                 (w2_s6NA [Occ=Once] :: Monoid c_s6Nv)
                 (w3_s6NB [Occ=Once] :: Monoid d_s6Nw)
                 (w4_s6NC [Occ=Once] :: Monoid e_s6Nx) ->
                 case GHC.Base.$w$cp1Monoid1
                        @ a_s6Nt
                        @ b_s6Nu
                        @ c_s6Nv
                        @ d_s6Nw
                        @ e_s6Nx
                        w_s6Ny
                        w1_s6Nz
                        w2_s6NA
                        w3_s6NB
                        w4_s6NC
                 of
                 { (# ww1_s6S9 [Occ=Once], ww2_s6Sa [Occ=Once],
                      ww3_s6Sb [Occ=Once] #) ->
                 GHC.Base.C:Semigroup
                   @ (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
                   ww1_s6S9
                   ww2_s6Sa
                   ww3_s6Sb
                 }}]
GHC.Base.$fMonoid(,,,,)_$cp1Monoid
  = \ (@ a_s6Nt)
      (@ b_s6Nu)
      (@ c_s6Nv)
      (@ d_s6Nw)
      (@ e_s6Nx)
      (w_s6Ny :: Monoid a_s6Nt)
      (w1_s6Nz :: Monoid b_s6Nu)
      (w2_s6NA :: Monoid c_s6Nv)
      (w3_s6NB :: Monoid d_s6Nw)
      (w4_s6NC :: Monoid e_s6Nx) ->
      case GHC.Base.$w$cp1Monoid1
             @ a_s6Nt
             @ b_s6Nu
             @ c_s6Nv
             @ d_s6Nw
             @ e_s6Nx
             w_s6Ny
             w1_s6Nz
             w2_s6NA
             w3_s6NB
             w4_s6NC
      of
      { (# ww1_s6S9, ww2_s6Sa, ww3_s6Sb #) ->
      GHC.Base.C:Semigroup
        @ (a_s6Nt, b_s6Nu, c_s6Nv, d_s6Nw, e_s6Nx)
        ww1_s6S9
        ww2_s6Sa
        ww3_s6Sb
      }

-- RHS size: {terms: 19, types: 125, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c d e.
     (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =>
     (a, b, c, d, e) -> (a, b, c, d, e) -> (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4x5)
                 (@ b_a4x6)
                 (@ c_a4x7)
                 (@ d_a4x8)
                 (@ e_a4x9)
                 ($dMonoid_a4xa [Occ=Once] :: Monoid a_a4x5)
                 ($dMonoid1_a4xb [Occ=Once] :: Monoid b_a4x6)
                 ($dMonoid2_a4xc [Occ=Once] :: Monoid c_a4x7)
                 ($dMonoid3_a4xd [Occ=Once] :: Monoid d_a4x8)
                 ($dMonoid4_a4xe [Occ=Once] :: Monoid e_a4x9) ->
                 <>
                   @ (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
                   (GHC.Base.$fMonoid(,,,,)_$cp1Monoid
                      @ a_a4x5
                      @ b_a4x6
                      @ c_a4x7
                      @ d_a4x8
                      @ e_a4x9
                      $dMonoid_a4xa
                      $dMonoid1_a4xb
                      $dMonoid2_a4xc
                      $dMonoid3_a4xd
                      $dMonoid4_a4xe)}]
GHC.Base.$fMonoid(,,,,)_$cmappend
  = \ (@ a_a4x5)
      (@ b_a4x6)
      (@ c_a4x7)
      (@ d_a4x8)
      (@ e_a4x9)
      ($dMonoid_a4xa :: Monoid a_a4x5)
      ($dMonoid1_a4xb :: Monoid b_a4x6)
      ($dMonoid2_a4xc :: Monoid c_a4x7)
      ($dMonoid3_a4xd :: Monoid d_a4x8)
      ($dMonoid4_a4xe :: Monoid e_a4x9) ->
      case GHC.Base.$w$cp1Monoid1
             @ a_a4x5
             @ b_a4x6
             @ c_a4x7
             @ d_a4x8
             @ e_a4x9
             $dMonoid_a4xa
             $dMonoid1_a4xb
             $dMonoid2_a4xc
             $dMonoid3_a4xd
             $dMonoid4_a4xe
      of
      { (# ww1_s6S9, ww2_s6Sa, ww3_s6Sb #) ->
      ww1_s6S9
      }

-- RHS size: {terms: 60, types: 223, coercions: 0, joins: 0/9}
GHC.Base.$fMonoid(,,,,)_$cmconcat
  :: forall a b c d e.
     (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =>
     [(a, b, c, d, e)] -> (a, b, c, d, e)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 30] 380 60}]
GHC.Base.$fMonoid(,,,,)_$cmconcat
  = \ (@ a_a4x5)
      (@ b_a4x6)
      (@ c_a4x7)
      (@ d_a4x8)
      (@ e_a4x9)
      ($dMonoid_a4xa :: Monoid a_a4x5)
      ($dMonoid1_a4xb :: Monoid b_a4x6)
      ($dMonoid2_a4xc :: Monoid c_a4x7)
      ($dMonoid3_a4xd :: Monoid d_a4x8)
      ($dMonoid4_a4xe :: Monoid e_a4x9) ->
      let {
        k_s68r [Dmd=<L,1*U(1*C(C1(U(U,U,U,U,U))),A,A)>]
          :: Semigroup (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
        [LclId]
        k_s68r
          = case GHC.Base.$w$cp1Monoid1
                   @ a_a4x5
                   @ b_a4x6
                   @ c_a4x7
                   @ d_a4x8
                   @ e_a4x9
                   $dMonoid_a4xa
                   $dMonoid1_a4xb
                   $dMonoid2_a4xc
                   $dMonoid3_a4xd
                   $dMonoid4_a4xe
            of
            { (# ww1_s6S9, ww2_s6Sa, ww3_s6Sb #) ->
            GHC.Base.C:Semigroup
              @ (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
              ww1_s6S9
              ww2_s6Sa
              ww3_s6Sb
            } } in
      let {
        k1_X3pH [Dmd=<L,C(C1(U(U,U,U,U,U)))>]
          :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
             -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
             -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
        [LclId]
        k1_X3pH = <> @ (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9) k_s68r } in
      let {
        z_s68s :: a_a4x5
        [LclId]
        z_s68s = mempty @ a_a4x5 $dMonoid_a4xa } in
      let {
        z1_s68t :: b_a4x6
        [LclId]
        z1_s68t = mempty @ b_a4x6 $dMonoid1_a4xb } in
      let {
        z2_s68u :: c_a4x7
        [LclId]
        z2_s68u = mempty @ c_a4x7 $dMonoid2_a4xc } in
      let {
        z3_s68v :: d_a4x8
        [LclId]
        z3_s68v = mempty @ d_a4x8 $dMonoid3_a4xd } in
      let {
        z4_s68w :: e_a4x9
        [LclId]
        z4_s68w = mempty @ e_a4x9 $dMonoid4_a4xe } in
      let {
        z5_X3pL [Dmd=<L,U(U,U,U,U,U)>]
          :: (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
        [LclId, Unf=OtherCon []]
        z5_X3pL = (z_s68s, z1_s68t, z2_s68u, z3_s68v, z4_s68w) } in
      letrec {
        go_X4ef [Occ=LoopBreaker]
          :: [(a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)]
             -> (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_X4ef
          = \ (ds_d51B :: [(a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)]) ->
              case ds_d51B of {
                [] -> z5_X3pL;
                : y_a3ex ys_a3ey -> k1_X3pH y_a3ex (go_X4ef ys_a3ey)
              }; } in
      go_X4ef

-- RHS size: {terms: 35, types: 46, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d e.
     (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =>
     Monoid (a, b, c, d, e)
[GblId[DFunId],
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m,
 Unf=DFun: \ (@ a_a39E)
             (@ b_a39F)
             (@ c_a39G)
             (@ d_a39H)
             (@ e_a39I)
             (v_Xba :: Monoid a_a39E)
             (v1_Xc3 :: Monoid b_a39F)
             (v2_Xc5 :: Monoid c_a39G)
             (v3_B4 :: Monoid d_a39H)
             (v4_B5 :: Monoid e_a39I) ->
       GHC.Base.C:Monoid TYPE: (a_a39E, b_a39F, c_a39G, d_a39H, e_a39I)
                         GHC.Base.$fMonoid(,,,,)_$cp1Monoid
                           @ a_a39E
                           @ b_a39F
                           @ c_a39G
                           @ d_a39H
                           @ e_a39I
                           v_Xba
                           v1_Xc3
                           v2_Xc5
                           v3_B4
                           v4_B5
                         GHC.Base.$fMonoid(,,,,)_$cmempty
                           @ a_a39E
                           @ b_a39F
                           @ c_a39G
                           @ d_a39H
                           @ e_a39I
                           v_Xba
                           v1_Xc3
                           v2_Xc5
                           v3_B4
                           v4_B5
                         GHC.Base.$fMonoid(,,,,)_$cmappend
                           @ a_a39E
                           @ b_a39F
                           @ c_a39G
                           @ d_a39H
                           @ e_a39I
                           v_Xba
                           v1_Xc3
                           v2_Xc5
                           v3_B4
                           v4_B5
                         GHC.Base.$fMonoid(,,,,)_$cmconcat
                           @ a_a39E
                           @ b_a39F
                           @ c_a39G
                           @ d_a39H
                           @ e_a39I
                           v_Xba
                           v1_Xc3
                           v2_Xc5
                           v3_B4
                           v4_B5]
GHC.Base.$fMonoid(,,,,)
  = \ (@ a_a4x5)
      (@ b_a4x6)
      (@ c_a4x7)
      (@ d_a4x8)
      (@ e_a4x9)
      ($dMonoid_a4xa :: Monoid a_a4x5)
      ($dMonoid1_a4xb :: Monoid b_a4x6)
      ($dMonoid2_a4xc :: Monoid c_a4x7)
      ($dMonoid3_a4xd :: Monoid d_a4x8)
      ($dMonoid4_a4xe :: Monoid e_a4x9) ->
      GHC.Base.C:Monoid
        @ (a_a4x5, b_a4x6, c_a4x7, d_a4x8, e_a4x9)
        (GHC.Base.$fMonoid(,,,,)_$cp1Monoid
           @ a_a4x5
           @ b_a4x6
           @ c_a4x7
           @ d_a4x8
           @ e_a4x9
           $dMonoid_a4xa
           $dMonoid1_a4xb
           $dMonoid2_a4xc
           $dMonoid3_a4xd
           $dMonoid4_a4xe)
        (GHC.Base.$fMonoid(,,,,)_$cmempty
           @ a_a4x5
           @ b_a4x6
           @ c_a4x7
           @ d_a4x8
           @ e_a4x9
           $dMonoid_a4xa
           $dMonoid1_a4xb
           $dMonoid2_a4xc
           $dMonoid3_a4xd
           $dMonoid4_a4xe)
        (GHC.Base.$fMonoid(,,,,)_$cmappend
           @ a_a4x5
           @ b_a4x6
           @ c_a4x7
           @ d_a4x8
           @ e_a4x9
           $dMonoid_a4xa
           $dMonoid1_a4xb
           $dMonoid2_a4xc
           $dMonoid3_a4xd
           $dMonoid4_a4xe)
        (GHC.Base.$fMonoid(,,,,)_$cmconcat
           @ a_a4x5
           @ b_a4x6
           @ c_a4x7
           @ d_a4x8
           @ e_a4x9
           $dMonoid_a4xa
           $dMonoid1_a4xb
           $dMonoid2_a4xc
           $dMonoid3_a4xd
           $dMonoid4_a4xe)

-- RHS size: {terms: 33, types: 52, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,,)_$c<>
  :: forall a b c d.
     (Semigroup a, Semigroup b, Semigroup c, Semigroup d) =>
     (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U,U)><S,1*U(U,U,U,U)>m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 20 20] 190 50}]
GHC.Base.$fMonoid(,,,)_$c<>
  = \ (@ a_a4CC)
      (@ b_a4CD)
      (@ c_a4CE)
      (@ d_a4CF)
      ($dSemigroup_a4CG :: Semigroup a_a4CC)
      ($dSemigroup1_a4CH :: Semigroup b_a4CD)
      ($dSemigroup2_a4CI :: Semigroup c_a4CE)
      ($dSemigroup3_a4CJ :: Semigroup d_a4CF)
      (ds_d58F :: (a_a4CC, b_a4CD, c_a4CE, d_a4CF))
      (ds1_d58G :: (a_a4CC, b_a4CD, c_a4CE, d_a4CF)) ->
      case ds_d58F of { (a1_a3ac, b1_a3ad, c1_a3ae, d1_a3af) ->
      case ds1_d58G of { (a'_a3ag, b'_a3ah, c'_a3ai, d'_a3aj) ->
      (<> @ a_a4CC $dSemigroup_a4CG a1_a3ac a'_a3ag,
       <> @ b_a4CD $dSemigroup1_a4CH b1_a3ad b'_a3ah,
       <> @ c_a4CE $dSemigroup2_a4CI c1_a3ae c'_a3ai,
       <> @ d_a4CF $dSemigroup3_a4CJ d1_a3af d'_a3aj)
      }
      }

-- RHS size: {terms: 62, types: 114, coercions: 0, joins: 0/1}
GHC.Base.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (Semigroup a, Semigroup b, Semigroup c, Semigroup d) =>
     a -> b -> c -> d -> [(a, b, c, d)] -> (# a, b, c, d #)
[GblId,
 Arity=9,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><L,U><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30 0 0 0 0 0] 380 0}]
GHC.Base.$w$csconcat2
  = \ (@ a_s6Ow)
      (@ b_s6Ox)
      (@ c_s6Oy)
      (@ d_s6Oz)
      (w_s6OA :: Semigroup a_s6Ow)
      (w1_s6OB :: Semigroup b_s6Ox)
      (w2_s6OC :: Semigroup c_s6Oy)
      (w3_s6OD :: Semigroup d_s6Oz)
      (ww_s6OK :: a_s6Ow)
      (ww1_s6OL :: b_s6Ox)
      (ww2_s6OM :: c_s6Oy)
      (ww3_s6ON :: d_s6Oz)
      (ww4_s6OP :: [(a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz)]) ->
      letrec {
        $wgo_s6Ov [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
          :: a_s6Ow
             -> b_s6Ox
             -> c_s6Oy
             -> d_s6Oz
             -> [(a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz)]
             -> (# a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz #)
        [LclId, Arity=5, Str=<L,U><L,U><L,U><L,U><S,1*U>, Unf=OtherCon []]
        $wgo_s6Ov
          = \ (ww5_s6On :: a_s6Ow)
              (ww6_s6Oo :: b_s6Ox)
              (ww7_s6Op :: c_s6Oy)
              (ww8_s6Oq :: d_s6Oz)
              (w4_s6Ok :: [(a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz)]) ->
              case w4_s6Ok of {
                [] -> (# ww5_s6On, ww6_s6Oo, ww7_s6Op, ww8_s6Oq #);
                : c1_a385 cs_a386 ->
                  case c1_a385 of { (ww10_X70N, ww11_X70P, ww12_X70R, ww13_X70T) ->
                  case $wgo_s6Ov ww10_X70N ww11_X70P ww12_X70R ww13_X70T cs_a386 of
                  { (# ww15_s6Sd, ww16_s6Se, ww17_s6Sf, ww18_s6Sg #) ->
                  (# <> @ a_s6Ow w_s6OA ww5_s6On ww15_s6Sd,
                     <> @ b_s6Ox w1_s6OB ww6_s6Oo ww16_s6Se,
                     <> @ c_s6Oy w2_s6OC ww7_s6Op ww17_s6Sf,
                     <> @ d_s6Oz w3_s6OD ww8_s6Oq ww18_s6Sg #)
                  }
                  }
              }; } in
      $wgo_s6Ov ww_s6OK ww1_s6OL ww2_s6OM ww3_s6ON ww4_s6OP

-- RHS size: {terms: 32, types: 69, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(,,,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (Semigroup a, Semigroup b, Semigroup c, Semigroup d) =>
     NonEmpty (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U,U),1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6Ow)
                 (@ b_s6Ox)
                 (@ c_s6Oy)
                 (@ d_s6Oz)
                 (w_s6OA [Occ=Once] :: Semigroup a_s6Ow)
                 (w1_s6OB [Occ=Once] :: Semigroup b_s6Ox)
                 (w2_s6OC [Occ=Once] :: Semigroup c_s6Oy)
                 (w3_s6OD [Occ=Once] :: Semigroup d_s6Oz)
                 (w4_s6OE [Occ=Once!]
                    :: NonEmpty (a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz)) ->
                 case w4_s6OE of { :| ww1_s6OH [Occ=Once!] ww2_s6OP [Occ=Once] ->
                 case ww1_s6OH of
                 { (ww4_s6OK [Occ=Once], ww5_s6OL [Occ=Once], ww6_s6OM [Occ=Once],
                    ww7_s6ON [Occ=Once]) ->
                 case GHC.Base.$w$csconcat2
                        @ a_s6Ow
                        @ b_s6Ox
                        @ c_s6Oy
                        @ d_s6Oz
                        w_s6OA
                        w1_s6OB
                        w2_s6OC
                        w3_s6OD
                        ww4_s6OK
                        ww5_s6OL
                        ww6_s6OM
                        ww7_s6ON
                        ww2_s6OP
                 of
                 { (# ww9_s6Si [Occ=Once], ww10_s6Sj [Occ=Once],
                      ww11_s6Sk [Occ=Once], ww12_s6Sl [Occ=Once] #) ->
                 (ww9_s6Si, ww10_s6Sj, ww11_s6Sk, ww12_s6Sl)
                 }
                 }
                 }}]
GHC.Base.$fSemigroup(,,,)_$csconcat
  = \ (@ a_s6Ow)
      (@ b_s6Ox)
      (@ c_s6Oy)
      (@ d_s6Oz)
      (w_s6OA :: Semigroup a_s6Ow)
      (w1_s6OB :: Semigroup b_s6Ox)
      (w2_s6OC :: Semigroup c_s6Oy)
      (w3_s6OD :: Semigroup d_s6Oz)
      (w4_s6OE :: NonEmpty (a_s6Ow, b_s6Ox, c_s6Oy, d_s6Oz)) ->
      case w4_s6OE of { :| ww1_s6OH ww2_s6OP ->
      case ww1_s6OH of { (ww4_s6OK, ww5_s6OL, ww6_s6OM, ww7_s6ON) ->
      case GHC.Base.$w$csconcat2
             @ a_s6Ow
             @ b_s6Ox
             @ c_s6Oy
             @ d_s6Oz
             w_s6OA
             w1_s6OB
             w2_s6OC
             w3_s6OD
             ww4_s6OK
             ww5_s6OL
             ww6_s6OM
             ww7_s6ON
             ww2_s6OP
      of
      { (# ww9_s6Si, ww10_s6Sj, ww11_s6Sk, ww12_s6Sl #) ->
      (ww9_s6Si, ww10_s6Sj, ww11_s6Sk, ww12_s6Sl)
      }
      }
      }

-- RHS size: {terms: 36, types: 47, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(,,,)_$cstimes [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (Semigroup a, Semigroup b, Semigroup c, Semigroup d) =>
     forall b1. Integral b1 => b1 -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=7,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6OV)
                 (@ b_s6OW)
                 (@ c_s6OX)
                 (@ d_s6OY)
                 (w_s6OZ [Occ=Once] :: Semigroup a_s6OV)
                 (w1_s6P0 [Occ=Once] :: Semigroup b_s6OW)
                 (w2_s6P1 [Occ=Once] :: Semigroup c_s6OX)
                 (w3_s6P2 [Occ=Once] :: Semigroup d_s6OY)
                 (@ b1_s6P3)
                 (w4_s6P4 :: Integral b1_s6P3)
                 (w5_s6P5 :: b1_s6P3)
                 (w6_s6P6 [Occ=Once!] :: (a_s6OV, b_s6OW, c_s6OX, d_s6OY)) ->
                 case w6_s6P6 of
                 { (ww1_s6P9 [Occ=Once], ww2_s6Pa [Occ=Once], ww3_s6Pb [Occ=Once],
                    ww4_s6Pc [Occ=Once]) ->
                 (stimes @ a_s6OV w_s6OZ @ b1_s6P3 w4_s6P4 w5_s6P5 ww1_s6P9,
                  stimes @ b_s6OW w1_s6P0 @ b1_s6P3 w4_s6P4 w5_s6P5 ww2_s6Pa,
                  stimes @ c_s6OX w2_s6P1 @ b1_s6P3 w4_s6P4 w5_s6P5 ww3_s6Pb,
                  stimes @ d_s6OY w3_s6P2 @ b1_s6P3 w4_s6P4 w5_s6P5 ww4_s6Pc)
                 }}]
GHC.Base.$fSemigroup(,,,)_$cstimes
  = \ (@ a_s6OV)
      (@ b_s6OW)
      (@ c_s6OX)
      (@ d_s6OY)
      (w_s6OZ :: Semigroup a_s6OV)
      (w1_s6P0 :: Semigroup b_s6OW)
      (w2_s6P1 :: Semigroup c_s6OX)
      (w3_s6P2 :: Semigroup d_s6OY)
      (@ b1_s6P3)
      (w4_s6P4 :: Integral b1_s6P3)
      (w5_s6P5 :: b1_s6P3)
      (w6_s6P6 :: (a_s6OV, b_s6OW, c_s6OX, d_s6OY)) ->
      case w6_s6P6 of { (ww1_s6P9, ww2_s6Pa, ww3_s6Pb, ww4_s6Pc) ->
      (stimes @ a_s6OV w_s6OZ @ b1_s6P3 w4_s6P4 w5_s6P5 ww1_s6P9,
       stimes @ b_s6OW w1_s6P0 @ b1_s6P3 w4_s6P4 w5_s6P5 ww2_s6Pa,
       stimes @ c_s6OX w2_s6P1 @ b1_s6P3 w4_s6P4 w5_s6P5 ww3_s6Pb,
       stimes @ d_s6OY w3_s6P2 @ b1_s6P3 w4_s6P4 w5_s6P5 ww4_s6Pc)
      }

-- RHS size: {terms: 24, types: 33, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d.
     (Semigroup a, Semigroup b, Semigroup c, Semigroup d) =>
     Semigroup (a, b, c, d)
[GblId[DFunId],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m,
 Unf=DFun: \ (@ a_a3a8)
             (@ b_a3a9)
             (@ c_a3aa)
             (@ d_a3ab)
             (v_Xbd :: Semigroup a_a3a8)
             (v1_Xc6 :: Semigroup b_a3a9)
             (v2_Xc8 :: Semigroup c_a3aa)
             (v3_B4 :: Semigroup d_a3ab) ->
       GHC.Base.C:Semigroup TYPE: (a_a3a8, b_a3a9, c_a3aa, d_a3ab)
                            GHC.Base.$fMonoid(,,,)_$c<>
                              @ a_a3a8 @ b_a3a9 @ c_a3aa @ d_a3ab v_Xbd v1_Xc6 v2_Xc8 v3_B4
                            GHC.Base.$fSemigroup(,,,)_$csconcat
                              @ a_a3a8 @ b_a3a9 @ c_a3aa @ d_a3ab v_Xbd v1_Xc6 v2_Xc8 v3_B4
                            GHC.Base.$fSemigroup(,,,)_$cstimes
                              @ a_a3a8 @ b_a3a9 @ c_a3aa @ d_a3ab v_Xbd v1_Xc6 v2_Xc8 v3_B4]
GHC.Base.$fSemigroup(,,,)
  = \ (@ a_a4CC)
      (@ b_a4CD)
      (@ c_a4CE)
      (@ d_a4CF)
      ($dSemigroup_a4CG :: Semigroup a_a4CC)
      ($dSemigroup1_a4CH :: Semigroup b_a4CD)
      ($dSemigroup2_a4CI :: Semigroup c_a4CE)
      ($dSemigroup3_a4CJ :: Semigroup d_a4CF) ->
      GHC.Base.C:Semigroup
        @ (a_a4CC, b_a4CD, c_a4CE, d_a4CF)
        (GHC.Base.$fMonoid(,,,)_$c<>
           @ a_a4CC
           @ b_a4CD
           @ c_a4CE
           @ d_a4CF
           $dSemigroup_a4CG
           $dSemigroup1_a4CH
           $dSemigroup2_a4CI
           $dSemigroup3_a4CJ)
        (GHC.Base.$fSemigroup(,,,)_$csconcat
           @ a_a4CC
           @ b_a4CD
           @ c_a4CE
           @ d_a4CF
           $dSemigroup_a4CG
           $dSemigroup1_a4CH
           $dSemigroup2_a4CI
           $dSemigroup3_a4CJ)
        (GHC.Base.$fSemigroup(,,,)_$cstimes
           @ a_a4CC
           @ b_a4CD
           @ c_a4CE
           @ d_a4CF
           $dSemigroup_a4CG
           $dSemigroup1_a4CH
           $dSemigroup2_a4CI
           $dSemigroup3_a4CJ)

-- RHS size: {terms: 94, types: 176, coercions: 0, joins: 0/8}
GHC.Base.$w$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (Monoid a, Monoid b, Monoid c, Monoid d) =>
     (# (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d),
        NonEmpty (a, b, c, d) -> (a, b, c, d),
        forall b1. Integral b1 => b1 -> (a, b, c, d) -> (a, b, c, d) #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [90 90 90 90] 770 40}]
GHC.Base.$w$cp1Monoid
  = \ (@ a_s6Pi)
      (@ b_s6Pj)
      (@ c_s6Pk)
      (@ d_s6Pl)
      (w_s6Pm :: Monoid a_s6Pi)
      (w1_s6Pn :: Monoid b_s6Pj)
      (w2_s6Po :: Monoid c_s6Pk)
      (w3_s6Pp :: Monoid d_s6Pl) ->
      (# GHC.Base.$fMonoid(,,,)_$c<>
           @ a_s6Pi
           @ b_s6Pj
           @ c_s6Pk
           @ d_s6Pl
           (GHC.Base.$p1Monoid @ a_s6Pi w_s6Pm)
           (GHC.Base.$p1Monoid @ b_s6Pj w1_s6Pn)
           (GHC.Base.$p1Monoid @ c_s6Pk w2_s6Po)
           (GHC.Base.$p1Monoid @ d_s6Pl w3_s6Pp),
         let {
           w4_s6OD [Dmd=<L,U(C(C1(U)),A,A)>] :: Semigroup d_s6Pl
           [LclId]
           w4_s6OD = GHC.Base.$p1Monoid @ d_s6Pl w3_s6Pp } in
         let {
           w5_s6OC [Dmd=<L,U(C(C1(U)),A,A)>] :: Semigroup c_s6Pk
           [LclId]
           w5_s6OC = GHC.Base.$p1Monoid @ c_s6Pk w2_s6Po } in
         let {
           w6_s6OB [Dmd=<L,U(C(C1(U)),A,A)>] :: Semigroup b_s6Pj
           [LclId]
           w6_s6OB = GHC.Base.$p1Monoid @ b_s6Pj w1_s6Pn } in
         let {
           w7_s6OA [Dmd=<L,U(C(C1(U)),A,A)>] :: Semigroup a_s6Pi
           [LclId]
           w7_s6OA = GHC.Base.$p1Monoid @ a_s6Pi w_s6Pm } in
         \ (w8_s6OE :: NonEmpty (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)) ->
           case w8_s6OE of { :| ww1_s6OH ww2_s6OP ->
           case ww1_s6OH of { (ww4_s6OK, ww5_s6OL, ww6_s6OM, ww7_s6ON) ->
           case GHC.Base.$w$csconcat2
                  @ a_s6Pi
                  @ b_s6Pj
                  @ c_s6Pk
                  @ d_s6Pl
                  w7_s6OA
                  w6_s6OB
                  w5_s6OC
                  w4_s6OD
                  ww4_s6OK
                  ww5_s6OL
                  ww6_s6OM
                  ww7_s6ON
                  ww2_s6OP
           of
           { (# ww9_s6Si, ww10_s6Sj, ww11_s6Sk, ww12_s6Sl #) ->
           (ww9_s6Si, ww10_s6Sj, ww11_s6Sk, ww12_s6Sl)
           }
           }
           },
         let {
           w4_s6P2 [Dmd=<L,U(A,A,C(C1(C1(U))))>] :: Semigroup d_s6Pl
           [LclId]
           w4_s6P2 = GHC.Base.$p1Monoid @ d_s6Pl w3_s6Pp } in
         let {
           w5_s6P1 [Dmd=<L,U(A,A,C(C1(C1(U))))>] :: Semigroup c_s6Pk
           [LclId]
           w5_s6P1 = GHC.Base.$p1Monoid @ c_s6Pk w2_s6Po } in
         let {
           w6_s6P0 [Dmd=<L,U(A,A,C(C1(C1(U))))>] :: Semigroup b_s6Pj
           [LclId]
           w6_s6P0 = GHC.Base.$p1Monoid @ b_s6Pj w1_s6Pn } in
         let {
           w7_s6OZ [Dmd=<L,U(A,A,C(C1(C1(U))))>] :: Semigroup a_s6Pi
           [LclId]
           w7_s6OZ = GHC.Base.$p1Monoid @ a_s6Pi w_s6Pm } in
         \ (@ b1_s6P3)
           (w8_s6P4 :: Integral b1_s6P3)
           (w9_s6P5 :: b1_s6P3)
           (w10_s6P6 :: (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl)) ->
           case w10_s6P6 of { (ww1_s6P9, ww2_s6Pa, ww3_s6Pb, ww4_s6Pc) ->
           (stimes @ a_s6Pi w7_s6OZ @ b1_s6P3 w8_s6P4 w9_s6P5 ww1_s6P9,
            stimes @ b_s6Pj w6_s6P0 @ b1_s6P3 w8_s6P4 w9_s6P5 ww2_s6Pa,
            stimes @ c_s6Pk w5_s6P1 @ b1_s6P3 w8_s6P4 w9_s6P5 ww3_s6Pb,
            stimes @ d_s6Pl w4_s6P2 @ b1_s6P3 w8_s6P4 w9_s6P5 ww4_s6Pc)
           } #)

-- RHS size: {terms: 19, types: 111, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,,)_$cp1Monoid [InlPrag=NOUSERINLINE[0]]
  :: forall a b c d.
     (Monoid a, Monoid b, Monoid c, Monoid d) =>
     Semigroup (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6Pi)
                 (@ b_s6Pj)
                 (@ c_s6Pk)
                 (@ d_s6Pl)
                 (w_s6Pm [Occ=Once] :: Monoid a_s6Pi)
                 (w1_s6Pn [Occ=Once] :: Monoid b_s6Pj)
                 (w2_s6Po [Occ=Once] :: Monoid c_s6Pk)
                 (w3_s6Pp [Occ=Once] :: Monoid d_s6Pl) ->
                 case GHC.Base.$w$cp1Monoid
                        @ a_s6Pi @ b_s6Pj @ c_s6Pk @ d_s6Pl w_s6Pm w1_s6Pn w2_s6Po w3_s6Pp
                 of
                 { (# ww1_s6Ss [Occ=Once], ww2_s6St [Occ=Once],
                      ww3_s6Su [Occ=Once] #) ->
                 GHC.Base.C:Semigroup
                   @ (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl) ww1_s6Ss ww2_s6St ww3_s6Su
                 }}]
GHC.Base.$fMonoid(,,,)_$cp1Monoid
  = \ (@ a_s6Pi)
      (@ b_s6Pj)
      (@ c_s6Pk)
      (@ d_s6Pl)
      (w_s6Pm :: Monoid a_s6Pi)
      (w1_s6Pn :: Monoid b_s6Pj)
      (w2_s6Po :: Monoid c_s6Pk)
      (w3_s6Pp :: Monoid d_s6Pl) ->
      case GHC.Base.$w$cp1Monoid
             @ a_s6Pi @ b_s6Pj @ c_s6Pk @ d_s6Pl w_s6Pm w1_s6Pn w2_s6Po w3_s6Pp
      of
      { (# ww1_s6Ss, ww2_s6St, ww3_s6Su #) ->
      GHC.Base.C:Semigroup
        @ (a_s6Pi, b_s6Pj, c_s6Pk, d_s6Pl) ww1_s6Ss ww2_s6St ww3_s6Su
      }

-- RHS size: {terms: 16, types: 106, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c d.
     (Monoid a, Monoid b, Monoid c, Monoid d) =>
     (a, b, c, d) -> (a, b, c, d) -> (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4xJ)
                 (@ b_a4xK)
                 (@ c_a4xL)
                 (@ d_a4xM)
                 ($dMonoid_a4xN [Occ=Once] :: Monoid a_a4xJ)
                 ($dMonoid1_a4xO [Occ=Once] :: Monoid b_a4xK)
                 ($dMonoid2_a4xP [Occ=Once] :: Monoid c_a4xL)
                 ($dMonoid3_a4xQ [Occ=Once] :: Monoid d_a4xM) ->
                 <>
                   @ (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
                   (GHC.Base.$fMonoid(,,,)_$cp1Monoid
                      @ a_a4xJ
                      @ b_a4xK
                      @ c_a4xL
                      @ d_a4xM
                      $dMonoid_a4xN
                      $dMonoid1_a4xO
                      $dMonoid2_a4xP
                      $dMonoid3_a4xQ)}]
GHC.Base.$fMonoid(,,,)_$cmappend
  = \ (@ a_a4xJ)
      (@ b_a4xK)
      (@ c_a4xL)
      (@ d_a4xM)
      ($dMonoid_a4xN :: Monoid a_a4xJ)
      ($dMonoid1_a4xO :: Monoid b_a4xK)
      ($dMonoid2_a4xP :: Monoid c_a4xL)
      ($dMonoid3_a4xQ :: Monoid d_a4xM) ->
      case GHC.Base.$w$cp1Monoid
             @ a_a4xJ
             @ b_a4xK
             @ c_a4xL
             @ d_a4xM
             $dMonoid_a4xN
             $dMonoid1_a4xO
             $dMonoid2_a4xP
             $dMonoid3_a4xQ
      of
      { (# ww1_s6Ss, ww2_s6St, ww3_s6Su #) ->
      ww1_s6Ss
      }

-- RHS size: {terms: 53, types: 188, coercions: 0, joins: 0/8}
GHC.Base.$fMonoid(,,,)_$cmconcat
  :: forall a b c d.
     (Monoid a, Monoid b, Monoid c, Monoid d) =>
     [(a, b, c, d)] -> (a, b, c, d)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),1*U,A,A)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 30] 340 60}]
GHC.Base.$fMonoid(,,,)_$cmconcat
  = \ (@ a_a4xJ)
      (@ b_a4xK)
      (@ c_a4xL)
      (@ d_a4xM)
      ($dMonoid_a4xN :: Monoid a_a4xJ)
      ($dMonoid1_a4xO :: Monoid b_a4xK)
      ($dMonoid2_a4xP :: Monoid c_a4xL)
      ($dMonoid3_a4xQ :: Monoid d_a4xM) ->
      let {
        k_s68D [Dmd=<L,1*U(1*C(C1(U(U,U,U,U))),A,A)>]
          :: Semigroup (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
        [LclId]
        k_s68D
          = case GHC.Base.$w$cp1Monoid
                   @ a_a4xJ
                   @ b_a4xK
                   @ c_a4xL
                   @ d_a4xM
                   $dMonoid_a4xN
                   $dMonoid1_a4xO
                   $dMonoid2_a4xP
                   $dMonoid3_a4xQ
            of
            { (# ww1_s6Ss, ww2_s6St, ww3_s6Su #) ->
            GHC.Base.C:Semigroup
              @ (a_a4xJ, b_a4xK, c_a4xL, d_a4xM) ww1_s6Ss ww2_s6St ww3_s6Su
            } } in
      let {
        k1_X3pN [Dmd=<L,C(C1(U(U,U,U,U)))>]
          :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
             -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
             -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
        [LclId]
        k1_X3pN = <> @ (a_a4xJ, b_a4xK, c_a4xL, d_a4xM) k_s68D } in
      let {
        z_s68E :: a_a4xJ
        [LclId]
        z_s68E = mempty @ a_a4xJ $dMonoid_a4xN } in
      let {
        z1_s68F :: b_a4xK
        [LclId]
        z1_s68F = mempty @ b_a4xK $dMonoid1_a4xO } in
      let {
        z2_s68G :: c_a4xL
        [LclId]
        z2_s68G = mempty @ c_a4xL $dMonoid2_a4xP } in
      let {
        z3_s68H :: d_a4xM
        [LclId]
        z3_s68H = mempty @ d_a4xM $dMonoid3_a4xQ } in
      let {
        z4_X3pR [Dmd=<L,U(U,U,U,U)>] :: (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
        [LclId, Unf=OtherCon []]
        z4_X3pR = (z_s68E, z1_s68F, z2_s68G, z3_s68H) } in
      letrec {
        go_X4ek [Occ=LoopBreaker]
          :: [(a_a4xJ, b_a4xK, c_a4xL, d_a4xM)]
             -> (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_X4ek
          = \ (ds_d51B :: [(a_a4xJ, b_a4xK, c_a4xL, d_a4xM)]) ->
              case ds_d51B of {
                [] -> z4_X3pR;
                : y_a3ex ys_a3ey -> k1_X3pN y_a3ex (go_X4ek ys_a3ey)
              }; } in
      go_X4ek

-- RHS size: {terms: 29, types: 37, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c d.
     (Monoid a, Monoid b, Monoid c, Monoid d) =>
     Monoid (a, b, c, d)
[GblId[DFunId],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m,
 Unf=DFun: \ (@ a_a3a4)
             (@ b_a3a5)
             (@ c_a3a6)
             (@ d_a3a7)
             (v_Xbh :: Monoid a_a3a4)
             (v1_Xca :: Monoid b_a3a5)
             (v2_Xcc :: Monoid c_a3a6)
             (v3_B4 :: Monoid d_a3a7) ->
       GHC.Base.C:Monoid TYPE: (a_a3a4, b_a3a5, c_a3a6, d_a3a7)
                         GHC.Base.$fMonoid(,,,)_$cp1Monoid
                           @ a_a3a4 @ b_a3a5 @ c_a3a6 @ d_a3a7 v_Xbh v1_Xca v2_Xcc v3_B4
                         GHC.Base.$fMonoid(,,,)_$cmempty
                           @ a_a3a4 @ b_a3a5 @ c_a3a6 @ d_a3a7 v_Xbh v1_Xca v2_Xcc v3_B4
                         GHC.Base.$fMonoid(,,,)_$cmappend
                           @ a_a3a4 @ b_a3a5 @ c_a3a6 @ d_a3a7 v_Xbh v1_Xca v2_Xcc v3_B4
                         GHC.Base.$fMonoid(,,,)_$cmconcat
                           @ a_a3a4 @ b_a3a5 @ c_a3a6 @ d_a3a7 v_Xbh v1_Xca v2_Xcc v3_B4]
GHC.Base.$fMonoid(,,,)
  = \ (@ a_a4xJ)
      (@ b_a4xK)
      (@ c_a4xL)
      (@ d_a4xM)
      ($dMonoid_a4xN :: Monoid a_a4xJ)
      ($dMonoid1_a4xO :: Monoid b_a4xK)
      ($dMonoid2_a4xP :: Monoid c_a4xL)
      ($dMonoid3_a4xQ :: Monoid d_a4xM) ->
      GHC.Base.C:Monoid
        @ (a_a4xJ, b_a4xK, c_a4xL, d_a4xM)
        (GHC.Base.$fMonoid(,,,)_$cp1Monoid
           @ a_a4xJ
           @ b_a4xK
           @ c_a4xL
           @ d_a4xM
           $dMonoid_a4xN
           $dMonoid1_a4xO
           $dMonoid2_a4xP
           $dMonoid3_a4xQ)
        (GHC.Base.$fMonoid(,,,)_$cmempty
           @ a_a4xJ
           @ b_a4xK
           @ c_a4xL
           @ d_a4xM
           $dMonoid_a4xN
           $dMonoid1_a4xO
           $dMonoid2_a4xP
           $dMonoid3_a4xQ)
        (GHC.Base.$fMonoid(,,,)_$cmappend
           @ a_a4xJ
           @ b_a4xK
           @ c_a4xL
           @ d_a4xM
           $dMonoid_a4xN
           $dMonoid1_a4xO
           $dMonoid2_a4xP
           $dMonoid3_a4xQ)
        (GHC.Base.$fMonoid(,,,)_$cmconcat
           @ a_a4xJ
           @ b_a4xK
           @ c_a4xL
           @ d_a4xM
           $dMonoid_a4xN
           $dMonoid1_a4xO
           $dMonoid2_a4xP
           $dMonoid3_a4xQ)

-- RHS size: {terms: 27, types: 40, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,)_$c<> [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Semigroup a, Semigroup b, Semigroup c) =>
     (a, b, c) -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U)><S,1*U(U,U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6PD)
                 (@ b_s6PE)
                 (@ c_s6PF)
                 (w_s6PG [Occ=Once] :: Semigroup a_s6PD)
                 (w1_s6PH [Occ=Once] :: Semigroup b_s6PE)
                 (w2_s6PI [Occ=Once] :: Semigroup c_s6PF)
                 (w3_s6PJ [Occ=Once!] :: (a_s6PD, b_s6PE, c_s6PF))
                 (w4_s6PK [Occ=Once!] :: (a_s6PD, b_s6PE, c_s6PF)) ->
                 case w3_s6PJ of
                 { (ww1_s6PN [Occ=Once], ww2_s6PO [Occ=Once],
                    ww3_s6PP [Occ=Once]) ->
                 case w4_s6PK of
                 { (ww5_s6PT [Occ=Once], ww6_s6PU [Occ=Once],
                    ww7_s6PV [Occ=Once]) ->
                 (<> @ a_s6PD w_s6PG ww1_s6PN ww5_s6PT,
                  <> @ b_s6PE w1_s6PH ww2_s6PO ww6_s6PU,
                  <> @ c_s6PF w2_s6PI ww3_s6PP ww7_s6PV)
                 }
                 }}]
GHC.Base.$fMonoid(,,)_$c<>
  = \ (@ a_s6PD)
      (@ b_s6PE)
      (@ c_s6PF)
      (w_s6PG :: Semigroup a_s6PD)
      (w1_s6PH :: Semigroup b_s6PE)
      (w2_s6PI :: Semigroup c_s6PF)
      (w3_s6PJ :: (a_s6PD, b_s6PE, c_s6PF))
      (w4_s6PK :: (a_s6PD, b_s6PE, c_s6PF)) ->
      case w3_s6PJ of { (ww1_s6PN, ww2_s6PO, ww3_s6PP) ->
      case w4_s6PK of { (ww5_s6PT, ww6_s6PU, ww7_s6PV) ->
      (<> @ a_s6PD w_s6PG ww1_s6PN ww5_s6PT,
       <> @ b_s6PE w1_s6PH ww2_s6PO ww6_s6PU,
       <> @ c_s6PF w2_s6PI ww3_s6PP ww7_s6PV)
      }
      }

-- RHS size: {terms: 51, types: 89, coercions: 0, joins: 0/1}
GHC.Base.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Semigroup a, Semigroup b, Semigroup c) =>
     a -> b -> c -> [(a, b, c)] -> (# a, b, c #)
[GblId,
 Arity=7,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30 30 30 0 0 0 0] 310 0}]
GHC.Base.$w$csconcat1
  = \ (@ a_s6Qd)
      (@ b_s6Qe)
      (@ c_s6Qf)
      (w_s6Qg :: Semigroup a_s6Qd)
      (w1_s6Qh :: Semigroup b_s6Qe)
      (w2_s6Qi :: Semigroup c_s6Qf)
      (ww_s6Qp :: a_s6Qd)
      (ww1_s6Qq :: b_s6Qe)
      (ww2_s6Qr :: c_s6Qf)
      (ww3_s6Qt :: [(a_s6Qd, b_s6Qe, c_s6Qf)]) ->
      letrec {
        $wgo_s6Qc [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
          :: a_s6Qd
             -> b_s6Qe
             -> c_s6Qf
             -> [(a_s6Qd, b_s6Qe, c_s6Qf)]
             -> (# a_s6Qd, b_s6Qe, c_s6Qf #)
        [LclId, Arity=4, Str=<L,U><L,U><L,U><S,1*U>, Unf=OtherCon []]
        $wgo_s6Qc
          = \ (ww4_s6Q5 :: a_s6Qd)
              (ww5_s6Q6 :: b_s6Qe)
              (ww6_s6Q7 :: c_s6Qf)
              (w3_s6Q2 :: [(a_s6Qd, b_s6Qe, c_s6Qf)]) ->
              case w3_s6Q2 of {
                [] -> (# ww4_s6Q5, ww5_s6Q6, ww6_s6Q7 #);
                : c1_a385 cs_a386 ->
                  case c1_a385 of { (ww8_X72B, ww9_X72D, ww10_X72F) ->
                  case $wgo_s6Qc ww8_X72B ww9_X72D ww10_X72F cs_a386 of
                  { (# ww12_s6SA, ww13_s6SB, ww14_s6SC #) ->
                  (# <> @ a_s6Qd w_s6Qg ww4_s6Q5 ww12_s6SA,
                     <> @ b_s6Qe w1_s6Qh ww5_s6Q6 ww13_s6SB,
                     <> @ c_s6Qf w2_s6Qi ww6_s6Q7 ww14_s6SC #)
                  }
                  }
              }; } in
      $wgo_s6Qc ww_s6Qp ww1_s6Qq ww2_s6Qr ww3_s6Qt

-- RHS size: {terms: 27, types: 54, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(,,)_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Semigroup a, Semigroup b, Semigroup c) =>
     NonEmpty (a, b, c) -> (a, b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U),1*U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6Qd)
                 (@ b_s6Qe)
                 (@ c_s6Qf)
                 (w_s6Qg [Occ=Once] :: Semigroup a_s6Qd)
                 (w1_s6Qh [Occ=Once] :: Semigroup b_s6Qe)
                 (w2_s6Qi [Occ=Once] :: Semigroup c_s6Qf)
                 (w3_s6Qj [Occ=Once!] :: NonEmpty (a_s6Qd, b_s6Qe, c_s6Qf)) ->
                 case w3_s6Qj of { :| ww1_s6Qm [Occ=Once!] ww2_s6Qt [Occ=Once] ->
                 case ww1_s6Qm of
                 { (ww4_s6Qp [Occ=Once], ww5_s6Qq [Occ=Once],
                    ww6_s6Qr [Occ=Once]) ->
                 case GHC.Base.$w$csconcat1
                        @ a_s6Qd
                        @ b_s6Qe
                        @ c_s6Qf
                        w_s6Qg
                        w1_s6Qh
                        w2_s6Qi
                        ww4_s6Qp
                        ww5_s6Qq
                        ww6_s6Qr
                        ww2_s6Qt
                 of
                 { (# ww8_s6SE [Occ=Once], ww9_s6SF [Occ=Once],
                      ww10_s6SG [Occ=Once] #) ->
                 (ww8_s6SE, ww9_s6SF, ww10_s6SG)
                 }
                 }
                 }}]
GHC.Base.$fSemigroup(,,)_$csconcat
  = \ (@ a_s6Qd)
      (@ b_s6Qe)
      (@ c_s6Qf)
      (w_s6Qg :: Semigroup a_s6Qd)
      (w1_s6Qh :: Semigroup b_s6Qe)
      (w2_s6Qi :: Semigroup c_s6Qf)
      (w3_s6Qj :: NonEmpty (a_s6Qd, b_s6Qe, c_s6Qf)) ->
      case w3_s6Qj of { :| ww1_s6Qm ww2_s6Qt ->
      case ww1_s6Qm of { (ww4_s6Qp, ww5_s6Qq, ww6_s6Qr) ->
      case GHC.Base.$w$csconcat1
             @ a_s6Qd
             @ b_s6Qe
             @ c_s6Qf
             w_s6Qg
             w1_s6Qh
             w2_s6Qi
             ww4_s6Qp
             ww5_s6Qq
             ww6_s6Qr
             ww2_s6Qt
      of
      { (# ww8_s6SE, ww9_s6SF, ww10_s6SG #) ->
      (ww8_s6SE, ww9_s6SF, ww10_s6SG)
      }
      }
      }

-- RHS size: {terms: 30, types: 43, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,)_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a b c.
     (Monoid a, Monoid b, Monoid c) =>
     (a, b, c) -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U(U,U,U)><S,1*U(U,U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_a4yj)
                 (@ b_a4yk)
                 (@ c_a4yl)
                 ($dMonoid_a4ym [Occ=Once] :: Monoid a_a4yj)
                 ($dMonoid1_a4yn [Occ=Once] :: Monoid b_a4yk)
                 ($dMonoid2_a4yo [Occ=Once] :: Monoid c_a4yl) ->
                 GHC.Base.$fMonoid(,,)_$c<>
                   @ a_a4yj
                   @ b_a4yk
                   @ c_a4yl
                   (GHC.Base.$p1Monoid @ a_a4yj $dMonoid_a4ym)
                   (GHC.Base.$p1Monoid @ b_a4yk $dMonoid1_a4yn)
                   (GHC.Base.$p1Monoid @ c_a4yl $dMonoid2_a4yo)}]
GHC.Base.$fMonoid(,,)_$cmappend
  = \ (@ a_a4yj)
      (@ b_a4yk)
      (@ c_a4yl)
      ($dMonoid_a4ym :: Monoid a_a4yj)
      ($dMonoid1_a4yn :: Monoid b_a4yk)
      ($dMonoid2_a4yo :: Monoid c_a4yl)
      (eta_Xce :: (a_a4yj, b_a4yk, c_a4yl))
      (eta1_Xbn :: (a_a4yj, b_a4yk, c_a4yl)) ->
      case eta_Xce of { (a1_a3av, b1_a3aw, c1_a3ax) ->
      case eta1_Xbn of { (a'_a3ay, b'_a3az, c'_a3aA) ->
      (<>
         @ a_a4yj
         (GHC.Base.$p1Monoid @ a_a4yj $dMonoid_a4ym)
         a1_a3av
         a'_a3ay,
       <>
         @ b_a4yk
         (GHC.Base.$p1Monoid @ b_a4yk $dMonoid1_a4yn)
         b1_a3aw
         b'_a3az,
       <>
         @ c_a4yl
         (GHC.Base.$p1Monoid @ c_a4yl $dMonoid2_a4yo)
         c1_a3ax
         c'_a3aA)
      }
      }

-- RHS size: {terms: 59, types: 87, coercions: 0, joins: 0/8}
GHC.Base.$fMonoid(,,)_$cmconcat
  :: forall a b c.
     (Monoid a, Monoid b, Monoid c) =>
     [(a, b, c)] -> (a, b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 60 60 0] 430 0}]
GHC.Base.$fMonoid(,,)_$cmconcat
  = \ (@ a_a4yj)
      (@ b_a4yk)
      (@ c_a4yl)
      ($dMonoid_a4ym :: Monoid a_a4yj)
      ($dMonoid1_a4yn :: Monoid b_a4yk)
      ($dMonoid2_a4yo :: Monoid c_a4yl)
      (eta_Xbn :: [(a_a4yj, b_a4yk, c_a4yl)]) ->
      let {
        $dSemigroup_a4Dt [Dmd=<L,U(C(C1(U)),A,A)>] :: Semigroup a_a4yj
        [LclId]
        $dSemigroup_a4Dt = GHC.Base.$p1Monoid @ a_a4yj $dMonoid_a4ym } in
      let {
        $dSemigroup1_a4Du [Dmd=<L,U(C(C1(U)),A,A)>] :: Semigroup b_a4yk
        [LclId]
        $dSemigroup1_a4Du = GHC.Base.$p1Monoid @ b_a4yk $dMonoid1_a4yn } in
      let {
        $dSemigroup2_a4Dv [Dmd=<L,U(C(C1(U)),A,A)>] :: Semigroup c_a4yl
        [LclId]
        $dSemigroup2_a4Dv = GHC.Base.$p1Monoid @ c_a4yl $dMonoid2_a4yo } in
      let {
        z_s68R :: a_a4yj
        [LclId]
        z_s68R = mempty @ a_a4yj $dMonoid_a4ym } in
      let {
        z1_s68S :: b_a4yk
        [LclId]
        z1_s68S = mempty @ b_a4yk $dMonoid1_a4yn } in
      let {
        z2_s68T :: c_a4yl
        [LclId]
        z2_s68T = mempty @ c_a4yl $dMonoid2_a4yo } in
      let {
        z3_X3q1 [Dmd=<S,U(U,U,U)>] :: (a_a4yj, b_a4yk, c_a4yl)
        [LclId, Unf=OtherCon []]
        z3_X3q1 = (z_s68R, z1_s68S, z2_s68T) } in
      letrec {
        go_X4et [Occ=LoopBreaker]
          :: [(a_a4yj, b_a4yk, c_a4yl)] -> (a_a4yj, b_a4yk, c_a4yl)
        [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []]
        go_X4et
          = \ (ds_d51B :: [(a_a4yj, b_a4yk, c_a4yl)]) ->
              case ds_d51B of {
                [] -> z3_X3q1;
                : y_a3ex ys_a3ey ->
                  case y_a3ex of { (a1_a3av, b1_a3aw, c1_a3ax) ->
                  case go_X4et ys_a3ey of { (a'_a3ay, b'_a3az, c'_a3aA) ->
                  (<> @ a_a4yj $dSemigroup_a4Dt a1_a3av a'_a3ay,
                   <> @ b_a4yk $dSemigroup1_a4Du b1_a3aw b'_a3az,
                   <> @ c_a4yl $dSemigroup2_a4Dv c1_a3ax c'_a3aA)
                  }
                  }
              }; } in
      go_X4et eta_Xbn

-- RHS size: {terms: 29, types: 37, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(,,)_$cstimes [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (Semigroup a, Semigroup b, Semigroup c) =>
     forall b1. Integral b1 => b1 -> (a, b, c) -> (a, b, c)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6QH)
                 (@ b_s6QI)
                 (@ c_s6QJ)
                 (w_s6QK [Occ=Once] :: Semigroup a_s6QH)
                 (w1_s6QL [Occ=Once] :: Semigroup b_s6QI)
                 (w2_s6QM [Occ=Once] :: Semigroup c_s6QJ)
                 (@ b1_s6QN)
                 (w3_s6QO :: Integral b1_s6QN)
                 (w4_s6QP :: b1_s6QN)
                 (w5_s6QQ [Occ=Once!] :: (a_s6QH, b_s6QI, c_s6QJ)) ->
                 case w5_s6QQ of
                 { (ww1_s6QT [Occ=Once], ww2_s6QU [Occ=Once],
                    ww3_s6QV [Occ=Once]) ->
                 (stimes @ a_s6QH w_s6QK @ b1_s6QN w3_s6QO w4_s6QP ww1_s6QT,
                  stimes @ b_s6QI w1_s6QL @ b1_s6QN w3_s6QO w4_s6QP ww2_s6QU,
                  stimes @ c_s6QJ w2_s6QM @ b1_s6QN w3_s6QO w4_s6QP ww3_s6QV)
                 }}]
GHC.Base.$fSemigroup(,,)_$cstimes
  = \ (@ a_s6QH)
      (@ b_s6QI)
      (@ c_s6QJ)
      (w_s6QK :: Semigroup a_s6QH)
      (w1_s6QL :: Semigroup b_s6QI)
      (w2_s6QM :: Semigroup c_s6QJ)
      (@ b1_s6QN)
      (w3_s6QO :: Integral b1_s6QN)
      (w4_s6QP :: b1_s6QN)
      (w5_s6QQ :: (a_s6QH, b_s6QI, c_s6QJ)) ->
      case w5_s6QQ of { (ww1_s6QT, ww2_s6QU, ww3_s6QV) ->
      (stimes @ a_s6QH w_s6QK @ b1_s6QN w3_s6QO w4_s6QP ww1_s6QT,
       stimes @ b_s6QI w1_s6QL @ b1_s6QN w3_s6QO w4_s6QP ww2_s6QU,
       stimes @ c_s6QJ w2_s6QM @ b1_s6QN w3_s6QO w4_s6QP ww3_s6QV)
      }

-- RHS size: {terms: 19, types: 25, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c.
     (Semigroup a, Semigroup b, Semigroup c) =>
     Semigroup (a, b, c)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m,
 Unf=DFun: \ (@ a_a3as)
             (@ b_a3at)
             (@ c_a3au)
             (v_Xbm :: Semigroup a_a3as)
             (v1_Xcf :: Semigroup b_a3at)
             (v2_Xch :: Semigroup c_a3au) ->
       GHC.Base.C:Semigroup TYPE: (a_a3as, b_a3at, c_a3au)
                            GHC.Base.$fMonoid(,,)_$c<>
                              @ a_a3as @ b_a3at @ c_a3au v_Xbm v1_Xcf v2_Xch
                            GHC.Base.$fSemigroup(,,)_$csconcat
                              @ a_a3as @ b_a3at @ c_a3au v_Xbm v1_Xcf v2_Xch
                            GHC.Base.$fSemigroup(,,)_$cstimes
                              @ a_a3as @ b_a3at @ c_a3au v_Xbm v1_Xcf v2_Xch]
GHC.Base.$fSemigroup(,,)
  = \ (@ a_a4Dq)
      (@ b_a4Dr)
      (@ c_a4Ds)
      ($dSemigroup_a4Dt :: Semigroup a_a4Dq)
      ($dSemigroup1_a4Du :: Semigroup b_a4Dr)
      ($dSemigroup2_a4Dv :: Semigroup c_a4Ds) ->
      GHC.Base.C:Semigroup
        @ (a_a4Dq, b_a4Dr, c_a4Ds)
        (GHC.Base.$fMonoid(,,)_$c<>
           @ a_a4Dq
           @ b_a4Dr
           @ c_a4Ds
           $dSemigroup_a4Dt
           $dSemigroup1_a4Du
           $dSemigroup2_a4Dv)
        (GHC.Base.$fSemigroup(,,)_$csconcat
           @ a_a4Dq
           @ b_a4Dr
           @ c_a4Ds
           $dSemigroup_a4Dt
           $dSemigroup1_a4Du
           $dSemigroup2_a4Dv)
        (GHC.Base.$fSemigroup(,,)_$cstimes
           @ a_a4Dq
           @ b_a4Dr
           @ c_a4Ds
           $dSemigroup_a4Dt
           $dSemigroup1_a4Du
           $dSemigroup2_a4Dv)

-- RHS size: {terms: 13, types: 18, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,)_$cp1Monoid
  :: forall a b c.
     (Monoid a, Monoid b, Monoid c) =>
     Semigroup (a, b, c)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4yj)
                 (@ b_a4yk)
                 (@ c_a4yl)
                 ($dMonoid_a4ym [Occ=Once] :: Monoid a_a4yj)
                 ($dMonoid1_a4yn [Occ=Once] :: Monoid b_a4yk)
                 ($dMonoid2_a4yo [Occ=Once] :: Monoid c_a4yl) ->
                 GHC.Base.$fSemigroup(,,)
                   @ a_a4yj
                   @ b_a4yk
                   @ c_a4yl
                   (GHC.Base.$p1Monoid @ a_a4yj $dMonoid_a4ym)
                   (GHC.Base.$p1Monoid @ b_a4yk $dMonoid1_a4yn)
                   (GHC.Base.$p1Monoid @ c_a4yl $dMonoid2_a4yo)}]
GHC.Base.$fMonoid(,,)_$cp1Monoid
  = \ (@ a_a4yj)
      (@ b_a4yk)
      (@ c_a4yl)
      ($dMonoid_a4ym :: Monoid a_a4yj)
      ($dMonoid1_a4yn :: Monoid b_a4yk)
      ($dMonoid2_a4yo :: Monoid c_a4yl) ->
      GHC.Base.$fSemigroup(,,)
        @ a_a4yj
        @ b_a4yk
        @ c_a4yl
        (GHC.Base.$p1Monoid @ a_a4yj $dMonoid_a4ym)
        (GHC.Base.$p1Monoid @ b_a4yk $dMonoid1_a4yn)
        (GHC.Base.$p1Monoid @ c_a4yl $dMonoid2_a4yo)

-- RHS size: {terms: 23, types: 28, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b c. (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c)
[GblId[DFunId],
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m,
 Unf=DFun: \ (@ a_a3ap)
             (@ b_a3aq)
             (@ c_a3ar)
             (v_Xbo :: Monoid a_a3ap)
             (v1_Xch :: Monoid b_a3aq)
             (v2_Xcj :: Monoid c_a3ar) ->
       GHC.Base.C:Monoid TYPE: (a_a3ap, b_a3aq, c_a3ar)
                         GHC.Base.$fMonoid(,,)_$cp1Monoid
                           @ a_a3ap @ b_a3aq @ c_a3ar v_Xbo v1_Xch v2_Xcj
                         GHC.Base.$fMonoid(,,)_$cmempty
                           @ a_a3ap @ b_a3aq @ c_a3ar v_Xbo v1_Xch v2_Xcj
                         GHC.Base.$fMonoid(,,)_$cmappend
                           @ a_a3ap @ b_a3aq @ c_a3ar v_Xbo v1_Xch v2_Xcj
                         GHC.Base.$fMonoid(,,)_$cmconcat
                           @ a_a3ap @ b_a3aq @ c_a3ar v_Xbo v1_Xch v2_Xcj]
GHC.Base.$fMonoid(,,)
  = \ (@ a_a4yj)
      (@ b_a4yk)
      (@ c_a4yl)
      ($dMonoid_a4ym :: Monoid a_a4yj)
      ($dMonoid1_a4yn :: Monoid b_a4yk)
      ($dMonoid2_a4yo :: Monoid c_a4yl) ->
      GHC.Base.C:Monoid
        @ (a_a4yj, b_a4yk, c_a4yl)
        (GHC.Base.$fMonoid(,,)_$cp1Monoid
           @ a_a4yj
           @ b_a4yk
           @ c_a4yl
           $dMonoid_a4ym
           $dMonoid1_a4yn
           $dMonoid2_a4yo)
        (GHC.Base.$fMonoid(,,)_$cmempty
           @ a_a4yj
           @ b_a4yk
           @ c_a4yl
           $dMonoid_a4ym
           $dMonoid1_a4yn
           $dMonoid2_a4yo)
        (GHC.Base.$fMonoid(,,)_$cmappend
           @ a_a4yj
           @ b_a4yk
           @ c_a4yl
           $dMonoid_a4ym
           $dMonoid1_a4yn
           $dMonoid2_a4yo)
        (GHC.Base.$fMonoid(,,)_$cmconcat
           @ a_a4yj
           @ b_a4yk
           @ c_a4yl
           $dMonoid_a4ym
           $dMonoid1_a4yn
           $dMonoid2_a4yo)

-- RHS size: {terms: 21, types: 28, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(,)_$c<>
  :: forall a b.
     (Semigroup a, Semigroup b) =>
     (a, b) -> (a, b) -> (a, b)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4E6)
                 (@ b_a4E7)
                 ($dSemigroup_a4E8 [Occ=Once] :: Semigroup a_a4E6)
                 ($dSemigroup1_a4E9 [Occ=Once] :: Semigroup b_a4E7)
                 (ds_d59g [Occ=Once!] :: (a_a4E6, b_a4E7))
                 (ds1_d59h [Occ=Once!] :: (a_a4E6, b_a4E7)) ->
                 case ds_d59g of { (a1_a3aJ [Occ=Once], b1_a3aK [Occ=Once]) ->
                 case ds1_d59h of { (a'_a3aL [Occ=Once], b'_a3aM [Occ=Once]) ->
                 (<> @ a_a4E6 $dSemigroup_a4E8 a1_a3aJ a'_a3aL,
                  <> @ b_a4E7 $dSemigroup1_a4E9 b1_a3aK b'_a3aM)
                 }
                 }}]
GHC.Base.$fSemigroup(,)_$c<>
  = \ (@ a_a4E6)
      (@ b_a4E7)
      ($dSemigroup_a4E8 :: Semigroup a_a4E6)
      ($dSemigroup1_a4E9 :: Semigroup b_a4E7)
      (ds_d59g :: (a_a4E6, b_a4E7))
      (ds1_d59h :: (a_a4E6, b_a4E7)) ->
      case ds_d59g of { (a1_a3aJ, b1_a3aK) ->
      case ds1_d59h of { (a'_a3aL, b'_a3aM) ->
      (<> @ a_a4E6 $dSemigroup_a4E8 a1_a3aJ a'_a3aL,
       <> @ b_a4E7 $dSemigroup1_a4E9 b1_a3aK b'_a3aM)
      }
      }

-- RHS size: {terms: 22, types: 27, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(,)_$cstimes
  :: forall a b.
     (Semigroup a, Semigroup b) =>
     forall b1. Integral b1 => b1 -> (a, b) -> (a, b)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,1*C1(C1(C1(U))))><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4E6)
                 (@ b_a4E7)
                 ($dSemigroup_a4E8 [Occ=Once] :: Semigroup a_a4E6)
                 ($dSemigroup1_a4E9 [Occ=Once] :: Semigroup b_a4E7)
                 (@ b1_a4Eq)
                 ($dIntegral_a4Es :: Integral b1_a4Eq)
                 (n_a3aN :: b1_a4Eq)
                 (ds_d59p [Occ=Once!] :: (a_a4E6, b_a4E7)) ->
                 case ds_d59p of { (a1_a3aO [Occ=Once], b2_a3aP [Occ=Once]) ->
                 (stimes
                    @ a_a4E6 $dSemigroup_a4E8 @ b1_a4Eq $dIntegral_a4Es n_a3aN a1_a3aO,
                  stimes
                    @ b_a4E7
                    $dSemigroup1_a4E9
                    @ b1_a4Eq
                    $dIntegral_a4Es
                    n_a3aN
                    b2_a3aP)
                 }}]
GHC.Base.$fSemigroup(,)_$cstimes
  = \ (@ a_a4E6)
      (@ b_a4E7)
      ($dSemigroup_a4E8 :: Semigroup a_a4E6)
      ($dSemigroup1_a4E9 :: Semigroup b_a4E7)
      (@ b1_a4Eq)
      ($dIntegral_a4Es :: Integral b1_a4Eq)
      (n_a3aN :: b1_a4Eq)
      (ds_d59p :: (a_a4E6, b_a4E7)) ->
      case ds_d59p of { (a1_a3aO, b2_a3aP) ->
      (stimes
         @ a_a4E6 $dSemigroup_a4E8 @ b1_a4Eq $dIntegral_a4Es n_a3aN a1_a3aO,
       stimes
         @ b_a4E7
         $dSemigroup1_a4E9
         @ b1_a4Eq
         $dIntegral_a4Es
         n_a3aN
         b2_a3aP)
      }

-- RHS size: {terms: 14, types: 17, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. (Semigroup a, Semigroup b) => Semigroup (a, b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))><L,U(C(C1(U)),A,C(C1(C1(U))))>m,
 Unf=DFun: \ (@ a_a3aH)
             (@ b_a3aI)
             (v_Xbq :: Semigroup a_a3aH)
             (v1_Xcj :: Semigroup b_a3aI) ->
       GHC.Base.C:Semigroup TYPE: (a_a3aH, b_a3aI)
                            GHC.Base.$fSemigroup(,)_$c<> @ a_a3aH @ b_a3aI v_Xbq v1_Xcj
                            GHC.Base.$fSemigroup(,)_$csconcat @ a_a3aH @ b_a3aI v_Xbq v1_Xcj
                            GHC.Base.$fSemigroup(,)_$cstimes @ a_a3aH @ b_a3aI v_Xbq v1_Xcj]
GHC.Base.$fSemigroup(,)
  = \ (@ a_a4E6)
      (@ b_a4E7)
      ($dSemigroup_a4E8 :: Semigroup a_a4E6)
      ($dSemigroup1_a4E9 :: Semigroup b_a4E7) ->
      GHC.Base.C:Semigroup
        @ (a_a4E6, b_a4E7)
        (GHC.Base.$fSemigroup(,)_$c<>
           @ a_a4E6 @ b_a4E7 $dSemigroup_a4E8 $dSemigroup1_a4E9)
        (GHC.Base.$fSemigroup(,)_$csconcat
           @ a_a4E6 @ b_a4E7 $dSemigroup_a4E8 $dSemigroup1_a4E9)
        (GHC.Base.$fSemigroup(,)_$cstimes
           @ a_a4E6 @ b_a4E7 $dSemigroup_a4E8 $dSemigroup1_a4E9)

-- RHS size: {terms: 9, types: 12, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,)_$cp1Monoid
  :: forall a b. (Monoid a, Monoid b) => Semigroup (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)><L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4yP)
                 (@ b_a4yQ)
                 ($dMonoid_a4yR [Occ=Once] :: Monoid a_a4yP)
                 ($dMonoid1_a4yS [Occ=Once] :: Monoid b_a4yQ) ->
                 GHC.Base.$fSemigroup(,)
                   @ a_a4yP
                   @ b_a4yQ
                   (GHC.Base.$p1Monoid @ a_a4yP $dMonoid_a4yR)
                   (GHC.Base.$p1Monoid @ b_a4yQ $dMonoid1_a4yS)}]
GHC.Base.$fMonoid(,)_$cp1Monoid
  = \ (@ a_a4yP)
      (@ b_a4yQ)
      ($dMonoid_a4yR :: Monoid a_a4yP)
      ($dMonoid1_a4yS :: Monoid b_a4yQ) ->
      GHC.Base.$fSemigroup(,)
        @ a_a4yP
        @ b_a4yQ
        (GHC.Base.$p1Monoid @ a_a4yP $dMonoid_a4yR)
        (GHC.Base.$p1Monoid @ b_a4yQ $dMonoid1_a4yS)

-- RHS size: {terms: 17, types: 19, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a b. (Monoid a, Monoid b) => Monoid (a, b)
[GblId[DFunId],
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)><L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m,
 Unf=DFun: \ (@ a_a3aF)
             (@ b_a3aG)
             (v_Xbs :: Monoid a_a3aF)
             (v1_Xcl :: Monoid b_a3aG) ->
       GHC.Base.C:Monoid TYPE: (a_a3aF, b_a3aG)
                         GHC.Base.$fMonoid(,)_$cp1Monoid @ a_a3aF @ b_a3aG v_Xbs v1_Xcl
                         GHC.Base.$fMonoid(,)_$cmempty @ a_a3aF @ b_a3aG v_Xbs v1_Xcl
                         GHC.Base.$fMonoid(,)_$cmappend @ a_a3aF @ b_a3aG v_Xbs v1_Xcl
                         GHC.Base.$fMonoid(,)_$cmconcat @ a_a3aF @ b_a3aG v_Xbs v1_Xcl]
GHC.Base.$fMonoid(,)
  = \ (@ a_a4yP)
      (@ b_a4yQ)
      ($dMonoid_a4yR :: Monoid a_a4yP)
      ($dMonoid1_a4yS :: Monoid b_a4yQ) ->
      GHC.Base.C:Monoid
        @ (a_a4yP, b_a4yQ)
        (GHC.Base.$fMonoid(,)_$cp1Monoid
           @ a_a4yP @ b_a4yQ $dMonoid_a4yR $dMonoid1_a4yS)
        (GHC.Base.$fMonoid(,)_$cmempty
           @ a_a4yP @ b_a4yQ $dMonoid_a4yR $dMonoid1_a4yS)
        (GHC.Base.$fMonoid(,)_$cmappend
           @ a_a4yP @ b_a4yQ $dMonoid_a4yR $dMonoid1_a4yS)
        (GHC.Base.$fMonoid(,)_$cmconcat
           @ a_a4yP @ b_a4yQ $dMonoid_a4yR $dMonoid1_a4yS)

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid()_$c<> :: () -> () -> ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Tuple.()}]
GHC.Base.$fMonoid()_$c<>
  = \ _ [Occ=Dead] _ [Occ=Dead] -> GHC.Tuple.()

-- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup()_$csconcat :: NonEmpty () -> ()
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> GHC.Tuple.()}]
GHC.Base.$fSemigroup()_$csconcat = \ _ [Occ=Dead] -> GHC.Tuple.()

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup()_$cstimes
  :: forall b. Integral b => b -> () -> ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_a4EP) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
                 GHC.Tuple.()}]
GHC.Base.$fSemigroup()_$cstimes
  = \ (@ b_a4EP) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] ->
      GHC.Tuple.()

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup() [InlPrag=NOUSERINLINE CONLIKE]
  :: Semigroup ()
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Semigroup TYPE: ()
                            GHC.Base.$fMonoid()_$c<>
                            GHC.Base.$fSemigroup()_$csconcat
                            GHC.Base.$fSemigroup()_$cstimes]
GHC.Base.$fSemigroup()
  = GHC.Base.C:Semigroup
      @ ()
      GHC.Base.$fMonoid()_$c<>
      GHC.Base.$fSemigroup()_$csconcat
      GHC.Base.$fSemigroup()_$cstimes

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid() [InlPrag=NOUSERINLINE CONLIKE] :: Monoid ()
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monoid TYPE: ()
                         GHC.Base.$fSemigroup()
                         GHC.Tuple.()
                         GHC.Base.$fMonoid()_$c<>
                         GHC.Base.$fMonoid()_$cmconcat]
GHC.Base.$fMonoid()
  = GHC.Base.C:Monoid
      @ ()
      GHC.Base.$fSemigroup()
      GHC.Tuple.()
      GHC.Base.$fMonoid()_$c<>
      GHC.Base.$fMonoid()_$cmconcat

-- RHS size: {terms: 12, types: 12, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(->)_$c<>
  :: forall b a. Semigroup b => (a -> b) -> (a -> b) -> a -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(C(C(S))LL),1*U(1*C1(C1(U)),A,A)><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4EV)
                 (@ a_a4EW)
                 ($dSemigroup_a4EX [Occ=Once] :: Semigroup b_a4EV)
                 (f_a3aU [Occ=Once!] :: a_a4EW -> b_a4EV)
                 (g_a3aV [Occ=Once!] :: a_a4EW -> b_a4EV)
                 (x_a3aW :: a_a4EW) ->
                 <> @ b_a4EV $dSemigroup_a4EX (f_a3aU x_a3aW) (g_a3aV x_a3aW)}]
GHC.Base.$fSemigroup(->)_$c<>
  = \ (@ b_a4EV)
      (@ a_a4EW)
      ($dSemigroup_a4EX :: Semigroup b_a4EV)
      (f_a3aU :: a_a4EW -> b_a4EV)
      (g_a3aV :: a_a4EW -> b_a4EV)
      (x_a3aW :: a_a4EW) ->
      <> @ b_a4EV $dSemigroup_a4EX (f_a3aU x_a3aW) (g_a3aV x_a3aW)

-- RHS size: {terms: 14, types: 16, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(->)_$cstimes
  :: forall b a.
     Semigroup b =>
     forall b1. Integral b1 => b1 -> (a -> b) -> a -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))),1*U(A,A,1*C1(C1(C1(U))))><L,U><L,U><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4EV)
                 (@ a_a4EW)
                 ($dSemigroup_a4EX [Occ=Once] :: Semigroup b_a4EV)
                 (@ b1_a4Fc)
                 ($dIntegral_a4Fe [Occ=Once] :: Integral b1_a4Fc)
                 (n_a3aX [Occ=Once] :: b1_a4Fc)
                 (f_a3aY [Occ=Once!] :: a_a4EW -> b_a4EV)
                 (e_a3aZ [Occ=Once] :: a_a4EW) ->
                 stimes
                   @ b_a4EV
                   $dSemigroup_a4EX
                   @ b1_a4Fc
                   $dIntegral_a4Fe
                   n_a3aX
                   (f_a3aY e_a3aZ)}]
GHC.Base.$fSemigroup(->)_$cstimes
  = \ (@ b_a4EV)
      (@ a_a4EW)
      ($dSemigroup_a4EX :: Semigroup b_a4EV)
      (@ b1_a4Fc)
      ($dIntegral_a4Fe :: Integral b1_a4Fc)
      (n_a3aX :: b1_a4Fc)
      (f_a3aY :: a_a4EW -> b_a4EV)
      (e_a3aZ :: a_a4EW) ->
      stimes
        @ b_a4EV
        $dSemigroup_a4EX
        @ b1_a4Fc
        $dIntegral_a4Fe
        n_a3aX
        (f_a3aY e_a3aZ)

-- RHS size: {terms: 10, types: 14, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall b a. Semigroup b => Semigroup (a -> b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m,
 Unf=DFun: \ (@ b_a3aS) (@ a_a3aT) (v_XbA :: Semigroup b_a3aS) ->
       GHC.Base.C:Semigroup TYPE: a_a3aT -> b_a3aS
                            GHC.Base.$fSemigroup(->)_$c<> @ b_a3aS @ a_a3aT v_XbA
                            GHC.Base.$fSemigroup(->)_$csconcat @ b_a3aS @ a_a3aT v_XbA
                            GHC.Base.$fSemigroup(->)_$cstimes @ b_a3aS @ a_a3aT v_XbA]
GHC.Base.$fSemigroup(->)
  = \ (@ b_a4EV) (@ a_a4EW) ($dSemigroup_a4EX :: Semigroup b_a4EV) ->
      GHC.Base.C:Semigroup
        @ (a_a4EW -> b_a4EV)
        (GHC.Base.$fSemigroup(->)_$c<> @ b_a4EV @ a_a4EW $dSemigroup_a4EX)
        (GHC.Base.$fSemigroup(->)_$csconcat
           @ b_a4EV @ a_a4EW $dSemigroup_a4EX)
        (GHC.Base.$fSemigroup(->)_$cstimes
           @ b_a4EV @ a_a4EW $dSemigroup_a4EX)

-- RHS size: {terms: 6, types: 9, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid(->)_$cp1Monoid
  :: forall b a. Monoid b => Semigroup (a -> b)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4zA)
                 (@ a_a4zB)
                 ($dMonoid_a4zC [Occ=Once] :: Monoid b_a4zA) ->
                 GHC.Base.$fSemigroup(->)
                   @ b_a4zA @ a_a4zB (GHC.Base.$p1Monoid @ b_a4zA $dMonoid_a4zC)}]
GHC.Base.$fMonoid(->)_$cp1Monoid
  = \ (@ b_a4zA) (@ a_a4zB) ($dMonoid_a4zC :: Monoid b_a4zA) ->
      GHC.Base.$fSemigroup(->)
        @ b_a4zA @ a_a4zB (GHC.Base.$p1Monoid @ b_a4zA $dMonoid_a4zC)

-- RHS size: {terms: 15, types: 17, coercions: 0, joins: 0/1}
GHC.Base.$fMonoid(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall b a. Monoid b => Monoid (a -> b)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m,
 Unf=DFun: \ (@ b_a3aQ) (@ a_a3aR) (v_XbC :: Monoid b_a3aQ) ->
       GHC.Base.C:Monoid TYPE: a_a3aR -> b_a3aQ
                         GHC.Base.$fMonoid(->)_$cp1Monoid @ b_a3aQ @ a_a3aR v_XbC
                         \ _ [Occ=Dead] -> mempty @ b_a3aQ v_XbC
                         GHC.Base.$fMonoid(->)_$cmappend @ b_a3aQ @ a_a3aR v_XbC
                         GHC.Base.$fMonoid(->)_$cmconcat @ b_a3aQ @ a_a3aR v_XbC]
GHC.Base.$fMonoid(->)
  = \ (@ b_a4zA) (@ a_a4zB) ($dMonoid_a4zC :: Monoid b_a4zA) ->
      let {
        lvl3_s5w6 :: b_a4zA
        [LclId]
        lvl3_s5w6 = mempty @ b_a4zA $dMonoid_a4zC } in
      GHC.Base.C:Monoid
        @ (a_a4zB -> b_a4zA)
        (GHC.Base.$fMonoid(->)_$cp1Monoid @ b_a4zA @ a_a4zB $dMonoid_a4zC)
        (\ _ [Occ=Dead] -> lvl3_s5w6)
        (GHC.Base.$fMonoid(->)_$cmappend @ b_a4zA @ a_a4zB $dMonoid_a4zC)
        (GHC.Base.$fMonoid(->)_$cmconcat @ b_a4zA @ a_a4zB $dMonoid_a4zC)

-- RHS size: {terms: 5, types: 8, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup[]_$cstimes
  :: forall a b. Integral b => b -> [a] -> [a]
[GblId,
 Arity=1,
 Str=<L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a4FL)
                 (@ b_a4FZ)
                 ($dIntegral_a4G1 [Occ=Once] :: Integral b_a4FZ) ->
                 stimesList @ b_a4FZ @ a_a4FL $dIntegral_a4G1}]
GHC.Base.$fSemigroup[]_$cstimes
  = \ (@ a_a4FL) (@ b_a4FZ) ($dIntegral_a4G1 :: Integral b_a4FZ) ->
      stimesList @ b_a4FZ @ a_a4FL $dIntegral_a4G1

-- RHS size: {terms: 5, types: 7, coercions: 0, joins: 0/0}
GHC.Base.$fSemigroup[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Semigroup [a]
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_a3b9) ->
       GHC.Base.C:Semigroup TYPE: [a_a3b9]
                            ++ @ a_a3b9
                            GHC.Base.$fSemigroup[]_$csconcat @ a_a3b9
                            GHC.Base.$fSemigroup[]_$cstimes @ a_a3b9]
GHC.Base.$fSemigroup[]
  = \ (@ a_a4FL) ->
      GHC.Base.C:Semigroup
        @ [a_a4FL]
        (++ @ a_a4FL)
        (GHC.Base.$fSemigroup[]_$csconcat @ a_a4FL)
        (GHC.Base.$fSemigroup[]_$cstimes @ a_a4FL)

-- RHS size: {terms: 6, types: 8, coercions: 0, joins: 0/0}
GHC.Base.$fMonoid[] [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Monoid [a]
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_a3b5) ->
       GHC.Base.C:Monoid TYPE: [a_a3b5]
                         GHC.Base.$fSemigroup[] @ a_a3b5
                         GHC.Types.[] @ a_a3b5
                         ++ @ a_a3b5
                         GHC.Base.$fMonoid[]_$cmconcat @ a_a3b5]
GHC.Base.$fMonoid[]
  = \ (@ a_a4zZ) ->
      GHC.Base.C:Monoid
        @ [a_a4zZ]
        (GHC.Base.$fSemigroup[] @ a_a4zZ)
        (GHC.Types.[] @ a_a4zZ)
        (++ @ a_a4zZ)
        (GHC.Base.$fMonoid[]_$cmconcat @ a_a4zZ)

-- RHS size: {terms: 5, types: 5, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeNonEmpty_$cpure :: forall a. a -> NonEmpty a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Gh) (a1_a38C [Occ=Once] :: a_a4Gh) ->
                 GHC.Base.:| @ a_a4Gh a1_a38C (GHC.Types.[] @ a_a4Gh)}]
GHC.Base.$fApplicativeNonEmpty_$cpure
  = \ (@ a_a4Gh) (a1_a38C :: a_a4Gh) ->
      GHC.Base.:| @ a_a4Gh a1_a38C (GHC.Types.[] @ a_a4Gh)

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
GHC.Base.$w$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c) -> NonEmpty a -> NonEmpty b -> (# c, [c] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(U,U)><L,U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 140 0}]
GHC.Base.$w$cliftA2
  = \ (@ a_s6R1)
      (@ b_s6R2)
      (@ c_s6R3)
      (w_s6R4 :: a_s6R1 -> b_s6R2 -> c_s6R3)
      (w1_s6R5 :: NonEmpty a_s6R1)
      (w2_s6R6 :: NonEmpty b_s6R2) ->
      GHC.Base.$w$c>>=
        @ a_s6R1
        @ c_s6R3
        w1_s6R5
        (\ (x1_a3dX :: a_s6R1) ->
           case GHC.Base.$w$c>>=
                  @ b_s6R2
                  @ c_s6R3
                  w2_s6R6
                  (\ (x2_a3dY :: b_s6R2) ->
                     GHC.Base.:|
                       @ c_s6R3 (w_s6R4 x1_a3dX x2_a3dY) (GHC.Types.[] @ c_s6R3))
           of
           { (# ww1_s6RF, ww2_s6RG #) ->
           GHC.Base.:| @ c_s6R3 ww1_s6RF ww2_s6RG
           })

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeNonEmpty_$cliftA2 [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(U,U)><L,U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6R1)
                 (@ b_s6R2)
                 (@ c_s6R3)
                 (w_s6R4 [Occ=Once] :: a_s6R1 -> b_s6R2 -> c_s6R3)
                 (w1_s6R5 [Occ=Once] :: NonEmpty a_s6R1)
                 (w2_s6R6 [Occ=Once] :: NonEmpty b_s6R2) ->
                 case GHC.Base.$w$cliftA2
                        @ a_s6R1 @ b_s6R2 @ c_s6R3 w_s6R4 w1_s6R5 w2_s6R6
                 of
                 { (# ww1_s6SM [Occ=Once], ww2_s6SN [Occ=Once] #) ->
                 GHC.Base.:| @ c_s6R3 ww1_s6SM ww2_s6SN
                 }}]
GHC.Base.$fApplicativeNonEmpty_$cliftA2
  = \ (@ a_s6R1)
      (@ b_s6R2)
      (@ c_s6R3)
      (w_s6R4 :: a_s6R1 -> b_s6R2 -> c_s6R3)
      (w1_s6R5 :: NonEmpty a_s6R1)
      (w2_s6R6 :: NonEmpty b_s6R2) ->
      case GHC.Base.$w$cliftA2
             @ a_s6R1 @ b_s6R2 @ c_s6R3 w_s6R4 w1_s6R5 w2_s6R6
      of
      { (# ww1_s6SM, ww2_s6SN #) ->
      GHC.Base.:| @ c_s6R3 ww1_s6SM ww2_s6SN
      }

-- RHS size: {terms: 20, types: 28, coercions: 0, joins: 0/1}
GHC.Base.$w$c<* [InlPrag=NOUSERINLINE[0]]
  :: forall a b. NonEmpty a -> NonEmpty b -> (# a, [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 120 0}]
GHC.Base.$w$c<*
  = \ (@ a_s6Rb)
      (@ b_s6Rc)
      (w_s6Rd :: NonEmpty a_s6Rb)
      (w1_s6Re :: NonEmpty b_s6Rc) ->
      GHC.Base.$w$c>>=
        @ a_s6Rb
        @ a_s6Rb
        w_s6Rd
        (\ (x1_a3dX :: a_s6Rb) ->
           let {
             lvl3_s5w7 [Dmd=<L,U(U,U)>] :: NonEmpty a_s6Rb
             [LclId, Unf=OtherCon []]
             lvl3_s5w7
               = GHC.Base.:| @ a_s6Rb x1_a3dX (GHC.Types.[] @ a_s6Rb) } in
           case GHC.Base.$w$c>>=
                  @ b_s6Rc @ a_s6Rb w1_s6Re (\ _ [Occ=Dead] -> lvl3_s5w7)
           of
           { (# ww1_s6RF, ww2_s6RG #) ->
           GHC.Base.:| @ a_s6Rb ww1_s6RF ww2_s6RG
           })

-- RHS size: {terms: 12, types: 20, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeNonEmpty_$c<* [InlPrag=NOUSERINLINE[0]]
  :: forall a b. NonEmpty a -> NonEmpty b -> NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6Rb)
                 (@ b_s6Rc)
                 (w_s6Rd [Occ=Once] :: NonEmpty a_s6Rb)
                 (w1_s6Re [Occ=Once] :: NonEmpty b_s6Rc) ->
                 case GHC.Base.$w$c<* @ a_s6Rb @ b_s6Rc w_s6Rd w1_s6Re of
                 { (# ww1_s6SP [Occ=Once], ww2_s6SQ [Occ=Once] #) ->
                 GHC.Base.:| @ a_s6Rb ww1_s6SP ww2_s6SQ
                 }}]
GHC.Base.$fApplicativeNonEmpty_$c<*
  = \ (@ a_s6Rb)
      (@ b_s6Rc)
      (w_s6Rd :: NonEmpty a_s6Rb)
      (w1_s6Re :: NonEmpty b_s6Rc) ->
      case GHC.Base.$w$c<* @ a_s6Rb @ b_s6Rc w_s6Rd w1_s6Re of
      { (# ww1_s6SP, ww2_s6SQ #) ->
      GHC.Base.:| @ a_s6Rb ww1_s6SP ww2_s6SQ
      }

-- RHS size: {terms: 19, types: 29, coercions: 0, joins: 0/0}
GHC.Base.$w$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b. NonEmpty (a -> b) -> NonEmpty a -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 130 0}]
GHC.Base.$w$c<*>
  = \ (@ a_s6Rj)
      (@ b_s6Rk)
      (w_s6Rl :: NonEmpty (a_s6Rj -> b_s6Rk))
      (w1_s6Rm :: NonEmpty a_s6Rj) ->
      GHC.Base.$w$c>>=
        @ (a_s6Rj -> b_s6Rk)
        @ b_s6Rk
        w_s6Rl
        (\ (x1_a3es :: a_s6Rj -> b_s6Rk) ->
           case GHC.Base.$w$c>>=
                  @ a_s6Rj
                  @ b_s6Rk
                  w1_s6Rm
                  (\ (x2_a3et :: a_s6Rj) ->
                     GHC.Base.:| @ b_s6Rk (x1_a3es x2_a3et) (GHC.Types.[] @ b_s6Rk))
           of
           { (# ww1_s6RF, ww2_s6RG #) ->
           GHC.Base.:| @ b_s6Rk ww1_s6RF ww2_s6RG
           })

-- RHS size: {terms: 12, types: 21, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeNonEmpty_$c<*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b. NonEmpty (a -> b) -> NonEmpty a -> NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U,U)><L,U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6Rj)
                 (@ b_s6Rk)
                 (w_s6Rl [Occ=Once] :: NonEmpty (a_s6Rj -> b_s6Rk))
                 (w1_s6Rm [Occ=Once] :: NonEmpty a_s6Rj) ->
                 case GHC.Base.$w$c<*> @ a_s6Rj @ b_s6Rk w_s6Rl w1_s6Rm of
                 { (# ww1_s6SS [Occ=Once], ww2_s6ST [Occ=Once] #) ->
                 GHC.Base.:| @ b_s6Rk ww1_s6SS ww2_s6ST
                 }}]
GHC.Base.$fApplicativeNonEmpty_$c<*>
  = \ (@ a_s6Rj)
      (@ b_s6Rk)
      (w_s6Rl :: NonEmpty (a_s6Rj -> b_s6Rk))
      (w1_s6Rm :: NonEmpty a_s6Rj) ->
      case GHC.Base.$w$c<*> @ a_s6Rj @ b_s6Rk w_s6Rl w1_s6Rm of
      { (# ww1_s6SS, ww2_s6ST #) ->
      GHC.Base.:| @ b_s6Rk ww1_s6SS ww2_s6ST
      }

-- RHS size: {terms: 5, types: 6, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeNonEmpty1 :: forall b a. a -> b -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)}]
GHC.Base.$fApplicativeNonEmpty1
  = \ (@ b_s6Rs) (@ a_s6Rr) _ [Occ=Dead] (eta_XbN :: b_s6Rs) ->
      eta_XbN

-- RHS size: {terms: 19, types: 33, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeNonEmpty_$c*> [InlPrag=NOUSERINLINE[0]]
  :: forall a b. NonEmpty a -> NonEmpty b -> NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U)><L,U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s6Rr)
                 (@ b_s6Rs)
                 (w_s6Rt [Occ=Once!] :: NonEmpty a_s6Rr)
                 (w1_s6Ru [Occ=Once] :: NonEmpty b_s6Rs) ->
                 case GHC.Base.$w$c<*>
                        @ b_s6Rs
                        @ b_s6Rs
                        (GHC.Base.:|
                           @ (b_s6Rs -> b_s6Rs)
                           (breakpoint @ b_s6Rs)
                           (case w_s6Rt of { :| _ [Occ=Dead] as_a38H [Occ=Once] ->
                            map
                              @ a_s6Rr
                              @ (b_s6Rs -> b_s6Rs)
                              (GHC.Base.$fApplicativeNonEmpty1 @ b_s6Rs @ a_s6Rr)
                              as_a38H
                            }))
                        w1_s6Ru
                 of
                 { (# ww1_s6SV [Occ=Once], ww2_s6SW [Occ=Once] #) ->
                 GHC.Base.:| @ b_s6Rs ww1_s6SV ww2_s6SW
                 }}]
GHC.Base.$fApplicativeNonEmpty_$c*>
  = \ (@ a_s6Rr)
      (@ b_s6Rs)
      (w_s6Rt :: NonEmpty a_s6Rr)
      (w1_s6Ru :: NonEmpty b_s6Rs) ->
      case GHC.Base.$w$c<*>
             @ b_s6Rs
             @ b_s6Rs
             (GHC.Base.:|
                @ (b_s6Rs -> b_s6Rs)
                (breakpoint @ b_s6Rs)
                (case w_s6Rt of { :| ds_d5aq as_a38H ->
                 map
                   @ a_s6Rr
                   @ (b_s6Rs -> b_s6Rs)
                   (GHC.Base.$fApplicativeNonEmpty1 @ b_s6Rs @ a_s6Rr)
                   as_a38H
                 }))
             w1_s6Ru
      of
      { (# ww1_s6SV, ww2_s6SW #) ->
      GHC.Base.:| @ b_s6Rs ww1_s6SV ww2_s6SW
      }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative NonEmpty
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: NonEmpty
                              GHC.Base.$fFunctorNonEmpty
                              GHC.Base.$fApplicativeNonEmpty_$cpure
                              GHC.Base.$fApplicativeNonEmpty_$c<*>
                              GHC.Base.$fApplicativeNonEmpty_$cliftA2
                              GHC.Base.$fApplicativeNonEmpty_$c*>
                              GHC.Base.$fApplicativeNonEmpty_$c<*]
GHC.Base.$fApplicativeNonEmpty
  = GHC.Base.C:Applicative
      @ NonEmpty
      GHC.Base.$fFunctorNonEmpty
      GHC.Base.$fApplicativeNonEmpty_$cpure
      GHC.Base.$fApplicativeNonEmpty_$c<*>
      GHC.Base.$fApplicativeNonEmpty_$cliftA2
      GHC.Base.$fApplicativeNonEmpty_$c*>
      GHC.Base.$fApplicativeNonEmpty_$c<*

-- RHS size: {terms: 4, types: 7, coercions: 0, joins: 0/0}
lvl_r7PJ :: forall a. [Char] -> NonEmpty a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
lvl_r7PJ
  = \ (@ a_a4sZ) (eta_XbL :: [Char]) ->
      errorWithoutStackTrace @ 'LiftedRep @ (NonEmpty a_a4sZ) eta_XbL

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fMonadNonEmpty [InlPrag=NOUSERINLINE CONLIKE]
  :: Monad NonEmpty
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: NonEmpty
                        GHC.Base.$fApplicativeNonEmpty
                        GHC.Base.$fMonadNonEmpty_$c>>=
                        GHC.Base.$fMonadNonEmpty_$c>>
                        GHC.Base.$fApplicativeNonEmpty_$cpure
                        \ (@ a_a4sZ) ->
                          errorWithoutStackTrace @ 'LiftedRep @ (NonEmpty a_a4sZ)]
GHC.Base.$fMonadNonEmpty
  = GHC.Base.C:Monad
      @ NonEmpty
      GHC.Base.$fApplicativeNonEmpty
      GHC.Base.$fMonadNonEmpty_$c>>=
      GHC.Base.$fMonadNonEmpty_$c>>
      GHC.Base.$fApplicativeNonEmpty_$cpure
      lvl_r7PJ

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$fAlternativeIO4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
GHC.Base.$fAlternativeIO4 = "mzero"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Base.$fAlternativeIO3 :: [Char]
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=True,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Base.$fAlternativeIO3
  = unpackCString# GHC.Base.$fAlternativeIO4

-- RHS size: {terms: 3, types: 3, coercions: 0, joins: 0/0}
GHC.Base.$fAlternativeIO_$cempty :: forall a. IO a
[GblId,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
GHC.Base.$fAlternativeIO_$cempty
  = \ (@ a_a4HB) -> failIO @ a_a4HB GHC.Base.$fAlternativeIO3

-- RHS size: {terms: 6, types: 1, coercions: 10, joins: 0/0}
GHC.Base.$fAlternativeIO [InlPrag=NOUSERINLINE CONLIKE]
  :: Alternative IO
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Alternative TYPE: IO
                              GHC.Base.$fApplicativeIO
                              GHC.Base.$fAlternativeIO_$cempty
                              mplusIO
                              GHC.Base.$fAlternativeIO2
                              `cast` (forall (a :: <*>_N).
                                      <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <[a]>_R)
                                      :: (forall a.
                                          IO a
                                          -> State# RealWorld -> (# State# RealWorld, [a] #) :: *)
                                         ~R# (forall a. IO a -> IO [a] :: *))
                              GHC.Base.$fAlternativeIO_$cmany]
GHC.Base.$fAlternativeIO
  = GHC.Base.C:Alternative
      @ IO
      GHC.Base.$fApplicativeIO
      GHC.Base.$fAlternativeIO_$cempty
      mplusIO
      (GHC.Base.$fAlternativeIO2
       `cast` (forall (a :: <*>_N).
               <IO a>_R ->_R Sym (GHC.Types.N:IO[0] <[a]>_R)
               :: (forall a.
                   IO a -> State# RealWorld -> (# State# RealWorld, [a] #) :: *)
                  ~R# (forall a. IO a -> IO [a] :: *)))
      GHC.Base.$fAlternativeIO_$cmany

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fMonadPlusIO [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadPlus IO
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:MonadPlus TYPE: IO
                            GHC.Base.$fAlternativeIO
                            GHC.Base.$fMonadIO
                            GHC.Base.$fAlternativeIO_$cempty
                            mplusIO]
GHC.Base.$fMonadPlusIO
  = GHC.Base.C:MonadPlus
      @ IO
      GHC.Base.$fAlternativeIO
      GHC.Base.$fMonadIO
      GHC.Base.$fAlternativeIO_$cempty
      mplusIO

-- RHS size: {terms: 9, types: 9, coercions: 0, joins: 0/0}
GHC.Base.$fAlternativeMaybe_$c<|>
  :: forall a. Maybe a -> Maybe a -> Maybe a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4IM)
                 (ds_d5aw [Occ=Once!] :: Maybe a_a4IM)
                 (r_a38I [Occ=Once] :: Maybe a_a4IM) ->
                 case ds_d5aw of wild_X5I {
                   Nothing -> r_a38I;
                   Just _ [Occ=Dead] -> wild_X5I
                 }}]
GHC.Base.$fAlternativeMaybe_$c<|>
  = \ (@ a_a4IM)
      (ds_d5aw :: Maybe a_a4IM)
      (r_a38I :: Maybe a_a4IM) ->
      case ds_d5aw of wild_X5I {
        Nothing -> r_a38I;
        Just ipv_s5cx -> wild_X5I
      }

-- RHS size: {terms: 20, types: 22, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeMaybe_$cliftA2
  :: forall a b c. (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4L7)
                 (@ b_a4L8)
                 (@ c_a4L9)
                 (f_a38P [Occ=Once!] :: a_a4L7 -> b_a4L8 -> c_a4L9)
                 (ds_d5br [Occ=Once!] :: Maybe a_a4L7)
                 (ds1_d5bs [Occ=Once!] :: Maybe b_a4L8) ->
                 case ds_d5br of {
                   Nothing -> GHC.Base.Nothing @ c_a4L9;
                   Just x_a38Q [Occ=Once] ->
                     case ds1_d5bs of {
                       Nothing -> GHC.Base.Nothing @ c_a4L9;
                       Just y_a38R [Occ=Once] ->
                         GHC.Base.Just @ c_a4L9 (f_a38P x_a38Q y_a38R)
                     }
                 }}]
GHC.Base.$fApplicativeMaybe_$cliftA2
  = \ (@ a_a4L7)
      (@ b_a4L8)
      (@ c_a4L9)
      (f_a38P :: a_a4L7 -> b_a4L8 -> c_a4L9)
      (ds_d5br :: Maybe a_a4L7)
      (ds1_d5bs :: Maybe b_a4L8) ->
      case ds_d5br of {
        Nothing -> GHC.Base.Nothing @ c_a4L9;
        Just x_a38Q ->
          case ds1_d5bs of {
            Nothing -> GHC.Base.Nothing @ c_a4L9;
            Just y_a38R -> GHC.Base.Just @ c_a4L9 (f_a38P x_a38Q y_a38R)
          }
      }

-- RHS size: {terms: 10, types: 12, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeMaybe_$c*>
  :: forall a b. Maybe a -> Maybe b -> Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Lg)
                 (@ b_a4Lh)
                 (ds_d5bF [Occ=Once!] :: Maybe a_a4Lg)
                 (m2_a38T [Occ=Once] :: Maybe b_a4Lh) ->
                 case ds_d5bF of {
                   Nothing -> GHC.Base.Nothing @ b_a4Lh;
                   Just _ [Occ=Dead] -> m2_a38T
                 }}]
GHC.Base.$fApplicativeMaybe_$c*>
  = \ (@ a_a4Lg)
      (@ b_a4Lh)
      (ds_d5bF :: Maybe a_a4Lg)
      (m2_a38T :: Maybe b_a4Lh) ->
      case ds_d5bF of {
        Nothing -> GHC.Base.Nothing @ b_a4Lh;
        Just _m1_a38S -> m2_a38T
      }

-- RHS size: {terms: 10, types: 12, coercions: 0, joins: 0/0}
GHC.Base.$fApplicative(->)_$c<*>
  :: forall a1 a2 b. (a1 -> a2 -> b) -> (a1 -> a2) -> a1 -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Lw)
                 (@ a1_a4LL)
                 (@ b_a4LM)
                 (f_a396 [Occ=Once!] :: a_a4Lw -> a1_a4LL -> b_a4LM)
                 (g_a397 [Occ=Once!] :: a_a4Lw -> a1_a4LL)
                 (x_a398 :: a_a4Lw) ->
                 f_a396 x_a398 (g_a397 x_a398)}]
GHC.Base.$fApplicative(->)_$c<*>
  = \ (@ a_a4Lw)
      (@ a1_a4LL)
      (@ b_a4LM)
      (f_a396 :: a_a4Lw -> a1_a4LL -> b_a4LM)
      (g_a397 :: a_a4Lw -> a1_a4LL)
      (x_a398 :: a_a4Lw) ->
      f_a396 x_a398 (g_a397 x_a398)

-- RHS size: {terms: 13, types: 16, coercions: 0, joins: 0/0}
GHC.Base.$fApplicative(->)_$cliftA2
  :: forall a1 a2 b c.
     (a2 -> b -> c) -> (a1 -> a2) -> (a1 -> b) -> a1 -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,1*C1(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Lw)
                 (@ a1_a4LR)
                 (@ b_a4LS)
                 (@ c_a4LT)
                 (q_a399 [Occ=Once!] :: a1_a4LR -> b_a4LS -> c_a4LT)
                 (f_a39a [Occ=Once!] :: a_a4Lw -> a1_a4LR)
                 (g_a39b [Occ=Once!] :: a_a4Lw -> b_a4LS)
                 (x_a39c :: a_a4Lw) ->
                 q_a399 (f_a39a x_a39c) (g_a39b x_a39c)}]
GHC.Base.$fApplicative(->)_$cliftA2
  = \ (@ a_a4Lw)
      (@ a1_a4LR)
      (@ b_a4LS)
      (@ c_a4LT)
      (q_a399 :: a1_a4LR -> b_a4LS -> c_a4LT)
      (f_a39a :: a_a4Lw -> a1_a4LR)
      (g_a39b :: a_a4Lw -> b_a4LS)
      (x_a39c :: a_a4Lw) ->
      q_a399 (f_a39a x_a39c) (g_a39b x_a39c)

-- RHS size: {terms: 9, types: 15, coercions: 0, joins: 0/0}
GHC.Base.$fApplicative(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Applicative ((->) a)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ a_a395) ->
       GHC.Base.C:Applicative TYPE: (->) a_a395
                              GHC.Base.$fFunctor(->) @ a_a395
                              \ (@ a1_a4LE) -> const @ a1_a4LE @ a_a395
                              GHC.Base.$fApplicative(->)_$c<*> @ a_a395
                              GHC.Base.$fApplicative(->)_$cliftA2 @ a_a395
                              GHC.Base.$fApplicative(->)_$c*> @ a_a395
                              GHC.Base.$fApplicative(->)_$c<* @ a_a395]
GHC.Base.$fApplicative(->)
  = \ (@ a_a4Lw) ->
      GHC.Base.C:Applicative
        @ ((->) a_a4Lw)
        (GHC.Base.$fFunctor(->) @ a_a4Lw)
        (\ (@ a1_a4LE) -> const @ a1_a4LE @ a_a4Lw)
        (GHC.Base.$fApplicative(->)_$c<*> @ a_a4Lw)
        (GHC.Base.$fApplicative(->)_$cliftA2 @ a_a4Lw)
        (GHC.Base.$fApplicative(->)_$c*> @ a_a4Lw)
        (GHC.Base.$fApplicative(->)_$c<* @ a_a4Lw)

-- RHS size: {terms: 5, types: 9, coercions: 0, joins: 0/0}
lvl1_r7PK :: forall r a. [Char] -> r -> a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
lvl1_r7PK
  = \ (@ r_a4tI) (@ a_a4ue) (eta_XbX :: [Char]) ->
      errorWithoutStackTrace @ 'LiftedRep @ (r_a4tI -> a_a4ue) eta_XbX

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
GHC.Base.$fMonad(->) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall r. Monad ((->) r)
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ (@ r_a391) ->
       GHC.Base.C:Monad TYPE: (->) r_a391
                        GHC.Base.$fApplicative(->) @ r_a391
                        GHC.Base.$fMonad(->)_$c>>= @ r_a391
                        GHC.Base.$fMonad(->)_$c>> @ r_a391
                        \ (@ a_a4u6) -> const @ a_a4u6 @ r_a391
                        \ (@ a_a4ue) ->
                          errorWithoutStackTrace @ 'LiftedRep @ (r_a391 -> a_a4ue)]
GHC.Base.$fMonad(->)
  = \ (@ r_a4tI) ->
      GHC.Base.C:Monad
        @ ((->) r_a4tI)
        (GHC.Base.$fApplicative(->) @ r_a4tI)
        (GHC.Base.$fMonad(->)_$c>>= @ r_a4tI)
        (GHC.Base.$fMonad(->)_$c>> @ r_a4tI)
        (\ (@ a_a4LE) -> const @ a_a4LE @ r_a4tI)
        (lvl1_r7PK @ r_a4tI)

-- RHS size: {terms: 12, types: 13, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeMaybe_$cfmap
  :: forall a b. (a -> b) -> Maybe a -> Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4ME)
                 (@ b_a4MF)
                 (ds_d5bO [Occ=Once!] :: a_a4ME -> b_a4MF)
                 (ds1_d5bP [Occ=Once!] :: Maybe a_a4ME) ->
                 case ds1_d5bP of {
                   Nothing -> GHC.Base.Nothing @ b_a4MF;
                   Just a1_a38W [Occ=Once] -> GHC.Base.Just @ b_a4MF (ds_d5bO a1_a38W)
                 }}]
GHC.Base.$fApplicativeMaybe_$cfmap
  = \ (@ a_a4ME)
      (@ b_a4MF)
      (ds_d5bO :: a_a4ME -> b_a4MF)
      (ds1_d5bP :: Maybe a_a4ME) ->
      case ds1_d5bP of {
        Nothing -> GHC.Base.Nothing @ b_a4MF;
        Just a1_a38W -> GHC.Base.Just @ b_a4MF (ds_d5bO a1_a38W)
      }

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fFunctorMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Functor Maybe
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Functor TYPE: Maybe
                          GHC.Base.$fApplicativeMaybe_$cfmap
                          GHC.Base.$fFunctorMaybe_$c<$]
GHC.Base.$fFunctorMaybe
  = GHC.Base.C:Functor
      @ Maybe
      GHC.Base.$fApplicativeMaybe_$cfmap
      GHC.Base.$fFunctorMaybe_$c<$

-- RHS size: {terms: 12, types: 17, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeMaybe_$c<*>
  :: forall a b. Maybe (a -> b) -> Maybe a -> Maybe b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4KV)
                 (@ b_a4KW)
                 (ds_d5bm [Occ=Once!] :: Maybe (a_a4KV -> b_a4KW))
                 (m_a38N [Occ=Once] :: Maybe a_a4KV) ->
                 case ds_d5bm of {
                   Nothing -> GHC.Base.Nothing @ b_a4KW;
                   Just f_a38M [Occ=Once] ->
                     GHC.Base.$fApplicativeMaybe_$cfmap @ a_a4KV @ b_a4KW f_a38M m_a38N
                 }}]
GHC.Base.$fApplicativeMaybe_$c<*>
  = \ (@ a_a4KV)
      (@ b_a4KW)
      (ds_d5bm :: Maybe (a_a4KV -> b_a4KW))
      (m_a38N :: Maybe a_a4KV) ->
      case ds_d5bm of {
        Nothing -> GHC.Base.Nothing @ b_a4KW;
        Just f_a38M ->
          GHC.Base.$fApplicativeMaybe_$cfmap @ a_a4KV @ b_a4KW f_a38M m_a38N
      }

-- RHS size: {terms: 7, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fApplicativeMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Applicative Maybe
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Applicative TYPE: Maybe
                              GHC.Base.$fFunctorMaybe
                              GHC.Base.Just
                              GHC.Base.$fApplicativeMaybe_$c<*>
                              GHC.Base.$fApplicativeMaybe_$cliftA2
                              GHC.Base.$fApplicativeMaybe_$c*>
                              GHC.Base.$fApplicativeMaybe_$c<*]
GHC.Base.$fApplicativeMaybe
  = GHC.Base.C:Applicative
      @ Maybe
      GHC.Base.$fFunctorMaybe
      GHC.Base.Just
      GHC.Base.$fApplicativeMaybe_$c<*>
      GHC.Base.$fApplicativeMaybe_$cliftA2
      GHC.Base.$fApplicativeMaybe_$c*>
      GHC.Base.$fApplicativeMaybe_$c<*

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fMonadMaybe [InlPrag=NOUSERINLINE CONLIKE] :: Monad Maybe
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Monad TYPE: Maybe
                        GHC.Base.$fApplicativeMaybe
                        GHC.Base.$fMonadMaybe_$c>>=
                        GHC.Base.$fApplicativeMaybe_$c*>
                        GHC.Base.Just
                        GHC.Base.$fMonadMaybe_$cfail]
GHC.Base.$fMonadMaybe
  = GHC.Base.C:Monad
      @ Maybe
      GHC.Base.$fApplicativeMaybe
      GHC.Base.$fMonadMaybe_$c>>=
      GHC.Base.$fApplicativeMaybe_$c*>
      GHC.Base.Just
      GHC.Base.$fMonadMaybe_$cfail

-- RHS size: {terms: 6, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fAlternativeMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: Alternative Maybe
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:Alternative TYPE: Maybe
                              GHC.Base.$fApplicativeMaybe
                              GHC.Base.Nothing
                              GHC.Base.$fAlternativeMaybe_$c<|>
                              GHC.Base.$fAlternativeMaybe_$csome
                              GHC.Base.$fAlternativeMaybe_$cmany]
GHC.Base.$fAlternativeMaybe
  = GHC.Base.C:Alternative
      @ Maybe
      GHC.Base.$fApplicativeMaybe
      GHC.Base.Nothing
      GHC.Base.$fAlternativeMaybe_$c<|>
      GHC.Base.$fAlternativeMaybe_$csome
      GHC.Base.$fAlternativeMaybe_$cmany

-- RHS size: {terms: 5, types: 1, coercions: 0, joins: 0/0}
GHC.Base.$fMonadPlusMaybe [InlPrag=NOUSERINLINE CONLIKE]
  :: MonadPlus Maybe
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Base.C:MonadPlus TYPE: Maybe
                            GHC.Base.$fAlternativeMaybe
                            GHC.Base.$fMonadMaybe
                            GHC.Base.Nothing
                            GHC.Base.$fAlternativeMaybe_$c<|>]
GHC.Base.$fMonadPlusMaybe
  = GHC.Base.C:MonadPlus
      @ Maybe
      GHC.Base.$fAlternativeMaybe
      GHC.Base.$fMonadMaybe
      GHC.Base.Nothing
      GHC.Base.$fAlternativeMaybe_$c<|>

-- RHS size: {terms: 28, types: 31, coercions: 0, joins: 0/0}
GHC.Base.liftA3_$sliftA3 [InlPrag=INLINABLE]
  :: forall a1 a2 a3 r.
     (a1 -> a2 -> a3 -> r)
     -> Maybe a1 -> Maybe a2 -> Maybe a3 -> Maybe r
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a1_a4gF)
                 (@ a2_a4gG)
                 (@ a3_a4gH)
                 (@ r_a4gI)
                 (f_X3qB [Occ=Once!] :: a1_a4gF -> a2_a4gG -> a3_a4gH -> r_a4gI)
                 (a_X3qD [Occ=Once!] :: Maybe a1_a4gF)
                 (b_X3qF [Occ=Once!] :: Maybe a2_a4gG)
                 (c_X3qH [Occ=Once!] :: Maybe a3_a4gH) ->
                 case a_X3qD of {
                   Nothing -> GHC.Base.Nothing @ r_a4gI;
                   Just x_a38Q [Occ=Once] ->
                     case b_X3qF of {
                       Nothing -> GHC.Base.Nothing @ r_a4gI;
                       Just y_a38R [Occ=Once] ->
                         case c_X3qH of {
                           Nothing -> GHC.Base.Nothing @ r_a4gI;
                           Just a4_a38W [Occ=Once] ->
                             GHC.Base.Just @ r_a4gI (f_X3qB x_a38Q y_a38R a4_a38W)
                         }
                     }
                 }}]
GHC.Base.liftA3_$sliftA3
  = \ (@ a1_a4gF)
      (@ a2_a4gG)
      (@ a3_a4gH)
      (@ r_a4gI)
      (f_X3qB :: a1_a4gF -> a2_a4gG -> a3_a4gH -> r_a4gI)
      (a_X3qD :: Maybe a1_a4gF)
      (b_X3qF :: Maybe a2_a4gG)
      (c_X3qH :: Maybe a3_a4gH) ->
      case a_X3qD of {
        Nothing -> GHC.Base.Nothing @ r_a4gI;
        Just x_a38Q ->
          case b_X3qF of {
            Nothing -> GHC.Base.Nothing @ r_a4gI;
            Just y_a38R ->
              case c_X3qH of {
                Nothing -> GHC.Base.Nothing @ r_a4gI;
                Just a4_a38W ->
                  GHC.Base.Just @ r_a4gI (f_X3qB x_a38Q y_a38R a4_a38W)
              }
          }
      }

-- RHS size: {terms: 18, types: 32, coercions: 0, joins: 0/0}
liftA3 [InlPrag=INLINABLE]
  :: forall (f :: * -> *) a b c d.
     Applicative f =>
     (a -> b -> c -> d) -> f a -> f b -> f c -> f d
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(A,A,1*C1(C1(U)),1*C1(C1(C1(U))),A,A)><L,U><L,U><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a4f9 :: * -> *))
                 (@ a_a4fa)
                 (@ b_a4fb)
                 (@ c_a4fc)
                 (@ d_a4fd)
                 ($dApplicative_a4ff :: Applicative f_a4f9)
                 (f1_X3qF [Occ=Once] :: a_a4fa -> b_a4fb -> c_a4fc -> d_a4fd)
                 (a1_X3qH [Occ=Once] :: f_a4f9 a_a4fa)
                 (b1_X3qJ [Occ=Once] :: f_a4f9 b_a4fb)
                 (c1_X3qL [Occ=Once] :: f_a4f9 c_a4fc) ->
                 <*>
                   @ f_a4f9
                   $dApplicative_a4ff
                   @ c_a4fc
                   @ d_a4fd
                   (liftA2
                      @ f_a4f9
                      $dApplicative_a4ff
                      @ a_a4fa
                      @ b_a4fb
                      @ (c_a4fc -> d_a4fd)
                      f1_X3qF
                      a1_X3qH
                      b1_X3qJ)
                   c1_X3qL}]
liftA3
  = \ (@ (f_a4f9 :: * -> *))
      (@ a_a4fa)
      (@ b_a4fb)
      (@ c_a4fc)
      (@ d_a4fd)
      ($dApplicative_a4ff :: Applicative f_a4f9)
      (f1_X3qF :: a_a4fa -> b_a4fb -> c_a4fc -> d_a4fd)
      (a1_X3qH :: f_a4f9 a_a4fa)
      (b1_X3qJ :: f_a4f9 b_a4fb)
      (c1_X3qL :: f_a4f9 c_a4fc) ->
      <*>
        @ f_a4f9
        $dApplicative_a4ff
        @ c_a4fc
        @ d_a4fd
        (liftA2
           @ f_a4f9
           $dApplicative_a4ff
           @ a_a4fa
           @ b_a4fb
           @ (c_a4fc -> d_a4fd)
           f1_X3qF
           a1_X3qH
           b1_X3qJ)
        c1_X3qL

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Base.liftA_$sliftA [InlPrag=INLINABLE]
  :: forall a1 r. (a1 -> r) -> Maybe a1 -> Maybe r
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= GHC.Base.$fApplicativeMaybe_$cfmap}]
GHC.Base.liftA_$sliftA = GHC.Base.$fApplicativeMaybe_$cfmap

-- RHS size: {terms: 12, types: 20, coercions: 0, joins: 0/0}
liftA [InlPrag=INLINABLE]
  :: forall (f :: * -> *) a b.
     Applicative f =>
     (a -> b) -> f a -> f b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLL),U(A,1*C1(U),1*C1(C1(U)),A,A,A)><L,U><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ (f_a4gQ :: * -> *))
                 (@ a_a4gR)
                 (@ b_a4gS)
                 ($dApplicative_a4gU :: Applicative f_a4gQ)
                 (f1_X3qE [Occ=Once] :: a_a4gR -> b_a4gS)
                 (a1_X3qG [Occ=Once] :: f_a4gQ a_a4gR) ->
                 <*>
                   @ f_a4gQ
                   $dApplicative_a4gU
                   @ a_a4gR
                   @ b_a4gS
                   (pure @ f_a4gQ $dApplicative_a4gU @ (a_a4gR -> b_a4gS) f1_X3qE)
                   a1_X3qG}]
liftA
  = \ (@ (f_a4gQ :: * -> *))
      (@ a_a4gR)
      (@ b_a4gS)
      ($dApplicative_a4gU :: Applicative f_a4gQ)
      (f1_X3qE :: a_a4gR -> b_a4gS)
      (a1_X3qG :: f_a4gQ a_a4gR) ->
      <*>
        @ f_a4gQ
        $dApplicative_a4gU
        @ a_a4gR
        @ b_a4gS
        (pure @ f_a4gQ $dApplicative_a4gU @ (a_a4gR -> b_a4gS) f1_X3qE)
        a1_X3qG

-- RHS size: {terms: 12, types: 18, coercions: 0, joins: 0/0}
GHC.Base.$fFunctor(,)_$cfmap
  :: forall a1 a2 b. (a2 -> b) -> (a1, a2) -> (a1, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*C1(U)><S,1*U(U,U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4MV)
                 (@ a1_a4MZ)
                 (@ b_a4N0)
                 (f_a38Y [Occ=Once!] :: a1_a4MZ -> b_a4N0)
                 (ds_d5bV [Occ=Once!] :: (a_a4MV, a1_a4MZ)) ->
                 case ds_d5bV of { (x_a38Z [Occ=Once], y_a390 [Occ=Once]) ->
                 (x_a38Z, f_a38Y y_a390)
                 }}]
GHC.Base.$fFunctor(,)_$cfmap
  = \ (@ a_a4MV)
      (@ a1_a4MZ)
      (@ b_a4N0)
      (f_a38Y :: a1_a4MZ -> b_a4N0)
      (ds_d5bV :: (a_a4MV, a1_a4MZ)) ->
      case ds_d5bV of { (x_a38Z, y_a390) -> (x_a38Z, f_a38Y y_a390) }

-- RHS size: {terms: 4, types: 6, coercions: 0, joins: 0/0}
GHC.Base.$fFunctor(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Functor ((,) a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_a38X) ->
       GHC.Base.C:Functor TYPE: (,) a_a38X
                          GHC.Base.$fFunctor(,)_$cfmap @ a_a38X
                          GHC.Base.$fFunctor(,)_$c<$ @ a_a38X]
GHC.Base.$fFunctor(,)
  = \ (@ a_a4MV) ->
      GHC.Base.C:Functor
        @ ((,) a_a4MV)
        (GHC.Base.$fFunctor(,)_$cfmap @ a_a4MV)
        (GHC.Base.$fFunctor(,)_$c<$ @ a_a4MV)

-- RHS size: {terms: 20, types: 18, coercions: 0, joins: 0/1}
GHC.Base.$fApplicative(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Monoid a => Applicative ((,) a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,A),1*U,A,A)>m,
 Unf=DFun: \ (@ a_a39m) (v_Xcd :: Monoid a_a39m) ->
       GHC.Base.C:Applicative TYPE: (,) a_a39m
                              GHC.Base.$fFunctor(,) @ a_a39m
                              \ (@ a1_a4vE) (x_a39n [Occ=Once] :: a1_a4vE) ->
                                (mempty @ a_a39m v_Xcd, x_a39n)
                              GHC.Base.$fApplicative(,)_$c<*> @ a_a39m v_Xcd
                              GHC.Base.$fApplicative(,)_$cliftA2 @ a_a39m v_Xcd
                              GHC.Base.$fApplicative(,)_$c*> @ a_a39m v_Xcd
                              GHC.Base.$fApplicative(,)_$c<* @ a_a39m v_Xcd]
GHC.Base.$fApplicative(,)
  = \ (@ a_a4vv) ($dMonoid_a4vw :: Monoid a_a4vv) ->
      let {
        lvl3_s5wf :: a_a4vv
        [LclId]
        lvl3_s5wf = mempty @ a_a4vv $dMonoid_a4vw } in
      GHC.Base.C:Applicative
        @ ((,) a_a4vv)
        (GHC.Base.$fFunctor(,) @ a_a4vv)
        (\ (@ a1_a4vE) (x_a39n :: a1_a4vE) -> (lvl3_s5wf, x_a39n))
        (GHC.Base.$fApplicative(,)_$c<*> @ a_a4vv $dMonoid_a4vw)
        (GHC.Base.$fApplicative(,)_$cliftA2 @ a_a4vv $dMonoid_a4vw)
        (GHC.Base.$fApplicative(,)_$c*> @ a_a4vv $dMonoid_a4vw)
        (GHC.Base.$fApplicative(,)_$c<* @ a_a4vv $dMonoid_a4vw)

-- RHS size: {terms: 5, types: 10, coercions: 0, joins: 0/0}
lvl2_r7PL :: forall a1 a2. [Char] -> (a1, a2)
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []]
lvl2_r7PL
  = \ (@ a_a4ul) (@ a1_a4uX) (eta_Xcf :: [Char]) ->
      errorWithoutStackTrace @ 'LiftedRep @ (a_a4ul, a1_a4uX) eta_Xcf

-- RHS size: {terms: 18, types: 17, coercions: 0, joins: 0/1}
GHC.Base.$fMonad(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Monoid a => Monad ((,) a)
[GblId[DFunId],
 Arity=1,
 Str=<L,U(U(C(C1(U)),A,A),U,A,A)>m,
 Unf=DFun: \ (@ a_a39g) (v_Xcf :: Monoid a_a39g) ->
       GHC.Base.C:Monad TYPE: (,) a_a39g
                        GHC.Base.$fApplicative(,) @ a_a39g v_Xcf
                        GHC.Base.$fMonad(,)_$c>>= @ a_a39g v_Xcf
                        GHC.Base.$fMonad(,)_$c>> @ a_a39g v_Xcf
                        \ (@ a1_a4uP) (x_a39n [Occ=Once] :: a1_a4uP) ->
                          (mempty @ a_a39g v_Xcf, x_a39n)
                        \ (@ a1_a4uX) ->
                          errorWithoutStackTrace @ 'LiftedRep @ (a_a39g, a1_a4uX)]
GHC.Base.$fMonad(,)
  = \ (@ a_a4ul) ($dMonoid_a4um :: Monoid a_a4ul) ->
      let {
        lvl3_s5wg :: a_a4ul
        [LclId]
        lvl3_s5wg = mempty @ a_a4ul $dMonoid_a4um } in
      GHC.Base.C:Monad
        @ ((,) a_a4ul)
        (GHC.Base.$fApplicative(,) @ a_a4ul $dMonoid_a4um)
        (GHC.Base.$fMonad(,)_$c>>= @ a_a4ul $dMonoid_a4um)
        (GHC.Base.$fMonad(,)_$c>> @ a_a4ul $dMonoid_a4um)
        (\ (@ a1_a4uP) (x_a39n :: a1_a4uP) -> (lvl3_s5wg, x_a39n))
        (lvl2_r7PL @ a_a4ul)


------ Local rules for imported ids --------
"SPEC when"
    forall ($dApplicative_X4jc :: Applicative IO).
      when @ IO $dApplicative_X4jc
      = GHC.Base.when_$swhen1
"SPEC when"
    forall ($dApplicative_X4jn :: Applicative Maybe).
      when @ Maybe $dApplicative_X4jn
      = GHC.Base.when_$swhen
"SPEC ap"
    forall (@ a_a43G) (@ b_a43H) ($dMonad_a43L :: Monad IO).
      ap @ IO @ a_a43G @ b_a43H $dMonad_a43L
      = GHC.Base.ap_$sap1 @ a_a43G @ b_a43H
"SPEC ap"
    forall (@ a_a446) (@ b_a447) ($dMonad_a44b :: Monad Maybe).
      ap @ Maybe @ a_a446 @ b_a447 $dMonad_a44b
      = GHC.Base.ap_$sap @ a_a446 @ b_a447
"SPEC liftM2"
    forall (@ a1_a4bp)
           (@ a2_a4bq)
           (@ r_a4br)
           ($dMonad_a4bw :: Monad IO).
      liftM2 @ IO @ a1_a4bp @ a2_a4bq @ r_a4br $dMonad_a4bw
      = GHC.Base.liftM2_$sliftM1 @ a1_a4bp @ a2_a4bq @ r_a4br
"SPEC liftM2"
    forall (@ a1_a4bY)
           (@ a2_a4bZ)
           (@ r_a4c0)
           ($dMonad_a4c5 :: Monad Maybe).
      liftM2 @ Maybe @ a1_a4bY @ a2_a4bZ @ r_a4c0 $dMonad_a4c5
      = GHC.Base.liftM2_$sliftM2 @ a1_a4bY @ a2_a4bZ @ r_a4c0
"SPEC liftM5"
    forall (@ a1_X4hF)
           (@ a2_X4hH)
           (@ a3_X4hJ)
           (@ a4_X4hL)
           (@ a5_X4hN)
           (@ r_X4hP)
           ($dMonad_a45I :: Monad IO).
      liftM5 @ IO
             @ a1_X4hF
             @ a2_X4hH
             @ a3_X4hJ
             @ a4_X4hL
             @ a5_X4hN
             @ r_X4hP
             $dMonad_a45I
      = GHC.Base.liftM5_$sliftM1
          @ a1_X4hF @ a2_X4hH @ a3_X4hJ @ a4_X4hL @ a5_X4hN @ r_X4hP
"SPEC liftM5"
    forall (@ a1_a46v)
           (@ a2_a46w)
           (@ a3_a46x)
           (@ a4_a46y)
           (@ a5_a46z)
           (@ r_a46A)
           ($dMonad_a46I :: Monad Maybe).
      liftM5 @ Maybe
             @ a1_a46v
             @ a2_a46w
             @ a3_a46x
             @ a4_a46y
             @ a5_a46z
             @ r_a46A
             $dMonad_a46I
      = GHC.Base.liftM5_$sliftM5
          @ a1_a46v @ a2_a46w @ a3_a46x @ a4_a46y @ a5_a46z @ r_a46A
"SPEC liftM4"
    forall (@ a1_X4ke)
           (@ a2_X4kg)
           (@ a3_X4ki)
           (@ a4_X4kk)
           (@ r_X4km)
           ($dMonad_a481 :: Monad IO).
      liftM4 @ IO
             @ a1_X4ke
             @ a2_X4kg
             @ a3_X4ki
             @ a4_X4kk
             @ r_X4km
             $dMonad_a481
      = GHC.Base.liftM4_$sliftM1
          @ a1_X4ke @ a2_X4kg @ a3_X4ki @ a4_X4kk @ r_X4km
"SPEC liftM4"
    forall (@ a1_a48H)
           (@ a2_a48I)
           (@ a3_a48J)
           (@ a4_a48K)
           (@ r_a48L)
           ($dMonad_a48S :: Monad Maybe).
      liftM4 @ Maybe
             @ a1_a48H
             @ a2_a48I
             @ a3_a48J
             @ a4_a48K
             @ r_a48L
             $dMonad_a48S
      = GHC.Base.liftM4_$sliftM4
          @ a1_a48H @ a2_a48I @ a3_a48J @ a4_a48K @ r_a48L
"SPEC liftM3"
    forall (@ a1_X4mo)
           (@ a2_X4mq)
           (@ a3_X4ms)
           (@ r_X4mu)
           ($dMonad_a49X :: Monad IO).
      liftM3 @ IO @ a1_X4mo @ a2_X4mq @ a3_X4ms @ r_X4mu $dMonad_a49X
      = GHC.Base.liftM3_$sliftM1 @ a1_X4mo @ a2_X4mq @ a3_X4ms @ r_X4mu
"SPEC liftM3"
    forall (@ a1_a4aw)
           (@ a2_a4ax)
           (@ a3_a4ay)
           (@ r_a4az)
           ($dMonad_a4aF :: Monad Maybe).
      liftM3 @ Maybe @ a1_a4aw @ a2_a4ax @ a3_a4ay @ r_a4az $dMonad_a4aF
      = GHC.Base.liftM3_$sliftM3 @ a1_a4aw @ a2_a4ax @ a3_a4ay @ r_a4az
"SPEC liftM"
    forall (@ a1_X4pv) (@ r_X4px) ($dMonad_a4cI :: Monad IO).
      liftM @ IO @ a1_X4pv @ r_X4px $dMonad_a4cI
      = GHC.Base.liftM_$sliftM1 @ a1_X4pv @ r_X4px
"SPEC liftM"
    forall (@ a1_a4d3) (@ r_a4d4) ($dMonad_a4d8 :: Monad Maybe).
      liftM @ Maybe @ a1_a4d3 @ r_a4d4 $dMonad_a4d8
      = GHC.Base.liftM_$sliftM @ a1_a4d3 @ r_a4d4
"mapFB/id"
    forall (@ elt_a4PI)
           (@ lst_a4PJ)
           (c_a3gd :: elt_a4PI -> lst_a4PJ -> lst_a4PJ).
      mapFB @ elt_a4PI
            @ lst_a4PJ
            @ elt_a4PI
            c_a3gd
            (\ (x_a3ge :: elt_a4PI) -> x_a3ge)
      = c_a3gd
"mapFB"
    forall (@ a_a4Pt)
           (@ lst_a4Pz)
           (@ c_a4PC)
           (@ a1_a4Pw)
           (c1_a3ga :: c_a4PC -> lst_a4Pz -> lst_a4Pz)
           (f_a3gb :: a1_a4Pw -> c_a4PC)
           (g_a3gc :: a_a4Pt -> a1_a4Pw).
      mapFB @ a1_a4Pw
            @ lst_a4Pz
            @ a_a4Pt
            (mapFB @ c_a4PC @ lst_a4Pz @ a1_a4Pw c1_a3ga f_a3gb)
            g_a3gc
      = mapFB
          @ c_a4PC
          @ lst_a4Pz
          @ a_a4Pt
          c1_a3ga
          (. @ a1_a4Pw @ c_a4PC @ a_a4Pt f_a3gb g_a3gc)
"augment/nil"
    forall (@ a_a3gM)
           (g_a3gL :: forall b. (a_a3gM -> b -> b) -> b -> b).
      augment @ a_a3gM g_a3gL (GHC.Types.[] @ a_a3gM)
      = build @ a_a3gM g_a3gL
"augment/build"
    forall (@ a_a3gG)
           (g_a3gE :: forall b. (a_a3gG -> b -> b) -> b -> b)
           (h_a3gF :: forall b. (a_a3gG -> b -> b) -> b -> b).
      augment @ a_a3gG g_a3gE (build @ a_a3gG h_a3gF)
      = build
          @ a_a3gG
          (\ (@ b_a4TU)
             (c_a3gJ :: a_a3gG -> b_a4TU -> b_a4TU)
             (n_a3gK :: b_a4TU) ->
             g_a3gE @ b_a4TU c_a3gJ (h_a3gF @ b_a4TU c_a3gJ n_a3gK))
"++" [~1]
    forall (@ a_a4Ok) (xs_a3g1 :: [a_a4Ok]) (ys_a3g2 :: [a_a4Ok]).
      ++ @ a_a4Ok xs_a3g1 ys_a3g2
      = augment
          @ a_a4Ok
          (\ (@ b_a4Om)
             (c_a3g3 :: a_a4Ok -> b_a4Om -> b_a4Om)
             (n_a3g4 :: b_a4Om) ->
             foldr @ a_a4Ok @ b_a4Om c_a3g3 n_a3g4 xs_a3g1)
          ys_a3g2
"foldr/cons/build"
    forall (@ b_a4SH)
           (@ a_a3gC)
           (k_a3gy :: a_a3gC -> b_a4SH -> b_a4SH)
           (z_a3gz :: b_a4SH)
           (x_a3gA :: a_a3gC)
           (g_a3gB :: forall b1. (a_a3gC -> b1 -> b1) -> b1 -> b1).
      foldr @ a_a3gC
            @ b_a4SH
            k_a3gy
            z_a3gz
            (GHC.Types.: @ a_a3gC x_a3gA (build @ a_a3gC g_a3gB))
      = k_a3gy x_a3gA (g_a3gB @ b_a4SH k_a3gy z_a3gz)
"foldr/nil"
    forall (@ b_a4RZ)
           (@ a_a4RY)
           (k_a3gw :: a_a4RY -> b_a4RZ -> b_a4RZ)
           (z_a3gx :: b_a4RZ).
      foldr @ a_a4RY @ b_a4RZ k_a3gw z_a3gx (GHC.Types.[] @ a_a4RY)
      = z_a3gx
"foldr/single"
    forall (@ b_a4RQ)
           (@ a_a4RP)
           (k_a3gt :: a_a4RP -> b_a4RQ -> b_a4RQ)
           (z_a3gu :: b_a4RQ)
           (x_a3gv :: a_a4RP).
      foldr @ a_a4RP
            @ b_a4RQ
            k_a3gt
            z_a3gu
            (GHC.Types.: @ a_a4RP x_a3gv (GHC.Types.[] @ a_a4RP))
      = k_a3gt x_a3gv z_a3gu
"foldr/app" [1]
    forall (@ a_a4RG) (ys_a3gr :: [a_a4RG]).
      foldr @ a_a4RG @ [a_a4RG] (GHC.Types.: @ a_a4RG) ys_a3gr
      = \ (xs_a3gs :: [a_a4RG]) -> ++ @ a_a4RG xs_a3gs ys_a3gr
"foldr/id"
    forall (@ a_a4Rw).
      foldr @ a_a4Rw
            @ [a_a4Rw]
            (GHC.Types.: @ a_a4Rw)
            (GHC.Types.[] @ a_a4Rw)
      = \ (x_a3gq :: [a_a4Rw]) -> x_a3gq
"foldr/augment"
    forall (@ b_a4Rh)
           (@ a_a3go)
           (k_a3gk :: a_a3go -> b_a4Rh -> b_a4Rh)
           (z_a3gl :: b_a4Rh)
           (xs_a3gm :: [a_a3go])
           (g_a3gn :: forall b1. (a_a3go -> b1 -> b1) -> b1 -> b1).
      foldr @ a_a3go
            @ b_a4Rh
            k_a3gk
            z_a3gl
            (augment @ a_a3go g_a3gn xs_a3gm)
      = g_a3gn
          @ b_a4Rh k_a3gk (foldr @ a_a3go @ b_a4Rh k_a3gk z_a3gl xs_a3gm)
"fold/build"
    forall (@ b_a4Qp)
           (@ a_a3gi)
           (k_a3gf :: a_a3gi -> b_a4Qp -> b_a4Qp)
           (z_a3gg :: b_a4Qp)
           (g_a3gh :: forall b1. (a_a3gi -> b1 -> b1) -> b1 -> b1).
      foldr @ a_a3gi @ b_a4Qp k_a3gf z_a3gg (build @ a_a3gi g_a3gh)
      = g_a3gh @ b_a4Qp k_a3gf z_a3gg
"mapList" [1]
    forall (@ a_a4Pe) (@ b_a4Pi) (f_a3g9 :: a_a4Pe -> b_a4Pi).
      foldr @ a_a4Pe
            @ [b_a4Pi]
            (mapFB @ b_a4Pi @ [b_a4Pi] @ a_a4Pe (GHC.Types.: @ b_a4Pi) f_a3g9)
            (GHC.Types.[] @ b_a4Pi)
      = map @ a_a4Pe @ b_a4Pi f_a3g9
"map" [~1]
    forall (@ b_a4OS)
           (@ a_a4OR)
           (f_a3g5 :: a_a4OR -> b_a4OS)
           (xs_a3g6 :: [a_a4OR]).
      map @ a_a4OR @ b_a4OS f_a3g5 xs_a3g6
      = build
          @ b_a4OS
          (\ (@ b1_a4OW)
             (c_a3g7 :: b_a4OS -> b1_a4OW -> b1_a4OW)
             (n_a3g8 :: b1_a4OW) ->
             foldr
               @ a_a4OR
               @ b1_a4OW
               (mapFB @ b_a4OS @ b1_a4OW @ a_a4OR c_a3g7 f_a3g5)
               n_a3g8
               xs_a3g6)
"map/coerce" [1]
    forall (@ a_a4Ox)
           (@ b_a4Ow)
           ($r$dCoercible_d5c2 :: (a_a4Ox :: *) ~R# (b_a4Ow :: *)).
      map @ a_a4Ox
          @ b_a4Ow
          ((\ (v_Xac :: a_a4Ox) -> v_Xac)
           `cast` (<a_a4Ox>_R ->_R $r$dCoercible_d5c2
                   :: (a_a4Ox -> a_a4Ox :: *) ~R# (a_a4Ox -> b_a4Ow :: *)))
      = (\ (v_Xac :: [a_a4Ox]) -> v_Xac)
        `cast` (<[a_a4Ox]>_R ->_R ([$r$dCoercible_d5c2])_R
                :: ([a_a4Ox] -> [a_a4Ox] :: *) ~R# ([a_a4Ox] -> [b_a4Ow] :: *))
"SPEC =<<"
    forall (@ a_a4eS) (@ b_a4eT) ($dMonad_a4eX :: Monad []).
      =<< @ [] @ a_a4eS @ b_a4eT $dMonad_a4eX
      = GHC.Base.=<<_$s=<< @ a_a4eS @ b_a4eT
"SPEC liftA3"
    forall (@ a1_X4sU)
           (@ a2_X4sW)
           (@ a3_X4sY)
           (@ r_X4t0)
           ($dApplicative_a4g6 :: Applicative IO).
      liftA3 @ IO
             @ a1_X4sU
             @ a2_X4sW
             @ a3_X4sY
             @ r_X4t0
             $dApplicative_a4g6
      = GHC.Base.liftA3_$sliftA1 @ a1_X4sU @ a2_X4sW @ a3_X4sY @ r_X4t0
"SPEC liftA3"
    forall (@ a1_a4gF)
           (@ a2_a4gG)
           (@ a3_a4gH)
           (@ r_a4gI)
           ($dApplicative_a4gO :: Applicative Maybe).
      liftA3 @ Maybe
             @ a1_a4gF
             @ a2_a4gG
             @ a3_a4gH
             @ r_a4gI
             $dApplicative_a4gO
      = GHC.Base.liftA3_$sliftA3 @ a1_a4gF @ a2_a4gG @ a3_a4gH @ r_a4gI
"SPEC liftA"
    forall (@ a1_X4um)
           (@ r_X4uo)
           ($dApplicative_a4hr :: Applicative IO).
      liftA @ IO @ a1_X4um @ r_X4uo $dApplicative_a4hr
      = GHC.Base.liftA_$sliftA1 @ a1_X4um @ r_X4uo
"SPEC liftA"
    forall (@ a1_a4hM)
           (@ r_a4hN)
           ($dApplicative_a4hR :: Applicative Maybe).
      liftA @ Maybe @ a1_a4hM @ r_a4hN $dApplicative_a4hR
      = GHC.Base.liftA_$sliftA @ a1_a4hM @ r_a4hN
"unpack" [~1]
    forall (a_a3fX :: Addr#).
      unpackCString# a_a3fX
      = build
          @ Char (\ (@ b_a4NG) -> unpackFoldrCString# @ b_a4NG a_a3fX)
"unpack-list" [1]
    forall (a_a3fY :: Addr#).
      unpackFoldrCString# @ [Char]
                          a_a3fY
                          (GHC.Types.: @ Char)
                          (GHC.Types.[] @ Char)
      = unpackCString# a_a3fY
"unpack-append"
    forall (a_a3fZ :: Addr#) (n_a3g0 :: [Char]).
      unpackFoldrCString# @ [Char] a_a3fZ (GHC.Types.: @ Char) n_a3g0
      = unpackAppendCString# a_a3fZ n_a3g0
"eqString"
    forall ($dEq_a4O7 :: Eq String). == @ String $dEq_a4O7 = eqString

