
==================== Output Cmm ====================
2018-03-16 15:59:27.472045878 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:27.474344586 UTC

[section ""data" . GHC.Storable.readWideCharOffPtr1_closure" {
     GHC.Storable.readWideCharOffPtr1_closure:
         const GHC.Storable.readWideCharOffPtr1_info;
 },
 GHC.Storable.readWideCharOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4Bxc,
                       label: GHC.Storable.readWideCharOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Bxc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Bxl; else goto c4Bxm;
       c4Bxl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWideCharOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Bxm: // global
           I64[Sp - 16] = block_c4Bx9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Bxs; else goto c4Bxa;
       u4Bxs: // global
           call _c4Bx9(R1) args: 0, res: 0, upd: 0;
       c4Bxa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Bx9() //  [R1]
         { info_tbl: [(c4Bx9,
                       label: block_c4Bx9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Bx9: // global
           I64[Sp] = block_c4Bxf_info;
           _s4Brt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Brt::I64;
           if (R1 & 7 != 0) goto u4Bxr; else goto c4Bxg;
       u4Bxr: // global
           call _c4Bxf(R1) args: 0, res: 0, upd: 0;
       c4Bxg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Bxf() //  [R1]
         { info_tbl: [(c4Bxf,
                       label: block_c4Bxf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Bxf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Bxq; else goto c4Bxp;
       c4Bxq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Bxp: // global
           _s4Bry::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s4Bry::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.475977775 UTC

[section ""data" . GHC.Storable.readWideCharOffPtr_closure" {
     GHC.Storable.readWideCharOffPtr_closure:
         const GHC.Storable.readWideCharOffPtr_info;
 },
 GHC.Storable.readWideCharOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4Bxx,
                       label: GHC.Storable.readWideCharOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Bxx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWideCharOffPtr1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.477046032 UTC

[section ""data" . GHC.Storable.readIntOffPtr1_closure" {
     GHC.Storable.readIntOffPtr1_closure:
         const GHC.Storable.readIntOffPtr1_info;
 },
 GHC.Storable.readIntOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BxH,
                       label: GHC.Storable.readIntOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BxH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BxQ; else goto c4BxR;
       c4BxQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readIntOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BxR: // global
           I64[Sp - 16] = block_c4BxE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BxX; else goto c4BxF;
       u4BxX: // global
           call _c4BxE(R1) args: 0, res: 0, upd: 0;
       c4BxF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BxE() //  [R1]
         { info_tbl: [(c4BxE,
                       label: block_c4BxE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BxE: // global
           I64[Sp] = block_c4BxK_info;
           _s4BrE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BrE::I64;
           if (R1 & 7 != 0) goto u4BxW; else goto c4BxL;
       u4BxW: // global
           call _c4BxK(R1) args: 0, res: 0, upd: 0;
       c4BxL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BxK() //  [R1]
         { info_tbl: [(c4BxK,
                       label: block_c4BxK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BxK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BxV; else goto c4BxU;
       c4BxV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BxU: // global
           _s4BrJ::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4BrJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.478553652 UTC

[section ""data" . GHC.Storable.readIntOffPtr_closure" {
     GHC.Storable.readIntOffPtr_closure:
         const GHC.Storable.readIntOffPtr_info;
 },
 GHC.Storable.readIntOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4By2,
                       label: GHC.Storable.readIntOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4By2: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readIntOffPtr1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.479723518 UTC

[section ""data" . GHC.Storable.readWordOffPtr1_closure" {
     GHC.Storable.readWordOffPtr1_closure:
         const GHC.Storable.readWordOffPtr1_info;
 },
 GHC.Storable.readWordOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4Byc,
                       label: GHC.Storable.readWordOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Byc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Byl; else goto c4Bym;
       c4Byl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWordOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Bym: // global
           I64[Sp - 16] = block_c4By9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Bys; else goto c4Bya;
       u4Bys: // global
           call _c4By9(R1) args: 0, res: 0, upd: 0;
       c4Bya: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4By9() //  [R1]
         { info_tbl: [(c4By9,
                       label: block_c4By9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4By9: // global
           I64[Sp] = block_c4Byf_info;
           _s4BrP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BrP::I64;
           if (R1 & 7 != 0) goto u4Byr; else goto c4Byg;
       u4Byr: // global
           call _c4Byf(R1) args: 0, res: 0, upd: 0;
       c4Byg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Byf() //  [R1]
         { info_tbl: [(c4Byf,
                       label: block_c4Byf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Byf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Byq; else goto c4Byp;
       c4Byq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Byp: // global
           _s4BrU::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s4BrU::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.48120022 UTC

[section ""data" . GHC.Storable.readWordOffPtr_closure" {
     GHC.Storable.readWordOffPtr_closure:
         const GHC.Storable.readWordOffPtr_info;
 },
 GHC.Storable.readWordOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4Byx,
                       label: GHC.Storable.readWordOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Byx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWordOffPtr1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.482495348 UTC

[section ""data" . GHC.Storable.readPtrOffPtr1_closure" {
     GHC.Storable.readPtrOffPtr1_closure:
         const GHC.Storable.readPtrOffPtr1_info;
 },
 GHC.Storable.readPtrOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4ByH,
                       label: GHC.Storable.readPtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ByH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ByQ; else goto c4ByR;
       c4ByQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readPtrOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ByR: // global
           I64[Sp - 16] = block_c4ByE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ByX; else goto c4ByF;
       u4ByX: // global
           call _c4ByE(R1) args: 0, res: 0, upd: 0;
       c4ByF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ByE() //  [R1]
         { info_tbl: [(c4ByE,
                       label: block_c4ByE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ByE: // global
           I64[Sp] = block_c4ByK_info;
           _s4Bs0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bs0::I64;
           if (R1 & 7 != 0) goto u4ByW; else goto c4ByL;
       u4ByW: // global
           call _c4ByK(R1) args: 0, res: 0, upd: 0;
       c4ByL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ByK() //  [R1]
         { info_tbl: [(c4ByK,
                       label: block_c4ByK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ByK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ByV; else goto c4ByU;
       c4ByV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ByU: // global
           _s4Bs5::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Bs5::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.483993828 UTC

[section ""data" . GHC.Storable.readPtrOffPtr_closure" {
     GHC.Storable.readPtrOffPtr_closure:
         const GHC.Storable.readPtrOffPtr_info;
 },
 GHC.Storable.readPtrOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4Bz2,
                       label: GHC.Storable.readPtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Bz2: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readPtrOffPtr1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.485081221 UTC

[section ""data" . GHC.Storable.readFunPtrOffPtr1_closure" {
     GHC.Storable.readFunPtrOffPtr1_closure:
         const GHC.Storable.readFunPtrOffPtr1_info;
 },
 GHC.Storable.readFunPtrOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4Bzc,
                       label: GHC.Storable.readFunPtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Bzc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Bzl; else goto c4Bzm;
       c4Bzl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readFunPtrOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Bzm: // global
           I64[Sp - 16] = block_c4Bz9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Bzs; else goto c4Bza;
       u4Bzs: // global
           call _c4Bz9(R1) args: 0, res: 0, upd: 0;
       c4Bza: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Bz9() //  [R1]
         { info_tbl: [(c4Bz9,
                       label: block_c4Bz9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Bz9: // global
           I64[Sp] = block_c4Bzf_info;
           _s4Bsb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bsb::I64;
           if (R1 & 7 != 0) goto u4Bzr; else goto c4Bzg;
       u4Bzr: // global
           call _c4Bzf(R1) args: 0, res: 0, upd: 0;
       c4Bzg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Bzf() //  [R1]
         { info_tbl: [(c4Bzf,
                       label: block_c4Bzf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Bzf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Bzq; else goto c4Bzp;
       c4Bzq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Bzp: // global
           _s4Bsg::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s4Bsg::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.486680893 UTC

[section ""data" . GHC.Storable.readFunPtrOffPtr_closure" {
     GHC.Storable.readFunPtrOffPtr_closure:
         const GHC.Storable.readFunPtrOffPtr_info;
 },
 GHC.Storable.readFunPtrOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4Bzx,
                       label: GHC.Storable.readFunPtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Bzx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readFunPtrOffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.487813666 UTC

[section ""data" . GHC.Storable.readFloatOffPtr1_closure" {
     GHC.Storable.readFloatOffPtr1_closure:
         const GHC.Storable.readFloatOffPtr1_info;
 },
 GHC.Storable.readFloatOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BzH,
                       label: GHC.Storable.readFloatOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BzH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BzQ; else goto c4BzR;
       c4BzQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readFloatOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BzR: // global
           I64[Sp - 16] = block_c4BzE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BzX; else goto c4BzF;
       u4BzX: // global
           call _c4BzE(R1) args: 0, res: 0, upd: 0;
       c4BzF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BzE() //  [R1]
         { info_tbl: [(c4BzE,
                       label: block_c4BzE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BzE: // global
           I64[Sp] = block_c4BzK_info;
           _s4Bsm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bsm::I64;
           if (R1 & 7 != 0) goto u4BzW; else goto c4BzL;
       u4BzW: // global
           call _c4BzK(R1) args: 0, res: 0, upd: 0;
       c4BzL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BzK() //  [R1]
         { info_tbl: [(c4BzK,
                       label: block_c4BzK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BzK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BzV; else goto c4BzU;
       c4BzV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BzU: // global
           _s4Bsr::F32 = F32[I64[Sp + 8] + (I64[R1 + 7] << 2)];
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _s4Bsr::F32;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.489393709 UTC

[section ""data" . GHC.Storable.readFloatOffPtr_closure" {
     GHC.Storable.readFloatOffPtr_closure:
         const GHC.Storable.readFloatOffPtr_info;
 },
 GHC.Storable.readFloatOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BA2,
                       label: GHC.Storable.readFloatOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BA2: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readFloatOffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.490531603 UTC

[section ""data" . GHC.Storable.readDoubleOffPtr1_closure" {
     GHC.Storable.readDoubleOffPtr1_closure:
         const GHC.Storable.readDoubleOffPtr1_info;
 },
 GHC.Storable.readDoubleOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BAc,
                       label: GHC.Storable.readDoubleOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BAc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BAl; else goto c4BAm;
       c4BAl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readDoubleOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BAm: // global
           I64[Sp - 16] = block_c4BA9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BAs; else goto c4BAa;
       u4BAs: // global
           call _c4BA9(R1) args: 0, res: 0, upd: 0;
       c4BAa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BA9() //  [R1]
         { info_tbl: [(c4BA9,
                       label: block_c4BA9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BA9: // global
           I64[Sp] = block_c4BAf_info;
           _s4Bsx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bsx::I64;
           if (R1 & 7 != 0) goto u4BAr; else goto c4BAg;
       u4BAr: // global
           call _c4BAf(R1) args: 0, res: 0, upd: 0;
       c4BAg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BAf() //  [R1]
         { info_tbl: [(c4BAf,
                       label: block_c4BAf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BAf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BAq; else goto c4BAp;
       c4BAq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BAp: // global
           _s4BsC::F64 = F64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _s4BsC::F64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.492092676 UTC

[section ""data" . GHC.Storable.readDoubleOffPtr_closure" {
     GHC.Storable.readDoubleOffPtr_closure:
         const GHC.Storable.readDoubleOffPtr_info;
 },
 GHC.Storable.readDoubleOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BAx,
                       label: GHC.Storable.readDoubleOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BAx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readDoubleOffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.493380178 UTC

[section ""data" . GHC.Storable.readStablePtrOffPtr1_closure" {
     GHC.Storable.readStablePtrOffPtr1_closure:
         const GHC.Storable.readStablePtrOffPtr1_info;
 },
 GHC.Storable.readStablePtrOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BAH,
                       label: GHC.Storable.readStablePtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BAH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BAQ; else goto c4BAR;
       c4BAQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readStablePtrOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BAR: // global
           I64[Sp - 16] = block_c4BAE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BAX; else goto c4BAF;
       u4BAX: // global
           call _c4BAE(R1) args: 0, res: 0, upd: 0;
       c4BAF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BAE() //  [R1]
         { info_tbl: [(c4BAE,
                       label: block_c4BAE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BAE: // global
           I64[Sp] = block_c4BAK_info;
           _s4BsI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BsI::I64;
           if (R1 & 7 != 0) goto u4BAW; else goto c4BAL;
       u4BAW: // global
           call _c4BAK(R1) args: 0, res: 0, upd: 0;
       c4BAL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BAK() //  [R1]
         { info_tbl: [(c4BAK,
                       label: block_c4BAK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BAK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BAV; else goto c4BAU;
       c4BAV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BAU: // global
           _s4BsN::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = _s4BsN::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.497039428 UTC

[section ""data" . GHC.Storable.readStablePtrOffPtr_closure" {
     GHC.Storable.readStablePtrOffPtr_closure:
         const GHC.Storable.readStablePtrOffPtr_info;
 },
 GHC.Storable.readStablePtrOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BB2,
                       label: GHC.Storable.readStablePtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BB2: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readStablePtrOffPtr1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.498869091 UTC

[section ""data" . GHC.Storable.readInt8OffPtr1_closure" {
     GHC.Storable.readInt8OffPtr1_closure:
         const GHC.Storable.readInt8OffPtr1_info;
 },
 GHC.Storable.readInt8OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BBc,
                       label: GHC.Storable.readInt8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BBc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BBl; else goto c4BBm;
       c4BBl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt8OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BBm: // global
           I64[Sp - 16] = block_c4BB9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BBs; else goto c4BBa;
       u4BBs: // global
           call _c4BB9(R1) args: 0, res: 0, upd: 0;
       c4BBa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BB9() //  [R1]
         { info_tbl: [(c4BB9,
                       label: block_c4BB9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BB9: // global
           I64[Sp] = block_c4BBf_info;
           _s4BsT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BsT::I64;
           if (R1 & 7 != 0) goto u4BBr; else goto c4BBg;
       u4BBr: // global
           call _c4BBf(R1) args: 0, res: 0, upd: 0;
       c4BBg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BBf() //  [R1]
         { info_tbl: [(c4BBf,
                       label: block_c4BBf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BBf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BBq; else goto c4BBp;
       c4BBq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BBp: // global
           _s4BsY::I64 = %MO_SS_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4BsY::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.501206261 UTC

[section ""data" . GHC.Storable.readInt8OffPtr_closure" {
     GHC.Storable.readInt8OffPtr_closure:
         const GHC.Storable.readInt8OffPtr_info;
 },
 GHC.Storable.readInt8OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BBx,
                       label: GHC.Storable.readInt8OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BBx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt8OffPtr1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.502948772 UTC

[section ""data" . GHC.Storable.readWord8OffPtr1_closure" {
     GHC.Storable.readWord8OffPtr1_closure:
         const GHC.Storable.readWord8OffPtr1_info;
 },
 GHC.Storable.readWord8OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BBH,
                       label: GHC.Storable.readWord8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BBH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BBQ; else goto c4BBR;
       c4BBQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord8OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BBR: // global
           I64[Sp - 16] = block_c4BBE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BBX; else goto c4BBF;
       u4BBX: // global
           call _c4BBE(R1) args: 0, res: 0, upd: 0;
       c4BBF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BBE() //  [R1]
         { info_tbl: [(c4BBE,
                       label: block_c4BBE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BBE: // global
           I64[Sp] = block_c4BBK_info;
           _s4Bt4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bt4::I64;
           if (R1 & 7 != 0) goto u4BBW; else goto c4BBL;
       u4BBW: // global
           call _c4BBK(R1) args: 0, res: 0, upd: 0;
       c4BBL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BBK() //  [R1]
         { info_tbl: [(c4BBK,
                       label: block_c4BBK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BBK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BBV; else goto c4BBU;
       c4BBV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BBU: // global
           _s4Bt9::I64 = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s4Bt9::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.505432067 UTC

[section ""data" . GHC.Storable.readWord8OffPtr_closure" {
     GHC.Storable.readWord8OffPtr_closure:
         const GHC.Storable.readWord8OffPtr_info;
 },
 GHC.Storable.readWord8OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BC2,
                       label: GHC.Storable.readWord8OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BC2: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord8OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.507224872 UTC

[section ""data" . GHC.Storable.readInt16OffPtr1_closure" {
     GHC.Storable.readInt16OffPtr1_closure:
         const GHC.Storable.readInt16OffPtr1_info;
 },
 GHC.Storable.readInt16OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BCc,
                       label: GHC.Storable.readInt16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BCc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BCl; else goto c4BCm;
       c4BCl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt16OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BCm: // global
           I64[Sp - 16] = block_c4BC9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BCs; else goto c4BCa;
       u4BCs: // global
           call _c4BC9(R1) args: 0, res: 0, upd: 0;
       c4BCa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BC9() //  [R1]
         { info_tbl: [(c4BC9,
                       label: block_c4BC9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BC9: // global
           I64[Sp] = block_c4BCf_info;
           _s4Btf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Btf::I64;
           if (R1 & 7 != 0) goto u4BCr; else goto c4BCg;
       u4BCr: // global
           call _c4BCf(R1) args: 0, res: 0, upd: 0;
       c4BCg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BCf() //  [R1]
         { info_tbl: [(c4BCf,
                       label: block_c4BCf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BCf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BCq; else goto c4BCp;
       c4BCq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BCp: // global
           _s4Btk::I64 = %MO_SS_Conv_W16_W64(I16[I64[Sp + 8] + (I64[R1 + 7] << 1)]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4Btk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.509688037 UTC

[section ""data" . GHC.Storable.readInt16OffPtr_closure" {
     GHC.Storable.readInt16OffPtr_closure:
         const GHC.Storable.readInt16OffPtr_info;
 },
 GHC.Storable.readInt16OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BCx,
                       label: GHC.Storable.readInt16OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BCx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt16OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.511483172 UTC

[section ""data" . GHC.Storable.readWord16OffPtr1_closure" {
     GHC.Storable.readWord16OffPtr1_closure:
         const GHC.Storable.readWord16OffPtr1_info;
 },
 GHC.Storable.readWord16OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BCH,
                       label: GHC.Storable.readWord16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BCH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BCQ; else goto c4BCR;
       c4BCQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord16OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BCR: // global
           I64[Sp - 16] = block_c4BCE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BCX; else goto c4BCF;
       u4BCX: // global
           call _c4BCE(R1) args: 0, res: 0, upd: 0;
       c4BCF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BCE() //  [R1]
         { info_tbl: [(c4BCE,
                       label: block_c4BCE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BCE: // global
           I64[Sp] = block_c4BCK_info;
           _s4Btq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Btq::I64;
           if (R1 & 7 != 0) goto u4BCW; else goto c4BCL;
       u4BCW: // global
           call _c4BCK(R1) args: 0, res: 0, upd: 0;
       c4BCL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BCK() //  [R1]
         { info_tbl: [(c4BCK,
                       label: block_c4BCK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BCK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BCV; else goto c4BCU;
       c4BCV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BCU: // global
           _s4Btv::I64 = %MO_UU_Conv_W16_W64(I16[I64[Sp + 8] + (I64[R1 + 7] << 1)]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s4Btv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.51361454 UTC

[section ""data" . GHC.Storable.readWord16OffPtr_closure" {
     GHC.Storable.readWord16OffPtr_closure:
         const GHC.Storable.readWord16OffPtr_info;
 },
 GHC.Storable.readWord16OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BD2,
                       label: GHC.Storable.readWord16OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BD2: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord16OffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.515393648 UTC

[section ""data" . GHC.Storable.readInt32OffPtr1_closure" {
     GHC.Storable.readInt32OffPtr1_closure:
         const GHC.Storable.readInt32OffPtr1_info;
 },
 GHC.Storable.readInt32OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BDc,
                       label: GHC.Storable.readInt32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BDc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BDl; else goto c4BDm;
       c4BDl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt32OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BDm: // global
           I64[Sp - 16] = block_c4BD9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BDs; else goto c4BDa;
       u4BDs: // global
           call _c4BD9(R1) args: 0, res: 0, upd: 0;
       c4BDa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BD9() //  [R1]
         { info_tbl: [(c4BD9,
                       label: block_c4BD9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BD9: // global
           I64[Sp] = block_c4BDf_info;
           _s4BtB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BtB::I64;
           if (R1 & 7 != 0) goto u4BDr; else goto c4BDg;
       u4BDr: // global
           call _c4BDf(R1) args: 0, res: 0, upd: 0;
       c4BDg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BDf() //  [R1]
         { info_tbl: [(c4BDf,
                       label: block_c4BDf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BDf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BDq; else goto c4BDp;
       c4BDq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BDp: // global
           _s4BtG::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4BtG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.51799781 UTC

[section ""data" . GHC.Storable.readInt32OffPtr_closure" {
     GHC.Storable.readInt32OffPtr_closure:
         const GHC.Storable.readInt32OffPtr_info;
 },
 GHC.Storable.readInt32OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BDx,
                       label: GHC.Storable.readInt32OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BDx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt32OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.519887004 UTC

[section ""data" . GHC.Storable.readWord32OffPtr1_closure" {
     GHC.Storable.readWord32OffPtr1_closure:
         const GHC.Storable.readWord32OffPtr1_info;
 },
 GHC.Storable.readWord32OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BDH,
                       label: GHC.Storable.readWord32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BDH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BDQ; else goto c4BDR;
       c4BDQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord32OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BDR: // global
           I64[Sp - 16] = block_c4BDE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BDX; else goto c4BDF;
       u4BDX: // global
           call _c4BDE(R1) args: 0, res: 0, upd: 0;
       c4BDF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BDE() //  [R1]
         { info_tbl: [(c4BDE,
                       label: block_c4BDE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BDE: // global
           I64[Sp] = block_c4BDK_info;
           _s4BtM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BtM::I64;
           if (R1 & 7 != 0) goto u4BDW; else goto c4BDL;
       u4BDW: // global
           call _c4BDK(R1) args: 0, res: 0, upd: 0;
       c4BDL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BDK() //  [R1]
         { info_tbl: [(c4BDK,
                       label: block_c4BDK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BDK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BDV; else goto c4BDU;
       c4BDV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BDU: // global
           _s4BtR::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s4BtR::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.522312883 UTC

[section ""data" . GHC.Storable.readWord32OffPtr_closure" {
     GHC.Storable.readWord32OffPtr_closure:
         const GHC.Storable.readWord32OffPtr_info;
 },
 GHC.Storable.readWord32OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BE2,
                       label: GHC.Storable.readWord32OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BE2: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord32OffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.524473508 UTC

[section ""data" . GHC.Storable.readInt64OffPtr1_closure" {
     GHC.Storable.readInt64OffPtr1_closure:
         const GHC.Storable.readInt64OffPtr1_info;
 },
 GHC.Storable.readInt64OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BEc,
                       label: GHC.Storable.readInt64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BEc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BEl; else goto c4BEm;
       c4BEl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt64OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BEm: // global
           I64[Sp - 16] = block_c4BE9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BEs; else goto c4BEa;
       u4BEs: // global
           call _c4BE9(R1) args: 0, res: 0, upd: 0;
       c4BEa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BE9() //  [R1]
         { info_tbl: [(c4BE9,
                       label: block_c4BE9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BE9: // global
           I64[Sp] = block_c4BEf_info;
           _s4BtX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BtX::I64;
           if (R1 & 7 != 0) goto u4BEr; else goto c4BEg;
       u4BEr: // global
           call _c4BEf(R1) args: 0, res: 0, upd: 0;
       c4BEg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BEf() //  [R1]
         { info_tbl: [(c4BEf,
                       label: block_c4BEf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BEf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BEq; else goto c4BEp;
       c4BEq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BEp: // global
           _s4Bu2::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4Bu2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.52834209 UTC

[section ""data" . GHC.Storable.readInt64OffPtr_closure" {
     GHC.Storable.readInt64OffPtr_closure:
         const GHC.Storable.readInt64OffPtr_info;
 },
 GHC.Storable.readInt64OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BEx,
                       label: GHC.Storable.readInt64OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BEx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt64OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.529720284 UTC

[section ""data" . GHC.Storable.readWord64OffPtr1_closure" {
     GHC.Storable.readWord64OffPtr1_closure:
         const GHC.Storable.readWord64OffPtr1_info;
 },
 GHC.Storable.readWord64OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BEH,
                       label: GHC.Storable.readWord64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BEH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BEQ; else goto c4BER;
       c4BEQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord64OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BER: // global
           I64[Sp - 16] = block_c4BEE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BEX; else goto c4BEF;
       u4BEX: // global
           call _c4BEE(R1) args: 0, res: 0, upd: 0;
       c4BEF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BEE() //  [R1]
         { info_tbl: [(c4BEE,
                       label: block_c4BEE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BEE: // global
           I64[Sp] = block_c4BEK_info;
           _s4Bu8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bu8::I64;
           if (R1 & 7 != 0) goto u4BEW; else goto c4BEL;
       u4BEW: // global
           call _c4BEK(R1) args: 0, res: 0, upd: 0;
       c4BEL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BEK() //  [R1]
         { info_tbl: [(c4BEK,
                       label: block_c4BEK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BEK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BEV; else goto c4BEU;
       c4BEV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BEU: // global
           _s4Bud::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4Bud::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.531502175 UTC

[section ""data" . GHC.Storable.readWord64OffPtr_closure" {
     GHC.Storable.readWord64OffPtr_closure:
         const GHC.Storable.readWord64OffPtr_info;
 },
 GHC.Storable.readWord64OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BF2,
                       label: GHC.Storable.readWord64OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BF2: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord64OffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.532645639 UTC

[section ""data" . GHC.Storable.writeWideCharOffPtr1_closure" {
     GHC.Storable.writeWideCharOffPtr1_closure:
         const GHC.Storable.writeWideCharOffPtr1_info;
 },
 GHC.Storable.writeWideCharOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BFc,
                       label: GHC.Storable.writeWideCharOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BFc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BFl; else goto c4BFm;
       c4BFl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWideCharOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BFm: // global
           I64[Sp - 24] = block_c4BF9_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BFv; else goto c4BFa;
       u4BFv: // global
           call _c4BF9(R1) args: 0, res: 0, upd: 0;
       c4BFa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BF9() //  [R1]
         { info_tbl: [(c4BF9,
                       label: block_c4BF9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BF9: // global
           I64[Sp] = block_c4BFf_info;
           _s4Buk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Buk::I64;
           if (R1 & 7 != 0) goto u4BFu; else goto c4BFg;
       u4BFu: // global
           call _c4BFf(R1) args: 0, res: 0, upd: 0;
       c4BFg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BFf() //  [R1]
         { info_tbl: [(c4BFf,
                       label: block_c4BFf_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BFf: // global
           I64[Sp] = block_c4BFk_info;
           _s4Bum::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bum::I64;
           if (R1 & 7 != 0) goto u4BFw; else goto c4BFp;
       u4BFw: // global
           call _c4BFk(R1) args: 0, res: 0, upd: 0;
       c4BFp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BFk() //  [R1]
         { info_tbl: [(c4BFk,
                       label: block_c4BFk_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BFk: // global
           I32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.534326184 UTC

[section ""data" . GHC.Storable.writeWideCharOffPtr_closure" {
     GHC.Storable.writeWideCharOffPtr_closure:
         const GHC.Storable.writeWideCharOffPtr_info;
 },
 GHC.Storable.writeWideCharOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BFB,
                       label: GHC.Storable.writeWideCharOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BFB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWideCharOffPtr1_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.535468249 UTC

[section ""data" . GHC.Storable.writeIntOffPtr1_closure" {
     GHC.Storable.writeIntOffPtr1_closure:
         const GHC.Storable.writeIntOffPtr1_info;
 },
 GHC.Storable.writeIntOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BFL,
                       label: GHC.Storable.writeIntOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BFL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BFU; else goto c4BFV;
       c4BFU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeIntOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BFV: // global
           I64[Sp - 24] = block_c4BFI_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BG4; else goto c4BFJ;
       u4BG4: // global
           call _c4BFI(R1) args: 0, res: 0, upd: 0;
       c4BFJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BFI() //  [R1]
         { info_tbl: [(c4BFI,
                       label: block_c4BFI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BFI: // global
           I64[Sp] = block_c4BFO_info;
           _s4Buv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Buv::I64;
           if (R1 & 7 != 0) goto u4BG3; else goto c4BFP;
       u4BG3: // global
           call _c4BFO(R1) args: 0, res: 0, upd: 0;
       c4BFP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BFO() //  [R1]
         { info_tbl: [(c4BFO,
                       label: block_c4BFO_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BFO: // global
           I64[Sp] = block_c4BFT_info;
           _s4Bux::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bux::I64;
           if (R1 & 7 != 0) goto u4BG5; else goto c4BFY;
       u4BG5: // global
           call _c4BFT(R1) args: 0, res: 0, upd: 0;
       c4BFY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BFT() //  [R1]
         { info_tbl: [(c4BFT,
                       label: block_c4BFT_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BFT: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.537141023 UTC

[section ""data" . GHC.Storable.writeIntOffPtr_closure" {
     GHC.Storable.writeIntOffPtr_closure:
         const GHC.Storable.writeIntOffPtr_info;
 },
 GHC.Storable.writeIntOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BGa,
                       label: GHC.Storable.writeIntOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BGa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeIntOffPtr1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.538305641 UTC

[section ""data" . GHC.Storable.writeWordOffPtr1_closure" {
     GHC.Storable.writeWordOffPtr1_closure:
         const GHC.Storable.writeWordOffPtr1_info;
 },
 GHC.Storable.writeWordOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BGk,
                       label: GHC.Storable.writeWordOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BGk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BGt; else goto c4BGu;
       c4BGt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWordOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BGu: // global
           I64[Sp - 24] = block_c4BGh_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BGD; else goto c4BGi;
       u4BGD: // global
           call _c4BGh(R1) args: 0, res: 0, upd: 0;
       c4BGi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BGh() //  [R1]
         { info_tbl: [(c4BGh,
                       label: block_c4BGh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BGh: // global
           I64[Sp] = block_c4BGn_info;
           _s4BuG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BuG::I64;
           if (R1 & 7 != 0) goto u4BGC; else goto c4BGo;
       u4BGC: // global
           call _c4BGn(R1) args: 0, res: 0, upd: 0;
       c4BGo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BGn() //  [R1]
         { info_tbl: [(c4BGn,
                       label: block_c4BGn_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BGn: // global
           I64[Sp] = block_c4BGs_info;
           _s4BuI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BuI::I64;
           if (R1 & 7 != 0) goto u4BGE; else goto c4BGx;
       u4BGE: // global
           call _c4BGs(R1) args: 0, res: 0, upd: 0;
       c4BGx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BGs() //  [R1]
         { info_tbl: [(c4BGs,
                       label: block_c4BGs_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BGs: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.539866926 UTC

[section ""data" . GHC.Storable.writeWordOffPtr_closure" {
     GHC.Storable.writeWordOffPtr_closure:
         const GHC.Storable.writeWordOffPtr_info;
 },
 GHC.Storable.writeWordOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BGJ,
                       label: GHC.Storable.writeWordOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BGJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWordOffPtr1_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.541109584 UTC

[section ""data" . GHC.Storable.writePtrOffPtr1_closure" {
     GHC.Storable.writePtrOffPtr1_closure:
         const GHC.Storable.writePtrOffPtr1_info;
 },
 GHC.Storable.writePtrOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BGT,
                       label: GHC.Storable.writePtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BGT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BH2; else goto c4BH3;
       c4BH2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writePtrOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BH3: // global
           I64[Sp - 24] = block_c4BGQ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BHc; else goto c4BGR;
       u4BHc: // global
           call _c4BGQ(R1) args: 0, res: 0, upd: 0;
       c4BGR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BGQ() //  [R1]
         { info_tbl: [(c4BGQ,
                       label: block_c4BGQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BGQ: // global
           I64[Sp] = block_c4BGW_info;
           _s4BuR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BuR::I64;
           if (R1 & 7 != 0) goto u4BHb; else goto c4BGX;
       u4BHb: // global
           call _c4BGW(R1) args: 0, res: 0, upd: 0;
       c4BGX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BGW() //  [R1]
         { info_tbl: [(c4BGW,
                       label: block_c4BGW_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BGW: // global
           I64[Sp] = block_c4BH1_info;
           _s4BuT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BuT::I64;
           if (R1 & 7 != 0) goto u4BHd; else goto c4BH6;
       u4BHd: // global
           call _c4BH1(R1) args: 0, res: 0, upd: 0;
       c4BH6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BH1() //  [R1]
         { info_tbl: [(c4BH1,
                       label: block_c4BH1_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BH1: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.542904222 UTC

[section ""data" . GHC.Storable.writePtrOffPtr_closure" {
     GHC.Storable.writePtrOffPtr_closure:
         const GHC.Storable.writePtrOffPtr_info;
 },
 GHC.Storable.writePtrOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BHi,
                       label: GHC.Storable.writePtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BHi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writePtrOffPtr1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.544085861 UTC

[section ""data" . GHC.Storable.writeFunPtrOffPtr1_closure" {
     GHC.Storable.writeFunPtrOffPtr1_closure:
         const GHC.Storable.writeFunPtrOffPtr1_info;
 },
 GHC.Storable.writeFunPtrOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BHs,
                       label: GHC.Storable.writeFunPtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BHs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BHB; else goto c4BHC;
       c4BHB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeFunPtrOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BHC: // global
           I64[Sp - 24] = block_c4BHp_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BHL; else goto c4BHq;
       u4BHL: // global
           call _c4BHp(R1) args: 0, res: 0, upd: 0;
       c4BHq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BHp() //  [R1]
         { info_tbl: [(c4BHp,
                       label: block_c4BHp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BHp: // global
           I64[Sp] = block_c4BHv_info;
           _s4Bv2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bv2::I64;
           if (R1 & 7 != 0) goto u4BHK; else goto c4BHw;
       u4BHK: // global
           call _c4BHv(R1) args: 0, res: 0, upd: 0;
       c4BHw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BHv() //  [R1]
         { info_tbl: [(c4BHv,
                       label: block_c4BHv_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BHv: // global
           I64[Sp] = block_c4BHA_info;
           _s4Bv4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bv4::I64;
           if (R1 & 7 != 0) goto u4BHM; else goto c4BHF;
       u4BHM: // global
           call _c4BHA(R1) args: 0, res: 0, upd: 0;
       c4BHF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BHA() //  [R1]
         { info_tbl: [(c4BHA,
                       label: block_c4BHA_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BHA: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.546647085 UTC

[section ""data" . GHC.Storable.writeFunPtrOffPtr_closure" {
     GHC.Storable.writeFunPtrOffPtr_closure:
         const GHC.Storable.writeFunPtrOffPtr_info;
 },
 GHC.Storable.writeFunPtrOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BHR,
                       label: GHC.Storable.writeFunPtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BHR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeFunPtrOffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.547821742 UTC

[section ""data" . GHC.Storable.writeFloatOffPtr1_closure" {
     GHC.Storable.writeFloatOffPtr1_closure:
         const GHC.Storable.writeFloatOffPtr1_info;
 },
 GHC.Storable.writeFloatOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BI1,
                       label: GHC.Storable.writeFloatOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BI1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BIa; else goto c4BIb;
       c4BIa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeFloatOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BIb: // global
           I64[Sp - 24] = block_c4BHY_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BIk; else goto c4BHZ;
       u4BIk: // global
           call _c4BHY(R1) args: 0, res: 0, upd: 0;
       c4BHZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BHY() //  [R1]
         { info_tbl: [(c4BHY,
                       label: block_c4BHY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BHY: // global
           I64[Sp] = block_c4BI4_info;
           _s4Bvd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bvd::I64;
           if (R1 & 7 != 0) goto u4BIj; else goto c4BI5;
       u4BIj: // global
           call _c4BI4(R1) args: 0, res: 0, upd: 0;
       c4BI5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BI4() //  [R1]
         { info_tbl: [(c4BI4,
                       label: block_c4BI4_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BI4: // global
           I64[Sp] = block_c4BI9_info;
           _s4Bvf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bvf::I64;
           if (R1 & 7 != 0) goto u4BIl; else goto c4BIe;
       u4BIl: // global
           call _c4BI9(R1) args: 0, res: 0, upd: 0;
       c4BIe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BI9() //  [R1]
         { info_tbl: [(c4BI9,
                       label: block_c4BI9_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BI9: // global
           F32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = F32[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.549580731 UTC

[section ""data" . GHC.Storable.writeFloatOffPtr_closure" {
     GHC.Storable.writeFloatOffPtr_closure:
         const GHC.Storable.writeFloatOffPtr_info;
 },
 GHC.Storable.writeFloatOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BIq,
                       label: GHC.Storable.writeFloatOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BIq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeFloatOffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.550692885 UTC

[section ""data" . GHC.Storable.writeDoubleOffPtr1_closure" {
     GHC.Storable.writeDoubleOffPtr1_closure:
         const GHC.Storable.writeDoubleOffPtr1_info;
 },
 GHC.Storable.writeDoubleOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BIA,
                       label: GHC.Storable.writeDoubleOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BIA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BIJ; else goto c4BIK;
       c4BIJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeDoubleOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BIK: // global
           I64[Sp - 24] = block_c4BIx_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BIT; else goto c4BIy;
       u4BIT: // global
           call _c4BIx(R1) args: 0, res: 0, upd: 0;
       c4BIy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BIx() //  [R1]
         { info_tbl: [(c4BIx,
                       label: block_c4BIx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BIx: // global
           I64[Sp] = block_c4BID_info;
           _s4Bvo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bvo::I64;
           if (R1 & 7 != 0) goto u4BIS; else goto c4BIE;
       u4BIS: // global
           call _c4BID(R1) args: 0, res: 0, upd: 0;
       c4BIE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BID() //  [R1]
         { info_tbl: [(c4BID,
                       label: block_c4BID_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BID: // global
           I64[Sp] = block_c4BII_info;
           _s4Bvq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bvq::I64;
           if (R1 & 7 != 0) goto u4BIU; else goto c4BIN;
       u4BIU: // global
           call _c4BII(R1) args: 0, res: 0, upd: 0;
       c4BIN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BII() //  [R1]
         { info_tbl: [(c4BII,
                       label: block_c4BII_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BII: // global
           F64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = F64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.55230895 UTC

[section ""data" . GHC.Storable.writeDoubleOffPtr_closure" {
     GHC.Storable.writeDoubleOffPtr_closure:
         const GHC.Storable.writeDoubleOffPtr_info;
 },
 GHC.Storable.writeDoubleOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BIZ,
                       label: GHC.Storable.writeDoubleOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BIZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeDoubleOffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.553432798 UTC

[section ""data" . GHC.Storable.writeStablePtrOffPtr1_closure" {
     GHC.Storable.writeStablePtrOffPtr1_closure:
         const GHC.Storable.writeStablePtrOffPtr1_info;
 },
 GHC.Storable.writeStablePtrOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BJ9,
                       label: GHC.Storable.writeStablePtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BJ9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BJi; else goto c4BJj;
       c4BJi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeStablePtrOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BJj: // global
           I64[Sp - 24] = block_c4BJ6_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BJs; else goto c4BJ7;
       u4BJs: // global
           call _c4BJ6(R1) args: 0, res: 0, upd: 0;
       c4BJ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BJ6() //  [R1]
         { info_tbl: [(c4BJ6,
                       label: block_c4BJ6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BJ6: // global
           I64[Sp] = block_c4BJc_info;
           _s4Bvz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bvz::I64;
           if (R1 & 7 != 0) goto u4BJr; else goto c4BJd;
       u4BJr: // global
           call _c4BJc(R1) args: 0, res: 0, upd: 0;
       c4BJd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BJc() //  [R1]
         { info_tbl: [(c4BJc,
                       label: block_c4BJc_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BJc: // global
           I64[Sp] = block_c4BJh_info;
           _s4BvB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BvB::I64;
           if (R1 & 7 != 0) goto u4BJt; else goto c4BJm;
       u4BJt: // global
           call _c4BJh(R1) args: 0, res: 0, upd: 0;
       c4BJm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BJh() //  [R1]
         { info_tbl: [(c4BJh,
                       label: block_c4BJh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BJh: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.555087885 UTC

[section ""data" . GHC.Storable.writeStablePtrOffPtr_closure" {
     GHC.Storable.writeStablePtrOffPtr_closure:
         const GHC.Storable.writeStablePtrOffPtr_info;
 },
 GHC.Storable.writeStablePtrOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BJy,
                       label: GHC.Storable.writeStablePtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BJy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeStablePtrOffPtr1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.556214656 UTC

[section ""data" . GHC.Storable.writeInt8OffPtr1_closure" {
     GHC.Storable.writeInt8OffPtr1_closure:
         const GHC.Storable.writeInt8OffPtr1_info;
 },
 GHC.Storable.writeInt8OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BJI,
                       label: GHC.Storable.writeInt8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BJI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BJR; else goto c4BJS;
       c4BJR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt8OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BJS: // global
           I64[Sp - 24] = block_c4BJF_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BK1; else goto c4BJG;
       u4BK1: // global
           call _c4BJF(R1) args: 0, res: 0, upd: 0;
       c4BJG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BJF() //  [R1]
         { info_tbl: [(c4BJF,
                       label: block_c4BJF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BJF: // global
           I64[Sp] = block_c4BJL_info;
           _s4BvK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BvK::I64;
           if (R1 & 7 != 0) goto u4BK0; else goto c4BJM;
       u4BK0: // global
           call _c4BJL(R1) args: 0, res: 0, upd: 0;
       c4BJM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BJL() //  [R1]
         { info_tbl: [(c4BJL,
                       label: block_c4BJL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BJL: // global
           I64[Sp] = block_c4BJQ_info;
           _s4BvM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BvM::I64;
           if (R1 & 7 != 0) goto u4BK2; else goto c4BJV;
       u4BK2: // global
           call _c4BJQ(R1) args: 0, res: 0, upd: 0;
       c4BJV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BJQ() //  [R1]
         { info_tbl: [(c4BJQ,
                       label: block_c4BJQ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BJQ: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.558839385 UTC

[section ""data" . GHC.Storable.writeInt8OffPtr_closure" {
     GHC.Storable.writeInt8OffPtr_closure:
         const GHC.Storable.writeInt8OffPtr_info;
 },
 GHC.Storable.writeInt8OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BK7,
                       label: GHC.Storable.writeInt8OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BK7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt8OffPtr1_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.560651096 UTC

[section ""data" . GHC.Storable.writeWord8OffPtr1_closure" {
     GHC.Storable.writeWord8OffPtr1_closure:
         const GHC.Storable.writeWord8OffPtr1_info;
 },
 GHC.Storable.writeWord8OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BKh,
                       label: GHC.Storable.writeWord8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BKh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BKq; else goto c4BKr;
       c4BKq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord8OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BKr: // global
           I64[Sp - 24] = block_c4BKe_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BKA; else goto c4BKf;
       u4BKA: // global
           call _c4BKe(R1) args: 0, res: 0, upd: 0;
       c4BKf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BKe() //  [R1]
         { info_tbl: [(c4BKe,
                       label: block_c4BKe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BKe: // global
           I64[Sp] = block_c4BKk_info;
           _s4BvV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BvV::I64;
           if (R1 & 7 != 0) goto u4BKz; else goto c4BKl;
       u4BKz: // global
           call _c4BKk(R1) args: 0, res: 0, upd: 0;
       c4BKl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BKk() //  [R1]
         { info_tbl: [(c4BKk,
                       label: block_c4BKk_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BKk: // global
           I64[Sp] = block_c4BKp_info;
           _s4BvX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BvX::I64;
           if (R1 & 7 != 0) goto u4BKB; else goto c4BKu;
       u4BKB: // global
           call _c4BKp(R1) args: 0, res: 0, upd: 0;
       c4BKu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BKp() //  [R1]
         { info_tbl: [(c4BKp,
                       label: block_c4BKp_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BKp: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.563936563 UTC

[section ""data" . GHC.Storable.writeWord8OffPtr_closure" {
     GHC.Storable.writeWord8OffPtr_closure:
         const GHC.Storable.writeWord8OffPtr_info;
 },
 GHC.Storable.writeWord8OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BKG,
                       label: GHC.Storable.writeWord8OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BKG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord8OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.56585579 UTC

[section ""data" . GHC.Storable.writeInt16OffPtr1_closure" {
     GHC.Storable.writeInt16OffPtr1_closure:
         const GHC.Storable.writeInt16OffPtr1_info;
 },
 GHC.Storable.writeInt16OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BKQ,
                       label: GHC.Storable.writeInt16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BKQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BKZ; else goto c4BL0;
       c4BKZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt16OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BL0: // global
           I64[Sp - 24] = block_c4BKN_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BL9; else goto c4BKO;
       u4BL9: // global
           call _c4BKN(R1) args: 0, res: 0, upd: 0;
       c4BKO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BKN() //  [R1]
         { info_tbl: [(c4BKN,
                       label: block_c4BKN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BKN: // global
           I64[Sp] = block_c4BKT_info;
           _s4Bw6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bw6::I64;
           if (R1 & 7 != 0) goto u4BL8; else goto c4BKU;
       u4BL8: // global
           call _c4BKT(R1) args: 0, res: 0, upd: 0;
       c4BKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BKT() //  [R1]
         { info_tbl: [(c4BKT,
                       label: block_c4BKT_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BKT: // global
           I64[Sp] = block_c4BKY_info;
           _s4Bw8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bw8::I64;
           if (R1 & 7 != 0) goto u4BLa; else goto c4BL3;
       u4BLa: // global
           call _c4BKY(R1) args: 0, res: 0, upd: 0;
       c4BL3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BKY() //  [R1]
         { info_tbl: [(c4BKY,
                       label: block_c4BKY_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BKY: // global
           I16[I64[Sp + 8] + (I64[Sp + 16] << 1)] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.568383945 UTC

[section ""data" . GHC.Storable.writeInt16OffPtr_closure" {
     GHC.Storable.writeInt16OffPtr_closure:
         const GHC.Storable.writeInt16OffPtr_info;
 },
 GHC.Storable.writeInt16OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BLf,
                       label: GHC.Storable.writeInt16OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BLf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt16OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.569662623 UTC

[section ""data" . GHC.Storable.writeWord16OffPtr1_closure" {
     GHC.Storable.writeWord16OffPtr1_closure:
         const GHC.Storable.writeWord16OffPtr1_info;
 },
 GHC.Storable.writeWord16OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BLp,
                       label: GHC.Storable.writeWord16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BLp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BLy; else goto c4BLz;
       c4BLy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord16OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BLz: // global
           I64[Sp - 24] = block_c4BLm_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BLI; else goto c4BLn;
       u4BLI: // global
           call _c4BLm(R1) args: 0, res: 0, upd: 0;
       c4BLn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BLm() //  [R1]
         { info_tbl: [(c4BLm,
                       label: block_c4BLm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BLm: // global
           I64[Sp] = block_c4BLs_info;
           _s4Bwh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bwh::I64;
           if (R1 & 7 != 0) goto u4BLH; else goto c4BLt;
       u4BLH: // global
           call _c4BLs(R1) args: 0, res: 0, upd: 0;
       c4BLt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BLs() //  [R1]
         { info_tbl: [(c4BLs,
                       label: block_c4BLs_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BLs: // global
           I64[Sp] = block_c4BLx_info;
           _s4Bwj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bwj::I64;
           if (R1 & 7 != 0) goto u4BLJ; else goto c4BLC;
       u4BLJ: // global
           call _c4BLx(R1) args: 0, res: 0, upd: 0;
       c4BLC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BLx() //  [R1]
         { info_tbl: [(c4BLx,
                       label: block_c4BLx_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BLx: // global
           I16[I64[Sp + 8] + (I64[Sp + 16] << 1)] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.572226328 UTC

[section ""data" . GHC.Storable.writeWord16OffPtr_closure" {
     GHC.Storable.writeWord16OffPtr_closure:
         const GHC.Storable.writeWord16OffPtr_info;
 },
 GHC.Storable.writeWord16OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BLO,
                       label: GHC.Storable.writeWord16OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BLO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord16OffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.573456473 UTC

[section ""data" . GHC.Storable.writeInt32OffPtr1_closure" {
     GHC.Storable.writeInt32OffPtr1_closure:
         const GHC.Storable.writeInt32OffPtr1_info;
 },
 GHC.Storable.writeInt32OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BLY,
                       label: GHC.Storable.writeInt32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BLY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BM7; else goto c4BM8;
       c4BM7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt32OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BM8: // global
           I64[Sp - 24] = block_c4BLV_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BMh; else goto c4BLW;
       u4BMh: // global
           call _c4BLV(R1) args: 0, res: 0, upd: 0;
       c4BLW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BLV() //  [R1]
         { info_tbl: [(c4BLV,
                       label: block_c4BLV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BLV: // global
           I64[Sp] = block_c4BM1_info;
           _s4Bws::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bws::I64;
           if (R1 & 7 != 0) goto u4BMg; else goto c4BM2;
       u4BMg: // global
           call _c4BM1(R1) args: 0, res: 0, upd: 0;
       c4BM2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BM1() //  [R1]
         { info_tbl: [(c4BM1,
                       label: block_c4BM1_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BM1: // global
           I64[Sp] = block_c4BM6_info;
           _s4Bwu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bwu::I64;
           if (R1 & 7 != 0) goto u4BMi; else goto c4BMb;
       u4BMi: // global
           call _c4BM6(R1) args: 0, res: 0, upd: 0;
       c4BMb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BM6() //  [R1]
         { info_tbl: [(c4BM6,
                       label: block_c4BM6_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BM6: // global
           I32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.575025011 UTC

[section ""data" . GHC.Storable.writeInt32OffPtr_closure" {
     GHC.Storable.writeInt32OffPtr_closure:
         const GHC.Storable.writeInt32OffPtr_info;
 },
 GHC.Storable.writeInt32OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BMn,
                       label: GHC.Storable.writeInt32OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BMn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt32OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.576168677 UTC

[section ""data" . GHC.Storable.writeWord32OffPtr1_closure" {
     GHC.Storable.writeWord32OffPtr1_closure:
         const GHC.Storable.writeWord32OffPtr1_info;
 },
 GHC.Storable.writeWord32OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BMx,
                       label: GHC.Storable.writeWord32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BMx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BMG; else goto c4BMH;
       c4BMG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord32OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BMH: // global
           I64[Sp - 24] = block_c4BMu_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BMQ; else goto c4BMv;
       u4BMQ: // global
           call _c4BMu(R1) args: 0, res: 0, upd: 0;
       c4BMv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BMu() //  [R1]
         { info_tbl: [(c4BMu,
                       label: block_c4BMu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BMu: // global
           I64[Sp] = block_c4BMA_info;
           _s4BwD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BwD::I64;
           if (R1 & 7 != 0) goto u4BMP; else goto c4BMB;
       u4BMP: // global
           call _c4BMA(R1) args: 0, res: 0, upd: 0;
       c4BMB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BMA() //  [R1]
         { info_tbl: [(c4BMA,
                       label: block_c4BMA_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BMA: // global
           I64[Sp] = block_c4BMF_info;
           _s4BwF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BwF::I64;
           if (R1 & 7 != 0) goto u4BMR; else goto c4BMK;
       u4BMR: // global
           call _c4BMF(R1) args: 0, res: 0, upd: 0;
       c4BMK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BMF() //  [R1]
         { info_tbl: [(c4BMF,
                       label: block_c4BMF_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BMF: // global
           I32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.577843847 UTC

[section ""data" . GHC.Storable.writeWord32OffPtr_closure" {
     GHC.Storable.writeWord32OffPtr_closure:
         const GHC.Storable.writeWord32OffPtr_info;
 },
 GHC.Storable.writeWord32OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BMW,
                       label: GHC.Storable.writeWord32OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BMW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord32OffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.579027217 UTC

[section ""data" . GHC.Storable.writeInt64OffPtr1_closure" {
     GHC.Storable.writeInt64OffPtr1_closure:
         const GHC.Storable.writeInt64OffPtr1_info;
 },
 GHC.Storable.writeInt64OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BN6,
                       label: GHC.Storable.writeInt64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BN6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BNf; else goto c4BNg;
       c4BNf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt64OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BNg: // global
           I64[Sp - 24] = block_c4BN3_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BNp; else goto c4BN4;
       u4BNp: // global
           call _c4BN3(R1) args: 0, res: 0, upd: 0;
       c4BN4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BN3() //  [R1]
         { info_tbl: [(c4BN3,
                       label: block_c4BN3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BN3: // global
           I64[Sp] = block_c4BN9_info;
           _s4BwO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BwO::I64;
           if (R1 & 7 != 0) goto u4BNo; else goto c4BNa;
       u4BNo: // global
           call _c4BN9(R1) args: 0, res: 0, upd: 0;
       c4BNa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BN9() //  [R1]
         { info_tbl: [(c4BN9,
                       label: block_c4BN9_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BN9: // global
           I64[Sp] = block_c4BNe_info;
           _s4BwQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BwQ::I64;
           if (R1 & 7 != 0) goto u4BNq; else goto c4BNj;
       u4BNq: // global
           call _c4BNe(R1) args: 0, res: 0, upd: 0;
       c4BNj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BNe() //  [R1]
         { info_tbl: [(c4BNe,
                       label: block_c4BNe_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BNe: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.580703817 UTC

[section ""data" . GHC.Storable.writeInt64OffPtr_closure" {
     GHC.Storable.writeInt64OffPtr_closure:
         const GHC.Storable.writeInt64OffPtr_info;
 },
 GHC.Storable.writeInt64OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BNv,
                       label: GHC.Storable.writeInt64OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BNv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt64OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.581998267 UTC

[section ""data" . GHC.Storable.writeWord64OffPtr1_closure" {
     GHC.Storable.writeWord64OffPtr1_closure:
         const GHC.Storable.writeWord64OffPtr1_info;
 },
 GHC.Storable.writeWord64OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BNF,
                       label: GHC.Storable.writeWord64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BNF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BNO; else goto c4BNP;
       c4BNO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord64OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BNP: // global
           I64[Sp - 24] = block_c4BNC_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BNY; else goto c4BND;
       u4BNY: // global
           call _c4BNC(R1) args: 0, res: 0, upd: 0;
       c4BND: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BNC() //  [R1]
         { info_tbl: [(c4BNC,
                       label: block_c4BNC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BNC: // global
           I64[Sp] = block_c4BNI_info;
           _s4BwZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BwZ::I64;
           if (R1 & 7 != 0) goto u4BNX; else goto c4BNJ;
       u4BNX: // global
           call _c4BNI(R1) args: 0, res: 0, upd: 0;
       c4BNJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BNI() //  [R1]
         { info_tbl: [(c4BNI,
                       label: block_c4BNI_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BNI: // global
           I64[Sp] = block_c4BNN_info;
           _s4Bx1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bx1::I64;
           if (R1 & 7 != 0) goto u4BNZ; else goto c4BNS;
       u4BNZ: // global
           call _c4BNN(R1) args: 0, res: 0, upd: 0;
       c4BNS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BNN() //  [R1]
         { info_tbl: [(c4BNN,
                       label: block_c4BNN_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BNN: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.583665441 UTC

[section ""data" . GHC.Storable.writeWord64OffPtr_closure" {
     GHC.Storable.writeWord64OffPtr_closure:
         const GHC.Storable.writeWord64OffPtr_info;
 },
 GHC.Storable.writeWord64OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BO4,
                       label: GHC.Storable.writeWord64OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BO4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord64OffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.584483149 UTC

[section ""cstring" . GHC.Storable.$trModule4_bytes" {
     GHC.Storable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.585114952 UTC

[section ""data" . GHC.Storable.$trModule3_closure" {
     GHC.Storable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Storable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.585741294 UTC

[section ""cstring" . GHC.Storable.$trModule2_bytes" {
     GHC.Storable.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,111,114,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.586310609 UTC

[section ""data" . GHC.Storable.$trModule1_closure" {
     GHC.Storable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Storable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.586918629 UTC

[section ""data" . GHC.Storable.$trModule_closure" {
     GHC.Storable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Storable.$trModule3_closure+1;
         const GHC.Storable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.587591935 UTC

[section ""relreadonly" . S4BO7_srt" { S4BO7_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.588941759 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:27.590439357 UTC

[section ""data" . GHC.Storable.readWideCharOffPtr1_closure" {
     GHC.Storable.readWideCharOffPtr1_closure:
         const GHC.Storable.readWideCharOffPtr1_info;
 },
 GHC.Storable.readWideCharOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BOf,
                       label: GHC.Storable.readWideCharOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BOf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BOo; else goto c4BOp;
       c4BOo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWideCharOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BOp: // global
           I64[Sp - 16] = block_c4BOc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BOv; else goto c4BOd;
       u4BOv: // global
           call _c4BOc(R1) args: 0, res: 0, upd: 0;
       c4BOd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BOc() //  [R1]
         { info_tbl: [(c4BOc,
                       label: block_c4BOc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BOc: // global
           I64[Sp] = block_c4BOi_info;
           _s4Brt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Brt::I64;
           if (R1 & 7 != 0) goto u4BOu; else goto c4BOj;
       u4BOu: // global
           call _c4BOi(R1) args: 0, res: 0, upd: 0;
       c4BOj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BOi() //  [R1]
         { info_tbl: [(c4BOi,
                       label: block_c4BOi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BOi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BOt; else goto c4BOs;
       c4BOt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BOs: // global
           _s4Bry::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s4Bry::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.592165818 UTC

[section ""data" . GHC.Storable.readWideCharOffPtr_closure" {
     GHC.Storable.readWideCharOffPtr_closure:
         const GHC.Storable.readWideCharOffPtr_info;
 },
 GHC.Storable.readWideCharOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BOA,
                       label: GHC.Storable.readWideCharOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BOA: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWideCharOffPtr1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.593341338 UTC

[section ""data" . GHC.Storable.readIntOffPtr1_closure" {
     GHC.Storable.readIntOffPtr1_closure:
         const GHC.Storable.readIntOffPtr1_info;
 },
 GHC.Storable.readIntOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BOK,
                       label: GHC.Storable.readIntOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BOK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BOT; else goto c4BOU;
       c4BOT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readIntOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BOU: // global
           I64[Sp - 16] = block_c4BOH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BP0; else goto c4BOI;
       u4BP0: // global
           call _c4BOH(R1) args: 0, res: 0, upd: 0;
       c4BOI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BOH() //  [R1]
         { info_tbl: [(c4BOH,
                       label: block_c4BOH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BOH: // global
           I64[Sp] = block_c4BON_info;
           _s4BrE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BrE::I64;
           if (R1 & 7 != 0) goto u4BOZ; else goto c4BOO;
       u4BOZ: // global
           call _c4BON(R1) args: 0, res: 0, upd: 0;
       c4BOO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BON() //  [R1]
         { info_tbl: [(c4BON,
                       label: block_c4BON_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BON: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BOY; else goto c4BOX;
       c4BOY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BOX: // global
           _s4BrJ::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4BrJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.594828125 UTC

[section ""data" . GHC.Storable.readIntOffPtr_closure" {
     GHC.Storable.readIntOffPtr_closure:
         const GHC.Storable.readIntOffPtr_info;
 },
 GHC.Storable.readIntOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BP5,
                       label: GHC.Storable.readIntOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BP5: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readIntOffPtr1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.595866043 UTC

[section ""data" . GHC.Storable.readWordOffPtr1_closure" {
     GHC.Storable.readWordOffPtr1_closure:
         const GHC.Storable.readWordOffPtr1_info;
 },
 GHC.Storable.readWordOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BPf,
                       label: GHC.Storable.readWordOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BPf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BPo; else goto c4BPp;
       c4BPo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWordOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BPp: // global
           I64[Sp - 16] = block_c4BPc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BPv; else goto c4BPd;
       u4BPv: // global
           call _c4BPc(R1) args: 0, res: 0, upd: 0;
       c4BPd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BPc() //  [R1]
         { info_tbl: [(c4BPc,
                       label: block_c4BPc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BPc: // global
           I64[Sp] = block_c4BPi_info;
           _s4BrP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BrP::I64;
           if (R1 & 7 != 0) goto u4BPu; else goto c4BPj;
       u4BPu: // global
           call _c4BPi(R1) args: 0, res: 0, upd: 0;
       c4BPj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BPi() //  [R1]
         { info_tbl: [(c4BPi,
                       label: block_c4BPi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BPi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BPt; else goto c4BPs;
       c4BPt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BPs: // global
           _s4BrU::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s4BrU::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.597336366 UTC

[section ""data" . GHC.Storable.readWordOffPtr_closure" {
     GHC.Storable.readWordOffPtr_closure:
         const GHC.Storable.readWordOffPtr_info;
 },
 GHC.Storable.readWordOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BPA,
                       label: GHC.Storable.readWordOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BPA: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWordOffPtr1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.598467401 UTC

[section ""data" . GHC.Storable.readPtrOffPtr1_closure" {
     GHC.Storable.readPtrOffPtr1_closure:
         const GHC.Storable.readPtrOffPtr1_info;
 },
 GHC.Storable.readPtrOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BPK,
                       label: GHC.Storable.readPtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BPK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BPT; else goto c4BPU;
       c4BPT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readPtrOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BPU: // global
           I64[Sp - 16] = block_c4BPH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BQ0; else goto c4BPI;
       u4BQ0: // global
           call _c4BPH(R1) args: 0, res: 0, upd: 0;
       c4BPI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BPH() //  [R1]
         { info_tbl: [(c4BPH,
                       label: block_c4BPH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BPH: // global
           I64[Sp] = block_c4BPN_info;
           _s4Bs0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bs0::I64;
           if (R1 & 7 != 0) goto u4BPZ; else goto c4BPO;
       u4BPZ: // global
           call _c4BPN(R1) args: 0, res: 0, upd: 0;
       c4BPO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BPN() //  [R1]
         { info_tbl: [(c4BPN,
                       label: block_c4BPN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BPN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BPY; else goto c4BPX;
       c4BPY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BPX: // global
           _s4Bs5::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Bs5::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.59993168 UTC

[section ""data" . GHC.Storable.readPtrOffPtr_closure" {
     GHC.Storable.readPtrOffPtr_closure:
         const GHC.Storable.readPtrOffPtr_info;
 },
 GHC.Storable.readPtrOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BQ5,
                       label: GHC.Storable.readPtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BQ5: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readPtrOffPtr1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.601037832 UTC

[section ""data" . GHC.Storable.readFunPtrOffPtr1_closure" {
     GHC.Storable.readFunPtrOffPtr1_closure:
         const GHC.Storable.readFunPtrOffPtr1_info;
 },
 GHC.Storable.readFunPtrOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BQf,
                       label: GHC.Storable.readFunPtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BQf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BQo; else goto c4BQp;
       c4BQo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readFunPtrOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BQp: // global
           I64[Sp - 16] = block_c4BQc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BQv; else goto c4BQd;
       u4BQv: // global
           call _c4BQc(R1) args: 0, res: 0, upd: 0;
       c4BQd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BQc() //  [R1]
         { info_tbl: [(c4BQc,
                       label: block_c4BQc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BQc: // global
           I64[Sp] = block_c4BQi_info;
           _s4Bsb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bsb::I64;
           if (R1 & 7 != 0) goto u4BQu; else goto c4BQj;
       u4BQu: // global
           call _c4BQi(R1) args: 0, res: 0, upd: 0;
       c4BQj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BQi() //  [R1]
         { info_tbl: [(c4BQi,
                       label: block_c4BQi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BQi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BQt; else goto c4BQs;
       c4BQt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BQs: // global
           _s4Bsg::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s4Bsg::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.602609408 UTC

[section ""data" . GHC.Storable.readFunPtrOffPtr_closure" {
     GHC.Storable.readFunPtrOffPtr_closure:
         const GHC.Storable.readFunPtrOffPtr_info;
 },
 GHC.Storable.readFunPtrOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BQA,
                       label: GHC.Storable.readFunPtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BQA: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readFunPtrOffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.603720844 UTC

[section ""data" . GHC.Storable.readFloatOffPtr1_closure" {
     GHC.Storable.readFloatOffPtr1_closure:
         const GHC.Storable.readFloatOffPtr1_info;
 },
 GHC.Storable.readFloatOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BQK,
                       label: GHC.Storable.readFloatOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BQK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BQT; else goto c4BQU;
       c4BQT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readFloatOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BQU: // global
           I64[Sp - 16] = block_c4BQH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BR0; else goto c4BQI;
       u4BR0: // global
           call _c4BQH(R1) args: 0, res: 0, upd: 0;
       c4BQI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BQH() //  [R1]
         { info_tbl: [(c4BQH,
                       label: block_c4BQH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BQH: // global
           I64[Sp] = block_c4BQN_info;
           _s4Bsm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bsm::I64;
           if (R1 & 7 != 0) goto u4BQZ; else goto c4BQO;
       u4BQZ: // global
           call _c4BQN(R1) args: 0, res: 0, upd: 0;
       c4BQO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BQN() //  [R1]
         { info_tbl: [(c4BQN,
                       label: block_c4BQN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BQN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BQY; else goto c4BQX;
       c4BQY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BQX: // global
           _s4Bsr::F32 = F32[I64[Sp + 8] + (I64[R1 + 7] << 2)];
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _s4Bsr::F32;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.605215373 UTC

[section ""data" . GHC.Storable.readFloatOffPtr_closure" {
     GHC.Storable.readFloatOffPtr_closure:
         const GHC.Storable.readFloatOffPtr_info;
 },
 GHC.Storable.readFloatOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BR5,
                       label: GHC.Storable.readFloatOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BR5: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readFloatOffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.606888417 UTC

[section ""data" . GHC.Storable.readDoubleOffPtr1_closure" {
     GHC.Storable.readDoubleOffPtr1_closure:
         const GHC.Storable.readDoubleOffPtr1_info;
 },
 GHC.Storable.readDoubleOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BRf,
                       label: GHC.Storable.readDoubleOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BRf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BRo; else goto c4BRp;
       c4BRo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readDoubleOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BRp: // global
           I64[Sp - 16] = block_c4BRc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BRv; else goto c4BRd;
       u4BRv: // global
           call _c4BRc(R1) args: 0, res: 0, upd: 0;
       c4BRd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BRc() //  [R1]
         { info_tbl: [(c4BRc,
                       label: block_c4BRc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BRc: // global
           I64[Sp] = block_c4BRi_info;
           _s4Bsx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bsx::I64;
           if (R1 & 7 != 0) goto u4BRu; else goto c4BRj;
       u4BRu: // global
           call _c4BRi(R1) args: 0, res: 0, upd: 0;
       c4BRj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BRi() //  [R1]
         { info_tbl: [(c4BRi,
                       label: block_c4BRi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BRi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BRt; else goto c4BRs;
       c4BRt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BRs: // global
           _s4BsC::F64 = F64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _s4BsC::F64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.60844849 UTC

[section ""data" . GHC.Storable.readDoubleOffPtr_closure" {
     GHC.Storable.readDoubleOffPtr_closure:
         const GHC.Storable.readDoubleOffPtr_info;
 },
 GHC.Storable.readDoubleOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BRA,
                       label: GHC.Storable.readDoubleOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BRA: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readDoubleOffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.610473849 UTC

[section ""data" . GHC.Storable.readStablePtrOffPtr1_closure" {
     GHC.Storable.readStablePtrOffPtr1_closure:
         const GHC.Storable.readStablePtrOffPtr1_info;
 },
 GHC.Storable.readStablePtrOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BRK,
                       label: GHC.Storable.readStablePtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BRK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BRT; else goto c4BRU;
       c4BRT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readStablePtrOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BRU: // global
           I64[Sp - 16] = block_c4BRH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BS0; else goto c4BRI;
       u4BS0: // global
           call _c4BRH(R1) args: 0, res: 0, upd: 0;
       c4BRI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BRH() //  [R1]
         { info_tbl: [(c4BRH,
                       label: block_c4BRH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BRH: // global
           I64[Sp] = block_c4BRN_info;
           _s4BsI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BsI::I64;
           if (R1 & 7 != 0) goto u4BRZ; else goto c4BRO;
       u4BRZ: // global
           call _c4BRN(R1) args: 0, res: 0, upd: 0;
       c4BRO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BRN() //  [R1]
         { info_tbl: [(c4BRN,
                       label: block_c4BRN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BRN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BRY; else goto c4BRX;
       c4BRY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BRX: // global
           _s4BsN::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = _s4BsN::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.612061166 UTC

[section ""data" . GHC.Storable.readStablePtrOffPtr_closure" {
     GHC.Storable.readStablePtrOffPtr_closure:
         const GHC.Storable.readStablePtrOffPtr_info;
 },
 GHC.Storable.readStablePtrOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BS5,
                       label: GHC.Storable.readStablePtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BS5: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readStablePtrOffPtr1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.613216982 UTC

[section ""data" . GHC.Storable.readInt8OffPtr1_closure" {
     GHC.Storable.readInt8OffPtr1_closure:
         const GHC.Storable.readInt8OffPtr1_info;
 },
 GHC.Storable.readInt8OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BSf,
                       label: GHC.Storable.readInt8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BSf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BSo; else goto c4BSp;
       c4BSo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt8OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BSp: // global
           I64[Sp - 16] = block_c4BSc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BSv; else goto c4BSd;
       u4BSv: // global
           call _c4BSc(R1) args: 0, res: 0, upd: 0;
       c4BSd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BSc() //  [R1]
         { info_tbl: [(c4BSc,
                       label: block_c4BSc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BSc: // global
           I64[Sp] = block_c4BSi_info;
           _s4BsT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BsT::I64;
           if (R1 & 7 != 0) goto u4BSu; else goto c4BSj;
       u4BSu: // global
           call _c4BSi(R1) args: 0, res: 0, upd: 0;
       c4BSj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BSi() //  [R1]
         { info_tbl: [(c4BSi,
                       label: block_c4BSi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BSi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BSt; else goto c4BSs;
       c4BSt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BSs: // global
           _s4BsY::I64 = %MO_SS_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4BsY::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.614774288 UTC

[section ""data" . GHC.Storable.readInt8OffPtr_closure" {
     GHC.Storable.readInt8OffPtr_closure:
         const GHC.Storable.readInt8OffPtr_info;
 },
 GHC.Storable.readInt8OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BSA,
                       label: GHC.Storable.readInt8OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BSA: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt8OffPtr1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.615891385 UTC

[section ""data" . GHC.Storable.readWord8OffPtr1_closure" {
     GHC.Storable.readWord8OffPtr1_closure:
         const GHC.Storable.readWord8OffPtr1_info;
 },
 GHC.Storable.readWord8OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BSK,
                       label: GHC.Storable.readWord8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BSK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BST; else goto c4BSU;
       c4BST: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord8OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BSU: // global
           I64[Sp - 16] = block_c4BSH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BT0; else goto c4BSI;
       u4BT0: // global
           call _c4BSH(R1) args: 0, res: 0, upd: 0;
       c4BSI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BSH() //  [R1]
         { info_tbl: [(c4BSH,
                       label: block_c4BSH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BSH: // global
           I64[Sp] = block_c4BSN_info;
           _s4Bt4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bt4::I64;
           if (R1 & 7 != 0) goto u4BSZ; else goto c4BSO;
       u4BSZ: // global
           call _c4BSN(R1) args: 0, res: 0, upd: 0;
       c4BSO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BSN() //  [R1]
         { info_tbl: [(c4BSN,
                       label: block_c4BSN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BSN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BSY; else goto c4BSX;
       c4BSY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BSX: // global
           _s4Bt9::I64 = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s4Bt9::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.61734114 UTC

[section ""data" . GHC.Storable.readWord8OffPtr_closure" {
     GHC.Storable.readWord8OffPtr_closure:
         const GHC.Storable.readWord8OffPtr_info;
 },
 GHC.Storable.readWord8OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BT5,
                       label: GHC.Storable.readWord8OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BT5: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord8OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.618796581 UTC

[section ""data" . GHC.Storable.readInt16OffPtr1_closure" {
     GHC.Storable.readInt16OffPtr1_closure:
         const GHC.Storable.readInt16OffPtr1_info;
 },
 GHC.Storable.readInt16OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BTf,
                       label: GHC.Storable.readInt16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BTf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BTo; else goto c4BTp;
       c4BTo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt16OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BTp: // global
           I64[Sp - 16] = block_c4BTc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BTv; else goto c4BTd;
       u4BTv: // global
           call _c4BTc(R1) args: 0, res: 0, upd: 0;
       c4BTd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BTc() //  [R1]
         { info_tbl: [(c4BTc,
                       label: block_c4BTc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BTc: // global
           I64[Sp] = block_c4BTi_info;
           _s4Btf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Btf::I64;
           if (R1 & 7 != 0) goto u4BTu; else goto c4BTj;
       u4BTu: // global
           call _c4BTi(R1) args: 0, res: 0, upd: 0;
       c4BTj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BTi() //  [R1]
         { info_tbl: [(c4BTi,
                       label: block_c4BTi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BTi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BTt; else goto c4BTs;
       c4BTt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BTs: // global
           _s4Btk::I64 = %MO_SS_Conv_W16_W64(I16[I64[Sp + 8] + (I64[R1 + 7] << 1)]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4Btk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.621361607 UTC

[section ""data" . GHC.Storable.readInt16OffPtr_closure" {
     GHC.Storable.readInt16OffPtr_closure:
         const GHC.Storable.readInt16OffPtr_info;
 },
 GHC.Storable.readInt16OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BTA,
                       label: GHC.Storable.readInt16OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BTA: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt16OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.622532769 UTC

[section ""data" . GHC.Storable.readWord16OffPtr1_closure" {
     GHC.Storable.readWord16OffPtr1_closure:
         const GHC.Storable.readWord16OffPtr1_info;
 },
 GHC.Storable.readWord16OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BTK,
                       label: GHC.Storable.readWord16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BTK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BTT; else goto c4BTU;
       c4BTT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord16OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BTU: // global
           I64[Sp - 16] = block_c4BTH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BU0; else goto c4BTI;
       u4BU0: // global
           call _c4BTH(R1) args: 0, res: 0, upd: 0;
       c4BTI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BTH() //  [R1]
         { info_tbl: [(c4BTH,
                       label: block_c4BTH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BTH: // global
           I64[Sp] = block_c4BTN_info;
           _s4Btq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Btq::I64;
           if (R1 & 7 != 0) goto u4BTZ; else goto c4BTO;
       u4BTZ: // global
           call _c4BTN(R1) args: 0, res: 0, upd: 0;
       c4BTO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BTN() //  [R1]
         { info_tbl: [(c4BTN,
                       label: block_c4BTN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BTN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BTY; else goto c4BTX;
       c4BTY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BTX: // global
           _s4Btv::I64 = %MO_UU_Conv_W16_W64(I16[I64[Sp + 8] + (I64[R1 + 7] << 1)]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s4Btv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.62406004 UTC

[section ""data" . GHC.Storable.readWord16OffPtr_closure" {
     GHC.Storable.readWord16OffPtr_closure:
         const GHC.Storable.readWord16OffPtr_info;
 },
 GHC.Storable.readWord16OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BU5,
                       label: GHC.Storable.readWord16OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BU5: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord16OffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.625170995 UTC

[section ""data" . GHC.Storable.readInt32OffPtr1_closure" {
     GHC.Storable.readInt32OffPtr1_closure:
         const GHC.Storable.readInt32OffPtr1_info;
 },
 GHC.Storable.readInt32OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BUf,
                       label: GHC.Storable.readInt32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BUf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BUo; else goto c4BUp;
       c4BUo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt32OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BUp: // global
           I64[Sp - 16] = block_c4BUc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BUv; else goto c4BUd;
       u4BUv: // global
           call _c4BUc(R1) args: 0, res: 0, upd: 0;
       c4BUd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BUc() //  [R1]
         { info_tbl: [(c4BUc,
                       label: block_c4BUc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BUc: // global
           I64[Sp] = block_c4BUi_info;
           _s4BtB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BtB::I64;
           if (R1 & 7 != 0) goto u4BUu; else goto c4BUj;
       u4BUu: // global
           call _c4BUi(R1) args: 0, res: 0, upd: 0;
       c4BUj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BUi() //  [R1]
         { info_tbl: [(c4BUi,
                       label: block_c4BUi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BUi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BUt; else goto c4BUs;
       c4BUt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BUs: // global
           _s4BtG::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4BtG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.626698169 UTC

[section ""data" . GHC.Storable.readInt32OffPtr_closure" {
     GHC.Storable.readInt32OffPtr_closure:
         const GHC.Storable.readInt32OffPtr_info;
 },
 GHC.Storable.readInt32OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BUA,
                       label: GHC.Storable.readInt32OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BUA: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt32OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.62786354 UTC

[section ""data" . GHC.Storable.readWord32OffPtr1_closure" {
     GHC.Storable.readWord32OffPtr1_closure:
         const GHC.Storable.readWord32OffPtr1_info;
 },
 GHC.Storable.readWord32OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BUK,
                       label: GHC.Storable.readWord32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BUK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BUT; else goto c4BUU;
       c4BUT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord32OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BUU: // global
           I64[Sp - 16] = block_c4BUH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BV0; else goto c4BUI;
       u4BV0: // global
           call _c4BUH(R1) args: 0, res: 0, upd: 0;
       c4BUI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BUH() //  [R1]
         { info_tbl: [(c4BUH,
                       label: block_c4BUH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BUH: // global
           I64[Sp] = block_c4BUN_info;
           _s4BtM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BtM::I64;
           if (R1 & 7 != 0) goto u4BUZ; else goto c4BUO;
       u4BUZ: // global
           call _c4BUN(R1) args: 0, res: 0, upd: 0;
       c4BUO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BUN() //  [R1]
         { info_tbl: [(c4BUN,
                       label: block_c4BUN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BUN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BUY; else goto c4BUX;
       c4BUY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BUX: // global
           _s4BtR::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s4BtR::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.630508154 UTC

[section ""data" . GHC.Storable.readWord32OffPtr_closure" {
     GHC.Storable.readWord32OffPtr_closure:
         const GHC.Storable.readWord32OffPtr_info;
 },
 GHC.Storable.readWord32OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BV5,
                       label: GHC.Storable.readWord32OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BV5: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord32OffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.631727576 UTC

[section ""data" . GHC.Storable.readInt64OffPtr1_closure" {
     GHC.Storable.readInt64OffPtr1_closure:
         const GHC.Storable.readInt64OffPtr1_info;
 },
 GHC.Storable.readInt64OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BVf,
                       label: GHC.Storable.readInt64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BVf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BVo; else goto c4BVp;
       c4BVo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt64OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BVp: // global
           I64[Sp - 16] = block_c4BVc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BVv; else goto c4BVd;
       u4BVv: // global
           call _c4BVc(R1) args: 0, res: 0, upd: 0;
       c4BVd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BVc() //  [R1]
         { info_tbl: [(c4BVc,
                       label: block_c4BVc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BVc: // global
           I64[Sp] = block_c4BVi_info;
           _s4BtX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BtX::I64;
           if (R1 & 7 != 0) goto u4BVu; else goto c4BVj;
       u4BVu: // global
           call _c4BVi(R1) args: 0, res: 0, upd: 0;
       c4BVj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BVi() //  [R1]
         { info_tbl: [(c4BVi,
                       label: block_c4BVi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BVi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BVt; else goto c4BVs;
       c4BVt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BVs: // global
           _s4Bu2::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4Bu2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.633172836 UTC

[section ""data" . GHC.Storable.readInt64OffPtr_closure" {
     GHC.Storable.readInt64OffPtr_closure:
         const GHC.Storable.readInt64OffPtr_info;
 },
 GHC.Storable.readInt64OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BVA,
                       label: GHC.Storable.readInt64OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BVA: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt64OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.634310641 UTC

[section ""data" . GHC.Storable.readWord64OffPtr1_closure" {
     GHC.Storable.readWord64OffPtr1_closure:
         const GHC.Storable.readWord64OffPtr1_info;
 },
 GHC.Storable.readWord64OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4BVK,
                       label: GHC.Storable.readWord64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BVK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4BVT; else goto c4BVU;
       c4BVT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord64OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BVU: // global
           I64[Sp - 16] = block_c4BVH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4BW0; else goto c4BVI;
       u4BW0: // global
           call _c4BVH(R1) args: 0, res: 0, upd: 0;
       c4BVI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BVH() //  [R1]
         { info_tbl: [(c4BVH,
                       label: block_c4BVH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BVH: // global
           I64[Sp] = block_c4BVN_info;
           _s4Bu8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bu8::I64;
           if (R1 & 7 != 0) goto u4BVZ; else goto c4BVO;
       u4BVZ: // global
           call _c4BVN(R1) args: 0, res: 0, upd: 0;
       c4BVO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BVN() //  [R1]
         { info_tbl: [(c4BVN,
                       label: block_c4BVN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BVN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4BVY; else goto c4BVX;
       c4BVY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4BVX: // global
           _s4Bud::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4Bud::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.635772683 UTC

[section ""data" . GHC.Storable.readWord64OffPtr_closure" {
     GHC.Storable.readWord64OffPtr_closure:
         const GHC.Storable.readWord64OffPtr_info;
 },
 GHC.Storable.readWord64OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4BW5,
                       label: GHC.Storable.readWord64OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BW5: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord64OffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.636968903 UTC

[section ""data" . GHC.Storable.writeWideCharOffPtr1_closure" {
     GHC.Storable.writeWideCharOffPtr1_closure:
         const GHC.Storable.writeWideCharOffPtr1_info;
 },
 GHC.Storable.writeWideCharOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BWf,
                       label: GHC.Storable.writeWideCharOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BWf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BWo; else goto c4BWp;
       c4BWo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWideCharOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BWp: // global
           I64[Sp - 24] = block_c4BWc_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BWy; else goto c4BWd;
       u4BWy: // global
           call _c4BWc(R1) args: 0, res: 0, upd: 0;
       c4BWd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BWc() //  [R1]
         { info_tbl: [(c4BWc,
                       label: block_c4BWc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BWc: // global
           I64[Sp] = block_c4BWi_info;
           _s4Buk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Buk::I64;
           if (R1 & 7 != 0) goto u4BWx; else goto c4BWj;
       u4BWx: // global
           call _c4BWi(R1) args: 0, res: 0, upd: 0;
       c4BWj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BWi() //  [R1]
         { info_tbl: [(c4BWi,
                       label: block_c4BWi_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BWi: // global
           I64[Sp] = block_c4BWn_info;
           _s4Bum::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bum::I64;
           if (R1 & 7 != 0) goto u4BWz; else goto c4BWs;
       u4BWz: // global
           call _c4BWn(R1) args: 0, res: 0, upd: 0;
       c4BWs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BWn() //  [R1]
         { info_tbl: [(c4BWn,
                       label: block_c4BWn_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BWn: // global
           I32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.638783541 UTC

[section ""data" . GHC.Storable.writeWideCharOffPtr_closure" {
     GHC.Storable.writeWideCharOffPtr_closure:
         const GHC.Storable.writeWideCharOffPtr_info;
 },
 GHC.Storable.writeWideCharOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BWE,
                       label: GHC.Storable.writeWideCharOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BWE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWideCharOffPtr1_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.639932692 UTC

[section ""data" . GHC.Storable.writeIntOffPtr1_closure" {
     GHC.Storable.writeIntOffPtr1_closure:
         const GHC.Storable.writeIntOffPtr1_info;
 },
 GHC.Storable.writeIntOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BWO,
                       label: GHC.Storable.writeIntOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BWO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BWX; else goto c4BWY;
       c4BWX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeIntOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BWY: // global
           I64[Sp - 24] = block_c4BWL_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BX7; else goto c4BWM;
       u4BX7: // global
           call _c4BWL(R1) args: 0, res: 0, upd: 0;
       c4BWM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BWL() //  [R1]
         { info_tbl: [(c4BWL,
                       label: block_c4BWL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BWL: // global
           I64[Sp] = block_c4BWR_info;
           _s4Buv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Buv::I64;
           if (R1 & 7 != 0) goto u4BX6; else goto c4BWS;
       u4BX6: // global
           call _c4BWR(R1) args: 0, res: 0, upd: 0;
       c4BWS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BWR() //  [R1]
         { info_tbl: [(c4BWR,
                       label: block_c4BWR_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BWR: // global
           I64[Sp] = block_c4BWW_info;
           _s4Bux::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bux::I64;
           if (R1 & 7 != 0) goto u4BX8; else goto c4BX1;
       u4BX8: // global
           call _c4BWW(R1) args: 0, res: 0, upd: 0;
       c4BX1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BWW() //  [R1]
         { info_tbl: [(c4BWW,
                       label: block_c4BWW_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BWW: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.641560699 UTC

[section ""data" . GHC.Storable.writeIntOffPtr_closure" {
     GHC.Storable.writeIntOffPtr_closure:
         const GHC.Storable.writeIntOffPtr_info;
 },
 GHC.Storable.writeIntOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BXd,
                       label: GHC.Storable.writeIntOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BXd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeIntOffPtr1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.642695103 UTC

[section ""data" . GHC.Storable.writeWordOffPtr1_closure" {
     GHC.Storable.writeWordOffPtr1_closure:
         const GHC.Storable.writeWordOffPtr1_info;
 },
 GHC.Storable.writeWordOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BXn,
                       label: GHC.Storable.writeWordOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BXn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BXw; else goto c4BXx;
       c4BXw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWordOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BXx: // global
           I64[Sp - 24] = block_c4BXk_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BXG; else goto c4BXl;
       u4BXG: // global
           call _c4BXk(R1) args: 0, res: 0, upd: 0;
       c4BXl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BXk() //  [R1]
         { info_tbl: [(c4BXk,
                       label: block_c4BXk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BXk: // global
           I64[Sp] = block_c4BXq_info;
           _s4BuG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BuG::I64;
           if (R1 & 7 != 0) goto u4BXF; else goto c4BXr;
       u4BXF: // global
           call _c4BXq(R1) args: 0, res: 0, upd: 0;
       c4BXr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BXq() //  [R1]
         { info_tbl: [(c4BXq,
                       label: block_c4BXq_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BXq: // global
           I64[Sp] = block_c4BXv_info;
           _s4BuI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BuI::I64;
           if (R1 & 7 != 0) goto u4BXH; else goto c4BXA;
       u4BXH: // global
           call _c4BXv(R1) args: 0, res: 0, upd: 0;
       c4BXA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BXv() //  [R1]
         { info_tbl: [(c4BXv,
                       label: block_c4BXv_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BXv: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.644286148 UTC

[section ""data" . GHC.Storable.writeWordOffPtr_closure" {
     GHC.Storable.writeWordOffPtr_closure:
         const GHC.Storable.writeWordOffPtr_info;
 },
 GHC.Storable.writeWordOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BXM,
                       label: GHC.Storable.writeWordOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BXM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWordOffPtr1_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.645529471 UTC

[section ""data" . GHC.Storable.writePtrOffPtr1_closure" {
     GHC.Storable.writePtrOffPtr1_closure:
         const GHC.Storable.writePtrOffPtr1_info;
 },
 GHC.Storable.writePtrOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BXW,
                       label: GHC.Storable.writePtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BXW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BY5; else goto c4BY6;
       c4BY5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writePtrOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BY6: // global
           I64[Sp - 24] = block_c4BXT_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BYf; else goto c4BXU;
       u4BYf: // global
           call _c4BXT(R1) args: 0, res: 0, upd: 0;
       c4BXU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BXT() //  [R1]
         { info_tbl: [(c4BXT,
                       label: block_c4BXT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BXT: // global
           I64[Sp] = block_c4BXZ_info;
           _s4BuR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BuR::I64;
           if (R1 & 7 != 0) goto u4BYe; else goto c4BY0;
       u4BYe: // global
           call _c4BXZ(R1) args: 0, res: 0, upd: 0;
       c4BY0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BXZ() //  [R1]
         { info_tbl: [(c4BXZ,
                       label: block_c4BXZ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BXZ: // global
           I64[Sp] = block_c4BY4_info;
           _s4BuT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BuT::I64;
           if (R1 & 7 != 0) goto u4BYg; else goto c4BY9;
       u4BYg: // global
           call _c4BY4(R1) args: 0, res: 0, upd: 0;
       c4BY9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BY4() //  [R1]
         { info_tbl: [(c4BY4,
                       label: block_c4BY4_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BY4: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.647283641 UTC

[section ""data" . GHC.Storable.writePtrOffPtr_closure" {
     GHC.Storable.writePtrOffPtr_closure:
         const GHC.Storable.writePtrOffPtr_info;
 },
 GHC.Storable.writePtrOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BYl,
                       label: GHC.Storable.writePtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BYl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writePtrOffPtr1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.64848277 UTC

[section ""data" . GHC.Storable.writeFunPtrOffPtr1_closure" {
     GHC.Storable.writeFunPtrOffPtr1_closure:
         const GHC.Storable.writeFunPtrOffPtr1_info;
 },
 GHC.Storable.writeFunPtrOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BYv,
                       label: GHC.Storable.writeFunPtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BYv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BYE; else goto c4BYF;
       c4BYE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeFunPtrOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BYF: // global
           I64[Sp - 24] = block_c4BYs_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BYO; else goto c4BYt;
       u4BYO: // global
           call _c4BYs(R1) args: 0, res: 0, upd: 0;
       c4BYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BYs() //  [R1]
         { info_tbl: [(c4BYs,
                       label: block_c4BYs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BYs: // global
           I64[Sp] = block_c4BYy_info;
           _s4Bv2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bv2::I64;
           if (R1 & 7 != 0) goto u4BYN; else goto c4BYz;
       u4BYN: // global
           call _c4BYy(R1) args: 0, res: 0, upd: 0;
       c4BYz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BYy() //  [R1]
         { info_tbl: [(c4BYy,
                       label: block_c4BYy_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BYy: // global
           I64[Sp] = block_c4BYD_info;
           _s4Bv4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bv4::I64;
           if (R1 & 7 != 0) goto u4BYP; else goto c4BYI;
       u4BYP: // global
           call _c4BYD(R1) args: 0, res: 0, upd: 0;
       c4BYI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BYD() //  [R1]
         { info_tbl: [(c4BYD,
                       label: block_c4BYD_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BYD: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.651018537 UTC

[section ""data" . GHC.Storable.writeFunPtrOffPtr_closure" {
     GHC.Storable.writeFunPtrOffPtr_closure:
         const GHC.Storable.writeFunPtrOffPtr_info;
 },
 GHC.Storable.writeFunPtrOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BYU,
                       label: GHC.Storable.writeFunPtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BYU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeFunPtrOffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.652166806 UTC

[section ""data" . GHC.Storable.writeFloatOffPtr1_closure" {
     GHC.Storable.writeFloatOffPtr1_closure:
         const GHC.Storable.writeFloatOffPtr1_info;
 },
 GHC.Storable.writeFloatOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BZ4,
                       label: GHC.Storable.writeFloatOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BZ4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BZd; else goto c4BZe;
       c4BZd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeFloatOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BZe: // global
           I64[Sp - 24] = block_c4BZ1_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BZn; else goto c4BZ2;
       u4BZn: // global
           call _c4BZ1(R1) args: 0, res: 0, upd: 0;
       c4BZ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BZ1() //  [R1]
         { info_tbl: [(c4BZ1,
                       label: block_c4BZ1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BZ1: // global
           I64[Sp] = block_c4BZ7_info;
           _s4Bvd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bvd::I64;
           if (R1 & 7 != 0) goto u4BZm; else goto c4BZ8;
       u4BZm: // global
           call _c4BZ7(R1) args: 0, res: 0, upd: 0;
       c4BZ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BZ7() //  [R1]
         { info_tbl: [(c4BZ7,
                       label: block_c4BZ7_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BZ7: // global
           I64[Sp] = block_c4BZc_info;
           _s4Bvf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bvf::I64;
           if (R1 & 7 != 0) goto u4BZo; else goto c4BZh;
       u4BZo: // global
           call _c4BZc(R1) args: 0, res: 0, upd: 0;
       c4BZh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BZc() //  [R1]
         { info_tbl: [(c4BZc,
                       label: block_c4BZc_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BZc: // global
           F32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = F32[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.653730625 UTC

[section ""data" . GHC.Storable.writeFloatOffPtr_closure" {
     GHC.Storable.writeFloatOffPtr_closure:
         const GHC.Storable.writeFloatOffPtr_info;
 },
 GHC.Storable.writeFloatOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BZt,
                       label: GHC.Storable.writeFloatOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BZt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeFloatOffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.654802362 UTC

[section ""data" . GHC.Storable.writeDoubleOffPtr1_closure" {
     GHC.Storable.writeDoubleOffPtr1_closure:
         const GHC.Storable.writeDoubleOffPtr1_info;
 },
 GHC.Storable.writeDoubleOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4BZD,
                       label: GHC.Storable.writeDoubleOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BZD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4BZM; else goto c4BZN;
       c4BZM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeDoubleOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4BZN: // global
           I64[Sp - 24] = block_c4BZA_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4BZW; else goto c4BZB;
       u4BZW: // global
           call _c4BZA(R1) args: 0, res: 0, upd: 0;
       c4BZB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BZA() //  [R1]
         { info_tbl: [(c4BZA,
                       label: block_c4BZA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BZA: // global
           I64[Sp] = block_c4BZG_info;
           _s4Bvo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bvo::I64;
           if (R1 & 7 != 0) goto u4BZV; else goto c4BZH;
       u4BZV: // global
           call _c4BZG(R1) args: 0, res: 0, upd: 0;
       c4BZH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BZG() //  [R1]
         { info_tbl: [(c4BZG,
                       label: block_c4BZG_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BZG: // global
           I64[Sp] = block_c4BZL_info;
           _s4Bvq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bvq::I64;
           if (R1 & 7 != 0) goto u4BZX; else goto c4BZQ;
       u4BZX: // global
           call _c4BZL(R1) args: 0, res: 0, upd: 0;
       c4BZQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4BZL() //  [R1]
         { info_tbl: [(c4BZL,
                       label: block_c4BZL_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4BZL: // global
           F64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = F64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.656386473 UTC

[section ""data" . GHC.Storable.writeDoubleOffPtr_closure" {
     GHC.Storable.writeDoubleOffPtr_closure:
         const GHC.Storable.writeDoubleOffPtr_info;
 },
 GHC.Storable.writeDoubleOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C02,
                       label: GHC.Storable.writeDoubleOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C02: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeDoubleOffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.657541872 UTC

[section ""data" . GHC.Storable.writeStablePtrOffPtr1_closure" {
     GHC.Storable.writeStablePtrOffPtr1_closure:
         const GHC.Storable.writeStablePtrOffPtr1_info;
 },
 GHC.Storable.writeStablePtrOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C0c,
                       label: GHC.Storable.writeStablePtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C0c: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4C0l; else goto c4C0m;
       c4C0l: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeStablePtrOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C0m: // global
           I64[Sp - 24] = block_c4C09_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4C0v; else goto c4C0a;
       u4C0v: // global
           call _c4C09(R1) args: 0, res: 0, upd: 0;
       c4C0a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C09() //  [R1]
         { info_tbl: [(c4C09,
                       label: block_c4C09_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C09: // global
           I64[Sp] = block_c4C0f_info;
           _s4Bvz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bvz::I64;
           if (R1 & 7 != 0) goto u4C0u; else goto c4C0g;
       u4C0u: // global
           call _c4C0f(R1) args: 0, res: 0, upd: 0;
       c4C0g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C0f() //  [R1]
         { info_tbl: [(c4C0f,
                       label: block_c4C0f_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C0f: // global
           I64[Sp] = block_c4C0k_info;
           _s4BvB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BvB::I64;
           if (R1 & 7 != 0) goto u4C0w; else goto c4C0p;
       u4C0w: // global
           call _c4C0k(R1) args: 0, res: 0, upd: 0;
       c4C0p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C0k() //  [R1]
         { info_tbl: [(c4C0k,
                       label: block_c4C0k_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C0k: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.659059889 UTC

[section ""data" . GHC.Storable.writeStablePtrOffPtr_closure" {
     GHC.Storable.writeStablePtrOffPtr_closure:
         const GHC.Storable.writeStablePtrOffPtr_info;
 },
 GHC.Storable.writeStablePtrOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C0B,
                       label: GHC.Storable.writeStablePtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C0B: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeStablePtrOffPtr1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.660221812 UTC

[section ""data" . GHC.Storable.writeInt8OffPtr1_closure" {
     GHC.Storable.writeInt8OffPtr1_closure:
         const GHC.Storable.writeInt8OffPtr1_info;
 },
 GHC.Storable.writeInt8OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C0L,
                       label: GHC.Storable.writeInt8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C0L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4C0U; else goto c4C0V;
       c4C0U: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt8OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C0V: // global
           I64[Sp - 24] = block_c4C0I_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4C14; else goto c4C0J;
       u4C14: // global
           call _c4C0I(R1) args: 0, res: 0, upd: 0;
       c4C0J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C0I() //  [R1]
         { info_tbl: [(c4C0I,
                       label: block_c4C0I_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C0I: // global
           I64[Sp] = block_c4C0O_info;
           _s4BvK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BvK::I64;
           if (R1 & 7 != 0) goto u4C13; else goto c4C0P;
       u4C13: // global
           call _c4C0O(R1) args: 0, res: 0, upd: 0;
       c4C0P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C0O() //  [R1]
         { info_tbl: [(c4C0O,
                       label: block_c4C0O_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C0O: // global
           I64[Sp] = block_c4C0T_info;
           _s4BvM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BvM::I64;
           if (R1 & 7 != 0) goto u4C15; else goto c4C0Y;
       u4C15: // global
           call _c4C0T(R1) args: 0, res: 0, upd: 0;
       c4C0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C0T() //  [R1]
         { info_tbl: [(c4C0T,
                       label: block_c4C0T_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C0T: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.661949583 UTC

[section ""data" . GHC.Storable.writeInt8OffPtr_closure" {
     GHC.Storable.writeInt8OffPtr_closure:
         const GHC.Storable.writeInt8OffPtr_info;
 },
 GHC.Storable.writeInt8OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C1a,
                       label: GHC.Storable.writeInt8OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C1a: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt8OffPtr1_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.663105052 UTC

[section ""data" . GHC.Storable.writeWord8OffPtr1_closure" {
     GHC.Storable.writeWord8OffPtr1_closure:
         const GHC.Storable.writeWord8OffPtr1_info;
 },
 GHC.Storable.writeWord8OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C1k,
                       label: GHC.Storable.writeWord8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C1k: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4C1t; else goto c4C1u;
       c4C1t: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord8OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C1u: // global
           I64[Sp - 24] = block_c4C1h_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4C1D; else goto c4C1i;
       u4C1D: // global
           call _c4C1h(R1) args: 0, res: 0, upd: 0;
       c4C1i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C1h() //  [R1]
         { info_tbl: [(c4C1h,
                       label: block_c4C1h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C1h: // global
           I64[Sp] = block_c4C1n_info;
           _s4BvV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BvV::I64;
           if (R1 & 7 != 0) goto u4C1C; else goto c4C1o;
       u4C1C: // global
           call _c4C1n(R1) args: 0, res: 0, upd: 0;
       c4C1o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C1n() //  [R1]
         { info_tbl: [(c4C1n,
                       label: block_c4C1n_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C1n: // global
           I64[Sp] = block_c4C1s_info;
           _s4BvX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BvX::I64;
           if (R1 & 7 != 0) goto u4C1E; else goto c4C1x;
       u4C1E: // global
           call _c4C1s(R1) args: 0, res: 0, upd: 0;
       c4C1x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C1s() //  [R1]
         { info_tbl: [(c4C1s,
                       label: block_c4C1s_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C1s: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.664709565 UTC

[section ""data" . GHC.Storable.writeWord8OffPtr_closure" {
     GHC.Storable.writeWord8OffPtr_closure:
         const GHC.Storable.writeWord8OffPtr_info;
 },
 GHC.Storable.writeWord8OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C1J,
                       label: GHC.Storable.writeWord8OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C1J: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord8OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.666072234 UTC

[section ""data" . GHC.Storable.writeInt16OffPtr1_closure" {
     GHC.Storable.writeInt16OffPtr1_closure:
         const GHC.Storable.writeInt16OffPtr1_info;
 },
 GHC.Storable.writeInt16OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C1T,
                       label: GHC.Storable.writeInt16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C1T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4C22; else goto c4C23;
       c4C22: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt16OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C23: // global
           I64[Sp - 24] = block_c4C1Q_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4C2c; else goto c4C1R;
       u4C2c: // global
           call _c4C1Q(R1) args: 0, res: 0, upd: 0;
       c4C1R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C1Q() //  [R1]
         { info_tbl: [(c4C1Q,
                       label: block_c4C1Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C1Q: // global
           I64[Sp] = block_c4C1W_info;
           _s4Bw6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bw6::I64;
           if (R1 & 7 != 0) goto u4C2b; else goto c4C1X;
       u4C2b: // global
           call _c4C1W(R1) args: 0, res: 0, upd: 0;
       c4C1X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C1W() //  [R1]
         { info_tbl: [(c4C1W,
                       label: block_c4C1W_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C1W: // global
           I64[Sp] = block_c4C21_info;
           _s4Bw8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bw8::I64;
           if (R1 & 7 != 0) goto u4C2d; else goto c4C26;
       u4C2d: // global
           call _c4C21(R1) args: 0, res: 0, upd: 0;
       c4C26: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C21() //  [R1]
         { info_tbl: [(c4C21,
                       label: block_c4C21_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C21: // global
           I16[I64[Sp + 8] + (I64[Sp + 16] << 1)] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.668829273 UTC

[section ""data" . GHC.Storable.writeInt16OffPtr_closure" {
     GHC.Storable.writeInt16OffPtr_closure:
         const GHC.Storable.writeInt16OffPtr_info;
 },
 GHC.Storable.writeInt16OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C2i,
                       label: GHC.Storable.writeInt16OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C2i: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt16OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.670106117 UTC

[section ""data" . GHC.Storable.writeWord16OffPtr1_closure" {
     GHC.Storable.writeWord16OffPtr1_closure:
         const GHC.Storable.writeWord16OffPtr1_info;
 },
 GHC.Storable.writeWord16OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C2s,
                       label: GHC.Storable.writeWord16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C2s: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4C2B; else goto c4C2C;
       c4C2B: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord16OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C2C: // global
           I64[Sp - 24] = block_c4C2p_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4C2L; else goto c4C2q;
       u4C2L: // global
           call _c4C2p(R1) args: 0, res: 0, upd: 0;
       c4C2q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C2p() //  [R1]
         { info_tbl: [(c4C2p,
                       label: block_c4C2p_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C2p: // global
           I64[Sp] = block_c4C2v_info;
           _s4Bwh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bwh::I64;
           if (R1 & 7 != 0) goto u4C2K; else goto c4C2w;
       u4C2K: // global
           call _c4C2v(R1) args: 0, res: 0, upd: 0;
       c4C2w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C2v() //  [R1]
         { info_tbl: [(c4C2v,
                       label: block_c4C2v_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C2v: // global
           I64[Sp] = block_c4C2A_info;
           _s4Bwj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bwj::I64;
           if (R1 & 7 != 0) goto u4C2M; else goto c4C2F;
       u4C2M: // global
           call _c4C2A(R1) args: 0, res: 0, upd: 0;
       c4C2F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C2A() //  [R1]
         { info_tbl: [(c4C2A,
                       label: block_c4C2A_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C2A: // global
           I16[I64[Sp + 8] + (I64[Sp + 16] << 1)] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.671683826 UTC

[section ""data" . GHC.Storable.writeWord16OffPtr_closure" {
     GHC.Storable.writeWord16OffPtr_closure:
         const GHC.Storable.writeWord16OffPtr_info;
 },
 GHC.Storable.writeWord16OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C2R,
                       label: GHC.Storable.writeWord16OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C2R: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord16OffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.672781714 UTC

[section ""data" . GHC.Storable.writeInt32OffPtr1_closure" {
     GHC.Storable.writeInt32OffPtr1_closure:
         const GHC.Storable.writeInt32OffPtr1_info;
 },
 GHC.Storable.writeInt32OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C31,
                       label: GHC.Storable.writeInt32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C31: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4C3a; else goto c4C3b;
       c4C3a: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt32OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C3b: // global
           I64[Sp - 24] = block_c4C2Y_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4C3k; else goto c4C2Z;
       u4C3k: // global
           call _c4C2Y(R1) args: 0, res: 0, upd: 0;
       c4C2Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C2Y() //  [R1]
         { info_tbl: [(c4C2Y,
                       label: block_c4C2Y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C2Y: // global
           I64[Sp] = block_c4C34_info;
           _s4Bws::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bws::I64;
           if (R1 & 7 != 0) goto u4C3j; else goto c4C35;
       u4C3j: // global
           call _c4C34(R1) args: 0, res: 0, upd: 0;
       c4C35: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C34() //  [R1]
         { info_tbl: [(c4C34,
                       label: block_c4C34_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C34: // global
           I64[Sp] = block_c4C39_info;
           _s4Bwu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bwu::I64;
           if (R1 & 7 != 0) goto u4C3l; else goto c4C3e;
       u4C3l: // global
           call _c4C39(R1) args: 0, res: 0, upd: 0;
       c4C3e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C39() //  [R1]
         { info_tbl: [(c4C39,
                       label: block_c4C39_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C39: // global
           I32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.674377149 UTC

[section ""data" . GHC.Storable.writeInt32OffPtr_closure" {
     GHC.Storable.writeInt32OffPtr_closure:
         const GHC.Storable.writeInt32OffPtr_info;
 },
 GHC.Storable.writeInt32OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C3q,
                       label: GHC.Storable.writeInt32OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C3q: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt32OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.675532679 UTC

[section ""data" . GHC.Storable.writeWord32OffPtr1_closure" {
     GHC.Storable.writeWord32OffPtr1_closure:
         const GHC.Storable.writeWord32OffPtr1_info;
 },
 GHC.Storable.writeWord32OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C3A,
                       label: GHC.Storable.writeWord32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C3A: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4C3J; else goto c4C3K;
       c4C3J: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord32OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C3K: // global
           I64[Sp - 24] = block_c4C3x_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4C3T; else goto c4C3y;
       u4C3T: // global
           call _c4C3x(R1) args: 0, res: 0, upd: 0;
       c4C3y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C3x() //  [R1]
         { info_tbl: [(c4C3x,
                       label: block_c4C3x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C3x: // global
           I64[Sp] = block_c4C3D_info;
           _s4BwD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BwD::I64;
           if (R1 & 7 != 0) goto u4C3S; else goto c4C3E;
       u4C3S: // global
           call _c4C3D(R1) args: 0, res: 0, upd: 0;
       c4C3E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C3D() //  [R1]
         { info_tbl: [(c4C3D,
                       label: block_c4C3D_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C3D: // global
           I64[Sp] = block_c4C3I_info;
           _s4BwF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BwF::I64;
           if (R1 & 7 != 0) goto u4C3U; else goto c4C3N;
       u4C3U: // global
           call _c4C3I(R1) args: 0, res: 0, upd: 0;
       c4C3N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C3I() //  [R1]
         { info_tbl: [(c4C3I,
                       label: block_c4C3I_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C3I: // global
           I32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.677124947 UTC

[section ""data" . GHC.Storable.writeWord32OffPtr_closure" {
     GHC.Storable.writeWord32OffPtr_closure:
         const GHC.Storable.writeWord32OffPtr_info;
 },
 GHC.Storable.writeWord32OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C3Z,
                       label: GHC.Storable.writeWord32OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C3Z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord32OffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.678384708 UTC

[section ""data" . GHC.Storable.writeInt64OffPtr1_closure" {
     GHC.Storable.writeInt64OffPtr1_closure:
         const GHC.Storable.writeInt64OffPtr1_info;
 },
 GHC.Storable.writeInt64OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C49,
                       label: GHC.Storable.writeInt64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C49: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4C4i; else goto c4C4j;
       c4C4i: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt64OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C4j: // global
           I64[Sp - 24] = block_c4C46_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4C4s; else goto c4C47;
       u4C4s: // global
           call _c4C46(R1) args: 0, res: 0, upd: 0;
       c4C47: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C46() //  [R1]
         { info_tbl: [(c4C46,
                       label: block_c4C46_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C46: // global
           I64[Sp] = block_c4C4c_info;
           _s4BwO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BwO::I64;
           if (R1 & 7 != 0) goto u4C4r; else goto c4C4d;
       u4C4r: // global
           call _c4C4c(R1) args: 0, res: 0, upd: 0;
       c4C4d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C4c() //  [R1]
         { info_tbl: [(c4C4c,
                       label: block_c4C4c_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C4c: // global
           I64[Sp] = block_c4C4h_info;
           _s4BwQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BwQ::I64;
           if (R1 & 7 != 0) goto u4C4t; else goto c4C4m;
       u4C4t: // global
           call _c4C4h(R1) args: 0, res: 0, upd: 0;
       c4C4m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C4h() //  [R1]
         { info_tbl: [(c4C4h,
                       label: block_c4C4h_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C4h: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.680029637 UTC

[section ""data" . GHC.Storable.writeInt64OffPtr_closure" {
     GHC.Storable.writeInt64OffPtr_closure:
         const GHC.Storable.writeInt64OffPtr_info;
 },
 GHC.Storable.writeInt64OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C4y,
                       label: GHC.Storable.writeInt64OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C4y: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt64OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.681193274 UTC

[section ""data" . GHC.Storable.writeWord64OffPtr1_closure" {
     GHC.Storable.writeWord64OffPtr1_closure:
         const GHC.Storable.writeWord64OffPtr1_info;
 },
 GHC.Storable.writeWord64OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C4I,
                       label: GHC.Storable.writeWord64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C4I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4C4R; else goto c4C4S;
       c4C4R: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord64OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C4S: // global
           I64[Sp - 24] = block_c4C4F_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4C51; else goto c4C4G;
       u4C51: // global
           call _c4C4F(R1) args: 0, res: 0, upd: 0;
       c4C4G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C4F() //  [R1]
         { info_tbl: [(c4C4F,
                       label: block_c4C4F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C4F: // global
           I64[Sp] = block_c4C4L_info;
           _s4BwZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BwZ::I64;
           if (R1 & 7 != 0) goto u4C50; else goto c4C4M;
       u4C50: // global
           call _c4C4L(R1) args: 0, res: 0, upd: 0;
       c4C4M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C4L() //  [R1]
         { info_tbl: [(c4C4L,
                       label: block_c4C4L_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C4L: // global
           I64[Sp] = block_c4C4Q_info;
           _s4Bx1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bx1::I64;
           if (R1 & 7 != 0) goto u4C52; else goto c4C4V;
       u4C52: // global
           call _c4C4Q(R1) args: 0, res: 0, upd: 0;
       c4C4V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C4Q() //  [R1]
         { info_tbl: [(c4C4Q,
                       label: block_c4C4Q_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C4Q: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.682871389 UTC

[section ""data" . GHC.Storable.writeWord64OffPtr_closure" {
     GHC.Storable.writeWord64OffPtr_closure:
         const GHC.Storable.writeWord64OffPtr_info;
 },
 GHC.Storable.writeWord64OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4C57,
                       label: GHC.Storable.writeWord64OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C57: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord64OffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.683600782 UTC

[section ""cstring" . GHC.Storable.$trModule4_bytes" {
     GHC.Storable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.684230415 UTC

[section ""data" . GHC.Storable.$trModule3_closure" {
     GHC.Storable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Storable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.684848072 UTC

[section ""cstring" . GHC.Storable.$trModule2_bytes" {
     GHC.Storable.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,111,114,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.685939645 UTC

[section ""data" . GHC.Storable.$trModule1_closure" {
     GHC.Storable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Storable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.686540314 UTC

[section ""data" . GHC.Storable.$trModule_closure" {
     GHC.Storable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Storable.$trModule3_closure+1;
         const GHC.Storable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.687976762 UTC

[section ""relreadonly" . S4BO7_srt" { S4BO7_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.688791169 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:27.690563611 UTC

[section ""data" . GHC.Storable.readWideCharOffPtr1_closure" {
     GHC.Storable.readWideCharOffPtr1_closure:
         const GHC.Storable.readWideCharOffPtr1_info;
 },
 GHC.Storable.readWideCharOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4C5h,
                       label: GHC.Storable.readWideCharOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C5h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4C5q; else goto c4C5r;
       c4C5q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWideCharOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C5r: // global
           I64[Sp - 16] = block_c4C5e_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4C5x; else goto c4C5f;
       u4C5x: // global
           call _c4C5e(R1) args: 0, res: 0, upd: 0;
       c4C5f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C5e() //  [R1]
         { info_tbl: [(c4C5e,
                       label: block_c4C5e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C5e: // global
           I64[Sp] = block_c4C5k_info;
           _s4Brt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Brt::I64;
           if (R1 & 7 != 0) goto u4C5w; else goto c4C5l;
       u4C5w: // global
           call _c4C5k(R1) args: 0, res: 0, upd: 0;
       c4C5l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C5k() //  [R1]
         { info_tbl: [(c4C5k,
                       label: block_c4C5k_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C5k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4C5v; else goto c4C5u;
       c4C5v: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4C5u: // global
           _s4Bry::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s4Bry::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.698774089 UTC

[section ""data" . GHC.Storable.readWideCharOffPtr_closure" {
     GHC.Storable.readWideCharOffPtr_closure:
         const GHC.Storable.readWideCharOffPtr_info;
 },
 GHC.Storable.readWideCharOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4C5S,
                       label: GHC.Storable.readWideCharOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C5S: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWideCharOffPtr1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.70294678 UTC

[section ""data" . GHC.Storable.readIntOffPtr1_closure" {
     GHC.Storable.readIntOffPtr1_closure:
         const GHC.Storable.readIntOffPtr1_info;
 },
 GHC.Storable.readIntOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4C66,
                       label: GHC.Storable.readIntOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C66: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4C6f; else goto c4C6g;
       c4C6f: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readIntOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C6g: // global
           I64[Sp - 16] = block_c4C63_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4C6m; else goto c4C64;
       u4C6m: // global
           call _c4C63(R1) args: 0, res: 0, upd: 0;
       c4C64: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C63() //  [R1]
         { info_tbl: [(c4C63,
                       label: block_c4C63_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C63: // global
           I64[Sp] = block_c4C69_info;
           _s4BrE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BrE::I64;
           if (R1 & 7 != 0) goto u4C6l; else goto c4C6a;
       u4C6l: // global
           call _c4C69(R1) args: 0, res: 0, upd: 0;
       c4C6a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C69() //  [R1]
         { info_tbl: [(c4C69,
                       label: block_c4C69_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C69: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4C6k; else goto c4C6j;
       c4C6k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4C6j: // global
           _s4BrJ::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4BrJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.712624696 UTC

[section ""data" . GHC.Storable.readIntOffPtr_closure" {
     GHC.Storable.readIntOffPtr_closure:
         const GHC.Storable.readIntOffPtr_info;
 },
 GHC.Storable.readIntOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4C6H,
                       label: GHC.Storable.readIntOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C6H: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readIntOffPtr1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.716885722 UTC

[section ""data" . GHC.Storable.readWordOffPtr1_closure" {
     GHC.Storable.readWordOffPtr1_closure:
         const GHC.Storable.readWordOffPtr1_info;
 },
 GHC.Storable.readWordOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4C6V,
                       label: GHC.Storable.readWordOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C6V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4C74; else goto c4C75;
       c4C74: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWordOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C75: // global
           I64[Sp - 16] = block_c4C6S_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4C7b; else goto c4C6T;
       u4C7b: // global
           call _c4C6S(R1) args: 0, res: 0, upd: 0;
       c4C6T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C6S() //  [R1]
         { info_tbl: [(c4C6S,
                       label: block_c4C6S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C6S: // global
           I64[Sp] = block_c4C6Y_info;
           _s4BrP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BrP::I64;
           if (R1 & 7 != 0) goto u4C7a; else goto c4C6Z;
       u4C7a: // global
           call _c4C6Y(R1) args: 0, res: 0, upd: 0;
       c4C6Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C6Y() //  [R1]
         { info_tbl: [(c4C6Y,
                       label: block_c4C6Y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C6Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4C79; else goto c4C78;
       c4C79: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4C78: // global
           _s4BrU::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s4BrU::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.726377435 UTC

[section ""data" . GHC.Storable.readWordOffPtr_closure" {
     GHC.Storable.readWordOffPtr_closure:
         const GHC.Storable.readWordOffPtr_info;
 },
 GHC.Storable.readWordOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4C7w,
                       label: GHC.Storable.readWordOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C7w: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWordOffPtr1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.730383666 UTC

[section ""data" . GHC.Storable.readPtrOffPtr1_closure" {
     GHC.Storable.readPtrOffPtr1_closure:
         const GHC.Storable.readPtrOffPtr1_info;
 },
 GHC.Storable.readPtrOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4C7K,
                       label: GHC.Storable.readPtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C7K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4C7T; else goto c4C7U;
       c4C7T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readPtrOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C7U: // global
           I64[Sp - 16] = block_c4C7H_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4C80; else goto c4C7I;
       u4C80: // global
           call _c4C7H(R1) args: 0, res: 0, upd: 0;
       c4C7I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C7H() //  [R1]
         { info_tbl: [(c4C7H,
                       label: block_c4C7H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C7H: // global
           I64[Sp] = block_c4C7N_info;
           _s4Bs0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bs0::I64;
           if (R1 & 7 != 0) goto u4C7Z; else goto c4C7O;
       u4C7Z: // global
           call _c4C7N(R1) args: 0, res: 0, upd: 0;
       c4C7O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C7N() //  [R1]
         { info_tbl: [(c4C7N,
                       label: block_c4C7N_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C7N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4C7Y; else goto c4C7X;
       c4C7Y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4C7X: // global
           _s4Bs5::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Bs5::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.73873802 UTC

[section ""data" . GHC.Storable.readPtrOffPtr_closure" {
     GHC.Storable.readPtrOffPtr_closure:
         const GHC.Storable.readPtrOffPtr_info;
 },
 GHC.Storable.readPtrOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4C8l,
                       label: GHC.Storable.readPtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C8l: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readPtrOffPtr1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.742757148 UTC

[section ""data" . GHC.Storable.readFunPtrOffPtr1_closure" {
     GHC.Storable.readFunPtrOffPtr1_closure:
         const GHC.Storable.readFunPtrOffPtr1_info;
 },
 GHC.Storable.readFunPtrOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4C8z,
                       label: GHC.Storable.readFunPtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C8z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4C8I; else goto c4C8J;
       c4C8I: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readFunPtrOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C8J: // global
           I64[Sp - 16] = block_c4C8w_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4C8P; else goto c4C8x;
       u4C8P: // global
           call _c4C8w(R1) args: 0, res: 0, upd: 0;
       c4C8x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C8w() //  [R1]
         { info_tbl: [(c4C8w,
                       label: block_c4C8w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C8w: // global
           I64[Sp] = block_c4C8C_info;
           _s4Bsb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bsb::I64;
           if (R1 & 7 != 0) goto u4C8O; else goto c4C8D;
       u4C8O: // global
           call _c4C8C(R1) args: 0, res: 0, upd: 0;
       c4C8D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C8C() //  [R1]
         { info_tbl: [(c4C8C,
                       label: block_c4C8C_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C8C: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4C8N; else goto c4C8M;
       c4C8N: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4C8M: // global
           _s4Bsg::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s4Bsg::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.751866188 UTC

[section ""data" . GHC.Storable.readFunPtrOffPtr_closure" {
     GHC.Storable.readFunPtrOffPtr_closure:
         const GHC.Storable.readFunPtrOffPtr_info;
 },
 GHC.Storable.readFunPtrOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4C9a,
                       label: GHC.Storable.readFunPtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C9a: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readFunPtrOffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.755769516 UTC

[section ""data" . GHC.Storable.readFloatOffPtr1_closure" {
     GHC.Storable.readFloatOffPtr1_closure:
         const GHC.Storable.readFloatOffPtr1_info;
 },
 GHC.Storable.readFloatOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4C9o,
                       label: GHC.Storable.readFloatOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C9o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4C9x; else goto c4C9y;
       c4C9x: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readFloatOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4C9y: // global
           I64[Sp - 16] = block_c4C9l_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4C9E; else goto c4C9m;
       u4C9E: // global
           call _c4C9l(R1) args: 0, res: 0, upd: 0;
       c4C9m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C9l() //  [R1]
         { info_tbl: [(c4C9l,
                       label: block_c4C9l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C9l: // global
           I64[Sp] = block_c4C9r_info;
           _s4Bsm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bsm::I64;
           if (R1 & 7 != 0) goto u4C9D; else goto c4C9s;
       u4C9D: // global
           call _c4C9r(R1) args: 0, res: 0, upd: 0;
       c4C9s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4C9r() //  [R1]
         { info_tbl: [(c4C9r,
                       label: block_c4C9r_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C9r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4C9C; else goto c4C9B;
       c4C9C: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4C9B: // global
           _s4Bsr::F32 = F32[I64[Sp + 8] + (I64[R1 + 7] << 2)];
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _s4Bsr::F32;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.76464912 UTC

[section ""data" . GHC.Storable.readFloatOffPtr_closure" {
     GHC.Storable.readFloatOffPtr_closure:
         const GHC.Storable.readFloatOffPtr_info;
 },
 GHC.Storable.readFloatOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4C9Z,
                       label: GHC.Storable.readFloatOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4C9Z: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readFloatOffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.768492135 UTC

[section ""data" . GHC.Storable.readDoubleOffPtr1_closure" {
     GHC.Storable.readDoubleOffPtr1_closure:
         const GHC.Storable.readDoubleOffPtr1_info;
 },
 GHC.Storable.readDoubleOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4Cad,
                       label: GHC.Storable.readDoubleOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cad: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Cam; else goto c4Can;
       c4Cam: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readDoubleOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Can: // global
           I64[Sp - 16] = block_c4Caa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Cat; else goto c4Cab;
       u4Cat: // global
           call _c4Caa(R1) args: 0, res: 0, upd: 0;
       c4Cab: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Caa() //  [R1]
         { info_tbl: [(c4Caa,
                       label: block_c4Caa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Caa: // global
           I64[Sp] = block_c4Cag_info;
           _s4Bsx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bsx::I64;
           if (R1 & 7 != 0) goto u4Cas; else goto c4Cah;
       u4Cas: // global
           call _c4Cag(R1) args: 0, res: 0, upd: 0;
       c4Cah: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cag() //  [R1]
         { info_tbl: [(c4Cag,
                       label: block_c4Cag_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cag: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Car; else goto c4Caq;
       c4Car: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Caq: // global
           _s4BsC::F64 = F64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _s4BsC::F64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.776565049 UTC

[section ""data" . GHC.Storable.readDoubleOffPtr_closure" {
     GHC.Storable.readDoubleOffPtr_closure:
         const GHC.Storable.readDoubleOffPtr_info;
 },
 GHC.Storable.readDoubleOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CaO,
                       label: GHC.Storable.readDoubleOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CaO: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readDoubleOffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.780995618 UTC

[section ""data" . GHC.Storable.readStablePtrOffPtr1_closure" {
     GHC.Storable.readStablePtrOffPtr1_closure:
         const GHC.Storable.readStablePtrOffPtr1_info;
 },
 GHC.Storable.readStablePtrOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4Cb2,
                       label: GHC.Storable.readStablePtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cb2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Cbb; else goto c4Cbc;
       c4Cbb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readStablePtrOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cbc: // global
           I64[Sp - 16] = block_c4CaZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Cbi; else goto c4Cb0;
       u4Cbi: // global
           call _c4CaZ(R1) args: 0, res: 0, upd: 0;
       c4Cb0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CaZ() //  [R1]
         { info_tbl: [(c4CaZ,
                       label: block_c4CaZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CaZ: // global
           I64[Sp] = block_c4Cb5_info;
           _s4BsI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BsI::I64;
           if (R1 & 7 != 0) goto u4Cbh; else goto c4Cb6;
       u4Cbh: // global
           call _c4Cb5(R1) args: 0, res: 0, upd: 0;
       c4Cb6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cb5() //  [R1]
         { info_tbl: [(c4Cb5,
                       label: block_c4Cb5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cb5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Cbg; else goto c4Cbf;
       c4Cbg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Cbf: // global
           _s4BsN::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = _s4BsN::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.789012485 UTC

[section ""data" . GHC.Storable.readStablePtrOffPtr_closure" {
     GHC.Storable.readStablePtrOffPtr_closure:
         const GHC.Storable.readStablePtrOffPtr_info;
 },
 GHC.Storable.readStablePtrOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CbD,
                       label: GHC.Storable.readStablePtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CbD: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readStablePtrOffPtr1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.793825179 UTC

[section ""data" . GHC.Storable.readInt8OffPtr1_closure" {
     GHC.Storable.readInt8OffPtr1_closure:
         const GHC.Storable.readInt8OffPtr1_info;
 },
 GHC.Storable.readInt8OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CbR,
                       label: GHC.Storable.readInt8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CbR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Cc0; else goto c4Cc1;
       c4Cc0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt8OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cc1: // global
           I64[Sp - 16] = block_c4CbO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Cc7; else goto c4CbP;
       u4Cc7: // global
           call _c4CbO(R1) args: 0, res: 0, upd: 0;
       c4CbP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CbO() //  [R1]
         { info_tbl: [(c4CbO,
                       label: block_c4CbO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CbO: // global
           I64[Sp] = block_c4CbU_info;
           _s4BsT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BsT::I64;
           if (R1 & 7 != 0) goto u4Cc6; else goto c4CbV;
       u4Cc6: // global
           call _c4CbU(R1) args: 0, res: 0, upd: 0;
       c4CbV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CbU() //  [R1]
         { info_tbl: [(c4CbU,
                       label: block_c4CbU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CbU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Cc5; else goto c4Cc4;
       c4Cc5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Cc4: // global
           _s4BsY::I64 = %MO_SS_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4BsY::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.802671618 UTC

[section ""data" . GHC.Storable.readInt8OffPtr_closure" {
     GHC.Storable.readInt8OffPtr_closure:
         const GHC.Storable.readInt8OffPtr_info;
 },
 GHC.Storable.readInt8OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4Ccs,
                       label: GHC.Storable.readInt8OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ccs: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt8OffPtr1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.806472949 UTC

[section ""data" . GHC.Storable.readWord8OffPtr1_closure" {
     GHC.Storable.readWord8OffPtr1_closure:
         const GHC.Storable.readWord8OffPtr1_info;
 },
 GHC.Storable.readWord8OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CcG,
                       label: GHC.Storable.readWord8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CcG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CcP; else goto c4CcQ;
       c4CcP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord8OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CcQ: // global
           I64[Sp - 16] = block_c4CcD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CcW; else goto c4CcE;
       u4CcW: // global
           call _c4CcD(R1) args: 0, res: 0, upd: 0;
       c4CcE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CcD() //  [R1]
         { info_tbl: [(c4CcD,
                       label: block_c4CcD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CcD: // global
           I64[Sp] = block_c4CcJ_info;
           _s4Bt4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bt4::I64;
           if (R1 & 7 != 0) goto u4CcV; else goto c4CcK;
       u4CcV: // global
           call _c4CcJ(R1) args: 0, res: 0, upd: 0;
       c4CcK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CcJ() //  [R1]
         { info_tbl: [(c4CcJ,
                       label: block_c4CcJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CcJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CcU; else goto c4CcT;
       c4CcU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CcT: // global
           _s4Bt9::I64 = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s4Bt9::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.814883136 UTC

[section ""data" . GHC.Storable.readWord8OffPtr_closure" {
     GHC.Storable.readWord8OffPtr_closure:
         const GHC.Storable.readWord8OffPtr_info;
 },
 GHC.Storable.readWord8OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4Cdh,
                       label: GHC.Storable.readWord8OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cdh: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord8OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.81945317 UTC

[section ""data" . GHC.Storable.readInt16OffPtr1_closure" {
     GHC.Storable.readInt16OffPtr1_closure:
         const GHC.Storable.readInt16OffPtr1_info;
 },
 GHC.Storable.readInt16OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4Cdv,
                       label: GHC.Storable.readInt16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cdv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CdE; else goto c4CdF;
       c4CdE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt16OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CdF: // global
           I64[Sp - 16] = block_c4Cds_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CdL; else goto c4Cdt;
       u4CdL: // global
           call _c4Cds(R1) args: 0, res: 0, upd: 0;
       c4Cdt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cds() //  [R1]
         { info_tbl: [(c4Cds,
                       label: block_c4Cds_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cds: // global
           I64[Sp] = block_c4Cdy_info;
           _s4Btf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Btf::I64;
           if (R1 & 7 != 0) goto u4CdK; else goto c4Cdz;
       u4CdK: // global
           call _c4Cdy(R1) args: 0, res: 0, upd: 0;
       c4Cdz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cdy() //  [R1]
         { info_tbl: [(c4Cdy,
                       label: block_c4Cdy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cdy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CdJ; else goto c4CdI;
       c4CdJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CdI: // global
           _s4Btk::I64 = %MO_SS_Conv_W16_W64(I16[I64[Sp + 8] + (I64[R1 + 7] << 1)]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4Btk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.827392401 UTC

[section ""data" . GHC.Storable.readInt16OffPtr_closure" {
     GHC.Storable.readInt16OffPtr_closure:
         const GHC.Storable.readInt16OffPtr_info;
 },
 GHC.Storable.readInt16OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4Ce6,
                       label: GHC.Storable.readInt16OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ce6: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt16OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.831484287 UTC

[section ""data" . GHC.Storable.readWord16OffPtr1_closure" {
     GHC.Storable.readWord16OffPtr1_closure:
         const GHC.Storable.readWord16OffPtr1_info;
 },
 GHC.Storable.readWord16OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4Cek,
                       label: GHC.Storable.readWord16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cek: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Cet; else goto c4Ceu;
       c4Cet: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord16OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ceu: // global
           I64[Sp - 16] = block_c4Ceh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CeA; else goto c4Cei;
       u4CeA: // global
           call _c4Ceh(R1) args: 0, res: 0, upd: 0;
       c4Cei: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ceh() //  [R1]
         { info_tbl: [(c4Ceh,
                       label: block_c4Ceh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ceh: // global
           I64[Sp] = block_c4Cen_info;
           _s4Btq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Btq::I64;
           if (R1 & 7 != 0) goto u4Cez; else goto c4Ceo;
       u4Cez: // global
           call _c4Cen(R1) args: 0, res: 0, upd: 0;
       c4Ceo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cen() //  [R1]
         { info_tbl: [(c4Cen,
                       label: block_c4Cen_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cen: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Cey; else goto c4Cex;
       c4Cey: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Cex: // global
           _s4Btv::I64 = %MO_UU_Conv_W16_W64(I16[I64[Sp + 8] + (I64[R1 + 7] << 1)]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s4Btv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.840022736 UTC

[section ""data" . GHC.Storable.readWord16OffPtr_closure" {
     GHC.Storable.readWord16OffPtr_closure:
         const GHC.Storable.readWord16OffPtr_info;
 },
 GHC.Storable.readWord16OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CeV,
                       label: GHC.Storable.readWord16OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CeV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord16OffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.844098162 UTC

[section ""data" . GHC.Storable.readInt32OffPtr1_closure" {
     GHC.Storable.readInt32OffPtr1_closure:
         const GHC.Storable.readInt32OffPtr1_info;
 },
 GHC.Storable.readInt32OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4Cf9,
                       label: GHC.Storable.readInt32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cf9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Cfi; else goto c4Cfj;
       c4Cfi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt32OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cfj: // global
           I64[Sp - 16] = block_c4Cf6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Cfp; else goto c4Cf7;
       u4Cfp: // global
           call _c4Cf6(R1) args: 0, res: 0, upd: 0;
       c4Cf7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cf6() //  [R1]
         { info_tbl: [(c4Cf6,
                       label: block_c4Cf6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cf6: // global
           I64[Sp] = block_c4Cfc_info;
           _s4BtB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BtB::I64;
           if (R1 & 7 != 0) goto u4Cfo; else goto c4Cfd;
       u4Cfo: // global
           call _c4Cfc(R1) args: 0, res: 0, upd: 0;
       c4Cfd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cfc() //  [R1]
         { info_tbl: [(c4Cfc,
                       label: block_c4Cfc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cfc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Cfn; else goto c4Cfm;
       c4Cfn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Cfm: // global
           _s4BtG::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4BtG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.852913563 UTC

[section ""data" . GHC.Storable.readInt32OffPtr_closure" {
     GHC.Storable.readInt32OffPtr_closure:
         const GHC.Storable.readInt32OffPtr_info;
 },
 GHC.Storable.readInt32OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CfK,
                       label: GHC.Storable.readInt32OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CfK: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt32OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.857920886 UTC

[section ""data" . GHC.Storable.readWord32OffPtr1_closure" {
     GHC.Storable.readWord32OffPtr1_closure:
         const GHC.Storable.readWord32OffPtr1_info;
 },
 GHC.Storable.readWord32OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CfY,
                       label: GHC.Storable.readWord32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CfY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Cg7; else goto c4Cg8;
       c4Cg7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord32OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cg8: // global
           I64[Sp - 16] = block_c4CfV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Cge; else goto c4CfW;
       u4Cge: // global
           call _c4CfV(R1) args: 0, res: 0, upd: 0;
       c4CfW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CfV() //  [R1]
         { info_tbl: [(c4CfV,
                       label: block_c4CfV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CfV: // global
           I64[Sp] = block_c4Cg1_info;
           _s4BtM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BtM::I64;
           if (R1 & 7 != 0) goto u4Cgd; else goto c4Cg2;
       u4Cgd: // global
           call _c4Cg1(R1) args: 0, res: 0, upd: 0;
       c4Cg2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cg1() //  [R1]
         { info_tbl: [(c4Cg1,
                       label: block_c4Cg1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cg1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Cgc; else goto c4Cgb;
       c4Cgc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Cgb: // global
           _s4BtR::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s4BtR::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.866220572 UTC

[section ""data" . GHC.Storable.readWord32OffPtr_closure" {
     GHC.Storable.readWord32OffPtr_closure:
         const GHC.Storable.readWord32OffPtr_info;
 },
 GHC.Storable.readWord32OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4Cgz,
                       label: GHC.Storable.readWord32OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cgz: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord32OffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.870344131 UTC

[section ""data" . GHC.Storable.readInt64OffPtr1_closure" {
     GHC.Storable.readInt64OffPtr1_closure:
         const GHC.Storable.readInt64OffPtr1_info;
 },
 GHC.Storable.readInt64OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CgN,
                       label: GHC.Storable.readInt64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CgN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CgW; else goto c4CgX;
       c4CgW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt64OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CgX: // global
           I64[Sp - 16] = block_c4CgK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Ch3; else goto c4CgL;
       u4Ch3: // global
           call _c4CgK(R1) args: 0, res: 0, upd: 0;
       c4CgL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CgK() //  [R1]
         { info_tbl: [(c4CgK,
                       label: block_c4CgK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CgK: // global
           I64[Sp] = block_c4CgQ_info;
           _s4BtX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BtX::I64;
           if (R1 & 7 != 0) goto u4Ch2; else goto c4CgR;
       u4Ch2: // global
           call _c4CgQ(R1) args: 0, res: 0, upd: 0;
       c4CgR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CgQ() //  [R1]
         { info_tbl: [(c4CgQ,
                       label: block_c4CgQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CgQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Ch1; else goto c4Ch0;
       c4Ch1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Ch0: // global
           _s4Bu2::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4Bu2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.879677378 UTC

[section ""data" . GHC.Storable.readInt64OffPtr_closure" {
     GHC.Storable.readInt64OffPtr_closure:
         const GHC.Storable.readInt64OffPtr_info;
 },
 GHC.Storable.readInt64OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4Cho,
                       label: GHC.Storable.readInt64OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cho: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt64OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.883687272 UTC

[section ""data" . GHC.Storable.readWord64OffPtr1_closure" {
     GHC.Storable.readWord64OffPtr1_closure:
         const GHC.Storable.readWord64OffPtr1_info;
 },
 GHC.Storable.readWord64OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4ChC,
                       label: GHC.Storable.readWord64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ChC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ChL; else goto c4ChM;
       c4ChL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord64OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ChM: // global
           I64[Sp - 16] = block_c4Chz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ChS; else goto c4ChA;
       u4ChS: // global
           call _c4Chz(R1) args: 0, res: 0, upd: 0;
       c4ChA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Chz() //  [R1]
         { info_tbl: [(c4Chz,
                       label: block_c4Chz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Chz: // global
           I64[Sp] = block_c4ChF_info;
           _s4Bu8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bu8::I64;
           if (R1 & 7 != 0) goto u4ChR; else goto c4ChG;
       u4ChR: // global
           call _c4ChF(R1) args: 0, res: 0, upd: 0;
       c4ChG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ChF() //  [R1]
         { info_tbl: [(c4ChF,
                       label: block_c4ChF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ChF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ChQ; else goto c4ChP;
       c4ChQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ChP: // global
           _s4Bud::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4Bud::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.892605849 UTC

[section ""data" . GHC.Storable.readWord64OffPtr_closure" {
     GHC.Storable.readWord64OffPtr_closure:
         const GHC.Storable.readWord64OffPtr_info;
 },
 GHC.Storable.readWord64OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4Cid,
                       label: GHC.Storable.readWord64OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cid: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord64OffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.896661481 UTC

[section ""data" . GHC.Storable.writeWideCharOffPtr1_closure" {
     GHC.Storable.writeWideCharOffPtr1_closure:
         const GHC.Storable.writeWideCharOffPtr1_info;
 },
 GHC.Storable.writeWideCharOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cir,
                       label: GHC.Storable.writeWideCharOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cir: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4CiA; else goto c4CiB;
       c4CiA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWideCharOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CiB: // global
           I64[Sp - 24] = block_c4Cio_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4CiK; else goto c4Cip;
       u4CiK: // global
           call _c4Cio(R1) args: 0, res: 0, upd: 0;
       c4Cip: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cio() //  [R1]
         { info_tbl: [(c4Cio,
                       label: block_c4Cio_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cio: // global
           I64[Sp] = block_c4Ciu_info;
           _s4Buk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Buk::I64;
           if (R1 & 7 != 0) goto u4CiJ; else goto c4Civ;
       u4CiJ: // global
           call _c4Ciu(R1) args: 0, res: 0, upd: 0;
       c4Civ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ciu() //  [R1]
         { info_tbl: [(c4Ciu,
                       label: block_c4Ciu_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ciu: // global
           I64[Sp] = block_c4Ciz_info;
           _s4Bum::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bum::I64;
           if (R1 & 7 != 0) goto u4CiL; else goto c4CiE;
       u4CiL: // global
           call _c4Ciz(R1) args: 0, res: 0, upd: 0;
       c4CiE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ciz() //  [R1]
         { info_tbl: [(c4Ciz,
                       label: block_c4Ciz_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ciz: // global
           I32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.906671747 UTC

[section ""data" . GHC.Storable.writeWideCharOffPtr_closure" {
     GHC.Storable.writeWideCharOffPtr_closure:
         const GHC.Storable.writeWideCharOffPtr_info;
 },
 GHC.Storable.writeWideCharOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cjb,
                       label: GHC.Storable.writeWideCharOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cjb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWideCharOffPtr1_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.911012944 UTC

[section ""data" . GHC.Storable.writeIntOffPtr1_closure" {
     GHC.Storable.writeIntOffPtr1_closure:
         const GHC.Storable.writeIntOffPtr1_info;
 },
 GHC.Storable.writeIntOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cjp,
                       label: GHC.Storable.writeIntOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cjp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Cjy; else goto c4Cjz;
       c4Cjy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeIntOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cjz: // global
           I64[Sp - 24] = block_c4Cjm_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4CjI; else goto c4Cjn;
       u4CjI: // global
           call _c4Cjm(R1) args: 0, res: 0, upd: 0;
       c4Cjn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cjm() //  [R1]
         { info_tbl: [(c4Cjm,
                       label: block_c4Cjm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cjm: // global
           I64[Sp] = block_c4Cjs_info;
           _s4Buv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Buv::I64;
           if (R1 & 7 != 0) goto u4CjH; else goto c4Cjt;
       u4CjH: // global
           call _c4Cjs(R1) args: 0, res: 0, upd: 0;
       c4Cjt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cjs() //  [R1]
         { info_tbl: [(c4Cjs,
                       label: block_c4Cjs_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cjs: // global
           I64[Sp] = block_c4Cjx_info;
           _s4Bux::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bux::I64;
           if (R1 & 7 != 0) goto u4CjJ; else goto c4CjC;
       u4CjJ: // global
           call _c4Cjx(R1) args: 0, res: 0, upd: 0;
       c4CjC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cjx() //  [R1]
         { info_tbl: [(c4Cjx,
                       label: block_c4Cjx_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cjx: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.920379128 UTC

[section ""data" . GHC.Storable.writeIntOffPtr_closure" {
     GHC.Storable.writeIntOffPtr_closure:
         const GHC.Storable.writeIntOffPtr_info;
 },
 GHC.Storable.writeIntOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Ck9,
                       label: GHC.Storable.writeIntOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ck9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeIntOffPtr1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.924506235 UTC

[section ""data" . GHC.Storable.writeWordOffPtr1_closure" {
     GHC.Storable.writeWordOffPtr1_closure:
         const GHC.Storable.writeWordOffPtr1_info;
 },
 GHC.Storable.writeWordOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Ckn,
                       label: GHC.Storable.writeWordOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ckn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Ckw; else goto c4Ckx;
       c4Ckw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWordOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ckx: // global
           I64[Sp - 24] = block_c4Ckk_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4CkG; else goto c4Ckl;
       u4CkG: // global
           call _c4Ckk(R1) args: 0, res: 0, upd: 0;
       c4Ckl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ckk() //  [R1]
         { info_tbl: [(c4Ckk,
                       label: block_c4Ckk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ckk: // global
           I64[Sp] = block_c4Ckq_info;
           _s4BuG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BuG::I64;
           if (R1 & 7 != 0) goto u4CkF; else goto c4Ckr;
       u4CkF: // global
           call _c4Ckq(R1) args: 0, res: 0, upd: 0;
       c4Ckr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ckq() //  [R1]
         { info_tbl: [(c4Ckq,
                       label: block_c4Ckq_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ckq: // global
           I64[Sp] = block_c4Ckv_info;
           _s4BuI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BuI::I64;
           if (R1 & 7 != 0) goto u4CkH; else goto c4CkA;
       u4CkH: // global
           call _c4Ckv(R1) args: 0, res: 0, upd: 0;
       c4CkA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ckv() //  [R1]
         { info_tbl: [(c4Ckv,
                       label: block_c4Ckv_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ckv: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.939218522 UTC

[section ""data" . GHC.Storable.writeWordOffPtr_closure" {
     GHC.Storable.writeWordOffPtr_closure:
         const GHC.Storable.writeWordOffPtr_info;
 },
 GHC.Storable.writeWordOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cl7,
                       label: GHC.Storable.writeWordOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cl7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWordOffPtr1_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.945282646 UTC

[section ""data" . GHC.Storable.writePtrOffPtr1_closure" {
     GHC.Storable.writePtrOffPtr1_closure:
         const GHC.Storable.writePtrOffPtr1_info;
 },
 GHC.Storable.writePtrOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cll,
                       label: GHC.Storable.writePtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cll: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Clu; else goto c4Clv;
       c4Clu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writePtrOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Clv: // global
           I64[Sp - 24] = block_c4Cli_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4ClE; else goto c4Clj;
       u4ClE: // global
           call _c4Cli(R1) args: 0, res: 0, upd: 0;
       c4Clj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cli() //  [R1]
         { info_tbl: [(c4Cli,
                       label: block_c4Cli_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cli: // global
           I64[Sp] = block_c4Clo_info;
           _s4BuR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BuR::I64;
           if (R1 & 7 != 0) goto u4ClD; else goto c4Clp;
       u4ClD: // global
           call _c4Clo(R1) args: 0, res: 0, upd: 0;
       c4Clp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Clo() //  [R1]
         { info_tbl: [(c4Clo,
                       label: block_c4Clo_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Clo: // global
           I64[Sp] = block_c4Clt_info;
           _s4BuT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BuT::I64;
           if (R1 & 7 != 0) goto u4ClF; else goto c4Cly;
       u4ClF: // global
           call _c4Clt(R1) args: 0, res: 0, upd: 0;
       c4Cly: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Clt() //  [R1]
         { info_tbl: [(c4Clt,
                       label: block_c4Clt_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Clt: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.956929893 UTC

[section ""data" . GHC.Storable.writePtrOffPtr_closure" {
     GHC.Storable.writePtrOffPtr_closure:
         const GHC.Storable.writePtrOffPtr_info;
 },
 GHC.Storable.writePtrOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cm5,
                       label: GHC.Storable.writePtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cm5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writePtrOffPtr1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.960957089 UTC

[section ""data" . GHC.Storable.writeFunPtrOffPtr1_closure" {
     GHC.Storable.writeFunPtrOffPtr1_closure:
         const GHC.Storable.writeFunPtrOffPtr1_info;
 },
 GHC.Storable.writeFunPtrOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cmj,
                       label: GHC.Storable.writeFunPtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cmj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Cms; else goto c4Cmt;
       c4Cms: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeFunPtrOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cmt: // global
           I64[Sp - 24] = block_c4Cmg_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4CmC; else goto c4Cmh;
       u4CmC: // global
           call _c4Cmg(R1) args: 0, res: 0, upd: 0;
       c4Cmh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cmg() //  [R1]
         { info_tbl: [(c4Cmg,
                       label: block_c4Cmg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cmg: // global
           I64[Sp] = block_c4Cmm_info;
           _s4Bv2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bv2::I64;
           if (R1 & 7 != 0) goto u4CmB; else goto c4Cmn;
       u4CmB: // global
           call _c4Cmm(R1) args: 0, res: 0, upd: 0;
       c4Cmn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cmm() //  [R1]
         { info_tbl: [(c4Cmm,
                       label: block_c4Cmm_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cmm: // global
           I64[Sp] = block_c4Cmr_info;
           _s4Bv4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bv4::I64;
           if (R1 & 7 != 0) goto u4CmD; else goto c4Cmw;
       u4CmD: // global
           call _c4Cmr(R1) args: 0, res: 0, upd: 0;
       c4Cmw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cmr() //  [R1]
         { info_tbl: [(c4Cmr,
                       label: block_c4Cmr_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cmr: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.971490567 UTC

[section ""data" . GHC.Storable.writeFunPtrOffPtr_closure" {
     GHC.Storable.writeFunPtrOffPtr_closure:
         const GHC.Storable.writeFunPtrOffPtr_info;
 },
 GHC.Storable.writeFunPtrOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cn3,
                       label: GHC.Storable.writeFunPtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cn3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeFunPtrOffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.975489634 UTC

[section ""data" . GHC.Storable.writeFloatOffPtr1_closure" {
     GHC.Storable.writeFloatOffPtr1_closure:
         const GHC.Storable.writeFloatOffPtr1_info;
 },
 GHC.Storable.writeFloatOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cnh,
                       label: GHC.Storable.writeFloatOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cnh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Cnq; else goto c4Cnr;
       c4Cnq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeFloatOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cnr: // global
           I64[Sp - 24] = block_c4Cne_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4CnA; else goto c4Cnf;
       u4CnA: // global
           call _c4Cne(R1) args: 0, res: 0, upd: 0;
       c4Cnf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cne() //  [R1]
         { info_tbl: [(c4Cne,
                       label: block_c4Cne_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cne: // global
           I64[Sp] = block_c4Cnk_info;
           _s4Bvd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bvd::I64;
           if (R1 & 7 != 0) goto u4Cnz; else goto c4Cnl;
       u4Cnz: // global
           call _c4Cnk(R1) args: 0, res: 0, upd: 0;
       c4Cnl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cnk() //  [R1]
         { info_tbl: [(c4Cnk,
                       label: block_c4Cnk_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cnk: // global
           I64[Sp] = block_c4Cnp_info;
           _s4Bvf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bvf::I64;
           if (R1 & 7 != 0) goto u4CnB; else goto c4Cnu;
       u4CnB: // global
           call _c4Cnp(R1) args: 0, res: 0, upd: 0;
       c4Cnu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cnp() //  [R1]
         { info_tbl: [(c4Cnp,
                       label: block_c4Cnp_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cnp: // global
           F32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = F32[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.985358886 UTC

[section ""data" . GHC.Storable.writeFloatOffPtr_closure" {
     GHC.Storable.writeFloatOffPtr_closure:
         const GHC.Storable.writeFloatOffPtr_info;
 },
 GHC.Storable.writeFloatOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Co1,
                       label: GHC.Storable.writeFloatOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Co1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeFloatOffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.989764552 UTC

[section ""data" . GHC.Storable.writeDoubleOffPtr1_closure" {
     GHC.Storable.writeDoubleOffPtr1_closure:
         const GHC.Storable.writeDoubleOffPtr1_info;
 },
 GHC.Storable.writeDoubleOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cof,
                       label: GHC.Storable.writeDoubleOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cof: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Coo; else goto c4Cop;
       c4Coo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeDoubleOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cop: // global
           I64[Sp - 24] = block_c4Coc_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Coy; else goto c4Cod;
       u4Coy: // global
           call _c4Coc(R1) args: 0, res: 0, upd: 0;
       c4Cod: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Coc() //  [R1]
         { info_tbl: [(c4Coc,
                       label: block_c4Coc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Coc: // global
           I64[Sp] = block_c4Coi_info;
           _s4Bvo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bvo::I64;
           if (R1 & 7 != 0) goto u4Cox; else goto c4Coj;
       u4Cox: // global
           call _c4Coi(R1) args: 0, res: 0, upd: 0;
       c4Coj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Coi() //  [R1]
         { info_tbl: [(c4Coi,
                       label: block_c4Coi_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Coi: // global
           I64[Sp] = block_c4Con_info;
           _s4Bvq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bvq::I64;
           if (R1 & 7 != 0) goto u4Coz; else goto c4Cos;
       u4Coz: // global
           call _c4Con(R1) args: 0, res: 0, upd: 0;
       c4Cos: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Con() //  [R1]
         { info_tbl: [(c4Con,
                       label: block_c4Con_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Con: // global
           F64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = F64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:27.999552226 UTC

[section ""data" . GHC.Storable.writeDoubleOffPtr_closure" {
     GHC.Storable.writeDoubleOffPtr_closure:
         const GHC.Storable.writeDoubleOffPtr_info;
 },
 GHC.Storable.writeDoubleOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CoZ,
                       label: GHC.Storable.writeDoubleOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CoZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeDoubleOffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.003317558 UTC

[section ""data" . GHC.Storable.writeStablePtrOffPtr1_closure" {
     GHC.Storable.writeStablePtrOffPtr1_closure:
         const GHC.Storable.writeStablePtrOffPtr1_info;
 },
 GHC.Storable.writeStablePtrOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cpd,
                       label: GHC.Storable.writeStablePtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cpd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Cpm; else goto c4Cpn;
       c4Cpm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeStablePtrOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cpn: // global
           I64[Sp - 24] = block_c4Cpa_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Cpw; else goto c4Cpb;
       u4Cpw: // global
           call _c4Cpa(R1) args: 0, res: 0, upd: 0;
       c4Cpb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cpa() //  [R1]
         { info_tbl: [(c4Cpa,
                       label: block_c4Cpa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cpa: // global
           I64[Sp] = block_c4Cpg_info;
           _s4Bvz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bvz::I64;
           if (R1 & 7 != 0) goto u4Cpv; else goto c4Cph;
       u4Cpv: // global
           call _c4Cpg(R1) args: 0, res: 0, upd: 0;
       c4Cph: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cpg() //  [R1]
         { info_tbl: [(c4Cpg,
                       label: block_c4Cpg_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cpg: // global
           I64[Sp] = block_c4Cpl_info;
           _s4BvB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BvB::I64;
           if (R1 & 7 != 0) goto u4Cpx; else goto c4Cpq;
       u4Cpx: // global
           call _c4Cpl(R1) args: 0, res: 0, upd: 0;
       c4Cpq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cpl() //  [R1]
         { info_tbl: [(c4Cpl,
                       label: block_c4Cpl_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cpl: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.013082333 UTC

[section ""data" . GHC.Storable.writeStablePtrOffPtr_closure" {
     GHC.Storable.writeStablePtrOffPtr_closure:
         const GHC.Storable.writeStablePtrOffPtr_info;
 },
 GHC.Storable.writeStablePtrOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CpX,
                       label: GHC.Storable.writeStablePtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CpX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeStablePtrOffPtr1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.016847715 UTC

[section ""data" . GHC.Storable.writeInt8OffPtr1_closure" {
     GHC.Storable.writeInt8OffPtr1_closure:
         const GHC.Storable.writeInt8OffPtr1_info;
 },
 GHC.Storable.writeInt8OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cqb,
                       label: GHC.Storable.writeInt8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cqb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Cqk; else goto c4Cql;
       c4Cqk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt8OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cql: // global
           I64[Sp - 24] = block_c4Cq8_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Cqu; else goto c4Cq9;
       u4Cqu: // global
           call _c4Cq8(R1) args: 0, res: 0, upd: 0;
       c4Cq9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cq8() //  [R1]
         { info_tbl: [(c4Cq8,
                       label: block_c4Cq8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cq8: // global
           I64[Sp] = block_c4Cqe_info;
           _s4BvK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BvK::I64;
           if (R1 & 7 != 0) goto u4Cqt; else goto c4Cqf;
       u4Cqt: // global
           call _c4Cqe(R1) args: 0, res: 0, upd: 0;
       c4Cqf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cqe() //  [R1]
         { info_tbl: [(c4Cqe,
                       label: block_c4Cqe_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cqe: // global
           I64[Sp] = block_c4Cqj_info;
           _s4BvM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BvM::I64;
           if (R1 & 7 != 0) goto u4Cqv; else goto c4Cqo;
       u4Cqv: // global
           call _c4Cqj(R1) args: 0, res: 0, upd: 0;
       c4Cqo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cqj() //  [R1]
         { info_tbl: [(c4Cqj,
                       label: block_c4Cqj_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cqj: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.027206067 UTC

[section ""data" . GHC.Storable.writeInt8OffPtr_closure" {
     GHC.Storable.writeInt8OffPtr_closure:
         const GHC.Storable.writeInt8OffPtr_info;
 },
 GHC.Storable.writeInt8OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CqV,
                       label: GHC.Storable.writeInt8OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CqV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt8OffPtr1_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.031077899 UTC

[section ""data" . GHC.Storable.writeWord8OffPtr1_closure" {
     GHC.Storable.writeWord8OffPtr1_closure:
         const GHC.Storable.writeWord8OffPtr1_info;
 },
 GHC.Storable.writeWord8OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cr9,
                       label: GHC.Storable.writeWord8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cr9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Cri; else goto c4Crj;
       c4Cri: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord8OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Crj: // global
           I64[Sp - 24] = block_c4Cr6_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Crs; else goto c4Cr7;
       u4Crs: // global
           call _c4Cr6(R1) args: 0, res: 0, upd: 0;
       c4Cr7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cr6() //  [R1]
         { info_tbl: [(c4Cr6,
                       label: block_c4Cr6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cr6: // global
           I64[Sp] = block_c4Crc_info;
           _s4BvV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BvV::I64;
           if (R1 & 7 != 0) goto u4Crr; else goto c4Crd;
       u4Crr: // global
           call _c4Crc(R1) args: 0, res: 0, upd: 0;
       c4Crd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Crc() //  [R1]
         { info_tbl: [(c4Crc,
                       label: block_c4Crc_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Crc: // global
           I64[Sp] = block_c4Crh_info;
           _s4BvX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BvX::I64;
           if (R1 & 7 != 0) goto u4Crt; else goto c4Crm;
       u4Crt: // global
           call _c4Crh(R1) args: 0, res: 0, upd: 0;
       c4Crm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Crh() //  [R1]
         { info_tbl: [(c4Crh,
                       label: block_c4Crh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Crh: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.04097215 UTC

[section ""data" . GHC.Storable.writeWord8OffPtr_closure" {
     GHC.Storable.writeWord8OffPtr_closure:
         const GHC.Storable.writeWord8OffPtr_info;
 },
 GHC.Storable.writeWord8OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CrT,
                       label: GHC.Storable.writeWord8OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CrT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord8OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.045408845 UTC

[section ""data" . GHC.Storable.writeInt16OffPtr1_closure" {
     GHC.Storable.writeInt16OffPtr1_closure:
         const GHC.Storable.writeInt16OffPtr1_info;
 },
 GHC.Storable.writeInt16OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cs7,
                       label: GHC.Storable.writeInt16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cs7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Csg; else goto c4Csh;
       c4Csg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt16OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Csh: // global
           I64[Sp - 24] = block_c4Cs4_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Csq; else goto c4Cs5;
       u4Csq: // global
           call _c4Cs4(R1) args: 0, res: 0, upd: 0;
       c4Cs5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cs4() //  [R1]
         { info_tbl: [(c4Cs4,
                       label: block_c4Cs4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cs4: // global
           I64[Sp] = block_c4Csa_info;
           _s4Bw6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bw6::I64;
           if (R1 & 7 != 0) goto u4Csp; else goto c4Csb;
       u4Csp: // global
           call _c4Csa(R1) args: 0, res: 0, upd: 0;
       c4Csb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Csa() //  [R1]
         { info_tbl: [(c4Csa,
                       label: block_c4Csa_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Csa: // global
           I64[Sp] = block_c4Csf_info;
           _s4Bw8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bw8::I64;
           if (R1 & 7 != 0) goto u4Csr; else goto c4Csk;
       u4Csr: // global
           call _c4Csf(R1) args: 0, res: 0, upd: 0;
       c4Csk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Csf() //  [R1]
         { info_tbl: [(c4Csf,
                       label: block_c4Csf_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Csf: // global
           I16[I64[Sp + 8] + (I64[Sp + 16] << 1)] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.05453343 UTC

[section ""data" . GHC.Storable.writeInt16OffPtr_closure" {
     GHC.Storable.writeInt16OffPtr_closure:
         const GHC.Storable.writeInt16OffPtr_info;
 },
 GHC.Storable.writeInt16OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CsR,
                       label: GHC.Storable.writeInt16OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CsR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt16OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.058576781 UTC

[section ""data" . GHC.Storable.writeWord16OffPtr1_closure" {
     GHC.Storable.writeWord16OffPtr1_closure:
         const GHC.Storable.writeWord16OffPtr1_info;
 },
 GHC.Storable.writeWord16OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Ct5,
                       label: GHC.Storable.writeWord16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ct5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Cte; else goto c4Ctf;
       c4Cte: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord16OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ctf: // global
           I64[Sp - 24] = block_c4Ct2_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Cto; else goto c4Ct3;
       u4Cto: // global
           call _c4Ct2(R1) args: 0, res: 0, upd: 0;
       c4Ct3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ct2() //  [R1]
         { info_tbl: [(c4Ct2,
                       label: block_c4Ct2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ct2: // global
           I64[Sp] = block_c4Ct8_info;
           _s4Bwh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bwh::I64;
           if (R1 & 7 != 0) goto u4Ctn; else goto c4Ct9;
       u4Ctn: // global
           call _c4Ct8(R1) args: 0, res: 0, upd: 0;
       c4Ct9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ct8() //  [R1]
         { info_tbl: [(c4Ct8,
                       label: block_c4Ct8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ct8: // global
           I64[Sp] = block_c4Ctd_info;
           _s4Bwj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bwj::I64;
           if (R1 & 7 != 0) goto u4Ctp; else goto c4Cti;
       u4Ctp: // global
           call _c4Ctd(R1) args: 0, res: 0, upd: 0;
       c4Cti: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ctd() //  [R1]
         { info_tbl: [(c4Ctd,
                       label: block_c4Ctd_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ctd: // global
           I16[I64[Sp + 8] + (I64[Sp + 16] << 1)] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.068758472 UTC

[section ""data" . GHC.Storable.writeWord16OffPtr_closure" {
     GHC.Storable.writeWord16OffPtr_closure:
         const GHC.Storable.writeWord16OffPtr_info;
 },
 GHC.Storable.writeWord16OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CtP,
                       label: GHC.Storable.writeWord16OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CtP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord16OffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.072719368 UTC

[section ""data" . GHC.Storable.writeInt32OffPtr1_closure" {
     GHC.Storable.writeInt32OffPtr1_closure:
         const GHC.Storable.writeInt32OffPtr1_info;
 },
 GHC.Storable.writeInt32OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cu3,
                       label: GHC.Storable.writeInt32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cu3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Cuc; else goto c4Cud;
       c4Cuc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt32OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cud: // global
           I64[Sp - 24] = block_c4Cu0_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Cum; else goto c4Cu1;
       u4Cum: // global
           call _c4Cu0(R1) args: 0, res: 0, upd: 0;
       c4Cu1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cu0() //  [R1]
         { info_tbl: [(c4Cu0,
                       label: block_c4Cu0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cu0: // global
           I64[Sp] = block_c4Cu6_info;
           _s4Bws::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Bws::I64;
           if (R1 & 7 != 0) goto u4Cul; else goto c4Cu7;
       u4Cul: // global
           call _c4Cu6(R1) args: 0, res: 0, upd: 0;
       c4Cu7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cu6() //  [R1]
         { info_tbl: [(c4Cu6,
                       label: block_c4Cu6_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cu6: // global
           I64[Sp] = block_c4Cub_info;
           _s4Bwu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bwu::I64;
           if (R1 & 7 != 0) goto u4Cun; else goto c4Cug;
       u4Cun: // global
           call _c4Cub(R1) args: 0, res: 0, upd: 0;
       c4Cug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cub() //  [R1]
         { info_tbl: [(c4Cub,
                       label: block_c4Cub_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cub: // global
           I32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.085232264 UTC

[section ""data" . GHC.Storable.writeInt32OffPtr_closure" {
     GHC.Storable.writeInt32OffPtr_closure:
         const GHC.Storable.writeInt32OffPtr_info;
 },
 GHC.Storable.writeInt32OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CuN,
                       label: GHC.Storable.writeInt32OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CuN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt32OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.089088255 UTC

[section ""data" . GHC.Storable.writeWord32OffPtr1_closure" {
     GHC.Storable.writeWord32OffPtr1_closure:
         const GHC.Storable.writeWord32OffPtr1_info;
 },
 GHC.Storable.writeWord32OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Cv1,
                       label: GHC.Storable.writeWord32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cv1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Cva; else goto c4Cvb;
       c4Cva: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord32OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cvb: // global
           I64[Sp - 24] = block_c4CuY_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Cvk; else goto c4CuZ;
       u4Cvk: // global
           call _c4CuY(R1) args: 0, res: 0, upd: 0;
       c4CuZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CuY() //  [R1]
         { info_tbl: [(c4CuY,
                       label: block_c4CuY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CuY: // global
           I64[Sp] = block_c4Cv4_info;
           _s4BwD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BwD::I64;
           if (R1 & 7 != 0) goto u4Cvj; else goto c4Cv5;
       u4Cvj: // global
           call _c4Cv4(R1) args: 0, res: 0, upd: 0;
       c4Cv5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cv4() //  [R1]
         { info_tbl: [(c4Cv4,
                       label: block_c4Cv4_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cv4: // global
           I64[Sp] = block_c4Cv9_info;
           _s4BwF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BwF::I64;
           if (R1 & 7 != 0) goto u4Cvl; else goto c4Cve;
       u4Cvl: // global
           call _c4Cv9(R1) args: 0, res: 0, upd: 0;
       c4Cve: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cv9() //  [R1]
         { info_tbl: [(c4Cv9,
                       label: block_c4Cv9_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cv9: // global
           I32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.099336958 UTC

[section ""data" . GHC.Storable.writeWord32OffPtr_closure" {
     GHC.Storable.writeWord32OffPtr_closure:
         const GHC.Storable.writeWord32OffPtr_info;
 },
 GHC.Storable.writeWord32OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CvL,
                       label: GHC.Storable.writeWord32OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CvL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord32OffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.103316663 UTC

[section ""data" . GHC.Storable.writeInt64OffPtr1_closure" {
     GHC.Storable.writeInt64OffPtr1_closure:
         const GHC.Storable.writeInt64OffPtr1_info;
 },
 GHC.Storable.writeInt64OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CvZ,
                       label: GHC.Storable.writeInt64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CvZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Cw8; else goto c4Cw9;
       c4Cw8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt64OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cw9: // global
           I64[Sp - 24] = block_c4CvW_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Cwi; else goto c4CvX;
       u4Cwi: // global
           call _c4CvW(R1) args: 0, res: 0, upd: 0;
       c4CvX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CvW() //  [R1]
         { info_tbl: [(c4CvW,
                       label: block_c4CvW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CvW: // global
           I64[Sp] = block_c4Cw2_info;
           _s4BwO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BwO::I64;
           if (R1 & 7 != 0) goto u4Cwh; else goto c4Cw3;
       u4Cwh: // global
           call _c4Cw2(R1) args: 0, res: 0, upd: 0;
       c4Cw3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cw2() //  [R1]
         { info_tbl: [(c4Cw2,
                       label: block_c4Cw2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cw2: // global
           I64[Sp] = block_c4Cw7_info;
           _s4BwQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4BwQ::I64;
           if (R1 & 7 != 0) goto u4Cwj; else goto c4Cwc;
       u4Cwj: // global
           call _c4Cw7(R1) args: 0, res: 0, upd: 0;
       c4Cwc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cw7() //  [R1]
         { info_tbl: [(c4Cw7,
                       label: block_c4Cw7_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cw7: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.114359423 UTC

[section ""data" . GHC.Storable.writeInt64OffPtr_closure" {
     GHC.Storable.writeInt64OffPtr_closure:
         const GHC.Storable.writeInt64OffPtr_info;
 },
 GHC.Storable.writeInt64OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CwJ,
                       label: GHC.Storable.writeInt64OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CwJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt64OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.118775764 UTC

[section ""data" . GHC.Storable.writeWord64OffPtr1_closure" {
     GHC.Storable.writeWord64OffPtr1_closure:
         const GHC.Storable.writeWord64OffPtr1_info;
 },
 GHC.Storable.writeWord64OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CwX,
                       label: GHC.Storable.writeWord64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CwX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Cx6; else goto c4Cx7;
       c4Cx6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord64OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Cx7: // global
           I64[Sp - 24] = block_c4CwU_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Cxg; else goto c4CwV;
       u4Cxg: // global
           call _c4CwU(R1) args: 0, res: 0, upd: 0;
       c4CwV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CwU() //  [R1]
         { info_tbl: [(c4CwU,
                       label: block_c4CwU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CwU: // global
           I64[Sp] = block_c4Cx0_info;
           _s4BwZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4BwZ::I64;
           if (R1 & 7 != 0) goto u4Cxf; else goto c4Cx1;
       u4Cxf: // global
           call _c4Cx0(R1) args: 0, res: 0, upd: 0;
       c4Cx1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cx0() //  [R1]
         { info_tbl: [(c4Cx0,
                       label: block_c4Cx0_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cx0: // global
           I64[Sp] = block_c4Cx5_info;
           _s4Bx1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Bx1::I64;
           if (R1 & 7 != 0) goto u4Cxh; else goto c4Cxa;
       u4Cxh: // global
           call _c4Cx5(R1) args: 0, res: 0, upd: 0;
       c4Cxa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Cx5() //  [R1]
         { info_tbl: [(c4Cx5,
                       label: block_c4Cx5_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Cx5: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.128052496 UTC

[section ""data" . GHC.Storable.writeWord64OffPtr_closure" {
     GHC.Storable.writeWord64OffPtr_closure:
         const GHC.Storable.writeWord64OffPtr_info;
 },
 GHC.Storable.writeWord64OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CxH,
                       label: GHC.Storable.writeWord64OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CxH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord64OffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.131624312 UTC

[section ""cstring" . GHC.Storable.$trModule4_bytes" {
     GHC.Storable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.134915266 UTC

[section ""data" . GHC.Storable.$trModule3_closure" {
     GHC.Storable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Storable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.136658209 UTC

[section ""cstring" . GHC.Storable.$trModule2_bytes" {
     GHC.Storable.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,111,114,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.138461988 UTC

[section ""data" . GHC.Storable.$trModule1_closure" {
     GHC.Storable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Storable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.140179419 UTC

[section ""data" . GHC.Storable.$trModule_closure" {
     GHC.Storable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Storable.$trModule3_closure+1;
         const GHC.Storable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:28.142155515 UTC

[section ""relreadonly" . S4BO7_srt" { S4BO7_srt:
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.442709352 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:29.444312442 UTC

[section ""data" . GHC.Storable.readWideCharOffPtr1_closure" {
     GHC.Storable.readWideCharOffPtr1_closure:
         const GHC.Storable.readWideCharOffPtr1_info;
 },
 GHC.Storable.readWideCharOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CDH,
                       label: GHC.Storable.readWideCharOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CDH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CDQ; else goto c4CDR;
       c4CDQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWideCharOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CDR: // global
           I64[Sp - 16] = block_c4CDE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CDX; else goto c4CDF;
       u4CDX: // global
           call _c4CDE(R1) args: 0, res: 0, upd: 0;
       c4CDF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CDE() //  [R1]
         { info_tbl: [(c4CDE,
                       label: block_c4CDE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CDE: // global
           I64[Sp] = block_c4CDK_info;
           _s4CxY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CxY::I64;
           if (R1 & 7 != 0) goto u4CDW; else goto c4CDL;
       u4CDW: // global
           call _c4CDK(R1) args: 0, res: 0, upd: 0;
       c4CDL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CDK() //  [R1]
         { info_tbl: [(c4CDK,
                       label: block_c4CDK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CDK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CDV; else goto c4CDU;
       c4CDV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CDU: // global
           _s4Cy3::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s4Cy3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.452051063 UTC

[section ""data" . GHC.Storable.readWideCharOffPtr_closure" {
     GHC.Storable.readWideCharOffPtr_closure:
         const GHC.Storable.readWideCharOffPtr_info;
 },
 GHC.Storable.readWideCharOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CEl,
                       label: GHC.Storable.readWideCharOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CEl: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWideCharOffPtr1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.455862736 UTC

[section ""data" . GHC.Storable.readIntOffPtr1_closure" {
     GHC.Storable.readIntOffPtr1_closure:
         const GHC.Storable.readIntOffPtr1_info;
 },
 GHC.Storable.readIntOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CEz,
                       label: GHC.Storable.readIntOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CEz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CEI; else goto c4CEJ;
       c4CEI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readIntOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CEJ: // global
           I64[Sp - 16] = block_c4CEw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CEP; else goto c4CEx;
       u4CEP: // global
           call _c4CEw(R1) args: 0, res: 0, upd: 0;
       c4CEx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CEw() //  [R1]
         { info_tbl: [(c4CEw,
                       label: block_c4CEw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CEw: // global
           I64[Sp] = block_c4CEC_info;
           _s4Cy9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Cy9::I64;
           if (R1 & 7 != 0) goto u4CEO; else goto c4CED;
       u4CEO: // global
           call _c4CEC(R1) args: 0, res: 0, upd: 0;
       c4CED: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CEC() //  [R1]
         { info_tbl: [(c4CEC,
                       label: block_c4CEC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CEC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CEN; else goto c4CEM;
       c4CEN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CEM: // global
           _s4Cye::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Cye::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.46354302 UTC

[section ""data" . GHC.Storable.readIntOffPtr_closure" {
     GHC.Storable.readIntOffPtr_closure:
         const GHC.Storable.readIntOffPtr_info;
 },
 GHC.Storable.readIntOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CFd,
                       label: GHC.Storable.readIntOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CFd: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readIntOffPtr1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.46745125 UTC

[section ""data" . GHC.Storable.readWordOffPtr1_closure" {
     GHC.Storable.readWordOffPtr1_closure:
         const GHC.Storable.readWordOffPtr1_info;
 },
 GHC.Storable.readWordOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CFr,
                       label: GHC.Storable.readWordOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CFr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CFA; else goto c4CFB;
       c4CFA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWordOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CFB: // global
           I64[Sp - 16] = block_c4CFo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CFH; else goto c4CFp;
       u4CFH: // global
           call _c4CFo(R1) args: 0, res: 0, upd: 0;
       c4CFp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CFo() //  [R1]
         { info_tbl: [(c4CFo,
                       label: block_c4CFo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CFo: // global
           I64[Sp] = block_c4CFu_info;
           _s4Cyk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Cyk::I64;
           if (R1 & 7 != 0) goto u4CFG; else goto c4CFv;
       u4CFG: // global
           call _c4CFu(R1) args: 0, res: 0, upd: 0;
       c4CFv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CFu() //  [R1]
         { info_tbl: [(c4CFu,
                       label: block_c4CFu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CFu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CFF; else goto c4CFE;
       c4CFF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CFE: // global
           _s4Cyp::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s4Cyp::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.475598183 UTC

[section ""data" . GHC.Storable.readWordOffPtr_closure" {
     GHC.Storable.readWordOffPtr_closure:
         const GHC.Storable.readWordOffPtr_info;
 },
 GHC.Storable.readWordOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CG5,
                       label: GHC.Storable.readWordOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CG5: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWordOffPtr1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.479260503 UTC

[section ""data" . GHC.Storable.readPtrOffPtr1_closure" {
     GHC.Storable.readPtrOffPtr1_closure:
         const GHC.Storable.readPtrOffPtr1_info;
 },
 GHC.Storable.readPtrOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CGj,
                       label: GHC.Storable.readPtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CGj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CGs; else goto c4CGt;
       c4CGs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readPtrOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CGt: // global
           I64[Sp - 16] = block_c4CGg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CGz; else goto c4CGh;
       u4CGz: // global
           call _c4CGg(R1) args: 0, res: 0, upd: 0;
       c4CGh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CGg() //  [R1]
         { info_tbl: [(c4CGg,
                       label: block_c4CGg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CGg: // global
           I64[Sp] = block_c4CGm_info;
           _s4Cyv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Cyv::I64;
           if (R1 & 7 != 0) goto u4CGy; else goto c4CGn;
       u4CGy: // global
           call _c4CGm(R1) args: 0, res: 0, upd: 0;
       c4CGn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CGm() //  [R1]
         { info_tbl: [(c4CGm,
                       label: block_c4CGm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CGm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CGx; else goto c4CGw;
       c4CGx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CGw: // global
           _s4CyA::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4CyA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.486757045 UTC

[section ""data" . GHC.Storable.readPtrOffPtr_closure" {
     GHC.Storable.readPtrOffPtr_closure:
         const GHC.Storable.readPtrOffPtr_info;
 },
 GHC.Storable.readPtrOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CGX,
                       label: GHC.Storable.readPtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CGX: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readPtrOffPtr1_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.490309395 UTC

[section ""data" . GHC.Storable.readFunPtrOffPtr1_closure" {
     GHC.Storable.readFunPtrOffPtr1_closure:
         const GHC.Storable.readFunPtrOffPtr1_info;
 },
 GHC.Storable.readFunPtrOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CHb,
                       label: GHC.Storable.readFunPtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CHb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CHk; else goto c4CHl;
       c4CHk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readFunPtrOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CHl: // global
           I64[Sp - 16] = block_c4CH8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CHr; else goto c4CH9;
       u4CHr: // global
           call _c4CH8(R1) args: 0, res: 0, upd: 0;
       c4CH9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CH8() //  [R1]
         { info_tbl: [(c4CH8,
                       label: block_c4CH8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CH8: // global
           I64[Sp] = block_c4CHe_info;
           _s4CyG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CyG::I64;
           if (R1 & 7 != 0) goto u4CHq; else goto c4CHf;
       u4CHq: // global
           call _c4CHe(R1) args: 0, res: 0, upd: 0;
       c4CHf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CHe() //  [R1]
         { info_tbl: [(c4CHe,
                       label: block_c4CHe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CHe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CHp; else goto c4CHo;
       c4CHp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CHo: // global
           _s4CyL::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s4CyL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.497703813 UTC

[section ""data" . GHC.Storable.readFunPtrOffPtr_closure" {
     GHC.Storable.readFunPtrOffPtr_closure:
         const GHC.Storable.readFunPtrOffPtr_info;
 },
 GHC.Storable.readFunPtrOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CHP,
                       label: GHC.Storable.readFunPtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CHP: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readFunPtrOffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.501322101 UTC

[section ""data" . GHC.Storable.readFloatOffPtr1_closure" {
     GHC.Storable.readFloatOffPtr1_closure:
         const GHC.Storable.readFloatOffPtr1_info;
 },
 GHC.Storable.readFloatOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CI3,
                       label: GHC.Storable.readFloatOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CI3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CIc; else goto c4CId;
       c4CIc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readFloatOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CId: // global
           I64[Sp - 16] = block_c4CI0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CIj; else goto c4CI1;
       u4CIj: // global
           call _c4CI0(R1) args: 0, res: 0, upd: 0;
       c4CI1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CI0() //  [R1]
         { info_tbl: [(c4CI0,
                       label: block_c4CI0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CI0: // global
           I64[Sp] = block_c4CI6_info;
           _s4CyR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CyR::I64;
           if (R1 & 7 != 0) goto u4CIi; else goto c4CI7;
       u4CIi: // global
           call _c4CI6(R1) args: 0, res: 0, upd: 0;
       c4CI7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CI6() //  [R1]
         { info_tbl: [(c4CI6,
                       label: block_c4CI6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CI6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CIh; else goto c4CIg;
       c4CIh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CIg: // global
           _s4CyW::F32 = F32[I64[Sp + 8] + (I64[R1 + 7] << 2)];
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _s4CyW::F32;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.509422082 UTC

[section ""data" . GHC.Storable.readFloatOffPtr_closure" {
     GHC.Storable.readFloatOffPtr_closure:
         const GHC.Storable.readFloatOffPtr_info;
 },
 GHC.Storable.readFloatOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CIH,
                       label: GHC.Storable.readFloatOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CIH: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readFloatOffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.513009359 UTC

[section ""data" . GHC.Storable.readDoubleOffPtr1_closure" {
     GHC.Storable.readDoubleOffPtr1_closure:
         const GHC.Storable.readDoubleOffPtr1_info;
 },
 GHC.Storable.readDoubleOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CIV,
                       label: GHC.Storable.readDoubleOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CIV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CJ4; else goto c4CJ5;
       c4CJ4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readDoubleOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CJ5: // global
           I64[Sp - 16] = block_c4CIS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CJb; else goto c4CIT;
       u4CJb: // global
           call _c4CIS(R1) args: 0, res: 0, upd: 0;
       c4CIT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CIS() //  [R1]
         { info_tbl: [(c4CIS,
                       label: block_c4CIS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CIS: // global
           I64[Sp] = block_c4CIY_info;
           _s4Cz2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Cz2::I64;
           if (R1 & 7 != 0) goto u4CJa; else goto c4CIZ;
       u4CJa: // global
           call _c4CIY(R1) args: 0, res: 0, upd: 0;
       c4CIZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CIY() //  [R1]
         { info_tbl: [(c4CIY,
                       label: block_c4CIY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CIY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CJ9; else goto c4CJ8;
       c4CJ9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CJ8: // global
           _s4Cz7::F64 = F64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _s4Cz7::F64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.521770722 UTC

[section ""data" . GHC.Storable.readDoubleOffPtr_closure" {
     GHC.Storable.readDoubleOffPtr_closure:
         const GHC.Storable.readDoubleOffPtr_info;
 },
 GHC.Storable.readDoubleOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CJz,
                       label: GHC.Storable.readDoubleOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CJz: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readDoubleOffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.526636936 UTC

[section ""data" . GHC.Storable.readStablePtrOffPtr1_closure" {
     GHC.Storable.readStablePtrOffPtr1_closure:
         const GHC.Storable.readStablePtrOffPtr1_info;
 },
 GHC.Storable.readStablePtrOffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CJN,
                       label: GHC.Storable.readStablePtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CJN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CJW; else goto c4CJX;
       c4CJW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readStablePtrOffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CJX: // global
           I64[Sp - 16] = block_c4CJK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CK3; else goto c4CJL;
       u4CK3: // global
           call _c4CJK(R1) args: 0, res: 0, upd: 0;
       c4CJL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CJK() //  [R1]
         { info_tbl: [(c4CJK,
                       label: block_c4CJK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CJK: // global
           I64[Sp] = block_c4CJQ_info;
           _s4Czd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Czd::I64;
           if (R1 & 7 != 0) goto u4CK2; else goto c4CJR;
       u4CK2: // global
           call _c4CJQ(R1) args: 0, res: 0, upd: 0;
       c4CJR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CJQ() //  [R1]
         { info_tbl: [(c4CJQ,
                       label: block_c4CJQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CJQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CK1; else goto c4CK0;
       c4CK1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CK0: // global
           _s4Czi::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = _s4Czi::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.537951456 UTC

[section ""data" . GHC.Storable.readStablePtrOffPtr_closure" {
     GHC.Storable.readStablePtrOffPtr_closure:
         const GHC.Storable.readStablePtrOffPtr_info;
 },
 GHC.Storable.readStablePtrOffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CKr,
                       label: GHC.Storable.readStablePtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CKr: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readStablePtrOffPtr1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.543837137 UTC

[section ""data" . GHC.Storable.readInt8OffPtr1_closure" {
     GHC.Storable.readInt8OffPtr1_closure:
         const GHC.Storable.readInt8OffPtr1_info;
 },
 GHC.Storable.readInt8OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CKF,
                       label: GHC.Storable.readInt8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CKF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CKO; else goto c4CKP;
       c4CKO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt8OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CKP: // global
           I64[Sp - 16] = block_c4CKC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CKV; else goto c4CKD;
       u4CKV: // global
           call _c4CKC(R1) args: 0, res: 0, upd: 0;
       c4CKD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CKC() //  [R1]
         { info_tbl: [(c4CKC,
                       label: block_c4CKC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CKC: // global
           I64[Sp] = block_c4CKI_info;
           _s4Czo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Czo::I64;
           if (R1 & 7 != 0) goto u4CKU; else goto c4CKJ;
       u4CKU: // global
           call _c4CKI(R1) args: 0, res: 0, upd: 0;
       c4CKJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CKI() //  [R1]
         { info_tbl: [(c4CKI,
                       label: block_c4CKI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CKI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CKT; else goto c4CKS;
       c4CKT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CKS: // global
           _s4Czt::I64 = %MO_SS_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4Czt::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.555627868 UTC

[section ""data" . GHC.Storable.readInt8OffPtr_closure" {
     GHC.Storable.readInt8OffPtr_closure:
         const GHC.Storable.readInt8OffPtr_info;
 },
 GHC.Storable.readInt8OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CLj,
                       label: GHC.Storable.readInt8OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CLj: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt8OffPtr1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.560774895 UTC

[section ""data" . GHC.Storable.readWord8OffPtr1_closure" {
     GHC.Storable.readWord8OffPtr1_closure:
         const GHC.Storable.readWord8OffPtr1_info;
 },
 GHC.Storable.readWord8OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CLx,
                       label: GHC.Storable.readWord8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CLx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CLG; else goto c4CLH;
       c4CLG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord8OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CLH: // global
           I64[Sp - 16] = block_c4CLu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CLN; else goto c4CLv;
       u4CLN: // global
           call _c4CLu(R1) args: 0, res: 0, upd: 0;
       c4CLv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CLu() //  [R1]
         { info_tbl: [(c4CLu,
                       label: block_c4CLu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CLu: // global
           I64[Sp] = block_c4CLA_info;
           _s4Czz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Czz::I64;
           if (R1 & 7 != 0) goto u4CLM; else goto c4CLB;
       u4CLM: // global
           call _c4CLA(R1) args: 0, res: 0, upd: 0;
       c4CLB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CLA() //  [R1]
         { info_tbl: [(c4CLA,
                       label: block_c4CLA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CLA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CLL; else goto c4CLK;
       c4CLL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CLK: // global
           _s4CzE::I64 = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s4CzE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.570978135 UTC

[section ""data" . GHC.Storable.readWord8OffPtr_closure" {
     GHC.Storable.readWord8OffPtr_closure:
         const GHC.Storable.readWord8OffPtr_info;
 },
 GHC.Storable.readWord8OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CMb,
                       label: GHC.Storable.readWord8OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CMb: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord8OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.575751847 UTC

[section ""data" . GHC.Storable.readInt16OffPtr1_closure" {
     GHC.Storable.readInt16OffPtr1_closure:
         const GHC.Storable.readInt16OffPtr1_info;
 },
 GHC.Storable.readInt16OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CMp,
                       label: GHC.Storable.readInt16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CMp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CMy; else goto c4CMz;
       c4CMy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt16OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CMz: // global
           I64[Sp - 16] = block_c4CMm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CMF; else goto c4CMn;
       u4CMF: // global
           call _c4CMm(R1) args: 0, res: 0, upd: 0;
       c4CMn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CMm() //  [R1]
         { info_tbl: [(c4CMm,
                       label: block_c4CMm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CMm: // global
           I64[Sp] = block_c4CMs_info;
           _s4CzK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CzK::I64;
           if (R1 & 7 != 0) goto u4CME; else goto c4CMt;
       u4CME: // global
           call _c4CMs(R1) args: 0, res: 0, upd: 0;
       c4CMt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CMs() //  [R1]
         { info_tbl: [(c4CMs,
                       label: block_c4CMs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CMs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CMD; else goto c4CMC;
       c4CMD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CMC: // global
           _s4CzP::I64 = %MO_SS_Conv_W16_W64(I16[I64[Sp + 8] + (I64[R1 + 7] << 1)]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4CzP::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.585559601 UTC

[section ""data" . GHC.Storable.readInt16OffPtr_closure" {
     GHC.Storable.readInt16OffPtr_closure:
         const GHC.Storable.readInt16OffPtr_info;
 },
 GHC.Storable.readInt16OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CN3,
                       label: GHC.Storable.readInt16OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CN3: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt16OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.589433729 UTC

[section ""data" . GHC.Storable.readWord16OffPtr1_closure" {
     GHC.Storable.readWord16OffPtr1_closure:
         const GHC.Storable.readWord16OffPtr1_info;
 },
 GHC.Storable.readWord16OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CNh,
                       label: GHC.Storable.readWord16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CNh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CNq; else goto c4CNr;
       c4CNq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord16OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CNr: // global
           I64[Sp - 16] = block_c4CNe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CNx; else goto c4CNf;
       u4CNx: // global
           call _c4CNe(R1) args: 0, res: 0, upd: 0;
       c4CNf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CNe() //  [R1]
         { info_tbl: [(c4CNe,
                       label: block_c4CNe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CNe: // global
           I64[Sp] = block_c4CNk_info;
           _s4CzV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CzV::I64;
           if (R1 & 7 != 0) goto u4CNw; else goto c4CNl;
       u4CNw: // global
           call _c4CNk(R1) args: 0, res: 0, upd: 0;
       c4CNl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CNk() //  [R1]
         { info_tbl: [(c4CNk,
                       label: block_c4CNk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CNk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CNv; else goto c4CNu;
       c4CNv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CNu: // global
           _s4CA0::I64 = %MO_UU_Conv_W16_W64(I16[I64[Sp + 8] + (I64[R1 + 7] << 1)]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s4CA0::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.59769451 UTC

[section ""data" . GHC.Storable.readWord16OffPtr_closure" {
     GHC.Storable.readWord16OffPtr_closure:
         const GHC.Storable.readWord16OffPtr_info;
 },
 GHC.Storable.readWord16OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CNV,
                       label: GHC.Storable.readWord16OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CNV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord16OffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.601903645 UTC

[section ""data" . GHC.Storable.readInt32OffPtr1_closure" {
     GHC.Storable.readInt32OffPtr1_closure:
         const GHC.Storable.readInt32OffPtr1_info;
 },
 GHC.Storable.readInt32OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CO9,
                       label: GHC.Storable.readInt32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CO9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4COi; else goto c4COj;
       c4COi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt32OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4COj: // global
           I64[Sp - 16] = block_c4CO6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4COp; else goto c4CO7;
       u4COp: // global
           call _c4CO6(R1) args: 0, res: 0, upd: 0;
       c4CO7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CO6() //  [R1]
         { info_tbl: [(c4CO6,
                       label: block_c4CO6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CO6: // global
           I64[Sp] = block_c4COc_info;
           _s4CA6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CA6::I64;
           if (R1 & 7 != 0) goto u4COo; else goto c4COd;
       u4COo: // global
           call _c4COc(R1) args: 0, res: 0, upd: 0;
       c4COd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4COc() //  [R1]
         { info_tbl: [(c4COc,
                       label: block_c4COc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4COc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4COn; else goto c4COm;
       c4COn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4COm: // global
           _s4CAb::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4CAb::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.60950748 UTC

[section ""data" . GHC.Storable.readInt32OffPtr_closure" {
     GHC.Storable.readInt32OffPtr_closure:
         const GHC.Storable.readInt32OffPtr_info;
 },
 GHC.Storable.readInt32OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CON,
                       label: GHC.Storable.readInt32OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CON: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt32OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.613122177 UTC

[section ""data" . GHC.Storable.readWord32OffPtr1_closure" {
     GHC.Storable.readWord32OffPtr1_closure:
         const GHC.Storable.readWord32OffPtr1_info;
 },
 GHC.Storable.readWord32OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CP1,
                       label: GHC.Storable.readWord32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CP1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CPa; else goto c4CPb;
       c4CPa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord32OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CPb: // global
           I64[Sp - 16] = block_c4COY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CPh; else goto c4COZ;
       u4CPh: // global
           call _c4COY(R1) args: 0, res: 0, upd: 0;
       c4COZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4COY() //  [R1]
         { info_tbl: [(c4COY,
                       label: block_c4COY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4COY: // global
           I64[Sp] = block_c4CP4_info;
           _s4CAh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CAh::I64;
           if (R1 & 7 != 0) goto u4CPg; else goto c4CP5;
       u4CPg: // global
           call _c4CP4(R1) args: 0, res: 0, upd: 0;
       c4CP5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CP4() //  [R1]
         { info_tbl: [(c4CP4,
                       label: block_c4CP4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CP4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CPf; else goto c4CPe;
       c4CPf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CPe: // global
           _s4CAm::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s4CAm::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.620984654 UTC

[section ""data" . GHC.Storable.readWord32OffPtr_closure" {
     GHC.Storable.readWord32OffPtr_closure:
         const GHC.Storable.readWord32OffPtr_info;
 },
 GHC.Storable.readWord32OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CPF,
                       label: GHC.Storable.readWord32OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CPF: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord32OffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.624637265 UTC

[section ""data" . GHC.Storable.readInt64OffPtr1_closure" {
     GHC.Storable.readInt64OffPtr1_closure:
         const GHC.Storable.readInt64OffPtr1_info;
 },
 GHC.Storable.readInt64OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CPT,
                       label: GHC.Storable.readInt64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CPT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CQ2; else goto c4CQ3;
       c4CQ2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readInt64OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CQ3: // global
           I64[Sp - 16] = block_c4CPQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CQ9; else goto c4CPR;
       u4CQ9: // global
           call _c4CPQ(R1) args: 0, res: 0, upd: 0;
       c4CPR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CPQ() //  [R1]
         { info_tbl: [(c4CPQ,
                       label: block_c4CPQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CPQ: // global
           I64[Sp] = block_c4CPW_info;
           _s4CAs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CAs::I64;
           if (R1 & 7 != 0) goto u4CQ8; else goto c4CPX;
       u4CQ8: // global
           call _c4CPW(R1) args: 0, res: 0, upd: 0;
       c4CPX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CPW() //  [R1]
         { info_tbl: [(c4CPW,
                       label: block_c4CPW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CPW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CQ7; else goto c4CQ6;
       c4CQ7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CQ6: // global
           _s4CAx::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4CAx::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.633155967 UTC

[section ""data" . GHC.Storable.readInt64OffPtr_closure" {
     GHC.Storable.readInt64OffPtr_closure:
         const GHC.Storable.readInt64OffPtr_info;
 },
 GHC.Storable.readInt64OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CQx,
                       label: GHC.Storable.readInt64OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CQx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readInt64OffPtr1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.636842197 UTC

[section ""data" . GHC.Storable.readWord64OffPtr1_closure" {
     GHC.Storable.readWord64OffPtr1_closure:
         const GHC.Storable.readWord64OffPtr1_info;
 },
 GHC.Storable.readWord64OffPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4CQL,
                       label: GHC.Storable.readWord64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CQL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4CQU; else goto c4CQV;
       c4CQU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.readWord64OffPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CQV: // global
           I64[Sp - 16] = block_c4CQI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4CR1; else goto c4CQJ;
       u4CR1: // global
           call _c4CQI(R1) args: 0, res: 0, upd: 0;
       c4CQJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CQI() //  [R1]
         { info_tbl: [(c4CQI,
                       label: block_c4CQI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CQI: // global
           I64[Sp] = block_c4CQO_info;
           _s4CAD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CAD::I64;
           if (R1 & 7 != 0) goto u4CR0; else goto c4CQP;
       u4CR0: // global
           call _c4CQO(R1) args: 0, res: 0, upd: 0;
       c4CQP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CQO() //  [R1]
         { info_tbl: [(c4CQO,
                       label: block_c4CQO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CQO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4CQZ; else goto c4CQY;
       c4CQZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4CQY: // global
           _s4CAI::I64 = I64[I64[Sp + 8] + (I64[R1 + 7] << 3)];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4CAI::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.644283981 UTC

[section ""data" . GHC.Storable.readWord64OffPtr_closure" {
     GHC.Storable.readWord64OffPtr_closure:
         const GHC.Storable.readWord64OffPtr_info;
 },
 GHC.Storable.readWord64OffPtr_entry() //  [R2, R3]
         { info_tbl: [(c4CRp,
                       label: GHC.Storable.readWord64OffPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CRp: // global
           R3 = R3;
           R2 = R2;
           call GHC.Storable.readWord64OffPtr1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.648166629 UTC

[section ""data" . GHC.Storable.writeWideCharOffPtr1_closure" {
     GHC.Storable.writeWideCharOffPtr1_closure:
         const GHC.Storable.writeWideCharOffPtr1_info;
 },
 GHC.Storable.writeWideCharOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CRD,
                       label: GHC.Storable.writeWideCharOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CRD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4CRM; else goto c4CRN;
       c4CRM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWideCharOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CRN: // global
           I64[Sp - 24] = block_c4CRA_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4CRW; else goto c4CRB;
       u4CRW: // global
           call _c4CRA(R1) args: 0, res: 0, upd: 0;
       c4CRB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CRA() //  [R1]
         { info_tbl: [(c4CRA,
                       label: block_c4CRA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CRA: // global
           I64[Sp] = block_c4CRG_info;
           _s4CAP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CAP::I64;
           if (R1 & 7 != 0) goto u4CRV; else goto c4CRH;
       u4CRV: // global
           call _c4CRG(R1) args: 0, res: 0, upd: 0;
       c4CRH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CRG() //  [R1]
         { info_tbl: [(c4CRG,
                       label: block_c4CRG_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CRG: // global
           I64[Sp] = block_c4CRL_info;
           _s4CAR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CAR::I64;
           if (R1 & 7 != 0) goto u4CRX; else goto c4CRQ;
       u4CRX: // global
           call _c4CRL(R1) args: 0, res: 0, upd: 0;
       c4CRQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CRL() //  [R1]
         { info_tbl: [(c4CRL,
                       label: block_c4CRL_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CRL: // global
           I32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.657174692 UTC

[section ""data" . GHC.Storable.writeWideCharOffPtr_closure" {
     GHC.Storable.writeWideCharOffPtr_closure:
         const GHC.Storable.writeWideCharOffPtr_info;
 },
 GHC.Storable.writeWideCharOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CSr,
                       label: GHC.Storable.writeWideCharOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CSr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWideCharOffPtr1_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.660906153 UTC

[section ""data" . GHC.Storable.writeIntOffPtr1_closure" {
     GHC.Storable.writeIntOffPtr1_closure:
         const GHC.Storable.writeIntOffPtr1_info;
 },
 GHC.Storable.writeIntOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CSF,
                       label: GHC.Storable.writeIntOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CSF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4CSO; else goto c4CSP;
       c4CSO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeIntOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CSP: // global
           I64[Sp - 24] = block_c4CSC_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4CSY; else goto c4CSD;
       u4CSY: // global
           call _c4CSC(R1) args: 0, res: 0, upd: 0;
       c4CSD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CSC() //  [R1]
         { info_tbl: [(c4CSC,
                       label: block_c4CSC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CSC: // global
           I64[Sp] = block_c4CSI_info;
           _s4CB0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CB0::I64;
           if (R1 & 7 != 0) goto u4CSX; else goto c4CSJ;
       u4CSX: // global
           call _c4CSI(R1) args: 0, res: 0, upd: 0;
       c4CSJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CSI() //  [R1]
         { info_tbl: [(c4CSI,
                       label: block_c4CSI_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CSI: // global
           I64[Sp] = block_c4CSN_info;
           _s4CB2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CB2::I64;
           if (R1 & 7 != 0) goto u4CSZ; else goto c4CSS;
       u4CSZ: // global
           call _c4CSN(R1) args: 0, res: 0, upd: 0;
       c4CSS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CSN() //  [R1]
         { info_tbl: [(c4CSN,
                       label: block_c4CSN_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CSN: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.670334689 UTC

[section ""data" . GHC.Storable.writeIntOffPtr_closure" {
     GHC.Storable.writeIntOffPtr_closure:
         const GHC.Storable.writeIntOffPtr_info;
 },
 GHC.Storable.writeIntOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CTt,
                       label: GHC.Storable.writeIntOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CTt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeIntOffPtr1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.673858514 UTC

[section ""data" . GHC.Storable.writeWordOffPtr1_closure" {
     GHC.Storable.writeWordOffPtr1_closure:
         const GHC.Storable.writeWordOffPtr1_info;
 },
 GHC.Storable.writeWordOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CTH,
                       label: GHC.Storable.writeWordOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CTH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4CTQ; else goto c4CTR;
       c4CTQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWordOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CTR: // global
           I64[Sp - 24] = block_c4CTE_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4CU0; else goto c4CTF;
       u4CU0: // global
           call _c4CTE(R1) args: 0, res: 0, upd: 0;
       c4CTF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CTE() //  [R1]
         { info_tbl: [(c4CTE,
                       label: block_c4CTE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CTE: // global
           I64[Sp] = block_c4CTK_info;
           _s4CBb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CBb::I64;
           if (R1 & 7 != 0) goto u4CTZ; else goto c4CTL;
       u4CTZ: // global
           call _c4CTK(R1) args: 0, res: 0, upd: 0;
       c4CTL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CTK() //  [R1]
         { info_tbl: [(c4CTK,
                       label: block_c4CTK_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CTK: // global
           I64[Sp] = block_c4CTP_info;
           _s4CBd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CBd::I64;
           if (R1 & 7 != 0) goto u4CU1; else goto c4CTU;
       u4CU1: // global
           call _c4CTP(R1) args: 0, res: 0, upd: 0;
       c4CTU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CTP() //  [R1]
         { info_tbl: [(c4CTP,
                       label: block_c4CTP_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CTP: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.682733876 UTC

[section ""data" . GHC.Storable.writeWordOffPtr_closure" {
     GHC.Storable.writeWordOffPtr_closure:
         const GHC.Storable.writeWordOffPtr_info;
 },
 GHC.Storable.writeWordOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CUv,
                       label: GHC.Storable.writeWordOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CUv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWordOffPtr1_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.687098822 UTC

[section ""data" . GHC.Storable.writePtrOffPtr1_closure" {
     GHC.Storable.writePtrOffPtr1_closure:
         const GHC.Storable.writePtrOffPtr1_info;
 },
 GHC.Storable.writePtrOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CUJ,
                       label: GHC.Storable.writePtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CUJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4CUS; else goto c4CUT;
       c4CUS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writePtrOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CUT: // global
           I64[Sp - 24] = block_c4CUG_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4CV2; else goto c4CUH;
       u4CV2: // global
           call _c4CUG(R1) args: 0, res: 0, upd: 0;
       c4CUH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CUG() //  [R1]
         { info_tbl: [(c4CUG,
                       label: block_c4CUG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CUG: // global
           I64[Sp] = block_c4CUM_info;
           _s4CBm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CBm::I64;
           if (R1 & 7 != 0) goto u4CV1; else goto c4CUN;
       u4CV1: // global
           call _c4CUM(R1) args: 0, res: 0, upd: 0;
       c4CUN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CUM() //  [R1]
         { info_tbl: [(c4CUM,
                       label: block_c4CUM_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CUM: // global
           I64[Sp] = block_c4CUR_info;
           _s4CBo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CBo::I64;
           if (R1 & 7 != 0) goto u4CV3; else goto c4CUW;
       u4CV3: // global
           call _c4CUR(R1) args: 0, res: 0, upd: 0;
       c4CUW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CUR() //  [R1]
         { info_tbl: [(c4CUR,
                       label: block_c4CUR_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CUR: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.696163845 UTC

[section ""data" . GHC.Storable.writePtrOffPtr_closure" {
     GHC.Storable.writePtrOffPtr_closure:
         const GHC.Storable.writePtrOffPtr_info;
 },
 GHC.Storable.writePtrOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CVx,
                       label: GHC.Storable.writePtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CVx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writePtrOffPtr1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.700362153 UTC

[section ""data" . GHC.Storable.writeFunPtrOffPtr1_closure" {
     GHC.Storable.writeFunPtrOffPtr1_closure:
         const GHC.Storable.writeFunPtrOffPtr1_info;
 },
 GHC.Storable.writeFunPtrOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CVL,
                       label: GHC.Storable.writeFunPtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CVL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4CVU; else goto c4CVV;
       c4CVU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeFunPtrOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CVV: // global
           I64[Sp - 24] = block_c4CVI_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4CW4; else goto c4CVJ;
       u4CW4: // global
           call _c4CVI(R1) args: 0, res: 0, upd: 0;
       c4CVJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CVI() //  [R1]
         { info_tbl: [(c4CVI,
                       label: block_c4CVI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CVI: // global
           I64[Sp] = block_c4CVO_info;
           _s4CBx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CBx::I64;
           if (R1 & 7 != 0) goto u4CW3; else goto c4CVP;
       u4CW3: // global
           call _c4CVO(R1) args: 0, res: 0, upd: 0;
       c4CVP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CVO() //  [R1]
         { info_tbl: [(c4CVO,
                       label: block_c4CVO_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CVO: // global
           I64[Sp] = block_c4CVT_info;
           _s4CBz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CBz::I64;
           if (R1 & 7 != 0) goto u4CW5; else goto c4CVY;
       u4CW5: // global
           call _c4CVT(R1) args: 0, res: 0, upd: 0;
       c4CVY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CVT() //  [R1]
         { info_tbl: [(c4CVT,
                       label: block_c4CVT_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CVT: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.709718988 UTC

[section ""data" . GHC.Storable.writeFunPtrOffPtr_closure" {
     GHC.Storable.writeFunPtrOffPtr_closure:
         const GHC.Storable.writeFunPtrOffPtr_info;
 },
 GHC.Storable.writeFunPtrOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CWz,
                       label: GHC.Storable.writeFunPtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CWz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeFunPtrOffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.713330952 UTC

[section ""data" . GHC.Storable.writeFloatOffPtr1_closure" {
     GHC.Storable.writeFloatOffPtr1_closure:
         const GHC.Storable.writeFloatOffPtr1_info;
 },
 GHC.Storable.writeFloatOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CWN,
                       label: GHC.Storable.writeFloatOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CWN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4CWW; else goto c4CWX;
       c4CWW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeFloatOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CWX: // global
           I64[Sp - 24] = block_c4CWK_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4CX6; else goto c4CWL;
       u4CX6: // global
           call _c4CWK(R1) args: 0, res: 0, upd: 0;
       c4CWL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CWK() //  [R1]
         { info_tbl: [(c4CWK,
                       label: block_c4CWK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CWK: // global
           I64[Sp] = block_c4CWQ_info;
           _s4CBI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CBI::I64;
           if (R1 & 7 != 0) goto u4CX5; else goto c4CWR;
       u4CX5: // global
           call _c4CWQ(R1) args: 0, res: 0, upd: 0;
       c4CWR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CWQ() //  [R1]
         { info_tbl: [(c4CWQ,
                       label: block_c4CWQ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CWQ: // global
           I64[Sp] = block_c4CWV_info;
           _s4CBK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CBK::I64;
           if (R1 & 7 != 0) goto u4CX7; else goto c4CX0;
       u4CX7: // global
           call _c4CWV(R1) args: 0, res: 0, upd: 0;
       c4CX0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CWV() //  [R1]
         { info_tbl: [(c4CWV,
                       label: block_c4CWV_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CWV: // global
           F32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = F32[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.722353668 UTC

[section ""data" . GHC.Storable.writeFloatOffPtr_closure" {
     GHC.Storable.writeFloatOffPtr_closure:
         const GHC.Storable.writeFloatOffPtr_info;
 },
 GHC.Storable.writeFloatOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CXB,
                       label: GHC.Storable.writeFloatOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CXB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeFloatOffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.726064862 UTC

[section ""data" . GHC.Storable.writeDoubleOffPtr1_closure" {
     GHC.Storable.writeDoubleOffPtr1_closure:
         const GHC.Storable.writeDoubleOffPtr1_info;
 },
 GHC.Storable.writeDoubleOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CXP,
                       label: GHC.Storable.writeDoubleOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CXP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4CXY; else goto c4CXZ;
       c4CXY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeDoubleOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CXZ: // global
           I64[Sp - 24] = block_c4CXM_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4CY8; else goto c4CXN;
       u4CY8: // global
           call _c4CXM(R1) args: 0, res: 0, upd: 0;
       c4CXN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CXM() //  [R1]
         { info_tbl: [(c4CXM,
                       label: block_c4CXM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CXM: // global
           I64[Sp] = block_c4CXS_info;
           _s4CBT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CBT::I64;
           if (R1 & 7 != 0) goto u4CY7; else goto c4CXT;
       u4CY7: // global
           call _c4CXS(R1) args: 0, res: 0, upd: 0;
       c4CXT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CXS() //  [R1]
         { info_tbl: [(c4CXS,
                       label: block_c4CXS_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CXS: // global
           I64[Sp] = block_c4CXX_info;
           _s4CBV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CBV::I64;
           if (R1 & 7 != 0) goto u4CY9; else goto c4CY2;
       u4CY9: // global
           call _c4CXX(R1) args: 0, res: 0, upd: 0;
       c4CY2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CXX() //  [R1]
         { info_tbl: [(c4CXX,
                       label: block_c4CXX_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CXX: // global
           F64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = F64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.736011381 UTC

[section ""data" . GHC.Storable.writeDoubleOffPtr_closure" {
     GHC.Storable.writeDoubleOffPtr_closure:
         const GHC.Storable.writeDoubleOffPtr_info;
 },
 GHC.Storable.writeDoubleOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CYD,
                       label: GHC.Storable.writeDoubleOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CYD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeDoubleOffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.74027734 UTC

[section ""data" . GHC.Storable.writeStablePtrOffPtr1_closure" {
     GHC.Storable.writeStablePtrOffPtr1_closure:
         const GHC.Storable.writeStablePtrOffPtr1_info;
 },
 GHC.Storable.writeStablePtrOffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CYR,
                       label: GHC.Storable.writeStablePtrOffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CYR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4CZ0; else goto c4CZ1;
       c4CZ0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeStablePtrOffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4CZ1: // global
           I64[Sp - 24] = block_c4CYO_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4CZa; else goto c4CYP;
       u4CZa: // global
           call _c4CYO(R1) args: 0, res: 0, upd: 0;
       c4CYP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CYO() //  [R1]
         { info_tbl: [(c4CYO,
                       label: block_c4CYO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CYO: // global
           I64[Sp] = block_c4CYU_info;
           _s4CC4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CC4::I64;
           if (R1 & 7 != 0) goto u4CZ9; else goto c4CYV;
       u4CZ9: // global
           call _c4CYU(R1) args: 0, res: 0, upd: 0;
       c4CYV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CYU() //  [R1]
         { info_tbl: [(c4CYU,
                       label: block_c4CYU_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CYU: // global
           I64[Sp] = block_c4CYZ_info;
           _s4CC6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CC6::I64;
           if (R1 & 7 != 0) goto u4CZb; else goto c4CZ4;
       u4CZb: // global
           call _c4CYZ(R1) args: 0, res: 0, upd: 0;
       c4CZ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CYZ() //  [R1]
         { info_tbl: [(c4CYZ,
                       label: block_c4CYZ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CYZ: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.749582049 UTC

[section ""data" . GHC.Storable.writeStablePtrOffPtr_closure" {
     GHC.Storable.writeStablePtrOffPtr_closure:
         const GHC.Storable.writeStablePtrOffPtr_info;
 },
 GHC.Storable.writeStablePtrOffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CZF,
                       label: GHC.Storable.writeStablePtrOffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CZF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeStablePtrOffPtr1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.753292691 UTC

[section ""data" . GHC.Storable.writeInt8OffPtr1_closure" {
     GHC.Storable.writeInt8OffPtr1_closure:
         const GHC.Storable.writeInt8OffPtr1_info;
 },
 GHC.Storable.writeInt8OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4CZT,
                       label: GHC.Storable.writeInt8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CZT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4D02; else goto c4D03;
       c4D02: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt8OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4D03: // global
           I64[Sp - 24] = block_c4CZQ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4D0c; else goto c4CZR;
       u4D0c: // global
           call _c4CZQ(R1) args: 0, res: 0, upd: 0;
       c4CZR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CZQ() //  [R1]
         { info_tbl: [(c4CZQ,
                       label: block_c4CZQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CZQ: // global
           I64[Sp] = block_c4CZW_info;
           _s4CCf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CCf::I64;
           if (R1 & 7 != 0) goto u4D0b; else goto c4CZX;
       u4D0b: // global
           call _c4CZW(R1) args: 0, res: 0, upd: 0;
       c4CZX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4CZW() //  [R1]
         { info_tbl: [(c4CZW,
                       label: block_c4CZW_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4CZW: // global
           I64[Sp] = block_c4D01_info;
           _s4CCh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CCh::I64;
           if (R1 & 7 != 0) goto u4D0d; else goto c4D06;
       u4D0d: // global
           call _c4D01(R1) args: 0, res: 0, upd: 0;
       c4D06: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D01() //  [R1]
         { info_tbl: [(c4D01,
                       label: block_c4D01_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D01: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.762715577 UTC

[section ""data" . GHC.Storable.writeInt8OffPtr_closure" {
     GHC.Storable.writeInt8OffPtr_closure:
         const GHC.Storable.writeInt8OffPtr_info;
 },
 GHC.Storable.writeInt8OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D0H,
                       label: GHC.Storable.writeInt8OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D0H: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt8OffPtr1_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.766363887 UTC

[section ""data" . GHC.Storable.writeWord8OffPtr1_closure" {
     GHC.Storable.writeWord8OffPtr1_closure:
         const GHC.Storable.writeWord8OffPtr1_info;
 },
 GHC.Storable.writeWord8OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D0V,
                       label: GHC.Storable.writeWord8OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D0V: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4D14; else goto c4D15;
       c4D14: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord8OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4D15: // global
           I64[Sp - 24] = block_c4D0S_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4D1e; else goto c4D0T;
       u4D1e: // global
           call _c4D0S(R1) args: 0, res: 0, upd: 0;
       c4D0T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D0S() //  [R1]
         { info_tbl: [(c4D0S,
                       label: block_c4D0S_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D0S: // global
           I64[Sp] = block_c4D0Y_info;
           _s4CCq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CCq::I64;
           if (R1 & 7 != 0) goto u4D1d; else goto c4D0Z;
       u4D1d: // global
           call _c4D0Y(R1) args: 0, res: 0, upd: 0;
       c4D0Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D0Y() //  [R1]
         { info_tbl: [(c4D0Y,
                       label: block_c4D0Y_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D0Y: // global
           I64[Sp] = block_c4D13_info;
           _s4CCs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CCs::I64;
           if (R1 & 7 != 0) goto u4D1f; else goto c4D18;
       u4D1f: // global
           call _c4D13(R1) args: 0, res: 0, upd: 0;
       c4D18: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D13() //  [R1]
         { info_tbl: [(c4D13,
                       label: block_c4D13_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D13: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.77590211 UTC

[section ""data" . GHC.Storable.writeWord8OffPtr_closure" {
     GHC.Storable.writeWord8OffPtr_closure:
         const GHC.Storable.writeWord8OffPtr_info;
 },
 GHC.Storable.writeWord8OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D1J,
                       label: GHC.Storable.writeWord8OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D1J: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord8OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.779758369 UTC

[section ""data" . GHC.Storable.writeInt16OffPtr1_closure" {
     GHC.Storable.writeInt16OffPtr1_closure:
         const GHC.Storable.writeInt16OffPtr1_info;
 },
 GHC.Storable.writeInt16OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D1X,
                       label: GHC.Storable.writeInt16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D1X: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4D26; else goto c4D27;
       c4D26: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt16OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4D27: // global
           I64[Sp - 24] = block_c4D1U_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4D2g; else goto c4D1V;
       u4D2g: // global
           call _c4D1U(R1) args: 0, res: 0, upd: 0;
       c4D1V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D1U() //  [R1]
         { info_tbl: [(c4D1U,
                       label: block_c4D1U_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D1U: // global
           I64[Sp] = block_c4D20_info;
           _s4CCB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CCB::I64;
           if (R1 & 7 != 0) goto u4D2f; else goto c4D21;
       u4D2f: // global
           call _c4D20(R1) args: 0, res: 0, upd: 0;
       c4D21: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D20() //  [R1]
         { info_tbl: [(c4D20,
                       label: block_c4D20_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D20: // global
           I64[Sp] = block_c4D25_info;
           _s4CCD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CCD::I64;
           if (R1 & 7 != 0) goto u4D2h; else goto c4D2a;
       u4D2h: // global
           call _c4D25(R1) args: 0, res: 0, upd: 0;
       c4D2a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D25() //  [R1]
         { info_tbl: [(c4D25,
                       label: block_c4D25_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D25: // global
           I16[I64[Sp + 8] + (I64[Sp + 16] << 1)] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.789219978 UTC

[section ""data" . GHC.Storable.writeInt16OffPtr_closure" {
     GHC.Storable.writeInt16OffPtr_closure:
         const GHC.Storable.writeInt16OffPtr_info;
 },
 GHC.Storable.writeInt16OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D2L,
                       label: GHC.Storable.writeInt16OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D2L: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt16OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.793172963 UTC

[section ""data" . GHC.Storable.writeWord16OffPtr1_closure" {
     GHC.Storable.writeWord16OffPtr1_closure:
         const GHC.Storable.writeWord16OffPtr1_info;
 },
 GHC.Storable.writeWord16OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D2Z,
                       label: GHC.Storable.writeWord16OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D2Z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4D38; else goto c4D39;
       c4D38: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord16OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4D39: // global
           I64[Sp - 24] = block_c4D2W_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4D3i; else goto c4D2X;
       u4D3i: // global
           call _c4D2W(R1) args: 0, res: 0, upd: 0;
       c4D2X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D2W() //  [R1]
         { info_tbl: [(c4D2W,
                       label: block_c4D2W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D2W: // global
           I64[Sp] = block_c4D32_info;
           _s4CCM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CCM::I64;
           if (R1 & 7 != 0) goto u4D3h; else goto c4D33;
       u4D3h: // global
           call _c4D32(R1) args: 0, res: 0, upd: 0;
       c4D33: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D32() //  [R1]
         { info_tbl: [(c4D32,
                       label: block_c4D32_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D32: // global
           I64[Sp] = block_c4D37_info;
           _s4CCO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CCO::I64;
           if (R1 & 7 != 0) goto u4D3j; else goto c4D3c;
       u4D3j: // global
           call _c4D37(R1) args: 0, res: 0, upd: 0;
       c4D3c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D37() //  [R1]
         { info_tbl: [(c4D37,
                       label: block_c4D37_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D37: // global
           I16[I64[Sp + 8] + (I64[Sp + 16] << 1)] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.80249514 UTC

[section ""data" . GHC.Storable.writeWord16OffPtr_closure" {
     GHC.Storable.writeWord16OffPtr_closure:
         const GHC.Storable.writeWord16OffPtr_info;
 },
 GHC.Storable.writeWord16OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D3N,
                       label: GHC.Storable.writeWord16OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D3N: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord16OffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.80676236 UTC

[section ""data" . GHC.Storable.writeInt32OffPtr1_closure" {
     GHC.Storable.writeInt32OffPtr1_closure:
         const GHC.Storable.writeInt32OffPtr1_info;
 },
 GHC.Storable.writeInt32OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D41,
                       label: GHC.Storable.writeInt32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D41: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4D4a; else goto c4D4b;
       c4D4a: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt32OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4D4b: // global
           I64[Sp - 24] = block_c4D3Y_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4D4k; else goto c4D3Z;
       u4D4k: // global
           call _c4D3Y(R1) args: 0, res: 0, upd: 0;
       c4D3Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D3Y() //  [R1]
         { info_tbl: [(c4D3Y,
                       label: block_c4D3Y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D3Y: // global
           I64[Sp] = block_c4D44_info;
           _s4CCX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CCX::I64;
           if (R1 & 7 != 0) goto u4D4j; else goto c4D45;
       u4D4j: // global
           call _c4D44(R1) args: 0, res: 0, upd: 0;
       c4D45: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D44() //  [R1]
         { info_tbl: [(c4D44,
                       label: block_c4D44_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D44: // global
           I64[Sp] = block_c4D49_info;
           _s4CCZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CCZ::I64;
           if (R1 & 7 != 0) goto u4D4l; else goto c4D4e;
       u4D4l: // global
           call _c4D49(R1) args: 0, res: 0, upd: 0;
       c4D4e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D49() //  [R1]
         { info_tbl: [(c4D49,
                       label: block_c4D49_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D49: // global
           I32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.816023366 UTC

[section ""data" . GHC.Storable.writeInt32OffPtr_closure" {
     GHC.Storable.writeInt32OffPtr_closure:
         const GHC.Storable.writeInt32OffPtr_info;
 },
 GHC.Storable.writeInt32OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D4P,
                       label: GHC.Storable.writeInt32OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D4P: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt32OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.819596408 UTC

[section ""data" . GHC.Storable.writeWord32OffPtr1_closure" {
     GHC.Storable.writeWord32OffPtr1_closure:
         const GHC.Storable.writeWord32OffPtr1_info;
 },
 GHC.Storable.writeWord32OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D53,
                       label: GHC.Storable.writeWord32OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D53: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4D5c; else goto c4D5d;
       c4D5c: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord32OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4D5d: // global
           I64[Sp - 24] = block_c4D50_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4D5m; else goto c4D51;
       u4D5m: // global
           call _c4D50(R1) args: 0, res: 0, upd: 0;
       c4D51: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D50() //  [R1]
         { info_tbl: [(c4D50,
                       label: block_c4D50_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D50: // global
           I64[Sp] = block_c4D56_info;
           _s4CD8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CD8::I64;
           if (R1 & 7 != 0) goto u4D5l; else goto c4D57;
       u4D5l: // global
           call _c4D56(R1) args: 0, res: 0, upd: 0;
       c4D57: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D56() //  [R1]
         { info_tbl: [(c4D56,
                       label: block_c4D56_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D56: // global
           I64[Sp] = block_c4D5b_info;
           _s4CDa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CDa::I64;
           if (R1 & 7 != 0) goto u4D5n; else goto c4D5g;
       u4D5n: // global
           call _c4D5b(R1) args: 0, res: 0, upd: 0;
       c4D5g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D5b() //  [R1]
         { info_tbl: [(c4D5b,
                       label: block_c4D5b_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D5b: // global
           I32[I64[Sp + 8] + (I64[Sp + 16] << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.828971241 UTC

[section ""data" . GHC.Storable.writeWord32OffPtr_closure" {
     GHC.Storable.writeWord32OffPtr_closure:
         const GHC.Storable.writeWord32OffPtr_info;
 },
 GHC.Storable.writeWord32OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D5R,
                       label: GHC.Storable.writeWord32OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D5R: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord32OffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.832700433 UTC

[section ""data" . GHC.Storable.writeInt64OffPtr1_closure" {
     GHC.Storable.writeInt64OffPtr1_closure:
         const GHC.Storable.writeInt64OffPtr1_info;
 },
 GHC.Storable.writeInt64OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D65,
                       label: GHC.Storable.writeInt64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D65: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4D6e; else goto c4D6f;
       c4D6e: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeInt64OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4D6f: // global
           I64[Sp - 24] = block_c4D62_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4D6o; else goto c4D63;
       u4D6o: // global
           call _c4D62(R1) args: 0, res: 0, upd: 0;
       c4D63: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D62() //  [R1]
         { info_tbl: [(c4D62,
                       label: block_c4D62_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D62: // global
           I64[Sp] = block_c4D68_info;
           _s4CDj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CDj::I64;
           if (R1 & 7 != 0) goto u4D6n; else goto c4D69;
       u4D6n: // global
           call _c4D68(R1) args: 0, res: 0, upd: 0;
       c4D69: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D68() //  [R1]
         { info_tbl: [(c4D68,
                       label: block_c4D68_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D68: // global
           I64[Sp] = block_c4D6d_info;
           _s4CDl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CDl::I64;
           if (R1 & 7 != 0) goto u4D6p; else goto c4D6i;
       u4D6p: // global
           call _c4D6d(R1) args: 0, res: 0, upd: 0;
       c4D6i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D6d() //  [R1]
         { info_tbl: [(c4D6d,
                       label: block_c4D6d_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D6d: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.842517201 UTC

[section ""data" . GHC.Storable.writeInt64OffPtr_closure" {
     GHC.Storable.writeInt64OffPtr_closure:
         const GHC.Storable.writeInt64OffPtr_info;
 },
 GHC.Storable.writeInt64OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D6T,
                       label: GHC.Storable.writeInt64OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D6T: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeInt64OffPtr1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.846117226 UTC

[section ""data" . GHC.Storable.writeWord64OffPtr1_closure" {
     GHC.Storable.writeWord64OffPtr1_closure:
         const GHC.Storable.writeWord64OffPtr1_info;
 },
 GHC.Storable.writeWord64OffPtr1_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D77,
                       label: GHC.Storable.writeWord64OffPtr1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D77: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4D7g; else goto c4D7h;
       c4D7g: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Storable.writeWord64OffPtr1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4D7h: // global
           I64[Sp - 24] = block_c4D74_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4D7q; else goto c4D75;
       u4D7q: // global
           call _c4D74(R1) args: 0, res: 0, upd: 0;
       c4D75: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D74() //  [R1]
         { info_tbl: [(c4D74,
                       label: block_c4D74_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D74: // global
           I64[Sp] = block_c4D7a_info;
           _s4CDu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4CDu::I64;
           if (R1 & 7 != 0) goto u4D7p; else goto c4D7b;
       u4D7p: // global
           call _c4D7a(R1) args: 0, res: 0, upd: 0;
       c4D7b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D7a() //  [R1]
         { info_tbl: [(c4D7a,
                       label: block_c4D7a_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D7a: // global
           I64[Sp] = block_c4D7f_info;
           _s4CDw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4CDw::I64;
           if (R1 & 7 != 0) goto u4D7r; else goto c4D7k;
       u4D7r: // global
           call _c4D7f(R1) args: 0, res: 0, upd: 0;
       c4D7k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4D7f() //  [R1]
         { info_tbl: [(c4D7f,
                       label: block_c4D7f_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D7f: // global
           I64[I64[Sp + 8] + (I64[Sp + 16] << 3)] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.855345408 UTC

[section ""data" . GHC.Storable.writeWord64OffPtr_closure" {
     GHC.Storable.writeWord64OffPtr_closure:
         const GHC.Storable.writeWord64OffPtr_info;
 },
 GHC.Storable.writeWord64OffPtr_entry() //  [R2, R3, R4]
         { info_tbl: [(c4D7V,
                       label: GHC.Storable.writeWord64OffPtr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4D7V: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Storable.writeWord64OffPtr1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.85902656 UTC

[section ""cstring" . GHC.Storable.$trModule4_bytes" {
     GHC.Storable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.860764163 UTC

[section ""data" . GHC.Storable.$trModule3_closure" {
     GHC.Storable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Storable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.862404314 UTC

[section ""cstring" . GHC.Storable.$trModule2_bytes" {
     GHC.Storable.$trModule2_bytes:
         I8[] [71,72,67,46,83,116,111,114,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.86402262 UTC

[section ""data" . GHC.Storable.$trModule1_closure" {
     GHC.Storable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Storable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.865897176 UTC

[section ""data" . GHC.Storable.$trModule_closure" {
     GHC.Storable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Storable.$trModule3_closure+1;
         const GHC.Storable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:29.867866176 UTC

[section ""relreadonly" . S4D87_srt" { S4D87_srt:
 }]

