
==================== Output Cmm ====================
2018-03-16 16:07:27.172593217 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:27.17325935 UTC

[section ""cstring" . GHC.ByteOrder.$fReadByteOrder11_bytes" {
     GHC.ByteOrder.$fReadByteOrder11_bytes:
         I8[] [66,105,103,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.174180361 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder10_closure" {
     GHC.ByteOrder.$fReadByteOrder10_closure:
         const GHC.ByteOrder.$fReadByteOrder10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder10_entry() //  [R1]
         { info_tbl: [(ccypi,
                       label: GHC.ByteOrder.$fReadByteOrder10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccypi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccypj; else goto ccypk;
       ccypj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccypk: // global
           (_ccypf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccypf::I64 == 0) goto ccyph; else goto ccypg;
       ccyph: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccypg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccypf::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.175179804 UTC

[section ""cstring" . GHC.ByteOrder.$fReadByteOrder7_bytes" {
     GHC.ByteOrder.$fReadByteOrder7_bytes:
         I8[] [76,105,116,116,108,101,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.175931134 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder6_closure" {
     GHC.ByteOrder.$fReadByteOrder6_closure:
         const GHC.ByteOrder.$fReadByteOrder6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder6_entry() //  [R1]
         { info_tbl: [(ccypr,
                       label: GHC.ByteOrder.$fReadByteOrder6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccypr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyps; else goto ccypt;
       ccyps: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccypt: // global
           (_ccypo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccypo::I64 == 0) goto ccypq; else goto ccypp;
       ccypq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccypp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccypo::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.177188646 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(ccypF,
                       label: GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccypF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccypG; else goto ccypH;
       ccypG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccypH: // global
           I64[Sp - 16] = block_ccypy_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucypO; else goto ccypz;
       ucypO: // global
           call _ccypy(R1) args: 0, res: 0, upd: 0;
       ccypz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccypy() //  [R1]
         { info_tbl: [(ccypy,
                       label: block_ccypy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccypy: // global
           _scykL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccypC; else goto ccypD;
       ccypC: // global
           R3 = _scykL::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccypD: // global
           R3 = _scykL::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.178637161 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshow_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshow_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshow_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshow_entry() //  [R2]
         { info_tbl: [(ccyq1,
                       label: GHC.ByteOrder.$fShowByteOrder_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyq1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccyq2; else goto ccyq3;
       ccyq2: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyq3: // global
           I64[Sp - 8] = block_ccypU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucyqa; else goto ccypV;
       ucyqa: // global
           call _ccypU(R1) args: 0, res: 0, upd: 0;
       ccypV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccypU() //  [R1]
         { info_tbl: [(ccypU,
                       label: block_ccypU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccypU: // global
           if (R1 & 7 == 1) goto ccypY; else goto ccypZ;
       ccypY: // global
           R1 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccypZ: // global
           R1 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.179974139 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder1_closure" {
     GHC.ByteOrder.$fShowByteOrder1_closure:
         const GHC.ByteOrder.$fShowByteOrder1_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder1_entry() //  [R2, R3]
         { info_tbl: [(ccyqm,
                       label: GHC.ByteOrder.$fShowByteOrder1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyqm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyqn; else goto ccyqo;
       ccyqn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyqo: // global
           I64[Sp - 16] = block_ccyqf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucyqv; else goto ccyqg;
       ucyqv: // global
           call _ccyqf(R1) args: 0, res: 0, upd: 0;
       ccyqg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyqf() //  [R1]
         { info_tbl: [(ccyqf,
                       label: block_ccyqf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyqf: // global
           _scykQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyqj; else goto ccyqk;
       ccyqj: // global
           R3 = _scykQ::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccyqk: // global
           R3 = _scykQ::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.181225568 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshowList_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshowList_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(ccyqA,
                       label: GHC.ByteOrder.$fShowByteOrder_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyqA: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.ByteOrder.$fShowByteOrder1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.182005617 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_closure" {
     GHC.ByteOrder.$fShowByteOrder_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure+3;
         const GHC.ByteOrder.$fShowByteOrder_$cshow_closure+1;
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.182749695 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder9_closure" {
     GHC.ByteOrder.$fReadByteOrder9_closure:
         const GHC.ByteOrder.$fReadByteOrder9_info;
 },
 GHC.ByteOrder.$fReadByteOrder9_entry() //  [R3]
         { info_tbl: [(ccyqH,
                       label: GHC.ByteOrder.$fReadByteOrder9_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyqH: // global
           R2 = GHC.ByteOrder.BigEndian_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.183507889 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder8_closure" {
     GHC.ByteOrder.$fReadByteOrder8_closure:
         const (,)_con_info;
         const GHC.ByteOrder.$fReadByteOrder10_closure;
         const GHC.ByteOrder.$fReadByteOrder9_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.184273874 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder5_closure" {
     GHC.ByteOrder.$fReadByteOrder5_closure:
         const GHC.ByteOrder.$fReadByteOrder5_info;
 },
 GHC.ByteOrder.$fReadByteOrder5_entry() //  [R3]
         { info_tbl: [(ccyqO,
                       label: GHC.ByteOrder.$fReadByteOrder5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyqO: // global
           R2 = GHC.ByteOrder.LittleEndian_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.185087338 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder4_closure" {
     GHC.ByteOrder.$fReadByteOrder4_closure:
         const (,)_con_info;
         const GHC.ByteOrder.$fReadByteOrder6_closure;
         const GHC.ByteOrder.$fReadByteOrder5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.185770543 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder3_closure" {
     GHC.ByteOrder.$fReadByteOrder3_closure:
         const :_con_info;
         const GHC.ByteOrder.$fReadByteOrder4_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.186392669 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_sps_closure" {
     GHC.ByteOrder.$fReadByteOrder_sps_closure:
         const :_con_info;
         const GHC.ByteOrder.$fReadByteOrder8_closure+1;
         const GHC.ByteOrder.$fReadByteOrder3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.187116666 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder2_closure" {
     GHC.ByteOrder.$fReadByteOrder2_closure:
         const GHC.ByteOrder.$fReadByteOrder2_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder2_entry() //  [R2]
         { info_tbl: [(ccyqV,
                       label: GHC.ByteOrder.$fReadByteOrder2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyqV: // global
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.188032665 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder1_closure" {
     GHC.ByteOrder.$fReadByteOrder1_closure:
         const GHC.ByteOrder.$fReadByteOrder1_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder1_entry() //  [R2, R3]
         { info_tbl: [(ccyr2,
                       label: GHC.ByteOrder.$fReadByteOrder1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyr2: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.189108052 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info;
         const 0;
 },
 sat_scyl0_entry() //  [R1]
         { info_tbl: [(ccyrd,
                       label: sat_scyl0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyrd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyre; else goto ccyrf;
       ccyre: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyrf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.ByteOrder.$fReadByteOrder2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fReadByteOrder_$creadsPrec_entry() //  [R2]
         { info_tbl: [(ccyrg,
                       label: GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyrg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccyrk; else goto ccyrj;
       ccyrk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyrj: // global
           I64[Hp - 16] = sat_scyl0_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.191418892 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadListPrec_entry() //  [R1]
         { info_tbl: [(ccyrr,
                       label: GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyrr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyrs; else goto ccyrt;
       ccyrs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyrt: // global
           (_ccyro::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyro::I64 == 0) goto ccyrq; else goto ccyrp;
       ccyrq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyrp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyro::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.192506769 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder12_closure" {
     GHC.ByteOrder.$fReadByteOrder12_closure:
         const GHC.ByteOrder.$fReadByteOrder12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder12_entry() //  [R1]
         { info_tbl: [(ccyrA,
                       label: GHC.ByteOrder.$fReadByteOrder12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyrA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyrB; else goto ccyrC;
       ccyrB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyrC: // global
           (_ccyrx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyrx::I64 == 0) goto ccyrz; else goto ccyry;
       ccyrz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyry: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyrx::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.193590368 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadList_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadList_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadList_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadList_entry() //  [R2]
         { info_tbl: [(ccyrH,
                       label: GHC.ByteOrder.$fReadByteOrder_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyrH: // global
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.194327177 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_closure" {
     GHC.ByteOrder.$fReadByteOrder_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure+1;
         const GHC.ByteOrder.$fReadByteOrder_$creadList_closure+1;
         const GHC.ByteOrder.$fReadByteOrder1_closure+2;
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.19494938 UTC

[section ""data" . GHC.ByteOrder.$fBoundedByteOrder_closure" {
     GHC.ByteOrder.$fBoundedByteOrder_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.ByteOrder.BigEndian_closure+1;
         const GHC.ByteOrder.LittleEndian_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.19596467 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c<_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c<_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c<_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c<_entry() //  [R2, R3]
         { info_tbl: [(ccyrV,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyrV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyrW; else goto ccyrX;
       ccyrW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyrX: // global
           I64[Sp - 16] = block_ccyrO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucysp; else goto ccyrP;
       ucysp: // global
           call _ccyrO(R1) args: 0, res: 0, upd: 0;
       ccyrP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyrO() //  [R1]
         { info_tbl: [(ccyrO,
                       label: block_ccyrO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyrO: // global
           _scyl2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyrS; else goto ccyrT;
       ccyrS: // global
           I64[Sp + 8] = block_ccys0_info;
           R1 = _scyl2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucysn; else goto ccys2;
       ucysn: // global
           call _ccys0(R1) args: 0, res: 0, upd: 0;
       ccys2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccyrT: // global
           I64[Sp + 8] = block_ccysf_info;
           R1 = _scyl2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyso; else goto ccysh;
       ucyso: // global
           call _ccysf() args: 0, res: 0, upd: 0;
       ccysh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccys0() //  [R1]
         { info_tbl: [(ccys0,
                       label: block_ccys0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccys0: // global
           if (R1 & 7 == 1) goto ccys8; else goto ccysc;
       ccys8: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccysc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccysf() //  []
         { info_tbl: [(ccysf,
                       label: block_ccysf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccysf: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.19809793 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(ccysB,
                       label: GHC.ByteOrder.$fOrdByteOrder_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccysB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccysC; else goto ccysD;
       ccysC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccysD: // global
           I64[Sp - 16] = block_ccysu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucyte; else goto ccysv;
       ucyte: // global
           call _ccysu(R1) args: 0, res: 0, upd: 0;
       ccysv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccysu() //  [R1]
         { info_tbl: [(ccysu,
                       label: block_ccysu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccysu: // global
           _scyl7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccysy; else goto ccysz;
       ccysy: // global
           I64[Sp + 8] = block_ccysG_info;
           R1 = _scyl7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucytc; else goto ccysI;
       ucytc: // global
           call _ccysG(R1) args: 0, res: 0, upd: 0;
       ccysI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccysz: // global
           I64[Sp + 8] = block_ccysV_info;
           R1 = _scyl7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucytd; else goto ccysX;
       ucytd: // global
           call _ccysV(R1) args: 0, res: 0, upd: 0;
       ccysX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccysG() //  [R1]
         { info_tbl: [(ccysG,
                       label: block_ccysG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccysG: // global
           if (R1 & 7 == 1) goto ucytb; else goto ccysS;
       ucytb: // global
           Sp = Sp + 8;
           call _ccyt7() args: 0, res: 0, upd: 0;
       ccysS: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccysV() //  [R1]
         { info_tbl: [(ccysV,
                       label: block_ccysV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccysV: // global
           if (R1 & 7 == 1) goto ccyt3; else goto ucyta;
       ccyt3: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ucyta: // global
           Sp = Sp + 8;
           call _ccyt7() args: 0, res: 0, upd: 0;
     }
 },
 _ccyt7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyt7: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.200174414 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_$c==_closure" {
     GHC.ByteOrder.$fEqByteOrder_$c==_closure:
         const GHC.ByteOrder.$fEqByteOrder_$c==_info;
 },
 GHC.ByteOrder.$fEqByteOrder_$c==_entry() //  [R2, R3]
         { info_tbl: [(ccyts,
                       label: GHC.ByteOrder.$fEqByteOrder_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyts: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccytt; else goto ccytu;
       ccytt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEqByteOrder_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccytu: // global
           I64[Sp - 16] = block_ccytl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucyu7; else goto ccytm;
       ucyu7: // global
           call _ccytl(R1) args: 0, res: 0, upd: 0;
       ccytm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccytl() //  [R1]
         { info_tbl: [(ccytl,
                       label: block_ccytl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccytl: // global
           _scylc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccytp; else goto ccytq;
       ccytp: // global
           I64[Sp + 8] = block_ccytx_info;
           R1 = _scylc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyu5; else goto ccytz;
       ucyu5: // global
           call _ccytx(R1) args: 0, res: 0, upd: 0;
       ccytz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccytq: // global
           I64[Sp + 8] = block_ccytM_info;
           R1 = _scylc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyu6; else goto ccytO;
       ucyu6: // global
           call _ccytM(R1) args: 0, res: 0, upd: 0;
       ccytO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccytx() //  [R1]
         { info_tbl: [(ccytx,
                       label: block_ccytx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccytx: // global
           if (R1 & 7 == 1) goto ucyu3; else goto ucyu4;
       ucyu3: // global
           Sp = Sp + 8;
           call _ccytY() args: 0, res: 0, upd: 0;
       ucyu4: // global
           Sp = Sp + 8;
           call _ccytU() args: 0, res: 0, upd: 0;
     }
 },
 _ccytM() //  [R1]
         { info_tbl: [(ccytM,
                       label: block_ccytM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccytM: // global
           if (R1 & 7 == 1) goto ucyu1; else goto ucyu2;
       ucyu1: // global
           Sp = Sp + 8;
           call _ccytU() args: 0, res: 0, upd: 0;
       ucyu2: // global
           Sp = Sp + 8;
           call _ccytY() args: 0, res: 0, upd: 0;
     }
 },
 _ccytU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccytU: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccytY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccytY: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.202334378 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_$c/=_closure" {
     GHC.ByteOrder.$fEqByteOrder_$c/=_closure:
         const GHC.ByteOrder.$fEqByteOrder_$c/=_info;
 },
 GHC.ByteOrder.$fEqByteOrder_$c/=_entry() //  [R2, R3]
         { info_tbl: [(ccyun,
                       label: GHC.ByteOrder.$fEqByteOrder_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyun: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyuo; else goto ccyup;
       ccyuo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEqByteOrder_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyup: // global
           I64[Sp - 16] = block_ccyug_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucyv2; else goto ccyuh;
       ucyv2: // global
           call _ccyug(R1) args: 0, res: 0, upd: 0;
       ccyuh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyug() //  [R1]
         { info_tbl: [(ccyug,
                       label: block_ccyug_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyug: // global
           _scylh::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyuk; else goto ccyul;
       ccyuk: // global
           I64[Sp + 8] = block_ccyus_info;
           R1 = _scylh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyv0; else goto ccyuu;
       ucyv0: // global
           call _ccyus(R1) args: 0, res: 0, upd: 0;
       ccyuu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccyul: // global
           I64[Sp + 8] = block_ccyuH_info;
           R1 = _scylh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyv1; else goto ccyuJ;
       ucyv1: // global
           call _ccyuH(R1) args: 0, res: 0, upd: 0;
       ccyuJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyus() //  [R1]
         { info_tbl: [(ccyus,
                       label: block_ccyus_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyus: // global
           if (R1 & 7 == 1) goto ucyuY; else goto ucyuZ;
       ucyuY: // global
           Sp = Sp + 8;
           call _ccyuT() args: 0, res: 0, upd: 0;
       ucyuZ: // global
           Sp = Sp + 8;
           call _ccyuP() args: 0, res: 0, upd: 0;
     }
 },
 _ccyuH() //  [R1]
         { info_tbl: [(ccyuH,
                       label: block_ccyuH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyuH: // global
           if (R1 & 7 == 1) goto ucyuW; else goto ucyuX;
       ucyuW: // global
           Sp = Sp + 8;
           call _ccyuP() args: 0, res: 0, upd: 0;
       ucyuX: // global
           Sp = Sp + 8;
           call _ccyuT() args: 0, res: 0, upd: 0;
     }
 },
 _ccyuP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyuP: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccyuT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyuT: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.203970231 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_closure" {
     GHC.ByteOrder.$fEqByteOrder_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.ByteOrder.$fEqByteOrder_$c==_closure+2;
         const GHC.ByteOrder.$fEqByteOrder_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.204989267 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c<=_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c<=_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c<=_entry() //  [R2, R3]
         { info_tbl: [(ccyvi,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyvi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyvj; else goto ccyvk;
       ccyvj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyvk: // global
           I64[Sp - 16] = block_ccyvb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucyvM; else goto ccyvc;
       ucyvM: // global
           call _ccyvb(R1) args: 0, res: 0, upd: 0;
       ccyvc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyvb() //  [R1]
         { info_tbl: [(ccyvb,
                       label: block_ccyvb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyvb: // global
           _scyll::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyvf; else goto ccyvg;
       ccyvf: // global
           I64[Sp + 8] = block_ccyvn_info;
           R1 = _scyll::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyvK; else goto ccyvp;
       ucyvK: // global
           call _ccyvn(R1) args: 0, res: 0, upd: 0;
       ccyvp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccyvg: // global
           I64[Sp + 8] = block_ccyvC_info;
           R1 = _scyll::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyvL; else goto ccyvE;
       ucyvL: // global
           call _ccyvC() args: 0, res: 0, upd: 0;
       ccyvE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyvn() //  [R1]
         { info_tbl: [(ccyvn,
                       label: block_ccyvn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyvn: // global
           if (R1 & 7 == 1) goto ccyvv; else goto ccyvz;
       ccyvv: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyvz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccyvC() //  []
         { info_tbl: [(ccyvC,
                       label: block_ccyvC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyvC: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.20685357 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$cmax_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$cmax_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$cmax_entry() //  [R2, R3]
         { info_tbl: [(ccyvY,
                       label: GHC.ByteOrder.$fOrdByteOrder_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyvY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyvZ; else goto ccyw0;
       ccyvZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyw0: // global
           I64[Sp - 16] = block_ccyvR_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucywe; else goto ccyvS;
       ucywe: // global
           call _ccyvR(R1) args: 0, res: 0, upd: 0;
       ccyvS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyvR() //  [R1]
         { info_tbl: [(ccyvR,
                       label: block_ccyvR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyvR: // global
           _scylq::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyvV; else goto ccyvW;
       ccyvV: // global
           R1 = _scylq::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccyvW: // global
           I64[Sp + 8] = block_ccyw6_info;
           R1 = _scylq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucywd; else goto ccyw8;
       ucywd: // global
           call _ccyw6() args: 0, res: 0, upd: 0;
       ccyw8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyw6() //  []
         { info_tbl: [(ccyw6,
                       label: block_ccyw6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyw6: // global
           R1 = GHC.ByteOrder.LittleEndian_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.208519588 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c>=_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c>=_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c>=_entry() //  [R2, R3]
         { info_tbl: [(ccywq,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccywq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccywr; else goto ccyws;
       ccywr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyws: // global
           I64[Sp - 16] = block_ccywj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucywU; else goto ccywk;
       ucywU: // global
           call _ccywj(R1) args: 0, res: 0, upd: 0;
       ccywk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccywj() //  [R1]
         { info_tbl: [(ccywj,
                       label: block_ccywj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccywj: // global
           _scylv::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccywn; else goto ccywo;
       ccywn: // global
           I64[Sp + 8] = block_ccywv_info;
           R1 = _scylv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucywS; else goto ccywx;
       ucywS: // global
           call _ccywv(R1) args: 0, res: 0, upd: 0;
       ccywx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccywo: // global
           I64[Sp + 8] = block_ccywK_info;
           R1 = _scylv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucywT; else goto ccywM;
       ucywT: // global
           call _ccywK() args: 0, res: 0, upd: 0;
       ccywM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccywv() //  [R1]
         { info_tbl: [(ccywv,
                       label: block_ccywv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccywv: // global
           if (R1 & 7 == 1) goto ccywD; else goto ccywH;
       ccywD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccywH: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccywK() //  []
         { info_tbl: [(ccywK,
                       label: block_ccywK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccywK: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.210588527 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c>_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c>_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c>_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c>_entry() //  [R2, R3]
         { info_tbl: [(ccywZ,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccywZ: // global
           _scylA::P64 = R3;
           R3 = R2;
           R2 = _scylA::P64;
           call GHC.ByteOrder.$fOrdByteOrder_$c<_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.211642132 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$cmin_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$cmin_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$cmin_entry() //  [R2, R3]
         { info_tbl: [(ccyxd,
                       label: GHC.ByteOrder.$fOrdByteOrder_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyxd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyxe; else goto ccyxf;
       ccyxe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyxf: // global
           I64[Sp - 16] = block_ccyx6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucyxt; else goto ccyx7;
       ucyxt: // global
           call _ccyx6(R1) args: 0, res: 0, upd: 0;
       ccyx7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyx6() //  [R1]
         { info_tbl: [(ccyx6,
                       label: block_ccyx6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyx6: // global
           _scylB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyxa; else goto ccyxb;
       ccyxa: // global
           I64[Sp + 8] = block_ccyxi_info;
           R1 = _scylB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyxs; else goto ccyxk;
       ucyxs: // global
           call _ccyxi() args: 0, res: 0, upd: 0;
       ccyxk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccyxb: // global
           R1 = _scylB::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccyxi() //  []
         { info_tbl: [(ccyxi,
                       label: block_ccyxi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyxi: // global
           R1 = GHC.ByteOrder.BigEndian_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.212922061 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_closure" {
     GHC.ByteOrder.$fOrdByteOrder_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.ByteOrder.$fEqByteOrder_closure+1;
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c<_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c>_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.213668302 UTC

[section ""data" . GHC.ByteOrder.targetByteOrder_closure" {
     GHC.ByteOrder.targetByteOrder_closure:
         const GHC.ByteOrder.LittleEndian_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.214246825 UTC

[section ""data" . lvl_rcykn_closure" {
     lvl_rcykn_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.214839651 UTC

[section ""data" . lvl1_rcyko_closure" {
     lvl1_rcyko_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.215688468 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_entry() //  [R2]
         { info_tbl: [(ccyxF,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyxF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccyxG; else goto ccyxH;
       ccyxG: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyxH: // global
           I64[Sp - 8] = block_ccyxy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucyxO; else goto ccyxz;
       ucyxO: // global
           call _ccyxy(R1) args: 0, res: 0, upd: 0;
       ccyxz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyxy() //  [R1]
         { info_tbl: [(ccyxy,
                       label: block_ccyxy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyxy: // global
           if (R1 & 7 == 1) goto ccyxC; else goto ccyxD;
       ccyxC: // global
           R1 = lvl_rcykn_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyxD: // global
           R1 = lvl1_rcyko_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.21673412 UTC

[section ""cstring" . lvl2_rcykp_bytes" {
     lvl2_rcykp_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.217529772 UTC

[section ""data" . lvl3_rcykq_closure" {
     lvl3_rcykq_closure:
         const lvl3_rcykq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rcykq_entry() //  [R1]
         { info_tbl: [(ccyxV,
                       label: lvl3_rcykq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyxV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyxW; else goto ccyxX;
       ccyxW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyxX: // global
           (_ccyxS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyxS::I64 == 0) goto ccyxU; else goto ccyxT;
       ccyxU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyxT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyxS::I64;
           R2 = lvl2_rcykp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.218458577 UTC

[section ""cstring" . GHC.ByteOrder.$trModule4_bytes" {
     GHC.ByteOrder.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.219247599 UTC

[section ""data" . lvl4_rcykr_closure" {
     lvl4_rcykr_closure:
         const lvl4_rcykr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rcykr_entry() //  [R1]
         { info_tbl: [(ccyy4,
                       label: lvl4_rcykr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyy4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyy5; else goto ccyy6;
       ccyy5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyy6: // global
           (_ccyy1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyy1::I64 == 0) goto ccyy3; else goto ccyy2;
       ccyy3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyy2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyy1::I64;
           R2 = GHC.ByteOrder.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.220178121 UTC

[section ""cstring" . GHC.ByteOrder.$trModule2_bytes" {
     GHC.ByteOrder.$trModule2_bytes:
         I8[] [71,72,67,46,66,121,116,101,79,114,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.220975469 UTC

[section ""data" . lvl5_rcyks_closure" {
     lvl5_rcyks_closure:
         const lvl5_rcyks_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rcyks_entry() //  [R1]
         { info_tbl: [(ccyyd,
                       label: lvl5_rcyks_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyyd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyye; else goto ccyyf;
       ccyye: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyyf: // global
           (_ccyya::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyya::I64 == 0) goto ccyyc; else goto ccyyb;
       ccyyc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyyb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyya::I64;
           R2 = GHC.ByteOrder.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.222027035 UTC

[section ""cstring" . lvl6_rcykt_bytes" {
     lvl6_rcykt_bytes:
         I8[] [46,47,71,72,67,47,66,121,116,101,79,114,100,101,114,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.222781646 UTC

[section ""data" . lvl7_rcyku_closure" {
     lvl7_rcyku_closure:
         const lvl7_rcyku_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rcyku_entry() //  [R1]
         { info_tbl: [(ccyym,
                       label: lvl7_rcyku_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyym: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyyn; else goto ccyyo;
       ccyyn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyyo: // global
           (_ccyyj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyyj::I64 == 0) goto ccyyl; else goto ccyyk;
       ccyyl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyyk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyyj::I64;
           R2 = lvl6_rcykt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.223740298 UTC

[section ""data" . lvl8_rcykv_closure" {
     lvl8_rcykv_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.224330903 UTC

[section ""data" . lvl9_rcykw_closure" {
     lvl9_rcykw_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.22593501 UTC

[section ""data" . lvl10_rcykx_closure" {
     lvl10_rcykx_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.226510565 UTC

[section ""data" . lvl11_rcyky_closure" {
     lvl11_rcyky_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl4_rcykr_closure;
         const lvl5_rcyks_closure;
         const lvl7_rcyku_closure;
         const lvl8_rcykv_closure+1;
         const lvl9_rcykw_closure+1;
         const lvl8_rcykv_closure+1;
         const lvl10_rcykx_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.227107588 UTC

[section ""data" . lvl12_rcykz_closure" {
     lvl12_rcykz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl3_rcykq_closure;
         const lvl11_rcyky_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.227672609 UTC

[section ""cstring" . lvl13_rcykA_bytes" {
     lvl13_rcykA_bytes:
         I8[] [112,114,101,100,123,66,121,116,101,79,114,100,101,114,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,112,114,101,100,39,32,111,102,32,102,105,114,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.22846743 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder3_closure" {
     GHC.ByteOrder.$fEnumByteOrder3_closure:
         const GHC.ByteOrder.$fEnumByteOrder3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder3_entry() //  [R1]
         { info_tbl: [(ccyyx,
                       label: GHC.ByteOrder.$fEnumByteOrder3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyyx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccyyy; else goto ccyyz;
       ccyyy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyyz: // global
           (_ccyys::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyys::I64 == 0) goto ccyyu; else goto ccyyt;
       ccyyu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyyt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyys::I64;
           I64[Sp - 24] = block_ccyyv_info;
           R2 = lvl13_rcykA_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccyyv() //  [R1]
         { info_tbl: [(ccyyv,
                       label: block_ccyyv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyyv: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.230022214 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cpred_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cpred_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cpred_entry() //  [R2]
         { info_tbl: [(ccyyO,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyyO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccyyP; else goto ccyyQ;
       ccyyP: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyyQ: // global
           I64[Sp - 8] = block_ccyyH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucyyX; else goto ccyyI;
       ucyyX: // global
           call _ccyyH(R1) args: 0, res: 0, upd: 0;
       ccyyI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyyH() //  [R1]
         { info_tbl: [(ccyyH,
                       label: block_ccyyH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyyH: // global
           if (R1 & 7 == 1) goto ccyyL; else goto ccyyM;
       ccyyL: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccyyM: // global
           R1 = GHC.ByteOrder.BigEndian_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.231067165 UTC

[section ""cstring" . lvl14_rcykB_bytes" {
     lvl14_rcykB_bytes:
         I8[] [115,117,99,99,123,66,121,116,101,79,114,100,101,114,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,115,117,99,99,39,32,111,102,32,108,97,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.231816303 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder4_closure" {
     GHC.ByteOrder.$fEnumByteOrder4_closure:
         const GHC.ByteOrder.$fEnumByteOrder4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder4_entry() //  [R1]
         { info_tbl: [(ccyz6,
                       label: GHC.ByteOrder.$fEnumByteOrder4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyz6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccyz7; else goto ccyz8;
       ccyz7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyz8: // global
           (_ccyz1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyz1::I64 == 0) goto ccyz3; else goto ccyz2;
       ccyz3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyz2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyz1::I64;
           I64[Sp - 24] = block_ccyz4_info;
           R2 = lvl14_rcykB_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccyz4() //  [R1]
         { info_tbl: [(ccyz4,
                       label: block_ccyz4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyz4: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.233089185 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$csucc_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$csucc_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$csucc_entry() //  [R2]
         { info_tbl: [(ccyzn,
                       label: GHC.ByteOrder.$fEnumByteOrder_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyzn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccyzo; else goto ccyzp;
       ccyzo: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyzp: // global
           I64[Sp - 8] = block_ccyzg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucyzw; else goto ccyzh;
       ucyzw: // global
           call _ccyzg(R1) args: 0, res: 0, upd: 0;
       ccyzh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyzg() //  [R1]
         { info_tbl: [(ccyzg,
                       label: block_ccyzg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyzg: // global
           if (R1 & 7 == 1) goto ccyzk; else goto ccyzl;
       ccyzk: // global
           R1 = GHC.ByteOrder.LittleEndian_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyzl: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.234123196 UTC

[section ""cstring" . lvl15_rcykC_bytes" {
     lvl15_rcykC_bytes:
         I8[] [41,32,105,115,32,111,117,116,115,105,100,101,32,111,102,32,101,110,117,109,101,114,97,116,105,111,110,39,115,32,114,97,110,103,101,32,40,48,44]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.234677708 UTC

[section ""cstring" . lvl16_rcykD_bytes" {
     lvl16_rcykD_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.235395005 UTC

[section ""data" . lvl17_rcykE_closure" {
     lvl17_rcykE_closure:
         const lvl17_rcykE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_rcykE_entry() //  [R1]
         { info_tbl: [(ccyzD,
                       label: lvl17_rcykE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyzD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyzE; else goto ccyzF;
       ccyzE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyzF: // global
           (_ccyzA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyzA::I64 == 0) goto ccyzC; else goto ccyzB;
       ccyzC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyzB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyzA::I64;
           R2 = lvl16_rcykD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.2365356 UTC

[section ""data" . lvl18_rcykF_closure" {
     lvl18_rcykF_closure:
         const lvl18_rcykF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_rcykF_entry() //  [R1]
         { info_tbl: [(ccyzP,
                       label: lvl18_rcykF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyzP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccyzQ; else goto ccyzR;
       ccyzQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyzR: // global
           (_ccyzJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyzJ::I64 == 0) goto ccyzL; else goto ccyzK;
       ccyzL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyzK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyzJ::I64;
           I64[Sp - 24] = block_ccyzM_info;
           R4 = lvl17_rcykE_closure;
           R3 = 1;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccyzM() //  [R1, R2]
         { info_tbl: [(ccyzM,
                       label: block_ccyzM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyzM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccyzU; else goto ccyzT;
       ccyzU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccyzT: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.237965477 UTC

[section ""data" . lvl19_rcykG_closure" {
     lvl19_rcykG_closure:
         const lvl19_rcykG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_rcykG_entry() //  [R1]
         { info_tbl: [(ccyA1,
                       label: lvl19_rcykG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyA1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyA2; else goto ccyA3;
       ccyA2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyA3: // global
           (_ccyzY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyzY::I64 == 0) goto ccyA0; else goto ccyzZ;
       ccyA0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyzZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyzY::I64;
           R3 = lvl18_rcykF_closure;
           R2 = lvl15_rcykC_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.238879061 UTC

[section ""cstring" . lvl20_rcykH_bytes" {
     lvl20_rcykH_bytes:
         I8[] [116,111,69,110,117,109,123,66,121,116,101,79,114,100,101,114,125,58,32,116,97,103,32,40]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.239927024 UTC

[section ""data" . GHC.ByteOrder.$wlvl_closure" {
     GHC.ByteOrder.$wlvl_closure:
         const GHC.ByteOrder.$wlvl_info;
         const 0;
 },
 sat_scylU_entry() //  [R1]
         { info_tbl: [(ccyAf,
                       label: sat_scylU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyAf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccyAg; else goto ccyAh;
       ccyAg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyAh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccyAc_info;
           R4 = lvl19_rcykG_closure;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccyAc() //  [R1, R2]
         { info_tbl: [(ccyAc,
                       label: block_ccyAc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyAc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccyAk; else goto ccyAj;
       ccyAk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccyAj: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$wlvl_entry() //  [R2]
         { info_tbl: [(ccyAn,
                       label: GHC.ByteOrder.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyAn: // global
           _scylQ::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccyAo; else goto ccyAp;
       ccyAp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccyAr; else goto ccyAq;
       ccyAr: // global
           HpAlloc = 24;
           goto ccyAo;
       ccyAo: // global
           R2 = _scylQ::I64;
           R1 = GHC.ByteOrder.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyAq: // global
           I64[Hp - 16] = sat_scylU_info;
           I64[Hp] = _scylQ::I64;
           I64[Sp - 8] = block_ccyAl_info;
           R3 = Hp - 16;
           R2 = lvl20_rcykH_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccyAl() //  [R1]
         { info_tbl: [(ccyAl,
                       label: block_ccyAl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyAl: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.241784756 UTC

[section ""data" . GHC.ByteOrder.$w$ctoEnum_closure" {
     GHC.ByteOrder.$w$ctoEnum_closure:
         const GHC.ByteOrder.$w$ctoEnum_info;
         const 0;
 },
 GHC.ByteOrder.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(ccyAE,
                       label: GHC.ByteOrder.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyAE: // global
           _scylW::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto ccyAM; else goto ccyAD;
       ccyAD: // global
           if (%MO_S_Gt_W64(_scylW::I64, 1)) goto ccyAM; else goto ccyAN;
       ccyAM: // global
           R2 = _scylW::I64;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ccyAN: // global
           R1 = I64[(_scylW::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.242896958 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_entry() //  [R2]
         { info_tbl: [(ccyAV,
                       label: GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyAV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccyAW; else goto ccyAX;
       ccyAW: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyAX: // global
           I64[Sp - 8] = block_ccyAS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucyB1; else goto ccyAT;
       ucyB1: // global
           call _ccyAS(R1) args: 0, res: 0, upd: 0;
       ccyAT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyAS() //  [R1]
         { info_tbl: [(ccyAS,
                       label: block_ccyAS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyAS: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.ByteOrder.$w$ctoEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.244354186 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go2_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go2_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go2_info;
 },
 sat_scym6_entry() //  [R1]
         { info_tbl: [(ccyBe,
                       label: sat_scym6_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyBe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyBf; else goto ccyBg;
       ccyBf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyBg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scym4::I64 = I64[R1 + 16];
           if (_scym4::I64 != 1) goto ccyBc; else goto ccyBd;
       ccyBc: // global
           R2 = _scym4::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
       ccyBd: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scym3_entry() //  [R1]
         { info_tbl: [(ccyBn,
                       label: sat_scym3_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyBn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyBo; else goto ccyBp;
       ccyBo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyBp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_go2_entry() //  [R2]
         { info_tbl: [(ccyBr,
                       label: GHC.ByteOrder.$fEnumByteOrder_go2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyBr: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccyBv; else goto ccyBu;
       ccyBv: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyBu: // global
           I64[Hp - 64] = sat_scym6_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scym3_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.246474051 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder2_closure" {
     GHC.ByteOrder.$fEnumByteOrder2_closure:
         const GHC.ByteOrder.$fEnumByteOrder2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder2_entry() //  [R1]
         { info_tbl: [(ccyBC,
                       label: GHC.ByteOrder.$fEnumByteOrder2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyBC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyBD; else goto ccyBE;
       ccyBD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyBE: // global
           (_ccyBz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyBz::I64 == 0) goto ccyBB; else goto ccyBA;
       ccyBB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyBA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyBz::I64;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.247504317 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder1_closure" {
     GHC.ByteOrder.$fEnumByteOrder1_closure:
         const GHC.ByteOrder.$fEnumByteOrder1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder1_entry() //  [R1]
         { info_tbl: [(ccyBL,
                       label: GHC.ByteOrder.$fEnumByteOrder1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyBL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyBM; else goto ccyBN;
       ccyBM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyBN: // global
           (_ccyBI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyBI::I64 == 0) goto ccyBK; else goto ccyBJ;
       ccyBK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyBJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyBI::I64;
           R2 = 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.248650856 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_entry() //  [R2]
         { info_tbl: [(ccyBZ,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyBZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccyC0; else goto ccyC1;
       ccyC0: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyC1: // global
           I64[Sp - 8] = block_ccyBS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucyC8; else goto ccyBT;
       ucyC8: // global
           call _ccyBS(R1) args: 0, res: 0, upd: 0;
       ccyBT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyBS() //  [R1]
         { info_tbl: [(ccyBS,
                       label: block_ccyBS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyBS: // global
           if (R1 & 7 == 1) goto ccyBW; else goto ccyBX;
       ccyBW: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccyBX: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.255086023 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info;
 },
 sat_scymq_entry() //  [R1]
         { info_tbl: [(ccyCU,
                       label: sat_scymq_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyCU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyCV; else goto ccyCW;
       ccyCV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyCW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scyml_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymo_entry() //  [R1]
         { info_tbl: [(ccyD1,
                       label: sat_scymo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyD1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyD2; else goto ccyD3;
       ccyD2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyD3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymr_entry() //  [R1]
         { info_tbl: [(ccyD9,
                       label: sat_scymr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyD9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyDa; else goto ccyDb;
       ccyDa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyDb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scyml_entry() //  [R1, R2]
         { info_tbl: [(ccyDf,
                       label: go_dn_scyml_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyDf: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccyDj; else goto ccyDi;
       ccyDj: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyDi: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccyDd; else goto ccyDe;
       ccyDd: // global
           _scymj::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scymq_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scymj::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scymo_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyDe: // global
           I64[Hp - 80] = sat_scymr_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccyDl::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccyDl::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyms_entry() //  [R1]
         { info_tbl: [(ccyDm,
                       label: sat_scyms_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyDm: // global
           _scyms::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccyDn; else goto ccyDo;
       ccyDo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccyDq; else goto ccyDp;
       ccyDq: // global
           HpAlloc = 24;
           goto ccyDn;
       ccyDn: // global
           R1 = _scyms::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyDp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyms::P64;
           _scyme::I64 = I64[_scyms::P64 + 24];
           _scymj::I64 = _scyme::I64 - I64[_scyms::P64 + 16];
           I64[Hp - 16] = go_dn_scyml_info;
           I64[Hp - 8] = _scymj::I64;
           I64[Hp] = 1 - _scymj::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scyml_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymi_entry() //  [R1]
         { info_tbl: [(ccyDv,
                       label: sat_scymi_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyDv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyDw; else goto ccyDx;
       ccyDw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyDx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymu_entry() //  [R1]
         { info_tbl: [(ccyDG,
                       label: sat_scymu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyDG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyDH; else goto ccyDI;
       ccyDH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyDI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymE_entry() //  [R1]
         { info_tbl: [(ccyEb,
                       label: sat_scymE_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyEb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyEc; else goto ccyEd;
       ccyEc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyEd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scymz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymC_entry() //  [R1]
         { info_tbl: [(ccyEi,
                       label: sat_scymC_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyEi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyEj; else goto ccyEk;
       ccyEj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyEk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymF_entry() //  [R1]
         { info_tbl: [(ccyEq,
                       label: sat_scymF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyEq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyEr; else goto ccyEs;
       ccyEr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyEs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scymz_entry() //  [R1, R2]
         { info_tbl: [(ccyEw,
                       label: go_up_scymz_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyEw: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccyEA; else goto ccyEz;
       ccyEA: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyEz: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccyEu; else goto ccyEv;
       ccyEu: // global
           _scymx::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scymE_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scymx::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scymC_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyEv: // global
           I64[Hp - 80] = sat_scymF_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccyEC::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccyEC::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scymG_entry() //  [R1]
         { info_tbl: [(ccyED,
                       label: sat_scymG_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyED: // global
           _scymG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccyEE; else goto ccyEF;
       ccyEF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccyEH; else goto ccyEG;
       ccyEH: // global
           HpAlloc = 24;
           goto ccyEE;
       ccyEE: // global
           R1 = _scymG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyEG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scymG::P64;
           _scyme::I64 = I64[_scymG::P64 + 24];
           _scymx::I64 = _scyme::I64 - I64[_scymG::P64 + 16];
           I64[Hp - 16] = go_up_scymz_info;
           I64[Hp - 8] = _scymx::I64;
           I64[Hp] = 1 - _scymx::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scymz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymw_entry() //  [R1]
         { info_tbl: [(ccyEM,
                       label: sat_scymw_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyEM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyEN; else goto ccyEO;
       ccyEN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyEO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymI_entry() //  [R1]
         { info_tbl: [(ccyEX,
                       label: sat_scymI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyEX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyEY; else goto ccyEZ;
       ccyEY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyEZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymT_entry() //  [R1]
         { info_tbl: [(ccyFv,
                       label: sat_scymT_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyFv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyFw; else goto ccyFx;
       ccyFw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyFx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scymO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymR_entry() //  [R1]
         { info_tbl: [(ccyFC,
                       label: sat_scymR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyFC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyFD; else goto ccyFE;
       ccyFD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyFE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymU_entry() //  [R1]
         { info_tbl: [(ccyFK,
                       label: sat_scymU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyFK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyFL; else goto ccyFM;
       ccyFL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyFM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scymO_entry() //  [R1, R2]
         { info_tbl: [(ccyFQ,
                       label: go_dn_scymO_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyFQ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccyFU; else goto ccyFT;
       ccyFU: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyFT: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccyFO; else goto ccyFP;
       ccyFO: // global
           _scymM::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scymT_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scymM::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scymR_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyFP: // global
           I64[Hp - 80] = sat_scymU_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccyFW::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccyFW::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scymV_entry() //  [R1]
         { info_tbl: [(ccyFX,
                       label: sat_scymV_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyFX: // global
           _scymV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccyFY; else goto ccyFZ;
       ccyFZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccyG1; else goto ccyG0;
       ccyG1: // global
           HpAlloc = 24;
           goto ccyFY;
       ccyFY: // global
           R1 = _scymV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyG0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scymV::P64;
           _scyme::I64 = I64[_scymV::P64 + 24];
           _scymM::I64 = _scyme::I64 - I64[_scymV::P64 + 16];
           I64[Hp - 16] = go_dn_scymO_info;
           I64[Hp - 8] = _scymM::I64;
           I64[Hp] = 0 - _scymM::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scymO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymL_entry() //  [R1]
         { info_tbl: [(ccyG6,
                       label: sat_scymL_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyG6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyG7; else goto ccyG8;
       ccyG7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyG8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymX_entry() //  [R1]
         { info_tbl: [(ccyGh,
                       label: sat_scymX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyGh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyGi; else goto ccyGj;
       ccyGi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyGj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyn7_entry() //  [R1]
         { info_tbl: [(ccyGM,
                       label: sat_scyn7_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyGM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyGN; else goto ccyGO;
       ccyGN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyGO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scyn2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyn5_entry() //  [R1]
         { info_tbl: [(ccyGT,
                       label: sat_scyn5_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyGT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyGU; else goto ccyGV;
       ccyGU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyGV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyn8_entry() //  [R1]
         { info_tbl: [(ccyH1,
                       label: sat_scyn8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyH1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyH2; else goto ccyH3;
       ccyH2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyH3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scyn2_entry() //  [R1, R2]
         { info_tbl: [(ccyH7,
                       label: go_up_scyn2_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyH7: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccyHb; else goto ccyHa;
       ccyHb: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyHa: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccyH5; else goto ccyH6;
       ccyH5: // global
           _scyn0::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyn7_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyn0::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyn5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyH6: // global
           I64[Hp - 80] = sat_scyn8_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccyHd::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccyHd::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyn9_entry() //  [R1]
         { info_tbl: [(ccyHe,
                       label: sat_scyn9_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyHe: // global
           _scyn9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccyHf; else goto ccyHg;
       ccyHg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccyHi; else goto ccyHh;
       ccyHi: // global
           HpAlloc = 24;
           goto ccyHf;
       ccyHf: // global
           R1 = _scyn9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyHh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyn9::P64;
           _scyme::I64 = I64[_scyn9::P64 + 24];
           _scyn0::I64 = _scyme::I64 - I64[_scyn9::P64 + 16];
           I64[Hp - 16] = go_up_scyn2_info;
           I64[Hp - 8] = _scyn0::I64;
           I64[Hp] = 0 - _scyn0::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scyn2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymZ_entry() //  [R1]
         { info_tbl: [(ccyHn,
                       label: sat_scymZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyHn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyHo; else goto ccyHp;
       ccyHo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyHp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynb_entry() //  [R1]
         { info_tbl: [(ccyHy,
                       label: sat_scynb_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyHy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyHz; else goto ccyHA;
       ccyHz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyHA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(ccyHI,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyHI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyHJ; else goto ccyHK;
       ccyHJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyHK: // global
           I64[Sp - 16] = block_ccyHB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucyIS; else goto ccyHC;
       ucyIS: // global
           call _ccyHB(R1) args: 0, res: 0, upd: 0;
       ccyHC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyHB() //  [R1]
         { info_tbl: [(ccyHB,
                       label: block_ccyHB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyHB: // global
           _scyma::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyHF; else goto ccyHG;
       ccyHF: // global
           _scymc::I64 = 0;
           goto scymb;
       ccyHG: // global
           _scymc::I64 = 1;
           goto scymb;
       scymb: // global
           I64[Sp] = block_ccyHL_info;
           R1 = _scyma::P64;
           I64[Sp + 8] = _scymc::I64;
           if (R1 & 7 != 0) goto ucyIR; else goto ccyIv;
       ucyIR: // global
           call _ccyHL(R1) args: 0, res: 0, upd: 0;
       ccyIv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyHL() //  [R1]
         { info_tbl: [(ccyHL,
                       label: block_ccyHL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyHL: // global
           if (R1 & 7 == 1) goto ccyIB; else goto ccyIF;
       ccyIB: // global
           I64[Sp] = 0;
           goto ucyIU;
       ccyIF: // global
           I64[Sp] = 1;
           goto ucyIU;
       ucyIU: // global
           call _ccyCl() args: 0, res: 0, upd: 0;
     }
 },
 _ccyCl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyCl: // global
           Hp = Hp + 80;
           _scyme::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto ccyHP; else goto ccyHO;
       ccyHP: // global
           HpAlloc = 80;
           I64[Sp] = block_ccyCk_info;
           R1 = _scyme::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccyHO: // global
           _scymc::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_scymc::I64,
                            _scyme::I64)) goto ccyIa; else goto ccyIu;
       ccyIa: // global
           if (%MO_S_Lt_W64(_scyme::I64,
                            _scymc::I64)) goto ccyHZ; else goto ccyI8;
       ccyHZ: // global
           if (%MO_S_Le_W64(1, _scyme::I64)) goto ccyHS; else goto ccyHX;
       ccyHS: // global
           I64[Hp - 72] = sat_scyms_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymi_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyHX: // global
           if (%MO_S_Gt_W64(1, _scymc::I64)) goto ccyIr; else goto ccyHV;
       ccyHV: // global
           I64[Hp - 72] = sat_scymu_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccyHT::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccyHT::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyI8: // global
           if (%MO_S_Ge_W64(1, _scyme::I64)) goto ccyI2; else goto ccyI7;
       ccyI2: // global
           I64[Hp - 72] = sat_scymG_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymw_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyI7: // global
           if (%MO_S_Lt_W64(1, _scymc::I64)) goto ccyIr; else goto ccyI5;
       ccyI5: // global
           I64[Hp - 72] = sat_scymI_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccyI3::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccyI3::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyIu: // global
           if (%MO_S_Lt_W64(_scyme::I64,
                            _scymc::I64)) goto ccyIk; else goto ccyIt;
       ccyIk: // global
           if (%MO_S_Le_W64(0, _scyme::I64)) goto ccyId; else goto ccyIi;
       ccyId: // global
           I64[Hp - 72] = sat_scymV_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymL_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyIi: // global
           if (%MO_S_Gt_W64(0, _scymc::I64)) goto ccyIr; else goto ccyIg;
       ccyIg: // global
           I64[Hp - 72] = sat_scymX_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccyIe::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccyIe::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyIt: // global
           if (%MO_S_Ge_W64(0, _scyme::I64)) goto ccyIn; else goto ccyIs;
       ccyIn: // global
           I64[Hp - 72] = sat_scyn9_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymZ_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyIs: // global
           if (%MO_S_Lt_W64(0, _scymc::I64)) goto ccyIr; else goto ccyIq;
       ccyIr: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyIq: // global
           I64[Hp - 72] = sat_scynb_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccyIo::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccyIo::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccyCk() //  [R1]
         { info_tbl: [(ccyCk,
                       label: block_ccyCk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyCk: // global
           I64[Sp] = R1;
           call _ccyCl() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.268929908 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go1_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go1_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go1_info;
         const 0;
 },
 sat_scynk_entry() //  [R1]
         { info_tbl: [(ccyJ7,
                       label: sat_scynk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyJ7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyJ8; else goto ccyJ9;
       ccyJ8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyJ9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyni::I64 = I64[R1 + 16];
           if (_scyni::I64 != 0) goto ccyJ5; else goto ccyJ6;
       ccyJ5: // global
           R2 = _scyni::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go1_entry(R2) args: 24, res: 0, upd: 24;
       ccyJ6: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynh_entry() //  [R1]
         { info_tbl: [(ccyJl,
                       label: sat_scynh_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyJl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyJm; else goto ccyJu;
       ccyJm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyJu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyne::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyne::I64, 0)) goto ccyJs; else goto ccyJk;
       ccyJk: // global
           if (%MO_S_Gt_W64(_scyne::I64, 1)) goto ccyJs; else goto ccyJt;
       ccyJs: // global
           R2 = _scyne::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyJt: // global
           R1 = I64[(_scyne::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_go1_entry() //  [R2]
         { info_tbl: [(ccyJw,
                       label: GHC.ByteOrder.$fEnumByteOrder_go1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyJw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccyJA; else goto ccyJz;
       ccyJA: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyJz: // global
           I64[Hp - 64] = sat_scynk_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scynh_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.271072703 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go_info;
         const 0;
 },
 sat_scynr_entry() //  [R1]
         { info_tbl: [(ccyJN,
                       label: sat_scynr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyJN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyJO; else goto ccyJP;
       ccyJO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyJP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynp::I64 = I64[R1 + 16];
           if (_scynp::I64 != 1) goto ccyJL; else goto ccyJM;
       ccyJL: // global
           R2 = _scynp::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go_entry(R2) args: 24, res: 0, upd: 24;
       ccyJM: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyno_entry() //  [R1]
         { info_tbl: [(ccyK1,
                       label: sat_scyno_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyK1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyK2; else goto ccyKa;
       ccyK2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyKa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynl::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynl::I64, 0)) goto ccyK8; else goto ccyK0;
       ccyK0: // global
           if (%MO_S_Gt_W64(_scynl::I64, 1)) goto ccyK8; else goto ccyK9;
       ccyK8: // global
           R2 = _scynl::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyK9: // global
           R1 = I64[(_scynl::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_go_entry() //  [R2]
         { info_tbl: [(ccyKc,
                       label: GHC.ByteOrder.$fEnumByteOrder_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyKc: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccyKg; else goto ccyKf;
       ccyKg: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyKf: // global
           I64[Hp - 64] = sat_scynr_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyno_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.273161876 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(ccyKu,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyKu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyKv; else goto ccyKw;
       ccyKv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyKw: // global
           I64[Sp - 16] = block_ccyKn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucyL5; else goto ccyKo;
       ucyL5: // global
           call _ccyKn(R1) args: 0, res: 0, upd: 0;
       ccyKo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyKn() //  [R1]
         { info_tbl: [(ccyKn,
                       label: block_ccyKn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyKn: // global
           _scynt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyKr; else goto ccyKs;
       ccyKr: // global
           _scynv::I64 = 0;
           goto scynu;
       ccyKs: // global
           _scynv::I64 = 1;
           goto scynu;
       scynu: // global
           I64[Sp] = block_ccyKA_info;
           R1 = _scynt::P64;
           I64[Sp + 8] = _scynv::I64;
           if (R1 & 7 != 0) goto ucyL4; else goto ccyKC;
       ucyL4: // global
           call _ccyKA(R1) args: 0, res: 0, upd: 0;
       ccyKC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyKA() //  [R1]
         { info_tbl: [(ccyKA,
                       label: block_ccyKA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyKA: // global
           _scynv::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto ccyKN; else goto ccyKW;
       ccyKN: // global
           if (%MO_S_Gt_W64(_scynv::I64, 0)) goto ccyKV; else goto ccyKK;
       ccyKK: // global
           R2 = _scynv::I64;
           Sp = Sp + 16;
           call GHC.ByteOrder.$fEnumByteOrder_go1_entry(R2) args: 8, res: 0, upd: 8;
       ccyKW: // global
           if (%MO_S_Gt_W64(_scynv::I64, 1)) goto ccyKV; else goto ccyKU;
       ccyKV: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyKU: // global
           R2 = _scynv::I64;
           Sp = Sp + 16;
           call GHC.ByteOrder.$fEnumByteOrder_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.281545891 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info;
         const 0;
 },
 sat_scynW_entry() //  [R1]
         { info_tbl: [(ccyLT,
                       label: sat_scynW_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyLT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyLU; else goto ccyLV;
       ccyLU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyLV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scynP_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynU_entry() //  [R1]
         { info_tbl: [(ccyM5,
                       label: sat_scynU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyM5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyM6; else goto ccyMe;
       ccyM6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyMe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynQ::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynQ::I64, 0)) goto ccyMc; else goto ccyM4;
       ccyM4: // global
           if (%MO_S_Gt_W64(_scynQ::I64, 1)) goto ccyMc; else goto ccyMd;
       ccyMc: // global
           R2 = _scynQ::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyMd: // global
           R1 = I64[(_scynQ::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynZ_entry() //  [R1]
         { info_tbl: [(ccyMp,
                       label: sat_scynZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyMp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyMq; else goto ccyMy;
       ccyMq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyMy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynQ::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynQ::I64, 0)) goto ccyMw; else goto ccyMo;
       ccyMo: // global
           if (%MO_S_Gt_W64(_scynQ::I64, 1)) goto ccyMw; else goto ccyMx;
       ccyMw: // global
           R2 = _scynQ::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyMx: // global
           R1 = I64[(_scynQ::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scynP_entry() //  [R1, R2]
         { info_tbl: [(ccyMC,
                       label: go_dn_scynP_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyMC: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccyMG; else goto ccyMF;
       ccyMG: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyMF: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccyMA; else goto ccyMB;
       ccyMA: // global
           _scynN::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scynW_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scynN::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scynU_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyMB: // global
           I64[Hp - 80] = sat_scynZ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccyMI::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccyMI::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyo0_entry() //  [R1]
         { info_tbl: [(ccyMJ,
                       label: sat_scyo0_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyMJ: // global
           _scyo0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccyMK; else goto ccyML;
       ccyML: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccyMN; else goto ccyMM;
       ccyMN: // global
           HpAlloc = 24;
           goto ccyMK;
       ccyMK: // global
           R1 = _scyo0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyMM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyo0::P64;
           _scynG::I64 = I64[_scyo0::P64 + 24];
           _scynN::I64 = _scynG::I64 - I64[_scyo0::P64 + 16];
           I64[Hp - 16] = go_dn_scynP_info;
           I64[Hp - 8] = _scynN::I64;
           I64[Hp] = 0 - _scynN::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scynP_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynM_entry() //  [R1]
         { info_tbl: [(ccyMX,
                       label: sat_scynM_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyMX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyMY; else goto ccyN6;
       ccyMY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyN6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccyN4; else goto ccyMW;
       ccyMW: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccyN4; else goto ccyN5;
       ccyN4: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyN5: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyo4_entry() //  [R1]
         { info_tbl: [(ccyNk,
                       label: sat_scyo4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyNk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyNl; else goto ccyNt;
       ccyNl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyNt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccyNr; else goto ccyNj;
       ccyNj: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccyNr; else goto ccyNs;
       ccyNr: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyNs: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoi_entry() //  [R1]
         { info_tbl: [(ccyNW,
                       label: sat_scyoi_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyNW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyNX; else goto ccyNY;
       ccyNX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyNY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scyob_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyog_entry() //  [R1]
         { info_tbl: [(ccyO8,
                       label: sat_scyog_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyO8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyO9; else goto ccyOh;
       ccyO9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyOh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoc::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoc::I64, 0)) goto ccyOf; else goto ccyO7;
       ccyO7: // global
           if (%MO_S_Gt_W64(_scyoc::I64, 1)) goto ccyOf; else goto ccyOg;
       ccyOf: // global
           R2 = _scyoc::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyOg: // global
           R1 = I64[(_scyoc::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyol_entry() //  [R1]
         { info_tbl: [(ccyOs,
                       label: sat_scyol_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyOs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyOt; else goto ccyOB;
       ccyOt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyOB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoc::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoc::I64, 0)) goto ccyOz; else goto ccyOr;
       ccyOr: // global
           if (%MO_S_Gt_W64(_scyoc::I64, 1)) goto ccyOz; else goto ccyOA;
       ccyOz: // global
           R2 = _scyoc::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyOA: // global
           R1 = I64[(_scyoc::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scyob_entry() //  [R1, R2]
         { info_tbl: [(ccyOF,
                       label: go_up_scyob_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyOF: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccyOJ; else goto ccyOI;
       ccyOJ: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyOI: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccyOD; else goto ccyOE;
       ccyOD: // global
           _scyo9::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyoi_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyo9::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyog_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyOE: // global
           I64[Hp - 80] = sat_scyol_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccyOL::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccyOL::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyom_entry() //  [R1]
         { info_tbl: [(ccyOM,
                       label: sat_scyom_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyOM: // global
           _scyom::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccyON; else goto ccyOO;
       ccyOO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccyOQ; else goto ccyOP;
       ccyOQ: // global
           HpAlloc = 24;
           goto ccyON;
       ccyON: // global
           R1 = _scyom::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyOP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyom::P64;
           _scynG::I64 = I64[_scyom::P64 + 24];
           _scyo9::I64 = _scynG::I64 - I64[_scyom::P64 + 16];
           I64[Hp - 16] = go_up_scyob_info;
           I64[Hp - 8] = _scyo9::I64;
           I64[Hp] = 0 - _scyo9::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scyob_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyo8_entry() //  [R1]
         { info_tbl: [(ccyP0,
                       label: sat_scyo8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyP0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyP1; else goto ccyP9;
       ccyP1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyP9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccyP7; else goto ccyOZ;
       ccyOZ: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccyP7; else goto ccyP8;
       ccyP7: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyP8: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoq_entry() //  [R1]
         { info_tbl: [(ccyPn,
                       label: sat_scyoq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyPn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyPo; else goto ccyPw;
       ccyPo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyPw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccyPu; else goto ccyPm;
       ccyPm: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccyPu; else goto ccyPv;
       ccyPu: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyPv: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoF_entry() //  [R1]
         { info_tbl: [(ccyQ3,
                       label: sat_scyoF_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyQ3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyQ4; else goto ccyQ5;
       ccyQ4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyQ5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scyoy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoD_entry() //  [R1]
         { info_tbl: [(ccyQf,
                       label: sat_scyoD_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyQf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyQg; else goto ccyQo;
       ccyQg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyQo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoz::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoz::I64, 0)) goto ccyQm; else goto ccyQe;
       ccyQe: // global
           if (%MO_S_Gt_W64(_scyoz::I64, 1)) goto ccyQm; else goto ccyQn;
       ccyQm: // global
           R2 = _scyoz::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyQn: // global
           R1 = I64[(_scyoz::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoI_entry() //  [R1]
         { info_tbl: [(ccyQz,
                       label: sat_scyoI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyQz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyQA; else goto ccyQI;
       ccyQA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyQI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoz::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoz::I64, 0)) goto ccyQG; else goto ccyQy;
       ccyQy: // global
           if (%MO_S_Gt_W64(_scyoz::I64, 1)) goto ccyQG; else goto ccyQH;
       ccyQG: // global
           R2 = _scyoz::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyQH: // global
           R1 = I64[(_scyoz::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scyoy_entry() //  [R1, R2]
         { info_tbl: [(ccyQM,
                       label: go_dn_scyoy_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyQM: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccyQQ; else goto ccyQP;
       ccyQQ: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyQP: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccyQK; else goto ccyQL;
       ccyQK: // global
           _scyow::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyoF_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyow::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyoD_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyQL: // global
           I64[Hp - 80] = sat_scyoI_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccyQS::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccyQS::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyoJ_entry() //  [R1]
         { info_tbl: [(ccyQT,
                       label: sat_scyoJ_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyQT: // global
           _scyoJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccyQU; else goto ccyQV;
       ccyQV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccyQX; else goto ccyQW;
       ccyQX: // global
           HpAlloc = 24;
           goto ccyQU;
       ccyQU: // global
           R1 = _scyoJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyQW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyoJ::P64;
           _scynG::I64 = I64[_scyoJ::P64 + 24];
           _scyow::I64 = _scynG::I64 - I64[_scyoJ::P64 + 16];
           I64[Hp - 16] = go_dn_scyoy_info;
           I64[Hp - 8] = _scyow::I64;
           I64[Hp] = 1 - _scyow::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scyoy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyov_entry() //  [R1]
         { info_tbl: [(ccyR7,
                       label: sat_scyov_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyR7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyR8; else goto ccyRg;
       ccyR8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyRg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccyRe; else goto ccyR6;
       ccyR6: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccyRe; else goto ccyRf;
       ccyRe: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyRf: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoN_entry() //  [R1]
         { info_tbl: [(ccyRu,
                       label: sat_scyoN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyRu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyRv; else goto ccyRD;
       ccyRv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyRD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccyRB; else goto ccyRt;
       ccyRt: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccyRB; else goto ccyRC;
       ccyRB: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyRC: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyp1_entry() //  [R1]
         { info_tbl: [(ccyS6,
                       label: sat_scyp1_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyS6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyS7; else goto ccyS8;
       ccyS7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyS8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scyoU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoZ_entry() //  [R1]
         { info_tbl: [(ccySi,
                       label: sat_scyoZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccySi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccySj; else goto ccySr;
       ccySj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccySr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoV::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoV::I64, 0)) goto ccySp; else goto ccySh;
       ccySh: // global
           if (%MO_S_Gt_W64(_scyoV::I64, 1)) goto ccySp; else goto ccySq;
       ccySp: // global
           R2 = _scyoV::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccySq: // global
           R1 = I64[(_scyoV::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyp4_entry() //  [R1]
         { info_tbl: [(ccySC,
                       label: sat_scyp4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccySC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccySD; else goto ccySL;
       ccySD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccySL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoV::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoV::I64, 0)) goto ccySJ; else goto ccySB;
       ccySB: // global
           if (%MO_S_Gt_W64(_scyoV::I64, 1)) goto ccySJ; else goto ccySK;
       ccySJ: // global
           R2 = _scyoV::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccySK: // global
           R1 = I64[(_scyoV::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scyoU_entry() //  [R1, R2]
         { info_tbl: [(ccySP,
                       label: go_up_scyoU_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccySP: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccyST; else goto ccySS;
       ccyST: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccySS: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccySN; else goto ccySO;
       ccySN: // global
           _scyoS::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyp1_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyoS::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyoZ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccySO: // global
           I64[Hp - 80] = sat_scyp4_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccySV::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccySV::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyp5_entry() //  [R1]
         { info_tbl: [(ccySW,
                       label: sat_scyp5_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccySW: // global
           _scyp5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccySX; else goto ccySY;
       ccySY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccyT0; else goto ccySZ;
       ccyT0: // global
           HpAlloc = 24;
           goto ccySX;
       ccySX: // global
           R1 = _scyp5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccySZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyp5::P64;
           _scynG::I64 = I64[_scyp5::P64 + 24];
           _scyoS::I64 = _scynG::I64 - I64[_scyp5::P64 + 16];
           I64[Hp - 16] = go_up_scyoU_info;
           I64[Hp - 8] = _scyoS::I64;
           I64[Hp] = 1 - _scyoS::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scyoU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoR_entry() //  [R1]
         { info_tbl: [(ccyTa,
                       label: sat_scyoR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyTa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyTb; else goto ccyTj;
       ccyTb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyTj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccyTh; else goto ccyT9;
       ccyT9: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccyTh; else goto ccyTi;
       ccyTh: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyTi: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyp9_entry() //  [R1]
         { info_tbl: [(ccyTx,
                       label: sat_scyp9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyTx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyTy; else goto ccyTG;
       ccyTy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyTG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccyTE; else goto ccyTw;
       ccyTw: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccyTE; else goto ccyTF;
       ccyTE: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccyTF: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(ccyTO,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyTO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccyTP; else goto ccyTQ;
       ccyTP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyTQ: // global
           I64[Sp - 24] = block_ccyTH_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucyUZ; else goto ccyTI;
       ucyUZ: // global
           call _ccyTH(R1) args: 0, res: 0, upd: 0;
       ccyTI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyTH() //  [R1]
         { info_tbl: [(ccyTH,
                       label: block_ccyTH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyTH: // global
           _scynB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyTL; else goto ccyTM;
       ccyTL: // global
           _scynE::I64 = 0;
           goto scynD;
       ccyTM: // global
           _scynE::I64 = 1;
           goto scynD;
       scynD: // global
           I64[Sp] = block_ccyTR_info;
           R1 = _scynB::P64;
           I64[Sp + 8] = _scynE::I64;
           if (R1 & 7 != 0) goto ucyUY; else goto ccyUF;
       ucyUY: // global
           call _ccyTR(R1) args: 0, res: 0, upd: 0;
       ccyUF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyTR() //  [R1]
         { info_tbl: [(ccyTR,
                       label: block_ccyTR_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyTR: // global
           _scynC::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccyUL; else goto ccyUP;
       ccyUL: // global
           _scynG::I64 = 0;
           goto scynF;
       ccyUP: // global
           _scynG::I64 = 1;
           goto scynF;
       scynF: // global
           I64[Sp] = block_ccyLk_info;
           R1 = _scynC::P64;
           I64[Sp + 16] = _scynG::I64;
           if (R1 & 7 != 0) goto ucyV0; else goto ccyLl;
       ucyV0: // global
           call _ccyLk(R1) args: 0, res: 0, upd: 0;
       ccyLl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyLk() //  [R1]
         { info_tbl: [(ccyLk,
                       label: block_ccyLk_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyLk: // global
           _scynE::I64 = I64[Sp + 8];
           _scynG::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto ccyTV; else goto ccyUi;
       ccyTV: // global
           Hp = Hp + 80;
           _scynH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccyUl; else goto ccyTX;
       ccyTX: // global
           if (%MO_S_Lt_W64(_scynG::I64,
                            _scynE::I64)) goto ccyU8; else goto ccyUh;
       ccyU8: // global
           if (%MO_S_Le_W64(0, _scynG::I64)) goto ccyU1; else goto ccyU6;
       ccyU1: // global
           I64[Hp - 72] = sat_scyo0_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scynM_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyU6: // global
           if (%MO_S_Gt_W64(0, _scynE::I64)) goto ccyUC; else goto ccyU4;
       ccyU4: // global
           I64[Hp - 72] = sat_scyo4_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccyU2::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccyU2::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyUh: // global
           if (%MO_S_Ge_W64(0, _scynG::I64)) goto ccyUb; else goto ccyUg;
       ccyUb: // global
           I64[Hp - 72] = sat_scyom_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scyo8_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyUg: // global
           if (%MO_S_Lt_W64(0, _scynE::I64)) goto ccyUC; else goto ccyUe;
       ccyUe: // global
           I64[Hp - 72] = sat_scyoq_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccyUc::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccyUc::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyUi: // global
           Hp = Hp + 80;
           _scynH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccyUl; else goto ccyUk;
       ccyUl: // global
           HpAlloc = 80;
           R1 = _scynH::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccyUk: // global
           if (%MO_S_Lt_W64(_scynG::I64,
                            _scynE::I64)) goto ccyUv; else goto ccyUE;
       ccyUv: // global
           if (%MO_S_Le_W64(1, _scynG::I64)) goto ccyUo; else goto ccyUt;
       ccyUo: // global
           I64[Hp - 72] = sat_scyoJ_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scyov_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyUt: // global
           if (%MO_S_Gt_W64(1, _scynE::I64)) goto ccyUC; else goto ccyUr;
       ccyUr: // global
           I64[Hp - 72] = sat_scyoN_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccyUp::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccyUp::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyUE: // global
           if (%MO_S_Ge_W64(1, _scynG::I64)) goto ccyUy; else goto ccyUD;
       ccyUy: // global
           I64[Hp - 72] = sat_scyp5_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scyoR_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyUD: // global
           if (%MO_S_Lt_W64(1, _scynE::I64)) goto ccyUC; else goto ccyUB;
       ccyUC: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyUB: // global
           I64[Hp - 72] = sat_scyp9_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccyUz::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccyUz::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.294755531 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_closure" {
     GHC.ByteOrder.$fEnumByteOrder_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure+2;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure+2;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.295486203 UTC

[section ""data" . GHC.ByteOrder.$trModule3_closure" {
     GHC.ByteOrder.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.296132903 UTC

[section ""data" . GHC.ByteOrder.$trModule1_closure" {
     GHC.ByteOrder.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.296777228 UTC

[section ""data" . GHC.ByteOrder.$trModule_closure" {
     GHC.ByteOrder.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.ByteOrder.$trModule3_closure+1;
         const GHC.ByteOrder.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.297425502 UTC

[section ""cstring" . GHC.ByteOrder.$tcByteOrder2_bytes" {
     GHC.ByteOrder.$tcByteOrder2_bytes:
         I8[] [66,121,116,101,79,114,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.297986114 UTC

[section ""data" . GHC.ByteOrder.$tcByteOrder1_closure" {
     GHC.ByteOrder.$tcByteOrder1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tcByteOrder2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.298613686 UTC

[section ""data" . GHC.ByteOrder.$tcByteOrder_closure" {
     GHC.ByteOrder.$tcByteOrder_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tcByteOrder1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16811050684449662084;
         const 17273005335247024091;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.299262604 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian1_closure" {
     GHC.ByteOrder.$tc'BigEndian1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ByteOrder.$tcByteOrder_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.299870635 UTC

[section ""cstring" . GHC.ByteOrder.$tc'BigEndian3_bytes" {
     GHC.ByteOrder.$tc'BigEndian3_bytes:
         I8[] [39,66,105,103,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.301944969 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian2_closure" {
     GHC.ByteOrder.$tc'BigEndian2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tc'BigEndian3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.302513052 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian_closure" {
     GHC.ByteOrder.$tc'BigEndian_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tc'BigEndian2_closure+1;
         const GHC.ByteOrder.$tc'BigEndian1_closure+1;
         const 2645192688778293591;
         const 7455668807059762078;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.303126252 UTC

[section ""cstring" . GHC.ByteOrder.$tc'LittleEndian2_bytes" {
     GHC.ByteOrder.$tc'LittleEndian2_bytes:
         I8[] [39,76,105,116,116,108,101,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.303687908 UTC

[section ""data" . GHC.ByteOrder.$tc'LittleEndian1_closure" {
     GHC.ByteOrder.$tc'LittleEndian1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tc'LittleEndian2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.304238032 UTC

[section ""data" . GHC.ByteOrder.$tc'LittleEndian_closure" {
     GHC.ByteOrder.$tc'LittleEndian_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tc'LittleEndian1_closure+1;
         const GHC.ByteOrder.$tc'BigEndian1_closure+1;
         const 8702700204875460152;
         const 10337679016369298147;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.304859939 UTC

[section ""data" . GHC.ByteOrder.BigEndian_closure" {
     GHC.ByteOrder.BigEndian_closure:
         const GHC.ByteOrder.BigEndian_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.305447064 UTC

[section ""data" . GHC.ByteOrder.LittleEndian_closure" {
     GHC.ByteOrder.LittleEndian_closure:
         const GHC.ByteOrder.LittleEndian_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.305984878 UTC

[section ""relreadonly" . GHC.ByteOrder.ByteOrder_closure_tbl" {
     GHC.ByteOrder.ByteOrder_closure_tbl:
         const GHC.ByteOrder.BigEndian_closure+1;
         const GHC.ByteOrder.LittleEndian_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.3066569 UTC

[GHC.ByteOrder.BigEndian_con_entry() //  [R1]
         { info_tbl: [(ccyV1,
                       label: GHC.ByteOrder.BigEndian_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,121,116,101,79,114,100,101,114,46,66,105,103,69,110,100,105,97,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyV1: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.307382096 UTC

[GHC.ByteOrder.LittleEndian_con_entry() //  [R1]
         { info_tbl: [(ccyV2,
                       label: GHC.ByteOrder.LittleEndian_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,66,121,116,101,79,114,100,101,114,46,76,105,116,116,108,101,69,110,100,105,97,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyV2: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.308027007 UTC

[section ""relreadonly" . ScypP_srt" {
     ScypP_srt:
         const GHC.ByteOrder.$fReadByteOrder6_closure;
         const GHC.ByteOrder.$fReadByteOrder10_closure;
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure;
         const GHC.ByteOrder.$fShowByteOrder_$cshow_closure;
         const GHC.ByteOrder.$fShowByteOrder1_closure;
         const GHC.Read.choose2_closure;
         const GHC.ByteOrder.$fReadByteOrder_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.ByteOrder.$fReadByteOrder2_closure;
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.ByteOrder.$fReadByteOrder1_closure;
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
         const GHC.ByteOrder.$fReadByteOrder12_closure;
         const GHC.Err.error_closure;
         const lvl12_rcykz_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_closure;
         const GHC.ByteOrder.$fEnumByteOrder3_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_closure;
         const GHC.ByteOrder.$fEnumByteOrder4_closure;
         const lvl17_rcykE_closure;
         const lvl18_rcykF_closure;
         const lvl19_rcykG_closure;
         const GHC.ByteOrder.$wlvl_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure;
         const GHC.ByteOrder.$w$ctoEnum_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure;
         const GHC.ByteOrder.$fEnumByteOrder1_closure;
         const GHC.ByteOrder.$fEnumByteOrder2_closure;
         const GHC.ByteOrder.$fEnumByteOrder_go1_closure;
         const GHC.ByteOrder.$fEnumByteOrder_go_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.308760293 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:27.309325995 UTC

[section ""cstring" . GHC.ByteOrder.$fReadByteOrder11_bytes" {
     GHC.ByteOrder.$fReadByteOrder11_bytes:
         I8[] [66,105,103,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.31011978 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder10_closure" {
     GHC.ByteOrder.$fReadByteOrder10_closure:
         const GHC.ByteOrder.$fReadByteOrder10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder10_entry() //  [R1]
         { info_tbl: [(ccyV9,
                       label: GHC.ByteOrder.$fReadByteOrder10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyV9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyVa; else goto ccyVb;
       ccyVa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyVb: // global
           (_ccyV6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyV6::I64 == 0) goto ccyV8; else goto ccyV7;
       ccyV8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyV7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyV6::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.310999957 UTC

[section ""cstring" . GHC.ByteOrder.$fReadByteOrder7_bytes" {
     GHC.ByteOrder.$fReadByteOrder7_bytes:
         I8[] [76,105,116,116,108,101,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.311728787 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder6_closure" {
     GHC.ByteOrder.$fReadByteOrder6_closure:
         const GHC.ByteOrder.$fReadByteOrder6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder6_entry() //  [R1]
         { info_tbl: [(ccyVi,
                       label: GHC.ByteOrder.$fReadByteOrder6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyVi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyVj; else goto ccyVk;
       ccyVj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyVk: // global
           (_ccyVf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyVf::I64 == 0) goto ccyVh; else goto ccyVg;
       ccyVh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyVg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyVf::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.312968643 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(ccyVw,
                       label: GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyVw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyVx; else goto ccyVy;
       ccyVx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyVy: // global
           I64[Sp - 16] = block_ccyVp_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucyVF; else goto ccyVq;
       ucyVF: // global
           call _ccyVp(R1) args: 0, res: 0, upd: 0;
       ccyVq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyVp() //  [R1]
         { info_tbl: [(ccyVp,
                       label: block_ccyVp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyVp: // global
           _scykL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyVt; else goto ccyVu;
       ccyVt: // global
           R3 = _scykL::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccyVu: // global
           R3 = _scykL::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.314578016 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshow_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshow_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshow_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshow_entry() //  [R2]
         { info_tbl: [(ccyVR,
                       label: GHC.ByteOrder.$fShowByteOrder_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyVR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccyVS; else goto ccyVT;
       ccyVS: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyVT: // global
           I64[Sp - 8] = block_ccyVK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucyW0; else goto ccyVL;
       ucyW0: // global
           call _ccyVK(R1) args: 0, res: 0, upd: 0;
       ccyVL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyVK() //  [R1]
         { info_tbl: [(ccyVK,
                       label: block_ccyVK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyVK: // global
           if (R1 & 7 == 1) goto ccyVO; else goto ccyVP;
       ccyVO: // global
           R1 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccyVP: // global
           R1 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.315888913 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder1_closure" {
     GHC.ByteOrder.$fShowByteOrder1_closure:
         const GHC.ByteOrder.$fShowByteOrder1_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder1_entry() //  [R2, R3]
         { info_tbl: [(ccyWc,
                       label: GHC.ByteOrder.$fShowByteOrder1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyWc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyWd; else goto ccyWe;
       ccyWd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyWe: // global
           I64[Sp - 16] = block_ccyW5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucyWl; else goto ccyW6;
       ucyWl: // global
           call _ccyW5(R1) args: 0, res: 0, upd: 0;
       ccyW6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyW5() //  [R1]
         { info_tbl: [(ccyW5,
                       label: block_ccyW5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyW5: // global
           _scykQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyW9; else goto ccyWa;
       ccyW9: // global
           R3 = _scykQ::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccyWa: // global
           R3 = _scykQ::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.317121335 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshowList_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshowList_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(ccyWq,
                       label: GHC.ByteOrder.$fShowByteOrder_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyWq: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.ByteOrder.$fShowByteOrder1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.317920152 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_closure" {
     GHC.ByteOrder.$fShowByteOrder_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure+3;
         const GHC.ByteOrder.$fShowByteOrder_$cshow_closure+1;
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.318648688 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder9_closure" {
     GHC.ByteOrder.$fReadByteOrder9_closure:
         const GHC.ByteOrder.$fReadByteOrder9_info;
 },
 GHC.ByteOrder.$fReadByteOrder9_entry() //  [R3]
         { info_tbl: [(ccyWx,
                       label: GHC.ByteOrder.$fReadByteOrder9_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyWx: // global
           R2 = GHC.ByteOrder.BigEndian_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.319369763 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder8_closure" {
     GHC.ByteOrder.$fReadByteOrder8_closure:
         const (,)_con_info;
         const GHC.ByteOrder.$fReadByteOrder10_closure;
         const GHC.ByteOrder.$fReadByteOrder9_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.320081276 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder5_closure" {
     GHC.ByteOrder.$fReadByteOrder5_closure:
         const GHC.ByteOrder.$fReadByteOrder5_info;
 },
 GHC.ByteOrder.$fReadByteOrder5_entry() //  [R3]
         { info_tbl: [(ccyWE,
                       label: GHC.ByteOrder.$fReadByteOrder5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyWE: // global
           R2 = GHC.ByteOrder.LittleEndian_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.320815308 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder4_closure" {
     GHC.ByteOrder.$fReadByteOrder4_closure:
         const (,)_con_info;
         const GHC.ByteOrder.$fReadByteOrder6_closure;
         const GHC.ByteOrder.$fReadByteOrder5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.321451613 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder3_closure" {
     GHC.ByteOrder.$fReadByteOrder3_closure:
         const :_con_info;
         const GHC.ByteOrder.$fReadByteOrder4_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.322015537 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_sps_closure" {
     GHC.ByteOrder.$fReadByteOrder_sps_closure:
         const :_con_info;
         const GHC.ByteOrder.$fReadByteOrder8_closure+1;
         const GHC.ByteOrder.$fReadByteOrder3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.322705653 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder2_closure" {
     GHC.ByteOrder.$fReadByteOrder2_closure:
         const GHC.ByteOrder.$fReadByteOrder2_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder2_entry() //  [R2]
         { info_tbl: [(ccyWL,
                       label: GHC.ByteOrder.$fReadByteOrder2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyWL: // global
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.323572156 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder1_closure" {
     GHC.ByteOrder.$fReadByteOrder1_closure:
         const GHC.ByteOrder.$fReadByteOrder1_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder1_entry() //  [R2, R3]
         { info_tbl: [(ccyWS,
                       label: GHC.ByteOrder.$fReadByteOrder1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyWS: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.324596098 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info;
         const 0;
 },
 sat_scyl0_entry() //  [R1]
         { info_tbl: [(ccyX3,
                       label: sat_scyl0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyX3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyX4; else goto ccyX5;
       ccyX4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyX5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.ByteOrder.$fReadByteOrder2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fReadByteOrder_$creadsPrec_entry() //  [R2]
         { info_tbl: [(ccyX6,
                       label: GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyX6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccyXa; else goto ccyX9;
       ccyXa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccyX9: // global
           I64[Hp - 16] = sat_scyl0_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.326333292 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadListPrec_entry() //  [R1]
         { info_tbl: [(ccyXh,
                       label: GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyXh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyXi; else goto ccyXj;
       ccyXi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyXj: // global
           (_ccyXe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyXe::I64 == 0) goto ccyXg; else goto ccyXf;
       ccyXg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyXf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyXe::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.32743075 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder12_closure" {
     GHC.ByteOrder.$fReadByteOrder12_closure:
         const GHC.ByteOrder.$fReadByteOrder12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder12_entry() //  [R1]
         { info_tbl: [(ccyXq,
                       label: GHC.ByteOrder.$fReadByteOrder12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyXq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyXr; else goto ccyXs;
       ccyXr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccyXs: // global
           (_ccyXn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccyXn::I64 == 0) goto ccyXp; else goto ccyXo;
       ccyXp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccyXo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccyXn::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.328442358 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadList_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadList_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadList_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadList_entry() //  [R2]
         { info_tbl: [(ccyXx,
                       label: GHC.ByteOrder.$fReadByteOrder_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyXx: // global
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.329216719 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_closure" {
     GHC.ByteOrder.$fReadByteOrder_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure+1;
         const GHC.ByteOrder.$fReadByteOrder_$creadList_closure+1;
         const GHC.ByteOrder.$fReadByteOrder1_closure+2;
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.329892077 UTC

[section ""data" . GHC.ByteOrder.$fBoundedByteOrder_closure" {
     GHC.ByteOrder.$fBoundedByteOrder_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.ByteOrder.BigEndian_closure+1;
         const GHC.ByteOrder.LittleEndian_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.330867768 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c<_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c<_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c<_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c<_entry() //  [R2, R3]
         { info_tbl: [(ccyXL,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyXL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyXM; else goto ccyXN;
       ccyXM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyXN: // global
           I64[Sp - 16] = block_ccyXE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucyYf; else goto ccyXF;
       ucyYf: // global
           call _ccyXE(R1) args: 0, res: 0, upd: 0;
       ccyXF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyXE() //  [R1]
         { info_tbl: [(ccyXE,
                       label: block_ccyXE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyXE: // global
           _scyl2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyXI; else goto ccyXJ;
       ccyXI: // global
           I64[Sp + 8] = block_ccyXQ_info;
           R1 = _scyl2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyYd; else goto ccyXS;
       ucyYd: // global
           call _ccyXQ(R1) args: 0, res: 0, upd: 0;
       ccyXS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccyXJ: // global
           I64[Sp + 8] = block_ccyY5_info;
           R1 = _scyl2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyYe; else goto ccyY7;
       ucyYe: // global
           call _ccyY5() args: 0, res: 0, upd: 0;
       ccyY7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyXQ() //  [R1]
         { info_tbl: [(ccyXQ,
                       label: block_ccyXQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyXQ: // global
           if (R1 & 7 == 1) goto ccyXY; else goto ccyY2;
       ccyXY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccyY2: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccyY5() //  []
         { info_tbl: [(ccyY5,
                       label: block_ccyY5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyY5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.332959995 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(ccyYr,
                       label: GHC.ByteOrder.$fOrdByteOrder_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyYr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyYs; else goto ccyYt;
       ccyYs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyYt: // global
           I64[Sp - 16] = block_ccyYk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucyZ4; else goto ccyYl;
       ucyZ4: // global
           call _ccyYk(R1) args: 0, res: 0, upd: 0;
       ccyYl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyYk() //  [R1]
         { info_tbl: [(ccyYk,
                       label: block_ccyYk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyYk: // global
           _scyl7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyYo; else goto ccyYp;
       ccyYo: // global
           I64[Sp + 8] = block_ccyYw_info;
           R1 = _scyl7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyZ2; else goto ccyYy;
       ucyZ2: // global
           call _ccyYw(R1) args: 0, res: 0, upd: 0;
       ccyYy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccyYp: // global
           I64[Sp + 8] = block_ccyYL_info;
           R1 = _scyl7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyZ3; else goto ccyYN;
       ucyZ3: // global
           call _ccyYL(R1) args: 0, res: 0, upd: 0;
       ccyYN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyYw() //  [R1]
         { info_tbl: [(ccyYw,
                       label: block_ccyYw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyYw: // global
           if (R1 & 7 == 1) goto ucyZ1; else goto ccyYI;
       ucyZ1: // global
           Sp = Sp + 8;
           call _ccyYX() args: 0, res: 0, upd: 0;
       ccyYI: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccyYL() //  [R1]
         { info_tbl: [(ccyYL,
                       label: block_ccyYL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyYL: // global
           if (R1 & 7 == 1) goto ccyYT; else goto ucyZ0;
       ccyYT: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ucyZ0: // global
           Sp = Sp + 8;
           call _ccyYX() args: 0, res: 0, upd: 0;
     }
 },
 _ccyYX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyYX: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.33521657 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_$c==_closure" {
     GHC.ByteOrder.$fEqByteOrder_$c==_closure:
         const GHC.ByteOrder.$fEqByteOrder_$c==_info;
 },
 GHC.ByteOrder.$fEqByteOrder_$c==_entry() //  [R2, R3]
         { info_tbl: [(ccyZi,
                       label: GHC.ByteOrder.$fEqByteOrder_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyZi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccyZj; else goto ccyZk;
       ccyZj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEqByteOrder_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccyZk: // global
           I64[Sp - 16] = block_ccyZb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucyZX; else goto ccyZc;
       ucyZX: // global
           call _ccyZb(R1) args: 0, res: 0, upd: 0;
       ccyZc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyZb() //  [R1]
         { info_tbl: [(ccyZb,
                       label: block_ccyZb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyZb: // global
           _scylc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccyZf; else goto ccyZg;
       ccyZf: // global
           I64[Sp + 8] = block_ccyZn_info;
           R1 = _scylc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyZV; else goto ccyZp;
       ucyZV: // global
           call _ccyZn(R1) args: 0, res: 0, upd: 0;
       ccyZp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccyZg: // global
           I64[Sp + 8] = block_ccyZC_info;
           R1 = _scylc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucyZW; else goto ccyZE;
       ucyZW: // global
           call _ccyZC(R1) args: 0, res: 0, upd: 0;
       ccyZE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccyZn() //  [R1]
         { info_tbl: [(ccyZn,
                       label: block_ccyZn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyZn: // global
           if (R1 & 7 == 1) goto ucyZT; else goto ucyZU;
       ucyZT: // global
           Sp = Sp + 8;
           call _ccyZO() args: 0, res: 0, upd: 0;
       ucyZU: // global
           Sp = Sp + 8;
           call _ccyZK() args: 0, res: 0, upd: 0;
     }
 },
 _ccyZC() //  [R1]
         { info_tbl: [(ccyZC,
                       label: block_ccyZC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyZC: // global
           if (R1 & 7 == 1) goto ucyZR; else goto ucyZS;
       ucyZR: // global
           Sp = Sp + 8;
           call _ccyZK() args: 0, res: 0, upd: 0;
       ucyZS: // global
           Sp = Sp + 8;
           call _ccyZO() args: 0, res: 0, upd: 0;
     }
 },
 _ccyZK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyZK: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccyZO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccyZO: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.338515843 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_$c/=_closure" {
     GHC.ByteOrder.$fEqByteOrder_$c/=_closure:
         const GHC.ByteOrder.$fEqByteOrder_$c/=_info;
 },
 GHC.ByteOrder.$fEqByteOrder_$c/=_entry() //  [R2, R3]
         { info_tbl: [(ccz0d,
                       label: GHC.ByteOrder.$fEqByteOrder_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz0d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz0e; else goto ccz0f;
       ccz0e: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEqByteOrder_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccz0f: // global
           I64[Sp - 16] = block_ccz06_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucz0S; else goto ccz07;
       ucz0S: // global
           call _ccz06(R1) args: 0, res: 0, upd: 0;
       ccz07: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz06() //  [R1]
         { info_tbl: [(ccz06,
                       label: block_ccz06_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz06: // global
           _scylh::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccz0a; else goto ccz0b;
       ccz0a: // global
           I64[Sp + 8] = block_ccz0i_info;
           R1 = _scylh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucz0Q; else goto ccz0k;
       ucz0Q: // global
           call _ccz0i(R1) args: 0, res: 0, upd: 0;
       ccz0k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccz0b: // global
           I64[Sp + 8] = block_ccz0x_info;
           R1 = _scylh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucz0R; else goto ccz0z;
       ucz0R: // global
           call _ccz0x(R1) args: 0, res: 0, upd: 0;
       ccz0z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz0i() //  [R1]
         { info_tbl: [(ccz0i,
                       label: block_ccz0i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz0i: // global
           if (R1 & 7 == 1) goto ucz0O; else goto ucz0P;
       ucz0O: // global
           Sp = Sp + 8;
           call _ccz0J() args: 0, res: 0, upd: 0;
       ucz0P: // global
           Sp = Sp + 8;
           call _ccz0F() args: 0, res: 0, upd: 0;
     }
 },
 _ccz0x() //  [R1]
         { info_tbl: [(ccz0x,
                       label: block_ccz0x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz0x: // global
           if (R1 & 7 == 1) goto ucz0M; else goto ucz0N;
       ucz0M: // global
           Sp = Sp + 8;
           call _ccz0F() args: 0, res: 0, upd: 0;
       ucz0N: // global
           Sp = Sp + 8;
           call _ccz0J() args: 0, res: 0, upd: 0;
     }
 },
 _ccz0F() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz0F: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccz0J() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz0J: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.340157732 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_closure" {
     GHC.ByteOrder.$fEqByteOrder_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.ByteOrder.$fEqByteOrder_$c==_closure+2;
         const GHC.ByteOrder.$fEqByteOrder_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.341156681 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c<=_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c<=_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c<=_entry() //  [R2, R3]
         { info_tbl: [(ccz18,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz18: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz19; else goto ccz1a;
       ccz19: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccz1a: // global
           I64[Sp - 16] = block_ccz11_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucz1C; else goto ccz12;
       ucz1C: // global
           call _ccz11(R1) args: 0, res: 0, upd: 0;
       ccz12: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz11() //  [R1]
         { info_tbl: [(ccz11,
                       label: block_ccz11_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz11: // global
           _scyll::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccz15; else goto ccz16;
       ccz15: // global
           I64[Sp + 8] = block_ccz1d_info;
           R1 = _scyll::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucz1A; else goto ccz1f;
       ucz1A: // global
           call _ccz1d(R1) args: 0, res: 0, upd: 0;
       ccz1f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccz16: // global
           I64[Sp + 8] = block_ccz1s_info;
           R1 = _scyll::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucz1B; else goto ccz1u;
       ucz1B: // global
           call _ccz1s() args: 0, res: 0, upd: 0;
       ccz1u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz1d() //  [R1]
         { info_tbl: [(ccz1d,
                       label: block_ccz1d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz1d: // global
           if (R1 & 7 == 1) goto ccz1l; else goto ccz1p;
       ccz1l: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccz1p: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccz1s() //  []
         { info_tbl: [(ccz1s,
                       label: block_ccz1s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz1s: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.342961533 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$cmax_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$cmax_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$cmax_entry() //  [R2, R3]
         { info_tbl: [(ccz1O,
                       label: GHC.ByteOrder.$fOrdByteOrder_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz1O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz1P; else goto ccz1Q;
       ccz1P: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccz1Q: // global
           I64[Sp - 16] = block_ccz1H_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucz24; else goto ccz1I;
       ucz24: // global
           call _ccz1H(R1) args: 0, res: 0, upd: 0;
       ccz1I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz1H() //  [R1]
         { info_tbl: [(ccz1H,
                       label: block_ccz1H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz1H: // global
           _scylq::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccz1L; else goto ccz1M;
       ccz1L: // global
           R1 = _scylq::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccz1M: // global
           I64[Sp + 8] = block_ccz1W_info;
           R1 = _scylq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucz23; else goto ccz1Y;
       ucz23: // global
           call _ccz1W() args: 0, res: 0, upd: 0;
       ccz1Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz1W() //  []
         { info_tbl: [(ccz1W,
                       label: block_ccz1W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz1W: // global
           R1 = GHC.ByteOrder.LittleEndian_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.344583343 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c>=_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c>=_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c>=_entry() //  [R2, R3]
         { info_tbl: [(ccz2g,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz2g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz2h; else goto ccz2i;
       ccz2h: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccz2i: // global
           I64[Sp - 16] = block_ccz29_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucz2K; else goto ccz2a;
       ucz2K: // global
           call _ccz29(R1) args: 0, res: 0, upd: 0;
       ccz2a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz29() //  [R1]
         { info_tbl: [(ccz29,
                       label: block_ccz29_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz29: // global
           _scylv::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccz2d; else goto ccz2e;
       ccz2d: // global
           I64[Sp + 8] = block_ccz2l_info;
           R1 = _scylv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucz2I; else goto ccz2n;
       ucz2I: // global
           call _ccz2l(R1) args: 0, res: 0, upd: 0;
       ccz2n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccz2e: // global
           I64[Sp + 8] = block_ccz2A_info;
           R1 = _scylv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucz2J; else goto ccz2C;
       ucz2J: // global
           call _ccz2A() args: 0, res: 0, upd: 0;
       ccz2C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz2l() //  [R1]
         { info_tbl: [(ccz2l,
                       label: block_ccz2l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz2l: // global
           if (R1 & 7 == 1) goto ccz2t; else goto ccz2x;
       ccz2t: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccz2x: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccz2A() //  []
         { info_tbl: [(ccz2A,
                       label: block_ccz2A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz2A: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.346532457 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c>_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c>_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c>_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c>_entry() //  [R2, R3]
         { info_tbl: [(ccz2P,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz2P: // global
           _scylA::P64 = R3;
           R3 = R2;
           R2 = _scylA::P64;
           call GHC.ByteOrder.$fOrdByteOrder_$c<_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.347575687 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$cmin_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$cmin_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$cmin_entry() //  [R2, R3]
         { info_tbl: [(ccz33,
                       label: GHC.ByteOrder.$fOrdByteOrder_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz33: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz34; else goto ccz35;
       ccz34: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccz35: // global
           I64[Sp - 16] = block_ccz2W_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucz3j; else goto ccz2X;
       ucz3j: // global
           call _ccz2W(R1) args: 0, res: 0, upd: 0;
       ccz2X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz2W() //  [R1]
         { info_tbl: [(ccz2W,
                       label: block_ccz2W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz2W: // global
           _scylB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccz30; else goto ccz31;
       ccz30: // global
           I64[Sp + 8] = block_ccz38_info;
           R1 = _scylB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucz3i; else goto ccz3a;
       ucz3i: // global
           call _ccz38() args: 0, res: 0, upd: 0;
       ccz3a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccz31: // global
           R1 = _scylB::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccz38() //  []
         { info_tbl: [(ccz38,
                       label: block_ccz38_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz38: // global
           R1 = GHC.ByteOrder.BigEndian_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.348853925 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_closure" {
     GHC.ByteOrder.$fOrdByteOrder_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.ByteOrder.$fEqByteOrder_closure+1;
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c<_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c>_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.349462495 UTC

[section ""data" . GHC.ByteOrder.targetByteOrder_closure" {
     GHC.ByteOrder.targetByteOrder_closure:
         const GHC.ByteOrder.LittleEndian_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.350023181 UTC

[section ""data" . lvl_rcykn_closure" {
     lvl_rcykn_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.350561826 UTC

[section ""data" . lvl1_rcyko_closure" {
     lvl1_rcyko_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.35140588 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_entry() //  [R2]
         { info_tbl: [(ccz3v,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz3v: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccz3w; else goto ccz3x;
       ccz3w: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccz3x: // global
           I64[Sp - 8] = block_ccz3o_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucz3E; else goto ccz3p;
       ucz3E: // global
           call _ccz3o(R1) args: 0, res: 0, upd: 0;
       ccz3p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz3o() //  [R1]
         { info_tbl: [(ccz3o,
                       label: block_ccz3o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz3o: // global
           if (R1 & 7 == 1) goto ccz3s; else goto ccz3t;
       ccz3s: // global
           R1 = lvl_rcykn_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccz3t: // global
           R1 = lvl1_rcyko_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.352451163 UTC

[section ""cstring" . lvl2_rcykp_bytes" {
     lvl2_rcykp_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.353206258 UTC

[section ""data" . lvl3_rcykq_closure" {
     lvl3_rcykq_closure:
         const lvl3_rcykq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rcykq_entry() //  [R1]
         { info_tbl: [(ccz3L,
                       label: lvl3_rcykq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz3L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz3M; else goto ccz3N;
       ccz3M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz3N: // global
           (_ccz3I::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccz3I::I64 == 0) goto ccz3K; else goto ccz3J;
       ccz3K: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccz3J: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccz3I::I64;
           R2 = lvl2_rcykp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.354158174 UTC

[section ""cstring" . GHC.ByteOrder.$trModule4_bytes" {
     GHC.ByteOrder.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.354884775 UTC

[section ""data" . lvl4_rcykr_closure" {
     lvl4_rcykr_closure:
         const lvl4_rcykr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rcykr_entry() //  [R1]
         { info_tbl: [(ccz3U,
                       label: lvl4_rcykr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz3U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz3V; else goto ccz3W;
       ccz3V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz3W: // global
           (_ccz3R::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccz3R::I64 == 0) goto ccz3T; else goto ccz3S;
       ccz3T: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccz3S: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccz3R::I64;
           R2 = GHC.ByteOrder.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.355806633 UTC

[section ""cstring" . GHC.ByteOrder.$trModule2_bytes" {
     GHC.ByteOrder.$trModule2_bytes:
         I8[] [71,72,67,46,66,121,116,101,79,114,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.356546322 UTC

[section ""data" . lvl5_rcyks_closure" {
     lvl5_rcyks_closure:
         const lvl5_rcyks_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rcyks_entry() //  [R1]
         { info_tbl: [(ccz43,
                       label: lvl5_rcyks_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz43: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz44; else goto ccz45;
       ccz44: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz45: // global
           (_ccz40::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccz40::I64 == 0) goto ccz42; else goto ccz41;
       ccz42: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccz41: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccz40::I64;
           R2 = GHC.ByteOrder.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.357511185 UTC

[section ""cstring" . lvl6_rcykt_bytes" {
     lvl6_rcykt_bytes:
         I8[] [46,47,71,72,67,47,66,121,116,101,79,114,100,101,114,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.358216279 UTC

[section ""data" . lvl7_rcyku_closure" {
     lvl7_rcyku_closure:
         const lvl7_rcyku_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rcyku_entry() //  [R1]
         { info_tbl: [(ccz4c,
                       label: lvl7_rcyku_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz4c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz4d; else goto ccz4e;
       ccz4d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz4e: // global
           (_ccz49::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccz49::I64 == 0) goto ccz4b; else goto ccz4a;
       ccz4b: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccz4a: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccz49::I64;
           R2 = lvl6_rcykt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.35918745 UTC

[section ""data" . lvl8_rcykv_closure" {
     lvl8_rcykv_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.359761193 UTC

[section ""data" . lvl9_rcykw_closure" {
     lvl9_rcykw_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.360334705 UTC

[section ""data" . lvl10_rcykx_closure" {
     lvl10_rcykx_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.360949122 UTC

[section ""data" . lvl11_rcyky_closure" {
     lvl11_rcyky_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl4_rcykr_closure;
         const lvl5_rcyks_closure;
         const lvl7_rcyku_closure;
         const lvl8_rcykv_closure+1;
         const lvl9_rcykw_closure+1;
         const lvl8_rcykv_closure+1;
         const lvl10_rcykx_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.361629221 UTC

[section ""data" . lvl12_rcykz_closure" {
     lvl12_rcykz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl3_rcykq_closure;
         const lvl11_rcyky_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.362265381 UTC

[section ""cstring" . lvl13_rcykA_bytes" {
     lvl13_rcykA_bytes:
         I8[] [112,114,101,100,123,66,121,116,101,79,114,100,101,114,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,112,114,101,100,39,32,111,102,32,102,105,114,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.363067978 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder3_closure" {
     GHC.ByteOrder.$fEnumByteOrder3_closure:
         const GHC.ByteOrder.$fEnumByteOrder3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder3_entry() //  [R1]
         { info_tbl: [(ccz4n,
                       label: GHC.ByteOrder.$fEnumByteOrder3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz4n: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccz4o; else goto ccz4p;
       ccz4o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz4p: // global
           (_ccz4i::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccz4i::I64 == 0) goto ccz4k; else goto ccz4j;
       ccz4k: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccz4j: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccz4i::I64;
           I64[Sp - 24] = block_ccz4l_info;
           R2 = lvl13_rcykA_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccz4l() //  [R1]
         { info_tbl: [(ccz4l,
                       label: block_ccz4l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz4l: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.364473907 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cpred_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cpred_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cpred_entry() //  [R2]
         { info_tbl: [(ccz4E,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz4E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccz4F; else goto ccz4G;
       ccz4F: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccz4G: // global
           I64[Sp - 8] = block_ccz4x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucz4N; else goto ccz4y;
       ucz4N: // global
           call _ccz4x(R1) args: 0, res: 0, upd: 0;
       ccz4y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz4x() //  [R1]
         { info_tbl: [(ccz4x,
                       label: block_ccz4x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz4x: // global
           if (R1 & 7 == 1) goto ccz4B; else goto ccz4C;
       ccz4B: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccz4C: // global
           R1 = GHC.ByteOrder.BigEndian_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.365940821 UTC

[section ""cstring" . lvl14_rcykB_bytes" {
     lvl14_rcykB_bytes:
         I8[] [115,117,99,99,123,66,121,116,101,79,114,100,101,114,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,115,117,99,99,39,32,111,102,32,108,97,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.366801003 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder4_closure" {
     GHC.ByteOrder.$fEnumByteOrder4_closure:
         const GHC.ByteOrder.$fEnumByteOrder4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder4_entry() //  [R1]
         { info_tbl: [(ccz4W,
                       label: GHC.ByteOrder.$fEnumByteOrder4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz4W: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccz4X; else goto ccz4Y;
       ccz4X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz4Y: // global
           (_ccz4R::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccz4R::I64 == 0) goto ccz4T; else goto ccz4S;
       ccz4T: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccz4S: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccz4R::I64;
           I64[Sp - 24] = block_ccz4U_info;
           R2 = lvl14_rcykB_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccz4U() //  [R1]
         { info_tbl: [(ccz4U,
                       label: block_ccz4U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz4U: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.368168589 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$csucc_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$csucc_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$csucc_entry() //  [R2]
         { info_tbl: [(ccz5d,
                       label: GHC.ByteOrder.$fEnumByteOrder_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz5d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccz5e; else goto ccz5f;
       ccz5e: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccz5f: // global
           I64[Sp - 8] = block_ccz56_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucz5m; else goto ccz57;
       ucz5m: // global
           call _ccz56(R1) args: 0, res: 0, upd: 0;
       ccz57: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz56() //  [R1]
         { info_tbl: [(ccz56,
                       label: block_ccz56_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz56: // global
           if (R1 & 7 == 1) goto ccz5a; else goto ccz5b;
       ccz5a: // global
           R1 = GHC.ByteOrder.LittleEndian_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccz5b: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.369283622 UTC

[section ""cstring" . lvl15_rcykC_bytes" {
     lvl15_rcykC_bytes:
         I8[] [41,32,105,115,32,111,117,116,115,105,100,101,32,111,102,32,101,110,117,109,101,114,97,116,105,111,110,39,115,32,114,97,110,103,101,32,40,48,44]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.36988993 UTC

[section ""cstring" . lvl16_rcykD_bytes" {
     lvl16_rcykD_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.371721989 UTC

[section ""data" . lvl17_rcykE_closure" {
     lvl17_rcykE_closure:
         const lvl17_rcykE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_rcykE_entry() //  [R1]
         { info_tbl: [(ccz5t,
                       label: lvl17_rcykE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz5t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz5u; else goto ccz5v;
       ccz5u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz5v: // global
           (_ccz5q::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccz5q::I64 == 0) goto ccz5s; else goto ccz5r;
       ccz5s: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccz5r: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccz5q::I64;
           R2 = lvl16_rcykD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.372959309 UTC

[section ""data" . lvl18_rcykF_closure" {
     lvl18_rcykF_closure:
         const lvl18_rcykF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_rcykF_entry() //  [R1]
         { info_tbl: [(ccz5F,
                       label: lvl18_rcykF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz5F: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccz5G; else goto ccz5H;
       ccz5G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz5H: // global
           (_ccz5z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccz5z::I64 == 0) goto ccz5B; else goto ccz5A;
       ccz5B: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccz5A: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccz5z::I64;
           I64[Sp - 24] = block_ccz5C_info;
           R4 = lvl17_rcykE_closure;
           R3 = 1;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccz5C() //  [R1, R2]
         { info_tbl: [(ccz5C,
                       label: block_ccz5C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz5C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccz5K; else goto ccz5J;
       ccz5K: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccz5J: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.374347937 UTC

[section ""data" . lvl19_rcykG_closure" {
     lvl19_rcykG_closure:
         const lvl19_rcykG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_rcykG_entry() //  [R1]
         { info_tbl: [(ccz5R,
                       label: lvl19_rcykG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz5R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz5S; else goto ccz5T;
       ccz5S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz5T: // global
           (_ccz5O::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccz5O::I64 == 0) goto ccz5Q; else goto ccz5P;
       ccz5Q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccz5P: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccz5O::I64;
           R3 = lvl18_rcykF_closure;
           R2 = lvl15_rcykC_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.375285644 UTC

[section ""cstring" . lvl20_rcykH_bytes" {
     lvl20_rcykH_bytes:
         I8[] [116,111,69,110,117,109,123,66,121,116,101,79,114,100,101,114,125,58,32,116,97,103,32,40]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.376308032 UTC

[section ""data" . GHC.ByteOrder.$wlvl_closure" {
     GHC.ByteOrder.$wlvl_closure:
         const GHC.ByteOrder.$wlvl_info;
         const 0;
 },
 sat_scylU_entry() //  [R1]
         { info_tbl: [(ccz65,
                       label: sat_scylU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz65: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccz66; else goto ccz67;
       ccz66: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz67: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccz62_info;
           R4 = lvl19_rcykG_closure;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccz62() //  [R1, R2]
         { info_tbl: [(ccz62,
                       label: block_ccz62_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz62: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccz6a; else goto ccz69;
       ccz6a: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccz69: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$wlvl_entry() //  [R2]
         { info_tbl: [(ccz6d,
                       label: GHC.ByteOrder.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz6d: // global
           _scylQ::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccz6e; else goto ccz6f;
       ccz6f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccz6h; else goto ccz6g;
       ccz6h: // global
           HpAlloc = 24;
           goto ccz6e;
       ccz6e: // global
           R2 = _scylQ::I64;
           R1 = GHC.ByteOrder.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccz6g: // global
           I64[Hp - 16] = sat_scylU_info;
           I64[Hp] = _scylQ::I64;
           I64[Sp - 8] = block_ccz6b_info;
           R3 = Hp - 16;
           R2 = lvl20_rcykH_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccz6b() //  [R1]
         { info_tbl: [(ccz6b,
                       label: block_ccz6b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz6b: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.378109164 UTC

[section ""data" . GHC.ByteOrder.$w$ctoEnum_closure" {
     GHC.ByteOrder.$w$ctoEnum_closure:
         const GHC.ByteOrder.$w$ctoEnum_info;
         const 0;
 },
 GHC.ByteOrder.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(ccz6u,
                       label: GHC.ByteOrder.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz6u: // global
           _scylW::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto ccz6C; else goto ccz6t;
       ccz6t: // global
           if (%MO_S_Gt_W64(_scylW::I64, 1)) goto ccz6C; else goto ccz6D;
       ccz6C: // global
           R2 = _scylW::I64;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ccz6D: // global
           R1 = I64[(_scylW::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.379140439 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_entry() //  [R2]
         { info_tbl: [(ccz6L,
                       label: GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz6L: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccz6M; else goto ccz6N;
       ccz6M: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccz6N: // global
           I64[Sp - 8] = block_ccz6I_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucz6R; else goto ccz6J;
       ucz6R: // global
           call _ccz6I(R1) args: 0, res: 0, upd: 0;
       ccz6J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz6I() //  [R1]
         { info_tbl: [(ccz6I,
                       label: block_ccz6I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz6I: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.ByteOrder.$w$ctoEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.3806411 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go2_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go2_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go2_info;
 },
 sat_scym6_entry() //  [R1]
         { info_tbl: [(ccz74,
                       label: sat_scym6_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz74: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz75; else goto ccz76;
       ccz75: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz76: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scym4::I64 = I64[R1 + 16];
           if (_scym4::I64 != 1) goto ccz72; else goto ccz73;
       ccz72: // global
           R2 = _scym4::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
       ccz73: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scym3_entry() //  [R1]
         { info_tbl: [(ccz7d,
                       label: sat_scym3_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz7d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz7e; else goto ccz7f;
       ccz7e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz7f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_go2_entry() //  [R2]
         { info_tbl: [(ccz7h,
                       label: GHC.ByteOrder.$fEnumByteOrder_go2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz7h: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccz7l; else goto ccz7k;
       ccz7l: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccz7k: // global
           I64[Hp - 64] = sat_scym6_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scym3_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.382231066 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder2_closure" {
     GHC.ByteOrder.$fEnumByteOrder2_closure:
         const GHC.ByteOrder.$fEnumByteOrder2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder2_entry() //  [R1]
         { info_tbl: [(ccz7s,
                       label: GHC.ByteOrder.$fEnumByteOrder2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz7s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz7t; else goto ccz7u;
       ccz7t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz7u: // global
           (_ccz7p::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccz7p::I64 == 0) goto ccz7r; else goto ccz7q;
       ccz7r: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccz7q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccz7p::I64;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.383309452 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder1_closure" {
     GHC.ByteOrder.$fEnumByteOrder1_closure:
         const GHC.ByteOrder.$fEnumByteOrder1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder1_entry() //  [R1]
         { info_tbl: [(ccz7B,
                       label: GHC.ByteOrder.$fEnumByteOrder1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz7B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz7C; else goto ccz7D;
       ccz7C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz7D: // global
           (_ccz7y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccz7y::I64 == 0) goto ccz7A; else goto ccz7z;
       ccz7A: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccz7z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccz7y::I64;
           R2 = 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.384437673 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_entry() //  [R2]
         { info_tbl: [(ccz7P,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz7P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccz7Q; else goto ccz7R;
       ccz7Q: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccz7R: // global
           I64[Sp - 8] = block_ccz7I_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucz7Y; else goto ccz7J;
       ucz7Y: // global
           call _ccz7I(R1) args: 0, res: 0, upd: 0;
       ccz7J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccz7I() //  [R1]
         { info_tbl: [(ccz7I,
                       label: block_ccz7I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz7I: // global
           if (R1 & 7 == 1) goto ccz7M; else goto ccz7N;
       ccz7M: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccz7N: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.391316333 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info;
 },
 sat_scymq_entry() //  [R1]
         { info_tbl: [(ccz8K,
                       label: sat_scymq_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz8K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz8L; else goto ccz8M;
       ccz8L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz8M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scyml_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymo_entry() //  [R1]
         { info_tbl: [(ccz8R,
                       label: sat_scymo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz8R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz8S; else goto ccz8T;
       ccz8S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz8T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymr_entry() //  [R1]
         { info_tbl: [(ccz8Z,
                       label: sat_scymr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz8Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz90; else goto ccz91;
       ccz90: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz91: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scyml_entry() //  [R1, R2]
         { info_tbl: [(ccz95,
                       label: go_dn_scyml_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz95: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccz99; else goto ccz98;
       ccz99: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccz98: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccz93; else goto ccz94;
       ccz93: // global
           _scymj::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scymq_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scymj::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scymo_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccz94: // global
           I64[Hp - 80] = sat_scymr_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccz9b::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccz9b::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyms_entry() //  [R1]
         { info_tbl: [(ccz9c,
                       label: sat_scyms_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz9c: // global
           _scyms::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccz9d; else goto ccz9e;
       ccz9e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccz9g; else goto ccz9f;
       ccz9g: // global
           HpAlloc = 24;
           goto ccz9d;
       ccz9d: // global
           R1 = _scyms::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz9f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyms::P64;
           _scyme::I64 = I64[_scyms::P64 + 24];
           _scymj::I64 = _scyme::I64 - I64[_scyms::P64 + 16];
           I64[Hp - 16] = go_dn_scyml_info;
           I64[Hp - 8] = _scymj::I64;
           I64[Hp] = 1 - _scymj::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scyml_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymi_entry() //  [R1]
         { info_tbl: [(ccz9l,
                       label: sat_scymi_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz9l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz9m; else goto ccz9n;
       ccz9m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz9n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymu_entry() //  [R1]
         { info_tbl: [(ccz9w,
                       label: sat_scymu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz9w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccz9x; else goto ccz9y;
       ccz9x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccz9y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymE_entry() //  [R1]
         { info_tbl: [(ccza1,
                       label: sat_scymE_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccza1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccza2; else goto ccza3;
       ccza2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccza3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scymz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymC_entry() //  [R1]
         { info_tbl: [(ccza8,
                       label: sat_scymC_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccza8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccza9; else goto cczaa;
       ccza9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczaa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymF_entry() //  [R1]
         { info_tbl: [(cczag,
                       label: sat_scymF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczag: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczah; else goto cczai;
       cczah: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczai: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scymz_entry() //  [R1, R2]
         { info_tbl: [(cczam,
                       label: go_up_scymz_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczam: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczaq; else goto cczap;
       cczaq: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczap: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto cczak; else goto cczal;
       cczak: // global
           _scymx::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scymE_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scymx::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scymC_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczal: // global
           I64[Hp - 80] = sat_scymF_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczas::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczas::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scymG_entry() //  [R1]
         { info_tbl: [(cczat,
                       label: sat_scymG_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczat: // global
           _scymG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczau; else goto cczav;
       cczav: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczax; else goto cczaw;
       cczax: // global
           HpAlloc = 24;
           goto cczau;
       cczau: // global
           R1 = _scymG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczaw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scymG::P64;
           _scyme::I64 = I64[_scymG::P64 + 24];
           _scymx::I64 = _scyme::I64 - I64[_scymG::P64 + 16];
           I64[Hp - 16] = go_up_scymz_info;
           I64[Hp - 8] = _scymx::I64;
           I64[Hp] = 1 - _scymx::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scymz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymw_entry() //  [R1]
         { info_tbl: [(cczaC,
                       label: sat_scymw_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczaC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczaD; else goto cczaE;
       cczaD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczaE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymI_entry() //  [R1]
         { info_tbl: [(cczaN,
                       label: sat_scymI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczaN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczaO; else goto cczaP;
       cczaO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczaP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymT_entry() //  [R1]
         { info_tbl: [(cczbl,
                       label: sat_scymT_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczbl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczbm; else goto cczbn;
       cczbm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczbn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scymO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymR_entry() //  [R1]
         { info_tbl: [(cczbs,
                       label: sat_scymR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczbs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczbt; else goto cczbu;
       cczbt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczbu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymU_entry() //  [R1]
         { info_tbl: [(cczbA,
                       label: sat_scymU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczbA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczbB; else goto cczbC;
       cczbB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczbC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scymO_entry() //  [R1, R2]
         { info_tbl: [(cczbG,
                       label: go_dn_scymO_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczbG: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczbK; else goto cczbJ;
       cczbK: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczbJ: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto cczbE; else goto cczbF;
       cczbE: // global
           _scymM::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scymT_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scymM::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scymR_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczbF: // global
           I64[Hp - 80] = sat_scymU_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczbM::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczbM::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scymV_entry() //  [R1]
         { info_tbl: [(cczbN,
                       label: sat_scymV_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczbN: // global
           _scymV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczbO; else goto cczbP;
       cczbP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczbR; else goto cczbQ;
       cczbR: // global
           HpAlloc = 24;
           goto cczbO;
       cczbO: // global
           R1 = _scymV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczbQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scymV::P64;
           _scyme::I64 = I64[_scymV::P64 + 24];
           _scymM::I64 = _scyme::I64 - I64[_scymV::P64 + 16];
           I64[Hp - 16] = go_dn_scymO_info;
           I64[Hp - 8] = _scymM::I64;
           I64[Hp] = 0 - _scymM::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scymO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymL_entry() //  [R1]
         { info_tbl: [(cczbW,
                       label: sat_scymL_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczbW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczbX; else goto cczbY;
       cczbX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczbY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymX_entry() //  [R1]
         { info_tbl: [(cczc7,
                       label: sat_scymX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczc7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczc8; else goto cczc9;
       cczc8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczc9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyn7_entry() //  [R1]
         { info_tbl: [(cczcC,
                       label: sat_scyn7_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczcC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczcD; else goto cczcE;
       cczcD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczcE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scyn2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyn5_entry() //  [R1]
         { info_tbl: [(cczcJ,
                       label: sat_scyn5_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczcJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczcK; else goto cczcL;
       cczcK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczcL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyn8_entry() //  [R1]
         { info_tbl: [(cczcR,
                       label: sat_scyn8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczcR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczcS; else goto cczcT;
       cczcS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczcT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scyn2_entry() //  [R1, R2]
         { info_tbl: [(cczcX,
                       label: go_up_scyn2_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczcX: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczd1; else goto cczd0;
       cczd1: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczd0: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto cczcV; else goto cczcW;
       cczcV: // global
           _scyn0::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyn7_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyn0::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyn5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczcW: // global
           I64[Hp - 80] = sat_scyn8_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczd3::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczd3::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyn9_entry() //  [R1]
         { info_tbl: [(cczd4,
                       label: sat_scyn9_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczd4: // global
           _scyn9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczd5; else goto cczd6;
       cczd6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczd8; else goto cczd7;
       cczd8: // global
           HpAlloc = 24;
           goto cczd5;
       cczd5: // global
           R1 = _scyn9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczd7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyn9::P64;
           _scyme::I64 = I64[_scyn9::P64 + 24];
           _scyn0::I64 = _scyme::I64 - I64[_scyn9::P64 + 16];
           I64[Hp - 16] = go_up_scyn2_info;
           I64[Hp - 8] = _scyn0::I64;
           I64[Hp] = 0 - _scyn0::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scyn2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymZ_entry() //  [R1]
         { info_tbl: [(cczdd,
                       label: sat_scymZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczdd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczde; else goto cczdf;
       cczde: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczdf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynb_entry() //  [R1]
         { info_tbl: [(cczdo,
                       label: sat_scynb_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczdo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczdp; else goto cczdq;
       cczdp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczdq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(cczdy,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczdy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczdz; else goto cczdA;
       cczdz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczdA: // global
           I64[Sp - 16] = block_cczdr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczeI; else goto cczds;
       uczeI: // global
           call _cczdr(R1) args: 0, res: 0, upd: 0;
       cczds: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczdr() //  [R1]
         { info_tbl: [(cczdr,
                       label: block_cczdr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczdr: // global
           _scyma::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczdv; else goto cczdw;
       cczdv: // global
           _scymc::I64 = 0;
           goto scymb;
       cczdw: // global
           _scymc::I64 = 1;
           goto scymb;
       scymb: // global
           I64[Sp] = block_cczdB_info;
           R1 = _scyma::P64;
           I64[Sp + 8] = _scymc::I64;
           if (R1 & 7 != 0) goto uczeH; else goto cczel;
       uczeH: // global
           call _cczdB(R1) args: 0, res: 0, upd: 0;
       cczel: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczdB() //  [R1]
         { info_tbl: [(cczdB,
                       label: block_cczdB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczdB: // global
           if (R1 & 7 == 1) goto cczer; else goto cczev;
       cczer: // global
           I64[Sp] = 0;
           goto uczeK;
       cczev: // global
           I64[Sp] = 1;
           goto uczeK;
       uczeK: // global
           call _ccz8b() args: 0, res: 0, upd: 0;
     }
 },
 _ccz8b() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz8b: // global
           Hp = Hp + 80;
           _scyme::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cczdF; else goto cczdE;
       cczdF: // global
           HpAlloc = 80;
           I64[Sp] = block_ccz8a_info;
           R1 = _scyme::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cczdE: // global
           _scymc::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_scymc::I64,
                            _scyme::I64)) goto ccze0; else goto cczek;
       ccze0: // global
           if (%MO_S_Lt_W64(_scyme::I64,
                            _scymc::I64)) goto cczdP; else goto cczdY;
       cczdP: // global
           if (%MO_S_Le_W64(1, _scyme::I64)) goto cczdI; else goto cczdN;
       cczdI: // global
           I64[Hp - 72] = sat_scyms_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymi_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczdN: // global
           if (%MO_S_Gt_W64(1, _scymc::I64)) goto cczeh; else goto cczdL;
       cczdL: // global
           I64[Hp - 72] = sat_scymu_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczdJ::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczdJ::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczdY: // global
           if (%MO_S_Ge_W64(1, _scyme::I64)) goto cczdS; else goto cczdX;
       cczdS: // global
           I64[Hp - 72] = sat_scymG_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymw_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczdX: // global
           if (%MO_S_Lt_W64(1, _scymc::I64)) goto cczeh; else goto cczdV;
       cczdV: // global
           I64[Hp - 72] = sat_scymI_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczdT::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczdT::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczek: // global
           if (%MO_S_Lt_W64(_scyme::I64,
                            _scymc::I64)) goto cczea; else goto cczej;
       cczea: // global
           if (%MO_S_Le_W64(0, _scyme::I64)) goto ccze3; else goto ccze8;
       ccze3: // global
           I64[Hp - 72] = sat_scymV_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymL_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccze8: // global
           if (%MO_S_Gt_W64(0, _scymc::I64)) goto cczeh; else goto ccze6;
       ccze6: // global
           I64[Hp - 72] = sat_scymX_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccze4::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccze4::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczej: // global
           if (%MO_S_Ge_W64(0, _scyme::I64)) goto cczed; else goto cczei;
       cczed: // global
           I64[Hp - 72] = sat_scyn9_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymZ_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczei: // global
           if (%MO_S_Lt_W64(0, _scymc::I64)) goto cczeh; else goto cczeg;
       cczeh: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczeg: // global
           I64[Hp - 72] = sat_scynb_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczee::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczee::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccz8a() //  [R1]
         { info_tbl: [(ccz8a,
                       label: block_ccz8a_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccz8a: // global
           I64[Sp] = R1;
           call _ccz8b() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.403945993 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go1_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go1_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go1_info;
         const 0;
 },
 sat_scynk_entry() //  [R1]
         { info_tbl: [(cczeX,
                       label: sat_scynk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczeX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczeY; else goto cczeZ;
       cczeY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczeZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyni::I64 = I64[R1 + 16];
           if (_scyni::I64 != 0) goto cczeV; else goto cczeW;
       cczeV: // global
           R2 = _scyni::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go1_entry(R2) args: 24, res: 0, upd: 24;
       cczeW: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynh_entry() //  [R1]
         { info_tbl: [(cczfb,
                       label: sat_scynh_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczfb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczfc; else goto cczfk;
       cczfc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczfk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyne::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyne::I64, 0)) goto cczfi; else goto cczfa;
       cczfa: // global
           if (%MO_S_Gt_W64(_scyne::I64, 1)) goto cczfi; else goto cczfj;
       cczfi: // global
           R2 = _scyne::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczfj: // global
           R1 = I64[(_scyne::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_go1_entry() //  [R2]
         { info_tbl: [(cczfm,
                       label: GHC.ByteOrder.$fEnumByteOrder_go1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczfm: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cczfq; else goto cczfp;
       cczfq: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczfp: // global
           I64[Hp - 64] = sat_scynk_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scynh_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.406251636 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go_info;
         const 0;
 },
 sat_scynr_entry() //  [R1]
         { info_tbl: [(cczfD,
                       label: sat_scynr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczfD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczfE; else goto cczfF;
       cczfE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczfF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynp::I64 = I64[R1 + 16];
           if (_scynp::I64 != 1) goto cczfB; else goto cczfC;
       cczfB: // global
           R2 = _scynp::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go_entry(R2) args: 24, res: 0, upd: 24;
       cczfC: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyno_entry() //  [R1]
         { info_tbl: [(cczfR,
                       label: sat_scyno_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczfR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczfS; else goto cczg0;
       cczfS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczg0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynl::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynl::I64, 0)) goto cczfY; else goto cczfQ;
       cczfQ: // global
           if (%MO_S_Gt_W64(_scynl::I64, 1)) goto cczfY; else goto cczfZ;
       cczfY: // global
           R2 = _scynl::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczfZ: // global
           R1 = I64[(_scynl::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_go_entry() //  [R2]
         { info_tbl: [(cczg2,
                       label: GHC.ByteOrder.$fEnumByteOrder_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczg2: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cczg6; else goto cczg5;
       cczg6: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczg5: // global
           I64[Hp - 64] = sat_scynr_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyno_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.40846655 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(cczgk,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczgk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczgl; else goto cczgm;
       cczgl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczgm: // global
           I64[Sp - 16] = block_cczgd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczgV; else goto cczge;
       uczgV: // global
           call _cczgd(R1) args: 0, res: 0, upd: 0;
       cczge: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczgd() //  [R1]
         { info_tbl: [(cczgd,
                       label: block_cczgd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczgd: // global
           _scynt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczgh; else goto cczgi;
       cczgh: // global
           _scynv::I64 = 0;
           goto scynu;
       cczgi: // global
           _scynv::I64 = 1;
           goto scynu;
       scynu: // global
           I64[Sp] = block_cczgq_info;
           R1 = _scynt::P64;
           I64[Sp + 8] = _scynv::I64;
           if (R1 & 7 != 0) goto uczgU; else goto cczgs;
       uczgU: // global
           call _cczgq(R1) args: 0, res: 0, upd: 0;
       cczgs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczgq() //  [R1]
         { info_tbl: [(cczgq,
                       label: block_cczgq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczgq: // global
           _scynv::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cczgD; else goto cczgM;
       cczgD: // global
           if (%MO_S_Gt_W64(_scynv::I64, 0)) goto cczgL; else goto cczgA;
       cczgA: // global
           R2 = _scynv::I64;
           Sp = Sp + 16;
           call GHC.ByteOrder.$fEnumByteOrder_go1_entry(R2) args: 8, res: 0, upd: 8;
       cczgM: // global
           if (%MO_S_Gt_W64(_scynv::I64, 1)) goto cczgL; else goto cczgK;
       cczgL: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczgK: // global
           R2 = _scynv::I64;
           Sp = Sp + 16;
           call GHC.ByteOrder.$fEnumByteOrder_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.418439943 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info;
         const 0;
 },
 sat_scynW_entry() //  [R1]
         { info_tbl: [(cczhJ,
                       label: sat_scynW_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczhJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczhK; else goto cczhL;
       cczhK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczhL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scynP_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynU_entry() //  [R1]
         { info_tbl: [(cczhV,
                       label: sat_scynU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczhV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczhW; else goto cczi4;
       cczhW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczi4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynQ::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynQ::I64, 0)) goto cczi2; else goto cczhU;
       cczhU: // global
           if (%MO_S_Gt_W64(_scynQ::I64, 1)) goto cczi2; else goto cczi3;
       cczi2: // global
           R2 = _scynQ::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczi3: // global
           R1 = I64[(_scynQ::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynZ_entry() //  [R1]
         { info_tbl: [(cczif,
                       label: sat_scynZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczif: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczig; else goto cczio;
       cczig: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczio: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynQ::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynQ::I64, 0)) goto cczim; else goto cczie;
       cczie: // global
           if (%MO_S_Gt_W64(_scynQ::I64, 1)) goto cczim; else goto cczin;
       cczim: // global
           R2 = _scynQ::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczin: // global
           R1 = I64[(_scynQ::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scynP_entry() //  [R1, R2]
         { info_tbl: [(cczis,
                       label: go_dn_scynP_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczis: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccziw; else goto ccziv;
       ccziw: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccziv: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccziq; else goto cczir;
       ccziq: // global
           _scynN::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scynW_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scynN::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scynU_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczir: // global
           I64[Hp - 80] = sat_scynZ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccziy::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccziy::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyo0_entry() //  [R1]
         { info_tbl: [(ccziz,
                       label: sat_scyo0_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccziz: // global
           _scyo0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccziA; else goto ccziB;
       ccziB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccziD; else goto ccziC;
       ccziD: // global
           HpAlloc = 24;
           goto ccziA;
       ccziA: // global
           R1 = _scyo0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccziC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyo0::P64;
           _scynG::I64 = I64[_scyo0::P64 + 24];
           _scynN::I64 = _scynG::I64 - I64[_scyo0::P64 + 16];
           I64[Hp - 16] = go_dn_scynP_info;
           I64[Hp - 8] = _scynN::I64;
           I64[Hp] = 0 - _scynN::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scynP_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynM_entry() //  [R1]
         { info_tbl: [(ccziN,
                       label: sat_scynM_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccziN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccziO; else goto ccziW;
       ccziO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccziW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccziU; else goto ccziM;
       ccziM: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccziU; else goto ccziV;
       ccziU: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccziV: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyo4_entry() //  [R1]
         { info_tbl: [(cczja,
                       label: sat_scyo4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczja: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczjb; else goto cczjj;
       cczjb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczjj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto cczjh; else goto cczj9;
       cczj9: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto cczjh; else goto cczji;
       cczjh: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczji: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoi_entry() //  [R1]
         { info_tbl: [(cczjM,
                       label: sat_scyoi_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczjM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczjN; else goto cczjO;
       cczjN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczjO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scyob_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyog_entry() //  [R1]
         { info_tbl: [(cczjY,
                       label: sat_scyog_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczjY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczjZ; else goto cczk7;
       cczjZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczk7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoc::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoc::I64, 0)) goto cczk5; else goto cczjX;
       cczjX: // global
           if (%MO_S_Gt_W64(_scyoc::I64, 1)) goto cczk5; else goto cczk6;
       cczk5: // global
           R2 = _scyoc::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczk6: // global
           R1 = I64[(_scyoc::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyol_entry() //  [R1]
         { info_tbl: [(cczki,
                       label: sat_scyol_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczki: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczkj; else goto cczkr;
       cczkj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczkr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoc::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoc::I64, 0)) goto cczkp; else goto cczkh;
       cczkh: // global
           if (%MO_S_Gt_W64(_scyoc::I64, 1)) goto cczkp; else goto cczkq;
       cczkp: // global
           R2 = _scyoc::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczkq: // global
           R1 = I64[(_scyoc::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scyob_entry() //  [R1, R2]
         { info_tbl: [(cczkv,
                       label: go_up_scyob_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczkv: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczkz; else goto cczky;
       cczkz: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczky: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto cczkt; else goto cczku;
       cczkt: // global
           _scyo9::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyoi_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyo9::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyog_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczku: // global
           I64[Hp - 80] = sat_scyol_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczkB::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczkB::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyom_entry() //  [R1]
         { info_tbl: [(cczkC,
                       label: sat_scyom_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczkC: // global
           _scyom::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczkD; else goto cczkE;
       cczkE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczkG; else goto cczkF;
       cczkG: // global
           HpAlloc = 24;
           goto cczkD;
       cczkD: // global
           R1 = _scyom::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczkF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyom::P64;
           _scynG::I64 = I64[_scyom::P64 + 24];
           _scyo9::I64 = _scynG::I64 - I64[_scyom::P64 + 16];
           I64[Hp - 16] = go_up_scyob_info;
           I64[Hp - 8] = _scyo9::I64;
           I64[Hp] = 0 - _scyo9::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scyob_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyo8_entry() //  [R1]
         { info_tbl: [(cczkQ,
                       label: sat_scyo8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczkQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczkR; else goto cczkZ;
       cczkR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczkZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto cczkX; else goto cczkP;
       cczkP: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto cczkX; else goto cczkY;
       cczkX: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczkY: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoq_entry() //  [R1]
         { info_tbl: [(cczld,
                       label: sat_scyoq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczld: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczle; else goto cczlm;
       cczle: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczlm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto cczlk; else goto cczlc;
       cczlc: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto cczlk; else goto cczll;
       cczlk: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczll: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoF_entry() //  [R1]
         { info_tbl: [(cczlT,
                       label: sat_scyoF_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczlT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczlU; else goto cczlV;
       cczlU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczlV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scyoy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoD_entry() //  [R1]
         { info_tbl: [(cczm5,
                       label: sat_scyoD_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczm5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczm6; else goto cczme;
       cczm6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczme: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoz::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoz::I64, 0)) goto cczmc; else goto cczm4;
       cczm4: // global
           if (%MO_S_Gt_W64(_scyoz::I64, 1)) goto cczmc; else goto cczmd;
       cczmc: // global
           R2 = _scyoz::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczmd: // global
           R1 = I64[(_scyoz::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoI_entry() //  [R1]
         { info_tbl: [(cczmp,
                       label: sat_scyoI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczmp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczmq; else goto cczmy;
       cczmq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczmy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoz::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoz::I64, 0)) goto cczmw; else goto cczmo;
       cczmo: // global
           if (%MO_S_Gt_W64(_scyoz::I64, 1)) goto cczmw; else goto cczmx;
       cczmw: // global
           R2 = _scyoz::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczmx: // global
           R1 = I64[(_scyoz::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scyoy_entry() //  [R1, R2]
         { info_tbl: [(cczmC,
                       label: go_dn_scyoy_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczmC: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczmG; else goto cczmF;
       cczmG: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczmF: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto cczmA; else goto cczmB;
       cczmA: // global
           _scyow::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyoF_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyow::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyoD_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczmB: // global
           I64[Hp - 80] = sat_scyoI_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczmI::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczmI::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyoJ_entry() //  [R1]
         { info_tbl: [(cczmJ,
                       label: sat_scyoJ_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczmJ: // global
           _scyoJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczmK; else goto cczmL;
       cczmL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczmN; else goto cczmM;
       cczmN: // global
           HpAlloc = 24;
           goto cczmK;
       cczmK: // global
           R1 = _scyoJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczmM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyoJ::P64;
           _scynG::I64 = I64[_scyoJ::P64 + 24];
           _scyow::I64 = _scynG::I64 - I64[_scyoJ::P64 + 16];
           I64[Hp - 16] = go_dn_scyoy_info;
           I64[Hp - 8] = _scyow::I64;
           I64[Hp] = 1 - _scyow::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scyoy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyov_entry() //  [R1]
         { info_tbl: [(cczmX,
                       label: sat_scyov_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczmX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczmY; else goto cczn6;
       cczmY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczn6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto cczn4; else goto cczmW;
       cczmW: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto cczn4; else goto cczn5;
       cczn4: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczn5: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoN_entry() //  [R1]
         { info_tbl: [(ccznk,
                       label: sat_scyoN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccznk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccznl; else goto ccznt;
       ccznl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccznt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccznr; else goto ccznj;
       ccznj: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccznr; else goto cczns;
       ccznr: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczns: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyp1_entry() //  [R1]
         { info_tbl: [(ccznW,
                       label: sat_scyp1_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccznW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccznX; else goto ccznY;
       ccznX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccznY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scyoU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoZ_entry() //  [R1]
         { info_tbl: [(cczo8,
                       label: sat_scyoZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczo8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczo9; else goto cczoh;
       cczo9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczoh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoV::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoV::I64, 0)) goto cczof; else goto cczo7;
       cczo7: // global
           if (%MO_S_Gt_W64(_scyoV::I64, 1)) goto cczof; else goto cczog;
       cczof: // global
           R2 = _scyoV::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczog: // global
           R1 = I64[(_scyoV::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyp4_entry() //  [R1]
         { info_tbl: [(cczos,
                       label: sat_scyp4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczos: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczot; else goto cczoB;
       cczot: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczoB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoV::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoV::I64, 0)) goto cczoz; else goto cczor;
       cczor: // global
           if (%MO_S_Gt_W64(_scyoV::I64, 1)) goto cczoz; else goto cczoA;
       cczoz: // global
           R2 = _scyoV::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczoA: // global
           R1 = I64[(_scyoV::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scyoU_entry() //  [R1, R2]
         { info_tbl: [(cczoF,
                       label: go_up_scyoU_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczoF: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczoJ; else goto cczoI;
       cczoJ: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczoI: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto cczoD; else goto cczoE;
       cczoD: // global
           _scyoS::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyp1_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyoS::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyoZ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczoE: // global
           I64[Hp - 80] = sat_scyp4_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczoL::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczoL::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyp5_entry() //  [R1]
         { info_tbl: [(cczoM,
                       label: sat_scyp5_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczoM: // global
           _scyp5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczoN; else goto cczoO;
       cczoO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczoQ; else goto cczoP;
       cczoQ: // global
           HpAlloc = 24;
           goto cczoN;
       cczoN: // global
           R1 = _scyp5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczoP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyp5::P64;
           _scynG::I64 = I64[_scyp5::P64 + 24];
           _scyoS::I64 = _scynG::I64 - I64[_scyp5::P64 + 16];
           I64[Hp - 16] = go_up_scyoU_info;
           I64[Hp - 8] = _scyoS::I64;
           I64[Hp] = 1 - _scyoS::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scyoU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoR_entry() //  [R1]
         { info_tbl: [(cczp0,
                       label: sat_scyoR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczp0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczp1; else goto cczp9;
       cczp1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczp9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto cczp7; else goto cczoZ;
       cczoZ: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto cczp7; else goto cczp8;
       cczp7: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczp8: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyp9_entry() //  [R1]
         { info_tbl: [(cczpn,
                       label: sat_scyp9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczpn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczpo; else goto cczpw;
       cczpo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczpw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto cczpu; else goto cczpm;
       cczpm: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto cczpu; else goto cczpv;
       cczpu: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczpv: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(cczpE,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczpE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cczpF; else goto cczpG;
       cczpF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cczpG: // global
           I64[Sp - 24] = block_cczpx_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uczqP; else goto cczpy;
       uczqP: // global
           call _cczpx(R1) args: 0, res: 0, upd: 0;
       cczpy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczpx() //  [R1]
         { info_tbl: [(cczpx,
                       label: block_cczpx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczpx: // global
           _scynB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczpB; else goto cczpC;
       cczpB: // global
           _scynE::I64 = 0;
           goto scynD;
       cczpC: // global
           _scynE::I64 = 1;
           goto scynD;
       scynD: // global
           I64[Sp] = block_cczpH_info;
           R1 = _scynB::P64;
           I64[Sp + 8] = _scynE::I64;
           if (R1 & 7 != 0) goto uczqO; else goto cczqv;
       uczqO: // global
           call _cczpH(R1) args: 0, res: 0, upd: 0;
       cczqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczpH() //  [R1]
         { info_tbl: [(cczpH,
                       label: block_cczpH_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczpH: // global
           _scynC::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cczqB; else goto cczqF;
       cczqB: // global
           _scynG::I64 = 0;
           goto scynF;
       cczqF: // global
           _scynG::I64 = 1;
           goto scynF;
       scynF: // global
           I64[Sp] = block_cczha_info;
           R1 = _scynC::P64;
           I64[Sp + 16] = _scynG::I64;
           if (R1 & 7 != 0) goto uczqQ; else goto cczhb;
       uczqQ: // global
           call _cczha(R1) args: 0, res: 0, upd: 0;
       cczhb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczha() //  [R1]
         { info_tbl: [(cczha,
                       label: block_cczha_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczha: // global
           _scynE::I64 = I64[Sp + 8];
           _scynG::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto cczpL; else goto cczq8;
       cczpL: // global
           Hp = Hp + 80;
           _scynH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cczqb; else goto cczpN;
       cczpN: // global
           if (%MO_S_Lt_W64(_scynG::I64,
                            _scynE::I64)) goto cczpY; else goto cczq7;
       cczpY: // global
           if (%MO_S_Le_W64(0, _scynG::I64)) goto cczpR; else goto cczpW;
       cczpR: // global
           I64[Hp - 72] = sat_scyo0_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scynM_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczpW: // global
           if (%MO_S_Gt_W64(0, _scynE::I64)) goto cczqs; else goto cczpU;
       cczpU: // global
           I64[Hp - 72] = sat_scyo4_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczpS::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczpS::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczq7: // global
           if (%MO_S_Ge_W64(0, _scynG::I64)) goto cczq1; else goto cczq6;
       cczq1: // global
           I64[Hp - 72] = sat_scyom_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scyo8_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczq6: // global
           if (%MO_S_Lt_W64(0, _scynE::I64)) goto cczqs; else goto cczq4;
       cczq4: // global
           I64[Hp - 72] = sat_scyoq_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczq2::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczq2::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczq8: // global
           Hp = Hp + 80;
           _scynH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cczqb; else goto cczqa;
       cczqb: // global
           HpAlloc = 80;
           R1 = _scynH::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cczqa: // global
           if (%MO_S_Lt_W64(_scynG::I64,
                            _scynE::I64)) goto cczql; else goto cczqu;
       cczql: // global
           if (%MO_S_Le_W64(1, _scynG::I64)) goto cczqe; else goto cczqj;
       cczqe: // global
           I64[Hp - 72] = sat_scyoJ_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scyov_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczqj: // global
           if (%MO_S_Gt_W64(1, _scynE::I64)) goto cczqs; else goto cczqh;
       cczqh: // global
           I64[Hp - 72] = sat_scyoN_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczqf::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczqf::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczqu: // global
           if (%MO_S_Ge_W64(1, _scynG::I64)) goto cczqo; else goto cczqt;
       cczqo: // global
           I64[Hp - 72] = sat_scyp5_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scyoR_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczqt: // global
           if (%MO_S_Lt_W64(1, _scynE::I64)) goto cczqs; else goto cczqr;
       cczqs: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczqr: // global
           I64[Hp - 72] = sat_scyp9_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczqp::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczqp::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.431503961 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_closure" {
     GHC.ByteOrder.$fEnumByteOrder_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure+2;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure+2;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.432194614 UTC

[section ""data" . GHC.ByteOrder.$trModule3_closure" {
     GHC.ByteOrder.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.432783739 UTC

[section ""data" . GHC.ByteOrder.$trModule1_closure" {
     GHC.ByteOrder.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.433406961 UTC

[section ""data" . GHC.ByteOrder.$trModule_closure" {
     GHC.ByteOrder.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.ByteOrder.$trModule3_closure+1;
         const GHC.ByteOrder.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.43400141 UTC

[section ""cstring" . GHC.ByteOrder.$tcByteOrder2_bytes" {
     GHC.ByteOrder.$tcByteOrder2_bytes:
         I8[] [66,121,116,101,79,114,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.434572719 UTC

[section ""data" . GHC.ByteOrder.$tcByteOrder1_closure" {
     GHC.ByteOrder.$tcByteOrder1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tcByteOrder2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.435160257 UTC

[section ""data" . GHC.ByteOrder.$tcByteOrder_closure" {
     GHC.ByteOrder.$tcByteOrder_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tcByteOrder1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16811050684449662084;
         const 17273005335247024091;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.435794276 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian1_closure" {
     GHC.ByteOrder.$tc'BigEndian1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ByteOrder.$tcByteOrder_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.436430839 UTC

[section ""cstring" . GHC.ByteOrder.$tc'BigEndian3_bytes" {
     GHC.ByteOrder.$tc'BigEndian3_bytes:
         I8[] [39,66,105,103,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.437029884 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian2_closure" {
     GHC.ByteOrder.$tc'BigEndian2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tc'BigEndian3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.437637905 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian_closure" {
     GHC.ByteOrder.$tc'BigEndian_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tc'BigEndian2_closure+1;
         const GHC.ByteOrder.$tc'BigEndian1_closure+1;
         const 2645192688778293591;
         const 7455668807059762078;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.438251398 UTC

[section ""cstring" . GHC.ByteOrder.$tc'LittleEndian2_bytes" {
     GHC.ByteOrder.$tc'LittleEndian2_bytes:
         I8[] [39,76,105,116,116,108,101,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.438854663 UTC

[section ""data" . GHC.ByteOrder.$tc'LittleEndian1_closure" {
     GHC.ByteOrder.$tc'LittleEndian1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tc'LittleEndian2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.439493368 UTC

[section ""data" . GHC.ByteOrder.$tc'LittleEndian_closure" {
     GHC.ByteOrder.$tc'LittleEndian_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tc'LittleEndian1_closure+1;
         const GHC.ByteOrder.$tc'BigEndian1_closure+1;
         const 8702700204875460152;
         const 10337679016369298147;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.440160218 UTC

[section ""data" . GHC.ByteOrder.BigEndian_closure" {
     GHC.ByteOrder.BigEndian_closure:
         const GHC.ByteOrder.BigEndian_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.440769018 UTC

[section ""data" . GHC.ByteOrder.LittleEndian_closure" {
     GHC.ByteOrder.LittleEndian_closure:
         const GHC.ByteOrder.LittleEndian_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.441397563 UTC

[section ""relreadonly" . GHC.ByteOrder.ByteOrder_closure_tbl" {
     GHC.ByteOrder.ByteOrder_closure_tbl:
         const GHC.ByteOrder.BigEndian_closure+1;
         const GHC.ByteOrder.LittleEndian_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.442154225 UTC

[GHC.ByteOrder.BigEndian_con_entry() //  [R1]
         { info_tbl: [(cczqR,
                       label: GHC.ByteOrder.BigEndian_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,121,116,101,79,114,100,101,114,46,66,105,103,69,110,100,105,97,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczqR: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.442933261 UTC

[GHC.ByteOrder.LittleEndian_con_entry() //  [R1]
         { info_tbl: [(cczqT,
                       label: GHC.ByteOrder.LittleEndian_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,66,121,116,101,79,114,100,101,114,46,76,105,116,116,108,101,69,110,100,105,97,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczqT: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.443694756 UTC

[section ""relreadonly" . ScypP_srt" {
     ScypP_srt:
         const GHC.ByteOrder.$fReadByteOrder6_closure;
         const GHC.ByteOrder.$fReadByteOrder10_closure;
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure;
         const GHC.ByteOrder.$fShowByteOrder_$cshow_closure;
         const GHC.ByteOrder.$fShowByteOrder1_closure;
         const GHC.Read.choose2_closure;
         const GHC.ByteOrder.$fReadByteOrder_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.ByteOrder.$fReadByteOrder2_closure;
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.ByteOrder.$fReadByteOrder1_closure;
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
         const GHC.ByteOrder.$fReadByteOrder12_closure;
         const GHC.Err.error_closure;
         const lvl12_rcykz_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_closure;
         const GHC.ByteOrder.$fEnumByteOrder3_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_closure;
         const GHC.ByteOrder.$fEnumByteOrder4_closure;
         const lvl17_rcykE_closure;
         const lvl18_rcykF_closure;
         const lvl19_rcykG_closure;
         const GHC.ByteOrder.$wlvl_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure;
         const GHC.ByteOrder.$w$ctoEnum_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure;
         const GHC.ByteOrder.$fEnumByteOrder1_closure;
         const GHC.ByteOrder.$fEnumByteOrder2_closure;
         const GHC.ByteOrder.$fEnumByteOrder_go1_closure;
         const GHC.ByteOrder.$fEnumByteOrder_go_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.446113744 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:27.447222065 UTC

[section ""cstring" . GHC.ByteOrder.$fReadByteOrder11_bytes" {
     GHC.ByteOrder.$fReadByteOrder11_bytes:
         I8[] [66,105,103,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.449339865 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder10_closure" {
     GHC.ByteOrder.$fReadByteOrder10_closure:
         const GHC.ByteOrder.$fReadByteOrder10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder10_entry() //  [R1]
         { info_tbl: [(cczr2,
                       label: GHC.ByteOrder.$fReadByteOrder10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczr2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczr3; else goto cczr4;
       cczr3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczr4: // global
           (_cczqZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczqZ::I64 == 0) goto cczr1; else goto cczr0;
       cczr1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczr0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczqZ::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.453387751 UTC

[section ""cstring" . GHC.ByteOrder.$fReadByteOrder7_bytes" {
     GHC.ByteOrder.$fReadByteOrder7_bytes:
         I8[] [76,105,116,116,108,101,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.455243838 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder6_closure" {
     GHC.ByteOrder.$fReadByteOrder6_closure:
         const GHC.ByteOrder.$fReadByteOrder6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder6_entry() //  [R1]
         { info_tbl: [(cczrj,
                       label: GHC.ByteOrder.$fReadByteOrder6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczrj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczrk; else goto cczrl;
       cczrk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczrl: // global
           (_cczrg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczrg::I64 == 0) goto cczri; else goto cczrh;
       cczri: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczrh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczrg::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.459545631 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(cczrE,
                       label: GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczrE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczrF; else goto cczrG;
       cczrF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cczrG: // global
           I64[Sp - 16] = block_cczrx_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczrN; else goto cczry;
       uczrN: // global
           call _cczrx(R1) args: 0, res: 0, upd: 0;
       cczry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczrx() //  [R1]
         { info_tbl: [(cczrx,
                       label: block_cczrx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczrx: // global
           _scykL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczrB; else goto cczrC;
       cczrB: // global
           R3 = _scykL::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cczrC: // global
           R3 = _scykL::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.465691738 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshow_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshow_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshow_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshow_entry() //  [R2]
         { info_tbl: [(cczsa,
                       label: GHC.ByteOrder.$fShowByteOrder_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczsa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cczsb; else goto cczsc;
       cczsb: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczsc: // global
           I64[Sp - 8] = block_cczs3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uczsj; else goto cczs4;
       uczsj: // global
           call _cczs3(R1) args: 0, res: 0, upd: 0;
       cczs4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczs3() //  [R1]
         { info_tbl: [(cczs3,
                       label: block_cczs3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczs3: // global
           if (R1 & 7 == 1) goto cczs7; else goto cczs8;
       cczs7: // global
           R1 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cczs8: // global
           R1 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.471494885 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder1_closure" {
     GHC.ByteOrder.$fShowByteOrder1_closure:
         const GHC.ByteOrder.$fShowByteOrder1_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder1_entry() //  [R2, R3]
         { info_tbl: [(cczsI,
                       label: GHC.ByteOrder.$fShowByteOrder1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczsI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczsJ; else goto cczsK;
       cczsJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczsK: // global
           I64[Sp - 16] = block_cczsB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczsR; else goto cczsC;
       uczsR: // global
           call _cczsB(R1) args: 0, res: 0, upd: 0;
       cczsC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczsB() //  [R1]
         { info_tbl: [(cczsB,
                       label: block_cczsB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczsB: // global
           _scykQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczsF; else goto cczsG;
       cczsF: // global
           R3 = _scykQ::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cczsG: // global
           R3 = _scykQ::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.478481009 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshowList_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshowList_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cczt7,
                       label: GHC.ByteOrder.$fShowByteOrder_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczt7: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.ByteOrder.$fShowByteOrder1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.48254294 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_closure" {
     GHC.ByteOrder.$fShowByteOrder_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure+3;
         const GHC.ByteOrder.$fShowByteOrder_$cshow_closure+1;
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.484459871 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder9_closure" {
     GHC.ByteOrder.$fReadByteOrder9_closure:
         const GHC.ByteOrder.$fReadByteOrder9_info;
 },
 GHC.ByteOrder.$fReadByteOrder9_entry() //  [R3]
         { info_tbl: [(ccztj,
                       label: GHC.ByteOrder.$fReadByteOrder9_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccztj: // global
           R2 = GHC.ByteOrder.BigEndian_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.488050599 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder8_closure" {
     GHC.ByteOrder.$fReadByteOrder8_closure:
         const (,)_con_info;
         const GHC.ByteOrder.$fReadByteOrder10_closure;
         const GHC.ByteOrder.$fReadByteOrder9_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.489870109 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder5_closure" {
     GHC.ByteOrder.$fReadByteOrder5_closure:
         const GHC.ByteOrder.$fReadByteOrder5_info;
 },
 GHC.ByteOrder.$fReadByteOrder5_entry() //  [R3]
         { info_tbl: [(ccztv,
                       label: GHC.ByteOrder.$fReadByteOrder5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccztv: // global
           R2 = GHC.ByteOrder.LittleEndian_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.493138721 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder4_closure" {
     GHC.ByteOrder.$fReadByteOrder4_closure:
         const (,)_con_info;
         const GHC.ByteOrder.$fReadByteOrder6_closure;
         const GHC.ByteOrder.$fReadByteOrder5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.494939233 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder3_closure" {
     GHC.ByteOrder.$fReadByteOrder3_closure:
         const :_con_info;
         const GHC.ByteOrder.$fReadByteOrder4_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.496672712 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_sps_closure" {
     GHC.ByteOrder.$fReadByteOrder_sps_closure:
         const :_con_info;
         const GHC.ByteOrder.$fReadByteOrder8_closure+1;
         const GHC.ByteOrder.$fReadByteOrder3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.498846696 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder2_closure" {
     GHC.ByteOrder.$fReadByteOrder2_closure:
         const GHC.ByteOrder.$fReadByteOrder2_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder2_entry() //  [R2]
         { info_tbl: [(ccztJ,
                       label: GHC.ByteOrder.$fReadByteOrder2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccztJ: // global
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.50221812 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder1_closure" {
     GHC.ByteOrder.$fReadByteOrder1_closure:
         const GHC.ByteOrder.$fReadByteOrder1_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder1_entry() //  [R2, R3]
         { info_tbl: [(ccztU,
                       label: GHC.ByteOrder.$fReadByteOrder1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccztU: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.506030412 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info;
         const 0;
 },
 sat_scyl0_entry() //  [R1]
         { info_tbl: [(cczu9,
                       label: sat_scyl0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczu9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczua; else goto cczub;
       cczua: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczub: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.ByteOrder.$fReadByteOrder2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fReadByteOrder_$creadsPrec_entry() //  [R2]
         { info_tbl: [(cczuc,
                       label: GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczuc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczug; else goto cczuf;
       cczug: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczuf: // global
           I64[Hp - 16] = sat_scyl0_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.512702735 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadListPrec_entry() //  [R1]
         { info_tbl: [(cczuv,
                       label: GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczuv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczuw; else goto cczux;
       cczuw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczux: // global
           (_cczus::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczus::I64 == 0) goto cczuu; else goto cczut;
       cczuu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczut: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczus::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.517374512 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder12_closure" {
     GHC.ByteOrder.$fReadByteOrder12_closure:
         const GHC.ByteOrder.$fReadByteOrder12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder12_entry() //  [R1]
         { info_tbl: [(cczuL,
                       label: GHC.ByteOrder.$fReadByteOrder12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczuL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczuM; else goto cczuN;
       cczuM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczuN: // global
           (_cczuI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczuI::I64 == 0) goto cczuK; else goto cczuJ;
       cczuK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczuJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczuI::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.521450669 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadList_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadList_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadList_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadList_entry() //  [R2]
         { info_tbl: [(cczuZ,
                       label: GHC.ByteOrder.$fReadByteOrder_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczuZ: // global
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.524892235 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_closure" {
     GHC.ByteOrder.$fReadByteOrder_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure+1;
         const GHC.ByteOrder.$fReadByteOrder_$creadList_closure+1;
         const GHC.ByteOrder.$fReadByteOrder1_closure+2;
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.527251047 UTC

[section ""data" . GHC.ByteOrder.$fBoundedByteOrder_closure" {
     GHC.ByteOrder.$fBoundedByteOrder_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.ByteOrder.BigEndian_closure+1;
         const GHC.ByteOrder.LittleEndian_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.529519561 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c<_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c<_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c<_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c<_entry() //  [R2, R3]
         { info_tbl: [(cczvj,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczvj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczvk; else goto cczvl;
       cczvk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczvl: // global
           I64[Sp - 16] = block_cczvc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczvN; else goto cczvd;
       uczvN: // global
           call _cczvc(R1) args: 0, res: 0, upd: 0;
       cczvd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczvc() //  [R1]
         { info_tbl: [(cczvc,
                       label: block_cczvc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczvc: // global
           _scyl2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczvg; else goto cczvh;
       cczvg: // global
           I64[Sp + 8] = block_cczvo_info;
           R1 = _scyl2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczvL; else goto cczvq;
       uczvL: // global
           call _cczvo(R1) args: 0, res: 0, upd: 0;
       cczvq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczvh: // global
           I64[Sp + 8] = block_cczvD_info;
           R1 = _scyl2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczvM; else goto cczvF;
       uczvM: // global
           call _cczvD() args: 0, res: 0, upd: 0;
       cczvF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczvo() //  [R1]
         { info_tbl: [(cczvo,
                       label: block_cczvo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczvo: // global
           if (R1 & 7 == 1) goto cczvw; else goto cczvA;
       cczvw: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczvA: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cczvD() //  []
         { info_tbl: [(cczvD,
                       label: block_cczvD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczvD: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.539857048 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(cczwn,
                       label: GHC.ByteOrder.$fOrdByteOrder_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczwn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczwo; else goto cczwp;
       cczwo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczwp: // global
           I64[Sp - 16] = block_cczwg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczx0; else goto cczwh;
       uczx0: // global
           call _cczwg(R1) args: 0, res: 0, upd: 0;
       cczwh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczwg() //  [R1]
         { info_tbl: [(cczwg,
                       label: block_cczwg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczwg: // global
           _scyl7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczwk; else goto cczwl;
       cczwk: // global
           I64[Sp + 8] = block_cczws_info;
           R1 = _scyl7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczwY; else goto cczwu;
       uczwY: // global
           call _cczws(R1) args: 0, res: 0, upd: 0;
       cczwu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczwl: // global
           I64[Sp + 8] = block_cczwH_info;
           R1 = _scyl7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczwZ; else goto cczwJ;
       uczwZ: // global
           call _cczwH(R1) args: 0, res: 0, upd: 0;
       cczwJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczws() //  [R1]
         { info_tbl: [(cczws,
                       label: block_cczws_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczws: // global
           if (R1 & 7 == 1) goto uczwX; else goto cczwE;
       uczwX: // global
           Sp = Sp + 8;
           call _cczwT() args: 0, res: 0, upd: 0;
       cczwE: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cczwH() //  [R1]
         { info_tbl: [(cczwH,
                       label: block_cczwH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczwH: // global
           if (R1 & 7 == 1) goto cczwP; else goto uczwW;
       cczwP: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uczwW: // global
           Sp = Sp + 8;
           call _cczwT() args: 0, res: 0, upd: 0;
     }
 },
 _cczwT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczwT: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.551632666 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_$c==_closure" {
     GHC.ByteOrder.$fEqByteOrder_$c==_closure:
         const GHC.ByteOrder.$fEqByteOrder_$c==_info;
 },
 GHC.ByteOrder.$fEqByteOrder_$c==_entry() //  [R2, R3]
         { info_tbl: [(cczxG,
                       label: GHC.ByteOrder.$fEqByteOrder_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczxG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczxH; else goto cczxI;
       cczxH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEqByteOrder_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczxI: // global
           I64[Sp - 16] = block_cczxz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczyl; else goto cczxA;
       uczyl: // global
           call _cczxz(R1) args: 0, res: 0, upd: 0;
       cczxA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczxz() //  [R1]
         { info_tbl: [(cczxz,
                       label: block_cczxz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczxz: // global
           _scylc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczxD; else goto cczxE;
       cczxD: // global
           I64[Sp + 8] = block_cczxL_info;
           R1 = _scylc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczyj; else goto cczxN;
       uczyj: // global
           call _cczxL(R1) args: 0, res: 0, upd: 0;
       cczxN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczxE: // global
           I64[Sp + 8] = block_cczy0_info;
           R1 = _scylc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczyk; else goto cczy2;
       uczyk: // global
           call _cczy0(R1) args: 0, res: 0, upd: 0;
       cczy2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczxL() //  [R1]
         { info_tbl: [(cczxL,
                       label: block_cczxL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczxL: // global
           if (R1 & 7 == 1) goto uczyh; else goto uczyi;
       uczyh: // global
           Sp = Sp + 8;
           call _cczyc() args: 0, res: 0, upd: 0;
       uczyi: // global
           Sp = Sp + 8;
           call _cczy8() args: 0, res: 0, upd: 0;
     }
 },
 _cczy0() //  [R1]
         { info_tbl: [(cczy0,
                       label: block_cczy0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczy0: // global
           if (R1 & 7 == 1) goto uczyf; else goto uczyg;
       uczyf: // global
           Sp = Sp + 8;
           call _cczy8() args: 0, res: 0, upd: 0;
       uczyg: // global
           Sp = Sp + 8;
           call _cczyc() args: 0, res: 0, upd: 0;
     }
 },
 _cczy8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczy8: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cczyc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczyc: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.562955141 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_$c/=_closure" {
     GHC.ByteOrder.$fEqByteOrder_$c/=_closure:
         const GHC.ByteOrder.$fEqByteOrder_$c/=_info;
 },
 GHC.ByteOrder.$fEqByteOrder_$c/=_entry() //  [R2, R3]
         { info_tbl: [(cczz4,
                       label: GHC.ByteOrder.$fEqByteOrder_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczz4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczz5; else goto cczz6;
       cczz5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEqByteOrder_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczz6: // global
           I64[Sp - 16] = block_cczyX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczzJ; else goto cczyY;
       uczzJ: // global
           call _cczyX(R1) args: 0, res: 0, upd: 0;
       cczyY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczyX() //  [R1]
         { info_tbl: [(cczyX,
                       label: block_cczyX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczyX: // global
           _scylh::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczz1; else goto cczz2;
       cczz1: // global
           I64[Sp + 8] = block_cczz9_info;
           R1 = _scylh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczzH; else goto cczzb;
       uczzH: // global
           call _cczz9(R1) args: 0, res: 0, upd: 0;
       cczzb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczz2: // global
           I64[Sp + 8] = block_cczzo_info;
           R1 = _scylh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczzI; else goto cczzq;
       uczzI: // global
           call _cczzo(R1) args: 0, res: 0, upd: 0;
       cczzq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczz9() //  [R1]
         { info_tbl: [(cczz9,
                       label: block_cczz9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczz9: // global
           if (R1 & 7 == 1) goto uczzF; else goto uczzG;
       uczzF: // global
           Sp = Sp + 8;
           call _cczzA() args: 0, res: 0, upd: 0;
       uczzG: // global
           Sp = Sp + 8;
           call _cczzw() args: 0, res: 0, upd: 0;
     }
 },
 _cczzo() //  [R1]
         { info_tbl: [(cczzo,
                       label: block_cczzo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczzo: // global
           if (R1 & 7 == 1) goto uczzD; else goto uczzE;
       uczzD: // global
           Sp = Sp + 8;
           call _cczzw() args: 0, res: 0, upd: 0;
       uczzE: // global
           Sp = Sp + 8;
           call _cczzA() args: 0, res: 0, upd: 0;
     }
 },
 _cczzw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczzw: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cczzA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczzA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.57415022 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_closure" {
     GHC.ByteOrder.$fEqByteOrder_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.ByteOrder.$fEqByteOrder_$c==_closure+2;
         const GHC.ByteOrder.$fEqByteOrder_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.577120692 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c<=_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c<=_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c<=_entry() //  [R2, R3]
         { info_tbl: [(cczAt,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczAt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczAu; else goto cczAv;
       cczAu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczAv: // global
           I64[Sp - 16] = block_cczAm_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczAX; else goto cczAn;
       uczAX: // global
           call _cczAm(R1) args: 0, res: 0, upd: 0;
       cczAn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczAm() //  [R1]
         { info_tbl: [(cczAm,
                       label: block_cczAm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczAm: // global
           _scyll::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczAq; else goto cczAr;
       cczAq: // global
           I64[Sp + 8] = block_cczAy_info;
           R1 = _scyll::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczAV; else goto cczAA;
       uczAV: // global
           call _cczAy(R1) args: 0, res: 0, upd: 0;
       cczAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczAr: // global
           I64[Sp + 8] = block_cczAN_info;
           R1 = _scyll::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczAW; else goto cczAP;
       uczAW: // global
           call _cczAN() args: 0, res: 0, upd: 0;
       cczAP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczAy() //  [R1]
         { info_tbl: [(cczAy,
                       label: block_cczAy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczAy: // global
           if (R1 & 7 == 1) goto cczAG; else goto cczAK;
       cczAG: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczAK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cczAN() //  []
         { info_tbl: [(cczAN,
                       label: block_cczAN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczAN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.587153897 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$cmax_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$cmax_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$cmax_entry() //  [R2, R3]
         { info_tbl: [(cczBx,
                       label: GHC.ByteOrder.$fOrdByteOrder_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczBx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczBy; else goto cczBz;
       cczBy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczBz: // global
           I64[Sp - 16] = block_cczBq_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczBN; else goto cczBr;
       uczBN: // global
           call _cczBq(R1) args: 0, res: 0, upd: 0;
       cczBr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczBq() //  [R1]
         { info_tbl: [(cczBq,
                       label: block_cczBq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczBq: // global
           _scylq::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczBu; else goto cczBv;
       cczBu: // global
           R1 = _scylq::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cczBv: // global
           I64[Sp + 8] = block_cczBF_info;
           R1 = _scylq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczBM; else goto cczBH;
       uczBM: // global
           call _cczBF() args: 0, res: 0, upd: 0;
       cczBH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczBF() //  []
         { info_tbl: [(cczBF,
                       label: block_cczBF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczBF: // global
           R1 = GHC.ByteOrder.LittleEndian_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.595325772 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c>=_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c>=_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c>=_entry() //  [R2, R3]
         { info_tbl: [(cczCh,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczCh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczCi; else goto cczCj;
       cczCi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczCj: // global
           I64[Sp - 16] = block_cczCa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczCL; else goto cczCb;
       uczCL: // global
           call _cczCa(R1) args: 0, res: 0, upd: 0;
       cczCb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczCa() //  [R1]
         { info_tbl: [(cczCa,
                       label: block_cczCa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczCa: // global
           _scylv::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczCe; else goto cczCf;
       cczCe: // global
           I64[Sp + 8] = block_cczCm_info;
           R1 = _scylv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczCJ; else goto cczCo;
       uczCJ: // global
           call _cczCm(R1) args: 0, res: 0, upd: 0;
       cczCo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczCf: // global
           I64[Sp + 8] = block_cczCB_info;
           R1 = _scylv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczCK; else goto cczCD;
       uczCK: // global
           call _cczCB() args: 0, res: 0, upd: 0;
       cczCD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczCm() //  [R1]
         { info_tbl: [(cczCm,
                       label: block_cczCm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczCm: // global
           if (R1 & 7 == 1) goto cczCu; else goto cczCy;
       cczCu: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczCy: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cczCB() //  []
         { info_tbl: [(cczCB,
                       label: block_cczCB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczCB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.604956804 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c>_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c>_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c>_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c>_entry() //  [R2, R3]
         { info_tbl: [(cczDe,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczDe: // global
           _scylA::P64 = R3;
           R3 = R2;
           R2 = _scylA::P64;
           call GHC.ByteOrder.$fOrdByteOrder_$c<_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.609368117 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$cmin_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$cmin_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$cmin_entry() //  [R2, R3]
         { info_tbl: [(cczDw,
                       label: GHC.ByteOrder.$fOrdByteOrder_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczDw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczDx; else goto cczDy;
       cczDx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczDy: // global
           I64[Sp - 16] = block_cczDp_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczDM; else goto cczDq;
       uczDM: // global
           call _cczDp(R1) args: 0, res: 0, upd: 0;
       cczDq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczDp() //  [R1]
         { info_tbl: [(cczDp,
                       label: block_cczDp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczDp: // global
           _scylB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczDt; else goto cczDu;
       cczDt: // global
           I64[Sp + 8] = block_cczDB_info;
           R1 = _scylB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczDL; else goto cczDD;
       uczDL: // global
           call _cczDB() args: 0, res: 0, upd: 0;
       cczDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczDu: // global
           R1 = _scylB::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cczDB() //  []
         { info_tbl: [(cczDB,
                       label: block_cczDB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczDB: // global
           R1 = GHC.ByteOrder.BigEndian_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.616705001 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_closure" {
     GHC.ByteOrder.$fOrdByteOrder_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.ByteOrder.$fEqByteOrder_closure+1;
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c<_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c>_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.61898174 UTC

[section ""data" . GHC.ByteOrder.targetByteOrder_closure" {
     GHC.ByteOrder.targetByteOrder_closure:
         const GHC.ByteOrder.LittleEndian_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.620657044 UTC

[section ""data" . lvl_rcykn_closure" {
     lvl_rcykn_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.622492296 UTC

[section ""data" . lvl1_rcyko_closure" {
     lvl1_rcyko_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.624625239 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_entry() //  [R2]
         { info_tbl: [(cczEk,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczEk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cczEl; else goto cczEm;
       cczEl: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczEm: // global
           I64[Sp - 8] = block_cczEd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uczEt; else goto cczEe;
       uczEt: // global
           call _cczEd(R1) args: 0, res: 0, upd: 0;
       cczEe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczEd() //  [R1]
         { info_tbl: [(cczEd,
                       label: block_cczEd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczEd: // global
           if (R1 & 7 == 1) goto cczEh; else goto cczEi;
       cczEh: // global
           R1 = lvl_rcykn_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczEi: // global
           R1 = lvl1_rcyko_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.630833726 UTC

[section ""cstring" . lvl2_rcykp_bytes" {
     lvl2_rcykp_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.63281796 UTC

[section ""data" . lvl3_rcykq_closure" {
     lvl3_rcykq_closure:
         const lvl3_rcykq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rcykq_entry() //  [R1]
         { info_tbl: [(cczEO,
                       label: lvl3_rcykq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczEO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczEP; else goto cczEQ;
       cczEP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczEQ: // global
           (_cczEL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczEL::I64 == 0) goto cczEN; else goto cczEM;
       cczEN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczEM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczEL::I64;
           R2 = lvl2_rcykp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.636896927 UTC

[section ""cstring" . GHC.ByteOrder.$trModule4_bytes" {
     GHC.ByteOrder.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.638971115 UTC

[section ""data" . lvl4_rcykr_closure" {
     lvl4_rcykr_closure:
         const lvl4_rcykr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rcykr_entry() //  [R1]
         { info_tbl: [(cczF5,
                       label: lvl4_rcykr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczF5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczF6; else goto cczF7;
       cczF6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczF7: // global
           (_cczF2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczF2::I64 == 0) goto cczF4; else goto cczF3;
       cczF4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczF3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczF2::I64;
           R2 = GHC.ByteOrder.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.643865737 UTC

[section ""cstring" . GHC.ByteOrder.$trModule2_bytes" {
     GHC.ByteOrder.$trModule2_bytes:
         I8[] [71,72,67,46,66,121,116,101,79,114,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.645797769 UTC

[section ""data" . lvl5_rcyks_closure" {
     lvl5_rcyks_closure:
         const lvl5_rcyks_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rcyks_entry() //  [R1]
         { info_tbl: [(cczFm,
                       label: lvl5_rcyks_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczFm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczFn; else goto cczFo;
       cczFn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczFo: // global
           (_cczFj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczFj::I64 == 0) goto cczFl; else goto cczFk;
       cczFl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczFk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczFj::I64;
           R2 = GHC.ByteOrder.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.649664116 UTC

[section ""cstring" . lvl6_rcykt_bytes" {
     lvl6_rcykt_bytes:
         I8[] [46,47,71,72,67,47,66,121,116,101,79,114,100,101,114,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.651504221 UTC

[section ""data" . lvl7_rcyku_closure" {
     lvl7_rcyku_closure:
         const lvl7_rcyku_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rcyku_entry() //  [R1]
         { info_tbl: [(cczFD,
                       label: lvl7_rcyku_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczFD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczFE; else goto cczFF;
       cczFE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczFF: // global
           (_cczFA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczFA::I64 == 0) goto cczFC; else goto cczFB;
       cczFC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczFB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczFA::I64;
           R2 = lvl6_rcykt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.655440509 UTC

[section ""data" . lvl8_rcykv_closure" {
     lvl8_rcykv_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.657170526 UTC

[section ""data" . lvl9_rcykw_closure" {
     lvl9_rcykw_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.658946856 UTC

[section ""data" . lvl10_rcykx_closure" {
     lvl10_rcykx_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.660632366 UTC

[section ""data" . lvl11_rcyky_closure" {
     lvl11_rcyky_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl4_rcykr_closure;
         const lvl5_rcyks_closure;
         const lvl7_rcyku_closure;
         const lvl8_rcykv_closure+1;
         const lvl9_rcykw_closure+1;
         const lvl8_rcykv_closure+1;
         const lvl10_rcykx_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.662809438 UTC

[section ""data" . lvl12_rcykz_closure" {
     lvl12_rcykz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl3_rcykq_closure;
         const lvl11_rcyky_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.66465099 UTC

[section ""cstring" . lvl13_rcykA_bytes" {
     lvl13_rcykA_bytes:
         I8[] [112,114,101,100,123,66,121,116,101,79,114,100,101,114,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,112,114,101,100,39,32,111,102,32,102,105,114,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.666768579 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder3_closure" {
     GHC.ByteOrder.$fEnumByteOrder3_closure:
         const GHC.ByteOrder.$fEnumByteOrder3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder3_entry() //  [R1]
         { info_tbl: [(cczG1,
                       label: GHC.ByteOrder.$fEnumByteOrder3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczG1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cczG2; else goto cczG3;
       cczG2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczG3: // global
           (_cczFW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczFW::I64 == 0) goto cczFY; else goto cczFX;
       cczFY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczFX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczFW::I64;
           I64[Sp - 24] = block_cczFZ_info;
           R2 = lvl13_rcykA_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cczFZ() //  [R1]
         { info_tbl: [(cczFZ,
                       label: block_cczFZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczFZ: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.67413705 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cpred_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cpred_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cpred_entry() //  [R2]
         { info_tbl: [(cczGs,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczGs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cczGt; else goto cczGu;
       cczGt: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczGu: // global
           I64[Sp - 8] = block_cczGl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uczGB; else goto cczGm;
       uczGB: // global
           call _cczGl(R1) args: 0, res: 0, upd: 0;
       cczGm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczGl() //  [R1]
         { info_tbl: [(cczGl,
                       label: block_cczGl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczGl: // global
           if (R1 & 7 == 1) goto cczGp; else goto cczGq;
       cczGp: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cczGq: // global
           R1 = GHC.ByteOrder.BigEndian_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.679547221 UTC

[section ""cstring" . lvl14_rcykB_bytes" {
     lvl14_rcykB_bytes:
         I8[] [115,117,99,99,123,66,121,116,101,79,114,100,101,114,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,115,117,99,99,39,32,111,102,32,108,97,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.681784161 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder4_closure" {
     GHC.ByteOrder.$fEnumByteOrder4_closure:
         const GHC.ByteOrder.$fEnumByteOrder4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder4_entry() //  [R1]
         { info_tbl: [(cczGY,
                       label: GHC.ByteOrder.$fEnumByteOrder4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczGY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cczGZ; else goto cczH0;
       cczGZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczH0: // global
           (_cczGT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczGT::I64 == 0) goto cczGV; else goto cczGU;
       cczGV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczGU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczGT::I64;
           I64[Sp - 24] = block_cczGW_info;
           R2 = lvl14_rcykB_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cczGW() //  [R1]
         { info_tbl: [(cczGW,
                       label: block_cczGW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczGW: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.687589595 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$csucc_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$csucc_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$csucc_entry() //  [R2]
         { info_tbl: [(cczHp,
                       label: GHC.ByteOrder.$fEnumByteOrder_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczHp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cczHq; else goto cczHr;
       cczHq: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczHr: // global
           I64[Sp - 8] = block_cczHi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uczHy; else goto cczHj;
       uczHy: // global
           call _cczHi(R1) args: 0, res: 0, upd: 0;
       cczHj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczHi() //  [R1]
         { info_tbl: [(cczHi,
                       label: block_cczHi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczHi: // global
           if (R1 & 7 == 1) goto cczHm; else goto cczHn;
       cczHm: // global
           R1 = GHC.ByteOrder.LittleEndian_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczHn: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.6931222 UTC

[section ""cstring" . lvl15_rcykC_bytes" {
     lvl15_rcykC_bytes:
         I8[] [41,32,105,115,32,111,117,116,115,105,100,101,32,111,102,32,101,110,117,109,101,114,97,116,105,111,110,39,115,32,114,97,110,103,101,32,40,48,44]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.695141198 UTC

[section ""cstring" . lvl16_rcykD_bytes" {
     lvl16_rcykD_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.696988828 UTC

[section ""data" . lvl17_rcykE_closure" {
     lvl17_rcykE_closure:
         const lvl17_rcykE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_rcykE_entry() //  [R1]
         { info_tbl: [(cczHU,
                       label: lvl17_rcykE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczHU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczHV; else goto cczHW;
       cczHV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczHW: // global
           (_cczHR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczHR::I64 == 0) goto cczHT; else goto cczHS;
       cczHT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczHS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczHR::I64;
           R2 = lvl16_rcykD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.701373376 UTC

[section ""data" . lvl18_rcykF_closure" {
     lvl18_rcykF_closure:
         const lvl18_rcykF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_rcykF_entry() //  [R1]
         { info_tbl: [(cczId,
                       label: lvl18_rcykF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczId: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cczIe; else goto cczIf;
       cczIe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczIf: // global
           (_cczI7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczI7::I64 == 0) goto cczI9; else goto cczI8;
       cczI9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczI8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczI7::I64;
           I64[Sp - 24] = block_cczIa_info;
           R4 = lvl17_rcykE_closure;
           R3 = 1;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cczIa() //  [R1, R2]
         { info_tbl: [(cczIa,
                       label: block_cczIa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczIa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczIi; else goto cczIh;
       cczIi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cczIh: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.708016934 UTC

[section ""data" . lvl19_rcykG_closure" {
     lvl19_rcykG_closure:
         const lvl19_rcykG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_rcykG_entry() //  [R1]
         { info_tbl: [(cczIA,
                       label: lvl19_rcykG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczIA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczIB; else goto cczIC;
       cczIB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczIC: // global
           (_cczIx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczIx::I64 == 0) goto cczIz; else goto cczIy;
       cczIz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczIy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczIx::I64;
           R3 = lvl18_rcykF_closure;
           R2 = lvl15_rcykC_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.712236421 UTC

[section ""cstring" . lvl20_rcykH_bytes" {
     lvl20_rcykH_bytes:
         I8[] [116,111,69,110,117,109,123,66,121,116,101,79,114,100,101,114,125,58,32,116,97,103,32,40]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.715694148 UTC

[section ""data" . GHC.ByteOrder.$wlvl_closure" {
     GHC.ByteOrder.$wlvl_closure:
         const GHC.ByteOrder.$wlvl_info;
         const 0;
 },
 sat_scylU_entry() //  [R1]
         { info_tbl: [(cczIW,
                       label: sat_scylU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczIW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cczIX; else goto cczIY;
       cczIX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczIY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cczIT_info;
           R4 = lvl19_rcykG_closure;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cczIT() //  [R1, R2]
         { info_tbl: [(cczIT,
                       label: block_cczIT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczIT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczJ1; else goto cczJ0;
       cczJ1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cczJ0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$wlvl_entry() //  [R2]
         { info_tbl: [(cczJ4,
                       label: GHC.ByteOrder.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczJ4: // global
           _scylQ::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cczJ5; else goto cczJ6;
       cczJ6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczJ8; else goto cczJ7;
       cczJ8: // global
           HpAlloc = 24;
           goto cczJ5;
       cczJ5: // global
           R2 = _scylQ::I64;
           R1 = GHC.ByteOrder.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczJ7: // global
           I64[Hp - 16] = sat_scylU_info;
           I64[Hp] = _scylQ::I64;
           I64[Sp - 8] = block_cczJ2_info;
           R3 = Hp - 16;
           R2 = lvl20_rcykH_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cczJ2() //  [R1]
         { info_tbl: [(cczJ2,
                       label: block_cczJ2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczJ2: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.725582928 UTC

[section ""data" . GHC.ByteOrder.$w$ctoEnum_closure" {
     GHC.ByteOrder.$w$ctoEnum_closure:
         const GHC.ByteOrder.$w$ctoEnum_info;
         const 0;
 },
 GHC.ByteOrder.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(cczJB,
                       label: GHC.ByteOrder.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczJB: // global
           _scylW::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto cczJJ; else goto cczJA;
       cczJA: // global
           if (%MO_S_Gt_W64(_scylW::I64, 1)) goto cczJJ; else goto cczJK;
       cczJJ: // global
           R2 = _scylW::I64;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       cczJK: // global
           R1 = I64[(_scylW::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.729609816 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_entry() //  [R2]
         { info_tbl: [(cczJY,
                       label: GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczJY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cczJZ; else goto cczK0;
       cczJZ: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczK0: // global
           I64[Sp - 8] = block_cczJV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uczK4; else goto cczJW;
       uczK4: // global
           call _cczJV(R1) args: 0, res: 0, upd: 0;
       cczJW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczJV() //  [R1]
         { info_tbl: [(cczJV,
                       label: block_cczJV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczJV: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.ByteOrder.$w$ctoEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.736151487 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go2_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go2_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go2_info;
 },
 sat_scym6_entry() //  [R1]
         { info_tbl: [(cczKq,
                       label: sat_scym6_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczKq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczKr; else goto cczKs;
       cczKr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczKs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scym4::I64 = I64[R1 + 16];
           if (_scym4::I64 != 1) goto cczKo; else goto cczKp;
       cczKo: // global
           R2 = _scym4::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
       cczKp: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scym3_entry() //  [R1]
         { info_tbl: [(cczKz,
                       label: sat_scym3_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczKz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczKA; else goto cczKB;
       cczKA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczKB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_go2_entry() //  [R2]
         { info_tbl: [(cczKD,
                       label: GHC.ByteOrder.$fEnumByteOrder_go2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczKD: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cczKH; else goto cczKG;
       cczKH: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczKG: // global
           I64[Hp - 64] = sat_scym6_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scym3_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.745297401 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder2_closure" {
     GHC.ByteOrder.$fEnumByteOrder2_closure:
         const GHC.ByteOrder.$fEnumByteOrder2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder2_entry() //  [R1]
         { info_tbl: [(cczL6,
                       label: GHC.ByteOrder.$fEnumByteOrder2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczL6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczL7; else goto cczL8;
       cczL7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczL8: // global
           (_cczL3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczL3::I64 == 0) goto cczL5; else goto cczL4;
       cczL5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczL4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczL3::I64;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.750108352 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder1_closure" {
     GHC.ByteOrder.$fEnumByteOrder1_closure:
         const GHC.ByteOrder.$fEnumByteOrder1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder1_entry() //  [R1]
         { info_tbl: [(cczLm,
                       label: GHC.ByteOrder.$fEnumByteOrder1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczLm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczLn; else goto cczLo;
       cczLn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczLo: // global
           (_cczLj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczLj::I64 == 0) goto cczLl; else goto cczLk;
       cczLl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczLk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczLj::I64;
           R2 = 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.754215598 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_entry() //  [R2]
         { info_tbl: [(cczLH,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczLH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cczLI; else goto cczLJ;
       cczLI: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczLJ: // global
           I64[Sp - 8] = block_cczLA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uczLQ; else goto cczLB;
       uczLQ: // global
           call _cczLA(R1) args: 0, res: 0, upd: 0;
       cczLB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczLA() //  [R1]
         { info_tbl: [(cczLA,
                       label: block_cczLA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczLA: // global
           if (R1 & 7 == 1) goto cczLE; else goto cczLF;
       cczLE: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cczLF: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.765213467 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info;
 },
 sat_scymq_entry() //  [R1]
         { info_tbl: [(cczMP,
                       label: sat_scymq_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczMP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczMQ; else goto cczMR;
       cczMQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczMR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scyml_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymo_entry() //  [R1]
         { info_tbl: [(cczMW,
                       label: sat_scymo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczMW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczMX; else goto cczMY;
       cczMX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczMY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymr_entry() //  [R1]
         { info_tbl: [(cczN4,
                       label: sat_scymr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczN4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczN5; else goto cczN6;
       cczN5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczN6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scyml_entry() //  [R1, R2]
         { info_tbl: [(cczNa,
                       label: go_dn_scyml_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczNa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczNe; else goto cczNd;
       cczNe: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczNd: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto cczN8; else goto cczN9;
       cczN8: // global
           _scymj::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scymq_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scymj::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scymo_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczN9: // global
           I64[Hp - 80] = sat_scymr_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczNg::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczNg::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyms_entry() //  [R1]
         { info_tbl: [(cczNh,
                       label: sat_scyms_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczNh: // global
           _scyms::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczNi; else goto cczNj;
       cczNj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczNl; else goto cczNk;
       cczNl: // global
           HpAlloc = 24;
           goto cczNi;
       cczNi: // global
           R1 = _scyms::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczNk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyms::P64;
           _scyme::I64 = I64[_scyms::P64 + 24];
           _scymj::I64 = _scyme::I64 - I64[_scyms::P64 + 16];
           I64[Hp - 16] = go_dn_scyml_info;
           I64[Hp - 8] = _scymj::I64;
           I64[Hp] = 1 - _scymj::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scyml_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymi_entry() //  [R1]
         { info_tbl: [(cczNq,
                       label: sat_scymi_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczNq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczNr; else goto cczNs;
       cczNr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczNs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymu_entry() //  [R1]
         { info_tbl: [(cczNB,
                       label: sat_scymu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczNB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczNC; else goto cczND;
       cczNC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczND: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymE_entry() //  [R1]
         { info_tbl: [(cczO6,
                       label: sat_scymE_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczO6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczO7; else goto cczO8;
       cczO7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczO8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scymz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymC_entry() //  [R1]
         { info_tbl: [(cczOd,
                       label: sat_scymC_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczOd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczOe; else goto cczOf;
       cczOe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczOf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymF_entry() //  [R1]
         { info_tbl: [(cczOl,
                       label: sat_scymF_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczOl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczOm; else goto cczOn;
       cczOm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczOn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scymz_entry() //  [R1, R2]
         { info_tbl: [(cczOr,
                       label: go_up_scymz_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczOr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczOv; else goto cczOu;
       cczOv: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczOu: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto cczOp; else goto cczOq;
       cczOp: // global
           _scymx::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scymE_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scymx::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scymC_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczOq: // global
           I64[Hp - 80] = sat_scymF_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczOx::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczOx::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scymG_entry() //  [R1]
         { info_tbl: [(cczOy,
                       label: sat_scymG_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczOy: // global
           _scymG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczOz; else goto cczOA;
       cczOA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczOC; else goto cczOB;
       cczOC: // global
           HpAlloc = 24;
           goto cczOz;
       cczOz: // global
           R1 = _scymG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczOB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scymG::P64;
           _scyme::I64 = I64[_scymG::P64 + 24];
           _scymx::I64 = _scyme::I64 - I64[_scymG::P64 + 16];
           I64[Hp - 16] = go_up_scymz_info;
           I64[Hp - 8] = _scymx::I64;
           I64[Hp] = 1 - _scymx::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scymz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymw_entry() //  [R1]
         { info_tbl: [(cczOH,
                       label: sat_scymw_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczOH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczOI; else goto cczOJ;
       cczOI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczOJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymI_entry() //  [R1]
         { info_tbl: [(cczOS,
                       label: sat_scymI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczOS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczOT; else goto cczOU;
       cczOT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczOU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymT_entry() //  [R1]
         { info_tbl: [(cczPq,
                       label: sat_scymT_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczPq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczPr; else goto cczPs;
       cczPr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczPs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scymO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymR_entry() //  [R1]
         { info_tbl: [(cczPx,
                       label: sat_scymR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczPx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczPy; else goto cczPz;
       cczPy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczPz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymU_entry() //  [R1]
         { info_tbl: [(cczPF,
                       label: sat_scymU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczPF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczPG; else goto cczPH;
       cczPG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczPH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scymO_entry() //  [R1, R2]
         { info_tbl: [(cczPL,
                       label: go_dn_scymO_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczPL: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczPP; else goto cczPO;
       cczPP: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczPO: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto cczPJ; else goto cczPK;
       cczPJ: // global
           _scymM::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scymT_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scymM::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scymR_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczPK: // global
           I64[Hp - 80] = sat_scymU_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczPR::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczPR::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scymV_entry() //  [R1]
         { info_tbl: [(cczPS,
                       label: sat_scymV_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczPS: // global
           _scymV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczPT; else goto cczPU;
       cczPU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczPW; else goto cczPV;
       cczPW: // global
           HpAlloc = 24;
           goto cczPT;
       cczPT: // global
           R1 = _scymV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczPV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scymV::P64;
           _scyme::I64 = I64[_scymV::P64 + 24];
           _scymM::I64 = _scyme::I64 - I64[_scymV::P64 + 16];
           I64[Hp - 16] = go_dn_scymO_info;
           I64[Hp - 8] = _scymM::I64;
           I64[Hp] = 0 - _scymM::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scymO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymL_entry() //  [R1]
         { info_tbl: [(cczQ1,
                       label: sat_scymL_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczQ1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczQ2; else goto cczQ3;
       cczQ2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczQ3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymX_entry() //  [R1]
         { info_tbl: [(cczQc,
                       label: sat_scymX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczQc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczQd; else goto cczQe;
       cczQd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczQe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyn7_entry() //  [R1]
         { info_tbl: [(cczQH,
                       label: sat_scyn7_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczQH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczQI; else goto cczQJ;
       cczQI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczQJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scyn2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyn5_entry() //  [R1]
         { info_tbl: [(cczQO,
                       label: sat_scyn5_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczQO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczQP; else goto cczQQ;
       cczQP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczQQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyn8_entry() //  [R1]
         { info_tbl: [(cczQW,
                       label: sat_scyn8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczQW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczQX; else goto cczQY;
       cczQX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczQY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scyn2_entry() //  [R1, R2]
         { info_tbl: [(cczR2,
                       label: go_up_scyn2_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczR2: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczR6; else goto cczR5;
       cczR6: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczR5: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto cczR0; else goto cczR1;
       cczR0: // global
           _scyn0::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyn7_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyn0::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyn5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczR1: // global
           I64[Hp - 80] = sat_scyn8_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczR8::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczR8::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyn9_entry() //  [R1]
         { info_tbl: [(cczR9,
                       label: sat_scyn9_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczR9: // global
           _scyn9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczRa; else goto cczRb;
       cczRb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczRd; else goto cczRc;
       cczRd: // global
           HpAlloc = 24;
           goto cczRa;
       cczRa: // global
           R1 = _scyn9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczRc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyn9::P64;
           _scyme::I64 = I64[_scyn9::P64 + 24];
           _scyn0::I64 = _scyme::I64 - I64[_scyn9::P64 + 16];
           I64[Hp - 16] = go_up_scyn2_info;
           I64[Hp - 8] = _scyn0::I64;
           I64[Hp] = 0 - _scyn0::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scyn2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scymZ_entry() //  [R1]
         { info_tbl: [(cczRi,
                       label: sat_scymZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczRi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczRj; else goto cczRk;
       cczRj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczRk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynb_entry() //  [R1]
         { info_tbl: [(cczRt,
                       label: sat_scynb_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczRt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczRu; else goto cczRv;
       cczRu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczRv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(cczRD,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczRD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczRE; else goto cczRF;
       cczRE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczRF: // global
           I64[Sp - 16] = block_cczRw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczSN; else goto cczRx;
       uczSN: // global
           call _cczRw(R1) args: 0, res: 0, upd: 0;
       cczRx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczRw() //  [R1]
         { info_tbl: [(cczRw,
                       label: block_cczRw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczRw: // global
           _scyma::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczRA; else goto cczRB;
       cczRA: // global
           _scymc::I64 = 0;
           goto scymb;
       cczRB: // global
           _scymc::I64 = 1;
           goto scymb;
       scymb: // global
           I64[Sp] = block_cczRG_info;
           R1 = _scyma::P64;
           I64[Sp + 8] = _scymc::I64;
           if (R1 & 7 != 0) goto uczSM; else goto cczSq;
       uczSM: // global
           call _cczRG(R1) args: 0, res: 0, upd: 0;
       cczSq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczRG() //  [R1]
         { info_tbl: [(cczRG,
                       label: block_cczRG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczRG: // global
           if (R1 & 7 == 1) goto cczSw; else goto cczSA;
       cczSw: // global
           I64[Sp] = 0;
           goto uczSP;
       cczSA: // global
           I64[Sp] = 1;
           goto uczSP;
       uczSP: // global
           call _cczMg() args: 0, res: 0, upd: 0;
     }
 },
 _cczMg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczMg: // global
           Hp = Hp + 80;
           _scyme::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cczRK; else goto cczRJ;
       cczRK: // global
           HpAlloc = 80;
           I64[Sp] = block_cczMf_info;
           R1 = _scyme::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cczRJ: // global
           _scymc::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_scymc::I64,
                            _scyme::I64)) goto cczS5; else goto cczSp;
       cczS5: // global
           if (%MO_S_Lt_W64(_scyme::I64,
                            _scymc::I64)) goto cczRU; else goto cczS3;
       cczRU: // global
           if (%MO_S_Le_W64(1, _scyme::I64)) goto cczRN; else goto cczRS;
       cczRN: // global
           I64[Hp - 72] = sat_scyms_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymi_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczRS: // global
           if (%MO_S_Gt_W64(1, _scymc::I64)) goto cczSm; else goto cczRQ;
       cczRQ: // global
           I64[Hp - 72] = sat_scymu_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczRO::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczRO::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczS3: // global
           if (%MO_S_Ge_W64(1, _scyme::I64)) goto cczRX; else goto cczS2;
       cczRX: // global
           I64[Hp - 72] = sat_scymG_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymw_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczS2: // global
           if (%MO_S_Lt_W64(1, _scymc::I64)) goto cczSm; else goto cczS0;
       cczS0: // global
           I64[Hp - 72] = sat_scymI_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczRY::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczRY::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczSp: // global
           if (%MO_S_Lt_W64(_scyme::I64,
                            _scymc::I64)) goto cczSf; else goto cczSo;
       cczSf: // global
           if (%MO_S_Le_W64(0, _scyme::I64)) goto cczS8; else goto cczSd;
       cczS8: // global
           I64[Hp - 72] = sat_scymV_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymL_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczSd: // global
           if (%MO_S_Gt_W64(0, _scymc::I64)) goto cczSm; else goto cczSb;
       cczSb: // global
           I64[Hp - 72] = sat_scymX_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczS9::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczS9::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczSo: // global
           if (%MO_S_Ge_W64(0, _scyme::I64)) goto cczSi; else goto cczSn;
       cczSi: // global
           I64[Hp - 72] = sat_scyn9_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymZ_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczSn: // global
           if (%MO_S_Lt_W64(0, _scymc::I64)) goto cczSm; else goto cczSl;
       cczSm: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczSl: // global
           I64[Hp - 72] = sat_scynb_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczSj::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczSj::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cczMf() //  [R1]
         { info_tbl: [(cczMf,
                       label: block_cczMf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczMf: // global
           I64[Sp] = R1;
           call _cczMg() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.840774665 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go1_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go1_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go1_info;
         const 0;
 },
 sat_scynk_entry() //  [R1]
         { info_tbl: [(cczWD,
                       label: sat_scynk_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczWD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczWE; else goto cczWF;
       cczWE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczWF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyni::I64 = I64[R1 + 16];
           if (_scyni::I64 != 0) goto cczWB; else goto cczWC;
       cczWB: // global
           R2 = _scyni::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go1_entry(R2) args: 24, res: 0, upd: 24;
       cczWC: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynh_entry() //  [R1]
         { info_tbl: [(cczWR,
                       label: sat_scynh_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczWR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczWS; else goto cczX0;
       cczWS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczX0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyne::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyne::I64, 0)) goto cczWY; else goto cczWQ;
       cczWQ: // global
           if (%MO_S_Gt_W64(_scyne::I64, 1)) goto cczWY; else goto cczWZ;
       cczWY: // global
           R2 = _scyne::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczWZ: // global
           R1 = I64[(_scyne::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_go1_entry() //  [R2]
         { info_tbl: [(cczX2,
                       label: GHC.ByteOrder.$fEnumByteOrder_go1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczX2: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cczX6; else goto cczX5;
       cczX6: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczX5: // global
           I64[Hp - 64] = sat_scynk_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scynh_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.85140394 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go_info;
         const 0;
 },
 sat_scynr_entry() //  [R1]
         { info_tbl: [(cczXB,
                       label: sat_scynr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczXB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczXC; else goto cczXD;
       cczXC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczXD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynp::I64 = I64[R1 + 16];
           if (_scynp::I64 != 1) goto cczXz; else goto cczXA;
       cczXz: // global
           R2 = _scynp::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go_entry(R2) args: 24, res: 0, upd: 24;
       cczXA: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyno_entry() //  [R1]
         { info_tbl: [(cczXP,
                       label: sat_scyno_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczXP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczXQ; else goto cczXY;
       cczXQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczXY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynl::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynl::I64, 0)) goto cczXW; else goto cczXO;
       cczXO: // global
           if (%MO_S_Gt_W64(_scynl::I64, 1)) goto cczXW; else goto cczXX;
       cczXW: // global
           R2 = _scynl::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczXX: // global
           R1 = I64[(_scynl::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_go_entry() //  [R2]
         { info_tbl: [(cczY0,
                       label: GHC.ByteOrder.$fEnumByteOrder_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczY0: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cczY4; else goto cczY3;
       cczY4: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczY3: // global
           I64[Hp - 64] = sat_scynr_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyno_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.86048672 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(cczYA,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczYA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczYB; else goto cczYC;
       cczYB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczYC: // global
           I64[Sp - 16] = block_cczYt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczZb; else goto cczYu;
       uczZb: // global
           call _cczYt(R1) args: 0, res: 0, upd: 0;
       cczYu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczYt() //  [R1]
         { info_tbl: [(cczYt,
                       label: block_cczYt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczYt: // global
           _scynt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczYx; else goto cczYy;
       cczYx: // global
           _scynv::I64 = 0;
           goto scynu;
       cczYy: // global
           _scynv::I64 = 1;
           goto scynu;
       scynu: // global
           I64[Sp] = block_cczYG_info;
           R1 = _scynt::P64;
           I64[Sp + 8] = _scynv::I64;
           if (R1 & 7 != 0) goto uczZa; else goto cczYI;
       uczZa: // global
           call _cczYG(R1) args: 0, res: 0, upd: 0;
       cczYI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczYG() //  [R1]
         { info_tbl: [(cczYG,
                       label: block_cczYG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczYG: // global
           _scynv::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cczYT; else goto cczZ2;
       cczYT: // global
           if (%MO_S_Gt_W64(_scynv::I64, 0)) goto cczZ1; else goto cczYQ;
       cczYQ: // global
           R2 = _scynv::I64;
           Sp = Sp + 16;
           call GHC.ByteOrder.$fEnumByteOrder_go1_entry(R2) args: 8, res: 0, upd: 8;
       cczZ2: // global
           if (%MO_S_Gt_W64(_scynv::I64, 1)) goto cczZ1; else goto cczZ0;
       cczZ1: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczZ0: // global
           R2 = _scynv::I64;
           Sp = Sp + 16;
           call GHC.ByteOrder.$fEnumByteOrder_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.876362202 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info;
         const 0;
 },
 sat_scynW_entry() //  [R1]
         { info_tbl: [(ccA0h,
                       label: sat_scynW_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA0h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA0i; else goto ccA0j;
       ccA0i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA0j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scynP_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynU_entry() //  [R1]
         { info_tbl: [(ccA0t,
                       label: sat_scynU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA0t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA0u; else goto ccA0C;
       ccA0u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA0C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynQ::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynQ::I64, 0)) goto ccA0A; else goto ccA0s;
       ccA0s: // global
           if (%MO_S_Gt_W64(_scynQ::I64, 1)) goto ccA0A; else goto ccA0B;
       ccA0A: // global
           R2 = _scynQ::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA0B: // global
           R1 = I64[(_scynQ::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynZ_entry() //  [R1]
         { info_tbl: [(ccA0N,
                       label: sat_scynZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA0N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA0O; else goto ccA0W;
       ccA0O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA0W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynQ::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynQ::I64, 0)) goto ccA0U; else goto ccA0M;
       ccA0M: // global
           if (%MO_S_Gt_W64(_scynQ::I64, 1)) goto ccA0U; else goto ccA0V;
       ccA0U: // global
           R2 = _scynQ::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA0V: // global
           R1 = I64[(_scynQ::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scynP_entry() //  [R1, R2]
         { info_tbl: [(ccA10,
                       label: go_dn_scynP_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA10: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccA14; else goto ccA13;
       ccA14: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccA13: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccA0Y; else goto ccA0Z;
       ccA0Y: // global
           _scynN::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scynW_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scynN::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scynU_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA0Z: // global
           I64[Hp - 80] = sat_scynZ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccA16::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccA16::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyo0_entry() //  [R1]
         { info_tbl: [(ccA17,
                       label: sat_scyo0_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA17: // global
           _scyo0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccA18; else goto ccA19;
       ccA19: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccA1b; else goto ccA1a;
       ccA1b: // global
           HpAlloc = 24;
           goto ccA18;
       ccA18: // global
           R1 = _scyo0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA1a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyo0::P64;
           _scynG::I64 = I64[_scyo0::P64 + 24];
           _scynN::I64 = _scynG::I64 - I64[_scyo0::P64 + 16];
           I64[Hp - 16] = go_dn_scynP_info;
           I64[Hp - 8] = _scynN::I64;
           I64[Hp] = 0 - _scynN::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scynP_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scynM_entry() //  [R1]
         { info_tbl: [(ccA1l,
                       label: sat_scynM_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA1l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA1m; else goto ccA1u;
       ccA1m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA1u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA1s; else goto ccA1k;
       ccA1k: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA1s; else goto ccA1t;
       ccA1s: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA1t: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyo4_entry() //  [R1]
         { info_tbl: [(ccA1I,
                       label: sat_scyo4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA1I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA1J; else goto ccA1R;
       ccA1J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA1R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA1P; else goto ccA1H;
       ccA1H: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA1P; else goto ccA1Q;
       ccA1P: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA1Q: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoi_entry() //  [R1]
         { info_tbl: [(ccA2k,
                       label: sat_scyoi_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA2k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA2l; else goto ccA2m;
       ccA2l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA2m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scyob_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyog_entry() //  [R1]
         { info_tbl: [(ccA2w,
                       label: sat_scyog_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA2w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA2x; else goto ccA2F;
       ccA2x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA2F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoc::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoc::I64, 0)) goto ccA2D; else goto ccA2v;
       ccA2v: // global
           if (%MO_S_Gt_W64(_scyoc::I64, 1)) goto ccA2D; else goto ccA2E;
       ccA2D: // global
           R2 = _scyoc::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA2E: // global
           R1 = I64[(_scyoc::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyol_entry() //  [R1]
         { info_tbl: [(ccA2Q,
                       label: sat_scyol_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA2Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA2R; else goto ccA2Z;
       ccA2R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA2Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoc::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoc::I64, 0)) goto ccA2X; else goto ccA2P;
       ccA2P: // global
           if (%MO_S_Gt_W64(_scyoc::I64, 1)) goto ccA2X; else goto ccA2Y;
       ccA2X: // global
           R2 = _scyoc::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA2Y: // global
           R1 = I64[(_scyoc::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scyob_entry() //  [R1, R2]
         { info_tbl: [(ccA33,
                       label: go_up_scyob_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA33: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccA37; else goto ccA36;
       ccA37: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccA36: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccA31; else goto ccA32;
       ccA31: // global
           _scyo9::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyoi_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyo9::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyog_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA32: // global
           I64[Hp - 80] = sat_scyol_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccA39::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccA39::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyom_entry() //  [R1]
         { info_tbl: [(ccA3a,
                       label: sat_scyom_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA3a: // global
           _scyom::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccA3b; else goto ccA3c;
       ccA3c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccA3e; else goto ccA3d;
       ccA3e: // global
           HpAlloc = 24;
           goto ccA3b;
       ccA3b: // global
           R1 = _scyom::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA3d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyom::P64;
           _scynG::I64 = I64[_scyom::P64 + 24];
           _scyo9::I64 = _scynG::I64 - I64[_scyom::P64 + 16];
           I64[Hp - 16] = go_up_scyob_info;
           I64[Hp - 8] = _scyo9::I64;
           I64[Hp] = 0 - _scyo9::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scyob_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyo8_entry() //  [R1]
         { info_tbl: [(ccA3o,
                       label: sat_scyo8_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA3o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA3p; else goto ccA3x;
       ccA3p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA3x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA3v; else goto ccA3n;
       ccA3n: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA3v; else goto ccA3w;
       ccA3v: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA3w: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoq_entry() //  [R1]
         { info_tbl: [(ccA3L,
                       label: sat_scyoq_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA3L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA3M; else goto ccA3U;
       ccA3M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA3U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA3S; else goto ccA3K;
       ccA3K: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA3S; else goto ccA3T;
       ccA3S: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA3T: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoF_entry() //  [R1]
         { info_tbl: [(ccA4r,
                       label: sat_scyoF_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA4r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA4s; else goto ccA4t;
       ccA4s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA4t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scyoy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoD_entry() //  [R1]
         { info_tbl: [(ccA4D,
                       label: sat_scyoD_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA4D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA4E; else goto ccA4M;
       ccA4E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA4M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoz::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoz::I64, 0)) goto ccA4K; else goto ccA4C;
       ccA4C: // global
           if (%MO_S_Gt_W64(_scyoz::I64, 1)) goto ccA4K; else goto ccA4L;
       ccA4K: // global
           R2 = _scyoz::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA4L: // global
           R1 = I64[(_scyoz::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoI_entry() //  [R1]
         { info_tbl: [(ccA4X,
                       label: sat_scyoI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA4X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA4Y; else goto ccA56;
       ccA4Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA56: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoz::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoz::I64, 0)) goto ccA54; else goto ccA4W;
       ccA4W: // global
           if (%MO_S_Gt_W64(_scyoz::I64, 1)) goto ccA54; else goto ccA55;
       ccA54: // global
           R2 = _scyoz::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA55: // global
           R1 = I64[(_scyoz::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scyoy_entry() //  [R1, R2]
         { info_tbl: [(ccA5a,
                       label: go_dn_scyoy_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA5a: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccA5e; else goto ccA5d;
       ccA5e: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccA5d: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccA58; else goto ccA59;
       ccA58: // global
           _scyow::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyoF_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyow::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyoD_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA59: // global
           I64[Hp - 80] = sat_scyoI_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccA5g::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccA5g::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyoJ_entry() //  [R1]
         { info_tbl: [(ccA5h,
                       label: sat_scyoJ_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA5h: // global
           _scyoJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccA5i; else goto ccA5j;
       ccA5j: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccA5l; else goto ccA5k;
       ccA5l: // global
           HpAlloc = 24;
           goto ccA5i;
       ccA5i: // global
           R1 = _scyoJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA5k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyoJ::P64;
           _scynG::I64 = I64[_scyoJ::P64 + 24];
           _scyow::I64 = _scynG::I64 - I64[_scyoJ::P64 + 16];
           I64[Hp - 16] = go_dn_scyoy_info;
           I64[Hp - 8] = _scyow::I64;
           I64[Hp] = 1 - _scyow::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scyoy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyov_entry() //  [R1]
         { info_tbl: [(ccA5v,
                       label: sat_scyov_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA5v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA5w; else goto ccA5E;
       ccA5w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA5E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA5C; else goto ccA5u;
       ccA5u: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA5C; else goto ccA5D;
       ccA5C: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA5D: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoN_entry() //  [R1]
         { info_tbl: [(ccA5S,
                       label: sat_scyoN_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA5S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA5T; else goto ccA61;
       ccA5T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA61: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA5Z; else goto ccA5R;
       ccA5R: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA5Z; else goto ccA60;
       ccA5Z: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA60: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyp1_entry() //  [R1]
         { info_tbl: [(ccA6u,
                       label: sat_scyp1_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA6u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA6v; else goto ccA6w;
       ccA6v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA6w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scyoU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoZ_entry() //  [R1]
         { info_tbl: [(ccA6G,
                       label: sat_scyoZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA6G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA6H; else goto ccA6P;
       ccA6H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA6P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoV::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoV::I64, 0)) goto ccA6N; else goto ccA6F;
       ccA6F: // global
           if (%MO_S_Gt_W64(_scyoV::I64, 1)) goto ccA6N; else goto ccA6O;
       ccA6N: // global
           R2 = _scyoV::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA6O: // global
           R1 = I64[(_scyoV::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyp4_entry() //  [R1]
         { info_tbl: [(ccA70,
                       label: sat_scyp4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA70: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA71; else goto ccA79;
       ccA71: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA79: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoV::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoV::I64, 0)) goto ccA77; else goto ccA6Z;
       ccA6Z: // global
           if (%MO_S_Gt_W64(_scyoV::I64, 1)) goto ccA77; else goto ccA78;
       ccA77: // global
           R2 = _scyoV::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA78: // global
           R1 = I64[(_scyoV::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scyoU_entry() //  [R1, R2]
         { info_tbl: [(ccA7d,
                       label: go_up_scyoU_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA7d: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccA7h; else goto ccA7g;
       ccA7h: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccA7g: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccA7b; else goto ccA7c;
       ccA7b: // global
           _scyoS::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyp1_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyoS::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyoZ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA7c: // global
           I64[Hp - 80] = sat_scyp4_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccA7j::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccA7j::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scyp5_entry() //  [R1]
         { info_tbl: [(ccA7k,
                       label: sat_scyp5_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA7k: // global
           _scyp5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccA7l; else goto ccA7m;
       ccA7m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccA7o; else goto ccA7n;
       ccA7o: // global
           HpAlloc = 24;
           goto ccA7l;
       ccA7l: // global
           R1 = _scyp5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA7n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyp5::P64;
           _scynG::I64 = I64[_scyp5::P64 + 24];
           _scyoS::I64 = _scynG::I64 - I64[_scyp5::P64 + 16];
           I64[Hp - 16] = go_up_scyoU_info;
           I64[Hp - 8] = _scyoS::I64;
           I64[Hp] = 1 - _scyoS::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scyoU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyoR_entry() //  [R1]
         { info_tbl: [(ccA7y,
                       label: sat_scyoR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA7y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA7z; else goto ccA7H;
       ccA7z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA7H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA7F; else goto ccA7x;
       ccA7x: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA7F; else goto ccA7G;
       ccA7F: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA7G: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scyp9_entry() //  [R1]
         { info_tbl: [(ccA7V,
                       label: sat_scyp9_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA7V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA7W; else goto ccA84;
       ccA7W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA84: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA82; else goto ccA7U;
       ccA7U: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA82; else goto ccA83;
       ccA82: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA83: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(ccA8c,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA8c: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccA8d; else goto ccA8e;
       ccA8d: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccA8e: // global
           I64[Sp - 24] = block_ccA85_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucA9n; else goto ccA86;
       ucA9n: // global
           call _ccA85(R1) args: 0, res: 0, upd: 0;
       ccA86: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccA85() //  [R1]
         { info_tbl: [(ccA85,
                       label: block_ccA85_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA85: // global
           _scynB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccA89; else goto ccA8a;
       ccA89: // global
           _scynE::I64 = 0;
           goto scynD;
       ccA8a: // global
           _scynE::I64 = 1;
           goto scynD;
       scynD: // global
           I64[Sp] = block_ccA8f_info;
           R1 = _scynB::P64;
           I64[Sp + 8] = _scynE::I64;
           if (R1 & 7 != 0) goto ucA9m; else goto ccA93;
       ucA9m: // global
           call _ccA8f(R1) args: 0, res: 0, upd: 0;
       ccA93: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccA8f() //  [R1]
         { info_tbl: [(ccA8f,
                       label: block_ccA8f_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccA8f: // global
           _scynC::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccA99; else goto ccA9d;
       ccA99: // global
           _scynG::I64 = 0;
           goto scynF;
       ccA9d: // global
           _scynG::I64 = 1;
           goto scynF;
       scynF: // global
           I64[Sp] = block_cczZI_info;
           R1 = _scynC::P64;
           I64[Sp + 16] = _scynG::I64;
           if (R1 & 7 != 0) goto ucA9o; else goto cczZJ;
       ucA9o: // global
           call _cczZI(R1) args: 0, res: 0, upd: 0;
       cczZJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cczZI() //  [R1]
         { info_tbl: [(cczZI,
                       label: block_cczZI_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cczZI: // global
           _scynE::I64 = I64[Sp + 8];
           _scynG::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto ccA8j; else goto ccA8G;
       ccA8j: // global
           Hp = Hp + 80;
           _scynH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccA8J; else goto ccA8l;
       ccA8l: // global
           if (%MO_S_Lt_W64(_scynG::I64,
                            _scynE::I64)) goto ccA8w; else goto ccA8F;
       ccA8w: // global
           if (%MO_S_Le_W64(0, _scynG::I64)) goto ccA8p; else goto ccA8u;
       ccA8p: // global
           I64[Hp - 72] = sat_scyo0_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scynM_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA8u: // global
           if (%MO_S_Gt_W64(0, _scynE::I64)) goto ccA90; else goto ccA8s;
       ccA8s: // global
           I64[Hp - 72] = sat_scyo4_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccA8q::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccA8q::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA8F: // global
           if (%MO_S_Ge_W64(0, _scynG::I64)) goto ccA8z; else goto ccA8E;
       ccA8z: // global
           I64[Hp - 72] = sat_scyom_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scyo8_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA8E: // global
           if (%MO_S_Lt_W64(0, _scynE::I64)) goto ccA90; else goto ccA8C;
       ccA8C: // global
           I64[Hp - 72] = sat_scyoq_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccA8A::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccA8A::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA8G: // global
           Hp = Hp + 80;
           _scynH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccA8J; else goto ccA8I;
       ccA8J: // global
           HpAlloc = 80;
           R1 = _scynH::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccA8I: // global
           if (%MO_S_Lt_W64(_scynG::I64,
                            _scynE::I64)) goto ccA8T; else goto ccA92;
       ccA8T: // global
           if (%MO_S_Le_W64(1, _scynG::I64)) goto ccA8M; else goto ccA8R;
       ccA8M: // global
           I64[Hp - 72] = sat_scyoJ_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scyov_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA8R: // global
           if (%MO_S_Gt_W64(1, _scynE::I64)) goto ccA90; else goto ccA8P;
       ccA8P: // global
           I64[Hp - 72] = sat_scyoN_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccA8N::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccA8N::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA92: // global
           if (%MO_S_Ge_W64(1, _scynG::I64)) goto ccA8W; else goto ccA91;
       ccA8W: // global
           I64[Hp - 72] = sat_scyp5_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scyoR_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA91: // global
           if (%MO_S_Lt_W64(1, _scynE::I64)) goto ccA90; else goto ccA8Z;
       ccA90: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA8Z: // global
           I64[Hp - 72] = sat_scyp9_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccA8X::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccA8X::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.956777505 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_closure" {
     GHC.ByteOrder.$fEnumByteOrder_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure+2;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure+2;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.958632906 UTC

[section ""data" . GHC.ByteOrder.$trModule3_closure" {
     GHC.ByteOrder.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.960357767 UTC

[section ""data" . GHC.ByteOrder.$trModule1_closure" {
     GHC.ByteOrder.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.962526982 UTC

[section ""data" . GHC.ByteOrder.$trModule_closure" {
     GHC.ByteOrder.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.ByteOrder.$trModule3_closure+1;
         const GHC.ByteOrder.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.964320872 UTC

[section ""cstring" . GHC.ByteOrder.$tcByteOrder2_bytes" {
     GHC.ByteOrder.$tcByteOrder2_bytes:
         I8[] [66,121,116,101,79,114,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.96607943 UTC

[section ""data" . GHC.ByteOrder.$tcByteOrder1_closure" {
     GHC.ByteOrder.$tcByteOrder1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tcByteOrder2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.967783111 UTC

[section ""data" . GHC.ByteOrder.$tcByteOrder_closure" {
     GHC.ByteOrder.$tcByteOrder_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tcByteOrder1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16811050684449662084;
         const 17273005335247024091;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.96986936 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian1_closure" {
     GHC.ByteOrder.$tc'BigEndian1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ByteOrder.$tcByteOrder_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.971692096 UTC

[section ""cstring" . GHC.ByteOrder.$tc'BigEndian3_bytes" {
     GHC.ByteOrder.$tc'BigEndian3_bytes:
         I8[] [39,66,105,103,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.973447546 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian2_closure" {
     GHC.ByteOrder.$tc'BigEndian2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tc'BigEndian3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.975707539 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian_closure" {
     GHC.ByteOrder.$tc'BigEndian_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tc'BigEndian2_closure+1;
         const GHC.ByteOrder.$tc'BigEndian1_closure+1;
         const 2645192688778293591;
         const 7455668807059762078;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.977578386 UTC

[section ""cstring" . GHC.ByteOrder.$tc'LittleEndian2_bytes" {
     GHC.ByteOrder.$tc'LittleEndian2_bytes:
         I8[] [39,76,105,116,116,108,101,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.979215273 UTC

[section ""data" . GHC.ByteOrder.$tc'LittleEndian1_closure" {
     GHC.ByteOrder.$tc'LittleEndian1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tc'LittleEndian2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.980853929 UTC

[section ""data" . GHC.ByteOrder.$tc'LittleEndian_closure" {
     GHC.ByteOrder.$tc'LittleEndian_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tc'LittleEndian1_closure+1;
         const GHC.ByteOrder.$tc'BigEndian1_closure+1;
         const 8702700204875460152;
         const 10337679016369298147;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.983012053 UTC

[section ""data" . GHC.ByteOrder.BigEndian_closure" {
     GHC.ByteOrder.BigEndian_closure:
         const GHC.ByteOrder.BigEndian_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.98469876 UTC

[section ""data" . GHC.ByteOrder.LittleEndian_closure" {
     GHC.ByteOrder.LittleEndian_closure:
         const GHC.ByteOrder.LittleEndian_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.98641651 UTC

[section ""relreadonly" . GHC.ByteOrder.ByteOrder_closure_tbl" {
     GHC.ByteOrder.ByteOrder_closure_tbl:
         const GHC.ByteOrder.BigEndian_closure+1;
         const GHC.ByteOrder.LittleEndian_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.988287651 UTC

[GHC.ByteOrder.BigEndian_con_entry() //  [R1]
         { info_tbl: [(ccAdi,
                       label: GHC.ByteOrder.BigEndian_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,121,116,101,79,114,100,101,114,46,66,105,103,69,110,100,105,97,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAdi: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.991668708 UTC

[GHC.ByteOrder.LittleEndian_con_entry() //  [R1]
         { info_tbl: [(ccAdo,
                       label: GHC.ByteOrder.LittleEndian_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,66,121,116,101,79,114,100,101,114,46,76,105,116,116,108,101,69,110,100,105,97,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAdo: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:27.995267789 UTC

[section ""relreadonly" . ScypP_srt" {
     ScypP_srt:
         const GHC.ByteOrder.$fReadByteOrder6_closure;
         const GHC.ByteOrder.$fReadByteOrder10_closure;
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure;
         const GHC.ByteOrder.$fShowByteOrder_$cshow_closure;
         const GHC.ByteOrder.$fShowByteOrder1_closure;
         const GHC.Read.choose2_closure;
         const GHC.ByteOrder.$fReadByteOrder_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.ByteOrder.$fReadByteOrder2_closure;
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.ByteOrder.$fReadByteOrder1_closure;
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
         const GHC.ByteOrder.$fReadByteOrder12_closure;
         const GHC.Err.error_closure;
         const lvl12_rcykz_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_closure;
         const GHC.ByteOrder.$fEnumByteOrder3_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_closure;
         const GHC.ByteOrder.$fEnumByteOrder4_closure;
         const lvl17_rcykE_closure;
         const lvl18_rcykF_closure;
         const lvl19_rcykG_closure;
         const GHC.ByteOrder.$wlvl_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure;
         const GHC.ByteOrder.$w$ctoEnum_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure;
         const GHC.ByteOrder.$fEnumByteOrder1_closure;
         const GHC.ByteOrder.$fEnumByteOrder2_closure;
         const GHC.ByteOrder.$fEnumByteOrder_go1_closure;
         const GHC.ByteOrder.$fEnumByteOrder_go_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.629453259 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:29.630518009 UTC

[section ""cstring" . GHC.ByteOrder.$fReadByteOrder11_bytes" {
     GHC.ByteOrder.$fReadByteOrder11_bytes:
         I8[] [66,105,103,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.63246058 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder10_closure" {
     GHC.ByteOrder.$fReadByteOrder10_closure:
         const GHC.ByteOrder.$fReadByteOrder10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder10_entry() //  [R1]
         { info_tbl: [(ccAi5,
                       label: GHC.ByteOrder.$fReadByteOrder10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAi5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAi6; else goto ccAi7;
       ccAi6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAi7: // global
           (_ccAi2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAi2::I64 == 0) goto ccAi4; else goto ccAi3;
       ccAi4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAi3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAi2::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.636581666 UTC

[section ""cstring" . GHC.ByteOrder.$fReadByteOrder7_bytes" {
     GHC.ByteOrder.$fReadByteOrder7_bytes:
         I8[] [76,105,116,116,108,101,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.638446645 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder6_closure" {
     GHC.ByteOrder.$fReadByteOrder6_closure:
         const GHC.ByteOrder.$fReadByteOrder6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder6_entry() //  [R1]
         { info_tbl: [(ccAin,
                       label: GHC.ByteOrder.$fReadByteOrder6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAin: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAio; else goto ccAip;
       ccAio: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAip: // global
           (_ccAik::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAik::I64 == 0) goto ccAim; else goto ccAil;
       ccAim: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAil: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAik::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.642707702 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(ccAiJ,
                       label: GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAiJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAiK; else goto ccAiL;
       ccAiK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAiL: // global
           I64[Sp - 16] = block_ccAiC_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAiS; else goto ccAiD;
       ucAiS: // global
           call _ccAiC(R1) args: 0, res: 0, upd: 0;
       ccAiD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAiC() //  [R1]
         { info_tbl: [(ccAiC,
                       label: block_ccAiC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAiC: // global
           _scAdx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAiG; else goto ccAiH;
       ccAiG: // global
           R3 = _scAdx::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccAiH: // global
           R3 = _scAdx::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.648596355 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshow_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshow_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshow_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshow_entry() //  [R2]
         { info_tbl: [(ccAjh,
                       label: GHC.ByteOrder.$fShowByteOrder_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAjh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccAji; else goto ccAjj;
       ccAji: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAjj: // global
           I64[Sp - 8] = block_ccAja_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucAjq; else goto ccAjb;
       ucAjq: // global
           call _ccAja(R1) args: 0, res: 0, upd: 0;
       ccAjb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAja() //  [R1]
         { info_tbl: [(ccAja,
                       label: block_ccAja_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAja: // global
           if (R1 & 7 == 1) goto ccAje; else goto ccAjf;
       ccAje: // global
           R1 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccAjf: // global
           R1 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.65437065 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder1_closure" {
     GHC.ByteOrder.$fShowByteOrder1_closure:
         const GHC.ByteOrder.$fShowByteOrder1_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder1_entry() //  [R2, R3]
         { info_tbl: [(ccAjQ,
                       label: GHC.ByteOrder.$fShowByteOrder1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAjQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAjR; else goto ccAjS;
       ccAjR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAjS: // global
           I64[Sp - 16] = block_ccAjJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAjZ; else goto ccAjK;
       ucAjZ: // global
           call _ccAjJ(R1) args: 0, res: 0, upd: 0;
       ccAjK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAjJ() //  [R1]
         { info_tbl: [(ccAjJ,
                       label: block_ccAjJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAjJ: // global
           _scAdC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAjN; else goto ccAjO;
       ccAjN: // global
           R3 = _scAdC::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccAjO: // global
           R3 = _scAdC::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.660459111 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshowList_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshowList_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(ccAkg,
                       label: GHC.ByteOrder.$fShowByteOrder_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAkg: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.ByteOrder.$fShowByteOrder1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.664460479 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_closure" {
     GHC.ByteOrder.$fShowByteOrder_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure+3;
         const GHC.ByteOrder.$fShowByteOrder_$cshow_closure+1;
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.666317043 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder9_closure" {
     GHC.ByteOrder.$fReadByteOrder9_closure:
         const GHC.ByteOrder.$fReadByteOrder9_info;
 },
 GHC.ByteOrder.$fReadByteOrder9_entry() //  [R3]
         { info_tbl: [(ccAks,
                       label: GHC.ByteOrder.$fReadByteOrder9_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAks: // global
           R2 = GHC.ByteOrder.BigEndian_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.669485268 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder8_closure" {
     GHC.ByteOrder.$fReadByteOrder8_closure:
         const (,)_con_info;
         const GHC.ByteOrder.$fReadByteOrder10_closure;
         const GHC.ByteOrder.$fReadByteOrder9_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.671248293 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder5_closure" {
     GHC.ByteOrder.$fReadByteOrder5_closure:
         const GHC.ByteOrder.$fReadByteOrder5_info;
 },
 GHC.ByteOrder.$fReadByteOrder5_entry() //  [R3]
         { info_tbl: [(ccAkE,
                       label: GHC.ByteOrder.$fReadByteOrder5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAkE: // global
           R2 = GHC.ByteOrder.LittleEndian_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.674833627 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder4_closure" {
     GHC.ByteOrder.$fReadByteOrder4_closure:
         const (,)_con_info;
         const GHC.ByteOrder.$fReadByteOrder6_closure;
         const GHC.ByteOrder.$fReadByteOrder5_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.676590421 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder3_closure" {
     GHC.ByteOrder.$fReadByteOrder3_closure:
         const :_con_info;
         const GHC.ByteOrder.$fReadByteOrder4_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.678309837 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_sps_closure" {
     GHC.ByteOrder.$fReadByteOrder_sps_closure:
         const :_con_info;
         const GHC.ByteOrder.$fReadByteOrder8_closure+1;
         const GHC.ByteOrder.$fReadByteOrder3_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.680127474 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder2_closure" {
     GHC.ByteOrder.$fReadByteOrder2_closure:
         const GHC.ByteOrder.$fReadByteOrder2_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder2_entry() //  [R2]
         { info_tbl: [(ccAkS,
                       label: GHC.ByteOrder.$fReadByteOrder2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAkS: // global
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.683571828 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder1_closure" {
     GHC.ByteOrder.$fReadByteOrder1_closure:
         const GHC.ByteOrder.$fReadByteOrder1_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder1_entry() //  [R2, R3]
         { info_tbl: [(ccAl3,
                       label: GHC.ByteOrder.$fReadByteOrder1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAl3: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.687147197 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info;
         const 0;
 },
 sat_scAdM_entry() //  [R1]
         { info_tbl: [(ccAli,
                       label: sat_scAdM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAli: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAlj; else goto ccAlk;
       ccAlj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAlk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.ByteOrder.$fReadByteOrder2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fReadByteOrder_$creadsPrec_entry() //  [R2]
         { info_tbl: [(ccAll,
                       label: GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAll: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAlp; else goto ccAlo;
       ccAlp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAlo: // global
           I64[Hp - 16] = sat_scAdM_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.693935276 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadListPrec_entry() //  [R1]
         { info_tbl: [(ccAlI,
                       label: GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAlI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAlJ; else goto ccAlK;
       ccAlJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAlK: // global
           (_ccAlF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAlF::I64 == 0) goto ccAlH; else goto ccAlG;
       ccAlH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAlG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAlF::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.69802035 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder12_closure" {
     GHC.ByteOrder.$fReadByteOrder12_closure:
         const GHC.ByteOrder.$fReadByteOrder12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder12_entry() //  [R1]
         { info_tbl: [(ccAlZ,
                       label: GHC.ByteOrder.$fReadByteOrder12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAlZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAm0; else goto ccAm1;
       ccAm0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAm1: // global
           (_ccAlW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAlW::I64 == 0) goto ccAlY; else goto ccAlX;
       ccAlY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAlX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAlW::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.702552428 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadList_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadList_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadList_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadList_entry() //  [R2]
         { info_tbl: [(ccAmf,
                       label: GHC.ByteOrder.$fReadByteOrder_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAmf: // global
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.705830111 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_closure" {
     GHC.ByteOrder.$fReadByteOrder_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure+1;
         const GHC.ByteOrder.$fReadByteOrder_$creadList_closure+1;
         const GHC.ByteOrder.$fReadByteOrder1_closure+2;
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.707658434 UTC

[section ""data" . GHC.ByteOrder.$fBoundedByteOrder_closure" {
     GHC.ByteOrder.$fBoundedByteOrder_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.ByteOrder.BigEndian_closure+1;
         const GHC.ByteOrder.LittleEndian_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.709811471 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c<_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c<_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c<_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c<_entry() //  [R2, R3]
         { info_tbl: [(ccAmz,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAmz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAmA; else goto ccAmB;
       ccAmA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAmB: // global
           I64[Sp - 16] = block_ccAms_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAn3; else goto ccAmt;
       ucAn3: // global
           call _ccAms(R1) args: 0, res: 0, upd: 0;
       ccAmt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAms() //  [R1]
         { info_tbl: [(ccAms,
                       label: block_ccAms_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAms: // global
           _scAdO::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAmw; else goto ccAmx;
       ccAmw: // global
           I64[Sp + 8] = block_ccAmE_info;
           R1 = _scAdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAn1; else goto ccAmG;
       ucAn1: // global
           call _ccAmE(R1) args: 0, res: 0, upd: 0;
       ccAmG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAmx: // global
           I64[Sp + 8] = block_ccAmT_info;
           R1 = _scAdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAn2; else goto ccAmV;
       ucAn2: // global
           call _ccAmT() args: 0, res: 0, upd: 0;
       ccAmV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAmE() //  [R1]
         { info_tbl: [(ccAmE,
                       label: block_ccAmE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAmE: // global
           if (R1 & 7 == 1) goto ccAmM; else goto ccAmQ;
       ccAmM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAmQ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccAmT() //  []
         { info_tbl: [(ccAmT,
                       label: block_ccAmT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAmT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.71934732 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(ccAnJ,
                       label: GHC.ByteOrder.$fOrdByteOrder_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAnJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAnK; else goto ccAnL;
       ccAnK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAnL: // global
           I64[Sp - 16] = block_ccAnC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAom; else goto ccAnD;
       ucAom: // global
           call _ccAnC(R1) args: 0, res: 0, upd: 0;
       ccAnD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAnC() //  [R1]
         { info_tbl: [(ccAnC,
                       label: block_ccAnC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAnC: // global
           _scAdT::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAnG; else goto ccAnH;
       ccAnG: // global
           I64[Sp + 8] = block_ccAnO_info;
           R1 = _scAdT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAok; else goto ccAnQ;
       ucAok: // global
           call _ccAnO(R1) args: 0, res: 0, upd: 0;
       ccAnQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAnH: // global
           I64[Sp + 8] = block_ccAo3_info;
           R1 = _scAdT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAol; else goto ccAo5;
       ucAol: // global
           call _ccAo3(R1) args: 0, res: 0, upd: 0;
       ccAo5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAnO() //  [R1]
         { info_tbl: [(ccAnO,
                       label: block_ccAnO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAnO: // global
           if (R1 & 7 == 1) goto ucAoj; else goto ccAo0;
       ucAoj: // global
           Sp = Sp + 8;
           call _ccAof() args: 0, res: 0, upd: 0;
       ccAo0: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccAo3() //  [R1]
         { info_tbl: [(ccAo3,
                       label: block_ccAo3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAo3: // global
           if (R1 & 7 == 1) goto ccAob; else goto ucAoi;
       ccAob: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ucAoi: // global
           Sp = Sp + 8;
           call _ccAof() args: 0, res: 0, upd: 0;
     }
 },
 _ccAof() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAof: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.730660618 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_$c==_closure" {
     GHC.ByteOrder.$fEqByteOrder_$c==_closure:
         const GHC.ByteOrder.$fEqByteOrder_$c==_info;
 },
 GHC.ByteOrder.$fEqByteOrder_$c==_entry() //  [R2, R3]
         { info_tbl: [(ccAp8,
                       label: GHC.ByteOrder.$fEqByteOrder_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAp8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAp9; else goto ccApa;
       ccAp9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEqByteOrder_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccApa: // global
           I64[Sp - 16] = block_ccAp1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucApN; else goto ccAp2;
       ucApN: // global
           call _ccAp1(R1) args: 0, res: 0, upd: 0;
       ccAp2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAp1() //  [R1]
         { info_tbl: [(ccAp1,
                       label: block_ccAp1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAp1: // global
           _scAdY::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAp5; else goto ccAp6;
       ccAp5: // global
           I64[Sp + 8] = block_ccApd_info;
           R1 = _scAdY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucApL; else goto ccApf;
       ucApL: // global
           call _ccApd(R1) args: 0, res: 0, upd: 0;
       ccApf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAp6: // global
           I64[Sp + 8] = block_ccAps_info;
           R1 = _scAdY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucApM; else goto ccApu;
       ucApM: // global
           call _ccAps(R1) args: 0, res: 0, upd: 0;
       ccApu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccApd() //  [R1]
         { info_tbl: [(ccApd,
                       label: block_ccApd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccApd: // global
           if (R1 & 7 == 1) goto ucApJ; else goto ucApK;
       ucApJ: // global
           Sp = Sp + 8;
           call _ccApE() args: 0, res: 0, upd: 0;
       ucApK: // global
           Sp = Sp + 8;
           call _ccApA() args: 0, res: 0, upd: 0;
     }
 },
 _ccAps() //  [R1]
         { info_tbl: [(ccAps,
                       label: block_ccAps_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAps: // global
           if (R1 & 7 == 1) goto ucApH; else goto ucApI;
       ucApH: // global
           Sp = Sp + 8;
           call _ccApA() args: 0, res: 0, upd: 0;
       ucApI: // global
           Sp = Sp + 8;
           call _ccApE() args: 0, res: 0, upd: 0;
     }
 },
 _ccApA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccApA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccApE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccApE: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.742144287 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_$c/=_closure" {
     GHC.ByteOrder.$fEqByteOrder_$c/=_closure:
         const GHC.ByteOrder.$fEqByteOrder_$c/=_info;
 },
 GHC.ByteOrder.$fEqByteOrder_$c/=_entry() //  [R2, R3]
         { info_tbl: [(ccAqB,
                       label: GHC.ByteOrder.$fEqByteOrder_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAqB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAqC; else goto ccAqD;
       ccAqC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEqByteOrder_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAqD: // global
           I64[Sp - 16] = block_ccAqu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucArg; else goto ccAqv;
       ucArg: // global
           call _ccAqu(R1) args: 0, res: 0, upd: 0;
       ccAqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAqu() //  [R1]
         { info_tbl: [(ccAqu,
                       label: block_ccAqu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAqu: // global
           _scAe3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAqy; else goto ccAqz;
       ccAqy: // global
           I64[Sp + 8] = block_ccAqG_info;
           R1 = _scAe3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAre; else goto ccAqI;
       ucAre: // global
           call _ccAqG(R1) args: 0, res: 0, upd: 0;
       ccAqI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAqz: // global
           I64[Sp + 8] = block_ccAqV_info;
           R1 = _scAe3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucArf; else goto ccAqX;
       ucArf: // global
           call _ccAqV(R1) args: 0, res: 0, upd: 0;
       ccAqX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAqG() //  [R1]
         { info_tbl: [(ccAqG,
                       label: block_ccAqG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAqG: // global
           if (R1 & 7 == 1) goto ucArc; else goto ucArd;
       ucArc: // global
           Sp = Sp + 8;
           call _ccAr7() args: 0, res: 0, upd: 0;
       ucArd: // global
           Sp = Sp + 8;
           call _ccAr3() args: 0, res: 0, upd: 0;
     }
 },
 _ccAqV() //  [R1]
         { info_tbl: [(ccAqV,
                       label: block_ccAqV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAqV: // global
           if (R1 & 7 == 1) goto ucAra; else goto ucArb;
       ucAra: // global
           Sp = Sp + 8;
           call _ccAr3() args: 0, res: 0, upd: 0;
       ucArb: // global
           Sp = Sp + 8;
           call _ccAr7() args: 0, res: 0, upd: 0;
     }
 },
 _ccAr3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAr3: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccAr7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAr7: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.752824591 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_closure" {
     GHC.ByteOrder.$fEqByteOrder_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.ByteOrder.$fEqByteOrder_$c==_closure+2;
         const GHC.ByteOrder.$fEqByteOrder_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.755156922 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c<=_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c<=_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c<=_entry() //  [R2, R3]
         { info_tbl: [(ccAs5,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAs5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAs6; else goto ccAs7;
       ccAs6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAs7: // global
           I64[Sp - 16] = block_ccArY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAsz; else goto ccArZ;
       ucAsz: // global
           call _ccArY(R1) args: 0, res: 0, upd: 0;
       ccArZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccArY() //  [R1]
         { info_tbl: [(ccArY,
                       label: block_ccArY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccArY: // global
           _scAe7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAs2; else goto ccAs3;
       ccAs2: // global
           I64[Sp + 8] = block_ccAsa_info;
           R1 = _scAe7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAsx; else goto ccAsc;
       ucAsx: // global
           call _ccAsa(R1) args: 0, res: 0, upd: 0;
       ccAsc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAs3: // global
           I64[Sp + 8] = block_ccAsp_info;
           R1 = _scAe7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAsy; else goto ccAsr;
       ucAsy: // global
           call _ccAsp() args: 0, res: 0, upd: 0;
       ccAsr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAsa() //  [R1]
         { info_tbl: [(ccAsa,
                       label: block_ccAsa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAsa: // global
           if (R1 & 7 == 1) goto ccAsi; else goto ccAsm;
       ccAsi: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAsm: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccAsp() //  []
         { info_tbl: [(ccAsp,
                       label: block_ccAsp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAsp: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.765412818 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$cmax_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$cmax_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$cmax_entry() //  [R2, R3]
         { info_tbl: [(ccAtf,
                       label: GHC.ByteOrder.$fOrdByteOrder_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAtf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAtg; else goto ccAth;
       ccAtg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAth: // global
           I64[Sp - 16] = block_ccAt8_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAtv; else goto ccAt9;
       ucAtv: // global
           call _ccAt8(R1) args: 0, res: 0, upd: 0;
       ccAt9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAt8() //  [R1]
         { info_tbl: [(ccAt8,
                       label: block_ccAt8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAt8: // global
           _scAec::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAtc; else goto ccAtd;
       ccAtc: // global
           R1 = _scAec::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccAtd: // global
           I64[Sp + 8] = block_ccAtn_info;
           R1 = _scAec::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAtu; else goto ccAtp;
       ucAtu: // global
           call _ccAtn() args: 0, res: 0, upd: 0;
       ccAtp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAtn() //  []
         { info_tbl: [(ccAtn,
                       label: block_ccAtn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAtn: // global
           R1 = GHC.ByteOrder.LittleEndian_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.772805691 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c>=_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c>=_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c>=_entry() //  [R2, R3]
         { info_tbl: [(ccAu1,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAu1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAu2; else goto ccAu3;
       ccAu2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAu3: // global
           I64[Sp - 16] = block_ccAtU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAuv; else goto ccAtV;
       ucAuv: // global
           call _ccAtU(R1) args: 0, res: 0, upd: 0;
       ccAtV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAtU() //  [R1]
         { info_tbl: [(ccAtU,
                       label: block_ccAtU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAtU: // global
           _scAeh::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAtY; else goto ccAtZ;
       ccAtY: // global
           I64[Sp + 8] = block_ccAu6_info;
           R1 = _scAeh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAut; else goto ccAu8;
       ucAut: // global
           call _ccAu6(R1) args: 0, res: 0, upd: 0;
       ccAu8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAtZ: // global
           I64[Sp + 8] = block_ccAul_info;
           R1 = _scAeh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAuu; else goto ccAun;
       ucAuu: // global
           call _ccAul() args: 0, res: 0, upd: 0;
       ccAun: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAu6() //  [R1]
         { info_tbl: [(ccAu6,
                       label: block_ccAu6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAu6: // global
           if (R1 & 7 == 1) goto ccAue; else goto ccAui;
       ccAue: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAui: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccAul() //  []
         { info_tbl: [(ccAul,
                       label: block_ccAul_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAul: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.7820772 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c>_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c>_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c>_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c>_entry() //  [R2, R3]
         { info_tbl: [(ccAv4,
                       label: GHC.ByteOrder.$fOrdByteOrder_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAv4: // global
           _scAem::P64 = R3;
           R3 = R2;
           R2 = _scAem::P64;
           call GHC.ByteOrder.$fOrdByteOrder_$c<_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.78613798 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$cmin_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$cmin_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$cmin_entry() //  [R2, R3]
         { info_tbl: [(ccAvm,
                       label: GHC.ByteOrder.$fOrdByteOrder_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAvm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAvn; else goto ccAvo;
       ccAvn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAvo: // global
           I64[Sp - 16] = block_ccAvf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAvC; else goto ccAvg;
       ucAvC: // global
           call _ccAvf(R1) args: 0, res: 0, upd: 0;
       ccAvg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAvf() //  [R1]
         { info_tbl: [(ccAvf,
                       label: block_ccAvf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAvf: // global
           _scAen::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAvj; else goto ccAvk;
       ccAvj: // global
           I64[Sp + 8] = block_ccAvr_info;
           R1 = _scAen::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAvB; else goto ccAvt;
       ucAvB: // global
           call _ccAvr() args: 0, res: 0, upd: 0;
       ccAvt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAvk: // global
           R1 = _scAen::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccAvr() //  []
         { info_tbl: [(ccAvr,
                       label: block_ccAvr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAvr: // global
           R1 = GHC.ByteOrder.BigEndian_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.793396916 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_closure" {
     GHC.ByteOrder.$fOrdByteOrder_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.ByteOrder.$fEqByteOrder_closure+1;
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c<_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c>_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.795278215 UTC

[section ""data" . GHC.ByteOrder.targetByteOrder_closure" {
     GHC.ByteOrder.targetByteOrder_closure:
         const GHC.ByteOrder.LittleEndian_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.796925207 UTC

[section ""data" . lvl_rcykn_closure" {
     lvl_rcykn_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.799484926 UTC

[section ""data" . lvl1_rcyko_closure" {
     lvl1_rcyko_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.801427985 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_entry() //  [R2]
         { info_tbl: [(ccAwc,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAwc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccAwd; else goto ccAwe;
       ccAwd: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAwe: // global
           I64[Sp - 8] = block_ccAw5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucAwl; else goto ccAw6;
       ucAwl: // global
           call _ccAw5(R1) args: 0, res: 0, upd: 0;
       ccAw6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAw5() //  [R1]
         { info_tbl: [(ccAw5,
                       label: block_ccAw5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAw5: // global
           if (R1 & 7 == 1) goto ccAw9; else goto ccAwa;
       ccAw9: // global
           R1 = lvl_rcykn_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAwa: // global
           R1 = lvl1_rcyko_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.807038756 UTC

[section ""cstring" . lvl2_rcykp_bytes" {
     lvl2_rcykp_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.808830943 UTC

[section ""data" . lvl3_rcykq_closure" {
     lvl3_rcykq_closure:
         const lvl3_rcykq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rcykq_entry() //  [R1]
         { info_tbl: [(ccAwH,
                       label: lvl3_rcykq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAwH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAwI; else goto ccAwJ;
       ccAwI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAwJ: // global
           (_ccAwE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAwE::I64 == 0) goto ccAwG; else goto ccAwF;
       ccAwG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAwF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAwE::I64;
           R2 = lvl2_rcykp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.812547977 UTC

[section ""cstring" . GHC.ByteOrder.$trModule4_bytes" {
     GHC.ByteOrder.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.814341276 UTC

[section ""data" . lvl4_rcykr_closure" {
     lvl4_rcykr_closure:
         const lvl4_rcykr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rcykr_entry() //  [R1]
         { info_tbl: [(ccAwZ,
                       label: lvl4_rcykr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAwZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAx0; else goto ccAx1;
       ccAx0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAx1: // global
           (_ccAwW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAwW::I64 == 0) goto ccAwY; else goto ccAwX;
       ccAwY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAwX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAwW::I64;
           R2 = GHC.ByteOrder.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.818194007 UTC

[section ""cstring" . GHC.ByteOrder.$trModule2_bytes" {
     GHC.ByteOrder.$trModule2_bytes:
         I8[] [71,72,67,46,66,121,116,101,79,114,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.819977805 UTC

[section ""data" . lvl5_rcyks_closure" {
     lvl5_rcyks_closure:
         const lvl5_rcyks_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rcyks_entry() //  [R1]
         { info_tbl: [(ccAxh,
                       label: lvl5_rcyks_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAxh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAxi; else goto ccAxj;
       ccAxi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAxj: // global
           (_ccAxe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAxe::I64 == 0) goto ccAxg; else goto ccAxf;
       ccAxg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAxf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAxe::I64;
           R2 = GHC.ByteOrder.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.823857502 UTC

[section ""cstring" . lvl6_rcykt_bytes" {
     lvl6_rcykt_bytes:
         I8[] [46,47,71,72,67,47,66,121,116,101,79,114,100,101,114,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.82566531 UTC

[section ""data" . lvl7_rcyku_closure" {
     lvl7_rcyku_closure:
         const lvl7_rcyku_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rcyku_entry() //  [R1]
         { info_tbl: [(ccAxz,
                       label: lvl7_rcyku_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAxz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAxA; else goto ccAxB;
       ccAxA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAxB: // global
           (_ccAxw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAxw::I64 == 0) goto ccAxy; else goto ccAxx;
       ccAxy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAxx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAxw::I64;
           R2 = lvl6_rcykt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.830271794 UTC

[section ""data" . lvl8_rcykv_closure" {
     lvl8_rcykv_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.831953287 UTC

[section ""data" . lvl9_rcykw_closure" {
     lvl9_rcykw_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.833607228 UTC

[section ""data" . lvl10_rcykx_closure" {
     lvl10_rcykx_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.835231538 UTC

[section ""data" . lvl11_rcyky_closure" {
     lvl11_rcyky_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl4_rcykr_closure;
         const lvl5_rcyks_closure;
         const lvl7_rcyku_closure;
         const lvl8_rcykv_closure+1;
         const lvl9_rcykw_closure+1;
         const lvl8_rcykv_closure+1;
         const lvl10_rcykx_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.836983422 UTC

[section ""data" . lvl12_rcykz_closure" {
     lvl12_rcykz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl3_rcykq_closure;
         const lvl11_rcyky_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.8387221 UTC

[section ""cstring" . lvl13_rcykA_bytes" {
     lvl13_rcykA_bytes:
         I8[] [112,114,101,100,123,66,121,116,101,79,114,100,101,114,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,112,114,101,100,39,32,111,102,32,102,105,114,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.840637208 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder3_closure" {
     GHC.ByteOrder.$fEnumByteOrder3_closure:
         const GHC.ByteOrder.$fEnumByteOrder3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder3_entry() //  [R1]
         { info_tbl: [(ccAxY,
                       label: GHC.ByteOrder.$fEnumByteOrder3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAxY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccAxZ; else goto ccAy0;
       ccAxZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAy0: // global
           (_ccAxT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAxT::I64 == 0) goto ccAxV; else goto ccAxU;
       ccAxV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAxU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAxT::I64;
           I64[Sp - 24] = block_ccAxW_info;
           R2 = lvl13_rcykA_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccAxW() //  [R1]
         { info_tbl: [(ccAxW,
                       label: block_ccAxW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAxW: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.846800145 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cpred_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cpred_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cpred_entry() //  [R2]
         { info_tbl: [(ccAyr,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAyr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccAys; else goto ccAyt;
       ccAys: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAyt: // global
           I64[Sp - 8] = block_ccAyk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucAyA; else goto ccAyl;
       ucAyA: // global
           call _ccAyk(R1) args: 0, res: 0, upd: 0;
       ccAyl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAyk() //  [R1]
         { info_tbl: [(ccAyk,
                       label: block_ccAyk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAyk: // global
           if (R1 & 7 == 1) goto ccAyo; else goto ccAyp;
       ccAyo: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccAyp: // global
           R1 = GHC.ByteOrder.BigEndian_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.85209154 UTC

[section ""cstring" . lvl14_rcykB_bytes" {
     lvl14_rcykB_bytes:
         I8[] [115,117,99,99,123,66,121,116,101,79,114,100,101,114,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,115,117,99,99,39,32,111,102,32,108,97,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.854518706 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder4_closure" {
     GHC.ByteOrder.$fEnumByteOrder4_closure:
         const GHC.ByteOrder.$fEnumByteOrder4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder4_entry() //  [R1]
         { info_tbl: [(ccAyY,
                       label: GHC.ByteOrder.$fEnumByteOrder4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAyY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccAyZ; else goto ccAz0;
       ccAyZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAz0: // global
           (_ccAyT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAyT::I64 == 0) goto ccAyV; else goto ccAyU;
       ccAyV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAyU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAyT::I64;
           I64[Sp - 24] = block_ccAyW_info;
           R2 = lvl14_rcykB_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccAyW() //  [R1]
         { info_tbl: [(ccAyW,
                       label: block_ccAyW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAyW: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.860179024 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$csucc_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$csucc_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$csucc_entry() //  [R2]
         { info_tbl: [(ccAzr,
                       label: GHC.ByteOrder.$fEnumByteOrder_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAzr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccAzs; else goto ccAzt;
       ccAzs: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAzt: // global
           I64[Sp - 8] = block_ccAzk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucAzA; else goto ccAzl;
       ucAzA: // global
           call _ccAzk(R1) args: 0, res: 0, upd: 0;
       ccAzl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAzk() //  [R1]
         { info_tbl: [(ccAzk,
                       label: block_ccAzk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAzk: // global
           if (R1 & 7 == 1) goto ccAzo; else goto ccAzp;
       ccAzo: // global
           R1 = GHC.ByteOrder.LittleEndian_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAzp: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.866258175 UTC

[section ""cstring" . lvl15_rcykC_bytes" {
     lvl15_rcykC_bytes:
         I8[] [41,32,105,115,32,111,117,116,115,105,100,101,32,111,102,32,101,110,117,109,101,114,97,116,105,111,110,39,115,32,114,97,110,103,101,32,40,48,44]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.867710783 UTC

[section ""cstring" . lvl16_rcykD_bytes" {
     lvl16_rcykD_bytes:
         I8[] [41]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.869534741 UTC

[section ""data" . lvl17_rcykE_closure" {
     lvl17_rcykE_closure:
         const lvl17_rcykE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_rcykE_entry() //  [R1]
         { info_tbl: [(ccAzX,
                       label: lvl17_rcykE_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAzX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAzY; else goto ccAzZ;
       ccAzY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAzZ: // global
           (_ccAzU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAzU::I64 == 0) goto ccAzW; else goto ccAzV;
       ccAzW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAzV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAzU::I64;
           R2 = lvl16_rcykD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.873945441 UTC

[section ""data" . lvl18_rcykF_closure" {
     lvl18_rcykF_closure:
         const lvl18_rcykF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_rcykF_entry() //  [R1]
         { info_tbl: [(ccAAh,
                       label: lvl18_rcykF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAAh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccAAi; else goto ccAAj;
       ccAAi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAAj: // global
           (_ccAAb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAAb::I64 == 0) goto ccAAd; else goto ccAAc;
       ccAAd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAAc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAAb::I64;
           I64[Sp - 24] = block_ccAAe_info;
           R4 = lvl17_rcykE_closure;
           R3 = 1;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccAAe() //  [R1, R2]
         { info_tbl: [(ccAAe,
                       label: block_ccAAe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAAe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAAm; else goto ccAAl;
       ccAAm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccAAl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.879820765 UTC

[section ""data" . lvl19_rcykG_closure" {
     lvl19_rcykG_closure:
         const lvl19_rcykG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_rcykG_entry() //  [R1]
         { info_tbl: [(ccAAH,
                       label: lvl19_rcykG_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAAH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAAI; else goto ccAAJ;
       ccAAI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAAJ: // global
           (_ccAAE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAAE::I64 == 0) goto ccAAG; else goto ccAAF;
       ccAAG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAAF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAAE::I64;
           R3 = lvl18_rcykF_closure;
           R2 = lvl15_rcykC_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.88363041 UTC

[section ""cstring" . lvl20_rcykH_bytes" {
     lvl20_rcykH_bytes:
         I8[] [116,111,69,110,117,109,123,66,121,116,101,79,114,100,101,114,125,58,32,116,97,103,32,40]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.886054537 UTC

[section ""data" . GHC.ByteOrder.$wlvl_closure" {
     GHC.ByteOrder.$wlvl_closure:
         const GHC.ByteOrder.$wlvl_info;
         const 0;
 },
 sat_scAeG_entry() //  [R1]
         { info_tbl: [(ccAB4,
                       label: sat_scAeG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAB4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccAB5; else goto ccAB6;
       ccAB5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAB6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccAB1_info;
           R4 = lvl19_rcykG_closure;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccAB1() //  [R1, R2]
         { info_tbl: [(ccAB1,
                       label: block_ccAB1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAB1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAB9; else goto ccAB8;
       ccAB9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccAB8: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$wlvl_entry() //  [R2]
         { info_tbl: [(ccABc,
                       label: GHC.ByteOrder.$wlvl_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccABc: // global
           _scAeC::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccABd; else goto ccABe;
       ccABe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccABg; else goto ccABf;
       ccABg: // global
           HpAlloc = 24;
           goto ccABd;
       ccABd: // global
           R2 = _scAeC::I64;
           R1 = GHC.ByteOrder.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccABf: // global
           I64[Hp - 16] = sat_scAeG_info;
           I64[Hp] = _scAeC::I64;
           I64[Sp - 8] = block_ccABa_info;
           R3 = Hp - 16;
           R2 = lvl20_rcykH_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccABa() //  [R1]
         { info_tbl: [(ccABa,
                       label: block_ccABa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccABa: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.895764273 UTC

[section ""data" . GHC.ByteOrder.$w$ctoEnum_closure" {
     GHC.ByteOrder.$w$ctoEnum_closure:
         const GHC.ByteOrder.$w$ctoEnum_info;
         const 0;
 },
 GHC.ByteOrder.$w$ctoEnum_entry() //  [R2]
         { info_tbl: [(ccABO,
                       label: GHC.ByteOrder.$w$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccABO: // global
           _scAeI::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto ccABW; else goto ccABN;
       ccABN: // global
           if (%MO_S_Gt_W64(_scAeI::I64, 1)) goto ccABW; else goto ccABX;
       ccABW: // global
           R2 = _scAeI::I64;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ccABX: // global
           R1 = I64[(_scAeI::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.899868221 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_entry() //  [R2]
         { info_tbl: [(ccACc,
                       label: GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccACc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccACd; else goto ccACe;
       ccACd: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccACe: // global
           I64[Sp - 8] = block_ccAC9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucACi; else goto ccACa;
       ucACi: // global
           call _ccAC9(R1) args: 0, res: 0, upd: 0;
       ccACa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAC9() //  [R1]
         { info_tbl: [(ccAC9,
                       label: block_ccAC9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAC9: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.ByteOrder.$w$ctoEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.905398217 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go2_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go2_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go2_info;
 },
 sat_scAeS_entry() //  [R1]
         { info_tbl: [(ccACF,
                       label: sat_scAeS_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccACF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccACG; else goto ccACH;
       ccACG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccACH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAeQ::I64 = I64[R1 + 16];
           if (_scAeQ::I64 != 1) goto ccACD; else goto ccACE;
       ccACD: // global
           R2 = _scAeQ::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
       ccACE: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAeP_entry() //  [R1]
         { info_tbl: [(ccACO,
                       label: sat_scAeP_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccACO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccACP; else goto ccACQ;
       ccACP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccACQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_go2_entry() //  [R2]
         { info_tbl: [(ccACS,
                       label: GHC.ByteOrder.$fEnumByteOrder_go2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccACS: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccACW; else goto ccACV;
       ccACW: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccACV: // global
           I64[Hp - 64] = sat_scAeS_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAeP_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.913432353 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder2_closure" {
     GHC.ByteOrder.$fEnumByteOrder2_closure:
         const GHC.ByteOrder.$fEnumByteOrder2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder2_entry() //  [R1]
         { info_tbl: [(ccADs,
                       label: GHC.ByteOrder.$fEnumByteOrder2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccADs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccADt; else goto ccADu;
       ccADt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccADu: // global
           (_ccADp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccADp::I64 == 0) goto ccADr; else goto ccADq;
       ccADr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccADq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccADp::I64;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.917367009 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder1_closure" {
     GHC.ByteOrder.$fEnumByteOrder1_closure:
         const GHC.ByteOrder.$fEnumByteOrder1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder1_entry() //  [R1]
         { info_tbl: [(ccADJ,
                       label: GHC.ByteOrder.$fEnumByteOrder1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccADJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccADK; else goto ccADL;
       ccADK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccADL: // global
           (_ccADG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccADG::I64 == 0) goto ccADI; else goto ccADH;
       ccADI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccADH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccADG::I64;
           R2 = 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.921811183 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_entry() //  [R2]
         { info_tbl: [(ccAE5,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAE5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccAE6; else goto ccAE7;
       ccAE6: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAE7: // global
           I64[Sp - 8] = block_ccADY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucAEe; else goto ccADZ;
       ucAEe: // global
           call _ccADY(R1) args: 0, res: 0, upd: 0;
       ccADZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccADY() //  [R1]
         { info_tbl: [(ccADY,
                       label: block_ccADY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccADY: // global
           if (R1 & 7 == 1) goto ccAE2; else goto ccAE3;
       ccAE2: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccAE3: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:29.932444652 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info;
 },
 sat_scAfc_entry() //  [R1]
         { info_tbl: [(ccAFe,
                       label: sat_scAfc_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAFe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAFf; else goto ccAFg;
       ccAFf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAFg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scAf7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfa_entry() //  [R1]
         { info_tbl: [(ccAFl,
                       label: sat_scAfa_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAFl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAFm; else goto ccAFn;
       ccAFm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAFn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfd_entry() //  [R1]
         { info_tbl: [(ccAFt,
                       label: sat_scAfd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAFt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAFu; else goto ccAFv;
       ccAFu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAFv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scAf7_entry() //  [R1, R2]
         { info_tbl: [(ccAFz,
                       label: go_dn_scAf7_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAFz: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAFD; else goto ccAFC;
       ccAFD: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAFC: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccAFx; else goto ccAFy;
       ccAFx: // global
           _scAf5::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAfc_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAf5::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAfa_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAFy: // global
           I64[Hp - 80] = sat_scAfd_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAFF::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAFF::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scAfe_entry() //  [R1]
         { info_tbl: [(ccAFG,
                       label: sat_scAfe_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAFG: // global
           _scAfe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAFH; else goto ccAFI;
       ccAFI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAFK; else goto ccAFJ;
       ccAFK: // global
           HpAlloc = 24;
           goto ccAFH;
       ccAFH: // global
           R1 = _scAfe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAFJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAfe::P64;
           _scAf0::I64 = I64[_scAfe::P64 + 24];
           _scAf5::I64 = _scAf0::I64 - I64[_scAfe::P64 + 16];
           I64[Hp - 16] = go_dn_scAf7_info;
           I64[Hp - 8] = _scAf5::I64;
           I64[Hp] = 1 - _scAf5::I64;
           R2 = _scAf0::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scAf7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAf4_entry() //  [R1]
         { info_tbl: [(ccAFP,
                       label: sat_scAf4_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAFP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAFQ; else goto ccAFR;
       ccAFQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAFR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfg_entry() //  [R1]
         { info_tbl: [(ccAG0,
                       label: sat_scAfg_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAG0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAG1; else goto ccAG2;
       ccAG1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAG2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfq_entry() //  [R1]
         { info_tbl: [(ccAGv,
                       label: sat_scAfq_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAGv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAGw; else goto ccAGx;
       ccAGw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAGx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scAfl_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfo_entry() //  [R1]
         { info_tbl: [(ccAGC,
                       label: sat_scAfo_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAGC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAGD; else goto ccAGE;
       ccAGD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAGE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfr_entry() //  [R1]
         { info_tbl: [(ccAGK,
                       label: sat_scAfr_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAGK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAGL; else goto ccAGM;
       ccAGL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAGM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scAfl_entry() //  [R1, R2]
         { info_tbl: [(ccAGQ,
                       label: go_up_scAfl_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAGQ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAGU; else goto ccAGT;
       ccAGU: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAGT: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccAGO; else goto ccAGP;
       ccAGO: // global
           _scAfj::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAfq_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAfj::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAfo_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAGP: // global
           I64[Hp - 80] = sat_scAfr_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAGW::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAGW::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scAfs_entry() //  [R1]
         { info_tbl: [(ccAGX,
                       label: sat_scAfs_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAGX: // global
           _scAfs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAGY; else goto ccAGZ;
       ccAGZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAH1; else goto ccAH0;
       ccAH1: // global
           HpAlloc = 24;
           goto ccAGY;
       ccAGY: // global
           R1 = _scAfs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAH0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAfs::P64;
           _scAf0::I64 = I64[_scAfs::P64 + 24];
           _scAfj::I64 = _scAf0::I64 - I64[_scAfs::P64 + 16];
           I64[Hp - 16] = go_up_scAfl_info;
           I64[Hp - 8] = _scAfj::I64;
           I64[Hp] = 1 - _scAfj::I64;
           R2 = _scAf0::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scAfl_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfi_entry() //  [R1]
         { info_tbl: [(ccAH6,
                       label: sat_scAfi_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAH6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAH7; else goto ccAH8;
       ccAH7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAH8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfu_entry() //  [R1]
         { info_tbl: [(ccAHh,
                       label: sat_scAfu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAHh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAHi; else goto ccAHj;
       ccAHi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAHj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfF_entry() //  [R1]
         { info_tbl: [(ccAHP,
                       label: sat_scAfF_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAHP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAHQ; else goto ccAHR;
       ccAHQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAHR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scAfA_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfD_entry() //  [R1]
         { info_tbl: [(ccAHW,
                       label: sat_scAfD_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAHW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAHX; else goto ccAHY;
       ccAHX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAHY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfG_entry() //  [R1]
         { info_tbl: [(ccAI4,
                       label: sat_scAfG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAI4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAI5; else goto ccAI6;
       ccAI5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAI6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scAfA_entry() //  [R1, R2]
         { info_tbl: [(ccAIa,
                       label: go_dn_scAfA_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAIa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAIe; else goto ccAId;
       ccAIe: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAId: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccAI8; else goto ccAI9;
       ccAI8: // global
           _scAfy::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAfF_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAfy::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAfD_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAI9: // global
           I64[Hp - 80] = sat_scAfG_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAIg::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAIg::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scAfH_entry() //  [R1]
         { info_tbl: [(ccAIh,
                       label: sat_scAfH_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAIh: // global
           _scAfH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAIi; else goto ccAIj;
       ccAIj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAIl; else goto ccAIk;
       ccAIl: // global
           HpAlloc = 24;
           goto ccAIi;
       ccAIi: // global
           R1 = _scAfH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAIk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAfH::P64;
           _scAf0::I64 = I64[_scAfH::P64 + 24];
           _scAfy::I64 = _scAf0::I64 - I64[_scAfH::P64 + 16];
           I64[Hp - 16] = go_dn_scAfA_info;
           I64[Hp - 8] = _scAfy::I64;
           I64[Hp] = 0 - _scAfy::I64;
           R2 = _scAf0::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scAfA_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfx_entry() //  [R1]
         { info_tbl: [(ccAIq,
                       label: sat_scAfx_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAIq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAIr; else goto ccAIs;
       ccAIr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAIs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfJ_entry() //  [R1]
         { info_tbl: [(ccAIB,
                       label: sat_scAfJ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAIB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAIC; else goto ccAID;
       ccAIC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAID: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfT_entry() //  [R1]
         { info_tbl: [(ccAJ6,
                       label: sat_scAfT_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAJ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAJ7; else goto ccAJ8;
       ccAJ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAJ8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scAfO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfR_entry() //  [R1]
         { info_tbl: [(ccAJd,
                       label: sat_scAfR_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAJd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAJe; else goto ccAJf;
       ccAJe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAJf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfU_entry() //  [R1]
         { info_tbl: [(ccAJl,
                       label: sat_scAfU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAJl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAJm; else goto ccAJn;
       ccAJm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAJn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scAfO_entry() //  [R1, R2]
         { info_tbl: [(ccAJr,
                       label: go_up_scAfO_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAJr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAJv; else goto ccAJu;
       ccAJv: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAJu: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccAJp; else goto ccAJq;
       ccAJp: // global
           _scAfM::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAfT_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAfM::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAfR_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAJq: // global
           I64[Hp - 80] = sat_scAfU_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAJx::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAJx::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scAfV_entry() //  [R1]
         { info_tbl: [(ccAJy,
                       label: sat_scAfV_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAJy: // global
           _scAfV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAJz; else goto ccAJA;
       ccAJA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAJC; else goto ccAJB;
       ccAJC: // global
           HpAlloc = 24;
           goto ccAJz;
       ccAJz: // global
           R1 = _scAfV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAJB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAfV::P64;
           _scAf0::I64 = I64[_scAfV::P64 + 24];
           _scAfM::I64 = _scAf0::I64 - I64[_scAfV::P64 + 16];
           I64[Hp - 16] = go_up_scAfO_info;
           I64[Hp - 8] = _scAfM::I64;
           I64[Hp] = 0 - _scAfM::I64;
           R2 = _scAf0::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scAfO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfL_entry() //  [R1]
         { info_tbl: [(ccAJH,
                       label: sat_scAfL_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAJH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAJI; else goto ccAJJ;
       ccAJI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAJJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAfX_entry() //  [R1]
         { info_tbl: [(ccAJS,
                       label: sat_scAfX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAJS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAJT; else goto ccAJU;
       ccAJT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAJU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(ccAK2,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAK2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAK3; else goto ccAK4;
       ccAK3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAK4: // global
           I64[Sp - 16] = block_ccAJV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucALc; else goto ccAJW;
       ucALc: // global
           call _ccAJV(R1) args: 0, res: 0, upd: 0;
       ccAJW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAJV() //  [R1]
         { info_tbl: [(ccAJV,
                       label: block_ccAJV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAJV: // global
           _scAeW::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAJZ; else goto ccAK0;
       ccAJZ: // global
           _scAeY::I64 = 0;
           goto scAeX;
       ccAK0: // global
           _scAeY::I64 = 1;
           goto scAeX;
       scAeX: // global
           I64[Sp] = block_ccAK5_info;
           R1 = _scAeW::P64;
           I64[Sp + 8] = _scAeY::I64;
           if (R1 & 7 != 0) goto ucALb; else goto ccAKP;
       ucALb: // global
           call _ccAK5(R1) args: 0, res: 0, upd: 0;
       ccAKP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAK5() //  [R1]
         { info_tbl: [(ccAK5,
                       label: block_ccAK5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAK5: // global
           if (R1 & 7 == 1) goto ccAKV; else goto ccAKZ;
       ccAKV: // global
           I64[Sp] = 0;
           goto ucALe;
       ccAKZ: // global
           I64[Sp] = 1;
           goto ucALe;
       ucALe: // global
           call _ccAEF() args: 0, res: 0, upd: 0;
     }
 },
 _ccAEF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAEF: // global
           Hp = Hp + 80;
           _scAf0::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto ccAK9; else goto ccAK8;
       ccAK9: // global
           HpAlloc = 80;
           I64[Sp] = block_ccAEE_info;
           R1 = _scAf0::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccAK8: // global
           _scAeY::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_scAeY::I64,
                            _scAf0::I64)) goto ccAKu; else goto ccAKO;
       ccAKu: // global
           if (%MO_S_Lt_W64(_scAf0::I64,
                            _scAeY::I64)) goto ccAKj; else goto ccAKs;
       ccAKj: // global
           if (%MO_S_Le_W64(1, _scAf0::I64)) goto ccAKc; else goto ccAKh;
       ccAKc: // global
           I64[Hp - 72] = sat_scAfe_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = _scAf0::I64;
           I64[Hp - 40] = sat_scAf4_info;
           I64[Hp - 24] = _scAeY::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKh: // global
           if (%MO_S_Gt_W64(1, _scAeY::I64)) goto ccAKL; else goto ccAKf;
       ccAKf: // global
           I64[Hp - 72] = sat_scAfg_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccAKd::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccAKd::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKs: // global
           if (%MO_S_Ge_W64(1, _scAf0::I64)) goto ccAKm; else goto ccAKr;
       ccAKm: // global
           I64[Hp - 72] = sat_scAfs_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = _scAf0::I64;
           I64[Hp - 40] = sat_scAfi_info;
           I64[Hp - 24] = _scAeY::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKr: // global
           if (%MO_S_Lt_W64(1, _scAeY::I64)) goto ccAKL; else goto ccAKp;
       ccAKp: // global
           I64[Hp - 72] = sat_scAfu_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccAKn::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccAKn::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKO: // global
           if (%MO_S_Lt_W64(_scAf0::I64,
                            _scAeY::I64)) goto ccAKE; else goto ccAKN;
       ccAKE: // global
           if (%MO_S_Le_W64(0, _scAf0::I64)) goto ccAKx; else goto ccAKC;
       ccAKx: // global
           I64[Hp - 72] = sat_scAfH_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = _scAf0::I64;
           I64[Hp - 40] = sat_scAfx_info;
           I64[Hp - 24] = _scAeY::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKC: // global
           if (%MO_S_Gt_W64(0, _scAeY::I64)) goto ccAKL; else goto ccAKA;
       ccAKA: // global
           I64[Hp - 72] = sat_scAfJ_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccAKy::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccAKy::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKN: // global
           if (%MO_S_Ge_W64(0, _scAf0::I64)) goto ccAKH; else goto ccAKM;
       ccAKH: // global
           I64[Hp - 72] = sat_scAfV_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = _scAf0::I64;
           I64[Hp - 40] = sat_scAfL_info;
           I64[Hp - 24] = _scAeY::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKM: // global
           if (%MO_S_Lt_W64(0, _scAeY::I64)) goto ccAKL; else goto ccAKK;
       ccAKL: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKK: // global
           I64[Hp - 72] = sat_scAfX_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccAKI::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccAKI::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccAEE() //  [R1]
         { info_tbl: [(ccAEE,
                       label: block_ccAEE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAEE: // global
           I64[Sp] = R1;
           call _ccAEF() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.00466618 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go1_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go1_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go1_info;
         const 0;
 },
 sat_scAg6_entry() //  [R1]
         { info_tbl: [(ccAQI,
                       label: sat_scAg6_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAQI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAQJ; else goto ccAQK;
       ccAQJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAQK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAg4::I64 = I64[R1 + 16];
           if (_scAg4::I64 != 0) goto ccAQG; else goto ccAQH;
       ccAQG: // global
           R2 = _scAg4::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go1_entry(R2) args: 24, res: 0, upd: 24;
       ccAQH: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAg3_entry() //  [R1]
         { info_tbl: [(ccAQW,
                       label: sat_scAg3_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAQW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAQX; else goto ccAR5;
       ccAQX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAR5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAg0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAg0::I64, 0)) goto ccAR3; else goto ccAQV;
       ccAQV: // global
           if (%MO_S_Gt_W64(_scAg0::I64, 1)) goto ccAR3; else goto ccAR4;
       ccAR3: // global
           R2 = _scAg0::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAR4: // global
           R1 = I64[(_scAg0::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_go1_entry() //  [R2]
         { info_tbl: [(ccAR7,
                       label: GHC.ByteOrder.$fEnumByteOrder_go1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAR7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccARb; else goto ccARa;
       ccARb: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccARa: // global
           I64[Hp - 64] = sat_scAg6_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAg3_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.013489383 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go_info;
         const 0;
 },
 sat_scAgd_entry() //  [R1]
         { info_tbl: [(ccARN,
                       label: sat_scAgd_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccARN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccARO; else goto ccARP;
       ccARO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccARP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgb::I64 = I64[R1 + 16];
           if (_scAgb::I64 != 1) goto ccARL; else goto ccARM;
       ccARL: // global
           R2 = _scAgb::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go_entry(R2) args: 24, res: 0, upd: 24;
       ccARM: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAga_entry() //  [R1]
         { info_tbl: [(ccAS1,
                       label: sat_scAga_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAS1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAS2; else goto ccASa;
       ccAS2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccASa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAg7::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAg7::I64, 0)) goto ccAS8; else goto ccAS0;
       ccAS0: // global
           if (%MO_S_Gt_W64(_scAg7::I64, 1)) goto ccAS8; else goto ccAS9;
       ccAS8: // global
           R2 = _scAg7::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAS9: // global
           R1 = I64[(_scAg7::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_go_entry() //  [R2]
         { info_tbl: [(ccASc,
                       label: GHC.ByteOrder.$fEnumByteOrder_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccASc: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccASg; else goto ccASf;
       ccASg: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccASf: // global
           I64[Hp - 64] = sat_scAgd_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAga_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.022318909 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_entry() //  [R2, R3]
         { info_tbl: [(ccAST,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAST: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccASU; else goto ccASV;
       ccASU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccASV: // global
           I64[Sp - 16] = block_ccASM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucATu; else goto ccASN;
       ucATu: // global
           call _ccASM(R1) args: 0, res: 0, upd: 0;
       ccASN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccASM() //  [R1]
         { info_tbl: [(ccASM,
                       label: block_ccASM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccASM: // global
           _scAgf::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccASQ; else goto ccASR;
       ccASQ: // global
           _scAgh::I64 = 0;
           goto scAgg;
       ccASR: // global
           _scAgh::I64 = 1;
           goto scAgg;
       scAgg: // global
           I64[Sp] = block_ccASZ_info;
           R1 = _scAgf::P64;
           I64[Sp + 8] = _scAgh::I64;
           if (R1 & 7 != 0) goto ucATt; else goto ccAT1;
       ucATt: // global
           call _ccASZ(R1) args: 0, res: 0, upd: 0;
       ccAT1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccASZ() //  [R1]
         { info_tbl: [(ccASZ,
                       label: block_ccASZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccASZ: // global
           _scAgh::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto ccATc; else goto ccATl;
       ccATc: // global
           if (%MO_S_Gt_W64(_scAgh::I64, 0)) goto ccATk; else goto ccAT9;
       ccAT9: // global
           R2 = _scAgh::I64;
           Sp = Sp + 16;
           call GHC.ByteOrder.$fEnumByteOrder_go1_entry(R2) args: 8, res: 0, upd: 8;
       ccATl: // global
           if (%MO_S_Gt_W64(_scAgh::I64, 1)) goto ccATk; else goto ccATj;
       ccATk: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccATj: // global
           R2 = _scAgh::I64;
           Sp = Sp + 16;
           call GHC.ByteOrder.$fEnumByteOrder_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.037936411 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info;
         const 0;
 },
 sat_scAgI_entry() //  [R1]
         { info_tbl: [(ccAUD,
                       label: sat_scAgI_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAUD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAUE; else goto ccAUF;
       ccAUE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAUF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scAgB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAgG_entry() //  [R1]
         { info_tbl: [(ccAUP,
                       label: sat_scAgG_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAUP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAUQ; else goto ccAUY;
       ccAUQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAUY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgC::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgC::I64, 0)) goto ccAUW; else goto ccAUO;
       ccAUO: // global
           if (%MO_S_Gt_W64(_scAgC::I64, 1)) goto ccAUW; else goto ccAUX;
       ccAUW: // global
           R2 = _scAgC::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAUX: // global
           R1 = I64[(_scAgC::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAgL_entry() //  [R1]
         { info_tbl: [(ccAV9,
                       label: sat_scAgL_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAV9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAVa; else goto ccAVi;
       ccAVa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAVi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgC::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgC::I64, 0)) goto ccAVg; else goto ccAV8;
       ccAV8: // global
           if (%MO_S_Gt_W64(_scAgC::I64, 1)) goto ccAVg; else goto ccAVh;
       ccAVg: // global
           R2 = _scAgC::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAVh: // global
           R1 = I64[(_scAgC::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scAgB_entry() //  [R1, R2]
         { info_tbl: [(ccAVm,
                       label: go_dn_scAgB_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAVm: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAVq; else goto ccAVp;
       ccAVq: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAVp: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccAVk; else goto ccAVl;
       ccAVk: // global
           _scAgz::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAgI_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAgz::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAgG_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAVl: // global
           I64[Hp - 80] = sat_scAgL_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAVs::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAVs::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scAgM_entry() //  [R1]
         { info_tbl: [(ccAVt,
                       label: sat_scAgM_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAVt: // global
           _scAgM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAVu; else goto ccAVv;
       ccAVv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAVx; else goto ccAVw;
       ccAVx: // global
           HpAlloc = 24;
           goto ccAVu;
       ccAVu: // global
           R1 = _scAgM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAVw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAgM::P64;
           _scAgs::I64 = I64[_scAgM::P64 + 24];
           _scAgz::I64 = _scAgs::I64 - I64[_scAgM::P64 + 16];
           I64[Hp - 16] = go_dn_scAgB_info;
           I64[Hp - 8] = _scAgz::I64;
           I64[Hp] = 0 - _scAgz::I64;
           R2 = _scAgs::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scAgB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAgy_entry() //  [R1]
         { info_tbl: [(ccAVH,
                       label: sat_scAgy_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAVH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAVI; else goto ccAVQ;
       ccAVI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAVQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccAVO; else goto ccAVG;
       ccAVG: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccAVO; else goto ccAVP;
       ccAVO: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAVP: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAgQ_entry() //  [R1]
         { info_tbl: [(ccAW4,
                       label: sat_scAgQ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAW4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAW5; else goto ccAWd;
       ccAW5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAWd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccAWb; else goto ccAW3;
       ccAW3: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccAWb; else goto ccAWc;
       ccAWb: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAWc: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAh4_entry() //  [R1]
         { info_tbl: [(ccAWG,
                       label: sat_scAh4_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAWG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAWH; else goto ccAWI;
       ccAWH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAWI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scAgX_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAh2_entry() //  [R1]
         { info_tbl: [(ccAWS,
                       label: sat_scAh2_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAWS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAWT; else goto ccAX1;
       ccAWT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAX1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgY::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgY::I64, 0)) goto ccAWZ; else goto ccAWR;
       ccAWR: // global
           if (%MO_S_Gt_W64(_scAgY::I64, 1)) goto ccAWZ; else goto ccAX0;
       ccAWZ: // global
           R2 = _scAgY::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAX0: // global
           R1 = I64[(_scAgY::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAh7_entry() //  [R1]
         { info_tbl: [(ccAXc,
                       label: sat_scAh7_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAXc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAXd; else goto ccAXl;
       ccAXd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAXl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgY::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgY::I64, 0)) goto ccAXj; else goto ccAXb;
       ccAXb: // global
           if (%MO_S_Gt_W64(_scAgY::I64, 1)) goto ccAXj; else goto ccAXk;
       ccAXj: // global
           R2 = _scAgY::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAXk: // global
           R1 = I64[(_scAgY::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scAgX_entry() //  [R1, R2]
         { info_tbl: [(ccAXp,
                       label: go_up_scAgX_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAXp: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAXt; else goto ccAXs;
       ccAXt: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAXs: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccAXn; else goto ccAXo;
       ccAXn: // global
           _scAgV::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAh4_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAgV::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAh2_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAXo: // global
           I64[Hp - 80] = sat_scAh7_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAXv::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAXv::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scAh8_entry() //  [R1]
         { info_tbl: [(ccAXw,
                       label: sat_scAh8_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAXw: // global
           _scAh8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAXx; else goto ccAXy;
       ccAXy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAXA; else goto ccAXz;
       ccAXA: // global
           HpAlloc = 24;
           goto ccAXx;
       ccAXx: // global
           R1 = _scAh8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAXz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAh8::P64;
           _scAgs::I64 = I64[_scAh8::P64 + 24];
           _scAgV::I64 = _scAgs::I64 - I64[_scAh8::P64 + 16];
           I64[Hp - 16] = go_up_scAgX_info;
           I64[Hp - 8] = _scAgV::I64;
           I64[Hp] = 0 - _scAgV::I64;
           R2 = _scAgs::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scAgX_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAgU_entry() //  [R1]
         { info_tbl: [(ccAXK,
                       label: sat_scAgU_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAXK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAXL; else goto ccAXT;
       ccAXL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAXT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccAXR; else goto ccAXJ;
       ccAXJ: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccAXR; else goto ccAXS;
       ccAXR: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAXS: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAhc_entry() //  [R1]
         { info_tbl: [(ccAY7,
                       label: sat_scAhc_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAY7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAY8; else goto ccAYg;
       ccAY8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAYg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccAYe; else goto ccAY6;
       ccAY6: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccAYe; else goto ccAYf;
       ccAYe: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAYf: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAhr_entry() //  [R1]
         { info_tbl: [(ccAYN,
                       label: sat_scAhr_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAYN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAYO; else goto ccAYP;
       ccAYO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAYP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scAhk_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAhp_entry() //  [R1]
         { info_tbl: [(ccAYZ,
                       label: sat_scAhp_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAYZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAZ0; else goto ccAZ8;
       ccAZ0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAZ8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAhl::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAhl::I64, 0)) goto ccAZ6; else goto ccAYY;
       ccAYY: // global
           if (%MO_S_Gt_W64(_scAhl::I64, 1)) goto ccAZ6; else goto ccAZ7;
       ccAZ6: // global
           R2 = _scAhl::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAZ7: // global
           R1 = I64[(_scAhl::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAhu_entry() //  [R1]
         { info_tbl: [(ccAZj,
                       label: sat_scAhu_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAZj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAZk; else goto ccAZs;
       ccAZk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAZs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAhl::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAhl::I64, 0)) goto ccAZq; else goto ccAZi;
       ccAZi: // global
           if (%MO_S_Gt_W64(_scAhl::I64, 1)) goto ccAZq; else goto ccAZr;
       ccAZq: // global
           R2 = _scAhl::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAZr: // global
           R1 = I64[(_scAhl::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_dn_scAhk_entry() //  [R1, R2]
         { info_tbl: [(ccAZw,
                       label: go_dn_scAhk_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAZw: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAZA; else goto ccAZz;
       ccAZA: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAZz: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccAZu; else goto ccAZv;
       ccAZu: // global
           _scAhi::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAhr_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAhi::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAhp_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAZv: // global
           I64[Hp - 80] = sat_scAhu_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAZC::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAZC::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scAhv_entry() //  [R1]
         { info_tbl: [(ccAZD,
                       label: sat_scAhv_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAZD: // global
           _scAhv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAZE; else goto ccAZF;
       ccAZF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAZH; else goto ccAZG;
       ccAZH: // global
           HpAlloc = 24;
           goto ccAZE;
       ccAZE: // global
           R1 = _scAhv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAZG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAhv::P64;
           _scAgs::I64 = I64[_scAhv::P64 + 24];
           _scAhi::I64 = _scAgs::I64 - I64[_scAhv::P64 + 16];
           I64[Hp - 16] = go_dn_scAhk_info;
           I64[Hp - 8] = _scAhi::I64;
           I64[Hp] = 1 - _scAhi::I64;
           R2 = _scAgs::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scAhk_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAhh_entry() //  [R1]
         { info_tbl: [(ccAZR,
                       label: sat_scAhh_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAZR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAZS; else goto ccB00;
       ccAZS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB00: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccAZY; else goto ccAZQ;
       ccAZQ: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccAZY; else goto ccAZZ;
       ccAZY: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAZZ: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAhz_entry() //  [R1]
         { info_tbl: [(ccB0e,
                       label: sat_scAhz_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB0e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccB0f; else goto ccB0n;
       ccB0f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB0n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccB0l; else goto ccB0d;
       ccB0d: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccB0l; else goto ccB0m;
       ccB0l: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccB0m: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAhN_entry() //  [R1]
         { info_tbl: [(ccB0Q,
                       label: sat_scAhN_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB0Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccB0R; else goto ccB0S;
       ccB0R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB0S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scAhG_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAhL_entry() //  [R1]
         { info_tbl: [(ccB12,
                       label: sat_scAhL_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB12: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccB13; else goto ccB1b;
       ccB13: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB1b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAhH::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAhH::I64, 0)) goto ccB19; else goto ccB11;
       ccB11: // global
           if (%MO_S_Gt_W64(_scAhH::I64, 1)) goto ccB19; else goto ccB1a;
       ccB19: // global
           R2 = _scAhH::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccB1a: // global
           R1 = I64[(_scAhH::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAhQ_entry() //  [R1]
         { info_tbl: [(ccB1m,
                       label: sat_scAhQ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB1m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccB1n; else goto ccB1v;
       ccB1n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB1v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAhH::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAhH::I64, 0)) goto ccB1t; else goto ccB1l;
       ccB1l: // global
           if (%MO_S_Gt_W64(_scAhH::I64, 1)) goto ccB1t; else goto ccB1u;
       ccB1t: // global
           R2 = _scAhH::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccB1u: // global
           R1 = I64[(_scAhH::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 go_up_scAhG_entry() //  [R1, R2]
         { info_tbl: [(ccB1z,
                       label: go_up_scAhG_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB1z: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccB1D; else goto ccB1C;
       ccB1D: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccB1C: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccB1x; else goto ccB1y;
       ccB1x: // global
           _scAhE::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAhN_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAhE::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAhL_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB1y: // global
           I64[Hp - 80] = sat_scAhQ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccB1F::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccB1F::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scAhR_entry() //  [R1]
         { info_tbl: [(ccB1G,
                       label: sat_scAhR_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB1G: // global
           _scAhR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccB1H; else goto ccB1I;
       ccB1I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccB1K; else goto ccB1J;
       ccB1K: // global
           HpAlloc = 24;
           goto ccB1H;
       ccB1H: // global
           R1 = _scAhR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB1J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAhR::P64;
           _scAgs::I64 = I64[_scAhR::P64 + 24];
           _scAhE::I64 = _scAgs::I64 - I64[_scAhR::P64 + 16];
           I64[Hp - 16] = go_up_scAhG_info;
           I64[Hp - 8] = _scAhE::I64;
           I64[Hp] = 1 - _scAhE::I64;
           R2 = _scAgs::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scAhG_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAhD_entry() //  [R1]
         { info_tbl: [(ccB1U,
                       label: sat_scAhD_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB1U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccB1V; else goto ccB23;
       ccB1V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB23: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccB21; else goto ccB1T;
       ccB1T: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccB21; else goto ccB22;
       ccB21: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccB22: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_scAhV_entry() //  [R1]
         { info_tbl: [(ccB2h,
                       label: sat_scAhV_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB2h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccB2i; else goto ccB2q;
       ccB2i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB2q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccB2o; else goto ccB2g;
       ccB2g: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccB2o; else goto ccB2p;
       ccB2o: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccB2p: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(ccB2y,
                       label: GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB2y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccB2z; else goto ccB2A;
       ccB2z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccB2A: // global
           I64[Sp - 24] = block_ccB2r_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucB3J; else goto ccB2s;
       ucB3J: // global
           call _ccB2r(R1) args: 0, res: 0, upd: 0;
       ccB2s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccB2r() //  [R1]
         { info_tbl: [(ccB2r,
                       label: block_ccB2r_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB2r: // global
           _scAgn::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccB2v; else goto ccB2w;
       ccB2v: // global
           _scAgq::I64 = 0;
           goto scAgp;
       ccB2w: // global
           _scAgq::I64 = 1;
           goto scAgp;
       scAgp: // global
           I64[Sp] = block_ccB2B_info;
           R1 = _scAgn::P64;
           I64[Sp + 8] = _scAgq::I64;
           if (R1 & 7 != 0) goto ucB3I; else goto ccB3p;
       ucB3I: // global
           call _ccB2B(R1) args: 0, res: 0, upd: 0;
       ccB3p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccB2B() //  [R1]
         { info_tbl: [(ccB2B,
                       label: block_ccB2B_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB2B: // global
           _scAgo::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccB3v; else goto ccB3z;
       ccB3v: // global
           _scAgs::I64 = 0;
           goto scAgr;
       ccB3z: // global
           _scAgs::I64 = 1;
           goto scAgr;
       scAgr: // global
           I64[Sp] = block_ccAU4_info;
           R1 = _scAgo::P64;
           I64[Sp + 16] = _scAgs::I64;
           if (R1 & 7 != 0) goto ucB3K; else goto ccAU5;
       ucB3K: // global
           call _ccAU4(R1) args: 0, res: 0, upd: 0;
       ccAU5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccAU4() //  [R1]
         { info_tbl: [(ccAU4,
                       label: block_ccAU4_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccAU4: // global
           _scAgq::I64 = I64[Sp + 8];
           _scAgs::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto ccB2F; else goto ccB32;
       ccB2F: // global
           Hp = Hp + 80;
           _scAgt::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccB35; else goto ccB2H;
       ccB2H: // global
           if (%MO_S_Lt_W64(_scAgs::I64,
                            _scAgq::I64)) goto ccB2S; else goto ccB31;
       ccB2S: // global
           if (%MO_S_Le_W64(0, _scAgs::I64)) goto ccB2L; else goto ccB2Q;
       ccB2L: // global
           I64[Hp - 72] = sat_scAgM_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = _scAgs::I64;
           I64[Hp - 40] = sat_scAgy_info;
           I64[Hp - 24] = _scAgq::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB2Q: // global
           if (%MO_S_Gt_W64(0, _scAgq::I64)) goto ccB3m; else goto ccB2O;
       ccB2O: // global
           I64[Hp - 72] = sat_scAgQ_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccB2M::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccB2M::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB31: // global
           if (%MO_S_Ge_W64(0, _scAgs::I64)) goto ccB2V; else goto ccB30;
       ccB2V: // global
           I64[Hp - 72] = sat_scAh8_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = _scAgs::I64;
           I64[Hp - 40] = sat_scAgU_info;
           I64[Hp - 24] = _scAgq::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB30: // global
           if (%MO_S_Lt_W64(0, _scAgq::I64)) goto ccB3m; else goto ccB2Y;
       ccB2Y: // global
           I64[Hp - 72] = sat_scAhc_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccB2W::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccB2W::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB32: // global
           Hp = Hp + 80;
           _scAgt::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccB35; else goto ccB34;
       ccB35: // global
           HpAlloc = 80;
           R1 = _scAgt::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccB34: // global
           if (%MO_S_Lt_W64(_scAgs::I64,
                            _scAgq::I64)) goto ccB3f; else goto ccB3o;
       ccB3f: // global
           if (%MO_S_Le_W64(1, _scAgs::I64)) goto ccB38; else goto ccB3d;
       ccB38: // global
           I64[Hp - 72] = sat_scAhv_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = _scAgs::I64;
           I64[Hp - 40] = sat_scAhh_info;
           I64[Hp - 24] = _scAgq::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB3d: // global
           if (%MO_S_Gt_W64(1, _scAgq::I64)) goto ccB3m; else goto ccB3b;
       ccB3b: // global
           I64[Hp - 72] = sat_scAhz_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccB39::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccB39::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB3o: // global
           if (%MO_S_Ge_W64(1, _scAgs::I64)) goto ccB3i; else goto ccB3n;
       ccB3i: // global
           I64[Hp - 72] = sat_scAhR_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = _scAgs::I64;
           I64[Hp - 40] = sat_scAhD_info;
           I64[Hp - 24] = _scAgq::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB3n: // global
           if (%MO_S_Lt_W64(1, _scAgq::I64)) goto ccB3m; else goto ccB3l;
       ccB3m: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB3l: // global
           I64[Hp - 72] = sat_scAhV_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccB3j::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccB3j::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.114887817 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_closure" {
     GHC.ByteOrder.$fEnumByteOrder_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure+2;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure+2;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.11681807 UTC

[section ""data" . GHC.ByteOrder.$trModule3_closure" {
     GHC.ByteOrder.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.118825333 UTC

[section ""data" . GHC.ByteOrder.$trModule1_closure" {
     GHC.ByteOrder.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.12052951 UTC

[section ""data" . GHC.ByteOrder.$trModule_closure" {
     GHC.ByteOrder.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.ByteOrder.$trModule3_closure+1;
         const GHC.ByteOrder.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.122313459 UTC

[section ""cstring" . GHC.ByteOrder.$tcByteOrder2_bytes" {
     GHC.ByteOrder.$tcByteOrder2_bytes:
         I8[] [66,121,116,101,79,114,100,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.124552977 UTC

[section ""data" . GHC.ByteOrder.$tcByteOrder1_closure" {
     GHC.ByteOrder.$tcByteOrder1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tcByteOrder2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.126563854 UTC

[section ""data" . GHC.ByteOrder.$tcByteOrder_closure" {
     GHC.ByteOrder.$tcByteOrder_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tcByteOrder1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16811050684449662084;
         const 17273005335247024091;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.128270265 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian1_closure" {
     GHC.ByteOrder.$tc'BigEndian1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ByteOrder.$tcByteOrder_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.129993384 UTC

[section ""cstring" . GHC.ByteOrder.$tc'BigEndian3_bytes" {
     GHC.ByteOrder.$tc'BigEndian3_bytes:
         I8[] [39,66,105,103,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.131631489 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian2_closure" {
     GHC.ByteOrder.$tc'BigEndian2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tc'BigEndian3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.133371918 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian_closure" {
     GHC.ByteOrder.$tc'BigEndian_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tc'BigEndian2_closure+1;
         const GHC.ByteOrder.$tc'BigEndian1_closure+1;
         const 2645192688778293591;
         const 7455668807059762078;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.135130098 UTC

[section ""cstring" . GHC.ByteOrder.$tc'LittleEndian2_bytes" {
     GHC.ByteOrder.$tc'LittleEndian2_bytes:
         I8[] [39,76,105,116,116,108,101,69,110,100,105,97,110]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.13672884 UTC

[section ""data" . GHC.ByteOrder.$tc'LittleEndian1_closure" {
     GHC.ByteOrder.$tc'LittleEndian1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tc'LittleEndian2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.138470691 UTC

[section ""data" . GHC.ByteOrder.$tc'LittleEndian_closure" {
     GHC.ByteOrder.$tc'LittleEndian_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tc'LittleEndian1_closure+1;
         const GHC.ByteOrder.$tc'BigEndian1_closure+1;
         const 8702700204875460152;
         const 10337679016369298147;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.140282773 UTC

[section ""data" . GHC.ByteOrder.BigEndian_closure" {
     GHC.ByteOrder.BigEndian_closure:
         const GHC.ByteOrder.BigEndian_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.14225963 UTC

[section ""data" . GHC.ByteOrder.LittleEndian_closure" {
     GHC.ByteOrder.LittleEndian_closure:
         const GHC.ByteOrder.LittleEndian_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.143858985 UTC

[section ""relreadonly" . GHC.ByteOrder.ByteOrder_closure_tbl" {
     GHC.ByteOrder.ByteOrder_closure_tbl:
         const GHC.ByteOrder.BigEndian_closure+1;
         const GHC.ByteOrder.LittleEndian_closure+2;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.145660582 UTC

[GHC.ByteOrder.BigEndian_con_entry() //  [R1]
         { info_tbl: [(ccB9k,
                       label: GHC.ByteOrder.BigEndian_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,66,121,116,101,79,114,100,101,114,46,66,105,103,69,110,100,105,97,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB9k: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.149452817 UTC

[GHC.ByteOrder.LittleEndian_con_entry() //  [R1]
         { info_tbl: [(ccB9r,
                       label: GHC.ByteOrder.LittleEndian_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,71,72,67,46,66,121,116,101,79,114,100,101,114,46,76,105,116,116,108,101,69,110,100,105,97,110]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccB9r: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:30.152519646 UTC

[section ""relreadonly" . ScAiT_srt" {
     ScAiT_srt:
         const GHC.ByteOrder.$fReadByteOrder6_closure;
         const GHC.ByteOrder.$fReadByteOrder10_closure;
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure;
         const GHC.ByteOrder.$fShowByteOrder_$cshow_closure;
         const GHC.ByteOrder.$fShowByteOrder1_closure;
         const GHC.Read.choose2_closure;
         const GHC.ByteOrder.$fReadByteOrder_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.ByteOrder.$fReadByteOrder2_closure;
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.ByteOrder.$fReadByteOrder1_closure;
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
         const GHC.ByteOrder.$fReadByteOrder12_closure;
         const GHC.Err.error_closure;
         const lvl12_rcykz_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_closure;
         const GHC.ByteOrder.$fEnumByteOrder3_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_closure;
         const GHC.ByteOrder.$fEnumByteOrder4_closure;
         const lvl17_rcykE_closure;
         const lvl18_rcykF_closure;
         const lvl19_rcykG_closure;
         const GHC.ByteOrder.$wlvl_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure;
         const GHC.ByteOrder.$w$ctoEnum_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure;
         const GHC.ByteOrder.$fEnumByteOrder1_closure;
         const GHC.ByteOrder.$fEnumByteOrder2_closure;
         const GHC.ByteOrder.$fEnumByteOrder_go1_closure;
         const GHC.ByteOrder.$fEnumByteOrder_go_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure;
 }]

