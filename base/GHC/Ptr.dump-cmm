
==================== Output Cmm ====================
2018-03-16 15:59:00.218146845 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:00.218955124 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr4_closure" {
     GHC.Ptr.$fShowFunPtr4_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.21964533 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr3_closure" {
     GHC.Ptr.$fShowFunPtr3_closure:
         const GHC.Types.C#_con_info;
         const 120;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.222143814 UTC

[section ""data" . GHC.Ptr.$w$cshowsPrec_closure" {
     GHC.Ptr.$w$cshowsPrec_closure:
         const GHC.Ptr.$w$cshowsPrec_info;
         const 0;
 },
 sat_s47xV_entry() //  [R1]
         { info_tbl: [(c47BF,
                       label: sat_s47xV_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47BF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47BG; else goto c47BH;
       c47BG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c47BH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ls_s47xS_entry() //  [R1]
         { info_tbl: [(c47BK,
                       label: ls_s47xS_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47BK: // global
           _s47xS::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c47BL; else goto c47BM;
       c47BM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c47BO; else goto c47BN;
       c47BO: // global
           HpAlloc = 24;
           goto c47BL;
       c47BL: // global
           R1 = _s47xS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c47BN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s47xS::P64;
           _s47xQ::I64 = I64[_s47xS::P64 + 16];
           I64[Hp - 16] = sat_s47xV_info;
           I64[Hp] = _s47xQ::I64;
           R6 = Hp - 16;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Numeric.showHex1_closure;
           R3 = GHC.Show.$fShowInteger_closure;
           R2 = GHC.Real.$fIntegralInteger_closure;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 32, res: 0, upd: 24;
     }
 },
 n_s47xZ_entry() //  [R1]
         { info_tbl: [(c47C8,
                       label: n_s47xZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47C8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47C9; else goto c47Ca;
       c47C9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c47Ca: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s47y5_entry() //  [R1]
         { info_tbl: [(c47Cp,
                       label: sat_s47y5_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Cp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47Cq; else goto c47Cr;
       c47Cq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c47Cr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_s47y1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_s47y1_entry() //  [R1, R2]
         { info_tbl: [(c47Cv,
                       label: $wxs_s47y1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Cv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c47Cz; else goto c47Cy;
       c47Cz: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c47Cy: // global
           if (R2 == 1) goto c47Cu; else goto c47Ct;
       c47Cu: // global
           _s47y0::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _s47y0::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47Ct: // global
           I64[Hp - 48] = sat_s47y5_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Ptr.$fShowFunPtr4_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s47y6_entry() //  [R1]
         { info_tbl: [(c47CB,
                       label: sat_s47y6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47CB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c47CC; else goto c47CD;
       c47CC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c47CD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c47BT_info;
           R3 = 0;
           _s47xS::P64 = P64[R1 + 24];
           R2 = _s47xS::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s47xS::P64;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c47BT() //  [R1]
         { info_tbl: [(c47BT,
                       label: block_c47BT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47BT: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c47CG; else goto c47CF;
       c47CG: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c47CF: // global
           _s47xR::P64 = P64[Sp + 8];
           _s47xS::P64 = P64[Sp + 16];
           _s47xX::I64 = 16 - R1;
           if (%MO_S_Ge_W64(0, _s47xX::I64)) goto c47CI; else goto c47CJ;
       c47CI: // global
           Hp = Hp - 72;
           R3 = _s47xR::P64;
           R2 = _s47xS::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c47CJ: // global
           I64[Hp - 64] = n_s47xZ_info;
           P64[Hp - 48] = _s47xR::P64;
           P64[Hp - 40] = _s47xS::P64;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Ptr.$fShowFunPtr4_closure+1;
           P64[Hp - 16] = Hp - 64;
           I64[Hp - 8] = $wxs_s47y1_info;
           P64[Hp] = Hp - 30;
           R2 = _s47xX::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call $wxs_s47y1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Ptr.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c47CL,
                       label: GHC.Ptr.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47CL: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c47CP; else goto c47CO;
       c47CP: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47CO: // global
           I64[Hp - 72] = ls_s47xS_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s47y6_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Ptr.$fShowFunPtr3_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = GHC.Ptr.$fShowFunPtr4_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.225878327 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c47CY,
                       label: GHC.Ptr.$fShowFunPtr_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47CY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47D4; else goto c47D5;
       c47D4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c47D5: // global
           I64[Sp - 16] = block_c47CV_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Da; else goto c47CW;
       u47Da: // global
           call _c47CV(R1) args: 0, res: 0, upd: 0;
       c47CW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47CV() //  [R1]
         { info_tbl: [(c47CV,
                       label: block_c47CV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47CV: // global
           _s47ya::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c47D1_info;
           R3 = _s47ya::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c47D1() //  [R1, R2]
         { info_tbl: [(c47D1,
                       label: block_c47D1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47D1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c47D9; else goto c47D8;
       c47D9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c47D8: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.227169979 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr2_closure" {
     GHC.Ptr.$fShowFunPtr2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.228022491 UTC

[section ""data" . GHC.Ptr.$fShowPtr_$cshow_closure" {
     GHC.Ptr.$fShowPtr_$cshow_closure:
         const GHC.Ptr.$fShowPtr_$cshow_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr_$cshow_entry() //  [R2]
         { info_tbl: [(c47Di,
                       label: GHC.Ptr.$fShowPtr_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Di: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c47Do; else goto c47Dp;
       c47Do: // global
           R2 = R2;
           R1 = GHC.Ptr.$fShowPtr_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c47Dp: // global
           I64[Sp - 8] = block_c47Df_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47Du; else goto c47Dg;
       u47Du: // global
           call _c47Df(R1) args: 0, res: 0, upd: 0;
       c47Dg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Df() //  [R1]
         { info_tbl: [(c47Df,
                       label: block_c47Df_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Df: // global
           I64[Sp] = block_c47Dl_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c47Dl() //  [R1, R2]
         { info_tbl: [(c47Dl,
                       label: block_c47Dl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Dl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c47Dt; else goto c47Ds;
       c47Dt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c47Ds: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.229610852 UTC

[section ""data" . GHC.Ptr.$fShowPtr1_closure" {
     GHC.Ptr.$fShowPtr1_closure:
         const GHC.Ptr.$fShowPtr1_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr1_entry() //  [R2, R3]
         { info_tbl: [(c47DC,
                       label: GHC.Ptr.$fShowPtr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47DC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47DI; else goto c47DJ;
       c47DI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47DJ: // global
           I64[Sp - 16] = block_c47Dz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47DO; else goto c47DA;
       u47DO: // global
           call _c47Dz(R1) args: 0, res: 0, upd: 0;
       c47DA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Dz() //  [R1]
         { info_tbl: [(c47Dz,
                       label: block_c47Dz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Dz: // global
           _s47yn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c47DF_info;
           R3 = _s47yn::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c47DF() //  [R1, R2]
         { info_tbl: [(c47DF,
                       label: block_c47DF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47DF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c47DN; else goto c47DM;
       c47DN: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c47DM: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.231030336 UTC

[section ""data" . GHC.Ptr.$fShowPtr_$cshowList_closure" {
     GHC.Ptr.$fShowPtr_$cshowList_closure:
         const GHC.Ptr.$fShowPtr_$cshowList_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c47DT,
                       label: GHC.Ptr.$fShowPtr_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47DT: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Ptr.$fShowPtr1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.231748499 UTC

[section ""data" . GHC.Ptr.$fShowPtr_closure" {
     GHC.Ptr.$fShowPtr_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure+3;
         const GHC.Ptr.$fShowPtr_$cshow_closure+1;
         const GHC.Ptr.$fShowPtr_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.232643996 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c<_closure" {
     GHC.Ptr.$fOrdFunPtr_$c<_closure:
         const GHC.Ptr.$fOrdFunPtr_$c<_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c<_entry() //  [R2, R3]
         { info_tbl: [(c47E3,
                       label: GHC.Ptr.$fOrdFunPtr_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47E3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47E7; else goto c47E8;
       c47E7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47E8: // global
           I64[Sp - 16] = block_c47E0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Eh; else goto c47E1;
       u47Eh: // global
           call _c47E0(R1) args: 0, res: 0, upd: 0;
       c47E1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47E0() //  [R1]
         { info_tbl: [(c47E0,
                       label: block_c47E0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47E0: // global
           I64[Sp] = block_c47E6_info;
           _s47yy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yy::I64;
           if (R1 & 7 != 0) goto u47Eg; else goto c47Ea;
       u47Eg: // global
           call _c47E6(R1) args: 0, res: 0, upd: 0;
       c47Ea: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47E6() //  [R1]
         { info_tbl: [(c47E6,
                       label: block_c47E6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47E6: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.234271548 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$ccompare_closure" {
     GHC.Ptr.$fOrdFunPtr_$ccompare_closure:
         const GHC.Ptr.$fOrdFunPtr_$ccompare_info;
 },
 GHC.Ptr.$fOrdFunPtr_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c47Ep,
                       label: GHC.Ptr.$fOrdFunPtr_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Ep: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47Et; else goto c47Eu;
       c47Et: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Eu: // global
           I64[Sp - 16] = block_c47Em_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47EN; else goto c47En;
       u47EN: // global
           call _c47Em(R1) args: 0, res: 0, upd: 0;
       c47En: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Em() //  [R1]
         { info_tbl: [(c47Em,
                       label: block_c47Em_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Em: // global
           I64[Sp] = block_c47Es_info;
           _s47yF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yF::I64;
           if (R1 & 7 != 0) goto u47EM; else goto c47Ew;
       u47EM: // global
           call _c47Es(R1) args: 0, res: 0, upd: 0;
       c47Ew: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Es() //  [R1]
         { info_tbl: [(c47Es,
                       label: block_c47Es_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Es: // global
           _s47yF::I64 = I64[Sp + 8];
           _s47yH::I64 = I64[R1 + 7];
           if (_s47yF::I64 >= _s47yH::I64) goto c47EK; else goto c47EL;
       c47EK: // global
           if (_s47yF::I64 == _s47yH::I64) goto c47EI; else goto c47EH;
       c47EI: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47EH: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47EL: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.235944108 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_$c==_closure" {
     GHC.Ptr.$fEqFunPtr_$c==_closure:
         const GHC.Ptr.$fEqFunPtr_$c==_info;
 },
 GHC.Ptr.$fEqFunPtr_$c==_entry() //  [R2, R3]
         { info_tbl: [(c47EV,
                       label: GHC.Ptr.$fEqFunPtr_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47EV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47EZ; else goto c47F0;
       c47EZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqFunPtr_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47F0: // global
           I64[Sp - 16] = block_c47ES_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47F9; else goto c47ET;
       u47F9: // global
           call _c47ES(R1) args: 0, res: 0, upd: 0;
       c47ET: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47ES() //  [R1]
         { info_tbl: [(c47ES,
                       label: block_c47ES_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47ES: // global
           I64[Sp] = block_c47EY_info;
           _s47yN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yN::I64;
           if (R1 & 7 != 0) goto u47F8; else goto c47F2;
       u47F8: // global
           call _c47EY(R1) args: 0, res: 0, upd: 0;
       c47F2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47EY() //  [R1]
         { info_tbl: [(c47EY,
                       label: block_c47EY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47EY: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.237590715 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_$c/=_closure" {
     GHC.Ptr.$fEqFunPtr_$c/=_closure:
         const GHC.Ptr.$fEqFunPtr_$c/=_info;
 },
 GHC.Ptr.$fEqFunPtr_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c47Fh,
                       label: GHC.Ptr.$fEqFunPtr_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Fh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47Fl; else goto c47Fm;
       c47Fl: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqFunPtr_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Fm: // global
           I64[Sp - 16] = block_c47Fe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Fz; else goto c47Ff;
       u47Fz: // global
           call _c47Fe(R1) args: 0, res: 0, upd: 0;
       c47Ff: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Fe() //  [R1]
         { info_tbl: [(c47Fe,
                       label: block_c47Fe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Fe: // global
           I64[Sp] = block_c47Fk_info;
           _s47yU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yU::I64;
           if (R1 & 7 != 0) goto u47Fy; else goto c47Fo;
       u47Fy: // global
           call _c47Fk(R1) args: 0, res: 0, upd: 0;
       c47Fo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Fk() //  [R1]
         { info_tbl: [(c47Fk,
                       label: block_c47Fk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Fk: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c47Fx; else goto c47Fw;
       c47Fx: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47Fw: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.238952017 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_closure" {
     GHC.Ptr.$fEqFunPtr_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Ptr.$fEqFunPtr_$c==_closure+2;
         const GHC.Ptr.$fEqFunPtr_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.241077081 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c<=_closure" {
     GHC.Ptr.$fOrdFunPtr_$c<=_closure:
         const GHC.Ptr.$fOrdFunPtr_$c<=_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c47FH,
                       label: GHC.Ptr.$fOrdFunPtr_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47FH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47FL; else goto c47FM;
       c47FL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47FM: // global
           I64[Sp - 16] = block_c47FE_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47FZ; else goto c47FF;
       u47FZ: // global
           call _c47FE(R1) args: 0, res: 0, upd: 0;
       c47FF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47FE() //  [R1]
         { info_tbl: [(c47FE,
                       label: block_c47FE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47FE: // global
           I64[Sp] = block_c47FK_info;
           _s47z1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47z1::I64;
           if (R1 & 7 != 0) goto u47FY; else goto c47FO;
       u47FY: // global
           call _c47FK(R1) args: 0, res: 0, upd: 0;
       c47FO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47FK() //  [R1]
         { info_tbl: [(c47FK,
                       label: block_c47FK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47FK: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47FW; else goto c47FX;
       c47FW: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47FX: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.242757651 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$cmax_closure" {
     GHC.Ptr.$fOrdFunPtr_$cmax_closure:
         const GHC.Ptr.$fOrdFunPtr_$cmax_info;
 },
 GHC.Ptr.$fOrdFunPtr_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c47G7,
                       label: GHC.Ptr.$fOrdFunPtr_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47G7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c47Gb; else goto c47Gc;
       c47Gb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Gc: // global
           I64[Sp - 16] = block_c47G4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Gp; else goto c47G5;
       u47Gp: // global
           call _c47G4(R1) args: 0, res: 0, upd: 0;
       c47G5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47G4() //  [R1]
         { info_tbl: [(c47G4,
                       label: block_c47G4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47G4: // global
           I64[Sp - 8] = block_c47Ga_info;
           _s47z7::P64 = R1;
           _s47z8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47z8::I64;
           P64[Sp + 8] = _s47z7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47Go; else goto c47Ge;
       u47Go: // global
           call _c47Ga(R1) args: 0, res: 0, upd: 0;
       c47Ge: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Ga() //  [R1]
         { info_tbl: [(c47Ga,
                       label: block_c47Ga_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Ga: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47Gm; else goto c47Gn;
       c47Gm: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c47Gn: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.244388308 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c>=_closure" {
     GHC.Ptr.$fOrdFunPtr_$c>=_closure:
         const GHC.Ptr.$fOrdFunPtr_$c>=_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c47Gx,
                       label: GHC.Ptr.$fOrdFunPtr_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Gx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47GB; else goto c47GC;
       c47GB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47GC: // global
           I64[Sp - 16] = block_c47Gu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47GP; else goto c47Gv;
       u47GP: // global
           call _c47Gu(R1) args: 0, res: 0, upd: 0;
       c47Gv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Gu() //  [R1]
         { info_tbl: [(c47Gu,
                       label: block_c47Gu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Gu: // global
           I64[Sp] = block_c47GA_info;
           _s47zf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zf::I64;
           if (R1 & 7 != 0) goto u47GO; else goto c47GE;
       u47GO: // global
           call _c47GA(R1) args: 0, res: 0, upd: 0;
       c47GE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47GA() //  [R1]
         { info_tbl: [(c47GA,
                       label: block_c47GA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47GA: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47GM; else goto c47GN;
       c47GM: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47GN: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.245992153 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c>_closure" {
     GHC.Ptr.$fOrdFunPtr_$c>_closure:
         const GHC.Ptr.$fOrdFunPtr_$c>_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c>_entry() //  [R2, R3]
         { info_tbl: [(c47GX,
                       label: GHC.Ptr.$fOrdFunPtr_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47GX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47H1; else goto c47H2;
       c47H1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47H2: // global
           I64[Sp - 16] = block_c47GU_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Hb; else goto c47GV;
       u47Hb: // global
           call _c47GU(R1) args: 0, res: 0, upd: 0;
       c47GV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47GU() //  [R1]
         { info_tbl: [(c47GU,
                       label: block_c47GU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47GU: // global
           I64[Sp] = block_c47H0_info;
           _s47zm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zm::I64;
           if (R1 & 7 != 0) goto u47Ha; else goto c47H4;
       u47Ha: // global
           call _c47H0(R1) args: 0, res: 0, upd: 0;
       c47H4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47H0() //  [R1]
         { info_tbl: [(c47H0,
                       label: block_c47H0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47H0: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.247618702 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$cmin_closure" {
     GHC.Ptr.$fOrdFunPtr_$cmin_closure:
         const GHC.Ptr.$fOrdFunPtr_$cmin_info;
 },
 GHC.Ptr.$fOrdFunPtr_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c47Hj,
                       label: GHC.Ptr.$fOrdFunPtr_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Hj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c47Hn; else goto c47Ho;
       c47Hn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Ho: // global
           I64[Sp - 16] = block_c47Hg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47HB; else goto c47Hh;
       u47HB: // global
           call _c47Hg(R1) args: 0, res: 0, upd: 0;
       c47Hh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Hg() //  [R1]
         { info_tbl: [(c47Hg,
                       label: block_c47Hg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Hg: // global
           I64[Sp - 8] = block_c47Hm_info;
           _s47zs::P64 = R1;
           _s47zt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47zt::I64;
           P64[Sp + 8] = _s47zs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47HA; else goto c47Hq;
       u47HA: // global
           call _c47Hm(R1) args: 0, res: 0, upd: 0;
       c47Hq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Hm() //  [R1]
         { info_tbl: [(c47Hm,
                       label: block_c47Hm_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Hm: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47Hy; else goto c47Hz;
       c47Hy: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c47Hz: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.2488421 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_closure" {
     GHC.Ptr.$fOrdFunPtr_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Ptr.$fEqFunPtr_closure+1;
         const GHC.Ptr.$fOrdFunPtr_$ccompare_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c<_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c<=_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c>_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c>=_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$cmax_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.249791651 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c<_closure" {
     GHC.Ptr.$fOrdPtr_$c<_closure:
         const GHC.Ptr.$fOrdPtr_$c<_info;
 },
 GHC.Ptr.$fOrdPtr_$c<_entry() //  [R2, R3]
         { info_tbl: [(c47HJ,
                       label: GHC.Ptr.$fOrdPtr_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47HJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47HN; else goto c47HO;
       c47HN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47HO: // global
           I64[Sp - 16] = block_c47HG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47HX; else goto c47HH;
       u47HX: // global
           call _c47HG(R1) args: 0, res: 0, upd: 0;
       c47HH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47HG() //  [R1]
         { info_tbl: [(c47HG,
                       label: block_c47HG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47HG: // global
           I64[Sp] = block_c47HM_info;
           _s47zA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zA::I64;
           if (R1 & 7 != 0) goto u47HW; else goto c47HQ;
       u47HW: // global
           call _c47HM(R1) args: 0, res: 0, upd: 0;
       c47HQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47HM() //  [R1]
         { info_tbl: [(c47HM,
                       label: block_c47HM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47HM: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.251316996 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$ccompare_closure" {
     GHC.Ptr.$fOrdPtr_$ccompare_closure:
         const GHC.Ptr.$fOrdPtr_$ccompare_info;
 },
 GHC.Ptr.$fOrdPtr_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c47I5,
                       label: GHC.Ptr.$fOrdPtr_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47I5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47I9; else goto c47Ia;
       c47I9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Ia: // global
           I64[Sp - 16] = block_c47I2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47It; else goto c47I3;
       u47It: // global
           call _c47I2(R1) args: 0, res: 0, upd: 0;
       c47I3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47I2() //  [R1]
         { info_tbl: [(c47I2,
                       label: block_c47I2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47I2: // global
           I64[Sp] = block_c47I8_info;
           _s47zH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zH::I64;
           if (R1 & 7 != 0) goto u47Is; else goto c47Ic;
       u47Is: // global
           call _c47I8(R1) args: 0, res: 0, upd: 0;
       c47Ic: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47I8() //  [R1]
         { info_tbl: [(c47I8,
                       label: block_c47I8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47I8: // global
           _s47zH::I64 = I64[Sp + 8];
           _s47zJ::I64 = I64[R1 + 7];
           if (_s47zH::I64 >= _s47zJ::I64) goto c47Iq; else goto c47Ir;
       c47Iq: // global
           if (_s47zH::I64 == _s47zJ::I64) goto c47Io; else goto c47In;
       c47Io: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47In: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47Ir: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.252916212 UTC

[section ""data" . GHC.Ptr.$fEqPtr_$c==_closure" {
     GHC.Ptr.$fEqPtr_$c==_closure:
         const GHC.Ptr.$fEqPtr_$c==_info;
 },
 GHC.Ptr.$fEqPtr_$c==_entry() //  [R2, R3]
         { info_tbl: [(c47IB,
                       label: GHC.Ptr.$fEqPtr_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47IB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47IF; else goto c47IG;
       c47IF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqPtr_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47IG: // global
           I64[Sp - 16] = block_c47Iy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47IP; else goto c47Iz;
       u47IP: // global
           call _c47Iy(R1) args: 0, res: 0, upd: 0;
       c47Iz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Iy() //  [R1]
         { info_tbl: [(c47Iy,
                       label: block_c47Iy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Iy: // global
           I64[Sp] = block_c47IE_info;
           _s47zP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zP::I64;
           if (R1 & 7 != 0) goto u47IO; else goto c47II;
       u47IO: // global
           call _c47IE(R1) args: 0, res: 0, upd: 0;
       c47II: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47IE() //  [R1]
         { info_tbl: [(c47IE,
                       label: block_c47IE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47IE: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.254626053 UTC

[section ""data" . GHC.Ptr.$fEqPtr_$c/=_closure" {
     GHC.Ptr.$fEqPtr_$c/=_closure:
         const GHC.Ptr.$fEqPtr_$c/=_info;
 },
 GHC.Ptr.$fEqPtr_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c47IX,
                       label: GHC.Ptr.$fEqPtr_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47IX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47J1; else goto c47J2;
       c47J1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqPtr_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47J2: // global
           I64[Sp - 16] = block_c47IU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Jf; else goto c47IV;
       u47Jf: // global
           call _c47IU(R1) args: 0, res: 0, upd: 0;
       c47IV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47IU() //  [R1]
         { info_tbl: [(c47IU,
                       label: block_c47IU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47IU: // global
           I64[Sp] = block_c47J0_info;
           _s47zW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zW::I64;
           if (R1 & 7 != 0) goto u47Je; else goto c47J4;
       u47Je: // global
           call _c47J0(R1) args: 0, res: 0, upd: 0;
       c47J4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47J0() //  [R1]
         { info_tbl: [(c47J0,
                       label: block_c47J0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47J0: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c47Jd; else goto c47Jc;
       c47Jd: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47Jc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.255884121 UTC

[section ""data" . GHC.Ptr.$fEqPtr_closure" {
     GHC.Ptr.$fEqPtr_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Ptr.$fEqPtr_$c==_closure+2;
         const GHC.Ptr.$fEqPtr_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.256788441 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c<=_closure" {
     GHC.Ptr.$fOrdPtr_$c<=_closure:
         const GHC.Ptr.$fOrdPtr_$c<=_info;
 },
 GHC.Ptr.$fOrdPtr_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c47Jn,
                       label: GHC.Ptr.$fOrdPtr_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Jn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47Jr; else goto c47Js;
       c47Jr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Js: // global
           I64[Sp - 16] = block_c47Jk_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47JF; else goto c47Jl;
       u47JF: // global
           call _c47Jk(R1) args: 0, res: 0, upd: 0;
       c47Jl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Jk() //  [R1]
         { info_tbl: [(c47Jk,
                       label: block_c47Jk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Jk: // global
           I64[Sp] = block_c47Jq_info;
           _s47A3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47A3::I64;
           if (R1 & 7 != 0) goto u47JE; else goto c47Ju;
       u47JE: // global
           call _c47Jq(R1) args: 0, res: 0, upd: 0;
       c47Ju: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Jq() //  [R1]
         { info_tbl: [(c47Jq,
                       label: block_c47Jq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Jq: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47JC; else goto c47JD;
       c47JC: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47JD: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.258467053 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$cmax_closure" {
     GHC.Ptr.$fOrdPtr_$cmax_closure:
         const GHC.Ptr.$fOrdPtr_$cmax_info;
 },
 GHC.Ptr.$fOrdPtr_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c47JN,
                       label: GHC.Ptr.$fOrdPtr_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47JN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c47JR; else goto c47JS;
       c47JR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47JS: // global
           I64[Sp - 16] = block_c47JK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47K5; else goto c47JL;
       u47K5: // global
           call _c47JK(R1) args: 0, res: 0, upd: 0;
       c47JL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47JK() //  [R1]
         { info_tbl: [(c47JK,
                       label: block_c47JK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47JK: // global
           I64[Sp - 8] = block_c47JQ_info;
           _s47A9::P64 = R1;
           _s47Aa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47Aa::I64;
           P64[Sp + 8] = _s47A9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47K4; else goto c47JU;
       u47K4: // global
           call _c47JQ(R1) args: 0, res: 0, upd: 0;
       c47JU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47JQ() //  [R1]
         { info_tbl: [(c47JQ,
                       label: block_c47JQ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47JQ: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47K2; else goto c47K3;
       c47K2: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c47K3: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.26007668 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c>=_closure" {
     GHC.Ptr.$fOrdPtr_$c>=_closure:
         const GHC.Ptr.$fOrdPtr_$c>=_info;
 },
 GHC.Ptr.$fOrdPtr_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c47Kd,
                       label: GHC.Ptr.$fOrdPtr_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Kd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47Kh; else goto c47Ki;
       c47Kh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Ki: // global
           I64[Sp - 16] = block_c47Ka_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Kv; else goto c47Kb;
       u47Kv: // global
           call _c47Ka(R1) args: 0, res: 0, upd: 0;
       c47Kb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Ka() //  [R1]
         { info_tbl: [(c47Ka,
                       label: block_c47Ka_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Ka: // global
           I64[Sp] = block_c47Kg_info;
           _s47Ah::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47Ah::I64;
           if (R1 & 7 != 0) goto u47Ku; else goto c47Kk;
       u47Ku: // global
           call _c47Kg(R1) args: 0, res: 0, upd: 0;
       c47Kk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Kg() //  [R1]
         { info_tbl: [(c47Kg,
                       label: block_c47Kg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Kg: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47Ks; else goto c47Kt;
       c47Ks: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47Kt: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.261642815 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c>_closure" {
     GHC.Ptr.$fOrdPtr_$c>_closure:
         const GHC.Ptr.$fOrdPtr_$c>_info;
 },
 GHC.Ptr.$fOrdPtr_$c>_entry() //  [R2, R3]
         { info_tbl: [(c47KD,
                       label: GHC.Ptr.$fOrdPtr_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47KD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47KH; else goto c47KI;
       c47KH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47KI: // global
           I64[Sp - 16] = block_c47KA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47KR; else goto c47KB;
       u47KR: // global
           call _c47KA(R1) args: 0, res: 0, upd: 0;
       c47KB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47KA() //  [R1]
         { info_tbl: [(c47KA,
                       label: block_c47KA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47KA: // global
           I64[Sp] = block_c47KG_info;
           _s47Ao::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47Ao::I64;
           if (R1 & 7 != 0) goto u47KQ; else goto c47KK;
       u47KQ: // global
           call _c47KG(R1) args: 0, res: 0, upd: 0;
       c47KK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47KG() //  [R1]
         { info_tbl: [(c47KG,
                       label: block_c47KG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47KG: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.263178289 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$cmin_closure" {
     GHC.Ptr.$fOrdPtr_$cmin_closure:
         const GHC.Ptr.$fOrdPtr_$cmin_info;
 },
 GHC.Ptr.$fOrdPtr_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c47KZ,
                       label: GHC.Ptr.$fOrdPtr_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47KZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c47L3; else goto c47L4;
       c47L3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47L4: // global
           I64[Sp - 16] = block_c47KW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Lh; else goto c47KX;
       u47Lh: // global
           call _c47KW(R1) args: 0, res: 0, upd: 0;
       c47KX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47KW() //  [R1]
         { info_tbl: [(c47KW,
                       label: block_c47KW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47KW: // global
           I64[Sp - 8] = block_c47L2_info;
           _s47Au::P64 = R1;
           _s47Av::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47Av::I64;
           P64[Sp + 8] = _s47Au::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47Lg; else goto c47L6;
       u47Lg: // global
           call _c47L2(R1) args: 0, res: 0, upd: 0;
       c47L6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47L2() //  [R1]
         { info_tbl: [(c47L2,
                       label: block_c47L2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47L2: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47Le; else goto c47Lf;
       c47Le: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c47Lf: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.264435212 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_closure" {
     GHC.Ptr.$fOrdPtr_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Ptr.$fEqPtr_closure+1;
         const GHC.Ptr.$fOrdPtr_$ccompare_closure+2;
         const GHC.Ptr.$fOrdPtr_$c<_closure+2;
         const GHC.Ptr.$fOrdPtr_$c<=_closure+2;
         const GHC.Ptr.$fOrdPtr_$c>_closure+2;
         const GHC.Ptr.$fOrdPtr_$c>=_closure+2;
         const GHC.Ptr.$fOrdPtr_$cmax_closure+2;
         const GHC.Ptr.$fOrdPtr_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.26505847 UTC

[section ""data" . GHC.Ptr.nullPtr_closure" {
     GHC.Ptr.nullPtr_closure:
         const GHC.Ptr.Ptr_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.266135926 UTC

[section ""data" . GHC.Ptr.castPtr1_closure" {
     GHC.Ptr.castPtr1_closure:
         const GHC.Ptr.castPtr1_info;
 },
 GHC.Ptr.castPtr1_entry() //  [R2]
         { info_tbl: [(c47Lm,
                       label: GHC.Ptr.castPtr1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Lm: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.266945532 UTC

[section ""data" . GHC.Ptr.castPtr_closure" {
     GHC.Ptr.castPtr_closure:
         const GHC.Ptr.castPtr_info;
 },
 GHC.Ptr.castPtr_entry() //  [R2]
         { info_tbl: [(c47Lt,
                       label: GHC.Ptr.castPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Lt: // global
           R2 = R2;
           call GHC.Ptr.castPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.268026223 UTC

[section ""data" . GHC.Ptr.plusPtr_closure" {
     GHC.Ptr.plusPtr_closure:
         const GHC.Ptr.plusPtr_info;
 },
 GHC.Ptr.plusPtr_entry() //  [R2, R3]
         { info_tbl: [(c47LD,
                       label: GHC.Ptr.plusPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47LD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47LP; else goto c47LQ;
       c47LP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.plusPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47LQ: // global
           I64[Sp - 16] = block_c47LA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47LW; else goto c47LB;
       u47LW: // global
           call _c47LA(R1) args: 0, res: 0, upd: 0;
       c47LB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47LA() //  [R1]
         { info_tbl: [(c47LA,
                       label: block_c47LA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47LA: // global
           I64[Sp] = block_c47LG_info;
           _s47AD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47AD::I64;
           if (R1 & 7 != 0) goto u47LV; else goto c47LH;
       u47LV: // global
           call _c47LG(R1) args: 0, res: 0, upd: 0;
       c47LH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47LG() //  [R1]
         { info_tbl: [(c47LG,
                       label: block_c47LG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47LG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c47LU; else goto c47LT;
       c47LU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c47LT: // global
           _s47AG::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s47AG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.269946994 UTC

[section ""data" . GHC.Ptr.alignPtr_closure" {
     GHC.Ptr.alignPtr_closure:
         const GHC.Ptr.alignPtr_info;
 },
 GHC.Ptr.alignPtr_entry() //  [R2, R3]
         { info_tbl: [(c47M4,
                       label: GHC.Ptr.alignPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47M4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c47M8; else goto c47M9;
       c47M8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.alignPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47M9: // global
           I64[Sp - 16] = block_c47M1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47MH; else goto c47M2;
       u47MH: // global
           call _c47M1(R1) args: 0, res: 0, upd: 0;
       c47M2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47M1() //  [R1]
         { info_tbl: [(c47M1,
                       label: block_c47M1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47M1: // global
           I64[Sp - 8] = block_c47M7_info;
           _s47AJ::P64 = R1;
           _s47AK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47AK::I64;
           P64[Sp + 8] = _s47AJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47MG; else goto c47Mb;
       u47MG: // global
           call _c47M7(R1) args: 0, res: 0, upd: 0;
       c47Mb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47M7() //  [R1]
         { info_tbl: [(c47M7,
                       label: block_c47M7_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47M7: // global
           _s47AM::I64 = I64[R1 + 7];
           _s47AN::I64 = I64[Sp + 8] % _s47AM::I64;
           if (_s47AN::I64 != 0) goto u47ME; else goto c47MA;
       u47ME: // global
           I64[Sp] = _s47AN::I64;
           I64[Sp + 16] = _s47AM::I64;
           call _c47Mk() args: 0, res: 0, upd: 0;
       c47MA: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c47Mk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Mk: // global
           Hp = Hp + 16;
           _s47AN::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c47Mx; else goto c47Mw;
       c47Mx: // global
           HpAlloc = 16;
           I64[Sp] = block_c47Mj_info;
           R1 = _s47AN::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c47Mw: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + (I64[Sp + 16] - _s47AN::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c47Mj() //  [R1]
         { info_tbl: [(c47Mj,
                       label: block_c47Mj_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Mj: // global
           I64[Sp] = R1;
           call _c47Mk() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.271929322 UTC

[section ""data" . GHC.Ptr.minusPtr_closure" {
     GHC.Ptr.minusPtr_closure:
         const GHC.Ptr.minusPtr_info;
 },
 GHC.Ptr.minusPtr_entry() //  [R2, R3]
         { info_tbl: [(c47MR,
                       label: GHC.Ptr.minusPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47MR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47N3; else goto c47N4;
       c47N3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.minusPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47N4: // global
           I64[Sp - 16] = block_c47MO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Na; else goto c47MP;
       u47Na: // global
           call _c47MO(R1) args: 0, res: 0, upd: 0;
       c47MP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47MO() //  [R1]
         { info_tbl: [(c47MO,
                       label: block_c47MO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47MO: // global
           I64[Sp] = block_c47MU_info;
           _s47AT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47AT::I64;
           if (R1 & 7 != 0) goto u47N9; else goto c47MV;
       u47N9: // global
           call _c47MU(R1) args: 0, res: 0, upd: 0;
       c47MV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47MU() //  [R1]
         { info_tbl: [(c47MU,
                       label: block_c47MU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47MU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c47N8; else goto c47N7;
       c47N8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c47N7: // global
           _s47AW::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s47AW::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.273207489 UTC

[section ""data" . GHC.Ptr.nullFunPtr_closure" {
     GHC.Ptr.nullFunPtr_closure:
         const GHC.Ptr.FunPtr_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.273947504 UTC

[section ""data" . GHC.Ptr.castFunPtr1_closure" {
     GHC.Ptr.castFunPtr1_closure:
         const GHC.Ptr.castFunPtr1_info;
 },
 GHC.Ptr.castFunPtr1_entry() //  [R2]
         { info_tbl: [(c47Nf,
                       label: GHC.Ptr.castFunPtr1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Nf: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.274717365 UTC

[section ""data" . GHC.Ptr.castFunPtr_closure" {
     GHC.Ptr.castFunPtr_closure:
         const GHC.Ptr.castFunPtr_info;
 },
 GHC.Ptr.castFunPtr_entry() //  [R2]
         { info_tbl: [(c47Nm,
                       label: GHC.Ptr.castFunPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Nm: // global
           R2 = R2;
           call GHC.Ptr.castFunPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.275683489 UTC

[section ""data" . GHC.Ptr.castFunPtrToPtr_closure" {
     GHC.Ptr.castFunPtrToPtr_closure:
         const GHC.Ptr.castFunPtrToPtr_info;
 },
 GHC.Ptr.castFunPtrToPtr_entry() //  [R2]
         { info_tbl: [(c47Nw,
                       label: GHC.Ptr.castFunPtrToPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Nw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c47NA; else goto c47NB;
       c47NA: // global
           R2 = R2;
           R1 = GHC.Ptr.castFunPtrToPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c47NB: // global
           I64[Sp - 8] = block_c47Nt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47NF; else goto c47Nu;
       u47NF: // global
           call _c47Nt(R1) args: 0, res: 0, upd: 0;
       c47Nu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Nt() //  [R1]
         { info_tbl: [(c47Nt,
                       label: block_c47Nt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Nt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c47NE; else goto c47ND;
       c47NE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c47ND: // global
           _s47B0::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s47B0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.27714972 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowsPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(c47NN,
                       label: GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47NN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47NT; else goto c47NU;
       c47NT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c47NU: // global
           I64[Sp - 16] = block_c47NK_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47NZ; else goto c47NL;
       u47NZ: // global
           call _c47NK(R1) args: 0, res: 0, upd: 0;
       c47NL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47NK() //  [R1]
         { info_tbl: [(c47NK,
                       label: block_c47NK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47NK: // global
           _s47B3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c47NQ_info;
           R3 = _s47B3::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c47NQ() //  [R1, R2]
         { info_tbl: [(c47NQ,
                       label: block_c47NQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47NQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c47NY; else goto c47NX;
       c47NY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c47NX: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.278846433 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshow_closure" {
     GHC.Ptr.$fShowFunPtr_$cshow_closure:
         const GHC.Ptr.$fShowFunPtr_$cshow_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshow_entry() //  [R2]
         { info_tbl: [(c47O7,
                       label: GHC.Ptr.$fShowFunPtr_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47O7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c47Od; else goto c47Oe;
       c47Od: // global
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c47Oe: // global
           I64[Sp - 8] = block_c47O4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47Oj; else goto c47O5;
       u47Oj: // global
           call _c47O4(R1) args: 0, res: 0, upd: 0;
       c47O5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47O4() //  [R1]
         { info_tbl: [(c47O4,
                       label: block_c47O4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47O4: // global
           I64[Sp] = block_c47Oa_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c47Oa() //  [R1, R2]
         { info_tbl: [(c47Oa,
                       label: block_c47Oa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Oa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c47Oi; else goto c47Oh;
       c47Oi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c47Oh: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.280391812 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr1_closure" {
     GHC.Ptr.$fShowFunPtr1_closure:
         const GHC.Ptr.$fShowFunPtr1_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr1_entry() //  [R2, R3]
         { info_tbl: [(c47Or,
                       label: GHC.Ptr.$fShowFunPtr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Or: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47Ox; else goto c47Oy;
       c47Ox: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Oy: // global
           I64[Sp - 16] = block_c47Oo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47OD; else goto c47Op;
       u47OD: // global
           call _c47Oo(R1) args: 0, res: 0, upd: 0;
       c47Op: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Oo() //  [R1]
         { info_tbl: [(c47Oo,
                       label: block_c47Oo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Oo: // global
           _s47Bg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c47Ou_info;
           R3 = _s47Bg::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c47Ou() //  [R1, R2]
         { info_tbl: [(c47Ou,
                       label: block_c47Ou_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Ou: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c47OC; else goto c47OB;
       c47OC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c47OB: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.282051181 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowList_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowList_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowList_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c47OI,
                       label: GHC.Ptr.$fShowFunPtr_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47OI: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Ptr.$fShowFunPtr1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.282801355 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_closure" {
     GHC.Ptr.$fShowFunPtr_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure+3;
         const GHC.Ptr.$fShowFunPtr_$cshow_closure+1;
         const GHC.Ptr.$fShowFunPtr_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.283680017 UTC

[section ""data" . GHC.Ptr.castPtrToFunPtr_closure" {
     GHC.Ptr.castPtrToFunPtr_closure:
         const GHC.Ptr.castPtrToFunPtr_info;
 },
 GHC.Ptr.castPtrToFunPtr_entry() //  [R2]
         { info_tbl: [(c47OS,
                       label: GHC.Ptr.castPtrToFunPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47OS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c47OW; else goto c47OX;
       c47OW: // global
           R2 = R2;
           R1 = GHC.Ptr.castPtrToFunPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c47OX: // global
           I64[Sp - 8] = block_c47OP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47P1; else goto c47OQ;
       u47P1: // global
           call _c47OP(R1) args: 0, res: 0, upd: 0;
       c47OQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47OP() //  [R1]
         { info_tbl: [(c47OP,
                       label: block_c47OP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47OP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c47P0; else goto c47OZ;
       c47P0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c47OZ: // global
           _s47Bq::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s47Bq::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.286501457 UTC

[section ""cstring" . GHC.Ptr.$trModule4_bytes" {
     GHC.Ptr.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.28703338 UTC

[section ""data" . GHC.Ptr.$trModule3_closure" {
     GHC.Ptr.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.287544933 UTC

[section ""cstring" . GHC.Ptr.$trModule2_bytes" {
     GHC.Ptr.$trModule2_bytes:
         I8[] [71,72,67,46,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.288088804 UTC

[section ""data" . GHC.Ptr.$trModule1_closure" {
     GHC.Ptr.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.288607887 UTC

[section ""data" . GHC.Ptr.$trModule_closure" {
     GHC.Ptr.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Ptr.$trModule3_closure+1;
         const GHC.Ptr.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.289151302 UTC

[section ""data" . $krep_r47xK_closure" {
     $krep_r47xK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.289785645 UTC

[section ""data" . $krep1_r47xL_closure" {
     $krep1_r47xL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcAddr#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.290317239 UTC

[section ""cstring" . GHC.Ptr.$tcPtr2_bytes" {
     GHC.Ptr.$tcPtr2_bytes:
         I8[] [80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.290841263 UTC

[section ""data" . GHC.Ptr.$tcPtr1_closure" {
     GHC.Ptr.$tcPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tcPtr2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.291382928 UTC

[section ""data" . GHC.Ptr.$tcPtr_closure" {
     GHC.Ptr.$tcPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tcPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13939499724423561315;
         const 16316673677148652216;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.291980209 UTC

[section ""data" . $krep2_r47xM_closure" {
     $krep2_r47xM_closure:
         const :_con_info;
         const $krep_r47xK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.292548999 UTC

[section ""data" . $krep3_r47xN_closure" {
     $krep3_r47xN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcPtr_closure+1;
         const $krep2_r47xM_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.293076992 UTC

[section ""data" . GHC.Ptr.$tc'Ptr1_closure" {
     GHC.Ptr.$tc'Ptr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r47xL_closure+1;
         const $krep3_r47xN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.293662529 UTC

[section ""cstring" . GHC.Ptr.$tc'Ptr3_bytes" {
     GHC.Ptr.$tc'Ptr3_bytes:
         I8[] [39,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.294182121 UTC

[section ""data" . GHC.Ptr.$tc'Ptr2_closure" {
     GHC.Ptr.$tc'Ptr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tc'Ptr3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.294694928 UTC

[section ""data" . GHC.Ptr.$tc'Ptr_closure" {
     GHC.Ptr.$tc'Ptr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tc'Ptr2_closure+1;
         const GHC.Ptr.$tc'Ptr1_closure+4;
         const 2332306090346040376;
         const 13491728187967991297;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.295241509 UTC

[section ""cstring" . GHC.Ptr.$tcFunPtr2_bytes" {
     GHC.Ptr.$tcFunPtr2_bytes:
         I8[] [70,117,110,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.29582449 UTC

[section ""data" . GHC.Ptr.$tcFunPtr1_closure" {
     GHC.Ptr.$tcFunPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tcFunPtr2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.296393605 UTC

[section ""data" . GHC.Ptr.$tcFunPtr_closure" {
     GHC.Ptr.$tcFunPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tcFunPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 38956960673620606;
         const 4307950889093819770;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.297005633 UTC

[section ""data" . $krep4_r47xO_closure" {
     $krep4_r47xO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcFunPtr_closure+1;
         const $krep2_r47xM_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.297858992 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr1_closure" {
     GHC.Ptr.$tc'FunPtr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r47xL_closure+1;
         const $krep4_r47xO_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.298370461 UTC

[section ""cstring" . GHC.Ptr.$tc'FunPtr3_bytes" {
     GHC.Ptr.$tc'FunPtr3_bytes:
         I8[] [39,70,117,110,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.298889315 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr2_closure" {
     GHC.Ptr.$tc'FunPtr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tc'FunPtr3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.299407376 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr_closure" {
     GHC.Ptr.$tc'FunPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tc'FunPtr2_closure+1;
         const GHC.Ptr.$tc'FunPtr1_closure+4;
         const 15722333564603238588;
         const 12100865307857439187;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.30026558 UTC

[section ""data" . GHC.Ptr.Ptr_closure" {
     GHC.Ptr.Ptr_closure:
         const GHC.Ptr.Ptr_info;
 },
 GHC.Ptr.Ptr_entry() //  [R2]
         { info_tbl: [(c47P7,
                       label: GHC.Ptr.Ptr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47P7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c47Pb; else goto c47Pa;
       c47Pb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Ptr.Ptr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c47Pa: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.301300709 UTC

[section ""data" . GHC.Ptr.FunPtr_closure" {
     GHC.Ptr.FunPtr_closure:
         const GHC.Ptr.FunPtr_info;
 },
 GHC.Ptr.FunPtr_entry() //  [R2]
         { info_tbl: [(c47Ph,
                       label: GHC.Ptr.FunPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Ph: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c47Pl; else goto c47Pk;
       c47Pl: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Ptr.FunPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c47Pk: // global
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.302166215 UTC

[GHC.Ptr.Ptr_con_entry() //  [R1]
         { info_tbl: [(c47Pm,
                       label: GHC.Ptr.Ptr_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,80,116,114,46,80,116,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Pm: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.302861247 UTC

[GHC.Ptr.FunPtr_con_entry() //  [R1]
         { info_tbl: [(c47Pn,
                       label: GHC.Ptr.FunPtr_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,80,116,114,46,70,117,110,80,116,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Pn: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.303514142 UTC

[section ""relreadonly" . S47CQ_srt" {
     S47CQ_srt:
         const GHC.Show.intToDigit_closure;
         const GHC.Show.$fShowInteger_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Numeric.showIntAtBase_closure;
         const Numeric.showHex1_closure;
         const GHC.Ptr.$w$cshowsPrec_closure;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure;
         const GHC.Ptr.$fShowPtr_$cshow_closure;
         const GHC.Ptr.$fShowPtr1_closure;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure;
         const GHC.Ptr.$fShowFunPtr_$cshow_closure;
         const GHC.Ptr.$fShowFunPtr1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.304130667 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:00.304666488 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr4_closure" {
     GHC.Ptr.$fShowFunPtr4_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.305222337 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr3_closure" {
     GHC.Ptr.$fShowFunPtr3_closure:
         const GHC.Types.C#_con_info;
         const 120;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.307334803 UTC

[section ""data" . GHC.Ptr.$w$cshowsPrec_closure" {
     GHC.Ptr.$w$cshowsPrec_closure:
         const GHC.Ptr.$w$cshowsPrec_info;
         const 0;
 },
 sat_s47xV_entry() //  [R1]
         { info_tbl: [(c47PC,
                       label: sat_s47xV_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47PC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47PD; else goto c47PE;
       c47PD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c47PE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ls_s47xS_entry() //  [R1]
         { info_tbl: [(c47PH,
                       label: ls_s47xS_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47PH: // global
           _s47xS::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c47PI; else goto c47PJ;
       c47PJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c47PL; else goto c47PK;
       c47PL: // global
           HpAlloc = 24;
           goto c47PI;
       c47PI: // global
           R1 = _s47xS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c47PK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s47xS::P64;
           _s47xQ::I64 = I64[_s47xS::P64 + 16];
           I64[Hp - 16] = sat_s47xV_info;
           I64[Hp] = _s47xQ::I64;
           R6 = Hp - 16;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Numeric.showHex1_closure;
           R3 = GHC.Show.$fShowInteger_closure;
           R2 = GHC.Real.$fIntegralInteger_closure;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 32, res: 0, upd: 24;
     }
 },
 n_s47xZ_entry() //  [R1]
         { info_tbl: [(c47Q5,
                       label: n_s47xZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Q5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47Q6; else goto c47Q7;
       c47Q6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c47Q7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s47y5_entry() //  [R1]
         { info_tbl: [(c47Qm,
                       label: sat_s47y5_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Qm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47Qn; else goto c47Qo;
       c47Qn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c47Qo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_s47y1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_s47y1_entry() //  [R1, R2]
         { info_tbl: [(c47Qs,
                       label: $wxs_s47y1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Qs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c47Qw; else goto c47Qv;
       c47Qw: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c47Qv: // global
           if (R2 == 1) goto c47Qr; else goto c47Qq;
       c47Qr: // global
           _s47y0::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _s47y0::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47Qq: // global
           I64[Hp - 48] = sat_s47y5_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Ptr.$fShowFunPtr4_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s47y6_entry() //  [R1]
         { info_tbl: [(c47Qy,
                       label: sat_s47y6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Qy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c47Qz; else goto c47QA;
       c47Qz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c47QA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c47PQ_info;
           R3 = 0;
           _s47xS::P64 = P64[R1 + 24];
           R2 = _s47xS::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s47xS::P64;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c47PQ() //  [R1]
         { info_tbl: [(c47PQ,
                       label: block_c47PQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47PQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c47QD; else goto c47QC;
       c47QD: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c47QC: // global
           _s47xR::P64 = P64[Sp + 8];
           _s47xS::P64 = P64[Sp + 16];
           _s47xX::I64 = 16 - R1;
           if (%MO_S_Ge_W64(0, _s47xX::I64)) goto c47QF; else goto c47QG;
       c47QF: // global
           Hp = Hp - 72;
           R3 = _s47xR::P64;
           R2 = _s47xS::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c47QG: // global
           I64[Hp - 64] = n_s47xZ_info;
           P64[Hp - 48] = _s47xR::P64;
           P64[Hp - 40] = _s47xS::P64;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Ptr.$fShowFunPtr4_closure+1;
           P64[Hp - 16] = Hp - 64;
           I64[Hp - 8] = $wxs_s47y1_info;
           P64[Hp] = Hp - 30;
           R2 = _s47xX::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call $wxs_s47y1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Ptr.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c47QI,
                       label: GHC.Ptr.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47QI: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c47QM; else goto c47QL;
       c47QM: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47QL: // global
           I64[Hp - 72] = ls_s47xS_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s47y6_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Ptr.$fShowFunPtr3_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = GHC.Ptr.$fShowFunPtr4_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.311224626 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c47QU,
                       label: GHC.Ptr.$fShowFunPtr_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47QU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47R0; else goto c47R1;
       c47R0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c47R1: // global
           I64[Sp - 16] = block_c47QR_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47R6; else goto c47QS;
       u47R6: // global
           call _c47QR(R1) args: 0, res: 0, upd: 0;
       c47QS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47QR() //  [R1]
         { info_tbl: [(c47QR,
                       label: block_c47QR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47QR: // global
           _s47ya::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c47QX_info;
           R3 = _s47ya::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c47QX() //  [R1, R2]
         { info_tbl: [(c47QX,
                       label: block_c47QX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47QX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c47R5; else goto c47R4;
       c47R5: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c47R4: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.312531984 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr2_closure" {
     GHC.Ptr.$fShowFunPtr2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.31344051 UTC

[section ""data" . GHC.Ptr.$fShowPtr_$cshow_closure" {
     GHC.Ptr.$fShowPtr_$cshow_closure:
         const GHC.Ptr.$fShowPtr_$cshow_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr_$cshow_entry() //  [R2]
         { info_tbl: [(c47Re,
                       label: GHC.Ptr.$fShowPtr_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Re: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c47Rk; else goto c47Rl;
       c47Rk: // global
           R2 = R2;
           R1 = GHC.Ptr.$fShowPtr_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c47Rl: // global
           I64[Sp - 8] = block_c47Rb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47Rq; else goto c47Rc;
       u47Rq: // global
           call _c47Rb(R1) args: 0, res: 0, upd: 0;
       c47Rc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Rb() //  [R1]
         { info_tbl: [(c47Rb,
                       label: block_c47Rb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Rb: // global
           I64[Sp] = block_c47Rh_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c47Rh() //  [R1, R2]
         { info_tbl: [(c47Rh,
                       label: block_c47Rh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Rh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c47Rp; else goto c47Ro;
       c47Rp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c47Ro: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.315036412 UTC

[section ""data" . GHC.Ptr.$fShowPtr1_closure" {
     GHC.Ptr.$fShowPtr1_closure:
         const GHC.Ptr.$fShowPtr1_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr1_entry() //  [R2, R3]
         { info_tbl: [(c47Ry,
                       label: GHC.Ptr.$fShowPtr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Ry: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47RE; else goto c47RF;
       c47RE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47RF: // global
           I64[Sp - 16] = block_c47Rv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47RK; else goto c47Rw;
       u47RK: // global
           call _c47Rv(R1) args: 0, res: 0, upd: 0;
       c47Rw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Rv() //  [R1]
         { info_tbl: [(c47Rv,
                       label: block_c47Rv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Rv: // global
           _s47yn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c47RB_info;
           R3 = _s47yn::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c47RB() //  [R1, R2]
         { info_tbl: [(c47RB,
                       label: block_c47RB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47RB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c47RJ; else goto c47RI;
       c47RJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c47RI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.316427228 UTC

[section ""data" . GHC.Ptr.$fShowPtr_$cshowList_closure" {
     GHC.Ptr.$fShowPtr_$cshowList_closure:
         const GHC.Ptr.$fShowPtr_$cshowList_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c47RP,
                       label: GHC.Ptr.$fShowPtr_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47RP: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Ptr.$fShowPtr1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.317199096 UTC

[section ""data" . GHC.Ptr.$fShowPtr_closure" {
     GHC.Ptr.$fShowPtr_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure+3;
         const GHC.Ptr.$fShowPtr_$cshow_closure+1;
         const GHC.Ptr.$fShowPtr_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.318137401 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c<_closure" {
     GHC.Ptr.$fOrdFunPtr_$c<_closure:
         const GHC.Ptr.$fOrdFunPtr_$c<_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c<_entry() //  [R2, R3]
         { info_tbl: [(c47RZ,
                       label: GHC.Ptr.$fOrdFunPtr_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47RZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47S3; else goto c47S4;
       c47S3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47S4: // global
           I64[Sp - 16] = block_c47RW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Sd; else goto c47RX;
       u47Sd: // global
           call _c47RW(R1) args: 0, res: 0, upd: 0;
       c47RX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47RW() //  [R1]
         { info_tbl: [(c47RW,
                       label: block_c47RW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47RW: // global
           I64[Sp] = block_c47S2_info;
           _s47yy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yy::I64;
           if (R1 & 7 != 0) goto u47Sc; else goto c47S6;
       u47Sc: // global
           call _c47S2(R1) args: 0, res: 0, upd: 0;
       c47S6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47S2() //  [R1]
         { info_tbl: [(c47S2,
                       label: block_c47S2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47S2: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.319740217 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$ccompare_closure" {
     GHC.Ptr.$fOrdFunPtr_$ccompare_closure:
         const GHC.Ptr.$fOrdFunPtr_$ccompare_info;
 },
 GHC.Ptr.$fOrdFunPtr_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c47Sl,
                       label: GHC.Ptr.$fOrdFunPtr_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Sl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47Sp; else goto c47Sq;
       c47Sp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Sq: // global
           I64[Sp - 16] = block_c47Si_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47SJ; else goto c47Sj;
       u47SJ: // global
           call _c47Si(R1) args: 0, res: 0, upd: 0;
       c47Sj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Si() //  [R1]
         { info_tbl: [(c47Si,
                       label: block_c47Si_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Si: // global
           I64[Sp] = block_c47So_info;
           _s47yF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yF::I64;
           if (R1 & 7 != 0) goto u47SI; else goto c47Ss;
       u47SI: // global
           call _c47So(R1) args: 0, res: 0, upd: 0;
       c47Ss: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47So() //  [R1]
         { info_tbl: [(c47So,
                       label: block_c47So_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47So: // global
           _s47yF::I64 = I64[Sp + 8];
           _s47yH::I64 = I64[R1 + 7];
           if (_s47yF::I64 >= _s47yH::I64) goto c47SG; else goto c47SH;
       c47SG: // global
           if (_s47yF::I64 == _s47yH::I64) goto c47SE; else goto c47SD;
       c47SE: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47SD: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47SH: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.322301698 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_$c==_closure" {
     GHC.Ptr.$fEqFunPtr_$c==_closure:
         const GHC.Ptr.$fEqFunPtr_$c==_info;
 },
 GHC.Ptr.$fEqFunPtr_$c==_entry() //  [R2, R3]
         { info_tbl: [(c47SR,
                       label: GHC.Ptr.$fEqFunPtr_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47SR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47SV; else goto c47SW;
       c47SV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqFunPtr_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47SW: // global
           I64[Sp - 16] = block_c47SO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47T5; else goto c47SP;
       u47T5: // global
           call _c47SO(R1) args: 0, res: 0, upd: 0;
       c47SP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47SO() //  [R1]
         { info_tbl: [(c47SO,
                       label: block_c47SO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47SO: // global
           I64[Sp] = block_c47SU_info;
           _s47yN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yN::I64;
           if (R1 & 7 != 0) goto u47T4; else goto c47SY;
       u47T4: // global
           call _c47SU(R1) args: 0, res: 0, upd: 0;
       c47SY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47SU() //  [R1]
         { info_tbl: [(c47SU,
                       label: block_c47SU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47SU: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.325140283 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_$c/=_closure" {
     GHC.Ptr.$fEqFunPtr_$c/=_closure:
         const GHC.Ptr.$fEqFunPtr_$c/=_info;
 },
 GHC.Ptr.$fEqFunPtr_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c47Td,
                       label: GHC.Ptr.$fEqFunPtr_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Td: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47Th; else goto c47Ti;
       c47Th: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqFunPtr_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Ti: // global
           I64[Sp - 16] = block_c47Ta_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Tv; else goto c47Tb;
       u47Tv: // global
           call _c47Ta(R1) args: 0, res: 0, upd: 0;
       c47Tb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Ta() //  [R1]
         { info_tbl: [(c47Ta,
                       label: block_c47Ta_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Ta: // global
           I64[Sp] = block_c47Tg_info;
           _s47yU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yU::I64;
           if (R1 & 7 != 0) goto u47Tu; else goto c47Tk;
       u47Tu: // global
           call _c47Tg(R1) args: 0, res: 0, upd: 0;
       c47Tk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Tg() //  [R1]
         { info_tbl: [(c47Tg,
                       label: block_c47Tg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Tg: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c47Tt; else goto c47Ts;
       c47Tt: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47Ts: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.326505396 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_closure" {
     GHC.Ptr.$fEqFunPtr_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Ptr.$fEqFunPtr_$c==_closure+2;
         const GHC.Ptr.$fEqFunPtr_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.327452964 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c<=_closure" {
     GHC.Ptr.$fOrdFunPtr_$c<=_closure:
         const GHC.Ptr.$fOrdFunPtr_$c<=_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c47TD,
                       label: GHC.Ptr.$fOrdFunPtr_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47TD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47TH; else goto c47TI;
       c47TH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47TI: // global
           I64[Sp - 16] = block_c47TA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47TV; else goto c47TB;
       u47TV: // global
           call _c47TA(R1) args: 0, res: 0, upd: 0;
       c47TB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47TA() //  [R1]
         { info_tbl: [(c47TA,
                       label: block_c47TA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47TA: // global
           I64[Sp] = block_c47TG_info;
           _s47z1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47z1::I64;
           if (R1 & 7 != 0) goto u47TU; else goto c47TK;
       u47TU: // global
           call _c47TG(R1) args: 0, res: 0, upd: 0;
       c47TK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47TG() //  [R1]
         { info_tbl: [(c47TG,
                       label: block_c47TG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47TG: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47TS; else goto c47TT;
       c47TS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47TT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.329031858 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$cmax_closure" {
     GHC.Ptr.$fOrdFunPtr_$cmax_closure:
         const GHC.Ptr.$fOrdFunPtr_$cmax_info;
 },
 GHC.Ptr.$fOrdFunPtr_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c47U3,
                       label: GHC.Ptr.$fOrdFunPtr_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47U3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c47U7; else goto c47U8;
       c47U7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47U8: // global
           I64[Sp - 16] = block_c47U0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Ul; else goto c47U1;
       u47Ul: // global
           call _c47U0(R1) args: 0, res: 0, upd: 0;
       c47U1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47U0() //  [R1]
         { info_tbl: [(c47U0,
                       label: block_c47U0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47U0: // global
           I64[Sp - 8] = block_c47U6_info;
           _s47z7::P64 = R1;
           _s47z8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47z8::I64;
           P64[Sp + 8] = _s47z7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47Uk; else goto c47Ua;
       u47Uk: // global
           call _c47U6(R1) args: 0, res: 0, upd: 0;
       c47Ua: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47U6() //  [R1]
         { info_tbl: [(c47U6,
                       label: block_c47U6_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47U6: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47Ui; else goto c47Uj;
       c47Ui: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c47Uj: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.330709734 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c>=_closure" {
     GHC.Ptr.$fOrdFunPtr_$c>=_closure:
         const GHC.Ptr.$fOrdFunPtr_$c>=_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c47Ut,
                       label: GHC.Ptr.$fOrdFunPtr_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Ut: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47Ux; else goto c47Uy;
       c47Ux: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Uy: // global
           I64[Sp - 16] = block_c47Uq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47UL; else goto c47Ur;
       u47UL: // global
           call _c47Uq(R1) args: 0, res: 0, upd: 0;
       c47Ur: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Uq() //  [R1]
         { info_tbl: [(c47Uq,
                       label: block_c47Uq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Uq: // global
           I64[Sp] = block_c47Uw_info;
           _s47zf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zf::I64;
           if (R1 & 7 != 0) goto u47UK; else goto c47UA;
       u47UK: // global
           call _c47Uw(R1) args: 0, res: 0, upd: 0;
       c47UA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Uw() //  [R1]
         { info_tbl: [(c47Uw,
                       label: block_c47Uw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Uw: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47UI; else goto c47UJ;
       c47UI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47UJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.33221283 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c>_closure" {
     GHC.Ptr.$fOrdFunPtr_$c>_closure:
         const GHC.Ptr.$fOrdFunPtr_$c>_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c>_entry() //  [R2, R3]
         { info_tbl: [(c47UT,
                       label: GHC.Ptr.$fOrdFunPtr_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47UT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47UX; else goto c47UY;
       c47UX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47UY: // global
           I64[Sp - 16] = block_c47UQ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47V7; else goto c47UR;
       u47V7: // global
           call _c47UQ(R1) args: 0, res: 0, upd: 0;
       c47UR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47UQ() //  [R1]
         { info_tbl: [(c47UQ,
                       label: block_c47UQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47UQ: // global
           I64[Sp] = block_c47UW_info;
           _s47zm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zm::I64;
           if (R1 & 7 != 0) goto u47V6; else goto c47V0;
       u47V6: // global
           call _c47UW(R1) args: 0, res: 0, upd: 0;
       c47V0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47UW() //  [R1]
         { info_tbl: [(c47UW,
                       label: block_c47UW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47UW: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.333759453 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$cmin_closure" {
     GHC.Ptr.$fOrdFunPtr_$cmin_closure:
         const GHC.Ptr.$fOrdFunPtr_$cmin_info;
 },
 GHC.Ptr.$fOrdFunPtr_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c47Vf,
                       label: GHC.Ptr.$fOrdFunPtr_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Vf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c47Vj; else goto c47Vk;
       c47Vj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Vk: // global
           I64[Sp - 16] = block_c47Vc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Vx; else goto c47Vd;
       u47Vx: // global
           call _c47Vc(R1) args: 0, res: 0, upd: 0;
       c47Vd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Vc() //  [R1]
         { info_tbl: [(c47Vc,
                       label: block_c47Vc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Vc: // global
           I64[Sp - 8] = block_c47Vi_info;
           _s47zs::P64 = R1;
           _s47zt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47zt::I64;
           P64[Sp + 8] = _s47zs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47Vw; else goto c47Vm;
       u47Vw: // global
           call _c47Vi(R1) args: 0, res: 0, upd: 0;
       c47Vm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Vi() //  [R1]
         { info_tbl: [(c47Vi,
                       label: block_c47Vi_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Vi: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47Vu; else goto c47Vv;
       c47Vu: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c47Vv: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.335014963 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_closure" {
     GHC.Ptr.$fOrdFunPtr_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Ptr.$fEqFunPtr_closure+1;
         const GHC.Ptr.$fOrdFunPtr_$ccompare_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c<_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c<=_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c>_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c>=_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$cmax_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.335936437 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c<_closure" {
     GHC.Ptr.$fOrdPtr_$c<_closure:
         const GHC.Ptr.$fOrdPtr_$c<_info;
 },
 GHC.Ptr.$fOrdPtr_$c<_entry() //  [R2, R3]
         { info_tbl: [(c47VF,
                       label: GHC.Ptr.$fOrdPtr_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47VF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47VJ; else goto c47VK;
       c47VJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47VK: // global
           I64[Sp - 16] = block_c47VC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47VT; else goto c47VD;
       u47VT: // global
           call _c47VC(R1) args: 0, res: 0, upd: 0;
       c47VD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47VC() //  [R1]
         { info_tbl: [(c47VC,
                       label: block_c47VC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47VC: // global
           I64[Sp] = block_c47VI_info;
           _s47zA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zA::I64;
           if (R1 & 7 != 0) goto u47VS; else goto c47VM;
       u47VS: // global
           call _c47VI(R1) args: 0, res: 0, upd: 0;
       c47VM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47VI() //  [R1]
         { info_tbl: [(c47VI,
                       label: block_c47VI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47VI: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.337556849 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$ccompare_closure" {
     GHC.Ptr.$fOrdPtr_$ccompare_closure:
         const GHC.Ptr.$fOrdPtr_$ccompare_info;
 },
 GHC.Ptr.$fOrdPtr_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c47W1,
                       label: GHC.Ptr.$fOrdPtr_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47W1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47W5; else goto c47W6;
       c47W5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47W6: // global
           I64[Sp - 16] = block_c47VY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Wp; else goto c47VZ;
       u47Wp: // global
           call _c47VY(R1) args: 0, res: 0, upd: 0;
       c47VZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47VY() //  [R1]
         { info_tbl: [(c47VY,
                       label: block_c47VY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47VY: // global
           I64[Sp] = block_c47W4_info;
           _s47zH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zH::I64;
           if (R1 & 7 != 0) goto u47Wo; else goto c47W8;
       u47Wo: // global
           call _c47W4(R1) args: 0, res: 0, upd: 0;
       c47W8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47W4() //  [R1]
         { info_tbl: [(c47W4,
                       label: block_c47W4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47W4: // global
           _s47zH::I64 = I64[Sp + 8];
           _s47zJ::I64 = I64[R1 + 7];
           if (_s47zH::I64 >= _s47zJ::I64) goto c47Wm; else goto c47Wn;
       c47Wm: // global
           if (_s47zH::I64 == _s47zJ::I64) goto c47Wk; else goto c47Wj;
       c47Wk: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47Wj: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47Wn: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.339154573 UTC

[section ""data" . GHC.Ptr.$fEqPtr_$c==_closure" {
     GHC.Ptr.$fEqPtr_$c==_closure:
         const GHC.Ptr.$fEqPtr_$c==_info;
 },
 GHC.Ptr.$fEqPtr_$c==_entry() //  [R2, R3]
         { info_tbl: [(c47Wx,
                       label: GHC.Ptr.$fEqPtr_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Wx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47WB; else goto c47WC;
       c47WB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqPtr_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47WC: // global
           I64[Sp - 16] = block_c47Wu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47WL; else goto c47Wv;
       u47WL: // global
           call _c47Wu(R1) args: 0, res: 0, upd: 0;
       c47Wv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Wu() //  [R1]
         { info_tbl: [(c47Wu,
                       label: block_c47Wu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Wu: // global
           I64[Sp] = block_c47WA_info;
           _s47zP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zP::I64;
           if (R1 & 7 != 0) goto u47WK; else goto c47WE;
       u47WK: // global
           call _c47WA(R1) args: 0, res: 0, upd: 0;
       c47WE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47WA() //  [R1]
         { info_tbl: [(c47WA,
                       label: block_c47WA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47WA: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.340719154 UTC

[section ""data" . GHC.Ptr.$fEqPtr_$c/=_closure" {
     GHC.Ptr.$fEqPtr_$c/=_closure:
         const GHC.Ptr.$fEqPtr_$c/=_info;
 },
 GHC.Ptr.$fEqPtr_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c47WT,
                       label: GHC.Ptr.$fEqPtr_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47WT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47WX; else goto c47WY;
       c47WX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqPtr_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47WY: // global
           I64[Sp - 16] = block_c47WQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Xb; else goto c47WR;
       u47Xb: // global
           call _c47WQ(R1) args: 0, res: 0, upd: 0;
       c47WR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47WQ() //  [R1]
         { info_tbl: [(c47WQ,
                       label: block_c47WQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47WQ: // global
           I64[Sp] = block_c47WW_info;
           _s47zW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zW::I64;
           if (R1 & 7 != 0) goto u47Xa; else goto c47X0;
       u47Xa: // global
           call _c47WW(R1) args: 0, res: 0, upd: 0;
       c47X0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47WW() //  [R1]
         { info_tbl: [(c47WW,
                       label: block_c47WW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47WW: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c47X9; else goto c47X8;
       c47X9: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47X8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.341979587 UTC

[section ""data" . GHC.Ptr.$fEqPtr_closure" {
     GHC.Ptr.$fEqPtr_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Ptr.$fEqPtr_$c==_closure+2;
         const GHC.Ptr.$fEqPtr_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.342905535 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c<=_closure" {
     GHC.Ptr.$fOrdPtr_$c<=_closure:
         const GHC.Ptr.$fOrdPtr_$c<=_info;
 },
 GHC.Ptr.$fOrdPtr_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c47Xj,
                       label: GHC.Ptr.$fOrdPtr_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Xj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47Xn; else goto c47Xo;
       c47Xn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Xo: // global
           I64[Sp - 16] = block_c47Xg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47XB; else goto c47Xh;
       u47XB: // global
           call _c47Xg(R1) args: 0, res: 0, upd: 0;
       c47Xh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Xg() //  [R1]
         { info_tbl: [(c47Xg,
                       label: block_c47Xg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Xg: // global
           I64[Sp] = block_c47Xm_info;
           _s47A3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47A3::I64;
           if (R1 & 7 != 0) goto u47XA; else goto c47Xq;
       u47XA: // global
           call _c47Xm(R1) args: 0, res: 0, upd: 0;
       c47Xq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Xm() //  [R1]
         { info_tbl: [(c47Xm,
                       label: block_c47Xm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Xm: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47Xy; else goto c47Xz;
       c47Xy: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47Xz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.344428066 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$cmax_closure" {
     GHC.Ptr.$fOrdPtr_$cmax_closure:
         const GHC.Ptr.$fOrdPtr_$cmax_info;
 },
 GHC.Ptr.$fOrdPtr_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c47XJ,
                       label: GHC.Ptr.$fOrdPtr_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47XJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c47XN; else goto c47XO;
       c47XN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47XO: // global
           I64[Sp - 16] = block_c47XG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Y1; else goto c47XH;
       u47Y1: // global
           call _c47XG(R1) args: 0, res: 0, upd: 0;
       c47XH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47XG() //  [R1]
         { info_tbl: [(c47XG,
                       label: block_c47XG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47XG: // global
           I64[Sp - 8] = block_c47XM_info;
           _s47A9::P64 = R1;
           _s47Aa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47Aa::I64;
           P64[Sp + 8] = _s47A9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47Y0; else goto c47XQ;
       u47Y0: // global
           call _c47XM(R1) args: 0, res: 0, upd: 0;
       c47XQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47XM() //  [R1]
         { info_tbl: [(c47XM,
                       label: block_c47XM_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47XM: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47XY; else goto c47XZ;
       c47XY: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c47XZ: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.346351206 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c>=_closure" {
     GHC.Ptr.$fOrdPtr_$c>=_closure:
         const GHC.Ptr.$fOrdPtr_$c>=_info;
 },
 GHC.Ptr.$fOrdPtr_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c47Y9,
                       label: GHC.Ptr.$fOrdPtr_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Y9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47Yd; else goto c47Ye;
       c47Yd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Ye: // global
           I64[Sp - 16] = block_c47Y6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Yr; else goto c47Y7;
       u47Yr: // global
           call _c47Y6(R1) args: 0, res: 0, upd: 0;
       c47Y7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Y6() //  [R1]
         { info_tbl: [(c47Y6,
                       label: block_c47Y6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Y6: // global
           I64[Sp] = block_c47Yc_info;
           _s47Ah::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47Ah::I64;
           if (R1 & 7 != 0) goto u47Yq; else goto c47Yg;
       u47Yq: // global
           call _c47Yc(R1) args: 0, res: 0, upd: 0;
       c47Yg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Yc() //  [R1]
         { info_tbl: [(c47Yc,
                       label: block_c47Yc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Yc: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47Yo; else goto c47Yp;
       c47Yo: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c47Yp: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.347876249 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c>_closure" {
     GHC.Ptr.$fOrdPtr_$c>_closure:
         const GHC.Ptr.$fOrdPtr_$c>_info;
 },
 GHC.Ptr.$fOrdPtr_$c>_entry() //  [R2, R3]
         { info_tbl: [(c47Yz,
                       label: GHC.Ptr.$fOrdPtr_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Yz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47YD; else goto c47YE;
       c47YD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47YE: // global
           I64[Sp - 16] = block_c47Yw_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47YN; else goto c47Yx;
       u47YN: // global
           call _c47Yw(R1) args: 0, res: 0, upd: 0;
       c47Yx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Yw() //  [R1]
         { info_tbl: [(c47Yw,
                       label: block_c47Yw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Yw: // global
           I64[Sp] = block_c47YC_info;
           _s47Ao::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47Ao::I64;
           if (R1 & 7 != 0) goto u47YM; else goto c47YG;
       u47YM: // global
           call _c47YC(R1) args: 0, res: 0, upd: 0;
       c47YG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47YC() //  [R1]
         { info_tbl: [(c47YC,
                       label: block_c47YC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47YC: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.349513985 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$cmin_closure" {
     GHC.Ptr.$fOrdPtr_$cmin_closure:
         const GHC.Ptr.$fOrdPtr_$cmin_info;
 },
 GHC.Ptr.$fOrdPtr_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c47YV,
                       label: GHC.Ptr.$fOrdPtr_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47YV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c47YZ; else goto c47Z0;
       c47YZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47Z0: // global
           I64[Sp - 16] = block_c47YS_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47Zd; else goto c47YT;
       u47Zd: // global
           call _c47YS(R1) args: 0, res: 0, upd: 0;
       c47YT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47YS() //  [R1]
         { info_tbl: [(c47YS,
                       label: block_c47YS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47YS: // global
           I64[Sp - 8] = block_c47YY_info;
           _s47Au::P64 = R1;
           _s47Av::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47Av::I64;
           P64[Sp + 8] = _s47Au::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u47Zc; else goto c47Z2;
       u47Zc: // global
           call _c47YY(R1) args: 0, res: 0, upd: 0;
       c47Z2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47YY() //  [R1]
         { info_tbl: [(c47YY,
                       label: block_c47YY_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47YY: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c47Za; else goto c47Zb;
       c47Za: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c47Zb: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.350771383 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_closure" {
     GHC.Ptr.$fOrdPtr_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Ptr.$fEqPtr_closure+1;
         const GHC.Ptr.$fOrdPtr_$ccompare_closure+2;
         const GHC.Ptr.$fOrdPtr_$c<_closure+2;
         const GHC.Ptr.$fOrdPtr_$c<=_closure+2;
         const GHC.Ptr.$fOrdPtr_$c>_closure+2;
         const GHC.Ptr.$fOrdPtr_$c>=_closure+2;
         const GHC.Ptr.$fOrdPtr_$cmax_closure+2;
         const GHC.Ptr.$fOrdPtr_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.351414406 UTC

[section ""data" . GHC.Ptr.nullPtr_closure" {
     GHC.Ptr.nullPtr_closure:
         const GHC.Ptr.Ptr_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.352091826 UTC

[section ""data" . GHC.Ptr.castPtr1_closure" {
     GHC.Ptr.castPtr1_closure:
         const GHC.Ptr.castPtr1_info;
 },
 GHC.Ptr.castPtr1_entry() //  [R2]
         { info_tbl: [(c47Zi,
                       label: GHC.Ptr.castPtr1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Zi: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.352900094 UTC

[section ""data" . GHC.Ptr.castPtr_closure" {
     GHC.Ptr.castPtr_closure:
         const GHC.Ptr.castPtr_info;
 },
 GHC.Ptr.castPtr_entry() //  [R2]
         { info_tbl: [(c47Zp,
                       label: GHC.Ptr.castPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Zp: // global
           R2 = R2;
           call GHC.Ptr.castPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.354000422 UTC

[section ""data" . GHC.Ptr.plusPtr_closure" {
     GHC.Ptr.plusPtr_closure:
         const GHC.Ptr.plusPtr_info;
 },
 GHC.Ptr.plusPtr_entry() //  [R2, R3]
         { info_tbl: [(c47Zz,
                       label: GHC.Ptr.plusPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Zz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c47ZL; else goto c47ZM;
       c47ZL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.plusPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c47ZM: // global
           I64[Sp - 16] = block_c47Zw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u47ZS; else goto c47Zx;
       u47ZS: // global
           call _c47Zw(R1) args: 0, res: 0, upd: 0;
       c47Zx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47Zw() //  [R1]
         { info_tbl: [(c47Zw,
                       label: block_c47Zw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47Zw: // global
           I64[Sp] = block_c47ZC_info;
           _s47AD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47AD::I64;
           if (R1 & 7 != 0) goto u47ZR; else goto c47ZD;
       u47ZR: // global
           call _c47ZC(R1) args: 0, res: 0, upd: 0;
       c47ZD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47ZC() //  [R1]
         { info_tbl: [(c47ZC,
                       label: block_c47ZC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47ZC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c47ZQ; else goto c47ZP;
       c47ZQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c47ZP: // global
           _s47AG::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s47AG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.355863347 UTC

[section ""data" . GHC.Ptr.alignPtr_closure" {
     GHC.Ptr.alignPtr_closure:
         const GHC.Ptr.alignPtr_info;
 },
 GHC.Ptr.alignPtr_entry() //  [R2, R3]
         { info_tbl: [(c4800,
                       label: GHC.Ptr.alignPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4800: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4804; else goto c4805;
       c4804: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.alignPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4805: // global
           I64[Sp - 16] = block_c47ZX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u480D; else goto c47ZY;
       u480D: // global
           call _c47ZX(R1) args: 0, res: 0, upd: 0;
       c47ZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c47ZX() //  [R1]
         { info_tbl: [(c47ZX,
                       label: block_c47ZX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c47ZX: // global
           I64[Sp - 8] = block_c4803_info;
           _s47AJ::P64 = R1;
           _s47AK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47AK::I64;
           P64[Sp + 8] = _s47AJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u480C; else goto c4807;
       u480C: // global
           call _c4803(R1) args: 0, res: 0, upd: 0;
       c4807: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4803() //  [R1]
         { info_tbl: [(c4803,
                       label: block_c4803_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4803: // global
           _s47AM::I64 = I64[R1 + 7];
           _s47AN::I64 = I64[Sp + 8] % _s47AM::I64;
           if (_s47AN::I64 != 0) goto u480A; else goto c480w;
       u480A: // global
           I64[Sp] = _s47AN::I64;
           I64[Sp + 16] = _s47AM::I64;
           call _c480g() args: 0, res: 0, upd: 0;
       c480w: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c480g() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c480g: // global
           Hp = Hp + 16;
           _s47AN::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c480t; else goto c480s;
       c480t: // global
           HpAlloc = 16;
           I64[Sp] = block_c480f_info;
           R1 = _s47AN::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c480s: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + (I64[Sp + 16] - _s47AN::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c480f() //  [R1]
         { info_tbl: [(c480f,
                       label: block_c480f_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c480f: // global
           I64[Sp] = R1;
           call _c480g() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.35793425 UTC

[section ""data" . GHC.Ptr.minusPtr_closure" {
     GHC.Ptr.minusPtr_closure:
         const GHC.Ptr.minusPtr_info;
 },
 GHC.Ptr.minusPtr_entry() //  [R2, R3]
         { info_tbl: [(c480N,
                       label: GHC.Ptr.minusPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c480N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c480Z; else goto c4810;
       c480Z: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.minusPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4810: // global
           I64[Sp - 16] = block_c480K_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4816; else goto c480L;
       u4816: // global
           call _c480K(R1) args: 0, res: 0, upd: 0;
       c480L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c480K() //  [R1]
         { info_tbl: [(c480K,
                       label: block_c480K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c480K: // global
           I64[Sp] = block_c480Q_info;
           _s47AT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47AT::I64;
           if (R1 & 7 != 0) goto u4815; else goto c480R;
       u4815: // global
           call _c480Q(R1) args: 0, res: 0, upd: 0;
       c480R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c480Q() //  [R1]
         { info_tbl: [(c480Q,
                       label: block_c480Q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c480Q: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4814; else goto c4813;
       c4814: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4813: // global
           _s47AW::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s47AW::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.359201821 UTC

[section ""data" . GHC.Ptr.nullFunPtr_closure" {
     GHC.Ptr.nullFunPtr_closure:
         const GHC.Ptr.FunPtr_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.359837391 UTC

[section ""data" . GHC.Ptr.castFunPtr1_closure" {
     GHC.Ptr.castFunPtr1_closure:
         const GHC.Ptr.castFunPtr1_info;
 },
 GHC.Ptr.castFunPtr1_entry() //  [R2]
         { info_tbl: [(c481b,
                       label: GHC.Ptr.castFunPtr1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c481b: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.360658627 UTC

[section ""data" . GHC.Ptr.castFunPtr_closure" {
     GHC.Ptr.castFunPtr_closure:
         const GHC.Ptr.castFunPtr_info;
 },
 GHC.Ptr.castFunPtr_entry() //  [R2]
         { info_tbl: [(c481i,
                       label: GHC.Ptr.castFunPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c481i: // global
           R2 = R2;
           call GHC.Ptr.castFunPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.361936182 UTC

[section ""data" . GHC.Ptr.castFunPtrToPtr_closure" {
     GHC.Ptr.castFunPtrToPtr_closure:
         const GHC.Ptr.castFunPtrToPtr_info;
 },
 GHC.Ptr.castFunPtrToPtr_entry() //  [R2]
         { info_tbl: [(c481s,
                       label: GHC.Ptr.castFunPtrToPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c481s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c481w; else goto c481x;
       c481w: // global
           R2 = R2;
           R1 = GHC.Ptr.castFunPtrToPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c481x: // global
           I64[Sp - 8] = block_c481p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u481B; else goto c481q;
       u481B: // global
           call _c481p(R1) args: 0, res: 0, upd: 0;
       c481q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c481p() //  [R1]
         { info_tbl: [(c481p,
                       label: block_c481p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c481p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c481A; else goto c481z;
       c481A: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c481z: // global
           _s47B0::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s47B0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.363399046 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowsPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(c481J,
                       label: GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c481J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c481P; else goto c481Q;
       c481P: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c481Q: // global
           I64[Sp - 16] = block_c481G_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u481V; else goto c481H;
       u481V: // global
           call _c481G(R1) args: 0, res: 0, upd: 0;
       c481H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c481G() //  [R1]
         { info_tbl: [(c481G,
                       label: block_c481G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c481G: // global
           _s47B3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c481M_info;
           R3 = _s47B3::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c481M() //  [R1, R2]
         { info_tbl: [(c481M,
                       label: block_c481M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c481M: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c481U; else goto c481T;
       c481U: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c481T: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.36505712 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshow_closure" {
     GHC.Ptr.$fShowFunPtr_$cshow_closure:
         const GHC.Ptr.$fShowFunPtr_$cshow_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshow_entry() //  [R2]
         { info_tbl: [(c4823,
                       label: GHC.Ptr.$fShowFunPtr_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4823: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4829; else goto c482a;
       c4829: // global
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c482a: // global
           I64[Sp - 8] = block_c4820_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u482f; else goto c4821;
       u482f: // global
           call _c4820(R1) args: 0, res: 0, upd: 0;
       c4821: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4820() //  [R1]
         { info_tbl: [(c4820,
                       label: block_c4820_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4820: // global
           I64[Sp] = block_c4826_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4826() //  [R1, R2]
         { info_tbl: [(c4826,
                       label: block_c4826_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4826: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c482e; else goto c482d;
       c482e: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c482d: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.366697458 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr1_closure" {
     GHC.Ptr.$fShowFunPtr1_closure:
         const GHC.Ptr.$fShowFunPtr1_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr1_entry() //  [R2, R3]
         { info_tbl: [(c482n,
                       label: GHC.Ptr.$fShowFunPtr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c482n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c482t; else goto c482u;
       c482t: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c482u: // global
           I64[Sp - 16] = block_c482k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u482z; else goto c482l;
       u482z: // global
           call _c482k(R1) args: 0, res: 0, upd: 0;
       c482l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c482k() //  [R1]
         { info_tbl: [(c482k,
                       label: block_c482k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c482k: // global
           _s47Bg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c482q_info;
           R3 = _s47Bg::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c482q() //  [R1, R2]
         { info_tbl: [(c482q,
                       label: block_c482q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c482q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c482y; else goto c482x;
       c482y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c482x: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.369693437 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowList_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowList_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowList_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c482E,
                       label: GHC.Ptr.$fShowFunPtr_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c482E: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Ptr.$fShowFunPtr1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.370435182 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_closure" {
     GHC.Ptr.$fShowFunPtr_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure+3;
         const GHC.Ptr.$fShowFunPtr_$cshow_closure+1;
         const GHC.Ptr.$fShowFunPtr_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.371289355 UTC

[section ""data" . GHC.Ptr.castPtrToFunPtr_closure" {
     GHC.Ptr.castPtrToFunPtr_closure:
         const GHC.Ptr.castPtrToFunPtr_info;
 },
 GHC.Ptr.castPtrToFunPtr_entry() //  [R2]
         { info_tbl: [(c482O,
                       label: GHC.Ptr.castPtrToFunPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c482O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c482S; else goto c482T;
       c482S: // global
           R2 = R2;
           R1 = GHC.Ptr.castPtrToFunPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c482T: // global
           I64[Sp - 8] = block_c482L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u482X; else goto c482M;
       u482X: // global
           call _c482L(R1) args: 0, res: 0, upd: 0;
       c482M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c482L() //  [R1]
         { info_tbl: [(c482L,
                       label: block_c482L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c482L: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c482W; else goto c482V;
       c482W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c482V: // global
           _s47Bq::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s47Bq::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.372339871 UTC

[section ""cstring" . GHC.Ptr.$trModule4_bytes" {
     GHC.Ptr.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.37288492 UTC

[section ""data" . GHC.Ptr.$trModule3_closure" {
     GHC.Ptr.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.373433158 UTC

[section ""cstring" . GHC.Ptr.$trModule2_bytes" {
     GHC.Ptr.$trModule2_bytes:
         I8[] [71,72,67,46,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.373971508 UTC

[section ""data" . GHC.Ptr.$trModule1_closure" {
     GHC.Ptr.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.374501564 UTC

[section ""data" . GHC.Ptr.$trModule_closure" {
     GHC.Ptr.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Ptr.$trModule3_closure+1;
         const GHC.Ptr.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.375062743 UTC

[section ""data" . $krep_r47xK_closure" {
     $krep_r47xK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.375608632 UTC

[section ""data" . $krep1_r47xL_closure" {
     $krep1_r47xL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcAddr#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.376146674 UTC

[section ""cstring" . GHC.Ptr.$tcPtr2_bytes" {
     GHC.Ptr.$tcPtr2_bytes:
         I8[] [80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.376653156 UTC

[section ""data" . GHC.Ptr.$tcPtr1_closure" {
     GHC.Ptr.$tcPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tcPtr2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.377217059 UTC

[section ""data" . GHC.Ptr.$tcPtr_closure" {
     GHC.Ptr.$tcPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tcPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13939499724423561315;
         const 16316673677148652216;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.377914295 UTC

[section ""data" . $krep2_r47xM_closure" {
     $krep2_r47xM_closure:
         const :_con_info;
         const $krep_r47xK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.378509974 UTC

[section ""data" . $krep3_r47xN_closure" {
     $krep3_r47xN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcPtr_closure+1;
         const $krep2_r47xM_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.379072899 UTC

[section ""data" . GHC.Ptr.$tc'Ptr1_closure" {
     GHC.Ptr.$tc'Ptr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r47xL_closure+1;
         const $krep3_r47xN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.379645895 UTC

[section ""cstring" . GHC.Ptr.$tc'Ptr3_bytes" {
     GHC.Ptr.$tc'Ptr3_bytes:
         I8[] [39,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.380195461 UTC

[section ""data" . GHC.Ptr.$tc'Ptr2_closure" {
     GHC.Ptr.$tc'Ptr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tc'Ptr3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.380777274 UTC

[section ""data" . GHC.Ptr.$tc'Ptr_closure" {
     GHC.Ptr.$tc'Ptr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tc'Ptr2_closure+1;
         const GHC.Ptr.$tc'Ptr1_closure+4;
         const 2332306090346040376;
         const 13491728187967991297;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.381425689 UTC

[section ""cstring" . GHC.Ptr.$tcFunPtr2_bytes" {
     GHC.Ptr.$tcFunPtr2_bytes:
         I8[] [70,117,110,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.381979454 UTC

[section ""data" . GHC.Ptr.$tcFunPtr1_closure" {
     GHC.Ptr.$tcFunPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tcFunPtr2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.38255846 UTC

[section ""data" . GHC.Ptr.$tcFunPtr_closure" {
     GHC.Ptr.$tcFunPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tcFunPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 38956960673620606;
         const 4307950889093819770;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.383161562 UTC

[section ""data" . $krep4_r47xO_closure" {
     $krep4_r47xO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcFunPtr_closure+1;
         const $krep2_r47xM_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.383745568 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr1_closure" {
     GHC.Ptr.$tc'FunPtr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r47xL_closure+1;
         const $krep4_r47xO_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.384284181 UTC

[section ""cstring" . GHC.Ptr.$tc'FunPtr3_bytes" {
     GHC.Ptr.$tc'FunPtr3_bytes:
         I8[] [39,70,117,110,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.384799503 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr2_closure" {
     GHC.Ptr.$tc'FunPtr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tc'FunPtr3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.385824892 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr_closure" {
     GHC.Ptr.$tc'FunPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tc'FunPtr2_closure+1;
         const GHC.Ptr.$tc'FunPtr1_closure+4;
         const 15722333564603238588;
         const 12100865307857439187;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.386710219 UTC

[section ""data" . GHC.Ptr.Ptr_closure" {
     GHC.Ptr.Ptr_closure:
         const GHC.Ptr.Ptr_info;
 },
 GHC.Ptr.Ptr_entry() //  [R2]
         { info_tbl: [(c4833,
                       label: GHC.Ptr.Ptr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4833: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4837; else goto c4836;
       c4837: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Ptr.Ptr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4836: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.387690199 UTC

[section ""data" . GHC.Ptr.FunPtr_closure" {
     GHC.Ptr.FunPtr_closure:
         const GHC.Ptr.FunPtr_info;
 },
 GHC.Ptr.FunPtr_entry() //  [R2]
         { info_tbl: [(c483d,
                       label: GHC.Ptr.FunPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c483d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c483h; else goto c483g;
       c483h: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Ptr.FunPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c483g: // global
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.388557916 UTC

[GHC.Ptr.Ptr_con_entry() //  [R1]
         { info_tbl: [(c483i,
                       label: GHC.Ptr.Ptr_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,80,116,114,46,80,116,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c483i: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.389358797 UTC

[GHC.Ptr.FunPtr_con_entry() //  [R1]
         { info_tbl: [(c483k,
                       label: GHC.Ptr.FunPtr_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,80,116,114,46,70,117,110,80,116,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c483k: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.390002544 UTC

[section ""relreadonly" . S47CQ_srt" {
     S47CQ_srt:
         const GHC.Show.intToDigit_closure;
         const GHC.Show.$fShowInteger_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Numeric.showIntAtBase_closure;
         const Numeric.showHex1_closure;
         const GHC.Ptr.$w$cshowsPrec_closure;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure;
         const GHC.Ptr.$fShowPtr_$cshow_closure;
         const GHC.Ptr.$fShowPtr1_closure;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure;
         const GHC.Ptr.$fShowFunPtr_$cshow_closure;
         const GHC.Ptr.$fShowFunPtr1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.390845863 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:00.392035346 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr4_closure" {
     GHC.Ptr.$fShowFunPtr4_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.393872312 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr3_closure" {
     GHC.Ptr.$fShowFunPtr3_closure:
         const GHC.Types.C#_con_info;
         const 120;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.396981473 UTC

[section ""data" . GHC.Ptr.$w$cshowsPrec_closure" {
     GHC.Ptr.$w$cshowsPrec_closure:
         const GHC.Ptr.$w$cshowsPrec_info;
         const 0;
 },
 sat_s47xV_entry() //  [R1]
         { info_tbl: [(c483C,
                       label: sat_s47xV_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c483C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c483D; else goto c483E;
       c483D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c483E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ls_s47xS_entry() //  [R1]
         { info_tbl: [(c483H,
                       label: ls_s47xS_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c483H: // global
           _s47xS::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c483I; else goto c483J;
       c483J: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c483L; else goto c483K;
       c483L: // global
           HpAlloc = 24;
           goto c483I;
       c483I: // global
           R1 = _s47xS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c483K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s47xS::P64;
           _s47xQ::I64 = I64[_s47xS::P64 + 16];
           I64[Hp - 16] = sat_s47xV_info;
           I64[Hp] = _s47xQ::I64;
           R6 = Hp - 16;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Numeric.showHex1_closure;
           R3 = GHC.Show.$fShowInteger_closure;
           R2 = GHC.Real.$fIntegralInteger_closure;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 32, res: 0, upd: 24;
     }
 },
 n_s47xZ_entry() //  [R1]
         { info_tbl: [(c4845,
                       label: n_s47xZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4845: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4846; else goto c4847;
       c4846: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4847: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s47y5_entry() //  [R1]
         { info_tbl: [(c484m,
                       label: sat_s47y5_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c484m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c484n; else goto c484o;
       c484n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c484o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_s47y1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_s47y1_entry() //  [R1, R2]
         { info_tbl: [(c484s,
                       label: $wxs_s47y1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c484s: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c484w; else goto c484v;
       c484w: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c484v: // global
           if (R2 == 1) goto c484r; else goto c484q;
       c484r: // global
           _s47y0::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _s47y0::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c484q: // global
           I64[Hp - 48] = sat_s47y5_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Ptr.$fShowFunPtr4_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s47y6_entry() //  [R1]
         { info_tbl: [(c484y,
                       label: sat_s47y6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c484y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c484z; else goto c484A;
       c484z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c484A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c483Q_info;
           R3 = 0;
           _s47xS::P64 = P64[R1 + 24];
           R2 = _s47xS::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s47xS::P64;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c483Q() //  [R1]
         { info_tbl: [(c483Q,
                       label: block_c483Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c483Q: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c484D; else goto c484C;
       c484D: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c484C: // global
           _s47xR::P64 = P64[Sp + 8];
           _s47xS::P64 = P64[Sp + 16];
           _s47xX::I64 = 16 - R1;
           if (%MO_S_Ge_W64(0, _s47xX::I64)) goto c484F; else goto c484G;
       c484F: // global
           Hp = Hp - 72;
           R3 = _s47xR::P64;
           R2 = _s47xS::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c484G: // global
           I64[Hp - 64] = n_s47xZ_info;
           P64[Hp - 48] = _s47xR::P64;
           P64[Hp - 40] = _s47xS::P64;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Ptr.$fShowFunPtr4_closure+1;
           P64[Hp - 16] = Hp - 64;
           I64[Hp - 8] = $wxs_s47y1_info;
           P64[Hp] = Hp - 30;
           R2 = _s47xX::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call $wxs_s47y1_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Ptr.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c484I,
                       label: GHC.Ptr.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c484I: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c484M; else goto c484L;
       c484M: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c484L: // global
           I64[Hp - 72] = ls_s47xS_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s47y6_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Ptr.$fShowFunPtr3_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = GHC.Ptr.$fShowFunPtr4_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.417587096 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c485z,
                       label: GHC.Ptr.$fShowFunPtr_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c485z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c485F; else goto c485G;
       c485F: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c485G: // global
           I64[Sp - 16] = block_c485w_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u485L; else goto c485x;
       u485L: // global
           call _c485w(R1) args: 0, res: 0, upd: 0;
       c485x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c485w() //  [R1]
         { info_tbl: [(c485w,
                       label: block_c485w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c485w: // global
           _s47ya::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c485C_info;
           R3 = _s47ya::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c485C() //  [R1, R2]
         { info_tbl: [(c485C,
                       label: block_c485C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c485C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c485K; else goto c485J;
       c485K: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c485J: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.425426939 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr2_closure" {
     GHC.Ptr.$fShowFunPtr2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.427769102 UTC

[section ""data" . GHC.Ptr.$fShowPtr_$cshow_closure" {
     GHC.Ptr.$fShowPtr_$cshow_closure:
         const GHC.Ptr.$fShowPtr_$cshow_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr_$cshow_entry() //  [R2]
         { info_tbl: [(c4867,
                       label: GHC.Ptr.$fShowPtr_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4867: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c486d; else goto c486e;
       c486d: // global
           R2 = R2;
           R1 = GHC.Ptr.$fShowPtr_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c486e: // global
           I64[Sp - 8] = block_c4864_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u486j; else goto c4865;
       u486j: // global
           call _c4864(R1) args: 0, res: 0, upd: 0;
       c4865: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4864() //  [R1]
         { info_tbl: [(c4864,
                       label: block_c4864_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4864: // global
           I64[Sp] = block_c486a_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c486a() //  [R1, R2]
         { info_tbl: [(c486a,
                       label: block_c486a_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c486a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c486i; else goto c486h;
       c486i: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c486h: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.435400839 UTC

[section ""data" . GHC.Ptr.$fShowPtr1_closure" {
     GHC.Ptr.$fShowPtr1_closure:
         const GHC.Ptr.$fShowPtr1_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr1_entry() //  [R2, R3]
         { info_tbl: [(c486E,
                       label: GHC.Ptr.$fShowPtr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c486E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c486K; else goto c486L;
       c486K: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c486L: // global
           I64[Sp - 16] = block_c486B_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u486Q; else goto c486C;
       u486Q: // global
           call _c486B(R1) args: 0, res: 0, upd: 0;
       c486C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c486B() //  [R1]
         { info_tbl: [(c486B,
                       label: block_c486B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c486B: // global
           _s47yn::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c486H_info;
           R3 = _s47yn::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c486H() //  [R1, R2]
         { info_tbl: [(c486H,
                       label: block_c486H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c486H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c486P; else goto c486O;
       c486P: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c486O: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.443791172 UTC

[section ""data" . GHC.Ptr.$fShowPtr_$cshowList_closure" {
     GHC.Ptr.$fShowPtr_$cshowList_closure:
         const GHC.Ptr.$fShowPtr_$cshowList_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4878,
                       label: GHC.Ptr.$fShowPtr_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4878: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Ptr.$fShowPtr1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.447140002 UTC

[section ""data" . GHC.Ptr.$fShowPtr_closure" {
     GHC.Ptr.$fShowPtr_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure+3;
         const GHC.Ptr.$fShowPtr_$cshow_closure+1;
         const GHC.Ptr.$fShowPtr_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.449342668 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c<_closure" {
     GHC.Ptr.$fOrdFunPtr_$c<_closure:
         const GHC.Ptr.$fOrdFunPtr_$c<_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c<_entry() //  [R2, R3]
         { info_tbl: [(c487n,
                       label: GHC.Ptr.$fOrdFunPtr_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c487n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c487r; else goto c487s;
       c487r: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c487s: // global
           I64[Sp - 16] = block_c487k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u487B; else goto c487l;
       u487B: // global
           call _c487k(R1) args: 0, res: 0, upd: 0;
       c487l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c487k() //  [R1]
         { info_tbl: [(c487k,
                       label: block_c487k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c487k: // global
           I64[Sp] = block_c487q_info;
           _s47yy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yy::I64;
           if (R1 & 7 != 0) goto u487A; else goto c487u;
       u487A: // global
           call _c487q(R1) args: 0, res: 0, upd: 0;
       c487u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c487q() //  [R1]
         { info_tbl: [(c487q,
                       label: block_c487q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c487q: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.457166045 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$ccompare_closure" {
     GHC.Ptr.$fOrdFunPtr_$ccompare_closure:
         const GHC.Ptr.$fOrdFunPtr_$ccompare_info;
 },
 GHC.Ptr.$fOrdFunPtr_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c4880,
                       label: GHC.Ptr.$fOrdFunPtr_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4880: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4884; else goto c4885;
       c4884: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4885: // global
           I64[Sp - 16] = block_c487X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u488o; else goto c487Y;
       u488o: // global
           call _c487X(R1) args: 0, res: 0, upd: 0;
       c487Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c487X() //  [R1]
         { info_tbl: [(c487X,
                       label: block_c487X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c487X: // global
           I64[Sp] = block_c4883_info;
           _s47yF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yF::I64;
           if (R1 & 7 != 0) goto u488n; else goto c4887;
       u488n: // global
           call _c4883(R1) args: 0, res: 0, upd: 0;
       c4887: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4883() //  [R1]
         { info_tbl: [(c4883,
                       label: block_c4883_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4883: // global
           _s47yF::I64 = I64[Sp + 8];
           _s47yH::I64 = I64[R1 + 7];
           if (_s47yF::I64 >= _s47yH::I64) goto c488l; else goto c488m;
       c488l: // global
           if (_s47yF::I64 == _s47yH::I64) goto c488j; else goto c488i;
       c488j: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c488i: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c488m: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.465049436 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_$c==_closure" {
     GHC.Ptr.$fEqFunPtr_$c==_closure:
         const GHC.Ptr.$fEqFunPtr_$c==_info;
 },
 GHC.Ptr.$fEqFunPtr_$c==_entry() //  [R2, R3]
         { info_tbl: [(c488M,
                       label: GHC.Ptr.$fEqFunPtr_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c488M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c488Q; else goto c488R;
       c488Q: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqFunPtr_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c488R: // global
           I64[Sp - 16] = block_c488J_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4890; else goto c488K;
       u4890: // global
           call _c488J(R1) args: 0, res: 0, upd: 0;
       c488K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c488J() //  [R1]
         { info_tbl: [(c488J,
                       label: block_c488J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c488J: // global
           I64[Sp] = block_c488P_info;
           _s47yN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yN::I64;
           if (R1 & 7 != 0) goto u488Z; else goto c488T;
       u488Z: // global
           call _c488P(R1) args: 0, res: 0, upd: 0;
       c488T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c488P() //  [R1]
         { info_tbl: [(c488P,
                       label: block_c488P_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c488P: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.473009555 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_$c/=_closure" {
     GHC.Ptr.$fEqFunPtr_$c/=_closure:
         const GHC.Ptr.$fEqFunPtr_$c/=_info;
 },
 GHC.Ptr.$fEqFunPtr_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c489p,
                       label: GHC.Ptr.$fEqFunPtr_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c489p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c489t; else goto c489u;
       c489t: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqFunPtr_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c489u: // global
           I64[Sp - 16] = block_c489m_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u489H; else goto c489n;
       u489H: // global
           call _c489m(R1) args: 0, res: 0, upd: 0;
       c489n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c489m() //  [R1]
         { info_tbl: [(c489m,
                       label: block_c489m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c489m: // global
           I64[Sp] = block_c489s_info;
           _s47yU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47yU::I64;
           if (R1 & 7 != 0) goto u489G; else goto c489w;
       u489G: // global
           call _c489s(R1) args: 0, res: 0, upd: 0;
       c489w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c489s() //  [R1]
         { info_tbl: [(c489s,
                       label: block_c489s_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c489s: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c489F; else goto c489E;
       c489F: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c489E: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.481038719 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_closure" {
     GHC.Ptr.$fEqFunPtr_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Ptr.$fEqFunPtr_$c==_closure+2;
         const GHC.Ptr.$fEqFunPtr_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.483314742 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c<=_closure" {
     GHC.Ptr.$fOrdFunPtr_$c<=_closure:
         const GHC.Ptr.$fOrdFunPtr_$c<=_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c48a6,
                       label: GHC.Ptr.$fOrdFunPtr_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48a6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48aa; else goto c48ab;
       c48aa: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48ab: // global
           I64[Sp - 16] = block_c48a3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48ao; else goto c48a4;
       u48ao: // global
           call _c48a3(R1) args: 0, res: 0, upd: 0;
       c48a4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48a3() //  [R1]
         { info_tbl: [(c48a3,
                       label: block_c48a3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48a3: // global
           I64[Sp] = block_c48a9_info;
           _s47z1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47z1::I64;
           if (R1 & 7 != 0) goto u48an; else goto c48ad;
       u48an: // global
           call _c48a9(R1) args: 0, res: 0, upd: 0;
       c48ad: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48a9() //  [R1]
         { info_tbl: [(c48a9,
                       label: block_c48a9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48a9: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48al; else goto c48am;
       c48al: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48am: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.491223172 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$cmax_closure" {
     GHC.Ptr.$fOrdFunPtr_$cmax_closure:
         const GHC.Ptr.$fOrdFunPtr_$cmax_info;
 },
 GHC.Ptr.$fOrdFunPtr_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c48aM,
                       label: GHC.Ptr.$fOrdFunPtr_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48aM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48aQ; else goto c48aR;
       c48aQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48aR: // global
           I64[Sp - 16] = block_c48aJ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48b4; else goto c48aK;
       u48b4: // global
           call _c48aJ(R1) args: 0, res: 0, upd: 0;
       c48aK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48aJ() //  [R1]
         { info_tbl: [(c48aJ,
                       label: block_c48aJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48aJ: // global
           I64[Sp - 8] = block_c48aP_info;
           _s47z7::P64 = R1;
           _s47z8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47z8::I64;
           P64[Sp + 8] = _s47z7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48b3; else goto c48aT;
       u48b3: // global
           call _c48aP(R1) args: 0, res: 0, upd: 0;
       c48aT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48aP() //  [R1]
         { info_tbl: [(c48aP,
                       label: block_c48aP_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48aP: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48b1; else goto c48b2;
       c48b1: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48b2: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.498936151 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c>=_closure" {
     GHC.Ptr.$fOrdFunPtr_$c>=_closure:
         const GHC.Ptr.$fOrdFunPtr_$c>=_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c48bu,
                       label: GHC.Ptr.$fOrdFunPtr_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48bu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48by; else goto c48bz;
       c48by: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48bz: // global
           I64[Sp - 16] = block_c48br_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48bM; else goto c48bs;
       u48bM: // global
           call _c48br(R1) args: 0, res: 0, upd: 0;
       c48bs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48br() //  [R1]
         { info_tbl: [(c48br,
                       label: block_c48br_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48br: // global
           I64[Sp] = block_c48bx_info;
           _s47zf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zf::I64;
           if (R1 & 7 != 0) goto u48bL; else goto c48bB;
       u48bL: // global
           call _c48bx(R1) args: 0, res: 0, upd: 0;
       c48bB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48bx() //  [R1]
         { info_tbl: [(c48bx,
                       label: block_c48bx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48bx: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48bJ; else goto c48bK;
       c48bJ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48bK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.506690336 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c>_closure" {
     GHC.Ptr.$fOrdFunPtr_$c>_closure:
         const GHC.Ptr.$fOrdFunPtr_$c>_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c>_entry() //  [R2, R3]
         { info_tbl: [(c48ca,
                       label: GHC.Ptr.$fOrdFunPtr_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48ca: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48ce; else goto c48cf;
       c48ce: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48cf: // global
           I64[Sp - 16] = block_c48c7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48co; else goto c48c8;
       u48co: // global
           call _c48c7(R1) args: 0, res: 0, upd: 0;
       c48c8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48c7() //  [R1]
         { info_tbl: [(c48c7,
                       label: block_c48c7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48c7: // global
           I64[Sp] = block_c48cd_info;
           _s47zm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zm::I64;
           if (R1 & 7 != 0) goto u48cn; else goto c48ch;
       u48cn: // global
           call _c48cd(R1) args: 0, res: 0, upd: 0;
       c48ch: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48cd() //  [R1]
         { info_tbl: [(c48cd,
                       label: block_c48cd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48cd: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.515158034 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$cmin_closure" {
     GHC.Ptr.$fOrdFunPtr_$cmin_closure:
         const GHC.Ptr.$fOrdFunPtr_$cmin_info;
 },
 GHC.Ptr.$fOrdFunPtr_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c48cN,
                       label: GHC.Ptr.$fOrdFunPtr_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48cN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48cR; else goto c48cS;
       c48cR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48cS: // global
           I64[Sp - 16] = block_c48cK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48d5; else goto c48cL;
       u48d5: // global
           call _c48cK(R1) args: 0, res: 0, upd: 0;
       c48cL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48cK() //  [R1]
         { info_tbl: [(c48cK,
                       label: block_c48cK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48cK: // global
           I64[Sp - 8] = block_c48cQ_info;
           _s47zs::P64 = R1;
           _s47zt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47zt::I64;
           P64[Sp + 8] = _s47zs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48d4; else goto c48cU;
       u48d4: // global
           call _c48cQ(R1) args: 0, res: 0, upd: 0;
       c48cU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48cQ() //  [R1]
         { info_tbl: [(c48cQ,
                       label: block_c48cQ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48cQ: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48d2; else goto c48d3;
       c48d2: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48d3: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.522386653 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_closure" {
     GHC.Ptr.$fOrdFunPtr_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Ptr.$fEqFunPtr_closure+1;
         const GHC.Ptr.$fOrdFunPtr_$ccompare_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c<_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c<=_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c>_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c>=_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$cmax_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.524701179 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c<_closure" {
     GHC.Ptr.$fOrdPtr_$c<_closure:
         const GHC.Ptr.$fOrdPtr_$c<_info;
 },
 GHC.Ptr.$fOrdPtr_$c<_entry() //  [R2, R3]
         { info_tbl: [(c48dw,
                       label: GHC.Ptr.$fOrdPtr_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48dw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48dA; else goto c48dB;
       c48dA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48dB: // global
           I64[Sp - 16] = block_c48dt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48dK; else goto c48du;
       u48dK: // global
           call _c48dt(R1) args: 0, res: 0, upd: 0;
       c48du: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48dt() //  [R1]
         { info_tbl: [(c48dt,
                       label: block_c48dt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48dt: // global
           I64[Sp] = block_c48dz_info;
           _s47zA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zA::I64;
           if (R1 & 7 != 0) goto u48dJ; else goto c48dD;
       u48dJ: // global
           call _c48dz(R1) args: 0, res: 0, upd: 0;
       c48dD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48dz() //  [R1]
         { info_tbl: [(c48dz,
                       label: block_c48dz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48dz: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.532590857 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$ccompare_closure" {
     GHC.Ptr.$fOrdPtr_$ccompare_closure:
         const GHC.Ptr.$fOrdPtr_$ccompare_info;
 },
 GHC.Ptr.$fOrdPtr_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c48e9,
                       label: GHC.Ptr.$fOrdPtr_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48e9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48ed; else goto c48ee;
       c48ed: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48ee: // global
           I64[Sp - 16] = block_c48e6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48ex; else goto c48e7;
       u48ex: // global
           call _c48e6(R1) args: 0, res: 0, upd: 0;
       c48e7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48e6() //  [R1]
         { info_tbl: [(c48e6,
                       label: block_c48e6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48e6: // global
           I64[Sp] = block_c48ec_info;
           _s47zH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zH::I64;
           if (R1 & 7 != 0) goto u48ew; else goto c48eg;
       u48ew: // global
           call _c48ec(R1) args: 0, res: 0, upd: 0;
       c48eg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48ec() //  [R1]
         { info_tbl: [(c48ec,
                       label: block_c48ec_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48ec: // global
           _s47zH::I64 = I64[Sp + 8];
           _s47zJ::I64 = I64[R1 + 7];
           if (_s47zH::I64 >= _s47zJ::I64) goto c48eu; else goto c48ev;
       c48eu: // global
           if (_s47zH::I64 == _s47zJ::I64) goto c48es; else goto c48er;
       c48es: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48er: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48ev: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.540509768 UTC

[section ""data" . GHC.Ptr.$fEqPtr_$c==_closure" {
     GHC.Ptr.$fEqPtr_$c==_closure:
         const GHC.Ptr.$fEqPtr_$c==_info;
 },
 GHC.Ptr.$fEqPtr_$c==_entry() //  [R2, R3]
         { info_tbl: [(c48eV,
                       label: GHC.Ptr.$fEqPtr_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48eV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48eZ; else goto c48f0;
       c48eZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqPtr_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48f0: // global
           I64[Sp - 16] = block_c48eS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48f9; else goto c48eT;
       u48f9: // global
           call _c48eS(R1) args: 0, res: 0, upd: 0;
       c48eT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48eS() //  [R1]
         { info_tbl: [(c48eS,
                       label: block_c48eS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48eS: // global
           I64[Sp] = block_c48eY_info;
           _s47zP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zP::I64;
           if (R1 & 7 != 0) goto u48f8; else goto c48f2;
       u48f8: // global
           call _c48eY(R1) args: 0, res: 0, upd: 0;
       c48f2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48eY() //  [R1]
         { info_tbl: [(c48eY,
                       label: block_c48eY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48eY: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.548291609 UTC

[section ""data" . GHC.Ptr.$fEqPtr_$c/=_closure" {
     GHC.Ptr.$fEqPtr_$c/=_closure:
         const GHC.Ptr.$fEqPtr_$c/=_info;
 },
 GHC.Ptr.$fEqPtr_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c48fy,
                       label: GHC.Ptr.$fEqPtr_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48fy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48fC; else goto c48fD;
       c48fC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqPtr_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48fD: // global
           I64[Sp - 16] = block_c48fv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48fQ; else goto c48fw;
       u48fQ: // global
           call _c48fv(R1) args: 0, res: 0, upd: 0;
       c48fw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48fv() //  [R1]
         { info_tbl: [(c48fv,
                       label: block_c48fv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48fv: // global
           I64[Sp] = block_c48fB_info;
           _s47zW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47zW::I64;
           if (R1 & 7 != 0) goto u48fP; else goto c48fF;
       u48fP: // global
           call _c48fB(R1) args: 0, res: 0, upd: 0;
       c48fF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48fB() //  [R1]
         { info_tbl: [(c48fB,
                       label: block_c48fB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48fB: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c48fO; else goto c48fN;
       c48fO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48fN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.556147932 UTC

[section ""data" . GHC.Ptr.$fEqPtr_closure" {
     GHC.Ptr.$fEqPtr_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Ptr.$fEqPtr_$c==_closure+2;
         const GHC.Ptr.$fEqPtr_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.558343537 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c<=_closure" {
     GHC.Ptr.$fOrdPtr_$c<=_closure:
         const GHC.Ptr.$fOrdPtr_$c<=_info;
 },
 GHC.Ptr.$fOrdPtr_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c48gf,
                       label: GHC.Ptr.$fOrdPtr_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48gf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48gj; else goto c48gk;
       c48gj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48gk: // global
           I64[Sp - 16] = block_c48gc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48gx; else goto c48gd;
       u48gx: // global
           call _c48gc(R1) args: 0, res: 0, upd: 0;
       c48gd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48gc() //  [R1]
         { info_tbl: [(c48gc,
                       label: block_c48gc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48gc: // global
           I64[Sp] = block_c48gi_info;
           _s47A3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47A3::I64;
           if (R1 & 7 != 0) goto u48gw; else goto c48gm;
       u48gw: // global
           call _c48gi(R1) args: 0, res: 0, upd: 0;
       c48gm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48gi() //  [R1]
         { info_tbl: [(c48gi,
                       label: block_c48gi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48gi: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48gu; else goto c48gv;
       c48gu: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48gv: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.565942086 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$cmax_closure" {
     GHC.Ptr.$fOrdPtr_$cmax_closure:
         const GHC.Ptr.$fOrdPtr_$cmax_info;
 },
 GHC.Ptr.$fOrdPtr_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c48gV,
                       label: GHC.Ptr.$fOrdPtr_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48gV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48gZ; else goto c48h0;
       c48gZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48h0: // global
           I64[Sp - 16] = block_c48gS_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48hd; else goto c48gT;
       u48hd: // global
           call _c48gS(R1) args: 0, res: 0, upd: 0;
       c48gT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48gS() //  [R1]
         { info_tbl: [(c48gS,
                       label: block_c48gS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48gS: // global
           I64[Sp - 8] = block_c48gY_info;
           _s47A9::P64 = R1;
           _s47Aa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47Aa::I64;
           P64[Sp + 8] = _s47A9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48hc; else goto c48h2;
       u48hc: // global
           call _c48gY(R1) args: 0, res: 0, upd: 0;
       c48h2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48gY() //  [R1]
         { info_tbl: [(c48gY,
                       label: block_c48gY_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48gY: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48ha; else goto c48hb;
       c48ha: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48hb: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.573839865 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c>=_closure" {
     GHC.Ptr.$fOrdPtr_$c>=_closure:
         const GHC.Ptr.$fOrdPtr_$c>=_info;
 },
 GHC.Ptr.$fOrdPtr_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c48hD,
                       label: GHC.Ptr.$fOrdPtr_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48hD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48hH; else goto c48hI;
       c48hH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48hI: // global
           I64[Sp - 16] = block_c48hA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48hV; else goto c48hB;
       u48hV: // global
           call _c48hA(R1) args: 0, res: 0, upd: 0;
       c48hB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48hA() //  [R1]
         { info_tbl: [(c48hA,
                       label: block_c48hA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48hA: // global
           I64[Sp] = block_c48hG_info;
           _s47Ah::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47Ah::I64;
           if (R1 & 7 != 0) goto u48hU; else goto c48hK;
       u48hU: // global
           call _c48hG(R1) args: 0, res: 0, upd: 0;
       c48hK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48hG() //  [R1]
         { info_tbl: [(c48hG,
                       label: block_c48hG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48hG: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48hS; else goto c48hT;
       c48hS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48hT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.581665504 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c>_closure" {
     GHC.Ptr.$fOrdPtr_$c>_closure:
         const GHC.Ptr.$fOrdPtr_$c>_info;
 },
 GHC.Ptr.$fOrdPtr_$c>_entry() //  [R2, R3]
         { info_tbl: [(c48ij,
                       label: GHC.Ptr.$fOrdPtr_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48ij: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48in; else goto c48io;
       c48in: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48io: // global
           I64[Sp - 16] = block_c48ig_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48ix; else goto c48ih;
       u48ix: // global
           call _c48ig(R1) args: 0, res: 0, upd: 0;
       c48ih: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48ig() //  [R1]
         { info_tbl: [(c48ig,
                       label: block_c48ig_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48ig: // global
           I64[Sp] = block_c48im_info;
           _s47Ao::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47Ao::I64;
           if (R1 & 7 != 0) goto u48iw; else goto c48iq;
       u48iw: // global
           call _c48im(R1) args: 0, res: 0, upd: 0;
       c48iq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48im() //  [R1]
         { info_tbl: [(c48im,
                       label: block_c48im_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48im: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.590864291 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$cmin_closure" {
     GHC.Ptr.$fOrdPtr_$cmin_closure:
         const GHC.Ptr.$fOrdPtr_$cmin_info;
 },
 GHC.Ptr.$fOrdPtr_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c48iW,
                       label: GHC.Ptr.$fOrdPtr_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48iW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48j0; else goto c48j1;
       c48j0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48j1: // global
           I64[Sp - 16] = block_c48iT_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48je; else goto c48iU;
       u48je: // global
           call _c48iT(R1) args: 0, res: 0, upd: 0;
       c48iU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48iT() //  [R1]
         { info_tbl: [(c48iT,
                       label: block_c48iT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48iT: // global
           I64[Sp - 8] = block_c48iZ_info;
           _s47Au::P64 = R1;
           _s47Av::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47Av::I64;
           P64[Sp + 8] = _s47Au::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48jd; else goto c48j3;
       u48jd: // global
           call _c48iZ(R1) args: 0, res: 0, upd: 0;
       c48j3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48iZ() //  [R1]
         { info_tbl: [(c48iZ,
                       label: block_c48iZ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48iZ: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48jb; else goto c48jc;
       c48jb: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48jc: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.599654646 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_closure" {
     GHC.Ptr.$fOrdPtr_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Ptr.$fEqPtr_closure+1;
         const GHC.Ptr.$fOrdPtr_$ccompare_closure+2;
         const GHC.Ptr.$fOrdPtr_$c<_closure+2;
         const GHC.Ptr.$fOrdPtr_$c<=_closure+2;
         const GHC.Ptr.$fOrdPtr_$c>_closure+2;
         const GHC.Ptr.$fOrdPtr_$c>=_closure+2;
         const GHC.Ptr.$fOrdPtr_$cmax_closure+2;
         const GHC.Ptr.$fOrdPtr_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.601663753 UTC

[section ""data" . GHC.Ptr.nullPtr_closure" {
     GHC.Ptr.nullPtr_closure:
         const GHC.Ptr.Ptr_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.60378346 UTC

[section ""data" . GHC.Ptr.castPtr1_closure" {
     GHC.Ptr.castPtr1_closure:
         const GHC.Ptr.castPtr1_info;
 },
 GHC.Ptr.castPtr1_entry() //  [R2]
         { info_tbl: [(c48jD,
                       label: GHC.Ptr.castPtr1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48jD: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.607789407 UTC

[section ""data" . GHC.Ptr.castPtr_closure" {
     GHC.Ptr.castPtr_closure:
         const GHC.Ptr.castPtr_info;
 },
 GHC.Ptr.castPtr_entry() //  [R2]
         { info_tbl: [(c48jQ,
                       label: GHC.Ptr.castPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48jQ: // global
           R2 = R2;
           call GHC.Ptr.castPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.611770067 UTC

[section ""data" . GHC.Ptr.plusPtr_closure" {
     GHC.Ptr.plusPtr_closure:
         const GHC.Ptr.plusPtr_info;
 },
 GHC.Ptr.plusPtr_entry() //  [R2, R3]
         { info_tbl: [(c48k4,
                       label: GHC.Ptr.plusPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48k4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48kg; else goto c48kh;
       c48kg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.plusPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48kh: // global
           I64[Sp - 16] = block_c48k1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48kn; else goto c48k2;
       u48kn: // global
           call _c48k1(R1) args: 0, res: 0, upd: 0;
       c48k2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48k1() //  [R1]
         { info_tbl: [(c48k1,
                       label: block_c48k1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48k1: // global
           I64[Sp] = block_c48k7_info;
           _s47AD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47AD::I64;
           if (R1 & 7 != 0) goto u48km; else goto c48k8;
       u48km: // global
           call _c48k7(R1) args: 0, res: 0, upd: 0;
       c48k8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48k7() //  [R1]
         { info_tbl: [(c48k7,
                       label: block_c48k7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48k7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48kl; else goto c48kk;
       c48kl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48kk: // global
           _s47AG::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s47AG::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.620271146 UTC

[section ""data" . GHC.Ptr.alignPtr_closure" {
     GHC.Ptr.alignPtr_closure:
         const GHC.Ptr.alignPtr_info;
 },
 GHC.Ptr.alignPtr_entry() //  [R2, R3]
         { info_tbl: [(c48kL,
                       label: GHC.Ptr.alignPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48kL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48kP; else goto c48kQ;
       c48kP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.alignPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48kQ: // global
           I64[Sp - 16] = block_c48kI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48lo; else goto c48kJ;
       u48lo: // global
           call _c48kI(R1) args: 0, res: 0, upd: 0;
       c48kJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48kI() //  [R1]
         { info_tbl: [(c48kI,
                       label: block_c48kI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48kI: // global
           I64[Sp - 8] = block_c48kO_info;
           _s47AJ::P64 = R1;
           _s47AK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s47AK::I64;
           P64[Sp + 8] = _s47AJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48ln; else goto c48kS;
       u48ln: // global
           call _c48kO(R1) args: 0, res: 0, upd: 0;
       c48kS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48kO() //  [R1]
         { info_tbl: [(c48kO,
                       label: block_c48kO_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48kO: // global
           _s47AM::I64 = I64[R1 + 7];
           _s47AN::I64 = I64[Sp + 8] % _s47AM::I64;
           if (_s47AN::I64 != 0) goto u48ll; else goto c48lh;
       u48ll: // global
           I64[Sp] = _s47AN::I64;
           I64[Sp + 16] = _s47AM::I64;
           call _c48l1() args: 0, res: 0, upd: 0;
       c48lh: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c48l1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48l1: // global
           Hp = Hp + 16;
           _s47AN::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c48le; else goto c48ld;
       c48le: // global
           HpAlloc = 16;
           I64[Sp] = block_c48l0_info;
           R1 = _s47AN::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c48ld: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + (I64[Sp + 16] - _s47AN::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c48l0() //  [R1]
         { info_tbl: [(c48l0,
                       label: block_c48l0_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48l0: // global
           I64[Sp] = R1;
           call _c48l1() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.63264579 UTC

[section ""data" . GHC.Ptr.minusPtr_closure" {
     GHC.Ptr.minusPtr_closure:
         const GHC.Ptr.minusPtr_info;
 },
 GHC.Ptr.minusPtr_entry() //  [R2, R3]
         { info_tbl: [(c48lX,
                       label: GHC.Ptr.minusPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48lX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48m9; else goto c48ma;
       c48m9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.minusPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48ma: // global
           I64[Sp - 16] = block_c48lU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48mg; else goto c48lV;
       u48mg: // global
           call _c48lU(R1) args: 0, res: 0, upd: 0;
       c48lV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48lU() //  [R1]
         { info_tbl: [(c48lU,
                       label: block_c48lU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48lU: // global
           I64[Sp] = block_c48m0_info;
           _s47AT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s47AT::I64;
           if (R1 & 7 != 0) goto u48mf; else goto c48m1;
       u48mf: // global
           call _c48m0(R1) args: 0, res: 0, upd: 0;
       c48m1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48m0() //  [R1]
         { info_tbl: [(c48m0,
                       label: block_c48m0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48m0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48me; else goto c48md;
       c48me: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48md: // global
           _s47AW::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s47AW::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.640111544 UTC

[section ""data" . GHC.Ptr.nullFunPtr_closure" {
     GHC.Ptr.nullFunPtr_closure:
         const GHC.Ptr.FunPtr_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.642106577 UTC

[section ""data" . GHC.Ptr.castFunPtr1_closure" {
     GHC.Ptr.castFunPtr1_closure:
         const GHC.Ptr.castFunPtr1_info;
 },
 GHC.Ptr.castFunPtr1_entry() //  [R2]
         { info_tbl: [(c48mC,
                       label: GHC.Ptr.castFunPtr1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48mC: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.645411147 UTC

[section ""data" . GHC.Ptr.castFunPtr_closure" {
     GHC.Ptr.castFunPtr_closure:
         const GHC.Ptr.castFunPtr_info;
 },
 GHC.Ptr.castFunPtr_entry() //  [R2]
         { info_tbl: [(c48mP,
                       label: GHC.Ptr.castFunPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48mP: // global
           R2 = R2;
           call GHC.Ptr.castFunPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.648855239 UTC

[section ""data" . GHC.Ptr.castFunPtrToPtr_closure" {
     GHC.Ptr.castFunPtrToPtr_closure:
         const GHC.Ptr.castFunPtrToPtr_info;
 },
 GHC.Ptr.castFunPtrToPtr_entry() //  [R2]
         { info_tbl: [(c48n3,
                       label: GHC.Ptr.castFunPtrToPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48n3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48n7; else goto c48n8;
       c48n7: // global
           R2 = R2;
           R1 = GHC.Ptr.castFunPtrToPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48n8: // global
           I64[Sp - 8] = block_c48n0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48nc; else goto c48n1;
       u48nc: // global
           call _c48n0(R1) args: 0, res: 0, upd: 0;
       c48n1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48n0() //  [R1]
         { info_tbl: [(c48n0,
                       label: block_c48n0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48n0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48nb; else goto c48na;
       c48nb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48na: // global
           _s47B0::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s47B0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.655277341 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowsPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(c48nu,
                       label: GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48nu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48nA; else goto c48nB;
       c48nA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c48nB: // global
           I64[Sp - 16] = block_c48nr_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48nG; else goto c48ns;
       u48nG: // global
           call _c48nr(R1) args: 0, res: 0, upd: 0;
       c48ns: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48nr() //  [R1]
         { info_tbl: [(c48nr,
                       label: block_c48nr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48nr: // global
           _s47B3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c48nx_info;
           R3 = _s47B3::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c48nx() //  [R1, R2]
         { info_tbl: [(c48nx,
                       label: block_c48nx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48nx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48nF; else goto c48nE;
       c48nF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48nE: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.663558661 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshow_closure" {
     GHC.Ptr.$fShowFunPtr_$cshow_closure:
         const GHC.Ptr.$fShowFunPtr_$cshow_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshow_entry() //  [R2]
         { info_tbl: [(c48o1,
                       label: GHC.Ptr.$fShowFunPtr_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48o1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48o7; else goto c48o8;
       c48o7: // global
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48o8: // global
           I64[Sp - 8] = block_c48nY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48od; else goto c48nZ;
       u48od: // global
           call _c48nY(R1) args: 0, res: 0, upd: 0;
       c48nZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48nY() //  [R1]
         { info_tbl: [(c48nY,
                       label: block_c48nY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48nY: // global
           I64[Sp] = block_c48o4_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c48o4() //  [R1, R2]
         { info_tbl: [(c48o4,
                       label: block_c48o4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48o4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48oc; else goto c48ob;
       c48oc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48ob: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.671058059 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr1_closure" {
     GHC.Ptr.$fShowFunPtr1_closure:
         const GHC.Ptr.$fShowFunPtr1_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr1_entry() //  [R2, R3]
         { info_tbl: [(c48oy,
                       label: GHC.Ptr.$fShowFunPtr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48oy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48oE; else goto c48oF;
       c48oE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48oF: // global
           I64[Sp - 16] = block_c48ov_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48oK; else goto c48ow;
       u48oK: // global
           call _c48ov(R1) args: 0, res: 0, upd: 0;
       c48ow: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48ov() //  [R1]
         { info_tbl: [(c48ov,
                       label: block_c48ov_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48ov: // global
           _s47Bg::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c48oB_info;
           R3 = _s47Bg::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c48oB() //  [R1, R2]
         { info_tbl: [(c48oB,
                       label: block_c48oB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48oB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48oJ; else goto c48oI;
       c48oJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48oI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.678452231 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowList_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowList_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowList_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c48p2,
                       label: GHC.Ptr.$fShowFunPtr_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48p2: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Ptr.$fShowFunPtr1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.681785286 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_closure" {
     GHC.Ptr.$fShowFunPtr_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure+3;
         const GHC.Ptr.$fShowFunPtr_$cshow_closure+1;
         const GHC.Ptr.$fShowFunPtr_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.683802125 UTC

[section ""data" . GHC.Ptr.castPtrToFunPtr_closure" {
     GHC.Ptr.castPtrToFunPtr_closure:
         const GHC.Ptr.castPtrToFunPtr_info;
 },
 GHC.Ptr.castPtrToFunPtr_entry() //  [R2]
         { info_tbl: [(c48ph,
                       label: GHC.Ptr.castPtrToFunPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48ph: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48pl; else goto c48pm;
       c48pl: // global
           R2 = R2;
           R1 = GHC.Ptr.castPtrToFunPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48pm: // global
           I64[Sp - 8] = block_c48pe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48pq; else goto c48pf;
       u48pq: // global
           call _c48pe(R1) args: 0, res: 0, upd: 0;
       c48pf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48pe() //  [R1]
         { info_tbl: [(c48pe,
                       label: block_c48pe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48pe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48pp; else goto c48po;
       c48pp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48po: // global
           _s47Bq::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s47Bq::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.689582995 UTC

[section ""cstring" . GHC.Ptr.$trModule4_bytes" {
     GHC.Ptr.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.691173896 UTC

[section ""data" . GHC.Ptr.$trModule3_closure" {
     GHC.Ptr.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.692801782 UTC

[section ""cstring" . GHC.Ptr.$trModule2_bytes" {
     GHC.Ptr.$trModule2_bytes:
         I8[] [71,72,67,46,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.695411893 UTC

[section ""data" . GHC.Ptr.$trModule1_closure" {
     GHC.Ptr.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.697016349 UTC

[section ""data" . GHC.Ptr.$trModule_closure" {
     GHC.Ptr.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Ptr.$trModule3_closure+1;
         const GHC.Ptr.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.698747939 UTC

[section ""data" . $krep_r47xK_closure" {
     $krep_r47xK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.700349128 UTC

[section ""data" . $krep1_r47xL_closure" {
     $krep1_r47xL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcAddr#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.702053571 UTC

[section ""cstring" . GHC.Ptr.$tcPtr2_bytes" {
     GHC.Ptr.$tcPtr2_bytes:
         I8[] [80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.70366531 UTC

[section ""data" . GHC.Ptr.$tcPtr1_closure" {
     GHC.Ptr.$tcPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tcPtr2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.705727269 UTC

[section ""data" . GHC.Ptr.$tcPtr_closure" {
     GHC.Ptr.$tcPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tcPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13939499724423561315;
         const 16316673677148652216;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.70750953 UTC

[section ""data" . $krep2_r47xM_closure" {
     $krep2_r47xM_closure:
         const :_con_info;
         const $krep_r47xK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.709131267 UTC

[section ""data" . $krep3_r47xN_closure" {
     $krep3_r47xN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcPtr_closure+1;
         const $krep2_r47xM_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.71085107 UTC

[section ""data" . GHC.Ptr.$tc'Ptr1_closure" {
     GHC.Ptr.$tc'Ptr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r47xL_closure+1;
         const $krep3_r47xN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.71251299 UTC

[section ""cstring" . GHC.Ptr.$tc'Ptr3_bytes" {
     GHC.Ptr.$tc'Ptr3_bytes:
         I8[] [39,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.714122744 UTC

[section ""data" . GHC.Ptr.$tc'Ptr2_closure" {
     GHC.Ptr.$tc'Ptr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tc'Ptr3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.715726353 UTC

[section ""data" . GHC.Ptr.$tc'Ptr_closure" {
     GHC.Ptr.$tc'Ptr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tc'Ptr2_closure+1;
         const GHC.Ptr.$tc'Ptr1_closure+4;
         const 2332306090346040376;
         const 13491728187967991297;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.717461329 UTC

[section ""cstring" . GHC.Ptr.$tcFunPtr2_bytes" {
     GHC.Ptr.$tcFunPtr2_bytes:
         I8[] [70,117,110,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.719621757 UTC

[section ""data" . GHC.Ptr.$tcFunPtr1_closure" {
     GHC.Ptr.$tcFunPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tcFunPtr2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.72189652 UTC

[section ""data" . GHC.Ptr.$tcFunPtr_closure" {
     GHC.Ptr.$tcFunPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tcFunPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 38956960673620606;
         const 4307950889093819770;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.723635696 UTC

[section ""data" . $krep4_r47xO_closure" {
     $krep4_r47xO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcFunPtr_closure+1;
         const $krep2_r47xM_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.725384229 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr1_closure" {
     GHC.Ptr.$tc'FunPtr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r47xL_closure+1;
         const $krep4_r47xO_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.727093427 UTC

[section ""cstring" . GHC.Ptr.$tc'FunPtr3_bytes" {
     GHC.Ptr.$tc'FunPtr3_bytes:
         I8[] [39,70,117,110,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.728754883 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr2_closure" {
     GHC.Ptr.$tc'FunPtr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tc'FunPtr3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.730469769 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr_closure" {
     GHC.Ptr.$tc'FunPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tc'FunPtr2_closure+1;
         const GHC.Ptr.$tc'FunPtr1_closure+4;
         const 15722333564603238588;
         const 12100865307857439187;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.732544643 UTC

[section ""data" . GHC.Ptr.Ptr_closure" {
     GHC.Ptr.Ptr_closure:
         const GHC.Ptr.Ptr_info;
 },
 GHC.Ptr.Ptr_entry() //  [R2]
         { info_tbl: [(c48q4,
                       label: GHC.Ptr.Ptr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48q4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48q8; else goto c48q7;
       c48q8: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Ptr.Ptr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48q7: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.736620693 UTC

[section ""data" . GHC.Ptr.FunPtr_closure" {
     GHC.Ptr.FunPtr_closure:
         const GHC.Ptr.FunPtr_info;
 },
 GHC.Ptr.FunPtr_entry() //  [R2]
         { info_tbl: [(c48qj,
                       label: GHC.Ptr.FunPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48qj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48qn; else goto c48qm;
       c48qn: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Ptr.FunPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48qm: // global
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.740225447 UTC

[GHC.Ptr.Ptr_con_entry() //  [R1]
         { info_tbl: [(c48qt,
                       label: GHC.Ptr.Ptr_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,80,116,114,46,80,116,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48qt: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.743438856 UTC

[GHC.Ptr.FunPtr_con_entry() //  [R1]
         { info_tbl: [(c48qz,
                       label: GHC.Ptr.FunPtr_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,80,116,114,46,70,117,110,80,116,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48qz: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:00.74756429 UTC

[section ""relreadonly" . S47CQ_srt" {
     S47CQ_srt:
         const GHC.Show.intToDigit_closure;
         const GHC.Show.$fShowInteger_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Numeric.showIntAtBase_closure;
         const Numeric.showHex1_closure;
         const GHC.Ptr.$w$cshowsPrec_closure;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure;
         const GHC.Ptr.$fShowPtr_$cshow_closure;
         const GHC.Ptr.$fShowPtr1_closure;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure;
         const GHC.Ptr.$fShowFunPtr_$cshow_closure;
         const GHC.Ptr.$fShowFunPtr1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.37085553 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:01.372431381 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr4_closure" {
     GHC.Ptr.$fShowFunPtr4_closure:
         const GHC.Types.C#_con_info;
         const 48;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.374210538 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr3_closure" {
     GHC.Ptr.$fShowFunPtr3_closure:
         const GHC.Types.C#_con_info;
         const 120;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.377500787 UTC

[section ""data" . GHC.Ptr.$w$cshowsPrec_closure" {
     GHC.Ptr.$w$cshowsPrec_closure:
         const GHC.Ptr.$w$cshowsPrec_info;
         const 0;
 },
 sat_s48qL_entry() //  [R1]
         { info_tbl: [(c48ux,
                       label: sat_s48qL_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48ux: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48uy; else goto c48uz;
       c48uy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c48uz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.wordToInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ls_s48qI_entry() //  [R1]
         { info_tbl: [(c48uC,
                       label: ls_s48qI_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48uC: // global
           _s48qI::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto c48uD; else goto c48uE;
       c48uE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48uG; else goto c48uF;
       c48uG: // global
           HpAlloc = 24;
           goto c48uD;
       c48uD: // global
           R1 = _s48qI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c48uF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s48qI::P64;
           _s48qG::I64 = I64[_s48qI::P64 + 16];
           I64[Hp - 16] = sat_s48qL_info;
           I64[Hp] = _s48qG::I64;
           R6 = Hp - 16;
           R5 = GHC.Show.intToDigit_closure+1;
           R4 = Numeric.showHex1_closure;
           R3 = GHC.Show.$fShowInteger_closure;
           R2 = GHC.Real.$fIntegralInteger_closure;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call Numeric.showIntAtBase_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 32, res: 0, upd: 24;
     }
 },
 n_s48qP_entry() //  [R1]
         { info_tbl: [(c48v0,
                       label: n_s48qP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48v0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48v1; else goto c48v2;
       c48v1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c48v2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s48qV_entry() //  [R1]
         { info_tbl: [(c48vh,
                       label: sat_s48qV_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48vh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48vi; else goto c48vj;
       c48vi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c48vj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_s48qR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_s48qR_entry() //  [R1, R2]
         { info_tbl: [(c48vn,
                       label: $wxs_s48qR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48vn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c48vr; else goto c48vq;
       c48vr: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48vq: // global
           if (R2 == 1) goto c48vm; else goto c48vl;
       c48vm: // global
           _s48qQ::P64 = P64[R1 + 7];
           Hp = Hp - 56;
           R1 = _s48qQ::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48vl: // global
           I64[Hp - 48] = sat_s48qV_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Ptr.$fShowFunPtr4_closure+1;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s48qW_entry() //  [R1]
         { info_tbl: [(c48vt,
                       label: sat_s48qW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48vt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c48vu; else goto c48vv;
       c48vu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c48vv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c48uL_info;
           R3 = 0;
           _s48qI::P64 = P64[R1 + 24];
           R2 = _s48qI::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s48qI::P64;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c48uL() //  [R1]
         { info_tbl: [(c48uL,
                       label: block_c48uL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48uL: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c48vy; else goto c48vx;
       c48vy: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c48vx: // global
           _s48qH::P64 = P64[Sp + 8];
           _s48qI::P64 = P64[Sp + 16];
           _s48qN::I64 = 16 - R1;
           if (%MO_S_Ge_W64(0, _s48qN::I64)) goto c48vA; else goto c48vB;
       c48vA: // global
           Hp = Hp - 72;
           R3 = _s48qH::P64;
           R2 = _s48qI::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c48vB: // global
           I64[Hp - 64] = n_s48qP_info;
           P64[Hp - 48] = _s48qH::P64;
           P64[Hp - 40] = _s48qI::P64;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Ptr.$fShowFunPtr4_closure+1;
           P64[Hp - 16] = Hp - 64;
           I64[Hp - 8] = $wxs_s48qR_info;
           P64[Hp] = Hp - 30;
           R2 = _s48qN::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call $wxs_s48qR_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Ptr.$w$cshowsPrec_entry() //  [R2, R3]
         { info_tbl: [(c48vD,
                       label: GHC.Ptr.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48vD: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c48vH; else goto c48vG;
       c48vH: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48vG: // global
           I64[Hp - 72] = ls_s48qI_info;
           I64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s48qW_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Ptr.$fShowFunPtr3_closure+1;
           P64[Hp] = Hp - 48;
           R2 = Hp - 14;
           R1 = GHC.Ptr.$fShowFunPtr4_closure+1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.398670119 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c48wQ,
                       label: GHC.Ptr.$fShowFunPtr_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48wQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48wW; else goto c48wX;
       c48wW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c48wX: // global
           I64[Sp - 16] = block_c48wN_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48x2; else goto c48wO;
       u48x2: // global
           call _c48wN(R1) args: 0, res: 0, upd: 0;
       c48wO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48wN() //  [R1]
         { info_tbl: [(c48wN,
                       label: block_c48wN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48wN: // global
           _s48r0::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c48wT_info;
           R3 = _s48r0::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c48wT() //  [R1, R2]
         { info_tbl: [(c48wT,
                       label: block_c48wT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48wT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48x1; else goto c48x0;
       c48x1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48x0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.406635839 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr2_closure" {
     GHC.Ptr.$fShowFunPtr2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.408784238 UTC

[section ""data" . GHC.Ptr.$fShowPtr_$cshow_closure" {
     GHC.Ptr.$fShowPtr_$cshow_closure:
         const GHC.Ptr.$fShowPtr_$cshow_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr_$cshow_entry() //  [R2]
         { info_tbl: [(c48xr,
                       label: GHC.Ptr.$fShowPtr_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48xr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48xx; else goto c48xy;
       c48xx: // global
           R2 = R2;
           R1 = GHC.Ptr.$fShowPtr_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48xy: // global
           I64[Sp - 8] = block_c48xo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48xD; else goto c48xp;
       u48xD: // global
           call _c48xo(R1) args: 0, res: 0, upd: 0;
       c48xp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48xo() //  [R1]
         { info_tbl: [(c48xo,
                       label: block_c48xo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48xo: // global
           I64[Sp] = block_c48xu_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c48xu() //  [R1, R2]
         { info_tbl: [(c48xu,
                       label: block_c48xu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48xu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48xC; else goto c48xB;
       c48xC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48xB: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.417585617 UTC

[section ""data" . GHC.Ptr.$fShowPtr1_closure" {
     GHC.Ptr.$fShowPtr1_closure:
         const GHC.Ptr.$fShowPtr1_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr1_entry() //  [R2, R3]
         { info_tbl: [(c48y2,
                       label: GHC.Ptr.$fShowPtr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48y2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48y8; else goto c48y9;
       c48y8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48y9: // global
           I64[Sp - 16] = block_c48xZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48ye; else goto c48y0;
       u48ye: // global
           call _c48xZ(R1) args: 0, res: 0, upd: 0;
       c48y0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48xZ() //  [R1]
         { info_tbl: [(c48xZ,
                       label: block_c48xZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48xZ: // global
           _s48rd::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c48y5_info;
           R3 = _s48rd::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c48y5() //  [R1, R2]
         { info_tbl: [(c48y5,
                       label: block_c48y5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48y5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48yd; else goto c48yc;
       c48yd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48yc: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.425341734 UTC

[section ""data" . GHC.Ptr.$fShowPtr_$cshowList_closure" {
     GHC.Ptr.$fShowPtr_$cshowList_closure:
         const GHC.Ptr.$fShowPtr_$cshowList_info;
         const 0;
 },
 GHC.Ptr.$fShowPtr_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c48yz,
                       label: GHC.Ptr.$fShowPtr_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48yz: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Ptr.$fShowPtr1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.429112759 UTC

[section ""data" . GHC.Ptr.$fShowPtr_closure" {
     GHC.Ptr.$fShowPtr_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure+3;
         const GHC.Ptr.$fShowPtr_$cshow_closure+1;
         const GHC.Ptr.$fShowPtr_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.431641433 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c<_closure" {
     GHC.Ptr.$fOrdFunPtr_$c<_closure:
         const GHC.Ptr.$fOrdFunPtr_$c<_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c<_entry() //  [R2, R3]
         { info_tbl: [(c48yO,
                       label: GHC.Ptr.$fOrdFunPtr_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48yO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48yS; else goto c48yT;
       c48yS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48yT: // global
           I64[Sp - 16] = block_c48yL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48z2; else goto c48yM;
       u48z2: // global
           call _c48yL(R1) args: 0, res: 0, upd: 0;
       c48yM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48yL() //  [R1]
         { info_tbl: [(c48yL,
                       label: block_c48yL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48yL: // global
           I64[Sp] = block_c48yR_info;
           _s48ro::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48ro::I64;
           if (R1 & 7 != 0) goto u48z1; else goto c48yV;
       u48z1: // global
           call _c48yR(R1) args: 0, res: 0, upd: 0;
       c48yV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48yR() //  [R1]
         { info_tbl: [(c48yR,
                       label: block_c48yR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48yR: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.439611304 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$ccompare_closure" {
     GHC.Ptr.$fOrdFunPtr_$ccompare_closure:
         const GHC.Ptr.$fOrdFunPtr_$ccompare_info;
 },
 GHC.Ptr.$fOrdFunPtr_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c48zu,
                       label: GHC.Ptr.$fOrdFunPtr_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48zu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48zy; else goto c48zz;
       c48zy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48zz: // global
           I64[Sp - 16] = block_c48zr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48zS; else goto c48zs;
       u48zS: // global
           call _c48zr(R1) args: 0, res: 0, upd: 0;
       c48zs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48zr() //  [R1]
         { info_tbl: [(c48zr,
                       label: block_c48zr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48zr: // global
           I64[Sp] = block_c48zx_info;
           _s48rv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48rv::I64;
           if (R1 & 7 != 0) goto u48zR; else goto c48zB;
       u48zR: // global
           call _c48zx(R1) args: 0, res: 0, upd: 0;
       c48zB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48zx() //  [R1]
         { info_tbl: [(c48zx,
                       label: block_c48zx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48zx: // global
           _s48rv::I64 = I64[Sp + 8];
           _s48rx::I64 = I64[R1 + 7];
           if (_s48rv::I64 >= _s48rx::I64) goto c48zP; else goto c48zQ;
       c48zP: // global
           if (_s48rv::I64 == _s48rx::I64) goto c48zN; else goto c48zM;
       c48zN: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48zM: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48zQ: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.448213196 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_$c==_closure" {
     GHC.Ptr.$fEqFunPtr_$c==_closure:
         const GHC.Ptr.$fEqFunPtr_$c==_info;
 },
 GHC.Ptr.$fEqFunPtr_$c==_entry() //  [R2, R3]
         { info_tbl: [(c48Al,
                       label: GHC.Ptr.$fEqFunPtr_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Al: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48Ap; else goto c48Aq;
       c48Ap: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqFunPtr_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Aq: // global
           I64[Sp - 16] = block_c48Ai_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Az; else goto c48Aj;
       u48Az: // global
           call _c48Ai(R1) args: 0, res: 0, upd: 0;
       c48Aj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Ai() //  [R1]
         { info_tbl: [(c48Ai,
                       label: block_c48Ai_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Ai: // global
           I64[Sp] = block_c48Ao_info;
           _s48rD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48rD::I64;
           if (R1 & 7 != 0) goto u48Ay; else goto c48As;
       u48Ay: // global
           call _c48Ao(R1) args: 0, res: 0, upd: 0;
       c48As: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Ao() //  [R1]
         { info_tbl: [(c48Ao,
                       label: block_c48Ao_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Ao: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.456393362 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_$c/=_closure" {
     GHC.Ptr.$fEqFunPtr_$c/=_closure:
         const GHC.Ptr.$fEqFunPtr_$c/=_info;
 },
 GHC.Ptr.$fEqFunPtr_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c48B1,
                       label: GHC.Ptr.$fEqFunPtr_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48B1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48B5; else goto c48B6;
       c48B5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqFunPtr_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48B6: // global
           I64[Sp - 16] = block_c48AY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Bj; else goto c48AZ;
       u48Bj: // global
           call _c48AY(R1) args: 0, res: 0, upd: 0;
       c48AZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48AY() //  [R1]
         { info_tbl: [(c48AY,
                       label: block_c48AY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48AY: // global
           I64[Sp] = block_c48B4_info;
           _s48rK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48rK::I64;
           if (R1 & 7 != 0) goto u48Bi; else goto c48B8;
       u48Bi: // global
           call _c48B4(R1) args: 0, res: 0, upd: 0;
       c48B8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48B4() //  [R1]
         { info_tbl: [(c48B4,
                       label: block_c48B4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48B4: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c48Bh; else goto c48Bg;
       c48Bh: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48Bg: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.46440669 UTC

[section ""data" . GHC.Ptr.$fEqFunPtr_closure" {
     GHC.Ptr.$fEqFunPtr_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Ptr.$fEqFunPtr_$c==_closure+2;
         const GHC.Ptr.$fEqFunPtr_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.467215992 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c<=_closure" {
     GHC.Ptr.$fOrdFunPtr_$c<=_closure:
         const GHC.Ptr.$fOrdFunPtr_$c<=_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c48BM,
                       label: GHC.Ptr.$fOrdFunPtr_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48BM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48BQ; else goto c48BR;
       c48BQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48BR: // global
           I64[Sp - 16] = block_c48BJ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48C4; else goto c48BK;
       u48C4: // global
           call _c48BJ(R1) args: 0, res: 0, upd: 0;
       c48BK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48BJ() //  [R1]
         { info_tbl: [(c48BJ,
                       label: block_c48BJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48BJ: // global
           I64[Sp] = block_c48BP_info;
           _s48rR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48rR::I64;
           if (R1 & 7 != 0) goto u48C3; else goto c48BT;
       u48C3: // global
           call _c48BP(R1) args: 0, res: 0, upd: 0;
       c48BT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48BP() //  [R1]
         { info_tbl: [(c48BP,
                       label: block_c48BP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48BP: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48C1; else goto c48C2;
       c48C1: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48C2: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.475635317 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$cmax_closure" {
     GHC.Ptr.$fOrdFunPtr_$cmax_closure:
         const GHC.Ptr.$fOrdFunPtr_$cmax_info;
 },
 GHC.Ptr.$fOrdFunPtr_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c48Cw,
                       label: GHC.Ptr.$fOrdFunPtr_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Cw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48CA; else goto c48CB;
       c48CA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48CB: // global
           I64[Sp - 16] = block_c48Ct_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48CO; else goto c48Cu;
       u48CO: // global
           call _c48Ct(R1) args: 0, res: 0, upd: 0;
       c48Cu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Ct() //  [R1]
         { info_tbl: [(c48Ct,
                       label: block_c48Ct_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Ct: // global
           I64[Sp - 8] = block_c48Cz_info;
           _s48rX::P64 = R1;
           _s48rY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s48rY::I64;
           P64[Sp + 8] = _s48rX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48CN; else goto c48CD;
       u48CN: // global
           call _c48Cz(R1) args: 0, res: 0, upd: 0;
       c48CD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Cz() //  [R1]
         { info_tbl: [(c48Cz,
                       label: block_c48Cz_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Cz: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48CL; else goto c48CM;
       c48CL: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48CM: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.483760558 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c>=_closure" {
     GHC.Ptr.$fOrdFunPtr_$c>=_closure:
         const GHC.Ptr.$fOrdFunPtr_$c>=_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c48Dg,
                       label: GHC.Ptr.$fOrdFunPtr_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Dg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48Dk; else goto c48Dl;
       c48Dk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Dl: // global
           I64[Sp - 16] = block_c48Dd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Dy; else goto c48De;
       u48Dy: // global
           call _c48Dd(R1) args: 0, res: 0, upd: 0;
       c48De: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Dd() //  [R1]
         { info_tbl: [(c48Dd,
                       label: block_c48Dd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Dd: // global
           I64[Sp] = block_c48Dj_info;
           _s48s5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48s5::I64;
           if (R1 & 7 != 0) goto u48Dx; else goto c48Dn;
       u48Dx: // global
           call _c48Dj(R1) args: 0, res: 0, upd: 0;
       c48Dn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Dj() //  [R1]
         { info_tbl: [(c48Dj,
                       label: block_c48Dj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Dj: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48Dv; else goto c48Dw;
       c48Dv: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48Dw: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.492322375 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$c>_closure" {
     GHC.Ptr.$fOrdFunPtr_$c>_closure:
         const GHC.Ptr.$fOrdFunPtr_$c>_info;
 },
 GHC.Ptr.$fOrdFunPtr_$c>_entry() //  [R2, R3]
         { info_tbl: [(c48E0,
                       label: GHC.Ptr.$fOrdFunPtr_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48E0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48E4; else goto c48E5;
       c48E4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48E5: // global
           I64[Sp - 16] = block_c48DX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Ee; else goto c48DY;
       u48Ee: // global
           call _c48DX(R1) args: 0, res: 0, upd: 0;
       c48DY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48DX() //  [R1]
         { info_tbl: [(c48DX,
                       label: block_c48DX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48DX: // global
           I64[Sp] = block_c48E3_info;
           _s48sc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48sc::I64;
           if (R1 & 7 != 0) goto u48Ed; else goto c48E7;
       u48Ed: // global
           call _c48E3(R1) args: 0, res: 0, upd: 0;
       c48E7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48E3() //  [R1]
         { info_tbl: [(c48E3,
                       label: block_c48E3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48E3: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.501179914 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_$cmin_closure" {
     GHC.Ptr.$fOrdFunPtr_$cmin_closure:
         const GHC.Ptr.$fOrdFunPtr_$cmin_info;
 },
 GHC.Ptr.$fOrdFunPtr_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c48EG,
                       label: GHC.Ptr.$fOrdFunPtr_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48EG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48EK; else goto c48EL;
       c48EK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdFunPtr_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48EL: // global
           I64[Sp - 16] = block_c48ED_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48EY; else goto c48EE;
       u48EY: // global
           call _c48ED(R1) args: 0, res: 0, upd: 0;
       c48EE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48ED() //  [R1]
         { info_tbl: [(c48ED,
                       label: block_c48ED_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48ED: // global
           I64[Sp - 8] = block_c48EJ_info;
           _s48si::P64 = R1;
           _s48sj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s48sj::I64;
           P64[Sp + 8] = _s48si::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48EX; else goto c48EN;
       u48EX: // global
           call _c48EJ(R1) args: 0, res: 0, upd: 0;
       c48EN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48EJ() //  [R1]
         { info_tbl: [(c48EJ,
                       label: block_c48EJ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48EJ: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48EV; else goto c48EW;
       c48EV: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48EW: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.508713016 UTC

[section ""data" . GHC.Ptr.$fOrdFunPtr_closure" {
     GHC.Ptr.$fOrdFunPtr_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Ptr.$fEqFunPtr_closure+1;
         const GHC.Ptr.$fOrdFunPtr_$ccompare_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c<_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c<=_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c>_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$c>=_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$cmax_closure+2;
         const GHC.Ptr.$fOrdFunPtr_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.511437607 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c<_closure" {
     GHC.Ptr.$fOrdPtr_$c<_closure:
         const GHC.Ptr.$fOrdPtr_$c<_info;
 },
 GHC.Ptr.$fOrdPtr_$c<_entry() //  [R2, R3]
         { info_tbl: [(c48Fr,
                       label: GHC.Ptr.$fOrdPtr_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Fr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48Fv; else goto c48Fw;
       c48Fv: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Fw: // global
           I64[Sp - 16] = block_c48Fo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48FF; else goto c48Fp;
       u48FF: // global
           call _c48Fo(R1) args: 0, res: 0, upd: 0;
       c48Fp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Fo() //  [R1]
         { info_tbl: [(c48Fo,
                       label: block_c48Fo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Fo: // global
           I64[Sp] = block_c48Fu_info;
           _s48sq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48sq::I64;
           if (R1 & 7 != 0) goto u48FE; else goto c48Fy;
       u48FE: // global
           call _c48Fu(R1) args: 0, res: 0, upd: 0;
       c48Fy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Fu() //  [R1]
         { info_tbl: [(c48Fu,
                       label: block_c48Fu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Fu: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.519566901 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$ccompare_closure" {
     GHC.Ptr.$fOrdPtr_$ccompare_closure:
         const GHC.Ptr.$fOrdPtr_$ccompare_info;
 },
 GHC.Ptr.$fOrdPtr_$ccompare_entry() //  [R2, R3]
         { info_tbl: [(c48G7,
                       label: GHC.Ptr.$fOrdPtr_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48G7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48Gb; else goto c48Gc;
       c48Gb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Gc: // global
           I64[Sp - 16] = block_c48G4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Gv; else goto c48G5;
       u48Gv: // global
           call _c48G4(R1) args: 0, res: 0, upd: 0;
       c48G5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48G4() //  [R1]
         { info_tbl: [(c48G4,
                       label: block_c48G4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48G4: // global
           I64[Sp] = block_c48Ga_info;
           _s48sx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48sx::I64;
           if (R1 & 7 != 0) goto u48Gu; else goto c48Ge;
       u48Gu: // global
           call _c48Ga(R1) args: 0, res: 0, upd: 0;
       c48Ge: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Ga() //  [R1]
         { info_tbl: [(c48Ga,
                       label: block_c48Ga_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Ga: // global
           _s48sx::I64 = I64[Sp + 8];
           _s48sz::I64 = I64[R1 + 7];
           if (_s48sx::I64 >= _s48sz::I64) goto c48Gs; else goto c48Gt;
       c48Gs: // global
           if (_s48sx::I64 == _s48sz::I64) goto c48Gq; else goto c48Gp;
       c48Gq: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48Gp: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48Gt: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.528498732 UTC

[section ""data" . GHC.Ptr.$fEqPtr_$c==_closure" {
     GHC.Ptr.$fEqPtr_$c==_closure:
         const GHC.Ptr.$fEqPtr_$c==_info;
 },
 GHC.Ptr.$fEqPtr_$c==_entry() //  [R2, R3]
         { info_tbl: [(c48GY,
                       label: GHC.Ptr.$fEqPtr_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48GY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48H2; else goto c48H3;
       c48H2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqPtr_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48H3: // global
           I64[Sp - 16] = block_c48GV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Hc; else goto c48GW;
       u48Hc: // global
           call _c48GV(R1) args: 0, res: 0, upd: 0;
       c48GW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48GV() //  [R1]
         { info_tbl: [(c48GV,
                       label: block_c48GV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48GV: // global
           I64[Sp] = block_c48H1_info;
           _s48sF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48sF::I64;
           if (R1 & 7 != 0) goto u48Hb; else goto c48H5;
       u48Hb: // global
           call _c48H1(R1) args: 0, res: 0, upd: 0;
       c48H5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48H1() //  [R1]
         { info_tbl: [(c48H1,
                       label: block_c48H1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48H1: // global
           R1 = I64[((I64[Sp + 8] == I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.536688668 UTC

[section ""data" . GHC.Ptr.$fEqPtr_$c/=_closure" {
     GHC.Ptr.$fEqPtr_$c/=_closure:
         const GHC.Ptr.$fEqPtr_$c/=_info;
 },
 GHC.Ptr.$fEqPtr_$c/=_entry() //  [R2, R3]
         { info_tbl: [(c48HE,
                       label: GHC.Ptr.$fEqPtr_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48HE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48HI; else goto c48HJ;
       c48HI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fEqPtr_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48HJ: // global
           I64[Sp - 16] = block_c48HB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48HW; else goto c48HC;
       u48HW: // global
           call _c48HB(R1) args: 0, res: 0, upd: 0;
       c48HC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48HB() //  [R1]
         { info_tbl: [(c48HB,
                       label: block_c48HB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48HB: // global
           I64[Sp] = block_c48HH_info;
           _s48sM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48sM::I64;
           if (R1 & 7 != 0) goto u48HV; else goto c48HL;
       u48HV: // global
           call _c48HH(R1) args: 0, res: 0, upd: 0;
       c48HL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48HH() //  [R1]
         { info_tbl: [(c48HH,
                       label: block_c48HH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48HH: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto c48HU; else goto c48HT;
       c48HU: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48HT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.545107737 UTC

[section ""data" . GHC.Ptr.$fEqPtr_closure" {
     GHC.Ptr.$fEqPtr_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Ptr.$fEqPtr_$c==_closure+2;
         const GHC.Ptr.$fEqPtr_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.548739625 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c<=_closure" {
     GHC.Ptr.$fOrdPtr_$c<=_closure:
         const GHC.Ptr.$fOrdPtr_$c<=_info;
 },
 GHC.Ptr.$fOrdPtr_$c<=_entry() //  [R2, R3]
         { info_tbl: [(c48Ip,
                       label: GHC.Ptr.$fOrdPtr_$c<=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Ip: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48It; else goto c48Iu;
       c48It: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Iu: // global
           I64[Sp - 16] = block_c48Im_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48IH; else goto c48In;
       u48IH: // global
           call _c48Im(R1) args: 0, res: 0, upd: 0;
       c48In: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Im() //  [R1]
         { info_tbl: [(c48Im,
                       label: block_c48Im_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Im: // global
           I64[Sp] = block_c48Is_info;
           _s48sT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48sT::I64;
           if (R1 & 7 != 0) goto u48IG; else goto c48Iw;
       u48IG: // global
           call _c48Is(R1) args: 0, res: 0, upd: 0;
       c48Iw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Is() //  [R1]
         { info_tbl: [(c48Is,
                       label: block_c48Is_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Is: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48IE; else goto c48IF;
       c48IE: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48IF: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.557179547 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$cmax_closure" {
     GHC.Ptr.$fOrdPtr_$cmax_closure:
         const GHC.Ptr.$fOrdPtr_$cmax_info;
 },
 GHC.Ptr.$fOrdPtr_$cmax_entry() //  [R2, R3]
         { info_tbl: [(c48J9,
                       label: GHC.Ptr.$fOrdPtr_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48J9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48Jd; else goto c48Je;
       c48Jd: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Je: // global
           I64[Sp - 16] = block_c48J6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Jr; else goto c48J7;
       u48Jr: // global
           call _c48J6(R1) args: 0, res: 0, upd: 0;
       c48J7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48J6() //  [R1]
         { info_tbl: [(c48J6,
                       label: block_c48J6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48J6: // global
           I64[Sp - 8] = block_c48Jc_info;
           _s48sZ::P64 = R1;
           _s48t0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s48t0::I64;
           P64[Sp + 8] = _s48sZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48Jq; else goto c48Jg;
       u48Jq: // global
           call _c48Jc(R1) args: 0, res: 0, upd: 0;
       c48Jg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Jc() //  [R1]
         { info_tbl: [(c48Jc,
                       label: block_c48Jc_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Jc: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48Jo; else goto c48Jp;
       c48Jo: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48Jp: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.565799291 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c>=_closure" {
     GHC.Ptr.$fOrdPtr_$c>=_closure:
         const GHC.Ptr.$fOrdPtr_$c>=_info;
 },
 GHC.Ptr.$fOrdPtr_$c>=_entry() //  [R2, R3]
         { info_tbl: [(c48JT,
                       label: GHC.Ptr.$fOrdPtr_$c>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48JT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48JX; else goto c48JY;
       c48JX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48JY: // global
           I64[Sp - 16] = block_c48JQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Kb; else goto c48JR;
       u48Kb: // global
           call _c48JQ(R1) args: 0, res: 0, upd: 0;
       c48JR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48JQ() //  [R1]
         { info_tbl: [(c48JQ,
                       label: block_c48JQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48JQ: // global
           I64[Sp] = block_c48JW_info;
           _s48t7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48t7::I64;
           if (R1 & 7 != 0) goto u48Ka; else goto c48K0;
       u48Ka: // global
           call _c48JW(R1) args: 0, res: 0, upd: 0;
       c48K0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48JW() //  [R1]
         { info_tbl: [(c48JW,
                       label: block_c48JW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48JW: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48K8; else goto c48K9;
       c48K8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c48K9: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.574132757 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$c>_closure" {
     GHC.Ptr.$fOrdPtr_$c>_closure:
         const GHC.Ptr.$fOrdPtr_$c>_info;
 },
 GHC.Ptr.$fOrdPtr_$c>_entry() //  [R2, R3]
         { info_tbl: [(c48KD,
                       label: GHC.Ptr.$fOrdPtr_$c>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48KD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48KH; else goto c48KI;
       c48KH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$c>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48KI: // global
           I64[Sp - 16] = block_c48KA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48KR; else goto c48KB;
       u48KR: // global
           call _c48KA(R1) args: 0, res: 0, upd: 0;
       c48KB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48KA() //  [R1]
         { info_tbl: [(c48KA,
                       label: block_c48KA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48KA: // global
           I64[Sp] = block_c48KG_info;
           _s48te::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48te::I64;
           if (R1 & 7 != 0) goto u48KQ; else goto c48KK;
       u48KQ: // global
           call _c48KG(R1) args: 0, res: 0, upd: 0;
       c48KK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48KG() //  [R1]
         { info_tbl: [(c48KG,
                       label: block_c48KG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48KG: // global
           R1 = I64[((I64[Sp + 8] < I64[R1 + 7]) << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.582297397 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_$cmin_closure" {
     GHC.Ptr.$fOrdPtr_$cmin_closure:
         const GHC.Ptr.$fOrdPtr_$cmin_info;
 },
 GHC.Ptr.$fOrdPtr_$cmin_entry() //  [R2, R3]
         { info_tbl: [(c48Lj,
                       label: GHC.Ptr.$fOrdPtr_$cmin_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Lj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48Ln; else goto c48Lo;
       c48Ln: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fOrdPtr_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Lo: // global
           I64[Sp - 16] = block_c48Lg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48LB; else goto c48Lh;
       u48LB: // global
           call _c48Lg(R1) args: 0, res: 0, upd: 0;
       c48Lh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Lg() //  [R1]
         { info_tbl: [(c48Lg,
                       label: block_c48Lg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Lg: // global
           I64[Sp - 8] = block_c48Lm_info;
           _s48tk::P64 = R1;
           _s48tl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s48tl::I64;
           P64[Sp + 8] = _s48tk::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48LA; else goto c48Lq;
       u48LA: // global
           call _c48Lm(R1) args: 0, res: 0, upd: 0;
       c48Lq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Lm() //  [R1]
         { info_tbl: [(c48Lm,
                       label: block_c48Lm_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Lm: // global
           if (I64[Sp + 8] >= I64[R1 + 7]) goto c48Ly; else goto c48Lz;
       c48Ly: // global
           R1 = R1 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c48Lz: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.589618346 UTC

[section ""data" . GHC.Ptr.$fOrdPtr_closure" {
     GHC.Ptr.$fOrdPtr_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Ptr.$fEqPtr_closure+1;
         const GHC.Ptr.$fOrdPtr_$ccompare_closure+2;
         const GHC.Ptr.$fOrdPtr_$c<_closure+2;
         const GHC.Ptr.$fOrdPtr_$c<=_closure+2;
         const GHC.Ptr.$fOrdPtr_$c>_closure+2;
         const GHC.Ptr.$fOrdPtr_$c>=_closure+2;
         const GHC.Ptr.$fOrdPtr_$cmax_closure+2;
         const GHC.Ptr.$fOrdPtr_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.591845134 UTC

[section ""data" . GHC.Ptr.nullPtr_closure" {
     GHC.Ptr.nullPtr_closure:
         const GHC.Ptr.Ptr_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.593788532 UTC

[section ""data" . GHC.Ptr.castPtr1_closure" {
     GHC.Ptr.castPtr1_closure:
         const GHC.Ptr.castPtr1_info;
 },
 GHC.Ptr.castPtr1_entry() //  [R2]
         { info_tbl: [(c48M2,
                       label: GHC.Ptr.castPtr1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48M2: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.597185797 UTC

[section ""data" . GHC.Ptr.castPtr_closure" {
     GHC.Ptr.castPtr_closure:
         const GHC.Ptr.castPtr_info;
 },
 GHC.Ptr.castPtr_entry() //  [R2]
         { info_tbl: [(c48Mf,
                       label: GHC.Ptr.castPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Mf: // global
           R2 = R2;
           call GHC.Ptr.castPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.601637797 UTC

[section ""data" . GHC.Ptr.plusPtr_closure" {
     GHC.Ptr.plusPtr_closure:
         const GHC.Ptr.plusPtr_info;
 },
 GHC.Ptr.plusPtr_entry() //  [R2, R3]
         { info_tbl: [(c48Mt,
                       label: GHC.Ptr.plusPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Mt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48MF; else goto c48MG;
       c48MF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.plusPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48MG: // global
           I64[Sp - 16] = block_c48Mq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48MM; else goto c48Mr;
       u48MM: // global
           call _c48Mq(R1) args: 0, res: 0, upd: 0;
       c48Mr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Mq() //  [R1]
         { info_tbl: [(c48Mq,
                       label: block_c48Mq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Mq: // global
           I64[Sp] = block_c48Mw_info;
           _s48tt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48tt::I64;
           if (R1 & 7 != 0) goto u48ML; else goto c48Mx;
       u48ML: // global
           call _c48Mw(R1) args: 0, res: 0, upd: 0;
       c48Mx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Mw() //  [R1]
         { info_tbl: [(c48Mw,
                       label: block_c48Mw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Mw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48MK; else goto c48MJ;
       c48MK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48MJ: // global
           _s48tw::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s48tw::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.609826265 UTC

[section ""data" . GHC.Ptr.alignPtr_closure" {
     GHC.Ptr.alignPtr_closure:
         const GHC.Ptr.alignPtr_info;
 },
 GHC.Ptr.alignPtr_entry() //  [R2, R3]
         { info_tbl: [(c48Nd,
                       label: GHC.Ptr.alignPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Nd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c48Nh; else goto c48Ni;
       c48Nh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.alignPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Ni: // global
           I64[Sp - 16] = block_c48Na_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48NQ; else goto c48Nb;
       u48NQ: // global
           call _c48Na(R1) args: 0, res: 0, upd: 0;
       c48Nb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Na() //  [R1]
         { info_tbl: [(c48Na,
                       label: block_c48Na_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Na: // global
           I64[Sp - 8] = block_c48Ng_info;
           _s48tz::P64 = R1;
           _s48tA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s48tA::I64;
           P64[Sp + 8] = _s48tz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48NP; else goto c48Nk;
       u48NP: // global
           call _c48Ng(R1) args: 0, res: 0, upd: 0;
       c48Nk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Ng() //  [R1]
         { info_tbl: [(c48Ng,
                       label: block_c48Ng_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Ng: // global
           _s48tC::I64 = I64[R1 + 7];
           _s48tD::I64 = I64[Sp + 8] % _s48tC::I64;
           if (_s48tD::I64 != 0) goto u48NN; else goto c48NJ;
       u48NN: // global
           I64[Sp] = _s48tD::I64;
           I64[Sp + 16] = _s48tC::I64;
           call _c48Nt() args: 0, res: 0, upd: 0;
       c48NJ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c48Nt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Nt: // global
           Hp = Hp + 16;
           _s48tD::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c48NG; else goto c48NF;
       c48NG: // global
           HpAlloc = 16;
           I64[Sp] = block_c48Ns_info;
           R1 = _s48tD::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c48NF: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = I64[Sp + 8] + (I64[Sp + 16] - _s48tD::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c48Ns() //  [R1]
         { info_tbl: [(c48Ns,
                       label: block_c48Ns_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Ns: // global
           I64[Sp] = R1;
           call _c48Nt() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.621119026 UTC

[section ""data" . GHC.Ptr.minusPtr_closure" {
     GHC.Ptr.minusPtr_closure:
         const GHC.Ptr.minusPtr_info;
 },
 GHC.Ptr.minusPtr_entry() //  [R2, R3]
         { info_tbl: [(c48Ot,
                       label: GHC.Ptr.minusPtr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Ot: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48OF; else goto c48OG;
       c48OF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.minusPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48OG: // global
           I64[Sp - 16] = block_c48Oq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48OM; else goto c48Or;
       u48OM: // global
           call _c48Oq(R1) args: 0, res: 0, upd: 0;
       c48Or: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Oq() //  [R1]
         { info_tbl: [(c48Oq,
                       label: block_c48Oq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Oq: // global
           I64[Sp] = block_c48Ow_info;
           _s48tJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s48tJ::I64;
           if (R1 & 7 != 0) goto u48OL; else goto c48Ox;
       u48OL: // global
           call _c48Ow(R1) args: 0, res: 0, upd: 0;
       c48Ox: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Ow() //  [R1]
         { info_tbl: [(c48Ow,
                       label: block_c48Ow_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Ow: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48OK; else goto c48OJ;
       c48OK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48OJ: // global
           _s48tM::I64 = I64[Sp + 8] - I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s48tM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.629447255 UTC

[section ""data" . GHC.Ptr.nullFunPtr_closure" {
     GHC.Ptr.nullFunPtr_closure:
         const GHC.Ptr.FunPtr_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.631543706 UTC

[section ""data" . GHC.Ptr.castFunPtr1_closure" {
     GHC.Ptr.castFunPtr1_closure:
         const GHC.Ptr.castFunPtr1_info;
 },
 GHC.Ptr.castFunPtr1_entry() //  [R2]
         { info_tbl: [(c48Pb,
                       label: GHC.Ptr.castFunPtr1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Pb: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.636309971 UTC

[section ""data" . GHC.Ptr.castFunPtr_closure" {
     GHC.Ptr.castFunPtr_closure:
         const GHC.Ptr.castFunPtr_info;
 },
 GHC.Ptr.castFunPtr_entry() //  [R2]
         { info_tbl: [(c48Po,
                       label: GHC.Ptr.castFunPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Po: // global
           R2 = R2;
           call GHC.Ptr.castFunPtr1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.639734073 UTC

[section ""data" . GHC.Ptr.castFunPtrToPtr_closure" {
     GHC.Ptr.castFunPtrToPtr_closure:
         const GHC.Ptr.castFunPtrToPtr_info;
 },
 GHC.Ptr.castFunPtrToPtr_entry() //  [R2]
         { info_tbl: [(c48PC,
                       label: GHC.Ptr.castFunPtrToPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48PC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48PG; else goto c48PH;
       c48PG: // global
           R2 = R2;
           R1 = GHC.Ptr.castFunPtrToPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48PH: // global
           I64[Sp - 8] = block_c48Pz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48PL; else goto c48PA;
       u48PL: // global
           call _c48Pz(R1) args: 0, res: 0, upd: 0;
       c48PA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Pz() //  [R1]
         { info_tbl: [(c48Pz,
                       label: block_c48Pz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Pz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48PK; else goto c48PJ;
       c48PK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48PJ: // global
           _s48tQ::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s48tQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.645999741 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowsPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(c48Q5,
                       label: GHC.Ptr.$fShowFunPtr_$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Q5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48Qb; else goto c48Qc;
       c48Qb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Qc: // global
           I64[Sp - 16] = block_c48Q2_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Qh; else goto c48Q3;
       u48Qh: // global
           call _c48Q2(R1) args: 0, res: 0, upd: 0;
       c48Q3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Q2() //  [R1]
         { info_tbl: [(c48Q2,
                       label: block_c48Q2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Q2: // global
           _s48tT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c48Q8_info;
           R3 = _s48tT::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c48Q8() //  [R1, R2]
         { info_tbl: [(c48Q8,
                       label: block_c48Q8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Q8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48Qg; else goto c48Qf;
       c48Qg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48Qf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.654373049 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshow_closure" {
     GHC.Ptr.$fShowFunPtr_$cshow_closure:
         const GHC.Ptr.$fShowFunPtr_$cshow_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshow_entry() //  [R2]
         { info_tbl: [(c48QF,
                       label: GHC.Ptr.$fShowFunPtr_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48QF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48QL; else goto c48QM;
       c48QL: // global
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48QM: // global
           I64[Sp - 8] = block_c48QC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48QR; else goto c48QD;
       u48QR: // global
           call _c48QC(R1) args: 0, res: 0, upd: 0;
       c48QD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48QC() //  [R1]
         { info_tbl: [(c48QC,
                       label: block_c48QC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48QC: // global
           I64[Sp] = block_c48QI_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[R1 + 7];
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c48QI() //  [R1, R2]
         { info_tbl: [(c48QI,
                       label: block_c48QI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48QI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48QQ; else goto c48QP;
       c48QQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48QP: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.662500173 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr1_closure" {
     GHC.Ptr.$fShowFunPtr1_closure:
         const GHC.Ptr.$fShowFunPtr1_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr1_entry() //  [R2, R3]
         { info_tbl: [(c48Rg,
                       label: GHC.Ptr.$fShowFunPtr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Rg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c48Rm; else goto c48Rn;
       c48Rm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Ptr.$fShowFunPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c48Rn: // global
           I64[Sp - 16] = block_c48Rd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u48Rs; else goto c48Re;
       u48Rs: // global
           call _c48Rd(R1) args: 0, res: 0, upd: 0;
       c48Re: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48Rd() //  [R1]
         { info_tbl: [(c48Rd,
                       label: block_c48Rd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Rd: // global
           _s48u6::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c48Rj_info;
           R3 = _s48u6::P64;
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Ptr.$w$cshowsPrec_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c48Rj() //  [R1, R2]
         { info_tbl: [(c48Rj,
                       label: block_c48Rj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Rj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c48Rr; else goto c48Rq;
       c48Rr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c48Rq: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.670792091 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_$cshowList_closure" {
     GHC.Ptr.$fShowFunPtr_$cshowList_closure:
         const GHC.Ptr.$fShowFunPtr_$cshowList_info;
         const 0;
 },
 GHC.Ptr.$fShowFunPtr_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c48RN,
                       label: GHC.Ptr.$fShowFunPtr_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48RN: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Ptr.$fShowFunPtr1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.674148604 UTC

[section ""data" . GHC.Ptr.$fShowFunPtr_closure" {
     GHC.Ptr.$fShowFunPtr_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure+3;
         const GHC.Ptr.$fShowFunPtr_$cshow_closure+1;
         const GHC.Ptr.$fShowFunPtr_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.676227373 UTC

[section ""data" . GHC.Ptr.castPtrToFunPtr_closure" {
     GHC.Ptr.castPtrToFunPtr_closure:
         const GHC.Ptr.castPtrToFunPtr_info;
 },
 GHC.Ptr.castPtrToFunPtr_entry() //  [R2]
         { info_tbl: [(c48S2,
                       label: GHC.Ptr.castPtrToFunPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48S2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c48S6; else goto c48S7;
       c48S6: // global
           R2 = R2;
           R1 = GHC.Ptr.castPtrToFunPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48S7: // global
           I64[Sp - 8] = block_c48RZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u48Sb; else goto c48S0;
       u48Sb: // global
           call _c48RZ(R1) args: 0, res: 0, upd: 0;
       c48S0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c48RZ() //  [R1]
         { info_tbl: [(c48RZ,
                       label: block_c48RZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48RZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48Sa; else goto c48S9;
       c48Sa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c48S9: // global
           _s48ug::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s48ug::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.682290902 UTC

[section ""cstring" . GHC.Ptr.$trModule4_bytes" {
     GHC.Ptr.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.683990809 UTC

[section ""data" . GHC.Ptr.$trModule3_closure" {
     GHC.Ptr.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.685761679 UTC

[section ""cstring" . GHC.Ptr.$trModule2_bytes" {
     GHC.Ptr.$trModule2_bytes:
         I8[] [71,72,67,46,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.687457897 UTC

[section ""data" . GHC.Ptr.$trModule1_closure" {
     GHC.Ptr.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.690003483 UTC

[section ""data" . GHC.Ptr.$trModule_closure" {
     GHC.Ptr.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Ptr.$trModule3_closure+1;
         const GHC.Ptr.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.691607511 UTC

[section ""data" . $krep_r47xK_closure" {
     $krep_r47xK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.693316943 UTC

[section ""data" . $krep1_r47xL_closure" {
     $krep1_r47xL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcAddr#_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.694948837 UTC

[section ""cstring" . GHC.Ptr.$tcPtr2_bytes" {
     GHC.Ptr.$tcPtr2_bytes:
         I8[] [80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.696622754 UTC

[section ""data" . GHC.Ptr.$tcPtr1_closure" {
     GHC.Ptr.$tcPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tcPtr2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.698435585 UTC

[section ""data" . GHC.Ptr.$tcPtr_closure" {
     GHC.Ptr.$tcPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tcPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13939499724423561315;
         const 16316673677148652216;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.700598283 UTC

[section ""data" . $krep2_r47xM_closure" {
     $krep2_r47xM_closure:
         const :_con_info;
         const $krep_r47xK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.702354923 UTC

[section ""data" . $krep3_r47xN_closure" {
     $krep3_r47xN_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcPtr_closure+1;
         const $krep2_r47xM_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.704076484 UTC

[section ""data" . GHC.Ptr.$tc'Ptr1_closure" {
     GHC.Ptr.$tc'Ptr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r47xL_closure+1;
         const $krep3_r47xN_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.706376213 UTC

[section ""cstring" . GHC.Ptr.$tc'Ptr3_bytes" {
     GHC.Ptr.$tc'Ptr3_bytes:
         I8[] [39,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.708043135 UTC

[section ""data" . GHC.Ptr.$tc'Ptr2_closure" {
     GHC.Ptr.$tc'Ptr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tc'Ptr3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.710166373 UTC

[section ""data" . GHC.Ptr.$tc'Ptr_closure" {
     GHC.Ptr.$tc'Ptr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tc'Ptr2_closure+1;
         const GHC.Ptr.$tc'Ptr1_closure+4;
         const 2332306090346040376;
         const 13491728187967991297;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.711967566 UTC

[section ""cstring" . GHC.Ptr.$tcFunPtr2_bytes" {
     GHC.Ptr.$tcFunPtr2_bytes:
         I8[] [70,117,110,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.713602408 UTC

[section ""data" . GHC.Ptr.$tcFunPtr1_closure" {
     GHC.Ptr.$tcFunPtr1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tcFunPtr2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.715252234 UTC

[section ""data" . GHC.Ptr.$tcFunPtr_closure" {
     GHC.Ptr.$tcFunPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tcFunPtr1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 38956960673620606;
         const 4307950889093819770;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.717115121 UTC

[section ""data" . $krep4_r47xO_closure" {
     $krep4_r47xO_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcFunPtr_closure+1;
         const $krep2_r47xM_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.71931408 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr1_closure" {
     GHC.Ptr.$tc'FunPtr1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r47xL_closure+1;
         const $krep4_r47xO_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.72095695 UTC

[section ""cstring" . GHC.Ptr.$tc'FunPtr3_bytes" {
     GHC.Ptr.$tc'FunPtr3_bytes:
         I8[] [39,70,117,110,80,116,114]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.722652755 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr2_closure" {
     GHC.Ptr.$tc'FunPtr2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Ptr.$tc'FunPtr3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.724376971 UTC

[section ""data" . GHC.Ptr.$tc'FunPtr_closure" {
     GHC.Ptr.$tc'FunPtr_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Ptr.$trModule_closure+1;
         const GHC.Ptr.$tc'FunPtr2_closure+1;
         const GHC.Ptr.$tc'FunPtr1_closure+4;
         const 15722333564603238588;
         const 12100865307857439187;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.726680726 UTC

[section ""data" . GHC.Ptr.Ptr_closure" {
     GHC.Ptr.Ptr_closure:
         const GHC.Ptr.Ptr_info;
 },
 GHC.Ptr.Ptr_entry() //  [R2]
         { info_tbl: [(c48SR,
                       label: GHC.Ptr.Ptr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48SR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48SV; else goto c48SU;
       c48SV: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Ptr.Ptr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48SU: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.731120533 UTC

[section ""data" . GHC.Ptr.FunPtr_closure" {
     GHC.Ptr.FunPtr_closure:
         const GHC.Ptr.FunPtr_info;
 },
 GHC.Ptr.FunPtr_entry() //  [R2]
         { info_tbl: [(c48T7,
                       label: GHC.Ptr.FunPtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48T7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c48Tb; else goto c48Ta;
       c48Tb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Ptr.FunPtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c48Ta: // global
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.735069951 UTC

[GHC.Ptr.Ptr_con_entry() //  [R1]
         { info_tbl: [(c48Ti,
                       label: GHC.Ptr.Ptr_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,80,116,114,46,80,116,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Ti: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.738421623 UTC

[GHC.Ptr.FunPtr_con_entry() //  [R1]
         { info_tbl: [(c48Tp,
                       label: GHC.Ptr.FunPtr_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,71,72,67,46,80,116,114,46,70,117,110,80,116,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c48Tp: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:01.74221143 UTC

[section ""relreadonly" . S48vI_srt" {
     S48vI_srt:
         const GHC.Show.intToDigit_closure;
         const GHC.Show.$fShowInteger_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const Numeric.showIntAtBase_closure;
         const Numeric.showHex1_closure;
         const GHC.Ptr.$w$cshowsPrec_closure;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec_closure;
         const GHC.Ptr.$fShowPtr_$cshow_closure;
         const GHC.Ptr.$fShowPtr1_closure;
         const GHC.Ptr.$fShowFunPtr_$cshowsPrec1_closure;
         const GHC.Ptr.$fShowFunPtr_$cshow_closure;
         const GHC.Ptr.$fShowFunPtr1_closure;
 }]

